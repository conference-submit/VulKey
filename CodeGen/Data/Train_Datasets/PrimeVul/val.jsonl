{"source": " String preg_quote(const String& str,\n                   const String& delimiter ) {\n   const char* in_str = str.data();\n   const char* in_str_end = in_str + str.size();\n \n   if (in_str == in_str_end) {\n     return str;\n   }\n \n   char delim_char = 0;\n   bool quote_delim = false;\n   if (!delimiter.empty()) {\n     delim_char = delimiter.charAt(0);\n     quote_delim = true;\n   }\n \n// bug_start\n// bug_end\n   String ret(4 * str.size() + 1, ReserveString);\n   char* out_str = ret.mutableData();\n \n   const char* p;\n   char* q;\n   for (p = in_str, q = out_str; p != in_str_end; p++) {\n     char c = *p;\n     switch (c) {\n     case '.': case '\\\\': case '+': case '*': case '?':\n     case '[': case '^':  case ']': case '$': case '(':\n     case ')': case '{':  case '}': case '=': case '!':\n     case '>': case '<':  case '|': case ':': case '-':\n     case '#':\n       *q++ = '\\\\';\n       *q++ = c;\n       break;\n \n     case '\\0':\n       *q++ = '\\\\';\n       *q++ = '0';\n       *q++ = '0';\n       *q++ = '0';\n       break;\n \n     default:\n       if (quote_delim && c == delim_char)\n         *q++ = '\\\\';\n       *q++ = c;\n       break;\n     }\n   }\n   *q = '\\0';\n \n   return ret.setSize(q - out_str);\n }\n \n", "target": "// fix_start\n  static_assert(\n    (StringData::MaxSize * 4 + 1) < std::numeric_limits<int64_t>::max()\n  );\n// fix_end\n", "cwe": "CWE-190", "cwe_name": "Integer Overflow or Wraparound", "cve": "CVE-2020-1918", "cve_desc": "In-memory file operations (ie: using fopen on a data URI) did not properly restrict negative seeking, allowing for the reading of memory prior to the in-memory buffer. This issue affects HHVM versions prior to 4.56.3, all versions between 4.57.0 and 4.80.1, all versions between 4.81.0 and 4.93.1, and versions 4.94.0, 4.95.0, 4.96.0, 4.97.0, 4.98.0.", "project": "hhvm", "idx": 194999}
{"source": " static int xbuf_format_converter(char **outbuf, const char *fmt, va_list ap)\n {\n   register char *s = nullptr;\n   char *q;\n   int s_len;\n \n   register int min_width = 0;\n   int precision = 0;\n   enum {\n     LEFT, RIGHT\n   } adjust;\n   char pad_char;\n   char prefix_char;\n \n   double fp_num;\n   wide_int i_num = (wide_int) 0;\n   u_wide_int ui_num;\n \n   char num_buf[NUM_BUF_SIZE];\n   char char_buf[2];\n \n #ifdef HAVE_LOCALE_H\n   struct lconv *lconv = nullptr;\n #endif\n \n   length_modifier_e modifier;\n   boolean_e alternate_form;\n   boolean_e print_sign;\n   boolean_e print_blank;\n   boolean_e adjust_precision;\n   boolean_e adjust_width;\n   int is_negative;\n \n   int size = 240;\n   char *result = (char *)malloc(size);\n   int outpos = 0;\n \n   while (*fmt) {\n     if (*fmt != '%') {\n       appendchar(&result, &outpos, &size, *fmt);\n     } else {\n       adjust = RIGHT;\n       alternate_form = print_sign = print_blank = NO;\n       pad_char = ' ';\n       prefix_char = NUL;\n \n       fmt++;\n \n       if (isascii((int)*fmt) && !islower((int)*fmt)) {\n         for (;; fmt++) {\n           if (*fmt == '-')\n             adjust = LEFT;\n           else if (*fmt == '+')\n             print_sign = YES;\n           else if (*fmt == '#')\n             alternate_form = YES;\n           else if (*fmt == ' ')\n             print_blank = YES;\n           else if (*fmt == '0')\n             pad_char = '0';\n           else\n             break;\n         }\n \n         if (isdigit((int)*fmt)) {\n           STR_TO_DEC(fmt, min_width);\n           adjust_width = YES;\n         } else if (*fmt == '*') {\n           min_width = va_arg(ap, int);\n           fmt++;\n           adjust_width = YES;\n           if (min_width < 0) {\n             adjust = LEFT;\n             min_width = -min_width;\n           }\n         } else\n           adjust_width = NO;\n \n         if (*fmt == '.') {\n           adjust_precision = YES;\n           fmt++;\n           if (isdigit((int)*fmt)) {\n             STR_TO_DEC(fmt, precision);\n           } else if (*fmt == '*') {\n             precision = va_arg(ap, int);\n             fmt++;\n             if (precision < 0)\n               precision = 0;\n           } else\n             precision = 0;\n         } else\n           adjust_precision = NO;\n       } else\n         adjust_precision = adjust_width = NO;\n \n       switch (*fmt) {\n         case 'L':\n           fmt++;\n           modifier = LM_LONG_DOUBLE;\n           break;\n         case 'I':\n           fmt++;\n #if SIZEOF_LONG_LONG\n           if (*fmt == '6' && *(fmt+1) == '4') {\n             fmt += 2;\n             modifier = LM_LONG_LONG;\n           } else\n #endif\n             if (*fmt == '3' && *(fmt+1) == '2') {\n               fmt += 2;\n               modifier = LM_LONG;\n             } else {\n #ifdef _WIN64\n               modifier = LM_LONG_LONG;\n #else\n               modifier = LM_LONG;\n #endif\n             }\n           break;\n         case 'l':\n           fmt++;\n #if SIZEOF_LONG_LONG\n           if (*fmt == 'l') {\n             fmt++;\n             modifier = LM_LONG_LONG;\n           } else\n #endif\n             modifier = LM_LONG;\n           break;\n         case 'z':\n           fmt++;\n           modifier = LM_SIZE_T;\n           break;\n         case 'j':\n           fmt++;\n #if SIZEOF_INTMAX_T\n           modifier = LM_INTMAX_T;\n #else\n           modifier = LM_SIZE_T;\n #endif\n           break;\n         case 't':\n           fmt++;\n #if SIZEOF_PTRDIFF_T\n           modifier = LM_PTRDIFF_T;\n #else\n           modifier = LM_SIZE_T;\n #endif\n           break;\n         case 'h':\n           fmt++;\n           if (*fmt == 'h') {\n             fmt++;\n           }\n         default:\n           modifier = LM_STD;\n           break;\n       }\n \n       switch (*fmt) {\n         case 'u':\n           switch(modifier) {\n             default:\n               i_num = (wide_int) va_arg(ap, unsigned int);\n               break;\n             case LM_LONG_DOUBLE:\n               goto fmt_error;\n             case LM_LONG:\n               i_num = (wide_int) va_arg(ap, unsigned long int);\n               break;\n             case LM_SIZE_T:\n               i_num = (wide_int) va_arg(ap, size_t);\n               break;\n #if SIZEOF_LONG_LONG\n             case LM_LONG_LONG:\n               i_num = (wide_int) va_arg(ap, u_wide_int);\n               break;\n #endif\n #if SIZEOF_INTMAX_T\n             case LM_INTMAX_T:\n               i_num = (wide_int) va_arg(ap, uintmax_t);\n               break;\n #endif\n #if SIZEOF_PTRDIFF_T\n             case LM_PTRDIFF_T:\n               i_num = (wide_int) va_arg(ap, ptrdiff_t);\n               break;\n #endif\n           }\n         case 'd':\n         case 'i':\n           if ((*fmt) != 'u') {\n             switch(modifier) {\n               default:\n                 i_num = (wide_int) va_arg(ap, int);\n                 break;\n               case LM_LONG_DOUBLE:\n                 goto fmt_error;\n               case LM_LONG:\n                 i_num = (wide_int) va_arg(ap, long int);\n                 break;\n               case LM_SIZE_T:\n #if SIZEOF_SSIZE_T\n                 i_num = (wide_int) va_arg(ap, ssize_t);\n #else\n                 i_num = (wide_int) va_arg(ap, size_t);\n #endif\n                 break;\n #if SIZEOF_LONG_LONG\n               case LM_LONG_LONG:\n                 i_num = (wide_int) va_arg(ap, wide_int);\n                 break;\n #endif\n #if SIZEOF_INTMAX_T\n               case LM_INTMAX_T:\n                 i_num = (wide_int) va_arg(ap, intmax_t);\n                 break;\n #endif\n #if SIZEOF_PTRDIFF_T\n               case LM_PTRDIFF_T:\n                 i_num = (wide_int) va_arg(ap, ptrdiff_t);\n                 break;\n #endif\n             }\n           }\n           s = ap_php_conv_10(i_num, (*fmt) == 'u', &is_negative,\n                 &num_buf[NUM_BUF_SIZE], &s_len);\n           FIX_PRECISION(adjust_precision, precision, s, s_len);\n \n           if (*fmt != 'u') {\n             if (is_negative)\n               prefix_char = '-';\n             else if (print_sign)\n               prefix_char = '+';\n             else if (print_blank)\n               prefix_char = ' ';\n           }\n           break;\n \n \n         case 'o':\n           switch(modifier) {\n             default:\n               ui_num = (u_wide_int) va_arg(ap, unsigned int);\n               break;\n             case LM_LONG_DOUBLE:\n               goto fmt_error;\n             case LM_LONG:\n               ui_num = (u_wide_int) va_arg(ap, unsigned long int);\n               break;\n             case LM_SIZE_T:\n               ui_num = (u_wide_int) va_arg(ap, size_t);\n               break;\n #if SIZEOF_LONG_LONG\n             case LM_LONG_LONG:\n               ui_num = (u_wide_int) va_arg(ap, u_wide_int);\n               break;\n #endif\n #if SIZEOF_INTMAX_T\n             case LM_INTMAX_T:\n               ui_num = (u_wide_int) va_arg(ap, uintmax_t);\n               break;\n #endif\n #if SIZEOF_PTRDIFF_T\n             case LM_PTRDIFF_T:\n               ui_num = (u_wide_int) va_arg(ap, ptrdiff_t);\n               break;\n #endif\n           }\n           s = ap_php_conv_p2(ui_num, 3, *fmt,\n                 &num_buf[NUM_BUF_SIZE], &s_len);\n           FIX_PRECISION(adjust_precision, precision, s, s_len);\n           if (alternate_form && *s != '0') {\n             *--s = '0';\n             s_len++;\n           }\n           break;\n \n \n         case 'x':\n         case 'X':\n           switch(modifier) {\n             default:\n               ui_num = (u_wide_int) va_arg(ap, unsigned int);\n               break;\n             case LM_LONG_DOUBLE:\n               goto fmt_error;\n             case LM_LONG:\n               ui_num = (u_wide_int) va_arg(ap, unsigned long int);\n               break;\n             case LM_SIZE_T:\n               ui_num = (u_wide_int) va_arg(ap, size_t);\n               break;\n #if SIZEOF_LONG_LONG\n             case LM_LONG_LONG:\n               ui_num = (u_wide_int) va_arg(ap, u_wide_int);\n               break;\n #endif\n #if SIZEOF_INTMAX_T\n             case LM_INTMAX_T:\n               ui_num = (u_wide_int) va_arg(ap, uintmax_t);\n               break;\n #endif\n #if SIZEOF_PTRDIFF_T\n             case LM_PTRDIFF_T:\n               ui_num = (u_wide_int) va_arg(ap, ptrdiff_t);\n               break;\n #endif\n           }\n           s = ap_php_conv_p2(ui_num, 4, *fmt,\n                 &num_buf[NUM_BUF_SIZE], &s_len);\n           FIX_PRECISION(adjust_precision, precision, s, s_len);\n           if (alternate_form && i_num != 0) {\n             *--s = *fmt;\n             *--s = '0';\n             s_len += 2;\n           }\n           break;\n \n \n         case 's':\n         case 'v':\n           s = va_arg(ap, char *);\n           if (s != nullptr) {\n             s_len = strlen(s);\n             if (adjust_precision && precision < s_len)\n               s_len = precision;\n           } else {\n             s = const_cast<char*>(s_null);\n             s_len = S_NULL_LEN;\n           }\n           pad_char = ' ';\n           break;\n \n \n         case 'f':\n         case 'F':\n         case 'e':\n         case 'E':\n           switch(modifier) {\n             case LM_LONG_DOUBLE:\n               fp_num = (double) va_arg(ap, long double);\n               break;\n             case LM_STD:\n               fp_num = va_arg(ap, double);\n               break;\n             default:\n               goto fmt_error;\n           }\n \n           if (std::isnan(fp_num)) {\n             s = const_cast<char*>(\"nan\");\n             s_len = 3;\n           } else if (std::isinf(fp_num)) {\n             s = const_cast<char*>(\"inf\");\n             s_len = 3;\n           } else {\n #ifdef HAVE_LOCALE_H\n             if (!lconv) {\n               lconv = localeconv();\n             }\n #endif\n             s = php_conv_fp((*fmt == 'f')?'F':*fmt, fp_num, alternate_form,\n              (adjust_precision == NO) ? FLOAT_DIGITS : precision,\n              (*fmt == 'f')?LCONV_DECIMAL_POINT:'.',\n                   &is_negative, &num_buf[1], &s_len);\n             if (is_negative)\n               prefix_char = '-';\n             else if (print_sign)\n               prefix_char = '+';\n             else if (print_blank)\n               prefix_char = ' ';\n           }\n           break;\n \n \n         case 'g':\n         case 'k':\n         case 'G':\n         case 'H':\n           switch(modifier) {\n             case LM_LONG_DOUBLE:\n               fp_num = (double) va_arg(ap, long double);\n               break;\n             case LM_STD:\n               fp_num = va_arg(ap, double);\n               break;\n             default:\n               goto fmt_error;\n           }\n \n           if (std::isnan(fp_num)) {\n              s = const_cast<char*>(\"NAN\");\n              s_len = 3;\n              break;\n            } else if (std::isinf(fp_num)) {\n              if (fp_num > 0) {\n                s = const_cast<char*>(\"INF\");\n                s_len = 3;\n              } else {\n                s = const_cast<char*>(\"-INF\");\n                s_len = 4;\n              }\n              break;\n            }\n \n           if (adjust_precision == NO)\n             precision = FLOAT_DIGITS;\n           else if (precision == 0)\n             precision = 1;\n #ifdef HAVE_LOCALE_H\n           if (!lconv) {\n             lconv = localeconv();\n           }\n #endif\n           s = php_gcvt(fp_num, precision,\n                        (*fmt=='H' || *fmt == 'k') ? '.' : LCONV_DECIMAL_POINT,\n                        (*fmt == 'G' || *fmt == 'H')?'E':'e', &num_buf[1]);\n           if (*s == '-')\n             prefix_char = *s++;\n           else if (print_sign)\n             prefix_char = '+';\n           else if (print_blank)\n             prefix_char = ' ';\n \n           s_len = strlen(s);\n \n           if (alternate_form && (q = strchr(s, '.')) == nullptr)\n             s[s_len++] = '.';\n           break;\n \n \n         case 'c':\n           char_buf[0] = (char) (va_arg(ap, int));\n           s = &char_buf[0];\n           s_len = 1;\n           pad_char = ' ';\n           break;\n \n \n         case '%':\n           char_buf[0] = '%';\n           s = &char_buf[0];\n           s_len = 1;\n           pad_char = ' ';\n           break;\n \n \n         case 'n':\n           *(va_arg(ap, int *)) = outpos;\n           goto skip_output;\n \n         case 'p':\n           if (sizeof(char *) <= sizeof(u_wide_int)) {\n             ui_num = (u_wide_int)((size_t) va_arg(ap, char *));\n             s = ap_php_conv_p2(ui_num, 4, 'x',\n                 &num_buf[NUM_BUF_SIZE], &s_len);\n             if (ui_num != 0) {\n               *--s = 'x';\n               *--s = '0';\n               s_len += 2;\n             }\n           } else {\n             s = const_cast<char*>(\"%p\");\n             s_len = 2;\n           }\n           pad_char = ' ';\n           break;\n \n \n         case NUL:\n           continue;\n \n \n fmt_error:\n         throw Exception(\"Illegal length modifier specified '%c'\", *fmt);\n \n         default:\n           char_buf[0] = '%';\n           char_buf[1] = *fmt;\n           s = char_buf;\n           s_len = 2;\n           pad_char = ' ';\n           break;\n       }\n \n       if (prefix_char != NUL) {\n         *--s = prefix_char;\n         s_len++;\n       }\n       if (adjust_width && adjust == RIGHT && min_width > s_len) {\n         if (pad_char == '0' && prefix_char != NUL) {\n           appendchar(&result, &outpos, &size, *s);\n           s++;\n           s_len--;\n           min_width--;\n         }\n         for (int i = 0; i < min_width - s_len; i++) {\n           appendchar(&result, &outpos, &size, pad_char);\n         }\n       }\n       appendsimplestring(&result, &outpos, &size, s, s_len);\n \n       if (adjust_width && adjust == LEFT && min_width > s_len) {\n         for (int i = 0; i < min_width - s_len; i++) {\n           appendchar(&result, &outpos, &size, pad_char);\n         }\n       }\n     }\n skip_output:\n     fmt++;\n   }\n// bug_start\n  result[outpos] = NUL;\n// bug_end\n   *outbuf = result;\n// bug_start\n  return outpos;\n// bug_end\n }\n \n", "target": "// fix_start\n  appendchar(&result, &outpos, &size, NUL);\n// fix_end\n// fix_start\n  return outpos - 1;\n// fix_end\n", "cwe": "CWE-190", "cwe_name": "Integer Overflow or Wraparound", "cve": "CVE-2020-1918", "cve_desc": "In-memory file operations (ie: using fopen on a data URI) did not properly restrict negative seeking, allowing for the reading of memory prior to the in-memory buffer. This issue affects HHVM versions prior to 4.56.3, all versions between 4.57.0 and 4.80.1, all versions between 4.81.0 and 4.93.1, and versions 4.94.0, 4.95.0, 4.96.0, 4.97.0, 4.98.0.", "project": "hhvm", "idx": 195007}
{"source": " bool CPlayListASX::LoadData(std::istream& stream)\n {\n   CLog::Log(LOGINFO, \"Parsing ASX\");\n \n   if(stream.peek() == '[')\n   {\n     return LoadAsxIniInfo(stream);\n   }\n   else\n   {\n// bug_start\n// bug_end\n     CXBMCTinyXML xmlDoc;\n// bug_start\n    stream >> xmlDoc;\n// bug_end\n \n     if (xmlDoc.Error())\n     {\n       CLog::Log(LOGERROR, \"Unable to parse ASX info Error: {}\", xmlDoc.ErrorDesc());\n       return false;\n     }\n \n     TiXmlElement *pRootElement = xmlDoc.RootElement();\n// bug_start\n// bug_end\n \n     TiXmlNode *pNode = pRootElement;\n     TiXmlNode *pChild = NULL;\n     std::string value;\n     value = pNode->Value();\n     StringUtils::ToLower(value);\n     pNode->SetValue(value);\n     while(pNode)\n     {\n       pChild = pNode->IterateChildren(pChild);\n       if(pChild)\n       {\n         if (pChild->Type() == TiXmlNode::TINYXML_ELEMENT)\n         {\n           value = pChild->Value();\n           StringUtils::ToLower(value);\n           pChild->SetValue(value);\n \n           TiXmlAttribute* pAttr = pChild->ToElement()->FirstAttribute();\n           while(pAttr)\n           {\n             value = pAttr->Name();\n             StringUtils::ToLower(value);\n             pAttr->SetName(value);\n             pAttr = pAttr->Next();\n           }\n         }\n \n         pNode = pChild;\n         pChild = NULL;\n         continue;\n       }\n \n       pChild = pNode;\n       pNode = pNode->Parent();\n     }\n     std::string roottitle;\n     TiXmlElement *pElement = pRootElement->FirstChildElement();\n     while (pElement)\n     {\n       value = pElement->Value();\n       if (value == \"title\" && !pElement->NoChildren())\n       {\n         roottitle = pElement->FirstChild()->ValueStr();\n       }\n       else if (value == \"entry\")\n       {\n         std::string title(roottitle);\n \n         TiXmlElement *pRef = pElement->FirstChildElement(\"ref\");\n         TiXmlElement *pTitle = pElement->FirstChildElement(\"title\");\n \n         if(pTitle && !pTitle->NoChildren())\n           title = pTitle->FirstChild()->ValueStr();\n \n         while (pRef)\n         {\n           value = XMLUtils::GetAttribute(pRef, \"href\");\n           if (!value.empty())\n           {\n             if(title.empty())\n               title = value;\n \n             CLog::Log(LOGINFO, \"Adding element {}, {}\", title, value);\n             CFileItemPtr newItem(new CFileItem(title));\n             newItem->SetPath(value);\n             Add(newItem);\n           }\n           pRef = pRef->NextSiblingElement(\"ref\");\n         }\n       }\n       else if (value == \"entryref\")\n       {\n         value = XMLUtils::GetAttribute(pElement, \"href\");\n         if (!value.empty())\n         {\n           std::unique_ptr<CPlayList> playlist(CPlayListFactory::Create(value));\n           if (nullptr != playlist)\n             if (playlist->Load(value))\n               Add(*playlist);\n         }\n       }\n       pElement = pElement->NextSiblingElement();\n     }\n   }\n \n   return true;\n }\n \n", "target": "// fix_start\n    std::string asxstream(std::istreambuf_iterator<char>(stream), {});\n// fix_end\n// fix_start\n    xmlDoc.Parse(asxstream, TIXML_DEFAULT_ENCODING);\n// fix_end\n// fix_start\n\n    if (!pRootElement)\n      return false;\n// fix_end\n", "cwe": "CWE-120", "cwe_name": "Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')", "cve": "CVE-2021-42917", "cve_desc": "Buffer overflow vulnerability in Kodi xbmc up to 19.0, allows attackers to cause a denial of service due to improper length of values passed to istream.", "project": "xbmc", "idx": 195020}
{"source": " TfLiteStatus EvalFloat(TfLiteContext* context, TfLiteNode* node,\n                        TfLiteFullyConnectedParams* params, OpData* data,\n                        const TfLiteTensor* input, const TfLiteTensor* filter,\n                        const TfLiteTensor* bias, TfLiteTensor* output) {\n   float output_activation_min, output_activation_max;\n   CalculateActivationRange(params->activation, &output_activation_min,\n                            &output_activation_max);\n   if (kernel_type == kReference) {\n     FullyConnectedParams op_params;\n     op_params.float_activation_min = output_activation_min;\n     op_params.float_activation_max = output_activation_max;\n     if (filter->sparsity != nullptr) {\n       const auto& sparsity = *filter->sparsity;\n       reference_ops::FullyConnectedSparseWeight(\n           sparsity, op_params, GetTensorShape(input),\n           GetTensorData<float>(input), GetTensorShape(filter),\n           GetTensorData<float>(filter), GetTensorShape(bias),\n           GetTensorData<float>(bias), GetTensorShape(output),\n           GetTensorData<float>(output));\n     } else {\n       reference_ops::FullyConnected(\n           op_params, GetTensorShape(input), GetTensorData<float>(input),\n           GetTensorShape(filter), GetTensorData<float>(filter),\n           GetTensorShape(bias), GetTensorData<float>(bias),\n           GetTensorShape(output), GetTensorData<float>(output));\n     }\n   } else if (kernel_type == kLegacyPie) {\n     return EvalPie(context, node, params, data, input, filter, bias, output);\n   } else {\n     FullyConnectedParams op_params;\n     op_params.float_activation_min = output_activation_min;\n     op_params.float_activation_max = output_activation_max;\n     if (filter->sparsity != nullptr) {\n       const auto& sparsity = *filter->sparsity;\n       if (!SupportedSparsityFormat(sparsity)) {\n         TF_LITE_KERNEL_LOG(context,\n                            \"Unsupported sparse fully-connected weight format.\");\n         return kTfLiteError;\n       }\n// bug_start\n// bug_end\n \n       if (sparsity.dim_metadata_size == kDimMetadataSizeRandomSparse) {\n         optimized_ops::FullyConnectedSparseWeight(\n// bug_start\n            sparsity, op_params, GetTensorShape(input),\n            GetTensorData<float>(input), GetTensorShape(filter),\n            GetTensorData<float>(filter), GetTensorShape(bias),\n            GetTensorData<float>(bias), GetTensorShape(output),\n            GetTensorData<float>(output));\n// bug_end\n       } else if (sparsity.dim_metadata_size == kDimMetadataSizeBlockSparse &&\n                  sparsity.dim_metadata[2].dense_size == 4) {\n         optimized_ops::FullyConnectedSparseWeight1x4(\n// bug_start\n            sparsity, op_params, GetTensorShape(input),\n            GetTensorData<float>(input), GetTensorShape(filter),\n            GetTensorData<float>(filter), GetTensorShape(bias),\n            GetTensorData<float>(bias), GetTensorShape(output),\n            GetTensorData<float>(output),\n// bug_end\n             CpuBackendContext::GetFromContext(context));\n       } else {\n         TF_LITE_KERNEL_LOG(context,\n                            \"Unsupported sparse fully-connected weight format.\");\n         return kTfLiteError;\n       }\n \n     } else {\n       op_params.lhs_cacheable = IsConstantTensor(filter);\n       op_params.rhs_cacheable = IsConstantTensor(input);\n       optimized_ops::FullyConnected(\n           op_params, GetTensorShape(input), GetTensorData<float>(input),\n           GetTensorShape(filter), GetTensorData<float>(filter),\n           GetTensorShape(bias), GetTensorData<float>(bias),\n           GetTensorShape(output), GetTensorData<float>(output),\n           CpuBackendContext::GetFromContext(context));\n     }\n   }\n \n   return kTfLiteOk;\n }\n \n", "target": "// fix_start\n      const auto& input_shape = GetTensorShape(input);\n      const auto& filter_shape = GetTensorShape(filter);\n      const auto& output_shape = GetTensorShape(output);\n      const auto& bias_shape = GetTensorShape(bias);\n      if (!VerifySparsity(filter_shape, input_shape, output_shape, &sparsity)) {\n        TF_LITE_KERNEL_LOG(context, \"Invalid sparse fully-connected format.\");\n        return kTfLiteError;\n      }\n// fix_end\n// fix_start\n            sparsity, op_params,\n            input_shape, GetTensorData<float>(input),\n            filter_shape, GetTensorData<float>(filter),\n            bias_shape, GetTensorData<float>(bias),\n            output_shape, GetTensorData<float>(output));\n// fix_end\n// fix_start\n            sparsity, op_params,\n            input_shape, GetTensorData<float>(input),\n            filter_shape, GetTensorData<float>(filter),\n            bias_shape, GetTensorData<float>(bias),\n            output_shape, GetTensorData<float>(output),\n// fix_end\n", "cwe": "CWE-787", "cwe_name": "Out-of-bounds Write", "cve": "CVE-2022-23561", "cve_desc": "Tensorflow is an Open Source Machine Learning Framework. An attacker can craft a TFLite model that would cause a write outside of bounds of an array in TFLite. In fact, the attacker can override the linked list used by the memory allocator. This can be leveraged for an arbitrary write primitive under certain conditions. The fix will be included in TensorFlow 2.8.0. We will also cherrypick this commit on TensorFlow 2.7.1, TensorFlow 2.6.3, and TensorFlow 2.5.3, as these are also affected and still in supported range.", "project": "tensorflow", "idx": 195042}
{"source": " uint8_t ethereum_extractThorchainData(const EthereumSignTx *msg,\n                                           char *buffer) {\n   uint16_t offset = 4 + (5 * 32);\n   int16_t len = msg->data_length - offset;\n// bug_start\n  if (msg->has_data_length && len > 0) {\n// bug_end\n     memcpy(buffer, msg->data_initial_chunk.bytes + offset, len);\n// bug_start\n    return len < 256 ? (uint8_t)len : 0;\n// bug_end\n   }\n   return 0;\n }\n \n", "target": "// fix_start\n  if (msg->has_data_length && len > 0 && len < 256) {\n// fix_end\n// fix_start\n    return (uint8_t)len;\n// fix_end\n", "cwe": "CWE-787", "cwe_name": "Out-of-bounds Write", "cve": "CVE-2021-31616", "cve_desc": "Insufficient length checks in the ShapeShift KeepKey hardware wallet firmware before 7.1.0 allow a stack buffer overflow via crafted messages. The overflow in ethereum_extractThorchainSwapData() in ethereum.c can circumvent stack protections and lead to code execution. The vulnerable interface is reachable remotely over WebUSB.", "project": "keepkey-firmware", "idx": 195057}
{"source": " static int stszin(int size)\n {\n     int cnt;\n     uint32_t ofs;\n \n     u32in();\n     u32in();\n     mp4config.frame.ents = u32in();\n// bug_start\n// bug_end\n     mp4config.frame.data = malloc(sizeof(*mp4config.frame.data)\n                                   * (mp4config.frame.ents + 1));\n \n     if (!mp4config.frame.data)\n         return ERR_FAIL;\n \n     ofs = 0;\n     mp4config.frame.data[0] = ofs;\n     for (cnt = 0; cnt < mp4config.frame.ents; cnt++)\n     {\n         uint32_t fsize = u32in();\n \n         ofs += fsize;\n         if (mp4config.frame.maxsize < fsize)\n             mp4config.frame.maxsize = fsize;\n \n         mp4config.frame.data[cnt + 1] = ofs;\n \n         if (ofs < mp4config.frame.data[cnt])\n             return ERR_FAIL;\n     }\n \n     return size;\n }\n \n", "target": "// fix_start\n\n    if (!(mp4config.frame.ents + 1))\n        return ERR_FAIL;\n\n// fix_end\n", "cwe": "CWE-787", "cwe_name": "Out-of-bounds Write", "cve": "CVE-2021-32272", "cve_desc": "An issue was discovered in faad2 before 2.10.0. A heap-buffer-overflow exists in the function stszin located in mp4read.c. It allows an attacker to cause Code Execution.", "project": "faad2", "idx": 195084}
{"source": " mrb_proc_copy(mrb_state *mrb, struct RProc *a, struct RProc *b)\n {\n   if (a->body.irep) {\n     return;\n   }\n// bug_start\n// bug_end\n   a->flags = b->flags;\n   a->body = b->body;\n   a->upper = b->upper;\n// bug_start\n  if (!MRB_PROC_CFUNC_P(a) && a->body.irep) {\n    mrb_irep_incref(mrb, (mrb_irep*)a->body.irep);\n  }\n// bug_end\n   a->e.env = b->e.env;\n }\n \n", "target": "// fix_start\n  if (!MRB_PROC_CFUNC_P(b) && b->body.irep) {\n    mrb_irep_incref(mrb, (mrb_irep*)b->body.irep);\n  }\n// fix_end\n// fix_start\n// fix_end\n", "cwe": "CWE-122", "cwe_name": "Heap-based Buffer Overflow", "cve": "CVE-2022-0080", "cve_desc": "mruby is vulnerable to Heap-based Buffer Overflow", "project": "mruby", "idx": 195217}
{"source": " int64_t TensorByteSize(const TensorProto& t) {\n// bug_start\n  int64_t num_elems = TensorShape(t.tensor_shape()).num_elements();\n// bug_end\n   return num_elems < 0 ? -1 : num_elems * DataTypeSize(t.dtype());\n }\n \n", "target": "// fix_start\n  int64_t num_elems = PartialTensorShape(t.tensor_shape()).num_elements();\n// fix_end\n", "cwe": "CWE-617", "cwe_name": "Reachable Assertion", "cve": "CVE-2022-23582", "cve_desc": "Tensorflow is an Open Source Machine Learning Framework. A malicious user can cause a denial of service by altering a `SavedModel` such that `TensorByteSize` would trigger `CHECK` failures. `TensorShape` constructor throws a `CHECK`-fail if shape is partial or has a number of elements that would overflow the size of an `int`. The `PartialTensorShape` constructor instead does not cause a `CHECK`-abort if the shape is partial, which is exactly what this function needs to be able to return `-1`. The fix will be included in TensorFlow 2.8.0. We will also cherrypick this commit on TensorFlow 2.7.1, TensorFlow 2.6.3, and TensorFlow 2.5.3, as these are also affected and still in supported range.", "project": "tensorflow", "idx": 195244}
{"source": " TfLiteStatus Prepare(TfLiteContext* context, TfLiteNode* node) {\n   auto* params =\n       reinterpret_cast<TfLiteDepthwiseConvParams*>(node->builtin_data);\n   OpData* data = reinterpret_cast<OpData*>(node->user_data);\n \n   bool has_bias = NumInputs(node) == 3;\n \n   TF_LITE_ENSURE(context, has_bias || NumInputs(node) == 2);\n   const TfLiteTensor* input;\n   TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, kInputTensor, &input));\n   const TfLiteTensor* filter;\n   TF_LITE_ENSURE_OK(context,\n                     GetInputSafe(context, node, kFilterTensor, &filter));\n   const TfLiteTensor* bias = nullptr;\n \n   TF_LITE_ENSURE_EQ(context, NumOutputs(node), 1);\n   TfLiteTensor* output;\n   TF_LITE_ENSURE_OK(context,\n                     GetOutputSafe(context, node, kOutputTensor, &output));\n \n   TF_LITE_ENSURE_EQ(context, NumDimensions(input), 4);\n   TF_LITE_ENSURE_EQ(context, NumDimensions(filter), 4);\n// bug_start\n// bug_end\n \n   const TfLiteType data_type = input->type;\n \n   const TfLiteType filter_type = filter->type;\n   const bool is_hybrid =\n       data_type == kTfLiteFloat32 && filter_type == kTfLiteInt8;\n   TF_LITE_ENSURE(context,\n                  data_type == kTfLiteFloat32 || data_type == kTfLiteUInt8 ||\n                      data_type == kTfLiteInt8 || data_type == kTfLiteInt16);\n   TF_LITE_ENSURE_TYPES_EQ(context, output->type, data_type);\n   if (!is_hybrid) {\n     TF_LITE_ENSURE(context,\n                    filter->type == data_type || data_type == kTfLiteInt16);\n   }\n \n   if (data_type == kTfLiteInt16) {\n     TF_LITE_ENSURE_EQ(context, input->params.zero_point, 0);\n     TF_LITE_ENSURE_EQ(context, output->params.zero_point, 0);\n   }\n \n   TF_LITE_ENSURE_EQ(context, SizeOfDimension(filter, 0), 1);\n \n   if (has_bias) {\n     TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, kBiasTensor, &bias));\n     if (data_type == kTfLiteUInt8 || data_type == kTfLiteInt8) {\n       TF_LITE_ENSURE_TYPES_EQ(context, bias->type, kTfLiteInt32);\n       TF_LITE_ENSURE_EQ(context, bias->params.zero_point, 0);\n     } else if (data_type == kTfLiteInt16) {\n       TF_LITE_ENSURE_TYPES_EQ(context, bias->type, kTfLiteInt64);\n       TF_LITE_ENSURE_EQ(context, bias->params.zero_point, 0);\n     } else {\n       TF_LITE_ENSURE_TYPES_EQ(context, bias->type, data_type);\n     }\n     TF_LITE_ENSURE_EQ(context, NumDimensions(bias), 1);\n     TF_LITE_ENSURE_EQ(context, SizeOfDimension(filter, 3),\n                       SizeOfDimension(bias, 0));\n   }\n \n   int channels_out = SizeOfDimension(filter, 3);\n   int width = SizeOfDimension(input, 2);\n   int height = SizeOfDimension(input, 1);\n   int filter_width = SizeOfDimension(filter, 2);\n   int filter_height = SizeOfDimension(filter, 1);\n   int batches = SizeOfDimension(input, 0);\n \n   auto padding = params->padding;\n   int out_width, out_height;\n \n   data->padding = ComputePaddingHeightWidth(\n       params->stride_height, params->stride_width,\n       params->dilation_height_factor, params->dilation_width_factor, height,\n       width, filter_height, filter_width, padding, &out_height, &out_width);\n \n   if (data_type != kTfLiteFloat32) {\n     TF_LITE_ENSURE_EQ(context, filter->quantization.type,\n                       kTfLiteAffineQuantization);\n     TF_LITE_ENSURE(context, filter->quantization.type != kTfLiteNoQuantization);\n     const auto* affine_quantization =\n         reinterpret_cast<TfLiteAffineQuantization*>(\n             filter->quantization.params);\n     TF_LITE_ENSURE(context, affine_quantization);\n     TF_LITE_ENSURE(context, affine_quantization->scale);\n     TF_LITE_ENSURE(context, (affine_quantization->scale->size == 1 ||\n                              affine_quantization->scale->size == channels_out));\n \n     data->per_channel_output_multiplier.resize(channels_out);\n     data->per_channel_output_shift.resize(channels_out);\n     TF_LITE_ENSURE_STATUS(tflite::PopulateConvolutionQuantizationParams(\n         context, input, filter, bias, output, params->activation,\n         &data->output_multiplier, &data->output_shift,\n         &data->output_activation_min, &data->output_activation_max,\n         data->per_channel_output_multiplier.data(),\n         data->per_channel_output_shift.data(), channels_out));\n   }\n \n   if (is_hybrid) {\n     TF_LITE_ENSURE(context, filter->quantization.type != kTfLiteNoQuantization);\n     const auto* affine_quantization =\n         reinterpret_cast<TfLiteAffineQuantization*>(\n             filter->quantization.params);\n     TF_LITE_ENSURE(context, affine_quantization);\n     TF_LITE_ENSURE(context, affine_quantization->scale);\n     TF_LITE_ENSURE_EQ(\n         context, affine_quantization->scale->size,\n         filter->dims->data[affine_quantization->quantized_dimension]);\n \n     int temporaries_count = 0;\n     data->input_quantized_index = temporaries_count;\n     if (data->input_quantized_id == kTensorNotAllocated) {\n       TF_LITE_ENSURE_OK(\n           context, context->AddTensors(context, 1, &data->input_quantized_id));\n     }\n     ++temporaries_count;\n     data->scaling_factors_index = temporaries_count;\n     if (data->scaling_factors_id == kTensorNotAllocated) {\n       TF_LITE_ENSURE_OK(\n           context, context->AddTensors(context, 1, &data->scaling_factors_id));\n     }\n     ++temporaries_count;\n     data->input_offset_index = temporaries_count;\n     if (data->input_offset_id == kTensorNotAllocated) {\n       TF_LITE_ENSURE_OK(\n           context, context->AddTensors(context, 1, &data->input_offset_id));\n     }\n     ++temporaries_count;\n \n     TfLiteIntArrayFree(node->temporaries);\n     node->temporaries = TfLiteIntArrayCreate(temporaries_count);\n \n     node->temporaries->data[data->input_quantized_index] =\n         data->input_quantized_id;\n     TfLiteTensor* input_quantized;\n     TF_LITE_ENSURE_OK(\n         context, GetTemporarySafe(context, node, data->input_quantized_index,\n                                   &input_quantized));\n     input_quantized->type = kTfLiteInt8;\n     input_quantized->allocation_type = kTfLiteArenaRw;\n     if (!TfLiteIntArrayEqual(input_quantized->dims, input->dims)) {\n       TfLiteIntArray* input_quantized_size = TfLiteIntArrayCopy(input->dims);\n       TF_LITE_ENSURE_OK(context, context->ResizeTensor(context, input_quantized,\n                                                        input_quantized_size));\n     }\n     node->temporaries->data[data->scaling_factors_index] =\n         data->scaling_factors_id;\n     TfLiteTensor* scaling_factors;\n     TF_LITE_ENSURE_OK(\n         context, GetTemporarySafe(context, node, data->scaling_factors_index,\n                                   &scaling_factors));\n     scaling_factors->type = kTfLiteFloat32;\n     scaling_factors->allocation_type = kTfLiteArenaRw;\n     const int batch_size = SizeOfDimension(input, 0);\n     int scaling_dims[1] = {batch_size};\n     if (!TfLiteIntArrayEqualsArray(scaling_factors->dims, 1, scaling_dims)) {\n       TfLiteIntArray* scaling_factors_size = TfLiteIntArrayCreate(1);\n       scaling_factors_size->data[0] = batch_size;\n       TF_LITE_ENSURE_OK(context, context->ResizeTensor(context, scaling_factors,\n                                                        scaling_factors_size));\n     }\n     node->temporaries->data[data->input_offset_index] = data->input_offset_id;\n     TfLiteTensor* input_offsets;\n     TF_LITE_ENSURE_OK(context,\n                       GetTemporarySafe(context, node, data->input_offset_index,\n                                        &input_offsets));\n     input_offsets->type = kTfLiteInt32;\n     input_offsets->allocation_type = kTfLiteArenaRw;\n     if (!TfLiteIntArrayEqualsArray(input_offsets->dims, 1, scaling_dims)) {\n       TfLiteIntArray* input_offsets_size = TfLiteIntArrayCreate(1);\n       input_offsets_size->data[0] = batch_size;\n       TF_LITE_ENSURE_OK(context, context->ResizeTensor(context, input_offsets,\n                                                        input_offsets_size));\n     }\n   }\n \n   TfLiteIntArray* outputSize = TfLiteIntArrayCreate(4);\n   outputSize->data[0] = batches;\n   outputSize->data[1] = out_height;\n   outputSize->data[2] = out_width;\n   outputSize->data[3] = channels_out;\n   return context->ResizeTensor(context, output, outputSize);\n }\n \n", "target": "// fix_start\n  TF_LITE_ENSURE(context, params->dilation_height_factor > 0);\n  TF_LITE_ENSURE(context, params->dilation_width_factor > 0);\n// fix_end\n", "cwe": "CWE-369", "cwe_name": "Divide By Zero", "cve": "CVE-2022-21741", "cve_desc": "Tensorflow is an Open Source Machine Learning Framework. ### Impact An attacker can craft a TFLite model that would trigger a division by zero in the implementation of depthwise convolutions. The parameters of the convolution can be user controlled and are also used within a division operation to determine the size of the padding that needs to be added before applying the convolution. There is no check before this division that the divisor is strictly positive. The fix will be included in TensorFlow 2.8.0. We will also cherrypick this commit on TensorFlow 2.7.1, TensorFlow 2.6.3, and TensorFlow 2.5.3, as these are also affected and still in supported range.", "project": "tensorflow", "idx": 195247}
{"source": " static struct sock *pep_sock_accept(struct sock *sk, int flags, int *errp,\n \t\t\t\t    bool kern)\n {\n \tstruct pep_sock *pn = pep_sk(sk), *newpn;\n \tstruct sock *newsk = NULL;\n \tstruct sk_buff *skb;\n \tstruct pnpipehdr *hdr;\n \tstruct sockaddr_pn dst, src;\n \tint err;\n \tu16 peer_type;\n \tu8 pipe_handle, enabled, n_sb;\n \tu8 aligned = 0;\n \n \tskb = skb_recv_datagram(sk, 0, flags & O_NONBLOCK, errp);\n \tif (!skb)\n \t\treturn NULL;\n \n \tlock_sock(sk);\n \tif (sk->sk_state != TCP_LISTEN) {\n \t\terr = -EINVAL;\n \t\tgoto drop;\n \t}\n \tsk_acceptq_removed(sk);\n \n \terr = -EPROTO;\n \tif (!pskb_may_pull(skb, sizeof(*hdr) + 4))\n \t\tgoto drop;\n \n \thdr = pnp_hdr(skb);\n \tpipe_handle = hdr->pipe_handle;\n \tswitch (hdr->state_after_connect) {\n \tcase PN_PIPE_DISABLE:\n \t\tenabled = 0;\n \t\tbreak;\n \tcase PN_PIPE_ENABLE:\n \t\tenabled = 1;\n \t\tbreak;\n \tdefault:\n \t\tpep_reject_conn(sk, skb, PN_PIPE_ERR_INVALID_PARAM,\n \t\t\t\tGFP_KERNEL);\n \t\tgoto drop;\n \t}\n \tpeer_type = hdr->other_pep_type << 8;\n \n \tn_sb = hdr->data[3];\n \twhile (n_sb > 0) {\n \t\tu8 type, buf[1], len = sizeof(buf);\n \t\tconst u8 *data = pep_get_sb(skb, &type, &len, buf);\n \n \t\tif (data == NULL)\n \t\t\tgoto drop;\n \t\tswitch (type) {\n \t\tcase PN_PIPE_SB_CONNECT_REQ_PEP_SUB_TYPE:\n \t\t\tif (len < 1)\n \t\t\t\tgoto drop;\n \t\t\tpeer_type = (peer_type & 0xff00) | data[0];\n \t\t\tbreak;\n \t\tcase PN_PIPE_SB_ALIGNED_DATA:\n \t\t\taligned = data[0] != 0;\n \t\t\tbreak;\n \t\t}\n \t\tn_sb--;\n \t}\n \n \tnewsk = pep_find_pipe(&pn->hlist, &dst, pipe_handle);\n \tif (unlikely(newsk)) {\n \t\t__sock_put(newsk);\n \t\tnewsk = NULL;\n \t\tpep_reject_conn(sk, skb, PN_PIPE_ERR_PEP_IN_USE, GFP_KERNEL);\n \t\tgoto drop;\n \t}\n \n \tnewsk = sk_alloc(sock_net(sk), PF_PHONET, GFP_KERNEL, sk->sk_prot,\n \t\t\t kern);\n \tif (!newsk) {\n \t\tpep_reject_conn(sk, skb, PN_PIPE_ERR_OVERLOAD, GFP_KERNEL);\n \t\terr = -ENOBUFS;\n \t\tgoto drop;\n \t}\n \n \tsock_init_data(NULL, newsk);\n \tnewsk->sk_state = TCP_SYN_RECV;\n \tnewsk->sk_backlog_rcv = pipe_do_rcv;\n \tnewsk->sk_protocol = sk->sk_protocol;\n \tnewsk->sk_destruct = pipe_destruct;\n \n \tnewpn = pep_sk(newsk);\n \tpn_skb_get_dst_sockaddr(skb, &dst);\n \tpn_skb_get_src_sockaddr(skb, &src);\n \tnewpn->pn_sk.sobject = pn_sockaddr_get_object(&dst);\n \tnewpn->pn_sk.dobject = pn_sockaddr_get_object(&src);\n \tnewpn->pn_sk.resource = pn_sockaddr_get_resource(&dst);\n \tsock_hold(sk);\n \tnewpn->listener = sk;\n \tskb_queue_head_init(&newpn->ctrlreq_queue);\n \tnewpn->pipe_handle = pipe_handle;\n \tatomic_set(&newpn->tx_credits, 0);\n \tnewpn->ifindex = 0;\n \tnewpn->peer_type = peer_type;\n \tnewpn->rx_credits = 0;\n \tnewpn->rx_fc = newpn->tx_fc = PN_LEGACY_FLOW_CONTROL;\n \tnewpn->init_enable = enabled;\n \tnewpn->aligned = aligned;\n \n \terr = pep_accept_conn(newsk, skb);\n \tif (err) {\n// bug_start\n// bug_end\n \t\tsock_put(newsk);\n \t\tnewsk = NULL;\n \t\tgoto drop;\n \t}\n \tsk_add_node(newsk, &pn->hlist);\n drop:\n \trelease_sock(sk);\n \tkfree_skb(skb);\n \t*errp = err;\n \treturn newsk;\n }\n \n", "target": "// fix_start\n\t\t__sock_put(sk);\n// fix_end\n", "cwe": "CWE-200", "cwe_name": "Exposure of Sensitive Information to an Unauthorized Actor", "cve": "CVE-2021-45095", "cve_desc": "pep_sock_accept in net/phonet/pep.c in the Linux kernel through 5.15.8 has a refcount leak.", "project": "linux", "idx": 195337}
{"source": " GF_Err gf_isom_box_parse_ex(GF_Box **outBox, GF_BitStream *bs, u32 parent_type, Bool is_root_box)\n {\n \tu32 type, uuid_type, hdr_size;\n \tu64 size, start, payload_start, end;\n \tchar uuid[16];\n \tGF_Err e;\n \tGF_Box *newBox;\n \tBool skip_logs = gf_bs_get_cookie(bs) ? GF_TRUE : GF_FALSE;\n \tBool is_special = GF_TRUE;\n \n \tif ((bs == NULL) || (outBox == NULL) ) return GF_BAD_PARAM;\n \t*outBox = NULL;\n \tif (gf_bs_available(bs) < 8) {\n \t\treturn GF_ISOM_INCOMPLETE_FILE;\n \t}\n \n \tstart = gf_bs_get_position(bs);\n \n \tuuid_type = 0;\n \tsize = (u64) gf_bs_read_u32(bs);\n \thdr_size = 4;\n \tif ((size >= 2) && (size <= 4)) {\n \t\tsize = 4;\n \t\ttype = GF_ISOM_BOX_TYPE_VOID;\n \t} else {\n \t\ttype = gf_bs_read_u32(bs);\n \t\thdr_size += 4;\n \t\tif (type == GF_ISOM_BOX_TYPE_TOTL)\n \t\t\tsize = 12;\n \t\tif (!size) {\n \t\t\tif (is_root_box) {\n \t\t\t\tif (!skip_logs) {\n \t\t\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[iso file] Warning Read Box type %s (0x%08X) size 0 reading till the end of file\\n\", gf_4cc_to_str(type), type));\n \t\t\t\t}\n \t\t\t\tsize = gf_bs_available(bs) + 8;\n \t\t\t} else {\n \t\t\t\tif (!skip_logs) {\n \t\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Read Box type %s (0x%08X) at position \"LLU\" has size 0 but is not at root/file level, skipping\\n\", gf_4cc_to_str(type), type, start));\n \t\t\t\t}\n \t\t\t\treturn GF_OK;\n \t\t\t}\n \t\t}\n \t}\n \tmemset(uuid, 0, 16);\n \tif (type == GF_ISOM_BOX_TYPE_UUID ) {\n \t\tif (gf_bs_available(bs) < 16) {\n \t\t\treturn GF_ISOM_INCOMPLETE_FILE;\n \t\t}\n \t\tgf_bs_read_data(bs, uuid, 16);\n \t\thdr_size += 16;\n \t\tuuid_type = gf_isom_solve_uuid_box(uuid);\n \t}\n \n \tif (size == 1) {\n \t\tif (gf_bs_available(bs) < 8) {\n \t\t\treturn GF_ISOM_INCOMPLETE_FILE;\n \t\t}\n \t\tsize = gf_bs_read_u64(bs);\n \t\thdr_size += 8;\n \t}\n \tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[iso file] Read Box type %s size \"LLD\" start \"LLD\"\\n\", gf_4cc_to_str(type), LLD_CAST size, LLD_CAST start));\n \n \tif ( size < hdr_size ) {\n \t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[iso file] Box size \"LLD\" less than box header size %d\\n\", LLD_CAST size, hdr_size));\n \t\treturn GF_ISOM_INVALID_FILE;\n \t}\n \n \tif (parent_type && (parent_type == GF_ISOM_BOX_TYPE_TREF)) {\n \t\tnewBox = gf_isom_box_new(GF_ISOM_BOX_TYPE_REFT);\n \t\tif (!newBox) return GF_OUT_OF_MEM;\n \t\t((GF_TrackReferenceTypeBox*)newBox)->reference_type = type;\n \t} else if (parent_type && (parent_type == GF_ISOM_BOX_TYPE_IREF)) {\n \t\tnewBox = gf_isom_box_new(GF_ISOM_BOX_TYPE_REFI);\n \t\tif (!newBox) return GF_OUT_OF_MEM;\n \t\t((GF_ItemReferenceTypeBox*)newBox)->reference_type = type;\n \t} else if (parent_type && (parent_type == GF_ISOM_BOX_TYPE_TRGR)) {\n \t\tnewBox = gf_isom_box_new(GF_ISOM_BOX_TYPE_TRGT);\n \t\tif (!newBox) return GF_OUT_OF_MEM;\n \t\t((GF_TrackGroupTypeBox*)newBox)->group_type = type;\n \t} else if (parent_type && (parent_type == GF_ISOM_BOX_TYPE_GRPL)) {\n \t\tnewBox = gf_isom_box_new(GF_ISOM_BOX_TYPE_GRPT);\n \t\tif (!newBox) return GF_OUT_OF_MEM;\n \t\t((GF_EntityToGroupTypeBox*)newBox)->grouping_type = type;\n \t} else {\n \t\tis_special = GF_FALSE;\n \t\tnewBox = gf_isom_box_new_ex(uuid_type ? uuid_type : type, parent_type, skip_logs, is_root_box);\n \t\tif (!newBox) return GF_OUT_OF_MEM;\n \t}\n \n \tif (type==GF_ISOM_BOX_TYPE_UUID && !is_special) {\n \t\tmemcpy(((GF_UUIDBox *)newBox)->uuid, uuid, 16);\n \t\t((GF_UUIDBox *)newBox)->internal_4cc = uuid_type;\n \t}\n \n \tif (!newBox->type) newBox->type = type;\n \tpayload_start = gf_bs_get_position(bs);\n \n retry_unknown_box:\n \n \tend = gf_bs_available(bs);\n \tif (size - hdr_size > end ) {\n \t\tnewBox->size = size - hdr_size - end;\n \t\t*outBox = newBox;\n \t\treturn GF_ISOM_INCOMPLETE_FILE;\n \t}\n \n \tnewBox->size = size - hdr_size;\n \n// bug_start\n\tif (newBox->size) {\n\t\te = gf_isom_full_box_read(newBox, bs);\n\t\tif (!e) e = gf_isom_box_read(newBox, bs);\n\t\tnewBox->size = size;\n\t\tend = gf_bs_get_position(bs);\n\t} else {\n\t\tnewBox->size = size;\n\t\te = GF_OK;\n\t\tend = gf_bs_get_position(bs);\n\t}\n// bug_end\n \n \tif (e && (e != GF_ISOM_INCOMPLETE_FILE)) {\n \t\tgf_isom_box_del(newBox);\n \t\t*outBox = NULL;\n \n \t\tif (parent_type==GF_ISOM_BOX_TYPE_STSD) {\n \t\t\tnewBox = gf_isom_box_new(GF_ISOM_BOX_TYPE_UNKNOWN);\n \t\t\t((GF_UnknownBox *)newBox)->original_4cc = type;\n \t\t\tnewBox->size = size;\n \t\t\tgf_bs_seek(bs, payload_start);\n \t\t\tgoto retry_unknown_box;\n \t\t}\n \t\tif (!skip_logs) {\n \t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Read Box \\\"%s\\\" (start \"LLU\") failed (%s) - skipping\\n\", gf_4cc_to_str(type), start, gf_error_to_string(e)));\n \t\t}\n \t\treturn e;\n \t}\n \n \tif (end-start > size) {\n \t\tif (!skip_logs) {\n \t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[iso file] Box \\\"%s\\\" size \"LLU\" (start \"LLU\") invalid (read \"LLU\")\\n\", gf_4cc_to_str(type), LLU_CAST size, start, LLU_CAST (end-start) ));\n \t\t}\n \t\tgf_bs_seek(bs, start+size);\n \t} else if (end-start < size) {\n \t\tu32 to_skip = (u32) (size-(end-start));\n \t\tif (!skip_logs) {\n \t\t\tif ((to_skip!=4) || gf_bs_peek_bits(bs, 32, 0)) {\n \t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[iso file] Box \\\"%s\\\" (start \"LLU\") has %u extra bytes\\n\", gf_4cc_to_str(type), start, to_skip));\n \t\t\t}\n \t\t}\n \t\tgf_bs_skip_bytes(bs, to_skip);\n \t}\n \t*outBox = newBox;\n \n \treturn e;\n }\n \n", "target": "// fix_start\n\te = gf_isom_full_box_read(newBox, bs);\n\tif (!e) e = gf_isom_box_read(newBox, bs);\n\tnewBox->size = size;\n\tend = gf_bs_get_position(bs);\n// fix_end\n", "cwe": "CWE-476", "cwe_name": "NULL Pointer Dereference", "cve": "CVE-2020-25427", "cve_desc": "A Null pointer dereference vulnerability exits in MP4Box - GPAC version 0.8.0-rev177-g51a8ef874-master via the gf_isom_get_track_id function, which causes a denial of service.", "project": "gpac", "idx": 195345}
{"source": "// bug_start\nsnmp_ber_decode_string_len_buffer(unsigned char *buf, uint32_t *buff_len, const char **str, uint32_t *length)\n// bug_end\n {\n   uint8_t type, i, length_bytes;\n \n// bug_start\n  buf = snmp_ber_decode_type(buf, buff_len, &type);\n\n  if(buf == NULL || type != BER_DATA_TYPE_OCTET_STRING) {\n    return NULL;\n// bug_end\n   }\n \n// bug_start\n  if((*buf & 0x80) == 0) {\n    *length = (uint32_t)*buf++;\n    (*buff_len)--;\n// bug_end\n   } else {\n \n// bug_start\n    length_bytes = (uint8_t)(*buf++ & 0x7F);\n    (*buff_len)--;\n    if(length_bytes > 4) {\n      return NULL;\n// bug_end\n     }\n \n// bug_start\n    *length = (uint32_t)*buf++;\n    (*buff_len)--;\n// bug_end\n     for(i = 1; i < length_bytes; ++i) {\n       *length <<= 8;\n// bug_start\n      *length |= *buf++;\n      (*buff_len)--;\n// bug_end\n     }\n   }\n \n// bug_start\n  *str = (const char *)buf;\n  *buff_len -= *length;\n// bug_end\n \n// bug_start\n  return buf + *length;\n// bug_end\n }\n \n", "target": "// fix_start\nsnmp_ber_decode_string_len_buffer(snmp_packet_t *snmp_packet, const char **str, uint32_t *length)\n// fix_end\n// fix_start\n  if(!snmp_ber_decode_type(snmp_packet, &type)) {\n    return 0;\n// fix_end\n// fix_start\n  if(type != BER_DATA_TYPE_OCTET_STRING) {\n    return 0;\n  }\n\n  if((*snmp_packet->in & 0x80) == 0) {\n\n    if(snmp_packet->used == 0) {\n      return 0;\n    }\n\n    *length = (uint32_t)*snmp_packet->in++;\n    snmp_packet->used--;\n// fix_end\n// fix_start\n    if(snmp_packet->used == 0) {\n      return 0;\n// fix_end\n// fix_start\n    length_bytes = (uint8_t)(*snmp_packet->in++ & 0x7F);\n    snmp_packet->used--;\n\n    if(length_bytes > 4) {\n      return 0;\n    }\n\n    if(snmp_packet->used == 0) {\n      return 0;\n    }\n\n    *length = (uint32_t)*snmp_packet->in++;\n    snmp_packet->used--;\n\n// fix_end\n// fix_start\n\n      if(snmp_packet->used == 0) {\n        return 0;\n      }\n\n      *length |= *snmp_packet->in++;\n      snmp_packet->used--;\n// fix_end\n// fix_start\n  *str = (const char *)snmp_packet->in;\n// fix_end\n// fix_start\n  if(snmp_packet->used == 0 || snmp_packet->used - *length <= 0) {\n    return 0;\n  }\n\n  snmp_packet->used -= *length;\n  snmp_packet->in += *length;\n\n  return 1;\n// fix_end\n", "cwe": "CWE-125", "cwe_name": "Out-of-bounds Read", "cve": "CVE-2020-12141", "cve_desc": "An out-of-bounds read in the SNMP stack in Contiki-NG 4.4 and earlier allows an attacker to cause a denial of service and potentially disclose information via crafted SNMP packets to snmp_ber_decode_string_len_buffer in os/net/app-layer/snmp/snmp-ber.c.", "project": "contiki-ng", "idx": 195362}
{"source": "   bool handleBackslash(signed char& out) {\n     char ch = *p++;\n     switch (ch) {\n       case 0: return false;\n       case '\"': out = ch; return true;\n       case '\\\\': out = ch; return true;\n       case '/': out = ch; return true;\n       case 'b': out = '\\b'; return true;\n       case 'f': out = '\\f'; return true;\n       case 'n': out = '\\n'; return true;\n       case 'r': out = '\\r'; return true;\n       case 't': out = '\\t'; return true;\n       case 'u': {\n         if (UNLIKELY(is_tsimplejson)) {\n           auto const ch1 = *p++;\n// bug_start\n// bug_end\n           auto const ch2 = *p++;\n// bug_start\n// bug_end\n           auto const dch3 = dehexchar(*p++);\n// bug_start\n// bug_end\n           auto const dch4 = dehexchar(*p++);\n// bug_start\n          if (UNLIKELY(ch1 != '0' || ch2 != '0' || dch3 < 0 || dch4 < 0)) {\n            return false;\n          }\n// bug_end\n           out = (dch3 << 4) | dch4;\n           return true;\n         } else {\n           uint16_t u16cp = 0;\n           for (int i = 0; i < 4; i++) {\n             auto const hexv = dehexchar(*p++);\n             if (hexv < 0) return false;\n             u16cp <<= 4;\n             u16cp |= hexv;\n           }\n           if (u16cp > 0x7f) {\n             return false;\n           } else {\n             out = u16cp;\n             return true;\n           }\n         }\n       }\n       default: return false;\n     }\n   }\n \n", "target": "// fix_start\n          if (UNLIKELY(ch1 != '0')) return false;\n// fix_end\n// fix_start\n          if (UNLIKELY(ch2 != '0')) return false;\n// fix_end\n// fix_start\n          if (UNLIKELY(dch3 < 0)) return false;\n// fix_end\n// fix_start\n          if (UNLIKELY(dch4 < 0)) return false;\n// fix_end\n", "cwe": "CWE-125", "cwe_name": "Out-of-bounds Read", "cve": "CVE-2020-1888", "cve_desc": "Insufficient boundary checks when decoding JSON in handleBackslash reads out of bounds memory, potentially leading to DOS. This issue affects HHVM 4.45.0, 4.44.0, 4.43.0, 4.42.0, 4.41.0, 4.40.0, 4.39.0, versions between 4.33.0 and 4.38.0 (inclusive), versions between 4.9.0 and 4.32.0 (inclusive), and versions prior to 4.8.7.", "project": "hhvm", "idx": 195486}
{"source": " void LanLinkProvider::addLink(const QString& deviceId, QSslSocket* socket, NetworkPacket* receivedPacket, LanDeviceLink::ConnectionStarted connectionOrigin)\n {\n     disconnect(socket, &QAbstractSocket::disconnected, socket, &QObject::deleteLater);\n \n     LanDeviceLink* deviceLink;\n     QMap< QString, LanDeviceLink* >::iterator linkIterator = m_links.find(deviceId);\n     if (linkIterator != m_links.end()) {\n         deviceLink = linkIterator.value();\n         deviceLink->reset(socket, connectionOrigin);\n     } else {\n         deviceLink = new LanDeviceLink(deviceId, this, socket, connectionOrigin);\n// bug_start\n// bug_end\n         connect(deviceLink, &QObject::destroyed, this, &LanLinkProvider::deviceLinkDestroyed);\n         m_links[deviceId] = deviceLink;\n         if (m_pairingHandlers.contains(deviceId)) {\n             Q_ASSERT(m_pairingHandlers.contains(deviceId));\n             m_pairingHandlers[deviceId]->setDeviceLink(deviceLink);\n         }\n     }\n     Q_EMIT onConnectionReceived(*receivedPacket, deviceLink);\n }\n \n", "target": "// fix_start\n        disconnect(socket, &QAbstractSocket::disconnected, socket, &QObject::deleteLater);\n        bool isDeviceTrusted = KdeConnectConfig::instance().trustedDevices().contains(deviceId);\n        if (!isDeviceTrusted && m_links.size() > MAX_UNPAIRED_CONNECTIONS) {\n            qCWarning(KDECONNECT_CORE) << \"Too many unpaired devices to remember them all. Ignoring \" << deviceId;\n            socket->disconnectFromHost();\n            socket->deleteLater();\n            return;\n        }\n// fix_end\n", "cwe": "CWE-400", "cwe_name": "Uncontrolled Resource Consumption", "cve": "CVE-2020-26164", "cve_desc": "In kdeconnect-kde (aka KDE Connect) before 20.08.2, an attacker on the local network could send crafted packets that trigger use of large amounts of CPU, memory, or network connection slots, aka a Denial of Service attack.", "project": "kdeconnect-kde", "idx": 195488}
{"source": " _libssh2_packet_add(LIBSSH2_SESSION * session, unsigned char *data,\n                     size_t datalen, int macstate)\n {\n     int rc = 0;\n// bug_start\n    char *message = NULL;\n    char *language = NULL;\n// bug_end\n     size_t message_len = 0;\n     size_t language_len = 0;\n     LIBSSH2_CHANNEL *channelp = NULL;\n     size_t data_head = 0;\n     unsigned char msg = data[0];\n \n     switch(session->packAdd_state) {\n     case libssh2_NB_state_idle:\n         _libssh2_debug(session, LIBSSH2_TRACE_TRANS,\n                        \"Packet type %d received, length=%d\",\n                        (int) msg, (int) datalen);\n \n         if((macstate == LIBSSH2_MAC_INVALID) &&\n             (!session->macerror ||\n              LIBSSH2_MACERROR(session, (char *) data, datalen))) {\n \n             LIBSSH2_FREE(session, data);\n             return _libssh2_error(session, LIBSSH2_ERROR_INVALID_MAC,\n                                   \"Invalid MAC received\");\n         }\n         session->packAdd_state = libssh2_NB_state_allocated;\n         break;\n     case libssh2_NB_state_jump1:\n         goto libssh2_packet_add_jump_point1;\n     case libssh2_NB_state_jump2:\n         goto libssh2_packet_add_jump_point2;\n     case libssh2_NB_state_jump3:\n         goto libssh2_packet_add_jump_point3;\n     case libssh2_NB_state_jump4:\n         goto libssh2_packet_add_jump_point4;\n     case libssh2_NB_state_jump5:\n         goto libssh2_packet_add_jump_point5;\n     default:\n         break;\n     }\n \n     if(session->packAdd_state == libssh2_NB_state_allocated) {\n         switch(msg) {\n \n \n         case SSH_MSG_DISCONNECT:\n             if(datalen >= 5) {\n// bug_start\n                size_t reason = _libssh2_ntohu32(data + 1);\n\n                if(datalen >= 9) {\n                    message_len = _libssh2_ntohu32(data + 5);\n\n                    if(message_len < datalen-13) {\n                        message = (char *) data + 9;\n\n                        language_len =\n                            _libssh2_ntohu32(data + 9 + message_len);\n                        language = (char *) data + 9 + message_len + 4;\n\n                        if(language_len > (datalen-13-message_len)) {\n                            language = message = NULL;\n                            language_len = message_len = 0;\n                        }\n                    }\n                    else\n                        message_len = 0;\n                }\n// bug_end\n                 if(session->ssh_msg_disconnect) {\n// bug_start\n                    LIBSSH2_DISCONNECT(session, reason, message,\n                                       message_len, language, language_len);\n                }\n// bug_end\n                 _libssh2_debug(session, LIBSSH2_TRACE_TRANS,\n                                \"Disconnect(%d): %s(%s)\", reason,\n                                message, language);\n             }\n \n             LIBSSH2_FREE(session, data);\n             session->socket_state = LIBSSH2_SOCKET_DISCONNECTED;\n             session->packAdd_state = libssh2_NB_state_idle;\n             return _libssh2_error(session, LIBSSH2_ERROR_SOCKET_DISCONNECT,\n                                   \"socket disconnect\");\n \n         case SSH_MSG_IGNORE:\n             if(datalen >= 2) {\n                 if(session->ssh_msg_ignore) {\n                     LIBSSH2_IGNORE(session, (char *) data + 1, datalen - 1);\n                 }\n             }\n             else if(session->ssh_msg_ignore) {\n                 LIBSSH2_IGNORE(session, \"\", 0);\n             }\n             LIBSSH2_FREE(session, data);\n             session->packAdd_state = libssh2_NB_state_idle;\n             return 0;\n \n \n         case SSH_MSG_DEBUG:\n             if(datalen >= 2) {\n                 int always_display = data[1];\n \n                 if(datalen >= 6) {\n// bug_start\n                    message_len = _libssh2_ntohu32(data + 2);\n\n                    if(message_len <= (datalen - 10)) {\n                        message = (char *) data + 6;\n                        language_len = _libssh2_ntohu32(data + 6 +\n                                                        message_len);\n\n                        if(language_len <= (datalen - 10 - message_len))\n                            language = (char *) data + 10 + message_len;\n                    }\n// bug_end\n                 }\n \n                 if(session->ssh_msg_debug) {\n// bug_start\n                    LIBSSH2_DEBUG(session, always_display, message,\n                                  message_len, language, language_len);\n                }\n            }\n// bug_end\n             _libssh2_debug(session, LIBSSH2_TRACE_TRANS,\n                            \"Debug Packet: %s\", message);\n             LIBSSH2_FREE(session, data);\n             session->packAdd_state = libssh2_NB_state_idle;\n             return 0;\n \n \n         case SSH_MSG_GLOBAL_REQUEST:\n             if(datalen >= 5) {\n                 uint32_t len = 0;\n                 unsigned char want_reply = 0;\n                 len = _libssh2_ntohu32(data + 1);\n// bug_start\n                if(datalen >= (6 + len)) {\n// bug_end\n                     want_reply = data[5 + len];\n                     _libssh2_debug(session,\n                                    LIBSSH2_TRACE_CONN,\n                                    \"Received global request type %.*s (wr %X)\",\n                                    len, data + 5, want_reply);\n                 }\n \n \n                 if(want_reply) {\n                     static const unsigned char packet =\n                         SSH_MSG_REQUEST_FAILURE;\n                   libssh2_packet_add_jump_point5:\n                     session->packAdd_state = libssh2_NB_state_jump5;\n                     rc = _libssh2_transport_send(session, &packet, 1, NULL, 0);\n                     if(rc == LIBSSH2_ERROR_EAGAIN)\n                         return rc;\n                 }\n             }\n             LIBSSH2_FREE(session, data);\n             session->packAdd_state = libssh2_NB_state_idle;\n             return 0;\n \n \n         case SSH_MSG_CHANNEL_EXTENDED_DATA:\n             data_head += 4;\n \n \n \n         case SSH_MSG_CHANNEL_DATA:\n             data_head += 9;\n \n             if(datalen >= data_head)\n                 channelp =\n                     _libssh2_channel_locate(session,\n                                             _libssh2_ntohu32(data + 1));\n \n             if(!channelp) {\n                 _libssh2_error(session, LIBSSH2_ERROR_CHANNEL_UNKNOWN,\n                                \"Packet received for unknown channel\");\n                 LIBSSH2_FREE(session, data);\n                 session->packAdd_state = libssh2_NB_state_idle;\n                 return 0;\n             }\n #ifdef LIBSSH2DEBUG\n             {\n                 uint32_t stream_id = 0;\n                 if(msg == SSH_MSG_CHANNEL_EXTENDED_DATA)\n                     stream_id = _libssh2_ntohu32(data + 5);\n \n                 _libssh2_debug(session, LIBSSH2_TRACE_CONN,\n                                \"%d bytes packet_add() for %lu/%lu/%lu\",\n                                (int) (datalen - data_head),\n                                channelp->local.id,\n                                channelp->remote.id,\n                                stream_id);\n             }\n #endif\n             if((channelp->remote.extended_data_ignore_mode ==\n                  LIBSSH2_CHANNEL_EXTENDED_DATA_IGNORE) &&\n                 (msg == SSH_MSG_CHANNEL_EXTENDED_DATA)) {\n                 LIBSSH2_FREE(session, data);\n \n                 _libssh2_debug(session, LIBSSH2_TRACE_CONN,\n                                \"Ignoring extended data and refunding %d bytes\",\n                                (int) (datalen - 13));\n                 if(channelp->read_avail + datalen - data_head >=\n                     channelp->remote.window_size)\n                     datalen = channelp->remote.window_size -\n                         channelp->read_avail + data_head;\n \n                 channelp->remote.window_size -= datalen - data_head;\n                 _libssh2_debug(session, LIBSSH2_TRACE_CONN,\n                                \"shrinking window size by %lu bytes to %lu, \"\n                                \"read_avail %lu\",\n                                datalen - data_head,\n                                channelp->remote.window_size,\n                                channelp->read_avail);\n \n                 session->packAdd_channelp = channelp;\n \n               libssh2_packet_add_jump_point1:\n                 session->packAdd_state = libssh2_NB_state_jump1;\n                 rc = _libssh2_channel_receive_window_adjust(session->\n                                                             packAdd_channelp,\n                                                             datalen - 13,\n                                                             1, NULL);\n                 if(rc == LIBSSH2_ERROR_EAGAIN)\n                     return rc;\n \n                 session->packAdd_state = libssh2_NB_state_idle;\n                 return 0;\n             }\n \n             if(channelp->remote.packet_size < (datalen - data_head)) {\n                 _libssh2_error(session,\n                                LIBSSH2_ERROR_CHANNEL_PACKET_EXCEEDED,\n                                \"Packet contains more data than we offered\"\n                                \" to receive, truncating\");\n                 datalen = channelp->remote.packet_size + data_head;\n             }\n             if(channelp->remote.window_size <= channelp->read_avail) {\n                 _libssh2_error(session,\n                                LIBSSH2_ERROR_CHANNEL_WINDOW_EXCEEDED,\n                                \"The current receive window is full,\"\n                                \" data ignored\");\n                 LIBSSH2_FREE(session, data);\n                 session->packAdd_state = libssh2_NB_state_idle;\n                 return 0;\n             }\n             channelp->remote.eof = 0;\n \n             if(channelp->read_avail + datalen - data_head >\n                 channelp->remote.window_size) {\n                 _libssh2_error(session,\n                                LIBSSH2_ERROR_CHANNEL_WINDOW_EXCEEDED,\n                                \"Remote sent more data than current \"\n                                \"window allows, truncating\");\n                 datalen = channelp->remote.window_size -\n                     channelp->read_avail + data_head;\n             }\n \n             channelp->read_avail += datalen - data_head;\n \n             _libssh2_debug(session, LIBSSH2_TRACE_CONN,\n                            \"increasing read_avail by %lu bytes to %lu/%lu\",\n                            (long)(datalen - data_head),\n                            (long)channelp->read_avail,\n                            (long)channelp->remote.window_size);\n \n             break;\n \n \n         case SSH_MSG_CHANNEL_EOF:\n             if(datalen >= 5)\n                 channelp =\n                     _libssh2_channel_locate(session,\n                                             _libssh2_ntohu32(data + 1));\n             if(!channelp)\n                 ;\n             else {\n                 _libssh2_debug(session,\n                                LIBSSH2_TRACE_CONN,\n                                \"EOF received for channel %lu/%lu\",\n                                channelp->local.id,\n                                channelp->remote.id);\n                 channelp->remote.eof = 1;\n             }\n             LIBSSH2_FREE(session, data);\n             session->packAdd_state = libssh2_NB_state_idle;\n             return 0;\n \n \n         case SSH_MSG_CHANNEL_REQUEST:\n             if(datalen >= 9) {\n                 uint32_t channel = _libssh2_ntohu32(data + 1);\n                 uint32_t len = _libssh2_ntohu32(data + 5);\n                 unsigned char want_reply = 1;\n \n                 if((len + 9) < datalen)\n                     want_reply = data[len + 9];\n \n                 _libssh2_debug(session,\n                                LIBSSH2_TRACE_CONN,\n                                \"Channel %d received request type %.*s (wr %X)\",\n                                channel, len, data + 9, want_reply);\n \n                 if(len == sizeof(\"exit-status\") - 1\n                     && (sizeof(\"exit-status\") - 1 + 9) <= datalen\n                     && !memcmp(\"exit-status\", data + 9,\n                                sizeof(\"exit-status\") - 1)) {\n \n                     if(datalen >= 20)\n                         channelp =\n                             _libssh2_channel_locate(session, channel);\n \n                     if(channelp && (sizeof(\"exit-status\") + 13) <= datalen) {\n                         channelp->exit_status =\n                             _libssh2_ntohu32(data + 9 + sizeof(\"exit-status\"));\n                         _libssh2_debug(session, LIBSSH2_TRACE_CONN,\n                                        \"Exit status %lu received for \"\n                                        \"channel %lu/%lu\",\n                                        channelp->exit_status,\n                                        channelp->local.id,\n                                        channelp->remote.id);\n                     }\n \n                 }\n                 else if(len == sizeof(\"exit-signal\") - 1\n                          && (sizeof(\"exit-signal\") - 1 + 9) <= datalen\n                          && !memcmp(\"exit-signal\", data + 9,\n                                     sizeof(\"exit-signal\") - 1)) {\n                     if(datalen >= 20)\n                         channelp = _libssh2_channel_locate(session, channel);\n \n                     if(channelp && (sizeof(\"exit-signal\") + 13) <= datalen) {\n                         uint32_t namelen =\n                             _libssh2_ntohu32(data + 9 + sizeof(\"exit-signal\"));\n \n                         if(namelen <= UINT_MAX - 1) {\n                             channelp->exit_signal =\n                                 LIBSSH2_ALLOC(session, namelen + 1);\n                         }\n                         else {\n                             channelp->exit_signal = NULL;\n                         }\n \n                         if(!channelp->exit_signal)\n                             rc = _libssh2_error(session, LIBSSH2_ERROR_ALLOC,\n                                                 \"memory for signal name\");\n                         else if((sizeof(\"exit-signal\") + 13 + namelen <=\n                                  datalen)) {\n                             memcpy(channelp->exit_signal,\n                                    data + 13 + sizeof(\"exit-signal\"), namelen);\n                             channelp->exit_signal[namelen] = '\\0';\n                             _libssh2_debug(session, LIBSSH2_TRACE_CONN,\n                                            \"Exit signal %s received for \"\n                                            \"channel %lu/%lu\",\n                                            channelp->exit_signal,\n                                            channelp->local.id,\n                                            channelp->remote.id);\n                         }\n                     }\n                 }\n \n \n                 if(want_reply) {\n                     unsigned char packet[5];\n                   libssh2_packet_add_jump_point4:\n                     session->packAdd_state = libssh2_NB_state_jump4;\n                     packet[0] = SSH_MSG_CHANNEL_FAILURE;\n                     memcpy(&packet[1], data + 1, 4);\n                     rc = _libssh2_transport_send(session, packet, 5, NULL, 0);\n                     if(rc == LIBSSH2_ERROR_EAGAIN)\n                         return rc;\n                 }\n             }\n             LIBSSH2_FREE(session, data);\n             session->packAdd_state = libssh2_NB_state_idle;\n             return rc;\n \n \n         case SSH_MSG_CHANNEL_CLOSE:\n             if(datalen >= 5)\n                 channelp =\n                     _libssh2_channel_locate(session,\n                                             _libssh2_ntohu32(data + 1));\n             if(!channelp) {\n                 LIBSSH2_FREE(session, data);\n                 session->packAdd_state = libssh2_NB_state_idle;\n                 return 0;\n             }\n             _libssh2_debug(session, LIBSSH2_TRACE_CONN,\n                            \"Close received for channel %lu/%lu\",\n                            channelp->local.id,\n                            channelp->remote.id);\n \n             channelp->remote.close = 1;\n             channelp->remote.eof = 1;\n \n             LIBSSH2_FREE(session, data);\n             session->packAdd_state = libssh2_NB_state_idle;\n             return 0;\n \n \n         case SSH_MSG_CHANNEL_OPEN:\n             if(datalen < 17)\n                 ;\n             else if((datalen >= (sizeof(\"forwarded-tcpip\") + 4)) &&\n                      ((sizeof(\"forwarded-tcpip\") - 1) ==\n                       _libssh2_ntohu32(data + 1))\n                      &&\n                      (memcmp(data + 5, \"forwarded-tcpip\",\n                              sizeof(\"forwarded-tcpip\") - 1) == 0)) {\n \n                 memset(&session->packAdd_Qlstn_state, 0,\n                        sizeof(session->packAdd_Qlstn_state));\n \n               libssh2_packet_add_jump_point2:\n                 session->packAdd_state = libssh2_NB_state_jump2;\n                 rc = packet_queue_listener(session, data, datalen,\n                                            &session->packAdd_Qlstn_state);\n             }\n             else if((datalen >= (sizeof(\"x11\") + 4)) &&\n                      ((sizeof(\"x11\") - 1) == _libssh2_ntohu32(data + 1)) &&\n                      (memcmp(data + 5, \"x11\", sizeof(\"x11\") - 1) == 0)) {\n \n                 memset(&session->packAdd_x11open_state, 0,\n                        sizeof(session->packAdd_x11open_state));\n \n               libssh2_packet_add_jump_point3:\n                 session->packAdd_state = libssh2_NB_state_jump3;\n                 rc = packet_x11_open(session, data, datalen,\n                                      &session->packAdd_x11open_state);\n             }\n             if(rc == LIBSSH2_ERROR_EAGAIN)\n                 return rc;\n \n             LIBSSH2_FREE(session, data);\n             session->packAdd_state = libssh2_NB_state_idle;\n             return rc;\n \n         case SSH_MSG_CHANNEL_WINDOW_ADJUST:\n             if(datalen < 9)\n                 ;\n             else {\n                 uint32_t bytestoadd = _libssh2_ntohu32(data + 5);\n                 channelp =\n                     _libssh2_channel_locate(session,\n                                             _libssh2_ntohu32(data + 1));\n                 if(channelp) {\n                     channelp->local.window_size += bytestoadd;\n \n                     _libssh2_debug(session, LIBSSH2_TRACE_CONN,\n                                    \"Window adjust for channel %lu/%lu, \"\n                                    \"adding %lu bytes, new window_size=%lu\",\n                                    channelp->local.id,\n                                    channelp->remote.id,\n                                    bytestoadd,\n                                    channelp->local.window_size);\n                 }\n             }\n             LIBSSH2_FREE(session, data);\n             session->packAdd_state = libssh2_NB_state_idle;\n             return 0;\n         default:\n             break;\n         }\n \n         session->packAdd_state = libssh2_NB_state_sent;\n     }\n \n     if(session->packAdd_state == libssh2_NB_state_sent) {\n         LIBSSH2_PACKET *packetp =\n             LIBSSH2_ALLOC(session, sizeof(LIBSSH2_PACKET));\n         if(!packetp) {\n             _libssh2_debug(session, LIBSSH2_ERROR_ALLOC,\n                            \"memory for packet\");\n             LIBSSH2_FREE(session, data);\n             session->packAdd_state = libssh2_NB_state_idle;\n             return LIBSSH2_ERROR_ALLOC;\n         }\n         packetp->data = data;\n         packetp->data_len = datalen;\n         packetp->data_head = data_head;\n \n         _libssh2_list_add(&session->packets, &packetp->node);\n \n         session->packAdd_state = libssh2_NB_state_sent1;\n     }\n \n     if((msg == SSH_MSG_KEXINIT &&\n          !(session->state & LIBSSH2_STATE_EXCHANGING_KEYS)) ||\n         (session->packAdd_state == libssh2_NB_state_sent2)) {\n         if(session->packAdd_state == libssh2_NB_state_sent1) {\n             _libssh2_debug(session, LIBSSH2_TRACE_TRANS, \"Renegotiating Keys\");\n \n             session->packAdd_state = libssh2_NB_state_sent2;\n         }\n \n         session->readPack_state = libssh2_NB_state_idle;\n         session->packet.total_num = 0;\n         session->packAdd_state = libssh2_NB_state_idle;\n         session->fullpacket_state = libssh2_NB_state_idle;\n \n         memset(&session->startup_key_state, 0, sizeof(key_exchange_state_t));\n \n         rc = _libssh2_kex_exchange(session, 1, &session->startup_key_state);\n         if(rc == LIBSSH2_ERROR_EAGAIN)\n             return rc;\n     }\n \n     session->packAdd_state = libssh2_NB_state_idle;\n     return 0;\n }\n \n", "target": "// fix_start\n    unsigned char *message = NULL;\n    unsigned char *language = NULL;\n// fix_end\n// fix_start\n                uint32_t reason = 0;\n                struct string_buf buf;\n                buf.data = (unsigned char *)data;\n                buf.dataptr = buf.data;\n                buf.len = datalen;\n                buf.dataptr++;\n\n                _libssh2_get_u32(&buf, &reason);\n                _libssh2_get_string(&buf, &message, &message_len);\n                _libssh2_get_string(&buf, &language, &language_len);\n\n// fix_end\n// fix_start\n                    LIBSSH2_DISCONNECT(session, reason, (const char *)message,\n                                       message_len, (const char *)language,\n                                       language_len);\n                }\n\n// fix_end\n// fix_start\n                    struct string_buf buf;\n                    buf.data = (unsigned char *)data;\n                    buf.dataptr = buf.data;\n                    buf.len = datalen;\n                    buf.dataptr += 2;\n\n                    _libssh2_get_string(&buf, &message, &message_len);\n                    _libssh2_get_string(&buf, &language, &language_len);\n// fix_end\n// fix_start\n                    LIBSSH2_DEBUG(session, always_display,\n                                  (const char *)message,\n                                  message_len, (const char *)language,\n                                  language_len);\n                }\n            }\n\n// fix_end\n// fix_start\n                if((len <= (UINT_MAX - 6)) && (datalen >= (6 + len))) {\n// fix_end\n", "cwe": "CWE-703", "cwe_name": "Improper Check or Handling of Exceptional Conditions", "cve": "CVE-2019-17498", "cve_desc": "In libssh2 v1.9.0 and earlier versions, the SSH_MSG_DISCONNECT logic in packet.c has an integer overflow in a bounds check, enabling an attacker to specify an arbitrary (out-of-bounds) offset for a subsequent memory read. A crafted SSH server may be able to disclose sensitive information or cause a denial of service condition on the client system when a user connects to the server.", "project": "libssh2", "idx": 195648}
{"source": "   void Compute(OpKernelContext* context) override {\n     const Tensor& logits_in = context->input(0);\n     const Tensor& labels_in = context->input(1);\n \n     TensorShape shape_in = logits_in.shape();\n \n     BCast bcast(BCast::FromShape(logits_in.shape()),\n// bug_start\n                BCast::FromShape(labels_in.shape()));\n// bug_end\n     if (!logits_in.IsSameSize(labels_in)) {\n       OP_REQUIRES(context, bcast.IsValid(),\n                   errors::InvalidArgument(\n                       \"logits and labels must be broadcastable: logits_size=\",\n                       logits_in.shape().DebugString(),\n                       \" labels_size=\", labels_in.shape().DebugString()));\n       shape_in = BCast::ToShape(bcast.output_shape());\n     }\n     OP_REQUIRES(context, TensorShapeUtils::IsMatrix(shape_in),\n                 errors::InvalidArgument(\"logits and labels must be either \"\n                                         \"2-dimensional, or broadcasted to be \"\n                                         \"2-dimensional\"));\n \n     if (std::is_same<Device, GPUDevice>::value) {\n       OP_REQUIRES(context, !OpDeterminismRequired(),\n                   errors::Unimplemented(\n                       \"The GPU implementation of SoftmaxCrossEntropyWithLogits\"\n                       \" that would have been executed is not deterministic.\"\n                       \" Note that the Python API uses an alternative,\"\n                       \" deterministic, GPU-accelerated path when determinism is\"\n                       \" enabled.\"));\n     }\n \n \n     Tensor scratch;\n     OP_REQUIRES_OK(\n         context, context->allocate_temp(DataTypeToEnum<T>::value,\n                                         TensorShape({shape_in.dim_size(0), 1}),\n                                         &scratch));\n \n     Tensor* loss_out = nullptr;\n     OP_REQUIRES_OK(context,\n                    context->allocate_output(\n                        0, TensorShape({shape_in.dim_size(0)}), &loss_out));\n     Tensor* back_out = nullptr;\n     OP_REQUIRES_OK(context, context->forward_input_or_allocate_output(\n                                 {0}, 1, shape_in, &back_out));\n     if (shape_in.dim_size(0) > 0) {\n       functor::XentFunctor<Device, T> functor;\n// bug_start\n      if (logits_in.IsSameSize(labels_in)) {\n        functor(context->eigen_device<Device>(), shape_in.AsEigenDSizes<2>(),\n                Eigen::array<Eigen::DenseIndex, 2>{1, 1},\n                Eigen::array<Eigen::DenseIndex, 2>{1, 1}, logits_in.matrix<T>(),\n                labels_in.matrix<T>(), scratch.matrix<T>(), loss_out->vec<T>(),\n                back_out->matrix<T>());\n      } else {\n        functor(context->eigen_device<Device>(), shape_in.AsEigenDSizes<2>(),\n                BCast::ToIndexArray<2>(bcast.x_bcast()),\n                BCast::ToIndexArray<2>(bcast.y_bcast()),\n                logits_in.template shaped<T, 2>(bcast.x_reshape()),\n                labels_in.template shaped<T, 2>(bcast.y_reshape()),\n                scratch.matrix<T>(), loss_out->vec<T>(), back_out->matrix<T>());\n      }\n// bug_end\n     }\n   }\n \n", "target": "// fix_start\n                BCast::FromShape(labels_in.shape()),\n                false);\n// fix_end\n// fix_start\n      functor(context->eigen_device<Device>(), shape_in.AsEigenDSizes<2>(),\n              BCast::ToIndexArray<2>(bcast.x_bcast()),\n              BCast::ToIndexArray<2>(bcast.y_bcast()),\n              logits_in.template shaped<T, 2>(bcast.x_reshape()),\n              labels_in.template shaped<T, 2>(bcast.y_reshape()),\n              scratch.matrix<T>(), loss_out->vec<T>(), back_out->matrix<T>());\n// fix_end\n", "cwe": "CWE-354", "cwe_name": "Improper Validation of Integrity Check Value", "cve": "CVE-2021-41206", "cve_desc": "TensorFlow is an open source platform for machine learning. In affected versions several TensorFlow operations are missing validation for the shapes of the tensor arguments involved in the call. Depending on the API, this can result in undefined behavior and segfault or `CHECK`-fail related crashes but in some scenarios writes and reads from heap populated arrays are also possible. We have discovered these issues internally via tooling while working on improving/testing GPU op determinism. As such, we don't have reproducers and there will be multiple fixes for these issues. These fixes will be included in TensorFlow 2.7.0. We will also cherrypick these commits on TensorFlow 2.6.1, TensorFlow 2.5.2, and TensorFlow 2.4.4, as these are also affected and still in supported range.", "project": "tensorflow", "idx": 195649}
{"source": "   Status BuildFeatureReaders(const OpInputList& ragged_values_list,\n                              const OpInputList& ragged_splits_list,\n                              const OpInputList& sparse_indices_list,\n                              const OpInputList& sparse_values_list,\n                              const OpInputList& dense_list, int64 batch_size,\n                              FeatureReaders* features) {\n     features->reserve(input_order_.size());\n \n     int next_ragged = 0;\n     int next_sparse = 0;\n     int next_dense = 0;\n     for (char c : input_order_) {\n       if (c == 'R') {\n// bug_start\n// bug_end\n         TF_RETURN_IF_ERROR(BuildRaggedFeatureReader(\n             ragged_values_list[next_ragged], ragged_splits_list[next_ragged],\n             features));\n         next_ragged++;\n       } else if (c == 'S') {\n// bug_start\n// bug_end\n         TF_RETURN_IF_ERROR(BuildSparseFeatureReader(\n             sparse_indices_list[next_sparse], sparse_values_list[next_sparse],\n             batch_size, features));\n         next_sparse++;\n       } else if (c == 'D') {\n// bug_start\n// bug_end\n         TF_RETURN_IF_ERROR(\n             BuildDenseFeatureReader(dense_list[next_dense++], features));\n       } else {\n         return errors::InvalidArgument(\"Unexpected input_order value.\");\n       }\n     }\n \n     return Status::OK();\n   }\n \n", "target": "// fix_start\n        if (next_ragged >= ragged_values_list.size())\n          return errors::InvalidArgument(\n              \"input_order \\\"\", input_order_,\n              \"\\\" specifies reading a ragged tensor value at index \",\n              next_ragged, \" from a list of \", ragged_values_list.size(),\n              \" values.\");\n        if (next_ragged >= ragged_splits_list.size())\n          return errors::InvalidArgument(\n              \"input_order \\\"\", input_order_,\n              \"\\\" specifies reading a ragged tensor split at index \",\n              next_ragged, \" from a list of \", ragged_splits_list.size(),\n              \" splits.\");\n// fix_end\n// fix_start\n        if (next_sparse >= sparse_values_list.size())\n          return errors::InvalidArgument(\n              \"input_order \\\"\", input_order_,\n              \"\\\" specifies reading a sparse tensor value at index \",\n              next_sparse, \" from a list of \", sparse_values_list.size(),\n              \" values.\");\n        if (next_sparse >= sparse_indices_list.size())\n          return errors::InvalidArgument(\n              \"input_order \\\"\", input_order_,\n              \"\\\" specifies reading a sparse tensor index at index \",\n              next_sparse, \" from a list of \", sparse_indices_list.size(),\n              \" indices.\");\n// fix_end\n// fix_start\n        if (next_dense >= dense_list.size())\n          return errors::InvalidArgument(\n              \"input_order \\\"\", input_order_,\n              \"\\\" specifies reading a dense tensor at index \", next_dense,\n              \" from a list of \", dense_list.size(), \" tensors.\");\n// fix_end\n", "cwe": "CWE-369", "cwe_name": "Divide By Zero", "cve": "CVE-2021-29532", "cve_desc": "TensorFlow is an end-to-end open source platform for machine learning. An attacker can force accesses outside the bounds of heap allocated arrays by passing in invalid tensor values to `tf.raw_ops.RaggedCross`. This is because the implementation(https://github.com/tensorflow/tensorflow/blob/efea03b38fb8d3b81762237dc85e579cc5fc6e87/tensorflow/core/kernels/ragged_cross_op.cc#L456-L487) lacks validation for the user supplied arguments. Each of the above branches call a helper function after accessing array elements via a `*_list[next_*]` pattern, followed by incrementing the `next_*` index. However, as there is no validation that the `next_*` values are in the valid range for the corresponding `*_list` arrays, this results in heap OOB reads. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.", "project": "tensorflow", "idx": 195659}
{"source": "   void Compute(OpKernelContext* ctx) override {\n     const Tensor& input = ctx->input(0);\n     const Tensor& input_min_tensor = ctx->input(1);\n     const Tensor& input_max_tensor = ctx->input(2);\n \n     int num_slices = 1;\n     if (axis_ > -1) {\n       num_slices = input.dim_size(axis_);\n     }\n// bug_start\n// bug_end\n \n     Tensor* output = nullptr;\n     OP_REQUIRES_OK(ctx, ctx->allocate_output(0, input.shape(), &output));\n     Tensor float_output =\n         need_cast_ ? tensorflow::Tensor(DT_FLOAT, input.shape()) : *output;\n     if (num_slices == 1) {\n       const float min_range = input_min_tensor.flat<float>()(0);\n       const float max_range = input_max_tensor.flat<float>()(0);\n       DequantizeTensor(ctx, input, min_range, max_range, &float_output);\n     } else {\n       OP_REQUIRES(ctx, mode_ != QUANTIZE_MODE_MIN_FIRST,\n                   errors::Unimplemented(\"MIN_FIRST mode is not implemented for \"\n                                         \"Dequantize with axis != -1.\"));\n \n       int64 pre_dim = 1, post_dim = 1;\n       for (int i = 0; i < axis_; ++i) {\n         pre_dim *= float_output.dim_size(i);\n       }\n       for (int i = axis_ + 1; i < float_output.dims(); ++i) {\n         post_dim *= float_output.dim_size(i);\n       }\n       auto input_tensor = input.template bit_casted_shaped<T, 3>(\n           {pre_dim, num_slices, post_dim});\n       auto output_tensor =\n           float_output.flat_inner_outer_dims<float, 3>(axis_ - 1);\n       auto min_ranges = input_min_tensor.vec<float>();\n       auto max_ranges = input_max_tensor.vec<float>();\n       for (int i = 0; i < num_slices; ++i) {\n         DequantizeSlice(ctx->eigen_device<Device>(), ctx,\n                         input_tensor.template chip<1>(i), min_ranges(i),\n                         max_ranges(i), output_tensor.template chip<1>(i));\n       }\n     }\n     if (need_cast_) {\n       S* out_ptr = output->flat<S>().data();\n       float* in_ptr = float_output.flat<float>().data();\n       for (int64 i = 0; i < float_output.NumElements(); ++i) {\n         out_ptr[i] = static_cast<S>(in_ptr[i]);\n       }\n     }\n   }\n \n", "target": "// fix_start\n    OP_REQUIRES(ctx, input_min_tensor.NumElements() == num_slices,\n                errors::InvalidArgument(\n                    \"input_min_tensor must have as many elements as input on \"\n                    \"the dequantization axis (\",\n                    axis_, \"), got \", input_min_tensor.NumElements(),\n                    \", expected \", num_slices));\n    OP_REQUIRES(ctx, input_max_tensor.NumElements() == num_slices,\n                errors::InvalidArgument(\n                    \"input_max_tensor must have as many elements as input on \"\n                    \"the dequantization axis (\",\n                    axis_, \"), got \", input_max_tensor.NumElements(),\n                    \", expected \", num_slices));\n// fix_end\n", "cwe": "CWE-20", "cwe_name": "Improper Input Validation", "cve": "CVE-2021-29582", "cve_desc": "TensorFlow is an end-to-end open source platform for machine learning. Due to lack of validation in `tf.raw_ops.Dequantize`, an attacker can trigger a read from outside of bounds of heap allocated data. The implementation(https://github.com/tensorflow/tensorflow/blob/26003593aa94b1742f34dc22ce88a1e17776a67d/tensorflow/core/kernels/dequantize_op.cc#L106-L131) accesses the `min_range` and `max_range` tensors in parallel but fails to check that they have the same shape. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.", "project": "tensorflow", "idx": 195663}
{"source": " CallResult<PseudoHandle<>> JSObject::getComputedWithReceiver_RJS(\n     Handle<JSObject> selfHandle,\n     Runtime *runtime,\n     Handle<> nameValHandle,\n     Handle<> receiver) {\n   if (selfHandle->flags_.fastIndexProperties) {\n     if (auto arrayIndex = toArrayIndexFastPath(*nameValHandle)) {\n       PseudoHandle<> ourValue = createPseudoHandle(\n           getOwnIndexed(selfHandle.get(), runtime, *arrayIndex));\n       if (LLVM_LIKELY(!ourValue->isEmpty()))\n         return ourValue;\n     }\n   }\n \n   auto converted = toPropertyKeyIfObject(runtime, nameValHandle);\n   if (LLVM_UNLIKELY(converted == ExecutionStatus::EXCEPTION)) {\n     return ExecutionStatus::EXCEPTION;\n   }\n   auto nameValPrimitiveHandle = *converted;\n \n   ComputedPropertyDescriptor desc;\n \n   MutableHandle<JSObject> propObj{runtime};\n   if (LLVM_UNLIKELY(\n           getComputedPrimitiveDescriptor(\n               selfHandle, runtime, nameValPrimitiveHandle, propObj, desc) ==\n           ExecutionStatus::EXCEPTION)) {\n     return ExecutionStatus::EXCEPTION;\n   }\n \n   if (!propObj)\n     return createPseudoHandle(HermesValue::encodeUndefinedValue());\n \n   if (LLVM_LIKELY(\n           !desc.flags.accessor && !desc.flags.hostObject &&\n           !desc.flags.proxyObject))\n     return createPseudoHandle(\n         getComputedSlotValue(propObj.get(), runtime, desc));\n \n   if (desc.flags.accessor) {\n     auto *accessor = vmcast<PropertyAccessor>(\n         getComputedSlotValue(propObj.get(), runtime, desc));\n     if (!accessor->getter)\n       return createPseudoHandle(HermesValue::encodeUndefinedValue());\n \n     return accessor->getter.get(runtime)->executeCall0(\n         runtime->makeHandle(accessor->getter), runtime, receiver);\n   } else if (desc.flags.hostObject) {\n     SymbolID id{};\n     LAZY_TO_IDENTIFIER(runtime, nameValPrimitiveHandle, id);\n// bug_start\n    auto propRes = vmcast<HostObject>(selfHandle.get())->get(id);\n// bug_end\n     if (propRes == ExecutionStatus::EXCEPTION)\n       return ExecutionStatus::EXCEPTION;\n     return createPseudoHandle(*propRes);\n   } else {\n     assert(desc.flags.proxyObject && \"descriptor flags are impossible\");\n     CallResult<Handle<>> key = toPropertyKey(runtime, nameValPrimitiveHandle);\n     if (key == ExecutionStatus::EXCEPTION)\n       return ExecutionStatus::EXCEPTION;\n     return JSProxy::getComputed(propObj, runtime, *key, receiver);\n   }\n }\n \n", "target": "// fix_start\n    auto propRes = vmcast<HostObject>(propObj.get())->get(id);\n// fix_end\n", "cwe": "CWE-125", "cwe_name": "Out-of-bounds Read", "cve": "CVE-2020-1911", "cve_desc": "A type confusion vulnerability when resolving properties of JavaScript objects with specially-crafted prototype chains in Facebook Hermes prior to commit fe52854cdf6725c2eaa9e125995da76e6ceb27da allows attackers to potentially execute arbitrary code via crafted JavaScript. Note that this is only exploitable if the application using Hermes permits evaluation of untrusted JavaScript. Hence, most React Native applications are not affected.", "project": "hermes", "idx": 195664}
{"source": " GF_Err abst_box_read(GF_Box *s, GF_BitStream *bs)\n {\n \tGF_AdobeBootstrapInfoBox *ptr = (GF_AdobeBootstrapInfoBox *)s;\n \tint i;\n \tu32 tmp_strsize;\n \tchar *tmp_str;\n \tBool zfound=GF_FALSE;\n// bug_start\n\tGF_Err e;\n// bug_end\n \n \tISOM_DECREASE_SIZE(ptr, 25)\n \tptr->bootstrapinfo_version = gf_bs_read_u32(bs);\n \tptr->profile = gf_bs_read_int(bs, 2);\n \tptr->live = gf_bs_read_int(bs, 1);\n \tptr->update = gf_bs_read_int(bs, 1);\n \tptr->reserved = gf_bs_read_int(bs, 4);\n \tptr->time_scale = gf_bs_read_u32(bs);\n \tptr->current_media_time = gf_bs_read_u64(bs);\n \tptr->smpte_time_code_offset = gf_bs_read_u64(bs);\n \n \ti=0;\n \tif (ptr->size<8) return GF_ISOM_INVALID_FILE;\n \ttmp_strsize =(u32)ptr->size;\n \ttmp_str = gf_malloc(sizeof(char)*tmp_strsize);\n \tif (!tmp_str) return GF_OUT_OF_MEM;\n \tmemset(tmp_str, 0, sizeof(char)*tmp_strsize);\n \n \twhile (tmp_strsize) {\n// bug_start\n\t\tISOM_DECREASE_SIZE(ptr, 1)\n// bug_end\n \t\ttmp_str[i] = gf_bs_read_u8(bs);\n \t\ttmp_strsize--;\n \t\tif (!tmp_str[i]) {\n \t\t\tzfound = GF_TRUE;\n \t\t\tbreak;\n \t\t}\n \t\ti++;\n \t}\n// bug_start\n\tif (!zfound)\n\t\treturn GF_ISOM_INVALID_FILE;\n// bug_end\n \tif (i) {\n \t\tptr->movie_identifier = gf_strdup(tmp_str);\n \t}\n \n// bug_start\n\tISOM_DECREASE_SIZE(ptr, 1)\n// bug_end\n \tptr->server_entry_count = gf_bs_read_u8(bs);\n \tfor (i=0; i<ptr->server_entry_count; i++) {\n \t\tint j=0;\n \t\tzfound = GF_FALSE;\n \t\ttmp_strsize=(u32)ptr->size;\n \t\twhile (tmp_strsize) {\n// bug_start\n\t\t\tISOM_DECREASE_SIZE(ptr, 1)\n// bug_end\n \t\t\ttmp_str[j] = gf_bs_read_u8(bs);\n \t\t\ttmp_strsize--;\n \t\t\tif (!tmp_str[j]) {\n \t\t\t\tzfound = GF_TRUE;\n \t\t\t\tbreak;\n \t\t\t}\n \t\t\tj++;\n \t\t}\n// bug_start\n\t\tif (!zfound)\n\t\t\treturn GF_ISOM_INVALID_FILE;\n// bug_end\n \t\tif (j) {\n \t\t\tgf_list_insert(ptr->server_entry_table, gf_strdup(tmp_str), i);\n \t\t}\n \t}\n// bug_start\n// bug_end\n \n// bug_start\n\tISOM_DECREASE_SIZE(ptr, 1)\n// bug_end\n \tptr->quality_entry_count = gf_bs_read_u8(bs);\n \tfor (i=0; i<ptr->quality_entry_count; i++) {\n \t\tint j=0;\n \t\tzfound = GF_FALSE;\n \t\ttmp_strsize=(u32)ptr->size;\n \t\twhile (tmp_strsize) {\n// bug_start\n\t\t\tISOM_DECREASE_SIZE(ptr, 1)\n// bug_end\n \t\t\ttmp_str[j] = gf_bs_read_u8(bs);\n \t\t\ttmp_strsize--;\n \t\t\tif (!tmp_str[j]) {\n \t\t\t\tzfound = GF_TRUE;\n \t\t\t\tbreak;\n \t\t\t}\n \t\t\tj++;\n \t\t}\n \n// bug_start\n\t\tif (!zfound)\n\t\t\treturn GF_ISOM_INVALID_FILE;\n// bug_end\n \t\tif (j) {\n \t\t\tgf_list_insert(ptr->quality_entry_table, gf_strdup(tmp_str), i);\n \t\t}\n// bug_start\n// bug_end\n \t}\n \n \ti=0;\n \ttmp_strsize=(u32)ptr->size;\n \tzfound = GF_FALSE;\n \twhile (tmp_strsize) {\n// bug_start\n\t\tISOM_DECREASE_SIZE(ptr, 1)\n// bug_end\n \t\ttmp_str[i] = gf_bs_read_u8(bs);\n \t\ttmp_strsize--;\n \t\tif (!tmp_str[i]) {\n \t\t\tzfound = GF_TRUE;\n \t\t\tbreak;\n \t\t}\n \t\ti++;\n \t}\n// bug_start\n\tif (!zfound)\n\t\treturn GF_ISOM_INVALID_FILE;\n// bug_end\n \tif (i) {\n \t\tptr->drm_data = gf_strdup(tmp_str);\n \t}\n \n \ti=0;\n \ttmp_strsize=(u32)ptr->size;\n \tzfound = GF_FALSE;\n \twhile (tmp_strsize) {\n// bug_start\n\t\tISOM_DECREASE_SIZE(ptr, 1)\n// bug_end\n \t\ttmp_str[i] = gf_bs_read_u8(bs);\n \t\ttmp_strsize--;\n \t\tif (!tmp_str[i]) {\n \t\t\tzfound = GF_TRUE;\n \t\t\tbreak;\n \t\t}\n \t\ti++;\n \t}\n// bug_start\n\tif (!zfound)\n\t\treturn GF_ISOM_INVALID_FILE;\n// bug_end\n \tif (i) {\n \t\tptr->meta_data = gf_strdup(tmp_str);\n \t}\n \n// bug_start\n\tISOM_DECREASE_SIZE(ptr, 1)\n// bug_end\n \tptr->segment_run_table_count = gf_bs_read_u8(bs);\n \tfor (i=0; i<ptr->segment_run_table_count; i++) {\n \t\tGF_AdobeSegmentRunTableBox *asrt = NULL;\n \t\te = gf_isom_box_parse((GF_Box **)&asrt, bs);\n \t\tif (e) {\n \t\t\tif (asrt) gf_isom_box_del((GF_Box*)asrt);\n// bug_start\n\t\t\tgf_free(tmp_str);\n\t\t\treturn e;\n// bug_end\n \t\t}\n \t\tgf_list_add(ptr->segment_run_table_entries, asrt);\n \t}\n// bug_start\n// bug_end\n \n// bug_start\n\tISOM_DECREASE_SIZE(ptr, 1)\n// bug_end\n \tptr->fragment_run_table_count = gf_bs_read_u8(bs);\n \tfor (i=0; i<ptr->fragment_run_table_count; i++) {\n \t\tGF_AdobeFragmentRunTableBox *afrt = NULL;\n \t\te = gf_isom_box_parse((GF_Box **)&afrt, bs);\n \t\tif (e) {\n \t\t\tif (afrt) gf_isom_box_del((GF_Box*)afrt);\n// bug_start\n\t\t\tgf_free(tmp_str);\n\t\t\treturn e;\n// bug_end\n \t\t}\n \t\tgf_list_add(ptr->fragment_run_table_entries, afrt);\n \t}\n// bug_start\n// bug_end\n \n// bug_start\n// bug_end\n \tgf_free(tmp_str);\n// bug_start\n\n\treturn GF_OK;\n// bug_end\n }\n \n", "target": "// fix_start\n\tGF_Err e = GF_OK;\n// fix_end\n// fix_start\n\t\tISOM_DECREASE_SIZE_GOTO_EXIT(ptr, 1)\n// fix_end\n// fix_start\n\tif (!zfound) {\n\t\te = GF_ISOM_INVALID_FILE;\n\t\tgoto exit;\n\t}\n// fix_end\n// fix_start\n\tISOM_DECREASE_SIZE_GOTO_EXIT(ptr, 1)\n// fix_end\n// fix_start\n\t\t\tISOM_DECREASE_SIZE_GOTO_EXIT(ptr, 1)\n// fix_end\n// fix_start\n\t\tif (!zfound) {\n\t\t\te = GF_ISOM_INVALID_FILE;\n\t\t\tgoto exit;\n\t\t}\n// fix_end\n// fix_start\n\tif (ptr->server_entry_count != gf_list_count(ptr->server_entry_table)) {\n\t\te = GF_ISOM_INVALID_FILE;\n\t\tgoto exit;\n\t}\n// fix_end\n// fix_start\n\tISOM_DECREASE_SIZE_GOTO_EXIT(ptr, 1)\n// fix_end\n// fix_start\n\t\t\tISOM_DECREASE_SIZE_GOTO_EXIT(ptr, 1)\n// fix_end\n// fix_start\n\t\tif (!zfound) {\n\t\t\te = GF_ISOM_INVALID_FILE;\n\t\t\tgoto exit;\n\t\t}\n// fix_end\n// fix_start\n\t}\n\tif (ptr->quality_entry_count != gf_list_count(ptr->quality_entry_table)) {\n\t\te = GF_ISOM_INVALID_FILE;\n\t\tgoto exit;\n// fix_end\n// fix_start\n\t\tISOM_DECREASE_SIZE_GOTO_EXIT(ptr, 1)\n// fix_end\n// fix_start\n\tif (!zfound) {\n\t\te = GF_ISOM_INVALID_FILE;\n\t\tgoto exit;\n\t}\n\n// fix_end\n// fix_start\n\t\tISOM_DECREASE_SIZE_GOTO_EXIT(ptr, 1)\n// fix_end\n// fix_start\n\tif (!zfound) {\n\t\te = GF_ISOM_INVALID_FILE;\n\t\tgoto exit;\n\t}\n\n// fix_end\n// fix_start\n\tISOM_DECREASE_SIZE_GOTO_EXIT(ptr, 1)\n// fix_end\n// fix_start\n\t\t\tgoto exit;\n// fix_end\n// fix_start\n\tif (ptr->segment_run_table_count != gf_list_count(ptr->segment_run_table_entries)) {\n\t\te = GF_ISOM_INVALID_FILE;\n\t\tgoto exit;\n\t}\n// fix_end\n// fix_start\n\tISOM_DECREASE_SIZE_GOTO_EXIT(ptr, 1)\n// fix_end\n// fix_start\n\t\t\tgoto exit;\n// fix_end\n// fix_start\n\tif (ptr->fragment_run_table_count != gf_list_count(ptr->fragment_run_table_entries)) {\n\t\te = GF_ISOM_INVALID_FILE;\n\t\tgoto exit;\n\t}\n// fix_end\n// fix_start\nexit:\n// fix_end\n// fix_start\n\treturn e;\n// fix_end\n", "cwe": "CWE-476", "cwe_name": "NULL Pointer Dereference", "cve": "CVE-2021-32132", "cve_desc": "The abst_box_size function in GPAC 1.0.1 allows attackers to cause a denial of service (NULL pointer dereference) via a crafted file in the MP4Box command.", "project": "gpac", "idx": 195679}
{"source": " void sqlite3Fts5UnicodeAscii(u8 *aArray, u8 *aAscii){\n   int i = 0;\n   int iTbl = 0;\n   while( i<128 ){\n     int bToken = aArray[ aFts5UnicodeData[iTbl] & 0x1F ];\n     int n = (aFts5UnicodeData[iTbl] >> 5) + i;\n     for(; i<128 && i<n; i++){\n       aAscii[i] = (u8)bToken;\n     }\n     iTbl++;\n   }\n// bug_start\n// bug_end\n }\n \n", "target": "// fix_start\n  aAscii[0] = 0;\n// fix_end\n", "cwe": "CWE-787", "cwe_name": "Out-of-bounds Write", "cve": "CVE-2021-20223", "cve_desc": "Rejected reason: DO NOT USE THIS CANDIDATE NUMBER. ConsultIDs: none. Reason: This candidate was withdrawn by its CNA. Further investigation showed that it was not a security issue. Notes: none.", "project": "sqlite", "idx": 195680}
{"source": " int32_t *enc_untrusted_create_wait_queue() {\n   MessageWriter input;\n   MessageReader output;\n   input.Push<uint64_t>(sizeof(int32_t));\n   const auto status = NonSystemCallDispatcher(\n       ::asylo::host_call::kLocalLifetimeAllocHandler, &input, &output);\n   CheckStatusAndParamCount(status, output, \"enc_untrusted_create_wait_queue\",\n                            2);\n   int32_t *queue = reinterpret_cast<int32_t *>(output.next<uintptr_t>());\n// bug_start\n// bug_end\n   int klinux_errno = output.next<int>();\n   if (queue == nullptr) {\n     errno = FromkLinuxErrorNumber(klinux_errno);\n   }\n   enc_untrusted_disable_waiting(queue);\n   return queue;\n }\n \n", "target": "// fix_start\n  if (!TrustedPrimitives::IsOutsideEnclave(queue, sizeof(int32_t))) {\n    TrustedPrimitives::BestEffortAbort(\n        \"enc_untrusted_create_wait_queue: queue should be in untrusted memory\");\n  }\n// fix_end\n", "cwe": "CWE-787", "cwe_name": "Out-of-bounds Write", "cve": "CVE-2020-8937", "cve_desc": "An arbitrary memory overwrite vulnerability in Asylo versions up to 0.6.0 allows an attacker to make a host call to enc_untrusted_create_wait_queue that uses a pointer queue that relies on UntrustedLocalMemcpy, which fails to validate where the pointer is located. This allows an attacker to write memory values from within the enclave. We recommend upgrading past commit a37fb6a0e7daf30134dbbf357c9a518a1026aa02", "project": "asylo", "idx": 195697}
{"source": " bool CClient::OnTextMessage(CTextMessage& Message) {\n     CString sTargets = Message.GetTarget();\n \n     VCString vTargets;\n     sTargets.Split(\",\", vTargets, false);\n \n     for (CString& sTarget : vTargets) {\n         Message.SetTarget(sTarget);\n         if (m_pNetwork) {\n             Message.SetChan(m_pNetwork->FindChan(sTarget));\n         }\n \n         if (sTarget.TrimPrefix(m_pUser->GetStatusPrefix())) {\n// bug_start\n// bug_end\n             if (sTarget.Equals(\"status\")) {\n                 CString sMsg = Message.GetText();\n                 UserCommand(sMsg);\n             } else {\n                 CALLMOD(sTarget, this, m_pUser, m_pNetwork,\n                         OnModCommand(Message.GetText()));\n             }\n             continue;\n         }\n \n         bool bContinue = false;\n         NETWORKMODULECALL(OnUserTextMessage(Message), m_pUser, m_pNetwork, this,\n                           &bContinue);\n         if (bContinue) continue;\n \n         if (!GetIRCSock()) {\n             if (!sTarget.Equals(m_sNick))\n                 PutStatus(\n                     t_f(\"Your message to {1} got lost, you are not connected \"\n                         \"to IRC!\")(Message.GetTarget()));\n             continue;\n         }\n \n         if (m_pNetwork) {\n             AddBuffer(Message);\n             EchoMessage(Message);\n             PutIRC(Message.ToString(CMessage::ExcludePrefix |\n                                     CMessage::ExcludeTags));\n         }\n     }\n \n     return true;\n }\n \n", "target": "// fix_start\n            EchoMessage(Message);\n\n// fix_end\n", "cwe": "CWE-476", "cwe_name": "NULL Pointer Dereference", "cve": "CVE-2020-13775", "cve_desc": "ZNC 1.8.0 up to 1.8.1-rc1 allows authenticated users to trigger an application crash (with a NULL pointer dereference) if echo-message is not enabled and there is no network.", "project": "znc", "idx": 195717}
{"source": " GF_Err Media_CheckDataEntry(GF_MediaBox *mdia, u32 dataEntryIndex)\n {\n// bug_start\n\n// bug_end\n \tGF_DataEntryURLBox *entry;\n \tGF_DataMap *map;\n \tGF_Err e;\n \tif (!mdia || !dataEntryIndex || dataEntryIndex > gf_list_count(mdia->information->dataInformation->dref->child_boxes)) return GF_BAD_PARAM;\n \n \tentry = (GF_DataEntryURLBox*)gf_list_get(mdia->information->dataInformation->dref->child_boxes, dataEntryIndex - 1);\n \tif (!entry) return GF_ISOM_INVALID_FILE;\n \tif (entry->flags == 1) return GF_OK;\n \n// bug_start\n\tif (entry->type == GF_ISOM_BOX_TYPE_URN) return GF_NOT_SUPPORTED;\n// bug_end\n \tif (mdia->mediaTrack->moov->mov->openMode == GF_ISOM_OPEN_WRITE) {\n \t\te = gf_isom_datamap_new(entry->location, NULL, GF_ISOM_DATA_MAP_READ, &map);\n \t} else {\n \t\te = gf_isom_datamap_new(entry->location, mdia->mediaTrack->moov->mov->fileName, GF_ISOM_DATA_MAP_READ, &map);\n \t}\n \tif (e) return e;\n \tgf_isom_datamap_del(map);\n \treturn GF_OK;\n }\n \n", "target": "// fix_start\n// fix_end\n// fix_start\n\tif ((entry->type != GF_ISOM_BOX_TYPE_URL) && (entry->type != GF_QT_BOX_TYPE_ALIS) )\n\t\treturn GF_NOT_SUPPORTED;\n\n// fix_end\n", "cwe": "CWE-787", "cwe_name": "Out-of-bounds Write", "cve": "CVE-2021-32137", "cve_desc": "Heap buffer overflow in the URL_GetProtocolType function in MP4Box in GPAC 1.0.1 allows attackers to cause a denial of service or execute arbitrary code via a crafted file.", "project": "gpac", "idx": 195719}
{"source": " R_API void r_core_fini(RCore *c) {\n \tif (!c) {\n \t\treturn;\n \t}\n \tr_core_task_break_all (&c->tasks);\n \tr_core_task_join (&c->tasks, NULL, -1);\n \tr_core_wait (c);\n \tr_list_free (c->ropchain);\n \tr_event_free (c->ev);\n \tfree (c->cmdlog);\n \tfree (c->lastsearch);\n \tR_FREE (c->cons->pager);\n \tfree (c->cmdqueue);\n \tfree (c->lastcmd);\n \tfree (c->stkcmd);\n \tr_list_free (c->visual.tabs);\n \tfree (c->block);\n \tr_core_autocomplete_free (c->autocomplete);\n \n \tr_list_free (c->gadgets);\n \tr_list_free (c->undos);\n \tr_num_free (c->num);\n// bug_start\n\tfree (c->table_query);\n// bug_end\n \tr_list_free (c->files);\n \tr_list_free (c->watchers);\n \tr_list_free (c->scriptstack);\n \tr_core_task_scheduler_fini (&c->tasks);\n \tc->rcmd = r_cmd_free (c->rcmd);\n \tr_list_free (c->cmd_descriptors);\n \tc->anal = r_anal_free (c->anal);\n \tr_asm_free (c->assembler);\n \tc->assembler = NULL;\n \tc->print = r_print_free (c->print);\n \tc->bin = (r_bin_free (c->bin), NULL);\n \tc->lang = (r_lang_free (c->lang), NULL);\n \tc->dbg = (r_debug_free (c->dbg), NULL);\n \tr_io_free (c->io);\n \tr_config_free (c->config);\n \tr_cons_free ();\n \tr_cons_singleton ()->teefile = NULL;\n \tr_search_free (c->search);\n \tr_flag_free (c->flags);\n \tr_fs_free (c->fs);\n \tr_egg_free (c->egg);\n \tr_lib_free (c->lib);\n \tr_buf_free (c->yank_buf);\n \tr_agraph_free (c->graph);\n \tfree (c->asmqjmps);\n \tsdb_free (c->sdb);\n \tr_core_log_free (c->log);\n \tr_parse_free (c->parser);\n \tfree (c->times);\n }\n \n", "target": "// fix_start\n\tR_FREE (c->table_query);\n// fix_end\n", "cwe": "CWE-703", "cwe_name": "Improper Check or Handling of Exceptional Conditions", "cve": "CVE-2020-27794", "cve_desc": "A double free issue was discovered in radare2 in cmd_info.c:cmd_info(). Successful exploitation could lead to modification of unexpected memory locations and potentially causing a crash.", "project": "radare2", "idx": 195727}
{"source": " inline void ComputeInterpolationWeights(\n     const int64 out_size, const int64 in_size, const float scale,\n     const int resolution, InterpolationCache<T_SCALE>* interpolation) {\n   const Scaler scaler;\n   interpolation->lower.resize(out_size + 1);\n   interpolation->upper.resize(out_size + 1);\n   interpolation->lerp.resize(out_size + 1);\n   interpolation->ilerp.resize(out_size + 1);\n \n   interpolation->lower[out_size] = 0;\n   interpolation->upper[out_size] = 0;\n   for (int64 i = out_size - 1; i >= 0; --i) {\n     const float in = scaler(i, scale);\n     const float in_f = std::floor(in);\n     interpolation->lower[i] =\n         std::max(static_cast<int64>(in_f), static_cast<int64>(0));\n     interpolation->upper[i] =\n         std::min(static_cast<int64>(std::ceil(in)), in_size - 1);\n// bug_start\n// bug_end\n     interpolation->lerp[i] = in - in_f;\n     interpolation->ilerp[i] =\n         static_cast<T_SCALE>((in - in_f) * (1 << resolution));\n   }\n }\n \n", "target": "// fix_start\n    interpolation->lower[i] =\n        std::min(interpolation->lower[i], interpolation->upper[i]);\n// fix_end\n", "cwe": "CWE-369", "cwe_name": "Divide By Zero", "cve": "CVE-2021-29529", "cve_desc": "TensorFlow is an end-to-end open source platform for machine learning. An attacker can trigger a heap buffer overflow in `tf.raw_ops.QuantizedResizeBilinear` by manipulating input values so that float rounding results in off-by-one error in accessing image elements. This is because the implementation(https://github.com/tensorflow/tensorflow/blob/44b7f486c0143f68b56c34e2d01e146ee445134a/tensorflow/core/kernels/quantized_resize_bilinear_op.cc#L62-L66) computes two integers (representing the upper and lower bounds for interpolation) by ceiling and flooring a floating point value. For some values of `in`, `interpolation->upper[i]` might be smaller than `interpolation->lower[i]`. This is an issue if `interpolation->upper[i]` is capped at `in_size-1` as it means that `interpolation->lower[i]` points outside of the image. Then, in the interpolation code(https://github.com/tensorflow/tensorflow/blob/44b7f486c0143f68b56c34e2d01e146ee445134a/tensorflow/core/kernels/quantized_resize_bilinear_op.cc#L245-L264), this would result in heap buffer overflow. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.", "project": "tensorflow", "idx": 195747}
{"source": "   void Compute(OpKernelContext* ctx) override {\n     const Tensor& in0 = ctx->input(0);\n     const Tensor& in1 = ctx->input(1);\n \n     ValidateInputTensors(ctx, in0, in1);\n// bug_start\n// bug_end\n \n     MatMulBCast bcast(in0.shape().dim_sizes(), in1.shape().dim_sizes());\n     OP_REQUIRES(\n         ctx, bcast.IsValid(),\n         errors::InvalidArgument(\n             \"In[0] and In[1] must have compatible batch dimensions: \",\n             in0.shape().DebugString(), \" vs. \", in1.shape().DebugString()));\n \n     TensorShape out_shape = bcast.output_batch_shape();\n     auto batch_size = bcast.output_batch_size();\n     auto d0 = in0.dim_size(in0.dims() - 2);\n     auto d1 = in0.dim_size(in0.dims() - 1);\n     Tensor in0_reshaped;\n     OP_REQUIRES(\n         ctx,\n         in0_reshaped.CopyFrom(in0, TensorShape({bcast.x_batch_size(), d0, d1})),\n         errors::Internal(\"Failed to reshape In[0] from \",\n                          in0.shape().DebugString()));\n     auto d2 = in1.dim_size(in1.dims() - 2);\n     auto d3 = in1.dim_size(in1.dims() - 1);\n     Tensor in1_reshaped;\n     OP_REQUIRES(\n         ctx,\n         in1_reshaped.CopyFrom(in1, TensorShape({bcast.y_batch_size(), d2, d3})),\n         errors::Internal(\"Failed to reshape In[1] from \",\n                          in1.shape().DebugString()));\n     OP_REQUIRES(ctx, d1 == d2,\n                 errors::InvalidArgument(\n                     \"In[0] mismatch In[1] shape: \", d1, \" vs. \", d2, \": \",\n                     in0.shape().DebugString(), \" \", in1.shape().DebugString(),\n                     \" \", lower_, \" \", adjoint_));\n     out_shape.AddDim(d1);\n     out_shape.AddDim(d3);\n     Tensor* out = nullptr;\n     OP_REQUIRES_OK(ctx, ctx->allocate_output(0, out_shape, &out));\n     if (out->NumElements() == 0) {\n       return;\n     }\n     Tensor out_reshaped;\n     OP_REQUIRES(ctx,\n                 out_reshaped.CopyFrom(*out, TensorShape({batch_size, d1, d3})),\n                 errors::Internal(\"Failed to reshape output from \",\n                                  out->shape().DebugString()));\n     LaunchBatchBandedTriangularSolve<Scalar>::Launch(\n         ctx, in0_reshaped, in1_reshaped, adjoint_, lower_, bcast,\n         &out_reshaped);\n   }\n \n", "target": "// fix_start\n    if (!ctx->status().ok()) return;\n// fix_end\n", "cwe": "CWE-787", "cwe_name": "Out-of-bounds Write", "cve": "CVE-2021-29612", "cve_desc": "TensorFlow is an end-to-end open source platform for machine learning. An attacker can trigger a heap buffer overflow in Eigen implementation of `tf.raw_ops.BandedTriangularSolve`. The implementation(https://github.com/tensorflow/tensorflow/blob/eccb7ec454e6617738554a255d77f08e60ee0808/tensorflow/core/kernels/linalg/banded_triangular_solve_op.cc#L269-L278) calls `ValidateInputTensors` for input validation but fails to validate that the two tensors are not empty. Furthermore, since `OP_REQUIRES` macro only stops execution of current function after setting `ctx->status()` to a non-OK value, callers of helper functions that use `OP_REQUIRES` must check value of `ctx->status()` before continuing. This doesn't happen in this op's implementation(https://github.com/tensorflow/tensorflow/blob/eccb7ec454e6617738554a255d77f08e60ee0808/tensorflow/core/kernels/linalg/banded_triangular_solve_op.cc#L219), hence the validation that is present is also not effective. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.", "project": "tensorflow", "idx": 195754}
{"source": " Status PyArrayDescr_to_TF_DataType(PyArray_Descr* descr,\n                                    TF_DataType* out_tf_datatype) {\n   PyObject* key;\n   PyObject* value;\n   Py_ssize_t pos = 0;\n// bug_start\n// bug_end\n   if (PyDict_Next(descr->fields, &pos, &key, &value)) {\n     const char* key_string =\n         PyBytes_Check(key) ? PyBytes_AsString(key)\n                            : PyBytes_AsString(PyUnicode_AsASCIIString(key));\n     if (!key_string) {\n       return errors::Internal(\"Corrupt numpy type descriptor\");\n     }\n     tensorflow::string key = key_string;\n     if (key == \"quint8\") {\n       *out_tf_datatype = TF_QUINT8;\n     } else if (key == \"qint8\") {\n       *out_tf_datatype = TF_QINT8;\n     } else if (key == \"qint16\") {\n       *out_tf_datatype = TF_QINT16;\n     } else if (key == \"quint16\") {\n       *out_tf_datatype = TF_QUINT16;\n     } else if (key == \"qint32\") {\n       *out_tf_datatype = TF_QINT32;\n     } else if (key == \"resource\") {\n       *out_tf_datatype = TF_RESOURCE;\n     } else {\n       return errors::Internal(\"Unsupported numpy data type\");\n     }\n     return Status::OK();\n   }\n   return errors::Internal(\"Unsupported numpy data type\");\n }\n \n", "target": "// fix_start\n\n  if (descr->fields == nullptr) {\n    return errors::Internal(\"Unexpected numpy data type\");\n  }\n\n// fix_end\n", "cwe": "CWE-476", "cwe_name": "NULL Pointer Dereference", "cve": "CVE-2021-29513", "cve_desc": "TensorFlow is an end-to-end open source platform for machine learning. Calling TF operations with tensors of non-numeric types when the operations expect numeric tensors result in null pointer dereferences. The conversion from Python array to C++ array(https://github.com/tensorflow/tensorflow/blob/ff70c47a396ef1e3cb73c90513da4f5cb71bebba/tensorflow/python/lib/core/ndarray_tensor.cc#L113-L169) is vulnerable to a type confusion. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.", "project": "tensorflow", "idx": 195755}
{"source": " vq_endchains(struct virtio_vq_info *vq, int used_all_avail)\n {\n \tstruct virtio_base *base;\n \tuint16_t event_idx, new_idx, old_idx;\n \tint intr;\n// bug_start\n// bug_end\n \n \n \tatomic_thread_fence();\n \n \tbase = vq->base;\n \told_idx = vq->save_used;\n \tvq->save_used = new_idx = vq->used->idx;\n \tif (used_all_avail &&\n \t    (base->negotiated_caps & (1 << VIRTIO_F_NOTIFY_ON_EMPTY)))\n \t\tintr = 1;\n \telse if (base->negotiated_caps & (1 << VIRTIO_RING_F_EVENT_IDX)) {\n \t\tevent_idx = VQ_USED_EVENT_IDX(vq);\n \t\tintr = (uint16_t)(new_idx - event_idx - 1) <\n \t\t\t(uint16_t)(new_idx - old_idx);\n \t} else {\n \t\tintr = new_idx != old_idx &&\n \t\t    !(vq->avail->flags & VRING_AVAIL_F_NO_INTERRUPT);\n \t}\n \tif (intr)\n \t\tvq_interrupt(base, vq);\n }\n \n", "target": "// fix_start\n\n\tif (!vq || !vq->used)\n\t\treturn;\n// fix_end\n", "cwe": "CWE-476", "cwe_name": "NULL Pointer Dereference", "cve": "CVE-2021-36143", "cve_desc": "ACRN before 2.5 has a hw/pci/virtio/virtio.c vq_endchains NULL Pointer Dereference.", "project": "acrn-hypervisor", "idx": 195776}
{"source": "   void ComputeEasyCases(OpKernelContext* context, bool* done,\n                         std::vector<Tlen>* split_sizes_vec) {\n     const int32_t num_split = context->num_outputs();\n     const Tensor& input = context->input(0);\n     const TensorShape& input_shape = input.shape();\n     const Tensor& split_tensor = context->input(1);\n     const Tensor& split_dim_tensor = context->input(2);\n \n     OP_REQUIRES(context, split_dim_tensor.NumElements() == 1,\n                 errors::InvalidArgument(\"split_dim_tensor must have \"\n                                         \"exactly one element.\"));\n \n     const int32_t split_dim_orig = split_dim_tensor.flat<int32>()(0);\n     const int32_t split_dim =\n         split_dim_orig < 0 ? split_dim_orig + input.dims() : split_dim_orig;\n \n     OP_REQUIRES(\n         context,\n         split_tensor.dims() == 1 && split_tensor.NumElements() == num_split,\n         errors::InvalidArgument(\"size of the split_tensor must be 1-D and have \"\n                                 \"the same elements as outputs got \",\n                                 split_tensor.dims(), \" -D and \",\n                                 split_tensor.NumElements(), \" elements\"));\n \n     auto split_sizes_d = split_tensor.vec<Tlen>();\n \n     split_sizes_vec->resize(split_sizes_d.size());\n \n     std::copy(split_sizes_d.data(), split_sizes_d.data() + split_sizes_d.size(),\n               split_sizes_vec->begin());\n \n     OP_REQUIRES(\n         context, num_split > 0,\n         errors::InvalidArgument(\n             \"Number of ways to split should be > 0, but got \", num_split));\n \n     OP_REQUIRES(\n         context, 0 <= split_dim && split_dim < input.dims(),\n         errors::InvalidArgument(\"-input rank(-\", input.dims(),\n                                 \") <= split_dim < input rank (\", input.dims(),\n                                 \"), but got \", split_dim_orig));\n \n     Tlen input_size_split_dim = input_shape.dim_size(split_dim);\n \n     if (num_split == 1) {\n       context->set_output(0, context->input(0));\n       OP_REQUIRES(\n           context, (*split_sizes_vec)[0] == input_size_split_dim,\n           errors::InvalidArgument(\"If there is only one output, it must have \"\n                                   \"the same size as the input. Input size: \",\n                                   input_size_split_dim,\n                                   \" output size: \", (*split_sizes_vec)[0]));\n       *done = true;\n       return;\n     }\n \n     int neg_one_dim = -1;\n     Tlen determined_size = 0;\n     for (int d = 0; d < split_sizes_vec->size(); ++d) {\n       Tlen size = (*split_sizes_vec)[d];\n \n       if (size == -1) {\n         OP_REQUIRES(context, neg_one_dim == -1,\n                     errors::InvalidArgument(\"There can only be one -1 in the \"\n                                             \"input.\"));\n         neg_one_dim = d;\n       } else {\n         determined_size += size;\n       }\n     }\n \n     OP_REQUIRES(\n         context,\n         (neg_one_dim == -1 && determined_size == input_size_split_dim) ||\n             (neg_one_dim >= 0 && determined_size <= input_size_split_dim),\n         errors::InvalidArgument(\"Determined shape must either match \"\n                                 \"input shape along split_dim exactly if \"\n                                 \"fully specified, or be less than the size of \"\n                                 \"the input along split_dim if not fully \"\n                                 \"specified.  Got: \",\n                                 determined_size));\n \n     if (neg_one_dim >= 0) {\n       (*split_sizes_vec)[neg_one_dim] = input_size_split_dim - determined_size;\n     }\n \n// bug_start\n// bug_end\n     if (SplitHasAlignedOutputsInFirstDimension(\n             input_shape, split_dim, absl::MakeConstSpan(*split_sizes_vec))) {\n       Tlen start = 0;\n       for (int i = 0; i < num_split; ++i) {\n         context->set_output(i,\n                             input.Slice(start, start + (*split_sizes_vec)[i]));\n         start += (*split_sizes_vec)[i];\n       }\n       *done = true;\n       return;\n     }\n   }\n \n", "target": "// fix_start\n    for (int i = 0; i < split_sizes_vec->size(); ++i) {\n      const Tlen& split_size = (*split_sizes_vec)[i];\n      OP_REQUIRES(context, split_size >= Tlen(0),\n                  errors::InvalidArgument(\"Split size at index \", i,\n                                          \" must be >= 0. Got: \", split_size));\n    }\n\n// fix_end\n", "cwe": "CWE-703", "cwe_name": "Improper Check or Handling of Exceptional Conditions", "cve": "CVE-2021-41222", "cve_desc": "TensorFlow is an open source platform for machine learning. In affected versions the implementation of `SplitV` can trigger a segfault is an attacker supplies negative arguments. This occurs whenever `size_splits` contains more than one value and at least one value is negative. The fix will be included in TensorFlow 2.7.0. We will also cherrypick this commit on TensorFlow 2.6.1, TensorFlow 2.5.2, and TensorFlow 2.4.4, as these are also affected and still in supported range.", "project": "tensorflow", "idx": 195778}
{"source": " int processClientServerHello(struct ndpi_detection_module_struct *ndpi_struct,\n \t\t\t     struct ndpi_flow_struct *flow, uint32_t quic_version) {\n   struct ndpi_packet_struct *packet = &flow->packet;\n   union ja3_info ja3;\n   u_int8_t invalid_ja3 = 0;\n   u_int16_t tls_version, ja3_str_len;\n   char ja3_str[JA3_STR_LEN];\n   ndpi_MD5_CTX ctx;\n   u_char md5_hash[16];\n   int i;\n   u_int16_t total_len;\n   u_int8_t handshake_type;\n   char buffer[64] = { '\\0' };\n   int is_quic = (quic_version != 0);\n   int is_dtls = packet->udp && (!is_quic);\n \n #ifdef DEBUG_TLS\n   printf(\"TLS %s() called\\n\", __FUNCTION__);\n #endif\n \n   memset(&ja3, 0, sizeof(ja3));\n \n   handshake_type = packet->payload[0];\n   total_len = (packet->payload[1] << 16) +  (packet->payload[2] << 8) + packet->payload[3];\n \n   if((total_len > packet->payload_packet_len) || (packet->payload[1] != 0x0))\n     return(0);\n \n   total_len = packet->payload_packet_len;\n \n   if(total_len > 4) {\n     u_int16_t base_offset    = (!is_dtls) ? 38 : 46;\n     u_int16_t version_offset = (!is_dtls) ? 4 : 12;\n     u_int16_t offset = (!is_dtls) ? 38 : 46, extension_len, j;\n     u_int8_t  session_id_len =  0;\n \n     if((base_offset >= total_len) ||\n        (version_offset + 1) >= total_len)\n       return 0;\n \n     session_id_len = packet->payload[base_offset];\n \n #ifdef DEBUG_TLS\n     printf(\"TLS [len: %u][handshake_type: %02X]\\n\", packet->payload_packet_len, handshake_type);\n #endif\n \n     tls_version = ntohs(*((u_int16_t*)&packet->payload[version_offset]));\n \n     if(handshake_type == 0x02 ) {\n       int i, rc;\n \n       ja3.server.tls_handshake_version = tls_version;\n \n #ifdef DEBUG_TLS\n       printf(\"TLS Server Hello [version: 0x%04X]\\n\", tls_version);\n #endif\n \n       if(packet->udp)\n \toffset += session_id_len + 1;\n       else {\n \tif(tls_version < 0x7F15 )\n \t  offset += session_id_len+1;\n       }\n \n       if((offset+3) > packet->payload_packet_len)\n \treturn(0);\n \n       ja3.server.num_cipher = 1, ja3.server.cipher[0] = ntohs(*((u_int16_t*)&packet->payload[offset]));\n       if((flow->protos.tls_quic_stun.tls_quic.server_unsafe_cipher = ndpi_is_safe_ssl_cipher(ja3.server.cipher[0])) == 1)\n \tndpi_set_risk(flow, NDPI_TLS_WEAK_CIPHER);\n \n       flow->protos.tls_quic_stun.tls_quic.server_cipher = ja3.server.cipher[0];\n \n #ifdef DEBUG_TLS\n       printf(\"TLS [server][session_id_len: %u][cipher: %04X]\\n\", session_id_len, ja3.server.cipher[0]);\n #endif\n \n       offset += 2 + 1;\n \n       if((offset + 1) < packet->payload_packet_len)\n \textension_len = ntohs(*((u_int16_t*)&packet->payload[offset]));\n       else\n \textension_len = 0;\n \n #ifdef DEBUG_TLS\n       printf(\"TLS [server][extension_len: %u]\\n\", extension_len);\n #endif\n       offset += 2;\n \n       for(i=0; i<extension_len; ) {\n \tu_int16_t extension_id, extension_len;\n \n \tif((offset+4) > packet->payload_packet_len) break;\n \n \textension_id  = ntohs(*((u_int16_t*)&packet->payload[offset]));\n \textension_len = ntohs(*((u_int16_t*)&packet->payload[offset+2]));\n \n \tif(ja3.server.num_tls_extension < MAX_NUM_JA3)\n \t  ja3.server.tls_extension[ja3.server.num_tls_extension++] = extension_id;\n \n #ifdef DEBUG_TLS\n \tprintf(\"TLS [server][extension_id: %u/0x%04X][len: %u]\\n\",\n \t       extension_id, extension_id, extension_len);\n #endif\n \n \tif(extension_id == 43 ) {\n \t  if(extension_len >= 2) {\n \t    u_int16_t tls_version = ntohs(*((u_int16_t*)&packet->payload[offset+4]));\n \n #ifdef DEBUG_TLS\n \t    printf(\"TLS [server] [TLS version: 0x%04X]\\n\", tls_version);\n #endif\n \n \t    flow->protos.tls_quic_stun.tls_quic.ssl_version = ja3.server.tls_supported_version = tls_version;\n \t  }\n \t} else if(extension_id == 16 ) {\n \t  u_int16_t s_offset = offset+4;\n \t  u_int16_t tot_alpn_len = ntohs(*((u_int16_t*)&packet->payload[s_offset]));\n \t  char alpn_str[256];\n \t  u_int8_t alpn_str_len = 0, i;\n \n #ifdef DEBUG_TLS\n \t  printf(\"Server TLS [ALPN: block_len=%u/len=%u]\\n\", extension_len, tot_alpn_len);\n #endif\n \t  s_offset += 2;\n \t  tot_alpn_len += s_offset;\n \n \t  while(s_offset < tot_alpn_len && s_offset < total_len) {\n \t    u_int8_t alpn_i, alpn_len = packet->payload[s_offset++];\n \n \t    if((s_offset + alpn_len) <= tot_alpn_len) {\n #ifdef DEBUG_TLS\n \t      printf(\"Server TLS [ALPN: %u]\\n\", alpn_len);\n #endif\n \n \t      if((alpn_str_len+alpn_len+1) < (sizeof(alpn_str)-1)) {\n \t        if(alpn_str_len > 0) {\n \t          alpn_str[alpn_str_len] = ',';\n \t          alpn_str_len++;\n \t        }\n \n \t        for(alpn_i=0; alpn_i<alpn_len; alpn_i++)\n \t        {\n \t          alpn_str[alpn_str_len+alpn_i] = packet->payload[s_offset+alpn_i];\n \t        }\n \n \t        s_offset += alpn_len, alpn_str_len += alpn_len;;\n \t      } else {\n \t        ndpi_set_risk(flow, NDPI_TLS_UNCOMMON_ALPN);\n \t        break;\n \t      }\n \t    } else {\n \t      ndpi_set_risk(flow, NDPI_TLS_UNCOMMON_ALPN);\n \t      break;\n \t    }\n \t  }\n \n \t  alpn_str[alpn_str_len] = '\\0';\n \n #ifdef DEBUG_TLS\n \t  printf(\"Server TLS [ALPN: %s][len: %u]\\n\", alpn_str, alpn_str_len);\n #endif\n \t  if(flow->protos.tls_quic_stun.tls_quic.alpn == NULL)\n \t    flow->protos.tls_quic_stun.tls_quic.alpn = ndpi_strdup(alpn_str);\n \n \t  if(flow->protos.tls_quic_stun.tls_quic.alpn != NULL)\n \t    tlsCheckUncommonALPN(flow);\n \n \t  snprintf(ja3.server.alpn, sizeof(ja3.server.alpn), \"%s\", alpn_str);\n \n \t  for(i=0; ja3.server.alpn[i] != '\\0'; i++)\n \t    if(ja3.server.alpn[i] == ',') ja3.server.alpn[i] = '-';\n \t} else if(extension_id == 11 ) {\n \t  u_int16_t s_offset = offset+4 + 1;\n \n #ifdef DEBUG_TLS\n \t  printf(\"Server TLS [EllipticCurveFormat: len=%u]\\n\", extension_len);\n #endif\n \t  if((s_offset+extension_len-1) <= total_len) {\n \t    for(i=0; i<extension_len-1; i++) {\n \t      u_int8_t s_group = packet->payload[s_offset+i];\n \n #ifdef DEBUG_TLS\n \t      printf(\"Server TLS [EllipticCurveFormat: %u]\\n\", s_group);\n #endif\n \n \t      if(ja3.server.num_elliptic_curve_point_format < MAX_NUM_JA3)\n \t\tja3.server.elliptic_curve_point_format[ja3.server.num_elliptic_curve_point_format++] = s_group;\n \t      else {\n \t\tinvalid_ja3 = 1;\n #ifdef DEBUG_TLS\n \t\tprintf(\"Server TLS Invalid num elliptic %u\\n\", ja3.server.num_elliptic_curve_point_format);\n #endif\n \t      }\n \t    }\n \t  } else {\n \t    invalid_ja3 = 1;\n #ifdef DEBUG_TLS\n \t    printf(\"Server TLS Invalid len %u vs %u\\n\", s_offset+extension_len, total_len);\n #endif\n \t  }\n \t}\n \n \ti += 4 + extension_len, offset += 4 + extension_len;\n       }\n \n// bug_start\n      ja3_str_len = snprintf(ja3_str, sizeof(ja3_str), \"%u,\", ja3.server.tls_handshake_version);\n\n      for(i=0; i<ja3.server.num_cipher; i++) {\n\trc = snprintf(&ja3_str[ja3_str_len], sizeof(ja3_str)-ja3_str_len, \"%s%u\", (i > 0) ? \"-\" : \"\", ja3.server.cipher[i]);\n// bug_end\n \n \tif(rc <= 0) break; else ja3_str_len += rc;\n       }\n \n// bug_start\n      rc = snprintf(&ja3_str[ja3_str_len], sizeof(ja3_str)-ja3_str_len, \",\");\n      if(rc > 0 && ja3_str_len + rc < JA3_STR_LEN) ja3_str_len += rc;\n\n\n      for(i=0; i<ja3.server.num_tls_extension; i++) {\n\tint rc = snprintf(&ja3_str[ja3_str_len], sizeof(ja3_str)-ja3_str_len, \"%s%u\", (i > 0) ? \"-\" : \"\", ja3.server.tls_extension[i]);\n// bug_end\n \n \tif(rc <= 0) break; else ja3_str_len += rc;\n       }\n \n       if(ndpi_struct->enable_ja3_plus) {\n// bug_start\n\tfor(i=0; i<ja3.server.num_elliptic_curve_point_format; i++) {\n\t  rc = snprintf(&ja3_str[ja3_str_len], sizeof(ja3_str)-ja3_str_len, \"%s%u\",\n// bug_end\n \t\t\t(i > 0) ? \"-\" : \"\", ja3.server.elliptic_curve_point_format[i]);\n \t  if((rc > 0) && (ja3_str_len + rc < JA3_STR_LEN)) ja3_str_len += rc; else break;\n \t}\n \n// bug_start\n\tif(ja3.server.alpn[0] != '\\0') {\n\t  rc = snprintf(&ja3_str[ja3_str_len], sizeof(ja3_str)-ja3_str_len, \",%s\", ja3.server.alpn);\n// bug_end\n \t  if((rc > 0) && (ja3_str_len + rc < JA3_STR_LEN)) ja3_str_len += rc;\n \t}\n \n #ifdef DEBUG_TLS\n \tprintf(\"[JA3+] Server: %s \\n\", ja3_str);\n #endif\n       } else {\n #ifdef DEBUG_TLS\n \tprintf(\"[JA3] Server: %s \\n\", ja3_str);\n #endif\n       }\n \n       ndpi_MD5Init(&ctx);\n       ndpi_MD5Update(&ctx, (const unsigned char *)ja3_str, strlen(ja3_str));\n       ndpi_MD5Final(md5_hash, &ctx);\n \n       for(i=0, j=0; i<16; i++) {\n \tint rc = snprintf(&flow->protos.tls_quic_stun.tls_quic.ja3_server[j],\n \t\t\t  sizeof(flow->protos.tls_quic_stun.tls_quic.ja3_server)-j, \"%02x\", md5_hash[i]);\n \tif(rc <= 0) break; else j += rc;\n       }\n \n #ifdef DEBUG_TLS\n       printf(\"[JA3] Server: %s \\n\", flow->protos.tls_quic_stun.tls_quic.ja3_server);\n #endif\n     } else if(handshake_type == 0x01 ) {\n       u_int16_t cipher_len, cipher_offset;\n       u_int8_t cookie_len = 0;\n \n       flow->protos.tls_quic_stun.tls_quic.ssl_version = ja3.client.tls_handshake_version = tls_version;\n       if(flow->protos.tls_quic_stun.tls_quic.ssl_version < 0x0302)\n \tndpi_set_risk(flow, NDPI_TLS_OBSOLETE_VERSION);\n \n       if((session_id_len+base_offset+3) > packet->payload_packet_len)\n \treturn(0);\n \n       if(!is_dtls) {\n \tcipher_len = packet->payload[session_id_len+base_offset+2] + (packet->payload[session_id_len+base_offset+1] << 8);\n \tcipher_offset = base_offset + session_id_len + 3;\n       } else {\n \tcookie_len = packet->payload[base_offset+session_id_len+1];\n #ifdef DEBUG_TLS\n \tprintf(\"[JA3] Client: DTLS cookie len %d\\n\", cookie_len);\n #endif\n \tif((session_id_len+base_offset+cookie_len+4) > packet->payload_packet_len)\n \t  return(0);\n \tcipher_len = ntohs(*((u_int16_t*)&packet->payload[base_offset+session_id_len+cookie_len+2]));\n \tcipher_offset = base_offset + session_id_len + cookie_len + 4;\n       }\n \n #ifdef DEBUG_TLS\n       printf(\"Client TLS [client cipher_len: %u][tls_version: 0x%04X]\\n\", cipher_len, tls_version);\n #endif\n \n       if((cipher_offset+cipher_len) <= total_len) {\n \tu_int8_t safari_ciphers = 0, chrome_ciphers = 0;\n \n \tfor(i=0; i<cipher_len;) {\n \t  u_int16_t *id = (u_int16_t*)&packet->payload[cipher_offset+i];\n \n #ifdef DEBUG_TLS\n \t  printf(\"Client TLS [cipher suite: %u/0x%04X] [%d/%u]\\n\", ntohs(*id), ntohs(*id), i, cipher_len);\n #endif\n \t  if((*id == 0) || (packet->payload[cipher_offset+i] != packet->payload[cipher_offset+i+1])) {\n \t    u_int16_t cipher_id = ntohs(*id);\n \n \t    if(ja3.client.num_cipher < MAX_NUM_JA3)\n \t      ja3.client.cipher[ja3.client.num_cipher++] = cipher_id;\n \t    else {\n \t      invalid_ja3 = 1;\n #ifdef DEBUG_TLS\n \t      printf(\"Client TLS Invalid cipher %u\\n\", ja3.client.num_cipher);\n #endif\n \t    }\n \n \t    switch(cipher_id) {\n \t    case TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256:\n \t    case TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384:\n \t      safari_ciphers++;\n \t      break;\n \n \t    case TLS_CIPHER_GREASE_RESERVED_0:\n \t    case TLS_AES_128_GCM_SHA256:\n \t    case TLS_AES_256_GCM_SHA384:\n \t    case TLS_CHACHA20_POLY1305_SHA256:\n \t      chrome_ciphers++;\n \t      break;\n \n \t    case TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_SHA256:\n \t    case TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384:\n \t    case TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256:\n \t    case TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256:\n \t    case TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA:\n \t    case TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA:\n \t    case TLS_RSA_WITH_AES_128_CBC_SHA:\n \t    case TLS_RSA_WITH_AES_256_CBC_SHA:\n \t    case TLS_RSA_WITH_AES_128_GCM_SHA256:\n \t    case TLS_RSA_WITH_AES_256_GCM_SHA384:\n \t      safari_ciphers++, chrome_ciphers++;\n \t      break;\n \t    }\n \t  }\n \n \t  i += 2;\n \t}\n \n \tif(chrome_ciphers == 13)\n \t  flow->protos.tls_quic_stun.tls_quic.browser_euristics.is_chrome_tls = 1;\n \telse if(safari_ciphers == 12)\n \t  flow->protos.tls_quic_stun.tls_quic.browser_euristics.is_safari_tls = 1;\n       } else {\n \tinvalid_ja3 = 1;\n #ifdef DEBUG_TLS\n \tprintf(\"Client TLS Invalid len %u vs %u\\n\", (cipher_offset+cipher_len), total_len);\n #endif\n       }\n \n       offset = base_offset + session_id_len + cookie_len + cipher_len + 2;\n       offset += (!is_dtls) ? 1 : 2;\n \n       if(offset < total_len) {\n \tu_int16_t compression_len;\n \tu_int16_t extensions_len;\n \n \tcompression_len = packet->payload[offset];\n \toffset++;\n \n #ifdef DEBUG_TLS\n \tprintf(\"Client TLS [compression_len: %u]\\n\", compression_len);\n #endif\n \n \toffset += compression_len;\n \n \tif(offset+1 < total_len) {\n \t  extensions_len = ntohs(*((u_int16_t*)&packet->payload[offset]));\n \t  offset += 2;\n \n #ifdef DEBUG_TLS\n \t  printf(\"Client TLS [extensions_len: %u]\\n\", extensions_len);\n #endif\n \n \t  if((extensions_len+offset) <= total_len) {\n \t    u_int extension_offset = 0;\n \t    u_int32_t j;\n \n \t    while(extension_offset < extensions_len &&\n \t\t  offset+extension_offset+4 <= total_len) {\n \t      u_int16_t extension_id, extension_len, extn_off = offset+extension_offset;\n \n \n \t      extension_id = ntohs(*((u_int16_t*)&packet->payload[offset+extension_offset]));\n \t      extension_offset += 2;\n \n \t      extension_len = ntohs(*((u_int16_t*)&packet->payload[offset+extension_offset]));\n \t      extension_offset += 2;\n \n #ifdef DEBUG_TLS\n \t      printf(\"Client TLS [extension_id: %u][extension_len: %u]\\n\", extension_id, extension_len);\n #endif\n \n \t      if((extension_id == 0) || (packet->payload[extn_off] != packet->payload[extn_off+1])) {\n \n \t\tif(ja3.client.num_tls_extension < MAX_NUM_JA3)\n \t\t  ja3.client.tls_extension[ja3.client.num_tls_extension++] = extension_id;\n \t\telse {\n \t\t  invalid_ja3 = 1;\n #ifdef DEBUG_TLS\n \t\t  printf(\"Client TLS Invalid extensions %u\\n\", ja3.client.num_tls_extension);\n #endif\n \t\t}\n \t      }\n \n \t      if(extension_id == 0 ) {\n \t\tu_int16_t len;\n \n #ifdef DEBUG_TLS\n \t\tprintf(\"[TLS] Extensions: found server name\\n\");\n #endif\n \t\tif((offset+extension_offset+4) < packet->payload_packet_len) {\n \n \t\t  len = (packet->payload[offset+extension_offset+3] << 8) + packet->payload[offset+extension_offset+4];\n \t\t  len = (u_int)ndpi_min(len, sizeof(buffer)-1);\n \n \t\t  if((offset+extension_offset+5+len) <= packet->payload_packet_len) {\n \t\t    strncpy(buffer, (char*)&packet->payload[offset+extension_offset+5], len);\n \t\t    buffer[len] = '\\0';\n \n \t\t    cleanupServerName(buffer, sizeof(buffer));\n \n \t\t    snprintf(flow->protos.tls_quic_stun.tls_quic.client_requested_server_name,\n \t\t\t     sizeof(flow->protos.tls_quic_stun.tls_quic.client_requested_server_name),\n \t\t\t     \"%s\", buffer);\n #ifdef DEBUG_TLS\n \t\t    printf(\"[TLS] SNI: [%s]\\n\", buffer);\n #endif\n \t\t    if(!is_quic) {\n \t\t      if(ndpi_match_hostname_protocol(ndpi_struct, flow, NDPI_PROTOCOL_TLS, buffer, strlen(buffer)))\n \t\t        flow->l4.tcp.tls.subprotocol_detected = 1;\n \t\t    } else {\n \t\t      if(ndpi_match_hostname_protocol(ndpi_struct, flow, NDPI_PROTOCOL_QUIC, buffer, strlen(buffer)))\n \t\t        flow->l4.tcp.tls.subprotocol_detected = 1;\n \t\t    }\n \n \t\t    if(ndpi_check_dga_name(ndpi_struct, flow,\n \t\t\t\t\t   flow->protos.tls_quic_stun.tls_quic.client_requested_server_name, 1)) {\n \t\t      char *sni = flow->protos.tls_quic_stun.tls_quic.client_requested_server_name;\n \t\t      int len = strlen(sni);\n \n #ifdef DEBUG_TLS\n \t\t      printf(\"[TLS] SNI: (DGA) [%s]\\n\", flow->protos.tls_quic_stun.tls_quic.client_requested_server_name);\n #endif\n \n \t\t      if((len >= 4)\n \t\t         && ((strcmp(&sni[len-4], \".com\") == 0) || (strcmp(&sni[len-4], \".net\") == 0))\n \t\t         && (strncmp(sni, \"www.\", 4) == 0))\n \t\t        ndpi_set_detected_protocol(ndpi_struct, flow, NDPI_PROTOCOL_TOR, NDPI_PROTOCOL_TLS);\n \t\t    } else {\n #ifdef DEBUG_TLS\n \t\t      printf(\"[TLS] SNI: (NO DGA) [%s]\\n\", flow->protos.tls_quic_stun.tls_quic.client_requested_server_name);\n #endif\n \t\t    }\n \t\t  } else {\n #ifdef DEBUG_TLS\n \t\t    printf(\"[TLS] Extensions server len too short: %u vs %u\\n\",\n \t\t\t   offset+extension_offset+5+len,\n \t\t\t   packet->payload_packet_len);\n #endif\n \t\t  }\n \t\t}\n \t      } else if(extension_id == 10 ) {\n \t\tu_int16_t s_offset = offset+extension_offset + 2;\n \n #ifdef DEBUG_TLS\n \t\tprintf(\"Client TLS [EllipticCurveGroups: len=%u]\\n\", extension_len);\n #endif\n \n \t\tif((s_offset+extension_len-2) <= total_len) {\n \t\t  for(i=0; i<extension_len-2;) {\n \t\t    u_int16_t s_group = ntohs(*((u_int16_t*)&packet->payload[s_offset+i]));\n \n #ifdef DEBUG_TLS\n \t\t    printf(\"Client TLS [EllipticCurve: %u/0x%04X]\\n\", s_group, s_group);\n #endif\n \t\t    if((s_group == 0) || (packet->payload[s_offset+i] != packet->payload[s_offset+i+1])) {\n \t\t      if(ja3.client.num_elliptic_curve < MAX_NUM_JA3)\n \t\t\tja3.client.elliptic_curve[ja3.client.num_elliptic_curve++] = s_group;\n \t\t      else {\n \t\t\tinvalid_ja3 = 1;\n #ifdef DEBUG_TLS\n \t\t\tprintf(\"Client TLS Invalid num elliptic %u\\n\", ja3.client.num_elliptic_curve);\n #endif\n \t\t      }\n \t\t    }\n \n \t\t    i += 2;\n \t\t  }\n \t\t} else {\n \t\t  invalid_ja3 = 1;\n #ifdef DEBUG_TLS\n \t\t  printf(\"Client TLS Invalid len %u vs %u\\n\", (s_offset+extension_len-1), total_len);\n #endif\n \t\t}\n \t      } else if(extension_id == 11 ) {\n \t\tu_int16_t s_offset = offset+extension_offset + 1;\n \n #ifdef DEBUG_TLS\n \t\tprintf(\"Client TLS [EllipticCurveFormat: len=%u]\\n\", extension_len);\n #endif\n \t\tif((s_offset+extension_len-1) <= total_len) {\n \t\t  for(i=0; i<extension_len-1; i++) {\n \t\t    u_int8_t s_group = packet->payload[s_offset+i];\n \n #ifdef DEBUG_TLS\n \t\t    printf(\"Client TLS [EllipticCurveFormat: %u]\\n\", s_group);\n #endif\n \n \t\t    if(ja3.client.num_elliptic_curve_point_format < MAX_NUM_JA3)\n \t\t      ja3.client.elliptic_curve_point_format[ja3.client.num_elliptic_curve_point_format++] = s_group;\n \t\t    else {\n \t\t      invalid_ja3 = 1;\n #ifdef DEBUG_TLS\n \t\t      printf(\"Client TLS Invalid num elliptic %u\\n\", ja3.client.num_elliptic_curve_point_format);\n #endif\n \t\t    }\n \t\t  }\n \t\t} else {\n \t\t  invalid_ja3 = 1;\n #ifdef DEBUG_TLS\n \t\t  printf(\"Client TLS Invalid len %u vs %u\\n\", s_offset+extension_len, total_len);\n #endif\n \t\t}\n \t      } else if(extension_id == 13 ) {\n \t\tu_int16_t s_offset = offset+extension_offset, safari_signature_algorithms = 0, chrome_signature_algorithms = 0;\n \t\tu_int16_t tot_signature_algorithms_len = ntohs(*((u_int16_t*)&packet->payload[s_offset]));\n \n #ifdef DEBUG_TLS\n \t\tprintf(\"Client TLS [SIGNATURE_ALGORITHMS: block_len=%u/len=%u]\\n\", extension_len, tot_signature_algorithms_len);\n #endif\n \n \t\ts_offset += 2;\n \t\ttot_signature_algorithms_len = ndpi_min((sizeof(ja3.client.signature_algorithms) / 2) - 1, tot_signature_algorithms_len);\n \n #ifdef TLS_HANDLE_SIGNATURE_ALGORITMS\n \t\tflow->protos.tls_quic_stun.tls_quic.num_tls_signature_algorithms = ndpi_min(tot_signature_algorithms_len / 2, MAX_NUM_TLS_SIGNATURE_ALGORITHMS);\n \n \t\tmemcpy(flow->protos.tls_quic_stun.tls_quic.client_signature_algorithms,\n \t\t       &packet->payload[s_offset], 2 *flow->protos.tls_quic_stun.tls_quic.num_tls_signature_algorithms);\n #endif\n \n \t\tfor(i=0; i<tot_signature_algorithms_len; i++) {\n \t\t  int rc = snprintf(&ja3.client.signature_algorithms[i*2], sizeof(ja3.client.signature_algorithms)-i*2, \"%02X\", packet->payload[s_offset+i]);\n \n \t\t  if(rc < 0) break;\n \t\t}\n \n \t\tfor(i=0; i<tot_signature_algorithms_len; i+=2) {\n \t\t  u_int16_t cipher_id = (u_int16_t)ntohs(*((u_int16_t*)&packet->payload[s_offset+i]));\n \n \n \t\t  switch(cipher_id) {\n \t\t  case ECDSA_SECP521R1_SHA512:\n \t\t    flow->protos.tls_quic_stun.tls_quic.browser_euristics.is_firefox_tls = 1;\n \t\t    break;\n \n \t\t  case ECDSA_SECP256R1_SHA256:\n \t\t  case ECDSA_SECP384R1_SHA384:\n \t\t  case RSA_PKCS1_SHA256:\n \t\t  case RSA_PKCS1_SHA384:\n \t\t  case RSA_PKCS1_SHA512:\n \t\t  case RSA_PSS_RSAE_SHA256:\n \t\t  case RSA_PSS_RSAE_SHA384:\n \t\t  case RSA_PSS_RSAE_SHA512:\n \t\t    chrome_signature_algorithms++, safari_signature_algorithms++;\n \t\t    break;\n \t\t  }\n \t\t}\n \n \t\tif(flow->protos.tls_quic_stun.tls_quic.browser_euristics.is_firefox_tls)\n \t\t  flow->protos.tls_quic_stun.tls_quic.browser_euristics.is_safari_tls = 0,\n \t\t    flow->protos.tls_quic_stun.tls_quic.browser_euristics.is_chrome_tls = 0;\n \n \t\tif(safari_signature_algorithms != 8)\n \t\t   flow->protos.tls_quic_stun.tls_quic.browser_euristics.is_safari_tls = 0;\n \n \t\tif(chrome_signature_algorithms != 8)\n \t\t   flow->protos.tls_quic_stun.tls_quic.browser_euristics.is_chrome_tls = 0;\n \n \t\tja3.client.signature_algorithms[i*2] = '\\0';\n \n #ifdef DEBUG_TLS\n \t\tprintf(\"Client TLS [SIGNATURE_ALGORITHMS: %s]\\n\", ja3.client.signature_algorithms);\n #endif\n \t      } else if(extension_id == 16 ) {\n \t\tu_int16_t s_offset = offset+extension_offset;\n \t\tu_int16_t tot_alpn_len = ntohs(*((u_int16_t*)&packet->payload[s_offset]));\n \t\tchar alpn_str[256];\n \t\tu_int8_t alpn_str_len = 0, i;\n \n #ifdef DEBUG_TLS\n \t\tprintf(\"Client TLS [ALPN: block_len=%u/len=%u]\\n\", extension_len, tot_alpn_len);\n #endif\n \t\ts_offset += 2;\n \t\ttot_alpn_len += s_offset;\n \n \t\twhile(s_offset < tot_alpn_len && s_offset < total_len) {\n \t\t  u_int8_t alpn_i, alpn_len = packet->payload[s_offset++];\n \n \t\t  if((s_offset + alpn_len) <= tot_alpn_len &&\n \t\t     (s_offset + alpn_len) <= total_len) {\n #ifdef DEBUG_TLS\n \t\t    printf(\"Client TLS [ALPN: %u]\\n\", alpn_len);\n #endif\n \n \t\t    if((alpn_str_len+alpn_len+1) < (sizeof(alpn_str)-1)) {\n \t\t      if(alpn_str_len > 0) {\n \t\t\talpn_str[alpn_str_len] = ',';\n \t\t\talpn_str_len++;\n \t\t      }\n \n \t\t      for(alpn_i=0; alpn_i<alpn_len; alpn_i++)\n \t\t\talpn_str[alpn_str_len+alpn_i] = packet->payload[s_offset+alpn_i];\n \n \t\t      s_offset += alpn_len, alpn_str_len += alpn_len;;\n \t\t    } else\n \t\t      break;\n \t\t  } else\n \t\t    break;\n \t\t}\n \n \t\talpn_str[alpn_str_len] = '\\0';\n \n #ifdef DEBUG_TLS\n \t\tprintf(\"Client TLS [ALPN: %s][len: %u]\\n\", alpn_str, alpn_str_len);\n #endif\n \t\tif(flow->protos.tls_quic_stun.tls_quic.alpn == NULL)\n \t\t  flow->protos.tls_quic_stun.tls_quic.alpn = ndpi_strdup(alpn_str);\n \n \t\tsnprintf(ja3.client.alpn, sizeof(ja3.client.alpn), \"%s\", alpn_str);\n \n \t\tfor(i=0; ja3.client.alpn[i] != '\\0'; i++)\n \t\t  if(ja3.client.alpn[i] == ',') ja3.client.alpn[i] = '-';\n \n \t      } else if(extension_id == 43 ) {\n \t\tu_int16_t s_offset = offset+extension_offset;\n \t\tu_int8_t version_len = packet->payload[s_offset];\n \t\tchar version_str[256];\n \t\tu_int8_t version_str_len = 0;\n \t\tversion_str[0] = 0;\n #ifdef DEBUG_TLS\n \t\tprintf(\"Client TLS [TLS version len: %u]\\n\", version_len);\n #endif\n \n \t\tif(version_len == (extension_len-1)) {\n \t\t  u_int8_t j;\n \t\t  u_int16_t supported_versions_offset = 0;\n \n \t\t  s_offset++;\n \n \t\t  for(j=0; j+1<version_len; j += 2) {\n \t\t    u_int16_t tls_version = ntohs(*((u_int16_t*)&packet->payload[s_offset+j]));\n \t\t    u_int8_t unknown_tls_version;\n \n #ifdef DEBUG_TLS\n \t\t    printf(\"Client TLS [TLS version: %s/0x%04X]\\n\",\n \t\t\t   ndpi_ssl_version2str(flow, tls_version, &unknown_tls_version), tls_version);\n #endif\n \n \t\t    if((version_str_len+8) < sizeof(version_str)) {\n \t\t      int rc = snprintf(&version_str[version_str_len],\n \t\t\t\t\tsizeof(version_str) - version_str_len, \"%s%s\",\n \t\t\t\t\t(version_str_len > 0) ? \",\" : \"\",\n \t\t\t\t\tndpi_ssl_version2str(flow, tls_version, &unknown_tls_version));\n \t\t      if(rc <= 0)\n \t\t\tbreak;\n \t\t      else\n \t\t\tversion_str_len += rc;\n \n \t\t      rc = snprintf(&ja3.client.supported_versions[supported_versions_offset],\n \t\t\t\t    sizeof(ja3.client.supported_versions)-supported_versions_offset,\n \t\t\t\t    \"%s%04X\", (j > 0) ? \"-\" : \"\", tls_version);\n \n \t\t      if(rc > 0)\n \t\t\tsupported_versions_offset += rc;\n \t\t    }\n \t\t  }\n \n #ifdef DEBUG_TLS\n \t\t  printf(\"Client TLS [SUPPORTED_VERSIONS: %s]\\n\", ja3.client.supported_versions);\n #endif\n \n \t\t  if(flow->protos.tls_quic_stun.tls_quic.tls_supported_versions == NULL)\n \t\t    flow->protos.tls_quic_stun.tls_quic.tls_supported_versions = ndpi_strdup(version_str);\n \t\t}\n \t      } else if(extension_id == 65486 ) {\n \t\tu_int16_t e_offset = offset+extension_offset;\n \t\tu_int16_t initial_offset = e_offset;\n \t\tu_int16_t e_sni_len, cipher_suite = ntohs(*((u_int16_t*)&packet->payload[e_offset]));\n \n \t\tflow->protos.tls_quic_stun.tls_quic.encrypted_sni.cipher_suite = cipher_suite;\n \n \t\te_offset += 2;\n \n \t\te_offset += 2;\n \t\te_offset +=  ntohs(*((u_int16_t*)&packet->payload[e_offset])) + 2;\n \n \t\tif((e_offset+4) < packet->payload_packet_len) {\n \t\t  e_offset +=  ntohs(*((u_int16_t*)&packet->payload[e_offset])) + 2;\n \n \t\t  if((e_offset+4) < packet->payload_packet_len) {\n \t\t    e_sni_len = ntohs(*((u_int16_t*)&packet->payload[e_offset]));\n \t\t    e_offset += 2;\n \n \t\t    if((e_offset+e_sni_len-extension_len-initial_offset) >= 0 &&\n \t\t        e_offset+e_sni_len < packet->payload_packet_len) {\n #ifdef DEBUG_ENCRYPTED_SNI\n \t\t      printf(\"Client TLS [Encrypted Server Name len: %u]\\n\", e_sni_len);\n #endif\n \n \t\t      if(flow->protos.tls_quic_stun.tls_quic.encrypted_sni.esni == NULL) {\n \t\t\tflow->protos.tls_quic_stun.tls_quic.encrypted_sni.esni = (char*)ndpi_malloc(e_sni_len*2+1);\n \n \t\t\tif(flow->protos.tls_quic_stun.tls_quic.encrypted_sni.esni) {\n \t\t\t  u_int16_t i, off;\n \n \t\t\t  for(i=e_offset, off=0; i<(e_offset+e_sni_len); i++) {\n \t\t\t    int rc = sprintf(&flow->protos.tls_quic_stun.tls_quic.encrypted_sni.esni[off], \"%02X\", packet->payload[i] & 0XFF);\n \n \t\t\t    if(rc <= 0) {\n \t\t\t      flow->protos.tls_quic_stun.tls_quic.encrypted_sni.esni[off] = '\\0';\n \t\t\t      break;\n \t\t\t    } else\n \t\t\t      off += rc;\n \t\t\t  }\n \t\t\t}\n \t\t      }\n \t\t    }\n \t\t  }\n \t\t}\n \t      } else if(extension_id == 65445 ||\n \t\t        extension_id == 57) {\n \t\tu_int16_t s_offset = offset+extension_offset;\n \t\tuint16_t final_offset;\n \t\tint using_var_int = is_version_with_var_int_transport_params(quic_version);\n \n \t\tif(!using_var_int) {\n \t\t  if(s_offset+1 >= total_len) {\n \t\t    final_offset = 0;\n \t\t  } else {\n \t\t    u_int16_t seq_len = ntohs(*((u_int16_t*)&packet->payload[s_offset]));\n \t\t    s_offset += 2;\n \t            final_offset = MIN(total_len, s_offset + seq_len);\n \t\t  }\n \t\t} else {\n \t          final_offset = MIN(total_len, s_offset + extension_len);\n \t\t}\n \n \t\twhile(s_offset < final_offset) {\n \t\t  u_int64_t param_type, param_len;\n \n                   if(!using_var_int) {\n \t\t    if(s_offset+3 >= final_offset)\n \t\t      break;\n \t\t    param_type = ntohs(*((u_int16_t*)&packet->payload[s_offset]));\n \t\t    param_len = ntohs(*((u_int16_t*)&packet->payload[s_offset + 2]));\n \t\t    s_offset += 4;\n \t\t  } else {\n \t\t    if(s_offset >= final_offset ||\n \t\t       (s_offset + quic_len_buffer_still_required(packet->payload[s_offset])) >= final_offset)\n \t\t      break;\n \t\t    s_offset += quic_len(&packet->payload[s_offset], &param_type);\n \n \t\t    if(s_offset >= final_offset ||\n \t\t       (s_offset + quic_len_buffer_still_required(packet->payload[s_offset])) >= final_offset)\n \t\t      break;\n \t\t    s_offset += quic_len(&packet->payload[s_offset], &param_len);\n \t\t  }\n \n #ifdef DEBUG_TLS\n \t\t  printf(\"Client TLS [QUIC TP: Param 0x%x Len %d]\\n\", (int)param_type, (int)param_len);\n #endif\n \t\t  if(s_offset+param_len > final_offset)\n \t\t    break;\n \n \t\t  if(param_type==0x3129) {\n #ifdef DEBUG_TLS\n \t\t      printf(\"UA [%.*s]\\n\", (int)param_len, &packet->payload[s_offset]);\n #endif\n \t\t      http_process_user_agent(ndpi_struct, flow,\n \t\t\t\t\t      &packet->payload[s_offset], param_len);\n \t\t      break;\n \t\t  }\n \t\t  s_offset += param_len;\n \t\t}\n \t      }\n \n \t      extension_offset += extension_len;\n \n #ifdef DEBUG_TLS\n \t      printf(\"Client TLS [extension_offset/len: %u/%u]\\n\", extension_offset, extension_len);\n #endif\n \t    }\n \n \t    if(!invalid_ja3) {\n \t      int rc;\n \n \t    compute_ja3c:\n// bug_start\n\t      ja3_str_len = snprintf(ja3_str, sizeof(ja3_str), \"%u,\", ja3.client.tls_handshake_version);\n// bug_end\n \n \t      for(i=0; i<ja3.client.num_cipher; i++) {\n// bug_start\n\t\trc = snprintf(&ja3_str[ja3_str_len], sizeof(ja3_str)-ja3_str_len, \"%s%u\",\n// bug_end\n \t\t\t      (i > 0) ? \"-\" : \"\", ja3.client.cipher[i]);\n \t\tif((rc > 0) && (ja3_str_len + rc < JA3_STR_LEN)) ja3_str_len += rc; else break;\n \t      }\n \n// bug_start\n\t      rc = snprintf(&ja3_str[ja3_str_len], sizeof(ja3_str)-ja3_str_len, \",\");\n// bug_end\n \t      if((rc > 0) && (ja3_str_len + rc < JA3_STR_LEN)) ja3_str_len += rc;\n \n \n \t      for(i=0; i<ja3.client.num_tls_extension; i++) {\n// bug_start\n\t\trc = snprintf(&ja3_str[ja3_str_len], sizeof(ja3_str)-ja3_str_len, \"%s%u\",\n// bug_end\n \t\t\t      (i > 0) ? \"-\" : \"\", ja3.client.tls_extension[i]);\n \t\tif((rc > 0) && (ja3_str_len + rc < JA3_STR_LEN)) ja3_str_len += rc; else break;\n \t      }\n \n// bug_start\n\t      rc = snprintf(&ja3_str[ja3_str_len], sizeof(ja3_str)-ja3_str_len, \",\");\n// bug_end\n \t      if((rc > 0) && (ja3_str_len + rc < JA3_STR_LEN)) ja3_str_len += rc;\n \n \n \t      for(i=0; i<ja3.client.num_elliptic_curve; i++) {\n// bug_start\n\t\trc = snprintf(&ja3_str[ja3_str_len], sizeof(ja3_str)-ja3_str_len, \"%s%u\",\n// bug_end\n \t\t\t      (i > 0) ? \"-\" : \"\", ja3.client.elliptic_curve[i]);\n \t\tif((rc > 0) && (ja3_str_len + rc < JA3_STR_LEN)) ja3_str_len += rc; else break;\n \t      }\n \n// bug_start\n\t      rc = snprintf(&ja3_str[ja3_str_len], sizeof(ja3_str)-ja3_str_len, \",\");\n// bug_end\n \t      if((rc > 0) && (ja3_str_len + rc < JA3_STR_LEN)) ja3_str_len += rc;\n \n \t      for(i=0; i<ja3.client.num_elliptic_curve_point_format; i++) {\n// bug_start\n\t\trc = snprintf(&ja3_str[ja3_str_len], sizeof(ja3_str)-ja3_str_len, \"%s%u\",\n// bug_end\n \t\t\t      (i > 0) ? \"-\" : \"\", ja3.client.elliptic_curve_point_format[i]);\n \t\tif((rc > 0) && (ja3_str_len + rc < JA3_STR_LEN)) ja3_str_len += rc; else break;\n \t      }\n \n \t      if(ndpi_struct->enable_ja3_plus) {\n// bug_start\n\t\trc = snprintf(&ja3_str[ja3_str_len], sizeof(ja3_str)-ja3_str_len,\n// bug_end\n \t\t\t      \",%s,%s,%s\", ja3.client.signature_algorithms, ja3.client.supported_versions, ja3.client.alpn);\n \t\tif((rc > 0) && (ja3_str_len + rc < JA3_STR_LEN)) ja3_str_len += rc;\n \t      }\n \n #ifdef DEBUG_JA3C\n \t      printf(\"[JA3+] Client: %s \\n\", ja3_str);\n #endif\n \n \t      ndpi_MD5Init(&ctx);\n \t      ndpi_MD5Update(&ctx, (const unsigned char *)ja3_str, strlen(ja3_str));\n \t      ndpi_MD5Final(md5_hash, &ctx);\n \n \t      for(i=0, j=0; i<16; i++) {\n \t\trc = snprintf(&flow->protos.tls_quic_stun.tls_quic.ja3_client[j],\n \t\t\t      sizeof(flow->protos.tls_quic_stun.tls_quic.ja3_client)-j, \"%02x\",\n \t\t\t      md5_hash[i]);\n \t\tif(rc > 0) j += rc; else break;\n \t      }\n \n #ifdef DEBUG_JA3C\n \t      printf(\"[JA3] Client: %s \\n\", flow->protos.tls_quic_stun.tls_quic.ja3_client);\n #endif\n \n \t      if(ndpi_struct->malicious_ja3_automa.ac_automa != NULL) {\n \t\tu_int16_t rc1 = ndpi_match_string(ndpi_struct->malicious_ja3_automa.ac_automa,\n \t\t\t\t\t\t  flow->protos.tls_quic_stun.tls_quic.ja3_client);\n \n \t\tif(rc1 > 0)\n \t\t  ndpi_set_risk(flow, NDPI_MALICIOUS_JA3);\n \t      }\n \t    }\n \n \t    if((flow->protos.tls_quic_stun.tls_quic.ssl_version >= 0x0303)\n \t       && (flow->protos.tls_quic_stun.tls_quic.alpn == NULL) ) {\n \t      ndpi_set_risk(flow, NDPI_TLS_NOT_CARRYING_HTTPS);\n \t    }\n \n \t    if(flow->protos.tls_quic_stun.tls_quic.encrypted_sni.esni &&\n \t       flow->protos.tls_quic_stun.tls_quic.client_requested_server_name[0] != '\\0') {\n \t      ndpi_set_risk(flow, NDPI_TLS_SUSPICIOUS_ESNI_USAGE);\n \t    }\n \n \t    if((flow->protos.tls_quic_stun.tls_quic.client_requested_server_name[0] == 0)\n \t       && (flow->protos.tls_quic_stun.tls_quic.ssl_version >= 0x0302)\n \t       && (flow->protos.tls_quic_stun.tls_quic.encrypted_sni.esni == NULL)\n \t       ) {\n \t      ndpi_set_risk(flow, NDPI_TLS_MISSING_SNI);\n \t    }\n \n \t    return(2 );\n \t  } else {\n #ifdef DEBUG_TLS\n \t    printf(\"[TLS] Client: too short [%u vs %u]\\n\",\n \t\t   (extensions_len+offset), total_len);\n #endif\n \t  }\n \t} else if(offset == total_len) {\n \t  goto compute_ja3c;\n \t}\n       } else {\n #ifdef DEBUG_TLS\n \tprintf(\"[JA3] Client: invalid length detected\\n\");\n #endif\n       }\n     }\n   }\n \n   return(0);\n }\n \n", "target": "// fix_start\n      ja3_str_len = snprintf(ja3_str, JA3_STR_LEN, \"%u,\", ja3.server.tls_handshake_version);\n\n      for(i=0; (i<ja3.server.num_cipher) && (JA3_STR_LEN > ja3_str_len); i++) {\n\trc = snprintf(&ja3_str[ja3_str_len], JA3_STR_LEN-ja3_str_len, \"%s%u\", (i > 0) ? \"-\" : \"\", ja3.server.cipher[i]);\n// fix_end\n// fix_start\n      if(JA3_STR_LEN > ja3_str_len) {\n\trc = snprintf(&ja3_str[ja3_str_len], JA3_STR_LEN-ja3_str_len, \",\");\n\tif(rc > 0 && ja3_str_len + rc < JA3_STR_LEN) ja3_str_len += rc;\n      }\n\n\n      for(i=0; (i<ja3.server.num_tls_extension) && (JA3_STR_LEN > ja3_str_len); i++) {\n\tint rc = snprintf(&ja3_str[ja3_str_len], JA3_STR_LEN-ja3_str_len, \"%s%u\", (i > 0) ? \"-\" : \"\", ja3.server.tls_extension[i]);\n// fix_end\n// fix_start\n\tfor(i=0; (i<ja3.server.num_elliptic_curve_point_format) && (JA3_STR_LEN > ja3_str_len); i++) {\n\t  rc = snprintf(&ja3_str[ja3_str_len], JA3_STR_LEN-ja3_str_len, \"%s%u\",\n// fix_end\n// fix_start\n\tif((ja3.server.alpn[0] != '\\0') && (JA3_STR_LEN > ja3_str_len)) {\n\t  rc = snprintf(&ja3_str[ja3_str_len], JA3_STR_LEN-ja3_str_len, \",%s\", ja3.server.alpn);\n// fix_end\n// fix_start\n\t      ja3_str_len = snprintf(ja3_str, JA3_STR_LEN, \"%u,\", ja3.client.tls_handshake_version);\n// fix_end\n// fix_start\n\t\trc = snprintf(&ja3_str[ja3_str_len], JA3_STR_LEN-ja3_str_len, \"%s%u\",\n// fix_end\n// fix_start\n\t      rc = snprintf(&ja3_str[ja3_str_len], JA3_STR_LEN-ja3_str_len, \",\");\n// fix_end\n// fix_start\n\t\trc = snprintf(&ja3_str[ja3_str_len], JA3_STR_LEN-ja3_str_len, \"%s%u\",\n// fix_end\n// fix_start\n\t      rc = snprintf(&ja3_str[ja3_str_len], JA3_STR_LEN-ja3_str_len, \",\");\n// fix_end\n// fix_start\n\t\trc = snprintf(&ja3_str[ja3_str_len], JA3_STR_LEN-ja3_str_len, \"%s%u\",\n// fix_end\n// fix_start\n\t      rc = snprintf(&ja3_str[ja3_str_len], JA3_STR_LEN-ja3_str_len, \",\");\n// fix_end\n// fix_start\n\t\trc = snprintf(&ja3_str[ja3_str_len], JA3_STR_LEN-ja3_str_len, \"%s%u\",\n// fix_end\n// fix_start\n\t\trc = snprintf(&ja3_str[ja3_str_len], JA3_STR_LEN-ja3_str_len,\n// fix_end\n", "cwe": "CWE-787", "cwe_name": "Out-of-bounds Write", "cve": "CVE-2021-36082", "cve_desc": "ntop nDPI 3.4 has a stack-based buffer overflow in processClientServerHello.", "project": "nDPI", "idx": 195820}
{"source": "   void DoRealForwardFFT(OpKernelContext* ctx, uint64* fft_shape,\n                         const Tensor& in, Tensor* out) {\n     const auto axes = Eigen::ArrayXi::LinSpaced(FFTRank, 1, FFTRank);\n     auto device = ctx->eigen_device<CPUDevice>();\n     auto input = Tensor(in).flat_inner_dims<RealT, FFTRank + 1>();\n     const auto input_dims = input.dimensions();\n \n     Eigen::DSizes<Eigen::DenseIndex, FFTRank + 1> input_slice_sizes;\n     input_slice_sizes[0] = input_dims[0];\n     TensorShape temp_shape{input_dims[0]};\n     for (int i = 1; i <= FFTRank; ++i) {\n       input_slice_sizes[i] = fft_shape[i - 1];\n       temp_shape.AddDim(fft_shape[i - 1]);\n     }\n// bug_start\n// bug_end\n \n     auto output = out->flat_inner_dims<ComplexT, FFTRank + 1>();\n     const Eigen::DSizes<Eigen::DenseIndex, FFTRank + 1> zero_start_indices;\n \n     Tensor temp;\n     OP_REQUIRES_OK(ctx, ctx->allocate_temp(DataTypeToEnum<ComplexT>::v(),\n                                            temp_shape, &temp));\n     auto full_fft = temp.flat_inner_dims<ComplexT, FFTRank + 1>();\n     full_fft.device(device) =\n         input.slice(zero_start_indices, input_slice_sizes)\n             .template fft<Eigen::BothParts, Eigen::FFT_FORWARD>(axes);\n \n     output.device(device) =\n         full_fft.slice(zero_start_indices, output.dimensions());\n   }\n \n", "target": "// fix_start\n    OP_REQUIRES(ctx, temp_shape.num_elements() > 0,\n                errors::InvalidArgument(\"Obtained a FFT shape of 0 elements: \",\n                                        temp_shape.DebugString()));\n// fix_end\n", "cwe": "CWE-703", "cwe_name": "Improper Check or Handling of Exceptional Conditions", "cve": "CVE-2021-29563", "cve_desc": "TensorFlow is an end-to-end open source platform for machine learning. An attacker can cause a denial of service by exploiting a `CHECK`-failure coming from the implementation of `tf.raw_ops.RFFT`. Eigen code operating on an empty matrix can trigger on an assertion and will cause program termination. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.", "project": "tensorflow", "idx": 195958}
{"source": " bool initiate_stratum(struct pool *pool)\n {\n \tchar s[RBUFSIZE], *sret = NULL, *nonce1, *sessionid;\n \tjson_t *val = NULL, *res_val, *err_val;\n \tbool ret = false, recvd = false;\n \tjson_error_t err;\n \tint n2size;\n \n \tif (!setup_stratum_curl(pool))\n \t\tgoto out;\n \n resend:\n \tif (pool->sessionid)\n \t\tsprintf(s, \"{\\\"id\\\": %d, \\\"method\\\": \\\"mining.subscribe\\\", \\\"params\\\": [\\\"%s\\\"]}\", swork_id++, pool->sessionid);\n \telse\n \t\tsprintf(s, \"{\\\"id\\\": %d, \\\"method\\\": \\\"mining.subscribe\\\", \\\"params\\\": []}\", swork_id++);\n \n \tif (!__stratum_send(pool, s, strlen(s))) {\n \t\tapplog(LOG_DEBUG, \"Failed to send s in initiate_stratum\");\n \t\tgoto out;\n \t}\n \n \tif (!socket_full(pool, true)) {\n \t\tapplog(LOG_DEBUG, \"Timed out waiting for response in initiate_stratum\");\n \t\tgoto out;\n \t}\n \n \tsret = recv_line(pool);\n \tif (!sret)\n \t\tgoto out;\n \n \trecvd = true;\n \n \tval = JSON_LOADS(sret, &err);\n \tfree(sret);\n \tif (!val) {\n \t\tapplog(LOG_INFO, \"JSON decode failed(%d): %s\", err.line, err.text);\n \t\tgoto out;\n \t}\n \n \tres_val = json_object_get(val, \"result\");\n \terr_val = json_object_get(val, \"error\");\n \n \tif (!res_val || json_is_null(res_val) ||\n \t    (err_val && !json_is_null(err_val))) {\n \t\tchar *ss;\n \n \t\tif (err_val)\n \t\t\tss = json_dumps(err_val, JSON_INDENT(3));\n \t\telse\n \t\t\tss = strdup(\"(unknown reason)\");\n \n \t\tapplog(LOG_INFO, \"JSON-RPC decode failed: %s\", ss);\n \n \t\tfree(ss);\n \n \t\tgoto out;\n \t}\n \n \tsessionid = json_array_string(json_array_get(res_val, 0), 1);\n \tif (!sessionid) {\n \t\tapplog(LOG_INFO, \"Failed to get sessionid in initiate_stratum\");\n \t\tgoto out;\n \t}\n \tnonce1 = json_array_string(res_val, 1);\n \tif (!nonce1) {\n \t\tapplog(LOG_INFO, \"Failed to get nonce1 in initiate_stratum\");\n \t\tfree(sessionid);\n \t\tgoto out;\n \t}\n \tn2size = json_integer_value(json_array_get(res_val, 2));\n// bug_start\n\tif (!n2size) {\n// bug_end\n \t\tapplog(LOG_INFO, \"Failed to get n2size in initiate_stratum\");\n \t\tfree(sessionid);\n \t\tfree(nonce1);\n \t\tgoto out;\n \t}\n \n \tmutex_lock(&pool->pool_lock);\n \tpool->sessionid = sessionid;\n \tfree(pool->nonce1);\n \tpool->nonce1 = nonce1;\n \tpool->n1_len = strlen(nonce1) / 2;\n \tpool->n2size = n2size;\n \tmutex_unlock(&pool->pool_lock);\n \n \tapplog(LOG_DEBUG, \"Pool %d stratum session id: %s\", pool->pool_no, pool->sessionid);\n \n \tret = true;\n out:\n \tif (val)\n \t\tjson_decref(val);\n \n \tif (ret) {\n \t\tif (!pool->stratum_url)\n \t\t\tpool->stratum_url = pool->sockaddr_url;\n \t\tpool->stratum_active = true;\n \t\tpool->swork.diff = 1;\n \t\tif (opt_protocol) {\n \t\t\tapplog(LOG_DEBUG, \"Pool %d confirmed mining.subscribe with extranonce1 %s extran2size %d\",\n \t\t\t       pool->pool_no, pool->nonce1, pool->n2size);\n \t\t}\n \t} else {\n \t\tif (recvd && pool->sessionid) {\n \t\t\tmutex_lock(&pool->pool_lock);\n \t\t\tfree(pool->sessionid);\n \t\t\tfree(pool->nonce1);\n \t\t\tpool->sessionid = pool->nonce1 = NULL;\n \t\t\tmutex_unlock(&pool->pool_lock);\n \t\t\tapplog(LOG_DEBUG, \"Failed to resume stratum, trying afresh\");\n \t\t\tgoto resend;\n \t\t}\n \t\tapplog(LOG_DEBUG, \"Initiate stratum failed\");\n \t\tif (pool->sock != INVSOCK) {\n \t\t\tshutdown(pool->sock, SHUT_RDWR);\n \t\t\tpool->sock = INVSOCK;\n \t\t}\n \t}\n \n \treturn ret;\n }\n \n", "target": "// fix_start\n\tif (n2size < 1)\n\t{\n// fix_end\n", "cwe": "CWE-787", "cwe_name": "Out-of-bounds Write", "cve": "CVE-2014-4502", "cve_desc": "Multiple heap-based buffer overflows in the parse_notify function in sgminer before 4.2.2, cgminer before 4.3.5, and BFGMiner before 4.1.0 allow remote pool servers to have unspecified impact via a (1) large or (2) negative value in the Extranonc2_size parameter in a mining.subscribe response and a crafted mining.notify request.", "project": "bfgminer", "idx": 195966}
{"source": "   void Compute(OpKernelContext *ctx) override {\n     const Tensor *indices_t, *values_t, *shape_t, *dense_t;\n     OP_REQUIRES_OK(ctx, ctx->input(\"sp_indices\", &indices_t));\n     OP_REQUIRES_OK(ctx, ctx->input(\"sp_values\", &values_t));\n     OP_REQUIRES_OK(ctx, ctx->input(\"sp_shape\", &shape_t));\n     OP_REQUIRES_OK(ctx, ctx->input(\"dense\", &dense_t));\n \n     OP_REQUIRES(ctx, TensorShapeUtils::IsMatrix(indices_t->shape()),\n                 errors::InvalidArgument(\n                     \"Input sp_indices should be a matrix but received shape: \",\n                     indices_t->shape().DebugString()));\n     OP_REQUIRES(ctx,\n                 TensorShapeUtils::IsVector(values_t->shape()) &&\n                     TensorShapeUtils::IsVector(shape_t->shape()),\n                 errors::InvalidArgument(\n                     \"Inputs sp_values and sp_shape should be vectors \"\n                     \"but received shapes: \",\n                     values_t->shape().DebugString(), \" and \",\n                     shape_t->shape().DebugString()));\n     OP_REQUIRES(\n         ctx, values_t->dim_size(0) == indices_t->dim_size(0),\n         errors::InvalidArgument(\n             \"The first dimension of values and indices should match. (\",\n             values_t->dim_size(0), \" vs. \", indices_t->dim_size(0), \")\"));\n \n     const auto indices_mat = indices_t->matrix<int64>();\n     const auto shape_vec = shape_t->vec<int64>();\n     const auto lhs_dims = BCast::FromShape(TensorShape(shape_vec));\n     const auto rhs_dims = BCast::FromShape(dense_t->shape());\n     BCast b(lhs_dims, rhs_dims, false);\n \n     auto VecGreaterEq = [](ArraySlice<int64> lhs, ArraySlice<int64> rhs) {\n       if (lhs.size() < rhs.size()) return false;\n       for (size_t i = 0; i < rhs.size(); ++i) {\n         if (lhs[lhs.size() - 1 - i] < rhs[rhs.size() - 1 - i]) return false;\n       }\n       return true;\n     };\n     OP_REQUIRES(ctx, VecGreaterEq(lhs_dims, rhs_dims) && b.IsValid(),\n                 errors::InvalidArgument(\n                     \"SparseDenseBinaryOpShared broadcasts dense to sparse \"\n                     \"only; got incompatible shapes: [\",\n                     absl::StrJoin(lhs_dims, \",\"), \"] vs. [\",\n                     absl::StrJoin(rhs_dims, \",\"), \"]\"));\n \n     Tensor *output_values = nullptr;\n     Tensor dense_gathered;\n     const int64 nnz = indices_t->dim_size(0);\n     OP_REQUIRES_OK(ctx,\n                    ctx->allocate_output(0, TensorShape({nnz}), &output_values));\n     OP_REQUIRES_OK(\n         ctx, ctx->allocate_temp(DataTypeToEnum<T>::value, TensorShape({nnz}),\n                                 &dense_gathered));\n// bug_start\n\n// bug_end\n     auto dense_gathered_flat = dense_gathered.flat<T>();\n     const int ndims = lhs_dims.size();\n     switch (ndims) {\n #define CASE(NDIM)                                                             \\\n   case NDIM: {                                                                 \\\n     TensorRef<Eigen::Tensor<const T, NDIM, Eigen::RowMajor>> rhs_ref =         \\\n         dense_t->shaped<T, NDIM>(b.y_reshape())                                \\\n             .broadcast(BCast::ToIndexArray<NDIM>(b.y_bcast()));                \\\n     Eigen::array<Eigen::DenseIndex, NDIM> idx;                                 \\\n     bool indices_valid = true;                                                 \\\n     for (int i = 0; i < nnz; ++i) {                                            \\\n       for (int d = 0; d < NDIM; ++d) {                                         \\\n         idx[d] = internal::SubtleMustCopy(indices_mat(i, d));                  \\\n         if (!FastBoundsCheck(idx[d], rhs_ref.dimension(d))) {                  \\\n           indices_valid = false;                                               \\\n         }                                                                      \\\n       }                                                                        \\\n       OP_REQUIRES(                                                             \\\n           ctx, indices_valid,                                                  \\\n           errors::InvalidArgument(\"Provided indices are out-of-bounds w.r.t. \" \\\n                                   \"dense side with broadcasted shape\"));       \\\n       dense_gathered_flat(i) = rhs_ref.coeff(idx);                             \\\n// bug_start\n// bug_end\n     }                                                                          \\\n     break;                                                                     \\\n   }\n \n       CASE(1);\n       CASE(2);\n       CASE(3);\n       CASE(4);\n       CASE(5);\n       default:\n         OP_REQUIRES(\n             ctx, false,\n             errors::InvalidArgument(\"Only tensors with ranks between 1 and 5 \"\n                                     \"are currently supported.  Tensor rank: \",\n                                     ndims));\n #undef CASE\n     }\n \n     output_values->flat<T>().device(ctx->eigen_device<Device>()) =\n         values_t->flat<T>().binaryExpr(dense_gathered_flat,\n                                        typename Functor::func());\n   }\n \n", "target": "// fix_start\n    bool op_is_div = false;\n    if (absl::StrContains(ctx->op_kernel().type_string_view(), \"Div\")) {\n      op_is_div = true;\n    }\n// fix_end\n// fix_start\n      if (op_is_div) {                                                         \\\n        OP_REQUIRES(ctx, dense_gathered_flat(i) != 0,                          \\\n                    errors::InvalidArgument(                                   \\\n                        \"SparseDenseCwiseDiv cannot divide by zero,\"           \\\n                        \"but input dense tensor contains zero \"));             \\\n      }                                                                        \\\n// fix_end\n", "cwe": "CWE-369", "cwe_name": "Divide By Zero", "cve": "CVE-2021-37636", "cve_desc": "TensorFlow is an end-to-end open source platform for machine learning. In affected versions the implementation of `tf.raw_ops.SparseDenseCwiseDiv` is vulnerable to a division by 0 error. The [implementation](https://github.com/tensorflow/tensorflow/blob/a1bc56203f21a5a4995311825ffaba7a670d7747/tensorflow/core/kernels/sparse_dense_binary_op_shared.cc#L56) uses a common class for all binary operations but fails to treat the division by 0 case separately. We have patched the issue in GitHub commit d9204be9f49520cdaaeb2541d1dc5187b23f31d9. The fix will be included in TensorFlow 2.6.0. We will also cherrypick this commit on TensorFlow 2.5.1, TensorFlow 2.4.3, and TensorFlow 2.3.4, as these are also affected and still in supported range.", "project": "tensorflow", "idx": 195972}
{"source": " static GF_Err av1dmx_parse_flush_sample(GF_Filter *filter, GF_AV1DmxCtx *ctx)\n {\n \tu32 pck_size;\n \tGF_FilterPacket *pck;\n \tu8 *output;\n// bug_start\n// bug_end\n \n \tgf_bs_get_content_no_truncate(ctx->state.bs, &ctx->state.frame_obus, &pck_size, &ctx->state.frame_obus_alloc);\n \n \tif (!pck_size) {\n \t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[AV1Dmx] no frame OBU, skipping OBU\\n\"));\n \t\treturn GF_OK;\n \t}\n \n \tpck = gf_filter_pck_new_alloc(ctx->opid, pck_size, &output);\n \tif (ctx->src_pck) gf_filter_pck_merge_properties(ctx->src_pck, pck);\n \n \tgf_filter_pck_set_cts(pck, ctx->cts);\n \tgf_filter_pck_set_sap(pck, ctx->state.frame_state.key_frame ? GF_FILTER_SAP_1 : 0);\n \n \tmemcpy(output, ctx->state.frame_obus, pck_size);\n \n \tif (ctx->deps) {\n \t\tu8 flags = 0;\n \t\tflags = ( ctx->state.frame_state.key_frame) ? 2 : 1;\n \t\tflags <<= 2;\n \t \tflags |= ctx->state.frame_state.refresh_frame_flags ? 1 : 2;\n \t\tflags <<= 2;\n \t \tgf_filter_pck_set_dependency_flags(pck, flags);\n \t}\n \n \tgf_filter_pck_send(pck);\n \n \tav1dmx_update_cts(ctx);\n \tgf_av1_reset_state(&ctx->state, GF_FALSE);\n \n \treturn GF_OK;\n \n }\n \n", "target": "// fix_start\n\n\tif (!ctx->opid)\n\t\treturn GF_NON_COMPLIANT_BITSTREAM;\n// fix_end\n", "cwe": "CWE-787", "cwe_name": "Out-of-bounds Write", "cve": "CVE-2021-30015", "cve_desc": "There is a Null Pointer Dereference in function filter_core/filter_pck.c:gf_filter_pck_new_alloc_internal in GPAC 1.0.1. The pid comes from function av1dmx_parse_flush_sample, the ctx.opid maybe NULL. The result is a crash in gf_filter_pck_new_alloc_internal.", "project": "gpac", "idx": 195985}
{"source": " NativeModule::NativeModule(const std::string& filename) : init(nullptr) {\n// bug_start\n// bug_end\n \tif (uv_dlopen(filename.c_str(), &lib) != 0) {\n \t\tthrow RuntimeGenericError(\"Failed to load module\");\n \t}\n \tif (uv_dlsym(&lib, \"InitForContext\", reinterpret_cast<void**>(&init)) != 0 || init == nullptr) {\n \t\tuv_dlclose(&lib);\n \t\tthrow RuntimeGenericError(\"Module is not isolated-vm compatible\");\n \t}\n }\n \n", "target": "// fix_start\n\tif (!IsolateEnvironment::GetCurrent()->IsDefault()) {\n\t\tthrow RuntimeGenericError(\"NativeModule may only be instantiated from default nodejs isolate\");\n\t}\n// fix_end\n", "cwe": "CWE-703", "cwe_name": "Improper Check or Handling of Exceptional Conditions", "cve": "CVE-2021-21413", "cve_desc": "isolated-vm is a library for nodejs which gives you access to v8's Isolate interface. Versions of isolated-vm before v4.0.0 have API pitfalls which may make it easy for implementers to expose supposed secure isolates to the permissions of the main nodejs isolate. Reference objects allow access to the underlying reference's full prototype chain. In an environment where the implementer has exposed a Reference instance to an attacker they would be able to use it to acquire a Reference to the nodejs context's Function object. Similar application-specific attacks could be possible by modifying the local prototype of other API objects. Access to NativeModule objects could allow an attacker to load and run native code from anywhere on the filesystem. If combined with, for example, a file upload API this would allow for arbitrary code execution. This is addressed in v4.0.0 through a series of related changes.", "project": "isolated-vm", "idx": 195986}
{"source": " codegen(codegen_scope *s, node *tree, int val)\n {\n   int nt;\n   int rlev = s->rlev;\n \n   if (!tree) {\n     if (val) {\n       genop_1(s, OP_LOADNIL, cursp());\n       push();\n     }\n     return;\n   }\n \n   s->rlev++;\n   if (s->rlev > MRB_CODEGEN_LEVEL_MAX) {\n     codegen_error(s, \"too complex expression\");\n   }\n   if (s->irep && s->filename_index != tree->filename_index) {\n     mrb_sym fname = mrb_parser_get_filename(s->parser, s->filename_index);\n     const char *filename = mrb_sym_name_len(s->mrb, fname, NULL);\n \n     mrb_debug_info_append_file(s->mrb, s->irep->debug_info,\n                                filename, s->lines, s->debug_start_pos, s->pc);\n     s->debug_start_pos = s->pc;\n     s->filename_index = tree->filename_index;\n     s->filename_sym = mrb_parser_get_filename(s->parser, tree->filename_index);\n   }\n \n   nt = nint(tree->car);\n   s->lineno = tree->lineno;\n   tree = tree->cdr;\n   switch (nt) {\n   case NODE_BEGIN:\n     if (val && !tree) {\n       genop_1(s, OP_LOADNIL, cursp());\n       push();\n     }\n     while (tree) {\n       codegen(s, tree->car, tree->cdr ? NOVAL : val);\n       tree = tree->cdr;\n     }\n     break;\n \n   case NODE_RESCUE:\n     {\n       int noexc;\n       uint32_t exend, pos1, pos2, tmp;\n       struct loopinfo *lp;\n       int catch_entry, begin, end;\n \n       if (tree->car == NULL) goto exit;\n       lp = loop_push(s, LOOP_BEGIN);\n       lp->pc0 = new_label(s);\n       catch_entry = catch_handler_new(s);\n       begin = s->pc;\n       codegen(s, tree->car, VAL);\n       pop();\n       lp->type = LOOP_RESCUE;\n       end = s->pc;\n       noexc = genjmp_0(s, OP_JMP);\n       catch_handler_set(s, catch_entry, MRB_CATCH_RESCUE, begin, end, s->pc);\n       tree = tree->cdr;\n       exend = JMPLINK_START;\n       pos1 = JMPLINK_START;\n       if (tree->car) {\n         node *n2 = tree->car;\n         int exc = cursp();\n \n         genop_1(s, OP_EXCEPT, exc);\n         push();\n         while (n2) {\n           node *n3 = n2->car;\n           node *n4 = n3->car;\n \n           dispatch(s, pos1);\n           pos2 = JMPLINK_START;\n           do {\n             if (n4 && n4->car && nint(n4->car->car) == NODE_SPLAT) {\n               codegen(s, n4->car, VAL);\n               gen_move(s, cursp(), exc, 0);\n               push_n(2); pop_n(2);\n               pop();\n               genop_3(s, OP_SEND, cursp(), new_sym(s, MRB_SYM_2(s->mrb, __case_eqq)), 1);\n             }\n             else {\n               if (n4) {\n                 codegen(s, n4->car, VAL);\n               }\n               else {\n                 genop_2(s, OP_GETCONST, cursp(), new_sym(s, MRB_SYM_2(s->mrb, StandardError)));\n                 push();\n               }\n               pop();\n               genop_2(s, OP_RESCUE, exc, cursp());\n             }\n             tmp = genjmp2(s, OP_JMPIF, cursp(), pos2, val);\n             pos2 = tmp;\n             if (n4) {\n               n4 = n4->cdr;\n             }\n           } while (n4);\n           pos1 = genjmp_0(s, OP_JMP);\n           dispatch_linked(s, pos2);\n \n           pop();\n           if (n3->cdr->car) {\n             gen_assignment(s, n3->cdr->car, NULL, exc, NOVAL);\n           }\n           if (n3->cdr->cdr->car) {\n             codegen(s, n3->cdr->cdr->car, val);\n             if (val) pop();\n           }\n           tmp = genjmp(s, OP_JMP, exend);\n           exend = tmp;\n           n2 = n2->cdr;\n           push();\n         }\n         if (pos1 != JMPLINK_START) {\n           dispatch(s, pos1);\n           genop_1(s, OP_RAISEIF, exc);\n         }\n       }\n       pop();\n       tree = tree->cdr;\n       dispatch(s, noexc);\n       if (tree->car) {\n         codegen(s, tree->car, val);\n       }\n       else if (val) {\n         push();\n       }\n       dispatch_linked(s, exend);\n       loop_pop(s, NOVAL);\n     }\n     break;\n \n   case NODE_ENSURE:\n     if (!tree->cdr || !tree->cdr->cdr ||\n         (nint(tree->cdr->cdr->car) == NODE_BEGIN &&\n          tree->cdr->cdr->cdr)) {\n       int catch_entry, begin, end, target;\n       int idx;\n \n       catch_entry = catch_handler_new(s);\n       begin = s->pc;\n       codegen(s, tree->car, val);\n       end = target = s->pc;\n       push();\n       idx = cursp();\n       genop_1(s, OP_EXCEPT, idx);\n       push();\n       codegen(s, tree->cdr->cdr, NOVAL);\n       pop();\n       genop_1(s, OP_RAISEIF, idx);\n       pop();\n       catch_handler_set(s, catch_entry, MRB_CATCH_ENSURE, begin, end, target);\n     }\n     else {\n       codegen(s, tree->car, val);\n     }\n     break;\n \n   case NODE_LAMBDA:\n     if (val) {\n       int idx = lambda_body(s, tree, 1);\n \n       genop_2(s, OP_LAMBDA, cursp(), idx);\n       push();\n     }\n     break;\n \n   case NODE_BLOCK:\n     if (val) {\n       int idx = lambda_body(s, tree, 1);\n \n       genop_2(s, OP_BLOCK, cursp(), idx);\n       push();\n     }\n     break;\n \n   case NODE_IF:\n     {\n       uint32_t pos1, pos2;\n       mrb_bool nil_p = FALSE;\n       node *elsepart = tree->cdr->cdr->car;\n \n       if (!tree->car) {\n         codegen(s, elsepart, val);\n         goto exit;\n       }\n       if (true_always(tree->car)) {\n         codegen(s, tree->cdr->car, val);\n         goto exit;\n       }\n       if (false_always(tree->car)) {\n         codegen(s, elsepart, val);\n         goto exit;\n       }\n       if (nint(tree->car->car) == NODE_CALL) {\n         node *n = tree->car->cdr;\n         mrb_sym mid = nsym(n->cdr->car);\n         mrb_sym sym_nil_p = MRB_SYM_Q_2(s->mrb, nil);\n         if (mid == sym_nil_p && n->cdr->cdr->car == NULL) {\n           nil_p = TRUE;\n           codegen(s, n->car, VAL);\n         }\n       }\n       if (!nil_p) {\n         codegen(s, tree->car, VAL);\n       }\n       pop();\n       if (val || tree->cdr->car) {\n         if (nil_p) {\n           pos2 = genjmp2_0(s, OP_JMPNIL, cursp(), val);\n           pos1 = genjmp_0(s, OP_JMP);\n           dispatch(s, pos2);\n         }\n         else {\n           pos1 = genjmp2_0(s, OP_JMPNOT, cursp(), val);\n         }\n         codegen(s, tree->cdr->car, val);\n         if (val) pop();\n         if (elsepart || val) {\n           pos2 = genjmp_0(s, OP_JMP);\n           dispatch(s, pos1);\n           codegen(s, elsepart, val);\n           dispatch(s, pos2);\n         }\n         else {\n           dispatch(s, pos1);\n         }\n       }\n       else {\n         if (elsepart) {\n           if (nil_p) {\n             pos1 = genjmp2_0(s, OP_JMPNIL, cursp(), val);\n           }\n           else {\n             pos1 = genjmp2_0(s, OP_JMPIF, cursp(), val);\n           }\n           codegen(s, elsepart, val);\n           dispatch(s, pos1);\n         }\n         else if (val && !nil_p) {\n           genop_1(s, OP_LOADNIL, cursp());\n           push();\n         }\n       }\n     }\n     break;\n \n   case NODE_AND:\n     {\n       uint32_t pos;\n \n       if (true_always(tree->car)) {\n         codegen(s, tree->cdr, val);\n         goto exit;\n       }\n       if (false_always(tree->car)) {\n         codegen(s, tree->car, val);\n         goto exit;\n       }\n       codegen(s, tree->car, VAL);\n       pop();\n       pos = genjmp2_0(s, OP_JMPNOT, cursp(), val);\n       codegen(s, tree->cdr, val);\n       dispatch(s, pos);\n     }\n     break;\n \n   case NODE_OR:\n     {\n       uint32_t pos;\n \n       if (true_always(tree->car)) {\n         codegen(s, tree->car, val);\n         goto exit;\n       }\n       if (false_always(tree->car)) {\n         codegen(s, tree->cdr, val);\n         goto exit;\n       }\n       codegen(s, tree->car, VAL);\n       pop();\n       pos = genjmp2_0(s, OP_JMPIF, cursp(), val);\n       codegen(s, tree->cdr, val);\n       dispatch(s, pos);\n     }\n     break;\n \n   case NODE_WHILE:\n   case NODE_UNTIL:\n     {\n       if (true_always(tree->car)) {\n         if (nt == NODE_UNTIL) {\n           if (val) {\n             genop_1(s, OP_LOADNIL, cursp());\n             push();\n           }\n           goto exit;\n         }\n       }\n       else if (false_always(tree->car)) {\n         if (nt == NODE_WHILE) {\n           if (val) {\n             genop_1(s, OP_LOADNIL, cursp());\n             push();\n           }\n           goto exit;\n         }\n       }\n \n       uint32_t pos = JMPLINK_START;\n       struct loopinfo *lp = loop_push(s, LOOP_NORMAL);\n \n       if (!val) lp->reg = -1;\n       lp->pc0 = new_label(s);\n       codegen(s, tree->car, VAL);\n       pop();\n       if (nt == NODE_WHILE) {\n         pos = genjmp2_0(s, OP_JMPNOT, cursp(), NOVAL);\n       }\n       else {\n         pos = genjmp2_0(s, OP_JMPIF, cursp(), NOVAL);\n       }\n       lp->pc1 = new_label(s);\n       codegen(s, tree->cdr, NOVAL);\n       genjmp(s, OP_JMP, lp->pc0);\n       dispatch(s, pos);\n       loop_pop(s, val);\n     }\n     break;\n \n   case NODE_FOR:\n     for_body(s, tree);\n     if (val) push();\n     break;\n \n   case NODE_CASE:\n     {\n       int head = 0;\n       uint32_t pos1, pos2, pos3, tmp;\n       node *n;\n \n       pos3 = JMPLINK_START;\n       if (tree->car) {\n         head = cursp();\n         codegen(s, tree->car, VAL);\n       }\n       tree = tree->cdr;\n       while (tree) {\n         n = tree->car->car;\n         pos1 = pos2 = JMPLINK_START;\n         while (n) {\n           codegen(s, n->car, VAL);\n           if (head) {\n             gen_move(s, cursp(), head, 0);\n             push(); push(); pop(); pop(); pop();\n             if (nint(n->car->car) == NODE_SPLAT) {\n               genop_3(s, OP_SEND, cursp(), new_sym(s, MRB_SYM_2(s->mrb, __case_eqq)), 1);\n             }\n             else {\n               genop_3(s, OP_SEND, cursp(), new_sym(s, MRB_OPSYM_2(s->mrb, eqq)), 1);\n             }\n           }\n           else {\n             pop();\n           }\n           tmp = genjmp2(s, OP_JMPIF, cursp(), pos2, NOVAL);\n           pos2 = tmp;\n           n = n->cdr;\n         }\n         if (tree->car->car) {\n           pos1 = genjmp_0(s, OP_JMP);\n           dispatch_linked(s, pos2);\n         }\n         codegen(s, tree->car->cdr, val);\n         if (val) pop();\n         tmp = genjmp(s, OP_JMP, pos3);\n         pos3 = tmp;\n         dispatch(s, pos1);\n         tree = tree->cdr;\n       }\n       if (val) {\n         uint32_t pos = cursp();\n         genop_1(s, OP_LOADNIL, cursp());\n         if (pos3 != JMPLINK_START) dispatch_linked(s, pos3);\n         if (head) pop();\n         if (cursp() != pos) {\n           gen_move(s, cursp(), pos, 0);\n         }\n         push();\n       }\n       else {\n         if (pos3 != JMPLINK_START) {\n           dispatch_linked(s, pos3);\n         }\n         if (head) {\n           pop();\n         }\n       }\n     }\n     break;\n \n   case NODE_SCOPE:\n     scope_body(s, tree, NOVAL);\n     break;\n \n   case NODE_FCALL:\n   case NODE_CALL:\n     gen_call(s, tree, val, 0);\n     break;\n   case NODE_SCALL:\n     gen_call(s, tree, val, 1);\n     break;\n \n   case NODE_DOT2:\n     codegen(s, tree->car, val);\n     codegen(s, tree->cdr, val);\n     if (val) {\n       pop(); pop();\n       genop_1(s, OP_RANGE_INC, cursp());\n       push();\n     }\n     break;\n \n   case NODE_DOT3:\n     codegen(s, tree->car, val);\n     codegen(s, tree->cdr, val);\n     if (val) {\n       pop(); pop();\n       genop_1(s, OP_RANGE_EXC, cursp());\n       push();\n     }\n     break;\n \n   case NODE_COLON2:\n     {\n       int sym = new_sym(s, nsym(tree->cdr));\n \n       codegen(s, tree->car, VAL);\n       pop();\n       genop_2(s, OP_GETMCNST, cursp(), sym);\n       if (val) push();\n     }\n     break;\n \n   case NODE_COLON3:\n     {\n       int sym = new_sym(s, nsym(tree));\n \n       genop_1(s, OP_OCLASS, cursp());\n       genop_2(s, OP_GETMCNST, cursp(), sym);\n       if (val) push();\n     }\n     break;\n \n   case NODE_ARRAY:\n     {\n       int n;\n \n       n = gen_values(s, tree, val, 0);\n       if (val) {\n         if (n >= 0) {\n           pop_n(n);\n           genop_2(s, OP_ARRAY, cursp(), n);\n         }\n         push();\n       }\n     }\n     break;\n \n   case NODE_HASH:\n   case NODE_KW_HASH:\n     {\n       int nk = gen_hash(s, tree, val, GEN_LIT_ARY_MAX);\n       if (val && nk >= 0) {\n         pop_n(nk*2);\n         genop_2(s, OP_HASH, cursp(), nk);\n         push();\n       }\n     }\n     break;\n \n   case NODE_SPLAT:\n     codegen(s, tree, val);\n     break;\n \n   case NODE_ASGN:\n     gen_assignment(s, tree->car, tree->cdr, 0, val);\n     break;\n \n   case NODE_MASGN:\n     {\n       int len = 0, n = 0, post = 0;\n       node *t = tree->cdr, *p;\n       int rhs = cursp();\n \n       if (nint(t->car) == NODE_ARRAY && t->cdr && nosplat(t->cdr)) {\n         t = t->cdr;\n         while (t) {\n           codegen(s, t->car, VAL);\n           len++;\n           t = t->cdr;\n         }\n         tree = tree->car;\n         if (tree->car) {\n           t = tree->car;\n           n = 0;\n           while (t) {\n             if (n < len) {\n               gen_assignment(s, t->car, NULL, rhs+n, NOVAL);\n               n++;\n             }\n             else {\n               genop_1(s, OP_LOADNIL, rhs+n);\n               gen_assignment(s, t->car, NULL, rhs+n, NOVAL);\n             }\n             t = t->cdr;\n           }\n         }\n         t = tree->cdr;\n         if (t) {\n           if (t->cdr) {\n             p = t->cdr->car;\n             while (p) {\n               post++;\n               p = p->cdr;\n             }\n           }\n           if (t->car) {\n             int rn;\n \n             if (len < post + n) {\n               rn = 0;\n             }\n             else {\n               rn = len - post - n;\n             }\n             genop_3(s, OP_ARRAY2, cursp(), rhs+n, rn);\n             gen_assignment(s, t->car, NULL, cursp(), NOVAL);\n             n += rn;\n           }\n           if (t->cdr && t->cdr->car) {\n             t = t->cdr->car;\n             while (n<len) {\n               gen_assignment(s, t->car, NULL, rhs+n, NOVAL);\n               t = t->cdr;\n               n++;\n             }\n           }\n         }\n         pop_n(len);\n         if (val) {\n           genop_2(s, OP_ARRAY, rhs, len);\n           push();\n         }\n       }\n       else {\n         codegen(s, t, VAL);\n         gen_vmassignment(s, tree->car, rhs, val);\n         if (!val) {\n           pop();\n         }\n       }\n     }\n     break;\n \n   case NODE_OP_ASGN:\n     {\n       mrb_sym sym = nsym(tree->cdr->car);\n       mrb_int len;\n       const char *name = mrb_sym_name_len(s->mrb, sym, &len);\n       int idx, callargs = -1, vsp = -1;\n \n       if ((len == 2 && name[0] == '|' && name[1] == '|') &&\n           (nint(tree->car->car) == NODE_CONST ||\n            nint(tree->car->car) == NODE_CVAR)) {\n         int catch_entry, begin, end;\n         int noexc, exc;\n         struct loopinfo *lp;\n \n         lp = loop_push(s, LOOP_BEGIN);\n         lp->pc0 = new_label(s);\n         catch_entry = catch_handler_new(s);\n         begin = s->pc;\n         exc = cursp();\n         codegen(s, tree->car, VAL);\n         end = s->pc;\n         noexc = genjmp_0(s, OP_JMP);\n         lp->type = LOOP_RESCUE;\n         catch_handler_set(s, catch_entry, MRB_CATCH_RESCUE, begin, end, s->pc);\n         genop_1(s, OP_EXCEPT, exc);\n         genop_1(s, OP_LOADF, exc);\n         dispatch(s, noexc);\n         loop_pop(s, NOVAL);\n       }\n       else if (nint(tree->car->car) == NODE_CALL) {\n         node *n = tree->car->cdr;\n         int base, i, nargs = 0;\n         callargs = 0;\n \n         if (val) {\n           vsp = cursp();\n           push();\n         }\n         codegen(s, n->car, VAL);\n         idx = new_sym(s, nsym(n->cdr->car));\n         base = cursp()-1;\n         if (n->cdr->cdr->car) {\n           nargs = gen_values(s, n->cdr->cdr->car->car, VAL, 13);\n           if (nargs >= 0) {\n             callargs = nargs;\n           }\n           else {\n             push();\n             nargs = 1;\n             callargs = CALL_MAXARGS;\n           }\n         }\n         gen_move(s, cursp(), base, 1);\n         for (i=0; i<nargs; i++) {\n           gen_move(s, cursp()+i+1, base+i+1, 1);\n         }\n         push_n(nargs+2);pop_n(nargs+2);\n         genop_3(s, OP_SEND, cursp(), idx, callargs);\n         push();\n       }\n       else {\n         codegen(s, tree->car, VAL);\n       }\n       if (len == 2 &&\n           ((name[0] == '|' && name[1] == '|') ||\n            (name[0] == '&' && name[1] == '&'))) {\n         uint32_t pos;\n \n         pop();\n         if (val) {\n           if (vsp >= 0) {\n             gen_move(s, vsp, cursp(), 1);\n           }\n           pos = genjmp2_0(s, name[0]=='|'?OP_JMPIF:OP_JMPNOT, cursp(), val);\n         }\n         else {\n           pos = genjmp2_0(s, name[0]=='|'?OP_JMPIF:OP_JMPNOT, cursp(), val);\n         }\n         codegen(s, tree->cdr->cdr->car, VAL);\n         pop();\n         if (val && vsp >= 0) {\n           gen_move(s, vsp, cursp(), 1);\n         }\n         if (nint(tree->car->car) == NODE_CALL) {\n           if (callargs == CALL_MAXARGS) {\n             pop();\n             genop_2(s, OP_ARYPUSH, cursp(), 1);\n           }\n           else {\n             pop_n(callargs);\n             callargs++;\n           }\n           pop();\n           idx = new_sym(s, attrsym(s, nsym(tree->car->cdr->cdr->car)));\n           genop_3(s, OP_SEND, cursp(), idx, callargs);\n         }\n         else {\n           gen_assignment(s, tree->car, NULL, cursp(), val);\n         }\n         dispatch(s, pos);\n         goto exit;\n       }\n       codegen(s, tree->cdr->cdr->car, VAL);\n       push(); pop();\n       pop(); pop();\n \n       if (len == 1 && name[0] == '+')  {\n         gen_addsub(s, OP_ADD, cursp());\n       }\n       else if (len == 1 && name[0] == '-')  {\n         gen_addsub(s, OP_SUB, cursp());\n       }\n       else if (len == 1 && name[0] == '*')  {\n         genop_1(s, OP_MUL, cursp());\n       }\n       else if (len == 1 && name[0] == '/')  {\n         genop_1(s, OP_DIV, cursp());\n       }\n       else if (len == 1 && name[0] == '<')  {\n         genop_1(s, OP_LT, cursp());\n       }\n       else if (len == 2 && name[0] == '<' && name[1] == '=')  {\n         genop_1(s, OP_LE, cursp());\n       }\n       else if (len == 1 && name[0] == '>')  {\n         genop_1(s, OP_GT, cursp());\n       }\n       else if (len == 2 && name[0] == '>' && name[1] == '=')  {\n         genop_1(s, OP_GE, cursp());\n       }\n       else {\n         idx = new_sym(s, sym);\n         genop_3(s, OP_SEND, cursp(), idx, 1);\n       }\n       if (callargs < 0) {\n         gen_assignment(s, tree->car, NULL, cursp(), val);\n       }\n       else {\n         if (val && vsp >= 0) {\n           gen_move(s, vsp, cursp(), 0);\n         }\n         if (callargs == CALL_MAXARGS) {\n           pop();\n           genop_2(s, OP_ARYPUSH, cursp(), 1);\n         }\n         else {\n           pop_n(callargs);\n           callargs++;\n         }\n         pop();\n         idx = new_sym(s, attrsym(s,nsym(tree->car->cdr->cdr->car)));\n         genop_3(s, OP_SEND, cursp(), idx, callargs);\n       }\n     }\n     break;\n \n   case NODE_SUPER:\n     {\n       codegen_scope *s2 = s;\n       int lv = 0;\n       int n = 0, nk = 0, st = 0;\n \n       push();\n       while (!s2->mscope) {\n         lv++;\n         s2 = s2->prev;\n         if (!s2) break;\n       }\n       if (tree) {\n         node *args = tree->car;\n         if (args) {\n           st = n = gen_values(s, args, VAL, 14);\n           if (n < 0) {\n             st = 1; n = 15;\n             push();\n           }\n         }\n         if (s2 && (s2->ainfo & 0x1) && tree->cdr->car) {\n           nk = gen_hash(s, tree->cdr->car->cdr, VAL, 14);\n           if (nk < 0) {st++; nk = 15;}\n           else st += nk*2;\n           n |= nk<<4;\n         }\n         if (tree->cdr->cdr) {\n           codegen(s, tree->cdr->cdr, VAL);\n         }\n// bug_start\n        else if (!s2) {\n// bug_end\n           push();\n         }\n// bug_start\n// bug_end\n         else {\n// bug_start\n          gen_blkmove(s, s2->ainfo, lv);\n        }\n        st++;\n      }\n      else {\n        if (!s2) push();\n        else gen_blkmove(s, s2->ainfo, lv);\n        st++;\n      }\n// bug_end\n       pop_n(st+1);\n       genop_2(s, OP_SUPER, cursp(), n);\n       if (val) push();\n     }\n     break;\n \n   case NODE_ZSUPER:\n     {\n       codegen_scope *s2 = s;\n       int lv = 0;\n       uint16_t ainfo = 0;\n       int n = CALL_MAXARGS;\n       int sp = cursp();\n \n       push();\n       while (!s2->mscope) {\n         lv++;\n         s2 = s2->prev;\n         if (!s2) break;\n       }\n       if (s2 && s2->ainfo > 0) {\n         ainfo = s2->ainfo;\n       }\n       if (ainfo > 0) {\n         genop_2S(s, OP_ARGARY, cursp(), (ainfo<<4)|(lv & 0xf));\n         push(); push(); push();\n         pop(); pop(); pop();\n         if (ainfo & 0x1) {\n           n |= CALL_MAXARGS<<4;\n           push();\n         }\n         if (tree && tree->cdr && tree->cdr->cdr) {\n           push();\n           codegen(s, tree->cdr->cdr, VAL);\n         }\n       }\n       else {\n         if (tree && tree->cdr && tree->cdr->cdr) {\n           codegen(s, tree->cdr->cdr, VAL);\n         }\n         else {\n           gen_blkmove(s, 0, lv);\n         }\n         n = 0;\n       }\n       s->sp = sp;\n       genop_2(s, OP_SUPER, cursp(), n);\n       if (val) push();\n     }\n     break;\n \n   case NODE_RETURN:\n     if (tree) {\n       gen_retval(s, tree);\n     }\n     else {\n       genop_1(s, OP_LOADNIL, cursp());\n     }\n     if (s->loop) {\n       gen_return(s, OP_RETURN_BLK, cursp());\n     }\n     else {\n       gen_return(s, OP_RETURN, cursp());\n     }\n     if (val) push();\n     break;\n \n   case NODE_YIELD:\n     {\n       codegen_scope *s2 = s;\n       int lv = 0, ainfo = -1;\n       int n = 0, sendv = 0;\n \n       while (!s2->mscope) {\n         lv++;\n         s2 = s2->prev;\n         if (!s2) break;\n       }\n       if (s2) {\n         ainfo = (int)s2->ainfo;\n       }\n       if (ainfo < 0) codegen_error(s, \"invalid yield (SyntaxError)\");\n       push();\n       if (tree) {\n         n = gen_values(s, tree, VAL, 14);\n         if (n < 0) {\n           n = sendv = 1;\n           push();\n         }\n       }\n       push();pop();\n       pop_n(n+1);\n       genop_2S(s, OP_BLKPUSH, cursp(), (ainfo<<4)|(lv & 0xf));\n       if (sendv) n = CALL_MAXARGS;\n       genop_3(s, OP_SEND, cursp(), new_sym(s, MRB_SYM_2(s->mrb, call)), n);\n       if (val) push();\n     }\n     break;\n \n   case NODE_BREAK:\n     loop_break(s, tree);\n     if (val) push();\n     break;\n \n   case NODE_NEXT:\n     if (!s->loop) {\n       raise_error(s, \"unexpected next\");\n     }\n     else if (s->loop->type == LOOP_NORMAL) {\n       codegen(s, tree, NOVAL);\n       genjmp(s, OP_JMPUW, s->loop->pc0);\n     }\n     else {\n       if (tree) {\n         codegen(s, tree, VAL);\n         pop();\n       }\n       else {\n         genop_1(s, OP_LOADNIL, cursp());\n       }\n       gen_return(s, OP_RETURN, cursp());\n     }\n     if (val) push();\n     break;\n \n   case NODE_REDO:\n     if (!s->loop || s->loop->type == LOOP_BEGIN || s->loop->type == LOOP_RESCUE) {\n       raise_error(s, \"unexpected redo\");\n     }\n     else {\n       genjmp(s, OP_JMPUW, s->loop->pc1);\n     }\n     if (val) push();\n     break;\n \n   case NODE_RETRY:\n     {\n       const char *msg = \"unexpected retry\";\n       const struct loopinfo *lp = s->loop;\n \n       while (lp && lp->type != LOOP_RESCUE) {\n         lp = lp->prev;\n       }\n       if (!lp) {\n         raise_error(s, msg);\n       }\n       else {\n         genjmp(s, OP_JMPUW, lp->pc0);\n       }\n       if (val) push();\n     }\n     break;\n \n   case NODE_LVAR:\n     if (val) {\n       int idx = lv_idx(s, nsym(tree));\n \n       if (idx > 0) {\n         gen_move(s, cursp(), idx, val);\n       }\n       else {\n         gen_getupvar(s, cursp(), nsym(tree));\n       }\n       push();\n     }\n     break;\n \n   case NODE_NVAR:\n     if (val) {\n       int idx = nint(tree);\n \n       gen_move(s, cursp(), idx, val);\n \n       push();\n     }\n     break;\n \n   case NODE_GVAR:\n     {\n       int sym = new_sym(s, nsym(tree));\n \n       genop_2(s, OP_GETGV, cursp(), sym);\n       if (val) push();\n     }\n     break;\n \n   case NODE_IVAR:\n     {\n       int sym = new_sym(s, nsym(tree));\n \n       genop_2(s, OP_GETIV, cursp(), sym);\n       if (val) push();\n     }\n     break;\n \n   case NODE_CVAR:\n     {\n       int sym = new_sym(s, nsym(tree));\n \n       genop_2(s, OP_GETCV, cursp(), sym);\n       if (val) push();\n     }\n     break;\n \n   case NODE_CONST:\n     {\n       int sym = new_sym(s, nsym(tree));\n \n       genop_2(s, OP_GETCONST, cursp(), sym);\n       if (val) push();\n     }\n     break;\n \n   case NODE_BACK_REF:\n     if (val) {\n       char buf[] = {'$', nchar(tree)};\n       int sym = new_sym(s, mrb_intern(s->mrb, buf, sizeof(buf)));\n \n       genop_2(s, OP_GETGV, cursp(), sym);\n       push();\n     }\n     break;\n \n   case NODE_NTH_REF:\n     if (val) {\n       mrb_state *mrb = s->mrb;\n       mrb_value str;\n       int sym;\n \n       str = mrb_format(mrb, \"$%d\", nint(tree));\n       sym = new_sym(s, mrb_intern_str(mrb, str));\n       genop_2(s, OP_GETGV, cursp(), sym);\n       push();\n     }\n     break;\n \n   case NODE_ARG:\n     break;\n \n   case NODE_BLOCK_ARG:\n     if (!tree) {\n       int idx = lv_idx(s, MRB_OPSYM_2(s->mrb, and));\n \n       if (idx == 0) {\n         codegen_error(s, \"no anonymous block argument\");\n       }\n       gen_move(s, cursp(), idx, val);\n// bug_start\n// bug_end\n     }\n     else {\n       codegen(s, tree, val);\n     }\n     break;\n \n   case NODE_INT:\n     if (val) {\n       char *p = (char*)tree->car;\n       int base = nint(tree->cdr->car);\n       mrb_int i;\n       mrb_bool overflow;\n \n       i = readint(s, p, base, FALSE, &overflow);\n       if (overflow) {\n         int off = new_litbn(s, p, base, FALSE);\n         genop_2(s, OP_LOADL, cursp(), off);\n       }\n       else {\n         gen_int(s, cursp(), i);\n       }\n       push();\n     }\n     break;\n \n #ifndef MRB_NO_FLOAT\n   case NODE_FLOAT:\n     if (val) {\n       char *p = (char*)tree;\n       mrb_float f = mrb_float_read(p, NULL);\n       int off = new_lit(s, mrb_float_value(s->mrb, f));\n \n       genop_2(s, OP_LOADL, cursp(), off);\n       push();\n     }\n     break;\n #endif\n \n   case NODE_NEGATE:\n     {\n       nt = nint(tree->car);\n       switch (nt) {\n #ifndef MRB_NO_FLOAT\n       case NODE_FLOAT:\n         if (val) {\n           char *p = (char*)tree->cdr;\n           mrb_float f = mrb_float_read(p, NULL);\n           int off = new_lit(s, mrb_float_value(s->mrb, -f));\n \n           genop_2(s, OP_LOADL, cursp(), off);\n           push();\n         }\n         break;\n #endif\n \n       case NODE_INT:\n         if (val) {\n           char *p = (char*)tree->cdr->car;\n           int base = nint(tree->cdr->cdr->car);\n           mrb_int i;\n           mrb_bool overflow;\n \n           i = readint(s, p, base, TRUE, &overflow);\n           if (overflow) {\n             int off = new_litbn(s, p, base, TRUE);\n             genop_2(s, OP_LOADL, cursp(), off);\n           }\n           else {\n             gen_int(s, cursp(), i);\n           }\n           push();\n         }\n         break;\n \n       default:\n         if (val) {\n           codegen(s, tree, VAL);\n           pop();\n           push_n(2);pop_n(2);\n           mrb_sym minus = MRB_OPSYM_2(s->mrb, minus);\n           if (!gen_uniop(s, minus, cursp())) {\n             genop_3(s, OP_SEND, cursp(), new_sym(s, minus), 0);\n           }\n           push();\n         }\n         else {\n           codegen(s, tree, NOVAL);\n         }\n         break;\n       }\n     }\n     break;\n \n   case NODE_STR:\n     if (val) {\n       char *p = (char*)tree->car;\n       size_t len = (intptr_t)tree->cdr;\n       int ai = mrb_gc_arena_save(s->mrb);\n       int off = new_lit(s, mrb_str_new(s->mrb, p, len));\n \n       mrb_gc_arena_restore(s->mrb, ai);\n       genop_2(s, OP_STRING, cursp(), off);\n       push();\n     }\n     break;\n \n   case NODE_HEREDOC:\n     tree = ((struct mrb_parser_heredoc_info *)tree)->doc;\n   case NODE_DSTR:\n     if (val) {\n       node *n = tree;\n \n       if (!n) {\n         genop_1(s, OP_LOADNIL, cursp());\n         push();\n         break;\n       }\n       codegen(s, n->car, VAL);\n       n = n->cdr;\n       while (n) {\n         codegen(s, n->car, VAL);\n         pop(); pop();\n         genop_1(s, OP_STRCAT, cursp());\n         push();\n         n = n->cdr;\n       }\n     }\n     else {\n       node *n = tree;\n \n       while (n) {\n         if (nint(n->car->car) != NODE_STR) {\n           codegen(s, n->car, NOVAL);\n         }\n         n = n->cdr;\n       }\n     }\n     break;\n \n   case NODE_WORDS:\n     gen_literal_array(s, tree, FALSE, val);\n     break;\n \n   case NODE_SYMBOLS:\n     gen_literal_array(s, tree, TRUE, val);\n     break;\n \n   case NODE_DXSTR:\n     {\n       node *n;\n       int ai = mrb_gc_arena_save(s->mrb);\n       int sym = new_sym(s, MRB_SYM_2(s->mrb, Kernel));\n \n       genop_1(s, OP_LOADSELF, cursp());\n       push();\n       codegen(s, tree->car, VAL);\n       n = tree->cdr;\n       while (n) {\n         if (nint(n->car->car) == NODE_XSTR) {\n           n->car->car = (struct mrb_ast_node*)(intptr_t)NODE_STR;\n           mrb_assert(!n->cdr);\n         }\n         codegen(s, n->car, VAL);\n         pop(); pop();\n         genop_1(s, OP_STRCAT, cursp());\n         push();\n         n = n->cdr;\n       }\n       push();\n       pop_n(3);\n       sym = new_sym(s, MRB_OPSYM_2(s->mrb, tick));\n       genop_3(s, OP_SEND, cursp(), sym, 1);\n       if (val) push();\n       mrb_gc_arena_restore(s->mrb, ai);\n     }\n     break;\n \n   case NODE_XSTR:\n     {\n       char *p = (char*)tree->car;\n       size_t len = (intptr_t)tree->cdr;\n       int ai = mrb_gc_arena_save(s->mrb);\n       int off = new_lit(s, mrb_str_new(s->mrb, p, len));\n       int sym;\n \n       genop_1(s, OP_LOADSELF, cursp());\n       push();\n       genop_2(s, OP_STRING, cursp(), off);\n       push(); push();\n       pop_n(3);\n       sym = new_sym(s, MRB_OPSYM_2(s->mrb, tick));\n       genop_3(s, OP_SEND, cursp(), sym, 1);\n       if (val) push();\n       mrb_gc_arena_restore(s->mrb, ai);\n     }\n     break;\n \n   case NODE_REGX:\n     if (val) {\n       char *p1 = (char*)tree->car;\n       char *p2 = (char*)tree->cdr->car;\n       char *p3 = (char*)tree->cdr->cdr;\n       int ai = mrb_gc_arena_save(s->mrb);\n       int sym = new_sym(s, mrb_intern_lit(s->mrb, REGEXP_CLASS));\n       int off = new_lit(s, mrb_str_new_cstr(s->mrb, p1));\n       int argc = 1;\n \n       genop_1(s, OP_OCLASS, cursp());\n       genop_2(s, OP_GETMCNST, cursp(), sym);\n       push();\n       genop_2(s, OP_STRING, cursp(), off);\n       push();\n       if (p2 || p3) {\n         if (p2) {\n           off = new_lit(s, mrb_str_new_cstr(s->mrb, p2));\n           genop_2(s, OP_STRING, cursp(), off);\n         }\n         else {\n           genop_1(s, OP_LOADNIL, cursp());\n         }\n         push();\n         argc++;\n         if (p3) {\n           off = new_lit(s, mrb_str_new(s->mrb, p3, 1));\n           genop_2(s, OP_STRING, cursp(), off);\n           push();\n           argc++;\n         }\n       }\n       push();\n       pop_n(argc+2);\n       sym = new_sym(s, MRB_SYM_2(s->mrb, compile));\n       genop_3(s, OP_SEND, cursp(), sym, argc);\n       mrb_gc_arena_restore(s->mrb, ai);\n       push();\n     }\n     break;\n \n   case NODE_DREGX:\n     if (val) {\n       node *n = tree->car;\n       int ai = mrb_gc_arena_save(s->mrb);\n       int sym = new_sym(s, mrb_intern_lit(s->mrb, REGEXP_CLASS));\n       int argc = 1;\n       int off;\n       char *p;\n \n       genop_1(s, OP_OCLASS, cursp());\n       genop_2(s, OP_GETMCNST, cursp(), sym);\n       push();\n       codegen(s, n->car, VAL);\n       n = n->cdr;\n       while (n) {\n         codegen(s, n->car, VAL);\n         pop(); pop();\n         genop_1(s, OP_STRCAT, cursp());\n         push();\n         n = n->cdr;\n       }\n       n = tree->cdr->cdr;\n       if (n->car) {\n         p = (char*)n->car;\n         off = new_lit(s, mrb_str_new_cstr(s->mrb, p));\n         codegen(s, tree->car, VAL);\n         genop_2(s, OP_STRING, cursp(), off);\n         pop();\n         genop_1(s, OP_STRCAT, cursp());\n         push();\n       }\n       if (n->cdr->car) {\n         char *p2 = (char*)n->cdr->car;\n         off = new_lit(s, mrb_str_new_cstr(s->mrb, p2));\n         genop_2(s, OP_STRING, cursp(), off);\n         push();\n         argc++;\n       }\n       if (n->cdr->cdr) {\n         char *p2 = (char*)n->cdr->cdr;\n         off = new_lit(s, mrb_str_new_cstr(s->mrb, p2));\n         genop_2(s, OP_STRING, cursp(), off);\n         push();\n         argc++;\n       }\n       push();\n       pop_n(argc+2);\n       sym = new_sym(s, MRB_SYM_2(s->mrb, compile));\n       genop_3(s, OP_SEND, cursp(), sym, argc);\n       mrb_gc_arena_restore(s->mrb, ai);\n       push();\n     }\n     else {\n       node *n = tree->car;\n \n       while (n) {\n         if (nint(n->car->car) != NODE_STR) {\n           codegen(s, n->car, NOVAL);\n         }\n         n = n->cdr;\n       }\n     }\n     break;\n \n   case NODE_SYM:\n     if (val) {\n       int sym = new_sym(s, nsym(tree));\n \n       genop_2(s, OP_LOADSYM, cursp(), sym);\n       push();\n     }\n     break;\n \n   case NODE_DSYM:\n     codegen(s, tree, val);\n     if (val) {\n       gen_intern(s);\n     }\n     break;\n \n   case NODE_SELF:\n     if (val) {\n       genop_1(s, OP_LOADSELF, cursp());\n       push();\n     }\n     break;\n \n   case NODE_NIL:\n     if (val) {\n       genop_1(s, OP_LOADNIL, cursp());\n       push();\n     }\n     break;\n \n   case NODE_TRUE:\n     if (val) {\n       genop_1(s, OP_LOADT, cursp());\n       push();\n     }\n     break;\n \n   case NODE_FALSE:\n     if (val) {\n       genop_1(s, OP_LOADF, cursp());\n       push();\n     }\n     break;\n \n   case NODE_ALIAS:\n     {\n       int a = new_sym(s, nsym(tree->car));\n       int b = new_sym(s, nsym(tree->cdr));\n \n       genop_2(s, OP_ALIAS, a, b);\n       if (val) {\n         genop_1(s, OP_LOADNIL, cursp());\n         push();\n       }\n     }\n    break;\n \n   case NODE_UNDEF:\n     {\n       node *t = tree;\n \n       while (t) {\n         int symbol = new_sym(s, nsym(t->car));\n         genop_1(s, OP_UNDEF, symbol);\n         t = t->cdr;\n       }\n       if (val) {\n         genop_1(s, OP_LOADNIL, cursp());\n         push();\n       }\n     }\n     break;\n \n   case NODE_CLASS:\n     {\n       int idx;\n       node *body;\n \n       if (tree->car->car == (node*)0) {\n         genop_1(s, OP_LOADNIL, cursp());\n         push();\n       }\n       else if (tree->car->car == (node*)1) {\n         genop_1(s, OP_OCLASS, cursp());\n         push();\n       }\n       else {\n         codegen(s, tree->car->car, VAL);\n       }\n       if (tree->cdr->car) {\n         codegen(s, tree->cdr->car, VAL);\n       }\n       else {\n         genop_1(s, OP_LOADNIL, cursp());\n         push();\n       }\n       pop(); pop();\n       idx = new_sym(s, nsym(tree->car->cdr));\n       genop_2(s, OP_CLASS, cursp(), idx);\n       body = tree->cdr->cdr->car;\n       if (nint(body->cdr->car) == NODE_BEGIN && body->cdr->cdr == NULL) {\n         genop_1(s, OP_LOADNIL, cursp());\n       }\n       else {\n         idx = scope_body(s, body, val);\n         genop_2(s, OP_EXEC, cursp(), idx);\n       }\n       if (val) {\n         push();\n       }\n     }\n     break;\n \n   case NODE_MODULE:\n     {\n       int idx;\n \n       if (tree->car->car == (node*)0) {\n         genop_1(s, OP_LOADNIL, cursp());\n         push();\n       }\n       else if (tree->car->car == (node*)1) {\n         genop_1(s, OP_OCLASS, cursp());\n         push();\n       }\n       else {\n         codegen(s, tree->car->car, VAL);\n       }\n       pop();\n       idx = new_sym(s, nsym(tree->car->cdr));\n       genop_2(s, OP_MODULE, cursp(), idx);\n       if (nint(tree->cdr->car->cdr->car) == NODE_BEGIN &&\n           tree->cdr->car->cdr->cdr == NULL) {\n         genop_1(s, OP_LOADNIL, cursp());\n       }\n       else {\n         idx = scope_body(s, tree->cdr->car, val);\n         genop_2(s, OP_EXEC, cursp(), idx);\n       }\n       if (val) {\n         push();\n       }\n     }\n     break;\n \n   case NODE_SCLASS:\n     {\n       int idx;\n \n       codegen(s, tree->car, VAL);\n       pop();\n       genop_1(s, OP_SCLASS, cursp());\n       if (nint(tree->cdr->car->cdr->car) == NODE_BEGIN &&\n           tree->cdr->car->cdr->cdr == NULL) {\n         genop_1(s, OP_LOADNIL, cursp());\n       }\n       else {\n         idx = scope_body(s, tree->cdr->car, val);\n         genop_2(s, OP_EXEC, cursp(), idx);\n       }\n       if (val) {\n         push();\n       }\n     }\n     break;\n \n   case NODE_DEF:\n     {\n       int sym = new_sym(s, nsym(tree->car));\n       int idx = lambda_body(s, tree->cdr, 0);\n \n       genop_1(s, OP_TCLASS, cursp());\n       push();\n       genop_2(s, OP_METHOD, cursp(), idx);\n       push(); pop();\n       pop();\n       genop_2(s, OP_DEF, cursp(), sym);\n       if (val) push();\n     }\n     break;\n \n   case NODE_SDEF:\n     {\n       node *recv = tree->car;\n       int sym = new_sym(s, nsym(tree->cdr->car));\n       int idx = lambda_body(s, tree->cdr->cdr, 0);\n \n       codegen(s, recv, VAL);\n       pop();\n       genop_1(s, OP_SCLASS, cursp());\n       push();\n       genop_2(s, OP_METHOD, cursp(), idx);\n       pop();\n       genop_2(s, OP_DEF, cursp(), sym);\n       if (val) push();\n     }\n     break;\n \n   case NODE_POSTEXE:\n     codegen(s, tree, NOVAL);\n     break;\n \n   default:\n     break;\n   }\n  exit:\n   s->rlev = rlev;\n }\n \n", "target": "// fix_start\n        else if (s2) gen_blkmove(s, s2->ainfo, lv);\n        else {\n          genop_1(s, OP_LOADNIL, cursp());\n// fix_end\n// fix_start\n      }\n      else {\n        if (s2) gen_blkmove(s, s2->ainfo, lv);\n// fix_end\n// fix_start\n          genop_1(s, OP_LOADNIL, cursp());\n          push();\n        }\n      }\n      st++;\n// fix_end\n// fix_start\n      if (val) push();\n// fix_end\n", "cwe": "CWE-476", "cwe_name": "NULL Pointer Dereference", "cve": "CVE-2022-0632", "cve_desc": "NULL Pointer Dereference in Homebrew mruby prior to 3.2.", "project": "mruby", "idx": 196318}
{"source": " ecma_op_internal_buffer_append (ecma_collection_t *container_p,\n                                 ecma_value_t key_arg,\n                                 ecma_value_t value_arg,\n                                 lit_magic_string_id_t lit_id)\n {\n   JERRY_ASSERT (container_p != NULL);\n \n// bug_start\n  ecma_collection_push_back (container_p, ecma_copy_value_if_not_object (key_arg));\n\n// bug_end\n   if (lit_id == LIT_MAGIC_STRING_WEAKMAP_UL || lit_id == LIT_MAGIC_STRING_MAP_UL)\n   {\n// bug_start\n    ecma_collection_push_back (container_p, ecma_copy_value_if_not_object (value_arg));\n// bug_end\n   }\n \n   ECMA_CONTAINER_SET_SIZE (container_p, ECMA_CONTAINER_GET_SIZE (container_p) + 1);\n }\n \n", "target": "// fix_start\n// fix_end\n// fix_start\n    ecma_value_t values[] = { ecma_copy_value_if_not_object (key_arg), ecma_copy_value_if_not_object (value_arg) };\n    ecma_collection_append (container_p, values, 2);\n  }\n  else\n  {\n    ecma_collection_push_back (container_p, ecma_copy_value_if_not_object (key_arg));\n// fix_end\n", "cwe": "CWE-703", "cwe_name": "Improper Check or Handling of Exceptional Conditions", "cve": "CVE-2020-14163", "cve_desc": "An issue was discovered in ecma/operations/ecma-container-object.c in JerryScript 2.2.0. Operations with key/value pairs did not consider the case where garbage collection is triggered after the key operation but before the value operation, as demonstrated by improper read access to memory in ecma_gc_set_object_visited in ecma/base/ecma-gc.c.", "project": "jerryscript", "idx": 196327}
{"source": "   void Compute(OpKernelContext* context) override {\n     const Tensor& input_tensor = context->input(0);\n     const auto input_tensor_flat = input_tensor.flat<int32>();\n     const Tensor& input_splits = context->input(1);\n     const auto input_splits_flat = input_splits.flat<SPLITS_TYPE>();\n \n// bug_start\n// bug_end\n     OP_REQUIRES(\n         context, input_splits_flat(0) == 0,\n         errors::InvalidArgument(\"First value in input_splits must be zero.\"));\n     OP_REQUIRES(context,\n                 input_splits_flat(input_splits_flat.size() - 1) ==\n                     input_tensor_flat.size(),\n                 errors::InvalidArgument(\"Last value in input_splits must be \"\n                                         \"equal to length of input_tensor.\"));\n     TensorShape output_shape({input_splits.dim_size(0) - 1});\n     Tensor* output_tensor;\n     OP_REQUIRES_OK(context, context->allocate_output(\"output\", output_shape,\n                                                      &output_tensor));\n     auto output_tensor_flat = output_tensor->flat<tstring>();\n \n     int idx = 0;\n     for (int i = 1; i < input_splits_flat.size(); ++i) {\n       icu::UnicodeString unicode_string;\n       icu::UnicodeStringAppendable appendable_unicode_string(unicode_string);\n       OP_REQUIRES(\n           context, input_splits_flat(i - 1) <= input_splits_flat(i),\n           errors::InvalidArgument(\n               \"Values in input_splits must be equal or in ascending order.\"));\n       OP_REQUIRES(\n           context, input_splits_flat(i) <= input_tensor_flat.size(),\n           errors::InvalidArgument(\"Values in input_splits must be less than or \"\n                                   \"equal to input_tensor length.\"));\n       for (; idx < input_splits_flat(i); ++idx) {\n         int32_t code_point = input_tensor_flat(idx);\n         if (!U_IS_UNICODE_CHAR(code_point)) {\n           if (error_options_.error_on_malformatting) {\n             context->CtxFailure(errors::InvalidArgument(\n                 \"Code point is out of range for Unicode, or a noncharacter.\"));\n             return;\n           } else if (!error_options_.elide_replacement) {\n             code_point = error_options_.subst;\n           }\n         }\n         appendable_unicode_string.appendCodePoint(code_point);\n       }\n       tstring result;\n       Encode(encoding_, unicode_string, &result);\n       output_tensor_flat(i - 1) = std::move(result);\n     }\n   }\n \n", "target": "// fix_start\n    OP_REQUIRES(\n        context, input_splits.NumElements() > 0,\n        errors::InvalidArgument(\"Input_splits should contain elements, but \"\n                                \"given input_values has 0 elements\"));\n// fix_end\n", "cwe": "CWE-787", "cwe_name": "Out-of-bounds Write", "cve": "CVE-2021-37667", "cve_desc": "TensorFlow is an end-to-end open source platform for machine learning. In affected versions an attacker can cause undefined behavior via binding a reference to null pointer in `tf.raw_ops.UnicodeEncode`. The [implementation](https://github.com/tensorflow/tensorflow/blob/460e000de3a83278fb00b61a16d161b1964f15f4/tensorflow/core/kernels/unicode_ops.cc#L533-L539) reads the first dimension of the `input_splits` tensor before validating that this tensor is not empty. We have patched the issue in GitHub commit 2e0ee46f1a47675152d3d865797a18358881d7a6. The fix will be included in TensorFlow 2.6.0. We will also cherrypick this commit on TensorFlow 2.5.1, TensorFlow 2.4.3, and TensorFlow 2.3.4, as these are also affected and still in supported range.", "project": "tensorflow", "idx": 196329}
{"source": " static inline Status ParseAndCheckBoxSizes(const Tensor& boxes,\n                                            const Tensor& box_index,\n                                            int* num_boxes) {\n   if (boxes.NumElements() == 0 && box_index.NumElements() == 0) {\n     *num_boxes = 0;\n     return Status::OK();\n   }\n   if (boxes.dims() != 2) {\n     return errors::InvalidArgument(\"boxes must be 2-D\",\n                                    boxes.shape().DebugString());\n   }\n   *num_boxes = boxes.dim_size(0);\n   if (boxes.dim_size(1) != 4) {\n     return errors::InvalidArgument(\"boxes must have 4 columns\");\n   }\n// bug_start\n// bug_end\n   if (box_index.dims() != 1) {\n     return errors::InvalidArgument(\"box_index must be 1-D\",\n                                    box_index.shape().DebugString());\n   }\n   if (box_index.dim_size(0) != *num_boxes) {\n     return errors::InvalidArgument(\"box_index has incompatible shape\");\n   }\n   return Status::OK();\n }\n \n", "target": "// fix_start\n  for (int64 i = 0; i < *num_boxes; i++) {\n    for (int64 j = 0; j < 4; j++) {\n      if (!isfinite(boxes.tensor<float, 2>()(i, j))) {\n        return errors::InvalidArgument(\n            \"boxes values must be finite, received boxes[\", i, \"]: \",\n            boxes.tensor<float, 2>()(i, 0), \", \",\n            boxes.tensor<float, 2>()(i, 1), \", \",\n            boxes.tensor<float, 2>()(i, 2), \", \",\n            boxes.tensor<float, 2>()(i, 3));\n      }\n    }\n  }\n// fix_end\n", "cwe": "CWE-787", "cwe_name": "Out-of-bounds Write", "cve": "CVE-2020-15266", "cve_desc": "In Tensorflow before version 2.4.0, when the `boxes` argument of `tf.image.crop_and_resize` has a very large value, the CPU kernel implementation receives it as a C++ `nan` floating point value. Attempting to operate on this is undefined behavior which later produces a segmentation fault. The issue is patched in eccb7ec454e6617738554a255d77f08e60ee0808 and TensorFlow 2.4.0 will be released containing the patch. TensorFlow nightly packages after this commit will also have the issue resolved.", "project": "tensorflow", "idx": 196330}
{"source": " int flb_parser_json_do(struct flb_parser *parser,\n                        const char *in_buf, size_t in_size,\n                        void **out_buf, size_t *out_size,\n                        struct flb_time *out_time)\n {\n     int i;\n     int skip;\n     int ret;\n     int slen;\n     int root_type;\n     int records;\n     double tmfrac = 0;\n     char *mp_buf = NULL;\n     char *time_key;\n     char *tmp_out_buf = NULL;\n     char tmp[255];\n     size_t tmp_out_size = 0;\n     size_t off = 0;\n     size_t map_size;\n     size_t mp_size;\n     size_t len;\n     msgpack_sbuffer mp_sbuf;\n     msgpack_packer  mp_pck;\n     msgpack_unpacked result;\n     msgpack_object map;\n     msgpack_object *k = NULL;\n     msgpack_object *v = NULL;\n     time_t time_lookup;\n     struct tm tm = {0};\n     struct flb_time *t;\n \n     ret = flb_pack_json_recs(in_buf, in_size, &mp_buf, &mp_size, &root_type,\n                              &records);\n     if (ret != 0) {\n         return -1;\n     }\n \n     if (records != 1) {\n         flb_free(mp_buf);\n         return -1;\n     }\n \n     msgpack_unpacked_init(&result);\n     if (msgpack_unpack_next(&result, mp_buf, mp_size, &off) == MSGPACK_UNPACK_SUCCESS) {\n         map = result.data;\n         if (map.type != MSGPACK_OBJECT_MAP) {\n             flb_free(mp_buf);\n             msgpack_unpacked_destroy(&result);\n             return -1;\n         }\n     }\n     else {\n         if (mp_size > 0) {\n             flb_free(mp_buf);\n         }\n         msgpack_unpacked_destroy(&result);\n         return -1;\n     }\n \n     tmp_out_buf = mp_buf;\n     tmp_out_size = mp_size;\n \n     if (parser->decoders) {\n         ret = flb_parser_decoder_do(parser->decoders,\n                                     mp_buf, mp_size,\n                                     &tmp_out_buf, &tmp_out_size);\n         if (ret == 0) {\n             off = 0;\n             msgpack_unpacked_destroy(&result);\n             msgpack_unpacked_init(&result);\n             msgpack_unpack_next(&result, tmp_out_buf, tmp_out_size, &off);\n             map = result.data;\n         }\n     }\n \n     *out_buf = tmp_out_buf;\n     *out_size = tmp_out_size;\n     if (mp_buf != tmp_out_buf) {\n         flb_free(mp_buf);\n// bug_start\n// bug_end\n     }\n \n     if (!parser->time_fmt) {\n         msgpack_unpacked_destroy(&result);\n         return *out_size;\n     }\n \n     if (parser->time_key) {\n         time_key = parser->time_key;\n     }\n     else {\n         time_key = \"time\";\n     }\n     slen = strlen(time_key);\n \n     map_size = map.via.map.size;\n     skip = map_size;\n     for (i = 0; i < map_size; i++) {\n         k = &map.via.map.ptr[i].key;\n         v = &map.via.map.ptr[i].val;\n \n         if (k->via.str.size != slen) {\n             continue;\n         }\n \n         if (k->via.str.ptr == NULL) {\n             flb_free(mp_buf);\n// bug_start\n// bug_end\n             *out_buf = NULL;\n             msgpack_unpacked_destroy(&result);\n             return -1;\n         }\n \n         if (strncmp(k->via.str.ptr, time_key, k->via.str.size) == 0) {\n             if (parser->time_keep == FLB_FALSE) {\n                 skip = i;\n                 break;\n             }\n             else {\n                 skip = -1;\n             }\n             break;\n         }\n \n         k = NULL;\n         v = NULL;\n     }\n \n     if (i >= map_size || !k || !v) {\n         msgpack_unpacked_destroy(&result);\n         return *out_size;\n     }\n \n     if (v->type != MSGPACK_OBJECT_STR) {\n         msgpack_unpacked_destroy(&result);\n         return *out_size;\n     }\n \n     ret = flb_parser_time_lookup(v->via.str.ptr, v->via.str.size,\n                                  0, parser, &tm, &tmfrac);\n     if (ret == -1) {\n         len = v->via.str.size;\n         if (len > sizeof(tmp) - 1) {\n             len = sizeof(tmp) - 1;\n         }\n         memcpy(tmp, v->via.str.ptr, len);\n         tmp[len] = '\\0';\n         flb_warn(\"[parser:%s] invalid time format %s for '%s'\",\n                  parser->name, parser->time_fmt_full, tmp);\n         time_lookup = 0;\n     }\n     else {\n         time_lookup = flb_parser_tm2time(&tm);\n     }\n \n     msgpack_sbuffer_init(&mp_sbuf);\n     msgpack_packer_init(&mp_pck, &mp_sbuf, msgpack_sbuffer_write);\n \n     if (parser->time_keep == FLB_FALSE) {\n         msgpack_pack_map(&mp_pck, map_size - 1);\n     }\n     else {\n         msgpack_pack_map(&mp_pck, map_size);\n     }\n \n     for (i = 0; i < map_size; i++) {\n         if (i == skip) {\n             continue;\n         }\n         msgpack_pack_object(&mp_pck, map.via.map.ptr[i].key);\n         msgpack_pack_object(&mp_pck, map.via.map.ptr[i].val);\n     }\n \n     flb_free(tmp_out_buf);\n     *out_buf = mp_sbuf.data;\n     *out_size = mp_sbuf.size;\n \n     t = out_time;\n     t->tm.tv_sec  = time_lookup;\n     t->tm.tv_nsec = (tmfrac * 1000000000);\n \n     msgpack_unpacked_destroy(&result);\n     return *out_size;\n }\n \n", "target": "// fix_start\n        mp_buf = NULL;\n// fix_end\n// fix_start\n            flb_free(tmp_out_buf);\n// fix_end\n", "cwe": "CWE-415", "cwe_name": "Double Free", "cve": "CVE-2021-36088", "cve_desc": "Fluent Bit (aka fluent-bit) 1.7.0 through 1.7,4 has a double free in flb_free (called from flb_parser_json_do and flb_parser_do).", "project": "fluent-bit", "idx": 196589}
{"source": " main(int argc, char **argv)\n {\n \tconst char *safepath = \"/bin:/sbin:/usr/bin:/usr/sbin:\"\n \t    \"/usr/local/bin:/usr/local/sbin\";\n \tconst char *confpath = NULL;\n \tchar *shargv[] = { NULL, NULL };\n \tchar *sh;\n \tconst char *p;\n \tconst char *cmd;\n \tchar cmdline[LINE_MAX];\n \tstruct passwd mypwstore, targpwstore;\n \tstruct passwd *mypw, *targpw;\n \tconst struct rule *rule;\n \tuid_t uid;\n \tuid_t target = 0;\n \tgid_t groups[NGROUPS_MAX + 1];\n \tint ngroups;\n \tint i, ch, rv;\n \tint sflag = 0;\n \tint nflag = 0;\n \tchar cwdpath[PATH_MAX];\n \tconst char *cwd;\n \tchar **envp;\n \n \tsetprogname(\"doas\");\n \n \tclosefrom(STDERR_FILENO + 1);\n \n \tuid = getuid();\n \n \twhile ((ch = getopt(argc, argv, \"+C:Lnsu:\")) != -1) {\n \t\tswitch (ch) {\n \t\tcase 'C':\n \t\t\tconfpath = optarg;\n \t\t\tbreak;\n \t\tcase 'L':\n #if defined(USE_TIMESTAMP)\n \t\t\texit(timestamp_clear() == -1);\n #else\n \t\t\texit(0);\n #endif\n \t\tcase 'u':\n \t\t\tif (parseuid(optarg, &target) != 0)\n \t\t\t\terrx(1, \"unknown user\");\n \t\t\tbreak;\n \t\tcase 'n':\n \t\t\tnflag = 1;\n \t\t\tbreak;\n \t\tcase 's':\n \t\t\tsflag = 1;\n \t\t\tbreak;\n \t\tdefault:\n \t\t\tusage();\n \t\t\tbreak;\n \t\t}\n \t}\n \targv += optind;\n \targc -= optind;\n \n \tif (confpath) {\n \t\tif (sflag)\n \t\t\tusage();\n \t} else if ((!sflag && !argc) || (sflag && argc))\n \t\tusage();\n \n \trv = mygetpwuid_r(uid, &mypwstore, &mypw);\n \tif (rv != 0)\n \t\terr(1, \"getpwuid_r failed\");\n \tif (mypw == NULL)\n \t\terrx(1, \"no passwd entry for self\");\n \tngroups = getgroups(NGROUPS_MAX, groups);\n \tif (ngroups == -1)\n \t\terr(1, \"can't get groups\");\n \tgroups[ngroups++] = getgid();\n \n \tif (sflag) {\n \t\tsh = getenv(\"SHELL\");\n \t\tif (sh == NULL || *sh == '\\0') {\n \t\t\tshargv[0] = mypw->pw_shell;\n \t\t} else\n \t\t\tshargv[0] = sh;\n \t\targv = shargv;\n \t\targc = 1;\n \t}\n \n \tif (confpath) {\n \t\tcheckconfig(confpath, argc, argv, uid, groups, ngroups,\n \t\t    target);\n \t\texit(1);\n \t}\n \n \tif (geteuid())\n \t\terrx(1, \"not installed setuid\");\n \n \tparseconfig(DOAS_CONF, 1);\n \n \t(void)strlcpy(cmdline, argv[0], sizeof(cmdline));\n \tfor (i = 1; i < argc; i++) {\n \t\tif (strlcat(cmdline, \" \", sizeof(cmdline)) >= sizeof(cmdline))\n \t\t\tbreak;\n \t\tif (strlcat(cmdline, argv[i], sizeof(cmdline)) >= sizeof(cmdline))\n \t\t\tbreak;\n \t}\n \n \tcmd = argv[0];\n \tif (!permit(uid, groups, ngroups, &rule, target, cmd,\n \t    (const char **)argv + 1)) {\n \t\tsyslog(LOG_AUTHPRIV | LOG_NOTICE,\n \t\t    \"command not permitted for %s: %s\", mypw->pw_name, cmdline);\n \t\terrc(1, EPERM, NULL);\n \t}\n \n #if defined(USE_SHADOW)\n \tif (!(rule->options & NOPASS)) {\n \t\tif (nflag)\n \t\t\terrx(1, \"Authorization required\");\n \n \t\tshadowauth(mypw->pw_name, rule->options & PERSIST);\n \t}\n #elif !defined(USE_PAM)\n \t(void) nflag;\n \tif (!(rule->options & NOPASS))\n \t\terrx(1, \"Authorization required\");\n #endif\n \n \tif ((p = getenv(\"PATH\")) != NULL)\n \t\tformerpath = strdup(p);\n \tif (formerpath == NULL)\n \t\tformerpath = \"\";\n \n \tif (rule->cmd) {\n \t\tif (setenv(\"PATH\", safepath, 1) == -1)\n \t\t\terr(1, \"failed to set PATH '%s'\", safepath);\n \t}\n \n \trv = mygetpwuid_r(target, &targpwstore, &targpw);\n \tif (rv != 0)\n \t\terr(1, \"getpwuid_r failed\");\n \tif (targpw == NULL)\n \t\terrx(1, \"no passwd entry for target\");\n \n #if defined(USE_PAM)\n \tpamauth(targpw->pw_name, mypw->pw_name, !nflag, rule->options & NOPASS,\n \t    rule->options & PERSIST);\n #endif\n \n #ifdef HAVE_LOGIN_CAP_H\n \tif (setusercontext(NULL, targpw, target, LOGIN_SETGROUP |\n// bug_start\n// bug_end\n \t    LOGIN_SETPRIORITY | LOGIN_SETRESOURCES | LOGIN_SETUMASK |\n \t    LOGIN_SETUSER) != 0)\n \t\terrx(1, \"failed to set user context for target\");\n #else\n \tif (setresgid(targpw->pw_gid, targpw->pw_gid, targpw->pw_gid) != 0)\n \t\terr(1, \"setresgid\");\n \tif (initgroups(targpw->pw_name, targpw->pw_gid) != 0)\n \t\terr(1, \"initgroups\");\n \tif (setresuid(target, target, target) != 0)\n \t\terr(1, \"setresuid\");\n// bug_start\n// bug_end\n #endif\n \n \tif (getcwd(cwdpath, sizeof(cwdpath)) == NULL)\n \t\tcwd = \"(failed)\";\n \telse\n \t\tcwd = cwdpath;\n \n \tif (!(rule->options & NOLOG)) {\n \t\tsyslog(LOG_AUTHPRIV | LOG_INFO,\n \t\t    \"%s ran command %s as %s from %s\",\n \t\t    mypw->pw_name, cmdline, targpw->pw_name, cwd);\n \t}\n \n \tenvp = prepenv(rule, mypw, targpw);\n \n \tif (rule->cmd) {\n \t\tif (setenv(\"PATH\", safepath, 1) == -1)\n \t\t\terr(1, \"failed to set PATH '%s'\", safepath);\n \t} else {\n \t\tif (setenv(\"PATH\", formerpath, 1) == -1)\n \t\t\terr(1, \"failed to set PATH '%s'\", formerpath);\n \t}\n \texecvpe(cmd, argv, envp);\n \tif (errno == ENOENT)\n \t\terrx(1, \"%s: command not found\", cmd);\n \terr(1, \"%s\", cmd);\n }\n \n", "target": "// fix_start\n\t    LOGIN_SETPATH |\n// fix_end\n// fix_start\n\tif (setenv(\"PATH\", safepath, 1) == -1)\n\t\terr(1, \"failed to set PATH '%s'\", safepath);\n// fix_end\n", "cwe": "CWE-200", "cwe_name": "Exposure of Sensitive Information to an Unauthorized Actor", "cve": "CVE-2019-25016", "cve_desc": "In OpenDoas from 6.6 to 6.8 the users PATH variable was incorrectly inherited by authenticated executions if the authenticating rule allowed the user to execute any command. Rules that only allowed to authenticated user to execute specific commands were not affected by this issue.", "project": "OpenDoas", "idx": 196601}
{"source": " bool WindowsServiceControl::install( const QString& filePath, const QString& displayName  )\n {\n// bug_start\n// bug_end\n \tm_serviceHandle = CreateService(\n \t\t\t\tm_serviceManager,\n \t\t\t\tWindowsCoreFunctions::toConstWCharArray( m_name ),\n \t\t\t\tWindowsCoreFunctions::toConstWCharArray( displayName ),\n \t\t\t\tSERVICE_ALL_ACCESS,\n \t\t\t\tSERVICE_WIN32_OWN_PROCESS,\n \t\t\t\tSERVICE_AUTO_START,\n \t\t\t\tSERVICE_ERROR_NORMAL,\n// bug_start\n\t\t\t\tWindowsCoreFunctions::toConstWCharArray( filePath ),\n// bug_end\n \t\t\t\tnullptr,\n \t\t\t\tnullptr,\n \t\t\t\tL\"Tcpip\\0RpcSs\\0\\0\",\n \t\t\t\tnullptr,\n \t\t\t\tnullptr );\n \n \tif( m_serviceHandle == nullptr )\n \t{\n \t\tconst auto error = GetLastError();\n \t\tif( error == ERROR_SERVICE_EXISTS )\n \t\t{\n \t\t\tvCritical() << qUtf8Printable( tr( \"The service \\\"%1\\\" is already installed.\" ).arg( m_name ) );\n \t\t}\n \t\telse\n \t\t{\n \t\t\tvCritical() << qUtf8Printable( tr( \"The service \\\"%1\\\" could not be installed.\" ).arg( m_name ) );\n \t\t}\n \n \t\treturn false;\n \t}\n \n \tSC_ACTION serviceActions;\n \tserviceActions.Delay = 10000;\n \tserviceActions.Type = SC_ACTION_RESTART;\n \n \tSERVICE_FAILURE_ACTIONS serviceFailureActions;\n \tserviceFailureActions.dwResetPeriod = 0;\n \tserviceFailureActions.lpRebootMsg = nullptr;\n \tserviceFailureActions.lpCommand = nullptr;\n \tserviceFailureActions.lpsaActions = &serviceActions;\n \tserviceFailureActions.cActions = 1;\n \tChangeServiceConfig2( m_serviceHandle, SERVICE_CONFIG_FAILURE_ACTIONS, &serviceFailureActions );\n \n \tvInfo() << qUtf8Printable( tr( \"The service \\\"%1\\\" has been installed successfully.\" ).arg( m_name ) );\n \n \treturn true;\n }\n \n", "target": "// fix_start\n\tconst auto binaryPath = QStringLiteral(\"\\\"%1\\\"\").arg( QString( filePath ).replace( QLatin1Char('\"'), QString() ) );\n\n// fix_end\n// fix_start\n\t\t\t\tWindowsCoreFunctions::toConstWCharArray( binaryPath ),\n// fix_end\n", "cwe": "CWE-295", "cwe_name": "Improper Certificate Validation", "cve": "CVE-2020-15261", "cve_desc": "On Windows the Veyon Service before version 4.4.2 contains an unquoted service path vulnerability, allowing locally authenticated users with administrative privileges to run malicious executables with LocalSystem privileges. Since Veyon users (both students and teachers) usually don't have administrative privileges, this vulnerability is only dangerous in anyway unsafe setups. The problem has been fixed in version 4.4.2. As a workaround, the exploitation of the vulnerability can be prevented by revoking administrative privileges from all potentially untrustworthy users.", "project": "veyon", "idx": 196610}
{"source": " void ndpi_search_openvpn(struct ndpi_detection_module_struct* ndpi_struct,\n                          struct ndpi_flow_struct* flow) {\n   struct ndpi_packet_struct* packet = &flow->packet;\n   const u_int8_t * ovpn_payload = packet->payload;\n   const u_int8_t * session_remote;\n   u_int8_t opcode;\n   u_int8_t alen;\n   int8_t hmac_size;\n   int8_t failed = 0;\n// bug_start\n// bug_end\n \n// bug_start\n  if(packet->payload_packet_len >= 40) {\n// bug_end\n     if(packet->tcp != NULL)\n// bug_start\n      ovpn_payload += 2;\n// bug_end\n \n     opcode = ovpn_payload[0] & P_OPCODE_MASK;\n \n     if(packet->udp) {\n #ifdef DEBUG\n       printf(\"[packet_id: %u][opcode: %u][Packet ID: %d][%u <-> %u][len: %u]\\n\",\n \t     flow->num_processed_pkts,\n \t     opcode, check_pkid_and_detect_hmac_size(ovpn_payload),\n// bug_start\n\t     htons(packet->udp->source), htons(packet->udp->dest), packet->payload_packet_len);\n// bug_end\n #endif\n \n       if(\n \t (flow->num_processed_pkts == 1)\n \t && (\n// bug_start\n\t     ((packet->payload_packet_len == 112)\n// bug_end\n \t      && ((opcode == 168) || (opcode == 192))\n \t      )\n// bug_start\n\t     || ((packet->payload_packet_len == 80)\n// bug_end\n \t\t && ((opcode == 184) || (opcode == 88) || (opcode == 160) || (opcode == 168) || (opcode == 200)))\n \t     )) {\n \tNDPI_LOG_INFO(ndpi_struct,\"found openvpn\\n\");\n \tndpi_set_detected_protocol(ndpi_struct, flow, NDPI_PROTOCOL_OPENVPN, NDPI_PROTOCOL_UNKNOWN);\n \treturn;\n       }\n     }\n \n     if(flow->ovpn_counter < P_HARD_RESET_CLIENT_MAX_COUNT && (opcode == P_CONTROL_HARD_RESET_CLIENT_V1 ||\n \t\t\t\t    opcode == P_CONTROL_HARD_RESET_CLIENT_V2)) {\n       if(check_pkid_and_detect_hmac_size(ovpn_payload) > 0) {\n         memcpy(flow->ovpn_session_id, ovpn_payload+1, 8);\n \n         NDPI_LOG_DBG2(ndpi_struct,\n \t\t \"session key: %02x%02x%02x%02x%02x%02x%02x%02x\\n\",\n \t\t flow->ovpn_session_id[0], flow->ovpn_session_id[1], flow->ovpn_session_id[2], flow->ovpn_session_id[3],\n \t\t flow->ovpn_session_id[4], flow->ovpn_session_id[5], flow->ovpn_session_id[6], flow->ovpn_session_id[7]);\n       }\n     } else if(flow->ovpn_counter >= 1 && flow->ovpn_counter <= P_HARD_RESET_CLIENT_MAX_COUNT &&\n             (opcode == P_CONTROL_HARD_RESET_SERVER_V1 || opcode == P_CONTROL_HARD_RESET_SERVER_V2)) {\n \n       hmac_size = check_pkid_and_detect_hmac_size(ovpn_payload);\n \n       if(hmac_size > 0) {\n// bug_start\n        alen = ovpn_payload[P_PACKET_ID_ARRAY_LEN_OFFSET(hmac_size)];\n// bug_end\n         if (alen > 0) {\n// bug_start\n\t  session_remote = ovpn_payload + P_PACKET_ID_ARRAY_LEN_OFFSET(hmac_size) + 1 + alen * 4;\n// bug_end\n \n// bug_start\n          if(memcmp(flow->ovpn_session_id, session_remote, 8) == 0) {\n\t    NDPI_LOG_INFO(ndpi_struct,\"found openvpn\\n\");\n\t    ndpi_set_detected_protocol(ndpi_struct, flow, NDPI_PROTOCOL_OPENVPN, NDPI_PROTOCOL_UNKNOWN);\n\t    return;\n\t  } else {\n            NDPI_LOG_DBG2(ndpi_struct,\n\t\t   \"key mismatch: %02x%02x%02x%02x%02x%02x%02x%02x\\n\",\n\t\t   session_remote[0], session_remote[1], session_remote[2], session_remote[3],\n\t\t   session_remote[4], session_remote[5], session_remote[6], session_remote[7]);\n            failed = 1;\n          }\n        } else\n// bug_end\n           failed = 1;\n       } else\n         failed = 1;\n     } else\n       failed = 1;\n \n     flow->ovpn_counter++;\n \n     if(failed) {\n       NDPI_EXCLUDE_PROTO(ndpi_struct, flow);\n     }\n   }\n }\n \n", "target": "// fix_start\n  int16_t ovpn_payload_len = packet->payload_packet_len;\n// fix_end\n// fix_start\n  if(ovpn_payload_len >= 40) {\n// fix_end\n// fix_start\n      ovpn_payload += 2, ovpn_payload_len -= 2;;\n// fix_end\n// fix_start\n\t     htons(packet->udp->source), htons(packet->udp->dest), ovpn_payload_len);\n// fix_end\n// fix_start\n\t     ((ovpn_payload_len == 112)\n// fix_end\n// fix_start\n\t     || ((ovpn_payload_len == 80)\n// fix_end\n// fix_start\n\tu_int16_t offset = P_PACKET_ID_ARRAY_LEN_OFFSET(hmac_size);\n\n        alen = ovpn_payload[offset];\n\n// fix_end\n// fix_start\n\t  offset += 1 + alen * 4;\n// fix_end\n// fix_start\n\t  if((offset+8) <= ovpn_payload_len) {\n\t    session_remote = &ovpn_payload[offset];\n\n\t    if(memcmp(flow->ovpn_session_id, session_remote, 8) == 0) {\n\t      NDPI_LOG_INFO(ndpi_struct,\"found openvpn\\n\");\n\t      ndpi_set_detected_protocol(ndpi_struct, flow, NDPI_PROTOCOL_OPENVPN, NDPI_PROTOCOL_UNKNOWN);\n\t      return;\n\t    } else {\n\t      NDPI_LOG_DBG2(ndpi_struct,\n\t\t\t    \"key mismatch: %02x%02x%02x%02x%02x%02x%02x%02x\\n\",\n\t\t\t    session_remote[0], session_remote[1], session_remote[2], session_remote[3],\n\t\t\t    session_remote[4], session_remote[5], session_remote[6], session_remote[7]);\n\t      failed = 1;\n\t    }\n\t  } else\n\t    failed = 1;\n\t} else\n// fix_end\n", "cwe": "CWE-125", "cwe_name": "Out-of-bounds Read", "cve": "CVE-2020-15473", "cve_desc": "In nDPI through 3.2, the OpenVPN dissector is vulnerable to a heap-based buffer over-read in ndpi_search_openvpn in lib/protocols/openvpn.c.", "project": "nDPI", "idx": 196624}
{"source": "   void Compute(OpKernelContext* context) override {\n     const Tensor& input_sizes = context->input(0);\n     const Tensor& filter = context->input(1);\n     const Tensor& out_backprop = context->input(2);\n \n     TensorShape input_shape;\n     OP_REQUIRES_OK(context,\n                    Conv2DBackpropComputeInputShape(input_sizes, filter.shape(),\n                                                    out_backprop.shape(),\n                                                    data_format_, &input_shape));\n \n     ConvBackpropDimensions dims;\n     OP_REQUIRES_OK(context,\n                    ConvBackpropComputeDimensionsV2(\n                        \"Conv2DCustomBackpropInput\", 2,\n                        input_shape, filter.shape(), out_backprop.shape(),\n                        {1, 1, 1, 1}, strides_, padding_,\n                        explicit_paddings_, data_format_, &dims));\n \n     OP_REQUIRES(context, dims.in_depth == filter.shape().dim_size(2),\n                 errors::InvalidArgument(\"Computed input depth \", dims.in_depth,\n                                         \" doesn't match filter input depth \",\n                                         filter.shape().dim_size(2)));\n     OP_REQUIRES(\n         context, dims.out_depth == filter.shape().dim_size(3),\n         errors::InvalidArgument(\"Computed output depth \", dims.out_depth,\n                                 \" doesn't match filter output depth \",\n                                 filter.shape().dim_size(3)));\n \n     Tensor* in_backprop = nullptr;\n     OP_REQUIRES_OK(context,\n                    context->allocate_output(0, input_shape, &in_backprop));\n \n     if (input_shape.num_elements() == 0) {\n       return;\n     }\n \n #if defined TENSORFLOW_USE_LIBXSMM_CONVOLUTIONS && \\\n     defined TENSORFLOW_USE_LIBXSMM_BACKWARD_CONVOLUTIONS\n     int64 pad_top, pad_bottom;\n     int64 pad_left, pad_right;\n     OP_REQUIRES_OK(\n         context,\n         GetWindowedOutputSizeVerbose(\n             dims.spatial_dims[0].input_size, dims.spatial_dims[0].filter_size,\n             dims.spatial_dims[0].stride, padding_,\n             &dims.spatial_dims[0].output_size, &pad_top, &pad_bottom));\n     OP_REQUIRES_OK(\n         context,\n         GetWindowedOutputSizeVerbose(\n             dims.spatial_dims[1].input_size, dims.spatial_dims[1].filter_size,\n             dims.spatial_dims[1].stride, padding_,\n             &dims.spatial_dims[1].output_size, &pad_left, &pad_right));\n \n     if (pad_left == pad_right && pad_top == pad_bottom) {\n       if (LaunchXsmmBackwardInputConvolution<Device, T>()(\n               context, context->eigen_device<Device>(),\n               in_backprop->tensor<T, 4>(), filter.tensor<T, 4>(),\n               out_backprop.tensor<T, 4>(), dims.spatial_dims[0].input_size,\n               dims.spatial_dims[1].input_size,\n               static_cast<int>(dims.spatial_dims[0].stride),\n               static_cast<int>(dims.spatial_dims[1].stride),\n               static_cast<int>(pad_top), static_cast<int>(pad_left),\n               data_format_)) {\n         return;\n       }\n     }\n #else\n     int64 pad_top, pad_bottom;\n     int64 pad_left, pad_right;\n #endif\n     if (padding_ == Padding::EXPLICIT) {\n       pad_top = explicit_paddings_[2];\n       pad_bottom = explicit_paddings_[3];\n       pad_left = explicit_paddings_[4];\n       pad_right = explicit_paddings_[5];\n     }\n     OP_REQUIRES_OK(\n         context,\n         GetWindowedOutputSizeVerbose(\n             dims.spatial_dims[0].input_size, dims.spatial_dims[0].filter_size,\n             dims.spatial_dims[0].stride, padding_,\n             &dims.spatial_dims[0].output_size, &pad_top, &pad_bottom));\n     OP_REQUIRES_OK(\n         context,\n         GetWindowedOutputSizeVerbose(\n             dims.spatial_dims[1].input_size, dims.spatial_dims[1].filter_size,\n             dims.spatial_dims[1].stride, padding_,\n             &dims.spatial_dims[1].output_size, &pad_left, &pad_right));\n \n     const int filter_total_size = dims.spatial_dims[0].filter_size *\n                                   dims.spatial_dims[1].filter_size *\n                                   dims.in_depth;\n     const int output_image_size =\n         dims.spatial_dims[0].output_size * dims.spatial_dims[1].output_size;\n \n     const size_t l2_cache_size = 256LL << 10;\n     const size_t l3_cache_size = 30LL << 20;\n \n     const size_t target_working_set_size = l3_cache_size / sizeof(T);\n \n     const size_t size_A = output_image_size * dims.out_depth;\n \n     const size_t size_B = filter_total_size * dims.out_depth;\n \n     const size_t size_C = output_image_size * filter_total_size;\n \n     const size_t work_unit_size = size_A + size_B + size_C;\n \n     auto worker_threads = *(context->device()->tensorflow_cpu_worker_threads());\n \n     const size_t thread_work_unit_size =\n         work_unit_size / worker_threads.num_threads;\n \n     const size_t min_thread_work_unit_size = l2_cache_size / sizeof(T);\n \n     const bool use_parallel_contraction =\n         dims.batch_size == 1 ||\n         thread_work_unit_size >= min_thread_work_unit_size;\n \n// bug_start\n// bug_end\n     const size_t shard_size =\n         use_parallel_contraction\n             ? 1\n             : (target_working_set_size + work_unit_size - 1) / work_unit_size;\n \n     Tensor col_buffer;\n     OP_REQUIRES_OK(context,\n                    context->allocate_temp(\n                        DataTypeToEnum<T>::value,\n                        TensorShape({static_cast<int64>(shard_size),\n                                     static_cast<int64>(output_image_size),\n                                     static_cast<int64>(filter_total_size)}),\n                        &col_buffer));\n \n     const int input_offset = dims.spatial_dims[0].input_size *\n                              dims.spatial_dims[1].input_size * dims.in_depth;\n     const int output_offset = dims.spatial_dims[0].output_size *\n                               dims.spatial_dims[1].output_size * dims.out_depth;\n \n     const T* filter_data = filter.template flat<T>().data();\n     T* col_buffer_data = col_buffer.template flat<T>().data();\n     const T* out_backprop_data = out_backprop.template flat<T>().data();\n \n     auto in_backprop_flat = in_backprop->template flat<T>();\n     T* input_backprop_data = in_backprop_flat.data();\n     in_backprop_flat.device(context->eigen_device<Device>()) =\n         in_backprop_flat.constant(T(0));\n \n     if (use_parallel_contraction) {\n       typedef Eigen::TensorMap<Eigen::Tensor<T, 2, Eigen::RowMajor>,\n                                Eigen::Unaligned>\n           TensorMap;\n       typedef Eigen::TensorMap<Eigen::Tensor<const T, 2, Eigen::RowMajor>,\n                                Eigen::Unaligned>\n           ConstTensorMap;\n \n       Eigen::array<Eigen::IndexPair<Eigen::DenseIndex>, 1> contract_dims;\n       contract_dims[0].first = 1;\n       contract_dims[0].second = 1;\n \n       for (int image_id = 0; image_id < dims.batch_size; ++image_id) {\n         TensorMap C(col_buffer_data, output_image_size, filter_total_size);\n \n         ConstTensorMap A(out_backprop_data + output_offset * image_id,\n                          output_image_size, dims.out_depth);\n         ConstTensorMap B(filter_data, filter_total_size, dims.out_depth);\n \n         C.device(context->eigen_cpu_device()) = A.contract(B, contract_dims);\n \n         Col2im<T>(\n             col_buffer_data, dims.in_depth, dims.spatial_dims[0].input_size,\n             dims.spatial_dims[1].input_size, dims.spatial_dims[0].filter_size,\n             dims.spatial_dims[1].filter_size, pad_top, pad_left, pad_bottom,\n             pad_right, dims.spatial_dims[0].stride, dims.spatial_dims[1].stride,\n             input_backprop_data);\n \n         input_backprop_data += input_offset;\n       }\n     } else {\n       for (int image_id = 0; image_id < dims.batch_size;\n            image_id += shard_size) {\n         const int shard_limit =\n             std::min(static_cast<int>(shard_size),\n                      static_cast<int>(dims.batch_size) - image_id);\n \n         auto shard = [&context, &dims, &pad_top, &pad_left, &pad_bottom,\n                       &pad_right, &output_image_size, &filter_total_size,\n                       &input_backprop_data, &col_buffer_data,\n                       &out_backprop_data, &filter_data, &input_offset,\n                       &output_offset, &size_C](int64 start, int64 limit) {\n           for (int shard_id = start; shard_id < limit; ++shard_id) {\n             T* im2col_buf = col_buffer_data + shard_id * size_C;\n             T* input_data = input_backprop_data + shard_id * input_offset;\n             const T* out_data = out_backprop_data + shard_id * output_offset;\n \n             Conv2DCustomBackpropInputMatMulFunctor<T>()(\n                 context, out_data, filter_data, filter_total_size,\n                 output_image_size, dims.out_depth, im2col_buf);\n \n             Col2im<T>(im2col_buf, dims.in_depth,\n                       dims.spatial_dims[0].input_size,\n                       dims.spatial_dims[1].input_size,\n                       dims.spatial_dims[0].filter_size,\n                       dims.spatial_dims[1].filter_size, pad_top, pad_left,\n                       pad_bottom, pad_right, dims.spatial_dims[0].stride,\n                       dims.spatial_dims[1].stride, input_data);\n           }\n         };\n         Shard(worker_threads.num_threads, worker_threads.workers, shard_limit,\n               work_unit_size, shard);\n \n         input_backprop_data += input_offset * shard_limit;\n         out_backprop_data += output_offset * shard_limit;\n       }\n     }\n   }\n \n", "target": "// fix_start\n    OP_REQUIRES(\n        context, work_unit_size > 0,\n        errors::InvalidArgument(\"input, filter_sizes and out_backprop tensors \"\n                                \"must all have at least 1 element\"));\n\n// fix_end\n", "cwe": "CWE-369", "cwe_name": "Divide By Zero", "cve": "CVE-2021-29525", "cve_desc": "TensorFlow is an end-to-end open source platform for machine learning. An attacker can trigger a division by 0 in `tf.raw_ops.Conv2DBackpropInput`. This is because the implementation(https://github.com/tensorflow/tensorflow/blob/b40060c9f697b044e3107917c797ba052f4506ab/tensorflow/core/kernels/conv_grad_input_ops.h#L625-L655) does a division by a quantity that is controlled by the caller. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.", "project": "tensorflow", "idx": 196632}
{"source": " escape_xml(const char *text)\n {\n \tstatic char *escaped;\n \tstatic size_t escaped_size;\n \tchar *out;\n \tsize_t len;\n \n// bug_start\n\tif (!strlen(text)) return \"empty string\";\n// bug_end\n \n \tfor (out=escaped, len=0; *text; ++len, ++out, ++text) {\n \t\tif ((len + 8) > escaped_size) {\n \t\t\tchar *bigger_escaped;\n \t\t\tescaped_size += 128;\n \t\t\tbigger_escaped = realloc(escaped, escaped_size);\n \t\t\tif (!bigger_escaped) {\n \t\t\t\tfree(escaped);\n \t\t\t\tescaped = NULL;\n \t\t\t\tescaped_size = 0;\n \t\t\t\treturn \">>> out of memory <<<\";\n \t\t\t}\n \t\t\tout = bigger_escaped + len;\n \t\t\tescaped = bigger_escaped;\n \t\t}\n \t\tswitch (*text) {\n \t\t\tcase '&':\n \t\t\t\tstrcpy(out, \"&amp;\");\n \t\t\t\tlen += strlen(out) - 1;\n \t\t\t\tout = escaped + len;\n \t\t\t\tbreak;\n \t\t\tcase '<':\n \t\t\t\tstrcpy(out, \"&lt;\");\n \t\t\t\tlen += strlen(out) - 1;\n \t\t\t\tout = escaped + len;\n \t\t\t\tbreak;\n \t\t\tcase '>':\n \t\t\t\tstrcpy(out, \"&gt;\");\n \t\t\t\tlen += strlen(out) - 1;\n \t\t\t\tout = escaped + len;\n \t\t\t\tbreak;\n \t\t\tdefault:\n \t\t\t\t*out = *text;\n \t\t\t\tbreak;\n \t\t}\n \t}\n \t*out = '\\x0';\n \treturn escaped;\n }\n \n", "target": "// fix_start\n\tif (!strlen(text)) return \"\";\n// fix_end\n", "cwe": "CWE-476", "cwe_name": "NULL Pointer Dereference", "cve": "CVE-2021-27815", "cve_desc": "NULL Pointer Deference in the exif command line tool, when printing out XML formatted EXIF data, in exif v0.6.22 and earlier allows attackers to cause a Denial of Service (DoS) by uploading a malicious JPEG file, causing the application to crash.", "project": "exif", "idx": 196672}
{"source": "   void Compute(OpKernelContext* context) override {\n// bug_start\n    const float in_min = context->input(2).flat<float>()(0);\n    const float in_max = context->input(3).flat<float>()(0);\n// bug_end\n \n     ImageResizerState st(align_corners_, false);\n     st.ValidateAndCreateOutput(context);\n \n     if (!context->status().ok()) return;\n \n     if (st.output->NumElements() == 0) return;\n \n     typename TTypes<T, 4>::ConstTensor image_data(\n         context->input(0).tensor<T, 4>());\n     typename TTypes<T, 4>::Tensor output_data(st.output->tensor<T, 4>());\n \n     ResizeBilinear<T>(image_data, st.height_scale, st.width_scale, in_min,\n                       in_max, half_pixel_centers_, &output_data);\n     Tensor* out_min = nullptr;\n     OP_REQUIRES_OK(context, context->allocate_output(1, {}, &out_min));\n     out_min->flat<float>()(0) = in_min;\n \n     Tensor* out_max = nullptr;\n     OP_REQUIRES_OK(context, context->allocate_output(2, {}, &out_max));\n     out_max->flat<float>()(0) = in_max;\n   }\n \n", "target": "// fix_start\n    const auto& in_min_tensor = context->input(2);\n    OP_REQUIRES(context, TensorShapeUtils::IsScalar(in_min_tensor.shape()),\n                errors::InvalidArgument(\"min must be a scalar\"));\n    const float in_min = in_min_tensor.flat<float>()(0);\n    const auto& in_max_tensor = context->input(3);\n    OP_REQUIRES(context, TensorShapeUtils::IsScalar(in_max_tensor.shape()),\n                errors::InvalidArgument(\"max must be a scalar\"));\n    const float in_max = in_max_tensor.flat<float>()(0);\n// fix_end\n", "cwe": "CWE-787", "cwe_name": "Out-of-bounds Write", "cve": "CVE-2021-29537", "cve_desc": "TensorFlow is an end-to-end open source platform for machine learning. An attacker can cause a heap buffer overflow in `QuantizedResizeBilinear` by passing in invalid thresholds for the quantization. This is because the implementation(https://github.com/tensorflow/tensorflow/blob/50711818d2e61ccce012591eeb4fdf93a8496726/tensorflow/core/kernels/quantized_resize_bilinear_op.cc#L705-L706) assumes that the 2 arguments are always valid scalars and tries to access the numeric value directly. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.", "project": "tensorflow", "idx": 196673}
{"source": " void gf_inspect_format_timecode(const u8 *data, u32 size, u32 tmcd_flags, u32 tc_num, u32 tc_den, u32 tmcd_fpt, char szFmt[100]);\n \n void DumpTrackInfo(GF_ISOFile *file, GF_ISOTrackID trackID, Bool full_dump, Bool is_track_num, Bool dump_m4sys)\n {\n \tchar szCodec[RFC6381_CODEC_NAME_SIZE_MAX];\n \tDouble scale, max_rate, rate;\n \tBool is_od_track = 0;\n \tu32 trackNum, i, j, ts, mtype, msub_type, timescale, sr, nb_ch, count, alt_group, nb_groups, nb_edits, cdur, csize, bps, pfmt, codecid;\n \tu64 time_slice, dur, size;\n \ts32 cts_shift;\n \tGF_ESD *esd;\n \tchar szDur[50];\n \tchar *lang;\n \n \tif (!is_track_num) {\n \t\ttrackNum = gf_isom_get_track_by_id(file, trackID);\n \t} else {\n \t\ttrackNum = trackID;\n \t\ttrackID = gf_isom_get_track_id(file, trackNum);\n \t}\n \tif (!trackNum) {\n \t\tM4_LOG(GF_LOG_ERROR, (\"No track with ID %d found\\n\", trackID));\n \t\treturn;\n \t}\n \n \ttimescale = gf_isom_get_media_timescale(file, trackNum);\n \tfprintf(stderr, \"# Track %d Info - ID %d - TimeScale %d\\n\", trackNum, trackID, timescale);\n \n \tdur = gf_isom_get_media_original_duration(file, trackNum);\n \tsize = gf_isom_get_media_duration(file, trackNum);\n \tfprintf(stderr, \"Media Duration %s \", format_duration(dur, timescale, szDur));\n \tif (dur != size)\n \t\tfprintf(stderr, \" (recomputed %s)\", format_duration(size, timescale, szDur));\n \tfprintf(stderr, \"\\n\");\n \n \tif (gf_isom_check_data_reference(file, trackNum, 1) != GF_OK) {\n \t\tM4_LOG(GF_LOG_WARNING, (\"Track uses external data reference not supported by GPAC!\\n\"));\n \t}\n \n \tnb_edits = gf_isom_get_edits_count(file, trackNum);\n \tif (nb_edits)\n \t\tfprintf(stderr, \"Track has %d edits: track duration is %s\\n\", nb_edits, format_duration(gf_isom_get_track_duration(file, trackNum), gf_isom_get_timescale(file), szDur));\n \n \tcts_shift = gf_isom_get_composition_offset_shift(file, trackNum);\n \tif (cts_shift)\n \t\tfprintf(stderr, \"Track composition offset shift (negative CTS offset): %d\\n\", cts_shift);\n \n \tif (gf_isom_is_track_in_root_od(file, trackNum) ) fprintf(stderr, \"Track is present in Root OD\\n\");\n \tif (!gf_isom_is_track_enabled(file, trackNum))  fprintf(stderr, \"Track is disabled\\n\");\n \tgf_isom_get_media_language(file, trackNum, &lang);\n \tfprintf(stderr, \"Media Info: Language \\\"%s (%s)\\\" - \", GetLanguage(lang), lang );\n \tgf_free(lang);\n \tmtype = gf_isom_get_media_type(file, trackNum);\n \tfprintf(stderr, \"Type \\\"%s:\", gf_4cc_to_str(mtype));\n \tmsub_type = gf_isom_get_mpeg4_subtype(file, trackNum, 1);\n \tif (!msub_type) msub_type = gf_isom_get_media_subtype(file, trackNum, 1);\n \tfprintf(stderr, \"%s\\\" - %d samples\\n\", gf_4cc_to_str(msub_type), gf_isom_get_sample_count(file, trackNum));\n \n \tpfmt = gf_pixel_fmt_from_qt_type(msub_type);\n \tcodecid = gf_codec_id_from_isobmf(msub_type);\n \n \tcount = gf_isom_get_track_kind_count(file, trackNum);\n \tfor (i = 0; i < count; i++) {\n \t\tchar *kind_scheme, *kind_value;\n \t\tgf_isom_get_track_kind(file, trackNum, i, &kind_scheme, &kind_value);\n \t\tfprintf(stderr, \"Kind: %s - %s\\n\", kind_scheme ? kind_scheme : \"null\", kind_value ? kind_value : \"null\");\n \t\tif (kind_scheme) gf_free(kind_scheme);\n \t\tif (kind_value) gf_free(kind_value);\n \t}\n \n \tif (gf_isom_is_track_fragmented(file, trackID) ) {\n \t\tu32 defaultDuration, defaultSize, defaultDescriptionIndex, defaultRandomAccess;\n \t\tu8 defaultPadding;\n \t\tu16 defaultDegradationPriority;\n \t\tu32 frag_samples;\n \t\tu64 frag_duration;\n \t\tgf_isom_get_fragmented_samples_info(file, trackID, &frag_samples, &frag_duration);\n \t\tfprintf(stderr, \"Fragmented track: %d samples - Media Duration %s\\n\", frag_samples, format_duration(frag_duration, timescale, szDur));\n \n \t\tgf_isom_get_fragment_defaults(file, trackNum, &defaultDuration, &defaultSize, &defaultDescriptionIndex, &defaultRandomAccess, &defaultPadding, &defaultDegradationPriority);\n \n \t\tfprintf(stderr, \"Fragment sample defaults: duration %d size %d stsd %d sync %d padding %d degradation_priority %d\\n\",\n \t\t\t\tdefaultDuration, defaultSize, defaultDescriptionIndex, defaultRandomAccess,\n \t\t\t\t(u32) defaultPadding, (u32) defaultDegradationPriority\n \t\t);\n \t}\n \n \tif (!gf_isom_is_self_contained(file, trackNum, 1)) {\n \t\tconst char *url, *urn;\n \t\tgf_isom_get_data_reference(file, trackNum, 1, &url, &urn);\n \t\tfprintf(stderr, \"Media Data Location: %s\\n\", url ? url : urn);\n \t}\n \n \tif (full_dump) {\n \t\tconst char *handler_name;\n \t\tgf_isom_get_handler_name(file, trackNum, &handler_name);\n \t\tfprintf(stderr, \"Handler name: %s\\n\", handler_name);\n \t}\n \n \tprint_udta(file, trackNum, GF_FALSE);\n \n \tif (gf_isom_is_video_handler_type(mtype) ) {\n \t\ts32 tx, ty;\n \t\tu32 w, h;\n \t\tu16 bit_depth;\n \n \t\tgf_isom_get_visual_info(file, trackNum, 1, &w, &h);\n \t\tgf_isom_get_visual_bit_depth(file, trackNum, 1, &bit_depth);\n \t\tfprintf(stderr, \"Visual Sample Entry Info: width=%d height=%d (depth=%d bits)\\n\", w, h, (int)bit_depth);\n \n \t\tgf_isom_get_track_layout_info(file, trackNum, &w, &h, &tx, &ty, NULL);\n \t\tfprintf(stderr, \"Visual Track layout: x=%d y=%d width=%d height=%d\\n\", tx, ty, w, h);\n \t}\n \n \tgf_isom_get_audio_info(file, trackNum, 1, &sr, &nb_ch, &bps);\n \tgf_isom_set_nalu_extract_mode(file, trackNum, GF_ISOM_NALU_EXTRACT_INSPECT);\n \n \tmsub_type = gf_isom_get_media_subtype(file, trackNum, 1);\n \tif (msub_type==GF_ISOM_SUBTYPE_MPEG4_CRYP)\n \t\tgf_isom_get_original_format_type(file, trackNum, 1, &msub_type);\n \n \tif ((msub_type==GF_ISOM_SUBTYPE_MPEG4)\n \t        || (msub_type==GF_ISOM_SUBTYPE_AVC_H264)\n \t        || (msub_type==GF_ISOM_SUBTYPE_AVC2_H264)\n \t        || (msub_type==GF_ISOM_SUBTYPE_AVC3_H264)\n \t        || (msub_type==GF_ISOM_SUBTYPE_AVC4_H264)\n \t        || (msub_type==GF_ISOM_SUBTYPE_SVC_H264)\n \t        || (msub_type==GF_ISOM_SUBTYPE_MVC_H264)\n \t        || (msub_type==GF_ISOM_SUBTYPE_LSR1)\n \t        || (msub_type==GF_ISOM_SUBTYPE_HVC1)\n \t        || (msub_type==GF_ISOM_SUBTYPE_HEV1)\n \t        || (msub_type==GF_ISOM_SUBTYPE_HVC2)\n \t        || (msub_type==GF_ISOM_SUBTYPE_HEV2)\n \t        || (msub_type==GF_ISOM_SUBTYPE_LHV1)\n \t        || (msub_type==GF_ISOM_SUBTYPE_LHE1)\n \t        || (msub_type==GF_ISOM_SUBTYPE_HVT1)\n \t   )  {\n \t\tesd = gf_isom_get_esd(file, trackNum, 1);\n \t\tif (!esd || !esd->decoderConfig) {\n \t\t\tM4_LOG(GF_LOG_WARNING, (\"WARNING: Broken MPEG-4 Track\\n\"));\n \t\t\tif (esd) gf_odf_desc_del((GF_Descriptor *)esd);\n \t\t} else {\n \t\t\tconst char *st = gf_stream_type_name(esd->decoderConfig->streamType);\n \t\t\tif (dump_m4sys) {\n \t\t\t\tif (st) {\n \t\t\t\t\tfprintf(stderr, \"MPEG-4 Config%s%s Stream - ObjectTypeIndication 0x%02x\\n\",\n \t\t\t\t\t\t\tfull_dump ? \"\\n\\t\" : \": \", st, esd->decoderConfig->objectTypeIndication);\n \t\t\t\t} else {\n \t\t\t\t\tfprintf(stderr, \"MPEG-4 Config%sStream Type 0x%02x - ObjectTypeIndication 0x%02x\\n\",\n \t\t\t\t\t\t\tfull_dump ? \"\\n\\t\" : \": \", esd->decoderConfig->streamType, esd->decoderConfig->objectTypeIndication);\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tif (esd->decoderConfig->streamType==GF_STREAM_OD)\n \t\t\t\tis_od_track=1;\n \n \t\t\tif (esd->decoderConfig->streamType==GF_STREAM_VISUAL) {\n \t\t\t\tu32 w, h;\n \t\t\t\tu16 rvc_predef;\n \t\t\t\tw = h = 0;\n \t\t\t\tif (esd->decoderConfig->objectTypeIndication==GF_CODECID_MPEG4_PART2) {\n #ifndef GPAC_DISABLE_AV_PARSERS\n \t\t\t\t\tif (!esd->decoderConfig->decoderSpecificInfo) {\n #else\n \t\t\t\t\tgf_isom_get_visual_info(file, trackNum, 1, &w, &h);\n \t\t\t\t\tfprintf(stderr, \"MPEG-4 Visual Size %d x %d\\n\", w, h);\n #endif\n \t\t\t\t\t\tM4_LOG(GF_LOG_WARNING, (\"Non-compliant MPEG-4 Visual track: video_object_layer infos not found in sample description\\n\"));\n #ifndef GPAC_DISABLE_AV_PARSERS\n \t\t\t\t\t} else {\n \t\t\t\t\t\tGF_M4VDecSpecInfo dsi;\n \t\t\t\t\t\tgf_m4v_get_config(esd->decoderConfig->decoderSpecificInfo->data, esd->decoderConfig->decoderSpecificInfo->dataLength, &dsi);\n \t\t\t\t\t\tif (full_dump) fprintf(stderr, \"\\t\");\n \t\t\t\t\t\tw = dsi.width;\n \t\t\t\t\t\th = dsi.height;\n \t\t\t\t\t\tfprintf(stderr, \"MPEG-4 Visual Size %d x %d - %s\\n\", w, h, gf_m4v_get_profile_name(dsi.VideoPL));\n \t\t\t\t\t\tif (dsi.par_den && dsi.par_num) {\n \t\t\t\t\t\t\tu32 tw, th;\n \t\t\t\t\t\t\tgf_isom_get_track_layout_info(file, trackNum, &tw, &th, NULL, NULL, NULL);\n \t\t\t\t\t\t\tfprintf(stderr, \"Pixel Aspect Ratio %d:%d - Indicated track size %d x %d\\n\", dsi.par_num, dsi.par_den, tw, th);\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n #endif\n \t\t\t\t} else if (gf_isom_get_avc_svc_type(file, trackNum, 1) != GF_ISOM_AVCTYPE_NONE) {\n \t\t\t\t\tGF_AVCConfig *avccfg, *svccfg, *mvccfg;\n \n \t\t\t\t\tgf_isom_get_visual_info(file, trackNum, 1, &w, &h);\n \t\t\t\t\tif (full_dump) fprintf(stderr, \"\\t\");\n \t\t\t\t\tfprintf(stderr, \"AVC/H264 Video - Visual Size %d x %d\\n\", w, h);\n \n \t\t\t\t\tavccfg = gf_isom_avc_config_get(file, trackNum, 1);\n \t\t\t\t\tsvccfg = gf_isom_svc_config_get(file, trackNum, 1);\n \t\t\t\t\tmvccfg = gf_isom_mvc_config_get(file, trackNum, 1);\n \t\t\t\t\tif (!avccfg && !svccfg && !mvccfg) {\n \t\t\t\t\t\tM4_LOG(GF_LOG_ERROR, (\"\\tNon-compliant AVC track: SPS/PPS not found in sample description\\n\"));\n \t\t\t\t\t} else if (avccfg) {\n \t\t\t\t\t\tfprintf(stderr, \"\\tAVC Info: %d SPS - %d PPS\", gf_list_count(avccfg->sequenceParameterSets) , gf_list_count(avccfg->pictureParameterSets) );\n \t\t\t\t\t\tfprintf(stderr, \" - Profile %s @ Level %g\\n\", gf_avc_get_profile_name(avccfg->AVCProfileIndication), ((Double)avccfg->AVCLevelIndication)/10.0 );\n \t\t\t\t\t\tfprintf(stderr, \"\\tNAL Unit length bits: %d\\n\", 8*avccfg->nal_unit_size);\n \n #ifndef GPAC_DISABLE_AV_PARSERS\n \t\t\t\t\t\tfor (i=0; i<gf_list_count(avccfg->sequenceParameterSets); i++) {\n \t\t\t\t\t\t\ts32 par_n, par_d;\n \t\t\t\t\t\t\tGF_NALUFFParam *slc = gf_list_get(avccfg->sequenceParameterSets, i);\n \t\t\t\t\t\t\tgf_avc_get_sps_info(slc->data, slc->size, NULL, NULL, NULL, &par_n, &par_d);\n \t\t\t\t\t\t\tif ((par_n>0) && (par_d>0)) {\n \t\t\t\t\t\t\t\tu32 tw, th;\n \t\t\t\t\t\t\t\tgf_isom_get_track_layout_info(file, trackNum, &tw, &th, NULL, NULL, NULL);\n \t\t\t\t\t\t\t\tfprintf(stderr, \"\\tPixel Aspect Ratio %d:%d - Indicated track size %d x %d\\n\", par_n, par_d, tw, th);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\tif (!full_dump) break;\n \t\t\t\t\t\t}\n #endif\n \n \t\t\t\t\t\tif (avccfg->chroma_bit_depth) {\n \t\t\t\t\t\t\tfprintf(stderr, \"\\tChroma format %s - Luma bit depth %d - chroma bit depth %d\\n\", gf_avc_hevc_get_chroma_format_name(avccfg->chroma_format), avccfg->luma_bit_depth, avccfg->chroma_bit_depth);\n \t\t\t\t\t\t}\n \n \t\t\t\t\t\tprint_config_hash(avccfg->sequenceParameterSets, \"SPS\");\n \t\t\t\t\t\tprint_config_hash(avccfg->pictureParameterSets, \"PPS\");\n \n \t\t\t\t\t\tgf_odf_avc_cfg_del(avccfg);\n \t\t\t\t\t}\n \t\t\t\t\tif (svccfg) {\n \t\t\t\t\t\tfprintf(stderr, \"\\n\\tSVC Info: %d SPS - %d PPS - Profile %s @ Level %g\\n\", gf_list_count(svccfg->sequenceParameterSets) , gf_list_count(svccfg->pictureParameterSets), gf_avc_get_profile_name(svccfg->AVCProfileIndication), ((Double)svccfg->AVCLevelIndication)/10.0 );\n \t\t\t\t\t\tfprintf(stderr, \"\\tSVC NAL Unit length bits: %d\\n\", 8*svccfg->nal_unit_size);\n #ifndef GPAC_DISABLE_AV_PARSERS\n \t\t\t\t\t\tfor (i=0; i<gf_list_count(svccfg->sequenceParameterSets); i++) {\n \t\t\t\t\t\t\tGF_NALUFFParam *slc = gf_list_get(svccfg->sequenceParameterSets, i);\n \t\t\t\t\t\t\tif (slc) {\n \t\t\t\t\t\t\t\ts32 par_n, par_d;\n \t\t\t\t\t\t\t\tu32 s_w, s_h, sps_id;\n \t\t\t\t\t\t\t\tgf_avc_get_sps_info(slc->data, slc->size, &sps_id, &s_w, &s_h, &par_n, &par_d);\n \t\t\t\t\t\t\t\tfprintf(stderr, \"\\t\\tSPS ID %d - Visual Size %d x %d\\n\", sps_id, s_w, s_h);\n \t\t\t\t\t\t\t\tif ((par_n>0) && (par_d>0)) {\n \t\t\t\t\t\t\t\t\tu32 tw, th;\n \t\t\t\t\t\t\t\t\tgf_isom_get_track_layout_info(file, trackNum, &tw, &th, NULL, NULL, NULL);\n \t\t\t\t\t\t\t\t\tfprintf(stderr, \"\\tPixel Aspect Ratio %d:%d - Indicated track size %d x %d\\n\", par_n, par_d, tw, th);\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}\n #endif\n \t\t\t\t\t\tprint_config_hash(svccfg->sequenceParameterSets, \"SPS\");\n \t\t\t\t\t\tprint_config_hash(svccfg->pictureParameterSets, \"PPS\");\n \t\t\t\t\t\tprint_config_hash(svccfg->sequenceParameterSetExtensions, \"SPSEx\");\n \n \t\t\t\t\t\tgf_odf_avc_cfg_del(svccfg);\n \t\t\t\t\t}\n \n \t\t\t\t\tif (mvccfg) {\n \t\t\t\t\t\tfprintf(stderr, \"\\n\\tMVC Info: %d SPS - %d PPS - Profile %s @ Level %g\\n\", gf_list_count(mvccfg->sequenceParameterSets) , gf_list_count(mvccfg->pictureParameterSets), gf_avc_get_profile_name(mvccfg->AVCProfileIndication), ((Double)mvccfg->AVCLevelIndication)/10.0 );\n \t\t\t\t\t\tfprintf(stderr, \"\\tMVC NAL Unit length bits: %d\\n\", 8*mvccfg->nal_unit_size);\n #ifndef GPAC_DISABLE_AV_PARSERS\n \t\t\t\t\t\tfor (i=0; i<gf_list_count(mvccfg->sequenceParameterSets); i++) {\n \t\t\t\t\t\t\tGF_NALUFFParam *slc = gf_list_get(mvccfg->sequenceParameterSets, i);\n \t\t\t\t\t\t\tif (slc) {\n \t\t\t\t\t\t\t\tu32 s_w, s_h, sps_id;\n \t\t\t\t\t\t\t\ts32 par_n, par_d;\n \t\t\t\t\t\t\t\tgf_avc_get_sps_info(slc->data, slc->size, &sps_id, &s_w, &s_h, &par_n, &par_d);\n \t\t\t\t\t\t\t\tfprintf(stderr, \"\\t\\tSPS ID %d - Visual Size %d x %d\\n\", sps_id, s_w, s_h);\n \t\t\t\t\t\t\t\tif ((par_n>0) && (par_d>0)) {\n \t\t\t\t\t\t\t\t\tu32 tw, th;\n \t\t\t\t\t\t\t\t\tgf_isom_get_track_layout_info(file, trackNum, &tw, &th, NULL, NULL, NULL);\n \t\t\t\t\t\t\t\t\tfprintf(stderr, \"\\tPixel Aspect Ratio %d:%d - Indicated track size %d x %d\\n\", par_n, par_d, tw, th);\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}\n #endif\n \t\t\t\t\t\tprint_config_hash(mvccfg->sequenceParameterSets, \"SPS\");\n \t\t\t\t\t\tprint_config_hash(mvccfg->pictureParameterSets, \"PPS\");\n \t\t\t\t\t\tgf_odf_avc_cfg_del(mvccfg);\n \t\t\t\t\t}\n \n \t\t\t\t} else if ((esd->decoderConfig->objectTypeIndication==GF_CODECID_HEVC)\n \t\t\t\t           || (esd->decoderConfig->objectTypeIndication==GF_CODECID_LHVC)\n \t\t\t\t          ) {\n \t\t\t\t\tGF_HEVCConfig *hevccfg, *lhvccfg;\n \t\t\t\t\tGF_OperatingPointsInformation *oinf;\n #if !defined(GPAC_DISABLE_AV_PARSERS) && !defined(GPAC_DISABLE_HEVC)\n \t\t\t\t\tHEVCState hevc_state;\n \t\t\t\t\tmemset(&hevc_state, 0, sizeof(HEVCState));\n \t\t\t\t\thevc_state.sps_active_idx = -1;\n #endif\n \n \t\t\t\t\tgf_isom_get_visual_info(file, trackNum, 1, &w, &h);\n \t\t\t\t\tif (full_dump) fprintf(stderr, \"\\t\");\n \t\t\t\t\tfprintf(stderr, \"HEVC Video - Visual Size %d x %d\\n\", w, h);\n \t\t\t\t\thevccfg = gf_isom_hevc_config_get(file, trackNum, 1);\n \t\t\t\t\tlhvccfg = gf_isom_lhvc_config_get(file, trackNum, 1);\n \n \t\t\t\t\tif (msub_type==GF_ISOM_SUBTYPE_HVT1) {\n \t\t\t\t\t\tconst u8 *data;\n \t\t\t\t\t\tu32 tsize;\n \t\t\t\t\t\tu32  is_default, tx,ty,tw,th, id, independent;\n \t\t\t\t\t\tBool full_frame;\n \t\t\t\t\t\tif (gf_isom_get_tile_info(file, trackNum, 1, &is_default, &id, &independent, &full_frame, &tx, &ty, &tw, &th)) {\n \t\t\t\t\t\t\tfprintf(stderr, \"\\tHEVC Tile - ID %d independent %d (x,y,w,h)=%d,%d,%d,%d \\n\", id, independent, tx, ty, tw, th);\n \t\t\t\t\t\t} else if (gf_isom_get_sample_group_info(file, trackNum, 1, GF_ISOM_SAMPLE_GROUP_TRIF, &is_default, &data, &tsize)) {\n \t\t\t\t\t\t\tfprintf(stderr, \"\\tHEVC Tile track containing a tile set\\n\");\n \t\t\t\t\t\t} else {\n \t\t\t\t\t\t\tfprintf(stderr, \"\\tHEVC Tile track without tiling info\\n\");\n \t\t\t\t\t\t}\n \t\t\t\t\t} else if (!hevccfg && !lhvccfg) {\n \t\t\t\t\t\tM4_LOG(GF_LOG_ERROR, (\"\\tNon-compliant HEVC track: No hvcC or shcC found in sample description\\n\"));\n \t\t\t\t\t}\n \n \t\t\t\t\tif (gf_isom_get_reference_count(file, trackNum, GF_ISOM_REF_SABT)) {\n \t\t\t\t\t\tfprintf(stderr, \"\\tHEVC Tile base track\\n\");\n \t\t\t\t\t}\n \t\t\t\t\tif (hevccfg) {\n \t\t\t\t\t\tdump_hevc_track_info(file, trackNum, hevccfg\n #if !defined(GPAC_DISABLE_AV_PARSERS) && !defined(GPAC_DISABLE_HEVC)\n \t\t\t\t\t\t\t, &hevc_state\n #endif\n \t\t\t\t\t\t);\n \t\t\t\t\t\tgf_odf_hevc_cfg_del(hevccfg);\n \t\t\t\t\t\tfprintf(stderr, \"\\n\");\n \t\t\t\t\t}\n \t\t\t\t\tif (lhvccfg) {\n \t\t\t\t\t\tdump_hevc_track_info(file, trackNum, lhvccfg\n #if !defined(GPAC_DISABLE_AV_PARSERS) && !defined(GPAC_DISABLE_HEVC)\n \t\t\t\t\t\t\t, &hevc_state\n #endif\n \t\t\t\t\t\t);\n \t\t\t\t\t\tgf_odf_hevc_cfg_del(lhvccfg);\n \t\t\t\t\t}\n \n \t\t\t\t\tif (gf_isom_get_oinf_info(file, trackNum, &oinf)) {\n \t\t\t\t\t\tfprintf(stderr, \"\\n\\tOperating Points Information -\");\n \t\t\t\t\t\tfprintf(stderr, \" scalability_mask %d (\", oinf->scalability_mask);\n \t\t\t\t\t\tswitch (oinf->scalability_mask) {\n \t\t\t\t\t\tcase 2:\n \t\t\t\t\t\t\tfprintf(stderr, \"Multiview\");\n \t\t\t\t\t\t\tbreak;\n \t\t\t\t\t\tcase 4:\n \t\t\t\t\t\t\tfprintf(stderr, \"Spatial scalability\");\n \t\t\t\t\t\t\tbreak;\n \t\t\t\t\t\tcase 8:\n \t\t\t\t\t\t\tfprintf(stderr, \"Auxilary\");\n \t\t\t\t\t\t\tbreak;\n \t\t\t\t\t\tdefault:\n \t\t\t\t\t\t\tfprintf(stderr, \"unknown\");\n \t\t\t\t\t\t}\n \t\t\t\t\t\tfprintf(stderr, \") num_profile_tier_level %d \", gf_list_count(oinf->profile_tier_levels) );\n \t\t\t\t\t\tfprintf(stderr, \" num_operating_points %d dependency layers %d \\n\", gf_list_count(oinf->operating_points), gf_list_count(oinf->dependency_layers) );\n \t\t\t\t\t}\n \t\t\t\t}\n \n \t\t\t\telse if (esd->decoderConfig->objectTypeIndication==GF_CODECID_THEORA) {\n \t\t\t\t\tchar *szName;\n \t\t\t\t\tgf_isom_get_visual_info(file, trackNum, 1, &w, &h);\n \t\t\t\t\tif (full_dump) fprintf(stderr, \"\\t\");\n \t\t\t\t\tif (!strnicmp((char *) &esd->decoderConfig->decoderSpecificInfo->data[3], \"theora\", 6)) szName = \"Theora\";\n \t\t\t\t\telse szName = \"Unknown\";\n \t\t\t\t\tfprintf(stderr, \"Ogg/%s video / GPAC Mux  - Visual Size %d x %d\\n\", szName, w, h);\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\tu32 codec_id = gf_codecid_from_oti(GF_STREAM_VISUAL, esd->decoderConfig->objectTypeIndication);\n \t\t\t\t\tif (codec_id) {\n \t\t\t\t\t\tgf_isom_get_visual_info(file, trackNum, 1, &w, &h);\n \t\t\t\t\t\tfprintf(stderr, \"%s - Visual Size %d x %d\\n\", gf_codecid_name(codec_id), w, h);\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\tif (!w || !h) {\n \t\t\t\t\tgf_isom_get_visual_info(file, trackNum, 1, &w, &h);\n \t\t\t\t\tif (full_dump) fprintf(stderr, \"\\t\");\n \t\t\t\t\tfprintf(stderr, \"Visual Size %d x %d\\n\", w, h);\n \t\t\t\t}\n \t\t\t\tif (gf_isom_get_rvc_config(file, trackNum, 1, &rvc_predef, NULL, NULL, NULL)==GF_OK) {\n \t\t\t\t\tfprintf(stderr, \"Has RVC signaled - Predefined configuration %d\\n\", rvc_predef);\n \t\t\t\t}\n \n \t\t\t} else if (esd->decoderConfig->streamType==GF_STREAM_AUDIO) {\n #ifndef GPAC_DISABLE_AV_PARSERS\n \t\t\t\tGF_M4ADecSpecInfo a_cfg;\n \t\t\t\tGF_Err e;\n \t\t\t\tu32 oti;\n #endif\n \t\t\t\tu32 codec_id;\n \t\t\t\tBool is_mp2 = GF_FALSE;\n \t\t\t\tswitch (esd->decoderConfig->objectTypeIndication) {\n \t\t\t\tcase GF_CODECID_AAC_MPEG2_MP:\n \t\t\t\tcase GF_CODECID_AAC_MPEG2_LCP:\n \t\t\t\tcase GF_CODECID_AAC_MPEG2_SSRP:\n \t\t\t\t\tis_mp2 = GF_TRUE;\n \t\t\t\tcase GF_CODECID_AAC_MPEG4:\n #ifndef GPAC_DISABLE_AV_PARSERS\n \t\t\t\t\tif (!esd->decoderConfig->decoderSpecificInfo)\n \t\t\t\t\t\te = GF_NON_COMPLIANT_BITSTREAM;\n \t\t\t\t\telse\n \t\t\t\t\t\te = gf_m4a_get_config(esd->decoderConfig->decoderSpecificInfo->data, esd->decoderConfig->decoderSpecificInfo->dataLength, &a_cfg);\n \t\t\t\t\tif (full_dump) fprintf(stderr, \"\\t\");\n \t\t\t\t\tif (e) {\n \t\t\t\t\t\tM4_LOG(GF_LOG_ERROR, (\"Corrupted AAC Config\\n\"));\n \t\t\t\t\t} else {\n \t\t\t\t\t\tchar *signaling = \"implicit\";\n \t\t\t\t\t\tchar *heaac = \"\";\n \t\t\t\t\t\tif (!is_mp2 && a_cfg.has_sbr) {\n \t\t\t\t\t\t\tif (a_cfg.has_ps) heaac = \"(HE-AAC v2) \";\n \t\t\t\t\t\t\telse heaac = \"(HE-AAC v1) \";\n \t\t\t\t\t\t}\n \t\t\t\t\t\tif (a_cfg.base_object_type==2) {\n \t\t\t\t\t\t\tif (a_cfg.has_ps || a_cfg.has_sbr)\n \t\t\t\t\t\t\t\tsignaling = \"backward compatible\";\n \t\t\t\t\t\t} else {\n \t\t\t\t\t\t\tsignaling = \"hierarchical\";\n \t\t\t\t\t\t}\n \t\t\t\t\t\tfprintf(stderr, \"%s (AOT=%d %s) %s- %d Channel(s) - SampleRate %d\", gf_m4a_object_type_name(a_cfg.base_object_type), a_cfg.base_object_type, signaling, heaac, a_cfg.nb_chan, a_cfg.base_sr);\n \t\t\t\t\t\tif (is_mp2) fprintf(stderr, \" (MPEG-2 Signaling)\");\n \t\t\t\t\t\tif (a_cfg.has_sbr) fprintf(stderr, \" - SBR: SampleRate %d Type %s\", a_cfg.sbr_sr, gf_m4a_object_type_name(a_cfg.sbr_object_type));\n \t\t\t\t\t\tif (a_cfg.has_ps) fprintf(stderr, \" - PS\");\n \t\t\t\t\t\tfprintf(stderr, \"\\n\");\n \t\t\t\t\t}\n #else\n \t\t\t\t\tfprintf(stderr, \"MPEG-2/4 Audio - %d Channels - SampleRate %d\\n\", nb_ch, sr);\n #endif\n \t\t\t\t\tbreak;\n \t\t\t\tcase GF_CODECID_MPEG2_PART3:\n \t\t\t\tcase GF_CODECID_MPEG_AUDIO:\n \t\t\t\t\tif (msub_type == GF_ISOM_SUBTYPE_MPEG4_CRYP) {\n \t\t\t\t\t\tfprintf(stderr, \"MPEG-1/2 Audio - %d Channels - SampleRate %d\\n\", nb_ch, sr);\n \t\t\t\t\t} else {\n #ifndef GPAC_DISABLE_AV_PARSERS\n \t\t\t\t\t\tGF_ISOSample *samp = gf_isom_get_sample(file, trackNum, 1, &oti);\n \t\t\t\t\t\tif (samp) {\n \t\t\t\t\t\t\tu32 mhdr = GF_4CC((u8)samp->data[0], (u8)samp->data[1], (u8)samp->data[2], (u8)samp->data[3]);\n \t\t\t\t\t\t\tif (full_dump) fprintf(stderr, \"\\t\");\n \t\t\t\t\t\t\tfprintf(stderr, \"%s Audio - %d Channel(s) - SampleRate %d - Layer %d\\n\",\n \t\t\t\t\t\t\t        gf_mp3_version_name(mhdr),\n \t\t\t\t\t\t\t        gf_mp3_num_channels(mhdr),\n \t\t\t\t\t\t\t        gf_mp3_sampling_rate(mhdr),\n \t\t\t\t\t\t\t        gf_mp3_layer(mhdr)\n \t\t\t\t\t\t\t       );\n \t\t\t\t\t\t\tgf_isom_sample_del(&samp);\n \t\t\t\t\t\t} else {\n \t\t\t\t\t\t\tM4_LOG(GF_LOG_ERROR, (\"Error fetching sample: %s\\n\", gf_error_to_string(gf_isom_last_error(file)) ));\n \t\t\t\t\t\t}\n #else\n \t\t\t\t\t\tfprintf(stderr, \"MPEG-1/2 Audio - %d Channels - SampleRate %d\\n\", nb_ch, sr);\n #endif\n \t\t\t\t\t}\n \t\t\t\t\tbreak;\n \t\t\t\tcase GF_CODECID_EVRC:\n \t\t\t\t\tfprintf(stderr, \"EVRC Audio - Sample Rate 8000 - 1 channel\\n\");\n \t\t\t\t\tbreak;\n \t\t\t\tcase GF_CODECID_SMV:\n \t\t\t\t\tfprintf(stderr, \"SMV Audio - Sample Rate 8000 - 1 channel\\n\");\n \t\t\t\t\tbreak;\n \t\t\t\tcase GF_CODECID_QCELP:\n \t\t\t\t\tfprintf(stderr, \"QCELP Audio - Sample Rate 8000 - 1 channel\\n\");\n \t\t\t\t\tbreak;\n \t\t\t\tcase GF_CODECID_EVRC_PV:\n \t\t\t\t\tif (esd->decoderConfig->decoderSpecificInfo && (esd->decoderConfig->decoderSpecificInfo->dataLength==8)\n \t\t\t\t\t        && !strnicmp((char *)esd->decoderConfig->decoderSpecificInfo->data, \"pvmm\", 4)) {\n \t\t\t\t\t\tif (full_dump) fprintf(stderr, \"\\t\");\n \t\t\t\t\t\tfprintf(stderr, \"EVRC Audio (PacketVideo Mux) - Sample Rate 8000 - 1 channel\\n\");\n \t\t\t\t\t}\n \t\t\t\t\tbreak;\n \t\t\t\tdefault:\n \t\t\t\t\tcodec_id = gf_codecid_from_oti(GF_STREAM_AUDIO, esd->decoderConfig->objectTypeIndication);\n \t\t\t\t\tif (codec_id) {\n \t\t\t\t\t\tfprintf(stderr, \"%s - Sample Rate %d - %d channel(s)\\n\", gf_codecid_name(codec_id), sr, nb_ch);\n \t\t\t\t\t}\n \t\t\t\t\tbreak;\n \t\t\t\t}\n \t\t\t}\n \t\t\telse if (esd->decoderConfig->streamType==GF_STREAM_SCENE) {\n \t\t\t\tif (esd->decoderConfig->objectTypeIndication<=4) {\n \t\t\t\t\tGF_BIFSConfig *b_cfg = gf_odf_get_bifs_config(esd->decoderConfig->decoderSpecificInfo, esd->decoderConfig->objectTypeIndication);\n \t\t\t\t\tfprintf(stderr, \"BIFS Scene description - %s stream\\n\", b_cfg->elementaryMasks ? \"Animation\" : \"Command\");\n \t\t\t\t\tif (full_dump && !b_cfg->elementaryMasks) {\n \t\t\t\t\t\tfprintf(stderr, \"\\tWidth %d Height %d Pixel Metrics %s\\n\", b_cfg->pixelWidth, b_cfg->pixelHeight, b_cfg->pixelMetrics ? \"yes\" : \"no\");\n \t\t\t\t\t}\n \t\t\t\t\tgf_odf_desc_del((GF_Descriptor *)b_cfg);\n \t\t\t\t} else if (esd->decoderConfig->objectTypeIndication==GF_CODECID_AFX) {\n \t\t\t\t\tu8 tag = esd->decoderConfig->decoderSpecificInfo ? esd->decoderConfig->decoderSpecificInfo->data[0] : 0xFF;\n \t\t\t\t\tconst char *afxtype = gf_stream_type_afx_name(tag);\n \t\t\t\t\tfprintf(stderr, \"AFX Stream - type %s (%d)\\n\", afxtype, tag);\n \t\t\t\t} else if (esd->decoderConfig->objectTypeIndication==GF_CODECID_FONT) {\n \t\t\t\t\tfprintf(stderr, \"Font Data stream\\n\");\n \t\t\t\t} else if (esd->decoderConfig->objectTypeIndication==GF_CODECID_LASER) {\n \t\t\t\t\tGF_LASERConfig l_cfg;\n \t\t\t\t\tgf_odf_get_laser_config(esd->decoderConfig->decoderSpecificInfo, &l_cfg);\n \t\t\t\t\tfprintf(stderr, \"LASER Stream - %s\\n\", l_cfg.newSceneIndicator ? \"Full Scene\" : \"Scene Segment\");\n \t\t\t\t} else if (esd->decoderConfig->objectTypeIndication==GF_CODECID_TEXT_MPEG4) {\n \t\t\t\t\tfprintf(stderr, \"MPEG-4 Streaming Text stream\\n\");\n \t\t\t\t} else if (esd->decoderConfig->objectTypeIndication==GF_CODECID_SYNTHESIZED_TEXTURE) {\n \t\t\t\t\tfprintf(stderr, \"Synthetized Texture stream stream\\n\");\n \t\t\t\t} else {\n \t\t\t\t\tM4_LOG(GF_LOG_WARNING, (\"Unknown Systems stream OTI %d\\n\", esd->decoderConfig->objectTypeIndication));\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tif (!full_dump) {\n \t\t\t\tif (dump_m4sys) {\n \t\t\t\t\tif (!esd->OCRESID || (esd->OCRESID == esd->ESID))\n \t\t\t\t\t\tfprintf(stderr, \"Self-synchronized\\n\");\n \t\t\t\t\telse\n \t\t\t\t\t\tfprintf(stderr, \"Synchronized on stream %d\\n\", esd->OCRESID);\n \t\t\t\t}\n \t\t\t} else {\n \t\t\t\tfprintf(stderr, \"\\tDecoding Buffer size %d - Bitrate: avg %d - max %d kbps\\n\", esd->decoderConfig->bufferSizeDB, esd->decoderConfig->avgBitrate/1000, esd->decoderConfig->maxBitrate/1000);\n \t\t\t\tif (esd->dependsOnESID)\n \t\t\t\t\tfprintf(stderr, \"\\tDepends on stream %d for decoding\\n\", esd->dependsOnESID);\n \t\t\t\telse\n \t\t\t\t\tfprintf(stderr, \"\\tNo stream dependencies for decoding\\n\");\n \n \t\t\t\tfprintf(stderr, \"\\tStreamPriority %d\\n\", esd->streamPriority);\n \t\t\t\tif (esd->URLString) fprintf(stderr, \"\\tRemote Data Source %s\\n\", esd->URLString);\n \t\t\t}\n \t\t\tgf_odf_desc_del((GF_Descriptor *) esd);\n \t\t}\n \t} else if (msub_type == GF_ISOM_SUBTYPE_AV01) {\n \t\tGF_AV1Config *av1c;\n \t\tu32 w, h;\n \t\tgf_isom_get_visual_info(file, trackNum, 1, &w, &h);\n \t\tfprintf(stderr, \"\\tAOM AV1 stream - Resolution %d x %d\\n\", w, h);\n \n \t\tav1c = gf_isom_av1_config_get(file, trackNum, 1);\n// bug_start\n\t\tfprintf(stderr, \"\\tversion=%u, profile=%u, level_idx0=%u, tier=%u\\n\", (u32)av1c->version, (u32)av1c->seq_profile, (u32)av1c->seq_level_idx_0, (u32)av1c->seq_tier_0);\n\t\tfprintf(stderr, \"\\thigh_bitdepth=%u, twelve_bit=%u, monochrome=%u\\n\", (u32)av1c->high_bitdepth, (u32)av1c->twelve_bit, (u32)av1c->monochrome);\n\t\tfprintf(stderr, \"\\tchroma: subsampling_x=%u, subsampling_y=%u, sample_position=%u\\n\", (u32)av1c->chroma_subsampling_x, (u32)av1c->chroma_subsampling_y, (u32)av1c->chroma_sample_position);\n\n\t\tif (av1c->initial_presentation_delay_present)\n\t\t\tfprintf(stderr, \"\\tInitial presentation delay %u\\n\", (u32) av1c->initial_presentation_delay_minus_one+1);\n\n\t\tcount = gf_list_count(av1c->obu_array);\n\t\tfor (i=0; i<count; i++) {\n\t\t\tu8 hash[20];\n\t\t\tGF_AV1_OBUArrayEntry *obu = gf_list_get(av1c->obu_array, i);\n\t\t\tgf_sha1_csum((u8*)obu->obu, (u32)obu->obu_length, hash);\n\t\t\tfprintf(stderr, \"\\tOBU#%d %s hash: \", i+1, gf_av1_get_obu_name(obu->obu_type) );\n\t\t\tfor (j=0; j<20; j++) fprintf(stderr, \"%02X\", hash[j]);\n\t\t\tfprintf(stderr, \"\\n\");\n\t\t}\n\t\tgf_odf_av1_cfg_del(av1c);\n// bug_end\n \t} else if (msub_type == GF_ISOM_SUBTYPE_3GP_H263) {\n \t\tu32 w, h;\n \t\tgf_isom_get_visual_info(file, trackNum, 1, &w, &h);\n \t\tfprintf(stderr, \"\\t3GPP H263 stream - Resolution %d x %d\\n\", w, h);\n \t} else if (msub_type == GF_ISOM_SUBTYPE_MJP2) {\n \t\tu32 w, h;\n \t\tgf_isom_get_visual_info(file, trackNum, 1, &w, &h);\n \t\tfprintf(stderr, \"\\tMotionJPEG2000 stream - Resolution %d x %d\\n\", w, h);\n \t} else if ((msub_type == GF_ISOM_SUBTYPE_3GP_AMR) || (msub_type == GF_ISOM_SUBTYPE_3GP_AMR_WB)) {\n \t\tfprintf(stderr, \"\\t3GPP AMR%s stream - Sample Rate %d - %d channel(s) %d bps\\n\", (msub_type == GF_ISOM_SUBTYPE_3GP_AMR_WB) ? \" Wide Band\" : \"\", sr, nb_ch, (u32) bps);\n \t} else if (msub_type == GF_ISOM_SUBTYPE_3GP_EVRC) {\n \t\tfprintf(stderr, \"\\t3GPP EVRC stream - Sample Rate %d - %d channel(s) %d bps\\n\", sr, nb_ch, (u32) bps);\n \t} else if (msub_type == GF_ISOM_SUBTYPE_3GP_QCELP) {\n \t\tfprintf(stderr, \"\\t3GPP QCELP stream - Sample Rate %d - %d channel(s) %d bps\\n\", sr, nb_ch, (u32) bps);\n \t} else if (msub_type == GF_ISOM_SUBTYPE_MP3) {\n \t\tfprintf(stderr, \"\\tMPEG 1/2 Audio stream - Sample Rate %d - %d channel(s) %d bps\\n\", sr, nb_ch, (u32) bps);\n \t} else if ((msub_type == GF_ISOM_SUBTYPE_AC3) || (msub_type == GF_ISOM_SUBTYPE_EC3)) {\n \t\tu32 br = 0;\n \t\tconst char *lfe = \"\";\n \t\tBool is_ec3 = (msub_type == GF_ISOM_SUBTYPE_EC3) ? GF_TRUE : GF_FALSE;\n #ifndef GPAC_DISABLE_AV_PARSERS\n \t\tGF_AC3Config *ac3 = gf_isom_ac3_config_get(file, trackNum, 1);\n \t\tif (ac3) {\n \t\t\tnb_ch = gf_ac3_get_channels(ac3->streams[0].acmod);\n \t\t\tfor (i=0; i<ac3->streams[0].nb_dep_sub; ++i) {\n \t\t\t\tassert(ac3->streams[0].nb_dep_sub == 1);\n \t\t\t\tnb_ch += gf_ac3_get_channels(ac3->streams[0].chan_loc);\n \t\t\t}\n \t\t\tif (ac3->streams[0].lfon) lfe = \".1\";\n \t\t\tbr = ac3->is_ec3 ? ac3->brcode : gf_ac3_get_bitrate(ac3->brcode);\n \t\t\tis_ec3 = ac3->is_ec3;\n \t\t\tgf_free(ac3);\n \t\t}\n #endif\n \t\tfprintf(stderr, \"\\t%s stream - Sample Rate %d - %d%s channel(s) - bitrate %d\\n\", is_ec3 ? \"EC-3\" : \"AC-3\", sr, nb_ch, lfe, br);\n \t} else if (msub_type == GF_ISOM_SUBTYPE_3GP_SMV) {\n \t\tfprintf(stderr, \"\\t3GPP SMV stream - Sample Rate %d - %d channel(s) %d bits per samples\\n\", sr, nb_ch, (u32) bps);\n \t} else if (msub_type == GF_ISOM_SUBTYPE_3GP_DIMS) {\n \t\tu32 w, h;\n \t\tGF_DIMSDescription dims;\n \t\tgf_isom_get_visual_info(file, trackNum, 1, &w, &h);\n \n \t\tgf_isom_get_dims_description(file, trackNum, 1, &dims);\n \t\tfprintf(stderr, \"\\t3GPP DIMS stream - size %d x %d - Profile %d - Level %d\\n\", w, h, dims.profile, dims.level);\n \t\tfprintf(stderr, \"\\tpathComponents: %d - useFullRequestHost: %s\\n\", dims.pathComponents, dims.fullRequestHost ? \"yes\" : \"no\");\n \t\tfprintf(stderr, \"\\tstream type: %s - redundant: %s\\n\", dims.streamType ? \"primary\" : \"secondary\", (dims.containsRedundant==1) ? \"main\" : ((dims.containsRedundant==2) ? \"redundant\" : \"main+redundant\") );\n \t\tif (dims.textEncoding[0]) fprintf(stderr, \"\\ttext encoding %s\\n\", dims.textEncoding);\n \t\tif (dims.contentEncoding[0]) fprintf(stderr, \"\\tcontent encoding %s\\n\", dims.contentEncoding);\n \t\tif (dims.content_script_types) fprintf(stderr, \"\\tscript languages %s\\n\", dims.content_script_types);\n \t} else if (mtype==GF_ISOM_MEDIA_HINT) {\n \t\tu32 refTrack;\n \t\ts32 refCount = gf_isom_get_reference_count(file, trackNum, GF_ISOM_REF_HINT);\n \t\tif (refCount>0) {\n \t\t\tfprintf(stderr, \"Streaming Hint Track for track%s \", (refCount>1) ? \"s\" :\"\");\n \t\t\tfor (i=0; i<(u32) refCount; i++) {\n \t\t\t\tgf_isom_get_reference(file, trackNum, GF_ISOM_REF_HINT, i+1, &refTrack);\n \t\t\t\tif (i) fprintf(stderr, \" - \");\n \t\t\t\tfprintf(stderr, \"ID %d\", gf_isom_get_track_id(file, refTrack));\n \t\t\t}\n \t\t\tfprintf(stderr, \"\\n\");\n \t\t} else {\n \t\t\tfprintf(stderr, \"Streaming Hint Track (no refs)\\n\");\n \t\t}\n #ifndef GPAC_DISABLE_ISOM_HINTING\n \t\trefCount = gf_isom_get_payt_count(file, trackNum);\n \t\tif (refCount>0) {\n \t\t\tfor (i=0; i<(u32) refCount; i++) {\n \t\t\t\tconst char *name = gf_isom_get_payt_info(file, trackNum, i+1, &refTrack);\n \t\t\t\tfprintf(stderr, \"\\tPayload ID %d: type %s\\n\", refTrack, name);\n \t\t\t}\n \t\t}\n #endif\n \t} else if (mtype==GF_ISOM_MEDIA_FLASH) {\n \t\tfprintf(stderr, \"Macromedia Flash Movie\\n\");\n \t} else if ((mtype==GF_ISOM_MEDIA_TEXT) || (mtype==GF_ISOM_MEDIA_SUBT) || (mtype==GF_ISOM_MEDIA_MPEG_SUBT)) {\n \t\tu32 w, h;\n \t\ts16 l;\n \t\ts32 tx, ty;\n \t\tconst char *content_encoding = NULL;\n \t\tconst char *mime = NULL;\n \t\tconst char *config  = NULL;\n \t\tconst char *_namespace = NULL;\n \t\tconst char *schema_loc = NULL;\n \t\tconst char *auxiliary_mimes = NULL;\n \t\tgf_isom_get_track_layout_info(file, trackNum, &w, &h, &tx, &ty, &l);\n \t\tif (msub_type == GF_ISOM_SUBTYPE_SBTT) {\n \t\t\tgf_isom_stxt_get_description(file, trackNum, 1, &mime, &content_encoding, &config);\n \t\t\tfprintf(stderr, \"Textual Subtitle Stream \");\n \t\t\tfprintf(stderr, \"- mime %s\", mime);\n \t\t\tif (content_encoding != NULL) {\n \t\t\t\tfprintf(stderr, \" - encoding %s\", content_encoding);\n \t\t\t}\n \t\t\tif (config != NULL) {\n \t\t\t\tfprintf(stderr, \" - %d bytes config\", (u32) strlen(config));\n \t\t\t}\n \t\t} else if (msub_type == GF_ISOM_SUBTYPE_STXT) {\n \t\t\tgf_isom_stxt_get_description(file, trackNum, 1, &mime, &content_encoding, &config);\n \t\t\tfprintf(stderr, \"Simple Timed Text Stream \");\n \t\t\tfprintf(stderr, \"- mime %s\", mime);\n \t\t\tif (content_encoding != NULL) {\n \t\t\t\tfprintf(stderr, \" - encoding %s\", content_encoding);\n \t\t\t}\n \t\t\tif (config != NULL) {\n \t\t\t\tfprintf(stderr, \" - %d bytes config\", (u32) strlen(config));\n \t\t\t}\n \t\t} else if (msub_type == GF_ISOM_SUBTYPE_STPP) {\n \t\t\tgf_isom_xml_subtitle_get_description(file, trackNum, 1, &_namespace, &schema_loc, &auxiliary_mimes);\n \t\t\tfprintf(stderr, \"XML Subtitle Stream \");\n \t\t\tfprintf(stderr, \"- namespace %s\", _namespace);\n \t\t\tif (schema_loc != NULL) {\n \t\t\t\tfprintf(stderr, \" - schema-location %s\", schema_loc);\n \t\t\t}\n \t\t\tif (auxiliary_mimes != NULL) {\n \t\t\t\tfprintf(stderr, \" - auxiliary-mime-types %s\", auxiliary_mimes);\n \t\t\t}\n \t\t} else {\n \t\t\tfprintf(stderr, \"Unknown Text Stream\");\n \t\t}\n \t\tfprintf(stderr, \"\\n Size %d x %d - Translation X=%d Y=%d - Layer %d\\n\", w, h, tx, ty, l);\n \t} else if (mtype == GF_ISOM_MEDIA_META) {\n \t\tconst char *content_encoding = NULL;\n \t\tif (msub_type == GF_ISOM_SUBTYPE_METT) {\n \t\t\tconst char *mime = NULL;\n \t\t\tconst char *config  = NULL;\n \t\t\tgf_isom_stxt_get_description(file, trackNum, 1, &mime, &content_encoding, &config);\n \t\t\tfprintf(stderr, \"Textual Metadata Stream - mime %s\", mime);\n \t\t\tif (content_encoding != NULL) {\n \t\t\t\tfprintf(stderr, \" - encoding %s\", content_encoding);\n \t\t\t}\n \t\t\tif (config != NULL) {\n \t\t\t\tfprintf(stderr, \" - %d bytes config\", (u32) strlen(config));\n \t\t\t}\n \t\t\tfprintf(stderr, \"\\n\");\n \t\t} else if (msub_type == GF_ISOM_SUBTYPE_METX) {\n \t\t\tconst char *_namespace = NULL;\n \t\t\tconst char *schema_loc = NULL;\n \t\t\tgf_isom_get_xml_metadata_description(file, trackNum, 1, &_namespace, &schema_loc, &content_encoding);\n \t\t\tfprintf(stderr, \"XML Metadata Stream - namespace %s\", _namespace);\n \t\t\tif (content_encoding != NULL) {\n \t\t\t\tfprintf(stderr, \" - encoding %s\", content_encoding);\n \t\t\t}\n \t\t\tif (schema_loc != NULL) {\n \t\t\t\tfprintf(stderr, \" - schema-location %s\", schema_loc);\n \t\t\t}\n \t\t\tfprintf(stderr, \"\\n\");\n \t\t} else {\n \t\t\tfprintf(stderr, \"Unknown Metadata Stream\\n\");\n \t\t}\n \t} else if ((msub_type==GF_ISOM_SUBTYPE_VVC1) || (msub_type==GF_ISOM_SUBTYPE_VVI1)) {\n \t\tGF_VVCConfig *vvccfg;\n \t\tu32 w, h;\n #if !defined(GPAC_DISABLE_AV_PARSERS)\n \t\tVVCState *vvc_state;\n \t\tGF_SAFEALLOC(vvc_state, VVCState);\n \t\tif (vvc_state) vvc_state->sps_active_idx = -1;\n #endif\n \n \t\tgf_isom_get_visual_info(file, trackNum, 1, &w, &h);\n \t\tif (full_dump) fprintf(stderr, \"\\t\");\n \t\tfprintf(stderr, \"VVC Video - Visual Size %d x %d\\n\", w, h);\n \t\tvvccfg = gf_isom_vvc_config_get(file, trackNum, 1);\n \n \t\tif (!vvccfg) {\n \t\t\tM4_LOG(GF_LOG_ERROR, (\"Non-compliant VVC track: No vvcC found in sample description\\n\"));\n \t\t} else {\n \t\t\tdump_vvc_track_info(file, trackNum, vvccfg\n #if !defined(GPAC_DISABLE_AV_PARSERS)\n \t\t\t\t, vvc_state\n #endif\n \t\t\t);\n \t\t\tgf_odf_vvc_cfg_del(vvccfg);\n \t\t\tfprintf(stderr, \"\\n\");\n \t\t}\n #if !defined(GPAC_DISABLE_AV_PARSERS)\n \t\tif (vvc_state) gf_free(vvc_state);\n #endif\n \t} else if ((msub_type == GF_ISOM_SUBTYPE_MH3D_MHA1) || (msub_type == GF_ISOM_SUBTYPE_MH3D_MHA2)\n \t\t\t|| (msub_type == GF_ISOM_SUBTYPE_MH3D_MHM1) || (msub_type == GF_ISOM_SUBTYPE_MH3D_MHM2)\n \t) {\n \t\tconst u8 *compat_profiles;\n \t\tu32 nb_compat_profiles;\n \t\tBool valid = GF_FALSE;\n \t\tBool allow_inband = GF_FALSE;\n \t\tif ( (msub_type == GF_ISOM_SUBTYPE_MH3D_MHM1) || (msub_type == GF_ISOM_SUBTYPE_MH3D_MHM2))\n \t\t\tallow_inband = GF_TRUE;\n \n \t\tfprintf(stderr, \"\\tMPEG-H Audio stream - Sample Rate %d\\n\", sr);\n \n \t\tesd = gf_media_map_esd(file, trackNum, 1);\n \t\tif (!esd || !esd->decoderConfig || !esd->decoderConfig->decoderSpecificInfo\n \t\t\t|| !esd->decoderConfig->decoderSpecificInfo->data\n \t\t) {\n \t\t\tif (allow_inband) {\n \t\t\t\tGF_ISOSample *samp = gf_isom_get_sample(file, trackNum, 1, NULL);\n \t\t\t\tif (samp) {\n \t\t\t\t\tu64 ch_layout=0;\n \t\t\t\t\ts32 PL = gf_mpegh_get_mhas_pl(samp->data, samp->dataLength, &ch_layout);\n \t\t\t\t\tif (PL>=0) {\n \t\t\t\t\t\tfprintf(stderr, \"\\tProfileLevelIndication: 0x%02X\", PL);\n \t\t\t\t\t\tif (ch_layout)\n \t\t\t\t\t\t\tfprintf(stderr, \" - Reference Channel Layout %s\", gf_audio_fmt_get_layout_name(ch_layout) );\n \t\t\t\t\t\tfprintf(stderr, \"\\n\");\n \t\t\t\t\t}\n \t\t\t\t\tgf_isom_sample_del(&samp);\n \t\t\t\t}\n \t\t\t\tvalid = GF_TRUE;\n \t\t\t}\n \t\t} else if (esd->decoderConfig->decoderSpecificInfo->dataLength>=5) {\n \t\t\tfprintf(stderr, \"\\tProfileLevelIndication: 0x%02X - Reference Channel Layout %s\\n\", esd->decoderConfig->decoderSpecificInfo->data[1]\n \t\t\t\t, gf_audio_fmt_get_layout_name_from_cicp(esd->decoderConfig->decoderSpecificInfo->data[2])\n \t\t\t);\n \t\t\tvalid = GF_TRUE;\n \t\t}\n \t\tif (!valid) {\n \t\t\tM4_LOG(GF_LOG_ERROR, (\"Invalid MPEG-H audio config\\n\"));\n \t\t}\n \t\tif (esd) gf_odf_desc_del((GF_Descriptor *)esd);\n \t\tcompat_profiles = gf_isom_get_mpegh_compatible_profiles(file, trackNum, 1, &nb_compat_profiles);\n \t\tfor (i=0; i<nb_compat_profiles; i++) {\n \t\t\tif (!i)\n \t\t\t\tfprintf(stderr, \"\\tCompatible profiles:\");\n \t\t\tfprintf(stderr, \" 0x%02X\", compat_profiles[i]);\n \t\t}\n \t\tif (i) fprintf(stderr, \"\\n\");\n \t} else if (msub_type==GF_ISOM_SUBTYPE_MLPA) {\n \t\tu32 fmt, prate;\n \t\tif (gf_isom_truehd_config_get(file, trackNum, 1, &fmt, &prate) != GF_OK) {\n \t\t\tfprintf(stderr, \"\\tInvalid TrueHD audio config\\n\");\n \t\t}\n \t\tfprintf(stderr, \"TrueHD Audio stream - Sample Rate %u - channels %u - format %u peak rate %u\\n\", sr, nb_ch, fmt, prate);\n \t} else if (codecid) {\n \t\tif (gf_isom_is_video_handler_type(mtype) ) {\n \t\t\tu32 w, h;\n \t\t\tgf_isom_get_visual_info(file, trackNum, 1, &w, &h);\n \t\t\tfprintf(stderr, \"%s - Resolution %d x %d\\n\", gf_codecid_name(codecid), w, h);\n \t\t} else if (mtype==GF_ISOM_MEDIA_AUDIO) {\n \t\t\tgf_isom_get_audio_info(file, trackNum, 1, &sr, &nb_ch, NULL);\n \t\t\tfprintf(stderr, \"%s - Sample Rate %d - %d channel(s)\\n\", gf_codecid_name(codecid), sr, nb_ch);\n \t\t} else {\n \t\t\tfprintf(stderr, \"%s\\n\", gf_codecid_name(codecid) );\n \t\t}\n \t} else if (pfmt) {\n \t\tu32 w, h;\n \t\tgf_isom_get_visual_info(file, trackNum, 1, &w, &h);\n \t\tfprintf(stderr, \"Raw video %s - Resolution %d x %d\\n\", gf_pixel_fmt_name(pfmt), w, h);\n \t} else if (msub_type==GF_QT_SUBTYPE_TMCD) {\n \t\tu32 stsd_idx;\n \t\tGF_ISOSample *sample = gf_isom_get_sample(file, trackNum, 1, &stsd_idx);\n \t\tfprintf(stderr, \"Time Code stream\\n\");\n \t\tif (sample) {\n \t\t\tchar szTimecode[100];\n \t\t\tu32 tmcd_flags, tmcd_num, tmcd_den, tmcd_fpt;\n \n \t\t\tgf_isom_get_tmcd_config(file, trackNum, stsd_idx, &tmcd_flags, &tmcd_num, &tmcd_den, &tmcd_fpt);\n \n \t\t\tgf_inspect_format_timecode(sample->data, sample->dataLength, tmcd_flags, tmcd_num, tmcd_den, tmcd_fpt, szTimecode);\n \n \t\t\tgf_isom_sample_del(&sample);\n \t\t\tfprintf(stderr, \"\\tFirst timecode: %s\\n\", szTimecode);\n \t\t}\n \t} else {\n \t\tGF_GenericSampleDescription *udesc;\n \n \t\tudesc = gf_isom_get_generic_sample_description(file, trackNum, 1);\n \t\tif (udesc) {\n \t\t\tif (gf_isom_is_video_handler_type(mtype) ) {\n                 fprintf(stderr, \"%s - Compressor \\\"%s\\\" - Resolution %d x %d\\n\",\n \t\t\t\t\t\t( (mtype == GF_ISOM_MEDIA_VISUAL ? \"Visual\" : \"Auxiliary Video\") ),\n                         udesc->compressor_name, udesc->width, udesc->height);\n \t\t\t} else if (mtype==GF_ISOM_MEDIA_AUDIO) {\n \t\t\t\tfprintf(stderr, \"Audio - Sample Rate %d - %d channel(s)\\n\", udesc->samplerate, udesc->nb_channels);\n \t\t\t} else {\n \t\t\t\tfprintf(stderr, \"Unknown media type\\n\");\n \t\t\t}\n \t\t\tif (udesc->vendor_code)\n \t\t\t\tfprintf(stderr, \"\\tVendor code \\\"%s\\\" - Version %d - revision %d\\n\", gf_4cc_to_str(udesc->vendor_code), udesc->version, udesc->revision);\n \n \t\t\tif (udesc->extension_buf) {\n \t\t\t\tfprintf(stderr, \"\\tCodec configuration data size: %d bytes\\n\", udesc->extension_buf_size);\n \t\t\t\tgf_free(udesc->extension_buf);\n \t\t\t}\n \t\t\tgf_free(udesc);\n \t\t} else {\n \t\t\tfprintf(stderr, \"Unknown track type\\n\");\n \t\t}\n \t}\n \n \n \tif (gf_isom_is_track_encrypted(file, trackNum)) {\n \t\tconst char *scheme_URI, *KMS_URI;\n \t\tu32 scheme_type, version;\n \t\tu32 IV_size;\n \t\tBool use_sel_enc;\n \n \t\tif (gf_isom_is_ismacryp_media(file, trackNum, 1)) {\n \t\t\tgf_isom_get_ismacryp_info(file, trackNum, 1, NULL, &scheme_type, &version, &scheme_URI, &KMS_URI, &use_sel_enc, &IV_size, NULL);\n \t\t\tfprintf(stderr, \"\\n\\tProtected by ISMA E&A scheme %s (version %d)\\n\", gf_4cc_to_str(scheme_type), version);\n \t\t\tif (scheme_URI) fprintf(stderr, \"scheme location: %s\\n\", scheme_URI);\n \t\t\tif (KMS_URI) {\n \t\t\t\tif (!strnicmp(KMS_URI, \"(key)\", 5)) fprintf(stderr, \"\\tKMS location: key in file\\n\");\n \t\t\t\telse fprintf(stderr, \"\\tKMS location: %s\\n\", KMS_URI);\n \t\t\t}\n \t\t\tfprintf(stderr, \"\\tSelective Encryption: %s\\n\", use_sel_enc ? \"Yes\" : \"No\");\n \t\t\tif (IV_size) fprintf(stderr, \"\\tInitialization Vector size: %d bits\\n\", IV_size*8);\n \t\t} else if (gf_isom_is_omadrm_media(file, trackNum, 1)) {\n \t\t\tconst char *textHdrs;\n \t\t\tu32 enc_type, hdr_len;\n \t\t\tu64 orig_len;\n \t\t\tgf_isom_get_omadrm_info(file, trackNum, 1, NULL, &scheme_type, &version, &scheme_URI, &KMS_URI, &textHdrs, &hdr_len, &orig_len, &enc_type, &use_sel_enc, &IV_size, NULL);\n \t\t\tfprintf(stderr, \"\\n\\tProtected by OMA DRM scheme %s (version %d)\\n\", gf_4cc_to_str(scheme_type), version);\n \t\t\tfprintf(stderr, \"\\tRights Issuer: %s\\n\", KMS_URI);\n \t\t\tfprintf(stderr, \"\\tContent ID: %s\\n\", scheme_URI);\n \t\t\tif (textHdrs) {\n \t\t\t\tu32 offset;\n \t\t\t\tconst char *start = textHdrs;\n \t\t\t\tfprintf(stderr, \"\\tOMA Textual Headers:\\n\");\n \t\t\t\ti=0;\n \t\t\t\toffset=0;\n \t\t\t\twhile (i<hdr_len) {\n \t\t\t\t\tif (start[i]==0) {\n \t\t\t\t\t\tfprintf(stderr, \"\\t\\t%s\\n\", start+offset);\n \t\t\t\t\t\toffset=i+1;\n \t\t\t\t\t}\n \t\t\t\t\ti++;\n \t\t\t\t}\n \t\t\t\tfprintf(stderr, \"\\\\tt%s\\n\", start+offset);\n \t\t\t}\n \t\t\tif (orig_len) fprintf(stderr, \"\\tOriginal media size \"LLD\"\\n\", orig_len);\n \t\t\tfprintf(stderr, \"\\tEncryption algorithm %s\\n\", (enc_type==1) ? \"AEA 128 CBC\" : (enc_type ? \"AEA 128 CTR\" : \"None\"));\n \t\t\tfprintf(stderr, \"\\tSelective Encryption: %s\\n\", use_sel_enc ? \"Yes\" : \"No\");\n \t\t\tif (IV_size) fprintf(stderr, \"\\tInitialization Vector size: %d bits\\n\", IV_size*8);\n \t\t} else if(gf_isom_is_cenc_media(file, trackNum, 1)) {\n \t\t\tconst u8 *def_key;\n \t\t\tu32 def_key_size;\n \t\t\tBool IsEncrypted;\n \t\t\tu8 crypt_byte_block, skip_byte_block;\n \t\t\tIV_size = 0;\n \t\t\tgf_isom_get_cenc_info(file, trackNum, 1, NULL, &scheme_type, &version);\n \n \t\t\tgf_isom_cenc_get_default_info(file, trackNum, 1, NULL, &IsEncrypted, &crypt_byte_block, &skip_byte_block, &def_key, &def_key_size);\n \n \t\t\tfprintf(stderr, \"\\n\\tProtected by CENC scheme %s version 0x%08X\", gf_4cc_to_str(scheme_type), version);\n \n \t\t\tif (crypt_byte_block && skip_byte_block)\n \t\t\t\tfprintf(stderr, \" - Pattern %d:%d\", (u32) skip_byte_block, (u32) crypt_byte_block);\n \t\t\tif (def_key && def_key[0])\n \t\t\t\tfprintf(stderr, \" - MultiKey\");\n \n \t\t\tfprintf(stderr, \"\\n\");\n \t\t\tdump_key_info(def_key, def_key_size, IsEncrypted);\n \n \t\t} else if(gf_isom_is_adobe_protection_media(file, trackNum, 1)) {\n \t\t\tgf_isom_get_adobe_protection_info(file, trackNum, 1, NULL, &scheme_type, &version, NULL);\n \t\t\tfprintf(stderr, \"\\nProtected by Adobe scheme %s (version %d)\\n\", gf_4cc_to_str(scheme_type), version);\n \t\t} else {\n \t\t\tfprintf(stderr, \"\\nProtected by unknown scheme %s\\n\", gf_4cc_to_str(gf_isom_is_media_encrypted(file, trackNum, 0) ));\n \t\t}\n \t\tfprintf(stderr, \"\\n\");\n \t}\n \n \tif ( gf_media_get_rfc_6381_codec_name(file, trackNum, szCodec, GF_FALSE, GF_FALSE) == GF_OK) {\n \t\tfprintf(stderr, \"\\tRFC6381 Codec Parameters: %s\\n\", szCodec);\n \t}\n \n \n \tDumpMetaItem(file, 0, trackNum, \"\\tTrack Meta\");\n \n \tgf_isom_get_track_switch_group_count(file, trackNum, &alt_group, &nb_groups);\n \tif (alt_group) {\n \t\tfprintf(stderr, \"Alternate Group ID %d\\n\", alt_group);\n \t\tfor (i=0; i<nb_groups; i++) {\n \t\t\tu32 nb_crit, switchGroupID;\n \t\t\tconst u32 *criterias = gf_isom_get_track_switch_parameter(file, trackNum, i+1, &switchGroupID, &nb_crit);\n \t\t\tif (!nb_crit) {\n \t\t\t\tfprintf(stderr, \"\\tNo criteria in %s group\\n\", switchGroupID ? \"switch\" : \"alternate\");\n \t\t\t} else {\n \t\t\t\tif (switchGroupID) {\n \t\t\t\t\tfprintf(stderr, \"\\tSwitchGroup ID %d criterias: \", switchGroupID);\n \t\t\t\t} else {\n \t\t\t\t\tfprintf(stderr, \"\\tAlternate Group criterias: \");\n \t\t\t\t}\n \t\t\t\tfor (j=0; j<nb_crit; j++) {\n \t\t\t\t\tif (j) fprintf(stderr, \" \");\n \t\t\t\t\tfprintf(stderr, \"%s\", gf_4cc_to_str(criterias[j]) );\n \t\t\t\t}\n \t\t\t\tfprintf(stderr, \"\\n\");\n \t\t\t}\n \t\t}\n \t}\n \n \tswitch (gf_isom_has_sync_points(file, trackNum)) {\n \tcase 0:\n \t\tfprintf(stderr, \"\\tAll samples are sync\\n\");\n \t\tbreak;\n \tcase 1:\n \t{\n \t\tu32 nb_sync = gf_isom_get_sync_point_count(file, trackNum) - 1;\n \t\tif (! nb_sync) {\n \t\t\tfprintf(stderr, \"\\tOnly one sync sample\\n\");\n \t\t} else {\n \t\t\tfprintf(stderr, \"\\tAverage GOP length: %d samples\\n\", gf_isom_get_sample_count(file, trackNum) / nb_sync);\n \t\t}\n \t}\n \tbreak;\n \tcase 2:\n \t\tfprintf(stderr, \"\\tNo sync sample found\\n\");\n \t\tbreak;\n \t}\n \tfprintf(stderr, \"\\tMax sample duration: %d / %d\\n\", gf_isom_get_max_sample_delta(file, trackNum), timescale);\n \n \tif (!full_dump) {\n \t\tfprintf(stderr, \"\\n\");\n \t\treturn;\n \t}\n \n \tdur = size = 0;\n \tmax_rate = rate = 0;\n \ttime_slice = 0;\n \tts = gf_isom_get_media_timescale(file, trackNum);\n \tcsize = gf_isom_get_constant_sample_size(file, trackNum);\n \tcdur = gf_isom_get_constant_sample_duration(file, trackNum);\n \tcount = gf_isom_get_sample_count(file, trackNum);\n \tif (csize && cdur) {\n \t\tsize = count * csize;\n \t\tdur = cdur * count;\n \t} else {\n \n \t\tfor (j=0; j<count; j++) {\n \t\t\tGF_ISOSample *samp;\n \t\t\tif (is_od_track) {\n \t\t\t\tsamp = gf_isom_get_sample(file, trackNum, j+1, NULL);\n \t\t\t} else {\n \t\t\t\tsamp = gf_isom_get_sample_info(file, trackNum, j+1, NULL, NULL);\n \t\t\t}\n \t\t\tif (!samp) {\n \t\t\t\tM4_LOG(GF_LOG_ERROR, (\"Failed to fetch sample %d\\n\", j+1));\n \t\t\t\treturn;\n \t\t\t}\n \t\t\tdur = samp->DTS+samp->CTS_Offset;\n \t\t\tsize += samp->dataLength;\n \t\t\trate += samp->dataLength;\n \t\t\tif (samp->DTS - time_slice > ts) {\n \t\t\t\tDouble max_tmp = rate * ts / (samp->DTS - time_slice);\n \t\t\t\tif (max_rate < max_tmp )\n \t\t\t\t\tmax_rate = max_tmp;\n \n \t\t\t\trate = 0;\n \t\t\t\ttime_slice = samp->DTS;\n \t\t\t}\n \t\t\tgf_isom_sample_del(&samp);\n \t\t}\n \t}\n \tfprintf(stderr, \"\\nComputed info from media:\\n\");\n \tif (csize && cdur) {\n \t\tfprintf(stderr, \"\\tConstant sample size %d bytes and dur %d / %d\\n\", csize, cdur, ts);\n \t}\n \tscale = 1000.0 / ts;\n \tdur = (u64) (scale * dur);\n \tfprintf(stderr, \"\\tTotal size \"LLU\" bytes - Total samples duration \"LLU\" ms\\n\", size, dur);\n \tif (!dur) {\n \t\tfprintf(stderr, \"\\n\");\n \t\treturn;\n \t}\n \trate = 8000.0 * size / dur;\n \n \tif (!max_rate)\n \t\tmax_rate = rate;\n \telse\n \t\tmax_rate *= 8.0;\n \n \tif (rate >= 1500) {\n \t\tfprintf(stderr, \"\\tAverage rate %.2f kbps - Max Rate %.2f kbps\\n\", rate/1000, max_rate/1000);\n \t} else {\n \t\tfprintf(stderr, \"\\tAverage rate %.2f bps - Max Rate %.2f bps\\n\", rate, max_rate);\n \t}\n \n \t{\n \t\tu32 dmin, dmax, davg, smin, smax, savg;\n \t\tgf_isom_get_chunks_infos(file, trackNum, &dmin, &davg, &dmax, &smin, &savg, &smax);\n \t\tfprintf(stderr, \"\\tChunk durations: min %d ms - max %d ms - average %d ms\\n\", (1000*dmin)/ts, (1000*dmax)/ts, (1000*davg)/ts);\n \t\tfprintf(stderr, \"\\tChunk sizes (bytes): min %d - max %d - average %d\\n\", smin, smax, savg);\n \t}\n \tfprintf(stderr, \"\\n\");\n \n \tcount = gf_isom_get_chapter_count(file, trackNum);\n \tif (count) {\n \t\tconst char *name;\n \t\tu64 time;\n \t\tfprintf(stderr, \"\\nChapters:\\n\");\n \t\tfor (j=0; j<count; j++) {\n \t\t\tgf_isom_get_chapter(file, trackNum, j+1, &time, &name);\n \t\t\tfprintf(stderr, \"\\tChapter #%d - %s - \\\"%s\\\"\\n\", j+1, format_duration(time, 1000, szDur), name);\n \t\t}\n \n", "target": "// fix_start\n\t\tif (!av1c) {\n\t\t\tfprintf(stderr, \"\\tCorrupted av1 config\\n\");\n\t\t} else {\n\t\t\tfprintf(stderr, \"\\tversion=%u, profile=%u, level_idx0=%u, tier=%u\\n\", (u32)av1c->version, (u32)av1c->seq_profile, (u32)av1c->seq_level_idx_0, (u32)av1c->seq_tier_0);\n\t\t\tfprintf(stderr, \"\\thigh_bitdepth=%u, twelve_bit=%u, monochrome=%u\\n\", (u32)av1c->high_bitdepth, (u32)av1c->twelve_bit, (u32)av1c->monochrome);\n\t\t\tfprintf(stderr, \"\\tchroma: subsampling_x=%u, subsampling_y=%u, sample_position=%u\\n\", (u32)av1c->chroma_subsampling_x, (u32)av1c->chroma_subsampling_y, (u32)av1c->chroma_sample_position);\n\n\t\t\tif (av1c->initial_presentation_delay_present)\n\t\t\t\tfprintf(stderr, \"\\tInitial presentation delay %u\\n\", (u32) av1c->initial_presentation_delay_minus_one+1);\n\n\t\t\tcount = gf_list_count(av1c->obu_array);\n\t\t\tfor (i=0; i<count; i++) {\n\t\t\t\tu8 hash[20];\n\t\t\t\tGF_AV1_OBUArrayEntry *obu = gf_list_get(av1c->obu_array, i);\n\t\t\t\tgf_sha1_csum((u8*)obu->obu, (u32)obu->obu_length, hash);\n\t\t\t\tfprintf(stderr, \"\\tOBU#%d %s hash: \", i+1, gf_av1_get_obu_name(obu->obu_type) );\n\t\t\t\tfor (j=0; j<20; j++) fprintf(stderr, \"%02X\", hash[j]);\n\t\t\t\tfprintf(stderr, \"\\n\");\n\t\t\t}\n\t\t\tgf_odf_av1_cfg_del(av1c);\n\t\t}\n// fix_end\n", "cwe": "CWE-401", "cwe_name": "Missing Release of Memory after Effective Lifetime", "cve": "CVE-2021-32138", "cve_desc": "The DumpTrackInfo function in GPAC 1.0.1 allows attackers to cause a denial of service (NULL pointer dereference) via a crafted file in the MP4Box command.", "project": "gpac", "idx": 196719}
{"source": "   void Compute(OpKernelContext* context) override {\n     const auto& input = context->input(0);\n     auto flat_in = input.flat<tstring>();\n \n     int fixed_length;\n     const auto& length_input = context->input(1);\n     OP_REQUIRES(context, TensorShapeUtils::IsScalar(length_input.shape()),\n                 errors::InvalidArgument(\"k must be scalar, got shape \",\n                                         length_input.shape().DebugString()));\n     fixed_length = length_input.scalar<int32>()();\n \n     OP_REQUIRES(\n         context, fixed_length % sizeof(T) == 0,\n         errors::InvalidArgument(\n             \"fixed_length (\", fixed_length,\n             \") must be a multiple of the size of out_type (\", sizeof(T), \")\"));\n \n     OP_REQUIRES(context, fixed_length > 0,\n                 errors::InvalidArgument(\"fixed_length (\", fixed_length,\n                                         \") must be greater than zero.\"));\n \n     int width = fixed_length / sizeof(T);\n \n     TensorShape out_shape = input.shape();\n     out_shape.AddDim(width);\n     Tensor* output_tensor = nullptr;\n     OP_REQUIRES_OK(\n         context, context->allocate_output(\"output\", out_shape, &output_tensor));\n \n     if (flat_in.size() == 0) {\n       return;\n     }\n \n     auto out = output_tensor->flat_inner_dims<T>();\n     T* out_data = out.data();\n \n     memset(out_data, 0, fixed_length * flat_in.size());\n \n     if (!convert_data_endianness_ || sizeof(T) == 1) {\n       for (int64 i = 0; i < flat_in.size(); ++i) {\n// bug_start\n        const T* in_data = reinterpret_cast<const T*>(flat_in(i).data());\n\n        if (flat_in(i).size() > fixed_length) {\n          memcpy(out_data, in_data, fixed_length);\n        } else {\n          memcpy(out_data, in_data, flat_in(i).size());\n        }\n        out_data += fixed_length;\n// bug_end\n       }\n     } else {\n       for (int64 i = 0; i < flat_in.size(); ++i) {\n         const char* in_data_bytes =\n             reinterpret_cast<const char*>(flat_in(i).data());\n         char* out_data_bytes = reinterpret_cast<char*>(out_data);\n         const char* p_in = in_data_bytes;\n         char* p_out = out_data_bytes;\n         for (; p_in < in_data_bytes + fixed_length;\n              p_in += sizeof(T), p_out += sizeof(T)) {\n           std::reverse_copy(p_in, p_in + sizeof(T), p_out);\n         }\n// bug_start\n        out_data += fixed_length;\n// bug_end\n       }\n     }\n   }\n \n", "target": "// fix_start\n        const auto to_copy =\n            std::min(flat_in(i).size(), static_cast<size_t>(fixed_length));\n        memcpy(out_data, flat_in(i).data(), to_copy);\n        out_data += width;\n// fix_end\n// fix_start\n        out_data += width;\n// fix_end\n", "cwe": "CWE-787", "cwe_name": "Out-of-bounds Write", "cve": "CVE-2021-29614", "cve_desc": "TensorFlow is an end-to-end open source platform for machine learning. The implementation of `tf.io.decode_raw` produces incorrect results and crashes the Python interpreter when combining `fixed_length` and wider datatypes. The implementation of the padded version(https://github.com/tensorflow/tensorflow/blob/1d8903e5b167ed0432077a3db6e462daf781d1fe/tensorflow/core/kernels/decode_padded_raw_op.cc) is buggy due to a confusion about pointer arithmetic rules. First, the code computes(https://github.com/tensorflow/tensorflow/blob/1d8903e5b167ed0432077a3db6e462daf781d1fe/tensorflow/core/kernels/decode_padded_raw_op.cc#L61) the width of each output element by dividing the `fixed_length` value to the size of the type argument. The `fixed_length` argument is also used to determine the size needed for the output tensor(https://github.com/tensorflow/tensorflow/blob/1d8903e5b167ed0432077a3db6e462daf781d1fe/tensorflow/core/kernels/decode_padded_raw_op.cc#L63-L79). This is followed by reencoding code(https://github.com/tensorflow/tensorflow/blob/1d8903e5b167ed0432077a3db6e462daf781d1fe/tensorflow/core/kernels/decode_padded_raw_op.cc#L85-L94). The erroneous code is the last line above: it is moving the `out_data` pointer by `fixed_length * sizeof(T)` bytes whereas it only copied at most `fixed_length` bytes from the input. This results in parts of the input not being decoded into the output. Furthermore, because the pointer advance is far wider than desired, this quickly leads to writing to outside the bounds of the backing data. This OOB write leads to interpreter crash in the reproducer mentioned here, but more severe attacks can be mounted too, given that this gadget allows writing to periodically placed locations in memory. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.", "project": "tensorflow", "idx": 196739}
{"source": "   void Compute(OpKernelContext* ctx) override {\n     const Tensor& indices_tensor = ctx->input(0);\n     OP_REQUIRES(ctx,\n                 TensorShapeUtils::IsVector(indices_tensor.shape()) ||\n                     TensorShapeUtils::IsScalar(indices_tensor.shape()),\n                 errors::InvalidArgument(\n                     \"The indices can only be scalar or vector, got \\\"\",\n                     indices_tensor.shape().DebugString(), \"\\\"\"));\n \n     const Tensor& dims_tensor = ctx->input(1);\n     OP_REQUIRES(\n         ctx, TensorShapeUtils::IsVector(dims_tensor.shape()),\n         errors::InvalidArgument(\"The indices can only be 1-D, got \\\"\",\n                                 dims_tensor.shape().DebugString(), \"\\\"\"));\n \n     auto dims = dims_tensor.vec<Tidx>();\n// bug_start\n// bug_end\n \n     Eigen::Tensor<Tidx, 0, Eigen::RowMajor> dims_prod_eigen = dims.prod();\n     Tidx dims_prod = dims_prod_eigen();\n     const Tidx* indices = indices_tensor.flat<Tidx>().data();\n     int64 size = indices_tensor.NumElements();\n     bool check = std::all_of(indices, indices + size,\n                              [&](Tidx index) { return index < dims_prod; });\n     OP_REQUIRES(ctx, check,\n                 errors::InvalidArgument(\"index is out of bound as with dims\"));\n \n     Eigen::array<bool, 1> reverse({true});\n \n     Tensor strides_tensor;\n     OP_REQUIRES_OK(ctx,\n                    ctx->allocate_temp(DataTypeToEnum<Tidx>::value,\n                                       TensorShape({dims_tensor.NumElements()}),\n                                       &strides_tensor));\n \n     auto strides = strides_tensor.vec<Tidx>();\n     strides = dims.reverse(reverse)\n                   .scan(0, Eigen::internal::ProdReducer<Tidx>(), false)\n                   .reverse(reverse);\n \n     Tensor strides_shifted_tensor;\n     OP_REQUIRES_OK(ctx,\n                    ctx->allocate_temp(DataTypeToEnum<Tidx>::value,\n                                       TensorShape({dims_tensor.NumElements()}),\n                                       &strides_shifted_tensor));\n \n     auto strides_shifted = strides_shifted_tensor.vec<Tidx>();\n     strides_shifted = dims.reverse(reverse)\n                           .scan(0, Eigen::internal::ProdReducer<Tidx>(), true)\n                           .reverse(reverse);\n \n     Tensor* output_tensor = nullptr;\n     if (TensorShapeUtils::IsScalar(indices_tensor.shape())) {\n       OP_REQUIRES_OK(\n           ctx, ctx->allocate_output(0, TensorShape({dims_tensor.NumElements()}),\n                                     &output_tensor));\n \n       auto output = output_tensor->vec<Tidx>();\n \n       output = output.constant(indices_tensor.scalar<Tidx>()());\n       output = output.binaryExpr(strides, mod_op<Tidx>()) / strides_shifted;\n     } else {\n       OP_REQUIRES_OK(\n           ctx, ctx->allocate_output(0,\n                                     TensorShape({dims_tensor.NumElements(),\n                                                  indices_tensor.NumElements()}),\n                                     &output_tensor));\n \n       auto output = output_tensor->matrix<Tidx>();\n \n       Eigen::array<Eigen::Index, 2> reshape{\n           {static_cast<Eigen::Index>(dims_tensor.NumElements()), 1}};\n       Eigen::array<Eigen::Index, 2> bcast(\n           {1, static_cast<Eigen::Index>(indices_tensor.NumElements())});\n       Eigen::array<Eigen::Index, 2> indices_reshape{\n           {1, static_cast<Eigen::Index>(indices_tensor.NumElements())}};\n       Eigen::array<Eigen::Index, 2> indices_bcast(\n           {static_cast<Eigen::Index>(dims_tensor.NumElements()), 1});\n \n       output = indices_tensor.vec<Tidx>()\n                    .reshape(indices_reshape)\n                    .broadcast(indices_bcast);\n       output = output.binaryExpr(strides.reshape(reshape).broadcast(bcast),\n                                  mod_op<Tidx>()) /\n                strides_shifted.reshape(reshape).broadcast(bcast);\n     }\n   }\n \n", "target": "// fix_start\n    for (int i = 0; i < dims.size(); i++) {\n      OP_REQUIRES(\n          ctx, dims(i) != 0,\n          errors::InvalidArgument(\"Input dims cannot contain a dim of zero, \"\n                                  \"but dims contains zero at index \",\n                                  i));\n    }\n// fix_end\n", "cwe": "CWE-369", "cwe_name": "Divide By Zero", "cve": "CVE-2021-37668", "cve_desc": "TensorFlow is an end-to-end open source platform for machine learning. In affected versions an attacker can cause denial of service in applications serving models using `tf.raw_ops.UnravelIndex` by triggering a division by 0. The [implementation](https://github.com/tensorflow/tensorflow/blob/460e000de3a83278fb00b61a16d161b1964f15f4/tensorflow/core/kernels/unravel_index_op.cc#L36) does not check that the tensor subsumed by `dims` is not empty. Hence, if one element of `dims` is 0, the implementation does a division by 0. We have patched the issue in GitHub commit a776040a5e7ebf76eeb7eb923bf1ae417dd4d233. The fix will be included in TensorFlow 2.6.0. We will also cherrypick this commit on TensorFlow 2.5.1, TensorFlow 2.4.3, and TensorFlow 2.3.4, as these are also affected and still in supported range.", "project": "tensorflow", "idx": 196763}
{"source": " static void nhmldump_send_header(GF_NHMLDumpCtx *ctx)\n {\n \tGF_FilterPacket *dst_pck;\n \tchar nhml[1024];\n \tu32 size;\n \tu8 *output;\n \tconst GF_PropertyValue *p;\n \n \tctx->szRootName = \"NHNTStream\";\n \tif (ctx->dims) {\n \t\tctx->szRootName = \"DIMSStream\";\n \t}\n \n \tif (!ctx->filep) {\n \t\tsprintf(nhml, \"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\" ?>\\n\");\n \t\tgf_bs_write_data(ctx->bs_w, nhml, (u32) strlen(nhml));\n \t}\n \n \tsprintf(nhml, \"<%s version=\\\"1.0\\\" \", ctx->szRootName);\n \tgf_bs_write_data(ctx->bs_w, nhml, (u32) strlen(nhml));\n \n \n \tNHML_PRINT_UINT(GF_PROP_PID_ID, NULL, \"trackID\")\n \tNHML_PRINT_UINT(GF_PROP_PID_TIMESCALE, NULL, \"timeScale\")\n \n \tp = gf_filter_pid_get_property(ctx->ipid, GF_PROP_PID_IN_IOD);\n \tif (p && p->value.boolean) {\n \t\tsprintf(nhml, \"inRootOD=\\\"yes\\\" \");\n \t\tgf_bs_write_data(ctx->bs_w, nhml, (u32) strlen(nhml));\n \t}\n \n \tif (ctx->oti && (ctx->oti<GF_CODECID_LAST_MPEG4_MAPPING)) {\n \t\tsprintf(nhml, \"streamType=\\\"%d\\\" objectTypeIndication=\\\"%d\\\" \", ctx->streamtype, ctx->oti);\n \t\tgf_bs_write_data(ctx->bs_w, nhml, (u32)strlen(nhml));\n \t} else {\n \t\tp = gf_filter_pid_get_property(ctx->ipid, GF_PROP_PID_SUBTYPE);\n \t\tif (p) {\n \t\t\tsprintf(nhml, \"%s=\\\"%s\\\" \", \"mediaType\", gf_4cc_to_str(p->value.uint));\n \t\t\tgf_bs_write_data(ctx->bs_w, nhml, (u32) strlen(nhml));\n \n \t\t\tNHML_PRINT_4CC(GF_PROP_PID_ISOM_SUBTYPE, \"mediaSubType\", \"mediaSubType\")\n \t\t} else {\n \t\t\tNHML_PRINT_4CC(GF_PROP_PID_CODECID, NULL, \"codecID\")\n \t\t}\n \t}\n \n \tif (ctx->w && ctx->h) {\n \t\tswitch (ctx->streamtype) {\n \t\tcase GF_STREAM_VISUAL:\n \t\tcase GF_STREAM_SCENE:\n \t\t\tsprintf(nhml, \"width=\\\"%d\\\" height=\\\"%d\\\" \", ctx->w, ctx->h);\n \t\t\tgf_bs_write_data(ctx->bs_w, nhml, (u32) strlen(nhml));\n \t\t\tbreak;\n \t\tdefault:\n \t\t\tbreak;\n \t\t}\n \t}\n \telse if (ctx->sr && ctx->chan) {\n \t\tsprintf(nhml, \"sampleRate=\\\"%d\\\" numChannels=\\\"%d\\\" \", ctx->sr, ctx->chan);\n \t\tgf_bs_write_data(ctx->bs_w, nhml, (u32) strlen(nhml));\n \t\tsprintf(nhml, \"sampleRate=\\\"%d\\\" numChannels=\\\"%d\\\" \", ctx->sr, ctx->chan);\n \t\tgf_bs_write_data(ctx->bs_w, nhml, (u32) strlen(nhml));\n \t\tp = gf_filter_pid_get_property(ctx->ipid, GF_PROP_PID_AUDIO_FORMAT);\n// bug_start\n\t\tsprintf(nhml, \"bitsPerSample=\\\"%d\\\" \", gf_audio_fmt_bit_depth(p->value.uint));\n// bug_end\n \t\tgf_bs_write_data(ctx->bs_w, nhml, (u32) strlen(nhml));\n \t}\n \n \tNHML_PRINT_4CC(0, \"codec_vendor\", \"codecVendor\")\n \tNHML_PRINT_UINT(0, \"codec_version\", \"codecVersion\")\n \tNHML_PRINT_UINT(0, \"codec_revision\", \"codecRevision\")\n \tNHML_PRINT_STRING(0, \"compressor_name\", \"compressorName\")\n \tNHML_PRINT_UINT(0, \"temporal_quality\", \"temporalQuality\")\n \tNHML_PRINT_UINT(0, \"spatial_quality\", \"spatialQuality\")\n \tNHML_PRINT_UINT(0, \"hres\", \"horizontalResolution\")\n \tNHML_PRINT_UINT(0, \"vres\", \"verticalResolution\")\n \tNHML_PRINT_UINT(GF_PROP_PID_BIT_DEPTH_Y, NULL, \"bitDepth\")\n \n \tNHML_PRINT_STRING(0, \"meta:xmlns\", \"xml_namespace\")\n \tNHML_PRINT_STRING(0, \"meta:schemaloc\", \"xml_schema_location\")\n \tNHML_PRINT_STRING(0, \"meta:mime\", \"mime_type\")\n \n \tNHML_PRINT_STRING(0, \"meta:config\", \"config\")\n \tNHML_PRINT_STRING(0, \"meta:aux_mimes\", \"aux_mime_type\")\n \n \tif (ctx->codecid == GF_CODECID_DIMS) {\n \t\tif (gf_filter_pid_get_property_str(ctx->ipid, \"meta:xmlns\")==NULL) {\n \t\t\tsprintf(nhml, \"xmlns=\\\"http://www.3gpp.org/richmedia\\\" \");\n \t\t\tgf_bs_write_data(ctx->bs_w, nhml, (u32) strlen(nhml));\n \t\t}\n \n \t\tNHML_PRINT_UINT(0, \"dims:profile\", \"profile\")\n \t\tNHML_PRINT_UINT(0, \"dims:level\", \"level\")\n \t\tNHML_PRINT_UINT(0, \"dims:pathComponents\", \"pathComponents\")\n \n \t\tp = gf_filter_pid_get_property_str(ctx->ipid, \"dims:fullRequestHost\");\n \t\tif (p) {\n \t\t\tsprintf(nhml, \"useFullRequestHost=\\\"%s\\\" \", p->value.boolean ? \"yes\" : \"no\");\n \t\t\tgf_bs_write_data(ctx->bs_w, nhml, (u32) strlen(nhml));\n \t\t}\n \t\tp = gf_filter_pid_get_property_str(ctx->ipid, \"dims:streamType\");\n \t\tif (p) {\n \t\t\tsprintf(nhml, \"stream_type=\\\"%s\\\" \", p->value.boolean ? \"primary\" : \"secondary\");\n \t\t\tgf_bs_write_data(ctx->bs_w, nhml, (u32) strlen(nhml));\n \t\t}\n \t\tp = gf_filter_pid_get_property_str(ctx->ipid, \"dims:redundant\");\n \t\tif (p) {\n \t\t\tsprintf(nhml, \"contains_redundant=\\\"%s\\\" \", (p->value.uint==1) ? \"main\" : ((p->value.uint==1) ? \"redundant\" : \"main+redundant\") );\n \t\t\tgf_bs_write_data(ctx->bs_w, nhml, (u32) strlen(nhml));\n \t\t}\n \t\tNHML_PRINT_UINT(0, \"dims:scriptTypes\", \"scriptTypes\")\n \t}\n \n \tif (ctx->opid_info) {\n \t\tsprintf(nhml, \"specificInfoFile=\\\"%s\\\" \", gf_file_basename(ctx->info_file) );\n \t\tgf_bs_write_data(ctx->bs_w, nhml, (u32) strlen(nhml));\n \n \t\tdst_pck = gf_filter_pck_new_shared(ctx->opid_info, ctx->dcfg, ctx->dcfg_size, NULL);\n \t\tgf_filter_pck_set_framing(dst_pck, GF_TRUE, GF_TRUE);\n \t\tgf_filter_pck_set_readonly(dst_pck);\n \t\tgf_filter_pck_send(dst_pck);\n \t}\n \n \tNHML_PRINT_STRING(0, \"meta:encoding\", \"encoding\")\n \tNHML_PRINT_STRING(0, \"meta:contentEncoding\", \"content_encoding\")\n \tctx->uncompress = GF_FALSE;\n \tif (p) {\n \t\tif (!strcmp(p->value.string, \"deflate\")) ctx->uncompress = GF_TRUE;\n \t\telse {\n \t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_AUTHOR, (\"[NHMLMx] content_encoding %s not supported\\n\", p->value.string ));\n \t\t}\n \t}\n \n \tif (ctx->opid_mdia) {\n \t\tsprintf(nhml, \"baseMediaFile=\\\"%s\\\" \", gf_file_basename(ctx->media_file) );\n \t\tgf_bs_write_data(ctx->bs_w, nhml, (u32) strlen(nhml));\n \t}\n \tsprintf(nhml, \">\\n\");\n \tgf_bs_write_data(ctx->bs_w, nhml, (u32) strlen(nhml));\n \n \tgf_bs_get_content_no_truncate(ctx->bs_w, &ctx->nhml_buffer, &size, &ctx->nhml_buffer_size);\n \n \tif (ctx->filep) {\n \t\tgf_fwrite(ctx->nhml_buffer, size, ctx->filep);\n \t\treturn;\n \t}\n \n \tdst_pck = gf_filter_pck_new_alloc(ctx->opid_nhml, size, &output);\n \tmemcpy(output, ctx->nhml_buffer, size);\n \tgf_filter_pck_set_framing(dst_pck, GF_TRUE, GF_FALSE);\n \tgf_filter_pck_send(dst_pck);\n }\n \n", "target": "// fix_start\n\t\tif (p)\n\t\t\tsprintf(nhml, \"bitsPerSample=\\\"%d\\\" \", gf_audio_fmt_bit_depth(p->value.uint));\n// fix_end\n", "cwe": "CWE-476", "cwe_name": "NULL Pointer Dereference", "cve": "CVE-2020-23930", "cve_desc": "An issue was discovered in gpac through 20200801. A NULL pointer dereference exists in the function nhmldump_send_header located in write_nhml.c. It allows an attacker to cause Denial of Service.", "project": "gpac", "idx": 196766}
{"source": " static int track_header(VividasDemuxContext *viv, AVFormatContext *s,  uint8_t *buf, int size)\n {\n     int i, j, ret;\n     int64_t off;\n     int val_1;\n     int num_video;\n     AVIOContext pb0, *pb = &pb0;\n \n     ffio_init_context(pb, buf, size, 0, NULL, NULL, NULL, NULL);\n \n     ffio_read_varlen(pb);\n     avio_r8(pb);\n \n     val_1 = ffio_read_varlen(pb);\n \n     for (i=0;i<val_1;i++) {\n         int c = avio_r8(pb);\n         if (avio_feof(pb))\n             return AVERROR_EOF;\n         for (j=0;j<c;j++) {\n             if (avio_feof(pb))\n                 return AVERROR_EOF;\n             avio_r8(pb);\n             avio_r8(pb);\n         }\n     }\n \n     avio_r8(pb);\n \n     off = avio_tell(pb);\n     off += ffio_read_varlen(pb);\n \n     avio_r8(pb);\n     num_video = avio_r8(pb);\n \n     avio_seek(pb, off, SEEK_SET);\n     if (num_video != 1) {\n         av_log(s, AV_LOG_ERROR, \"number of video tracks %d is not 1\\n\", num_video);\n         return AVERROR_PATCHWELCOME;\n     }\n \n     for (i = 0; i < num_video; i++) {\n         AVStream *st = avformat_new_stream(s, NULL);\n         int num, den;\n \n         if (!st)\n             return AVERROR(ENOMEM);\n \n         st->id = i;\n \n         st->codecpar->codec_type = AVMEDIA_TYPE_VIDEO;\n         st->codecpar->codec_id = AV_CODEC_ID_VP6;\n \n         off = avio_tell(pb);\n         off += ffio_read_varlen(pb);\n         avio_r8(pb);\n         avio_r8(pb);\n         num = avio_rl32(pb);\n         den = avio_rl32(pb);\n         avpriv_set_pts_info(st, 64, num, den);\n         st->nb_frames = avio_rl32(pb);\n         st->codecpar->width = avio_rl16(pb);\n         st->codecpar->height = avio_rl16(pb);\n         avio_r8(pb);\n         avio_rl32(pb);\n \n         avio_seek(pb, off, SEEK_SET);\n     }\n \n     off = avio_tell(pb);\n     off += ffio_read_varlen(pb);\n     avio_r8(pb);\n     viv->num_audio = avio_r8(pb);\n     avio_seek(pb, off, SEEK_SET);\n \n     if (viv->num_audio != 1)\n         av_log(s, AV_LOG_WARNING, \"number of audio tracks %d is not 1\\n\", viv->num_audio);\n \n     for(i=0;i<viv->num_audio;i++) {\n         int q;\n         AVStream *st = avformat_new_stream(s, NULL);\n         if (!st)\n             return AVERROR(ENOMEM);\n \n         st->id = num_video + i;\n \n         st->codecpar->codec_type = AVMEDIA_TYPE_AUDIO;\n         st->codecpar->codec_id = AV_CODEC_ID_VORBIS;\n \n         off = avio_tell(pb);\n         off += ffio_read_varlen(pb);\n         avio_r8(pb);\n         avio_r8(pb);\n         avio_rl16(pb);\n         st->codecpar->channels = avio_rl16(pb);\n         st->codecpar->sample_rate = avio_rl32(pb);\n         avio_seek(pb, 10, SEEK_CUR);\n         q = avio_r8(pb);\n         avio_seek(pb, q, SEEK_CUR);\n         avio_r8(pb);\n \n         if (avio_tell(pb) < off) {\n             int num_data;\n// bug_start\n            int xd_size = 0;\n// bug_end\n             int data_len[256];\n             int offset = 1;\n             uint8_t *p;\n             ffio_read_varlen(pb);\n             avio_r8(pb);\n             ffio_read_varlen(pb);\n             num_data = avio_r8(pb);\n             for (j = 0; j < num_data; j++) {\n                 uint64_t len = ffio_read_varlen(pb);\n                 if (len > INT_MAX/2 - xd_size) {\n                     return AVERROR_INVALIDDATA;\n                 }\n                 data_len[j] = len;\n// bug_start\n                xd_size += len;\n// bug_end\n             }\n \n// bug_start\n            ret = ff_alloc_extradata(st->codecpar, 64 + xd_size + xd_size / 255);\n// bug_end\n             if (ret < 0)\n                 return ret;\n \n             p = st->codecpar->extradata;\n             p[0] = 2;\n \n             for (j = 0; j < num_data - 1; j++) {\n                 unsigned delta = av_xiphlacing(&p[offset], data_len[j]);\n// bug_start\n                if (delta > data_len[j]) {\n                    return AVERROR_INVALIDDATA;\n                }\n// bug_end\n                 offset += delta;\n             }\n \n             for (j = 0; j < num_data; j++) {\n                 int ret = avio_read(pb, &p[offset], data_len[j]);\n                 if (ret < data_len[j]) {\n                     st->codecpar->extradata_size = 0;\n                     av_freep(&st->codecpar->extradata);\n                     break;\n                 }\n// bug_start\n// bug_end\n                 offset += data_len[j];\n             }\n \n             if (offset < st->codecpar->extradata_size)\n                 st->codecpar->extradata_size = offset;\n         }\n     }\n \n     return 0;\n }\n \n", "target": "// fix_start\n            int xd_size = 1;\n// fix_end\n// fix_start\n                xd_size += len + 1 + len/255;\n// fix_end\n// fix_start\n            ret = ff_alloc_extradata(st->codecpar, xd_size);\n// fix_end\n// fix_start\n                av_assert0(delta <= xd_size - offset);\n// fix_end\n// fix_start\n                av_assert0(data_len[j] <= xd_size - offset);\n// fix_end\n", "cwe": "CWE-787", "cwe_name": "Out-of-bounds Write", "cve": "CVE-2020-35964", "cve_desc": "track_header in libavformat/vividas.c in FFmpeg 4.3.1 has an out-of-bounds write because of incorrect extradata packing.", "project": "FFmpeg", "idx": 196768}
{"source": " static int process_base_block(struct archive_read* a,\n     struct archive_entry* entry)\n {\n// bug_start\n// bug_end\n \tstruct rar5* rar = get_context(a);\n \tuint32_t hdr_crc, computed_crc;\n \tsize_t raw_hdr_size = 0, hdr_size_len, hdr_size;\n \tsize_t header_id = 0;\n \tsize_t header_flags = 0;\n \tconst uint8_t* p;\n \tint ret;\n \n \tenum HEADER_TYPE {\n \t\tHEAD_MARK    = 0x00, HEAD_MAIN  = 0x01, HEAD_FILE   = 0x02,\n \t\tHEAD_SERVICE = 0x03, HEAD_CRYPT = 0x04, HEAD_ENDARC = 0x05,\n \t\tHEAD_UNKNOWN = 0xff,\n \t};\n \n \tret = skip_unprocessed_bytes(a);\n \tif(ret != ARCHIVE_OK)\n \t\treturn ret;\n \n \tif(!read_u32(a, &hdr_crc)) {\n \t\treturn ARCHIVE_EOF;\n \t}\n \n \tif(!read_var_sized(a, &raw_hdr_size, &hdr_size_len)) {\n \t\treturn ARCHIVE_EOF;\n \t}\n \n// bug_start\n\tif(raw_hdr_size > (2 * 1024 * 1024)) {\n// bug_end\n \t\tarchive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,\n \t\t    \"Base block header is too large\");\n \n \t\treturn ARCHIVE_FATAL;\n \t}\n \n// bug_start\n\thdr_size = raw_hdr_size + hdr_size_len;\n// bug_end\n \n \tif(!read_ahead(a, hdr_size, &p)) {\n \t\treturn ARCHIVE_EOF;\n \t}\n \n \tcomputed_crc = (uint32_t) crc32(0, p, (int) hdr_size);\n \tif(computed_crc != hdr_crc) {\n \t\tarchive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,\n \t\t    \"Header CRC error\");\n \n \t\treturn ARCHIVE_FATAL;\n \t}\n \n \tif(ARCHIVE_OK != consume(a, hdr_size_len)) {\n \t\treturn ARCHIVE_EOF;\n \t}\n \n \tif(!read_var_sized(a, &header_id, NULL))\n \t\treturn ARCHIVE_EOF;\n \n \tif(!read_var_sized(a, &header_flags, NULL))\n \t\treturn ARCHIVE_EOF;\n \n \trar->generic.split_after = (header_flags & HFL_SPLIT_AFTER) > 0;\n \trar->generic.split_before = (header_flags & HFL_SPLIT_BEFORE) > 0;\n \trar->generic.size = (int)hdr_size;\n \trar->generic.last_header_id = (int)header_id;\n \trar->main.endarc = 0;\n \n \tswitch(header_id) {\n \t\tcase HEAD_MAIN:\n \t\t\tret = process_head_main(a, rar, entry, header_flags);\n \n \t\t\tif(ret == ARCHIVE_OK)\n \t\t\t\treturn ARCHIVE_RETRY;\n \n \t\t\treturn ret;\n \t\tcase HEAD_SERVICE:\n \t\t\tret = process_head_service(a, rar, entry, header_flags);\n \t\t\treturn ret;\n \t\tcase HEAD_FILE:\n \t\t\tret = process_head_file(a, rar, entry, header_flags);\n \t\t\treturn ret;\n \t\tcase HEAD_CRYPT:\n \t\t\tarchive_set_error(&a->archive,\n \t\t\t    ARCHIVE_ERRNO_FILE_FORMAT,\n \t\t\t    \"Encryption is not supported\");\n \t\t\treturn ARCHIVE_FATAL;\n \t\tcase HEAD_ENDARC:\n \t\t\trar->main.endarc = 1;\n \n \t\t\tif(rar->main.volume) {\n \t\t\t\tret = scan_for_signature(a);\n \t\t\t\tif(ret == ARCHIVE_FATAL) {\n \t\t\t\t\treturn ARCHIVE_EOF;\n \t\t\t\t} else {\n \t\t\t\t\tif(rar->vol.expected_vol_no ==\n \t\t\t\t\t    UINT_MAX) {\n \t\t\t\t\t\tarchive_set_error(&a->archive,\n \t\t\t\t\t\t    ARCHIVE_ERRNO_FILE_FORMAT,\n \t\t\t\t\t\t    \"Header error\");\n \t\t\t\t\t\t\treturn ARCHIVE_FATAL;\n \t\t\t\t\t}\n \n \t\t\t\t\trar->vol.expected_vol_no =\n \t\t\t\t\t    rar->main.vol_no + 1;\n \t\t\t\t\treturn ARCHIVE_OK;\n \t\t\t\t}\n \t\t\t} else {\n \t\t\t\treturn ARCHIVE_EOF;\n \t\t\t}\n \t\tcase HEAD_MARK:\n \t\t\treturn ARCHIVE_EOF;\n \t\tdefault:\n \t\t\tif((header_flags & HFL_SKIP_IF_UNKNOWN) == 0) {\n \t\t\t\tarchive_set_error(&a->archive,\n \t\t\t\t    ARCHIVE_ERRNO_FILE_FORMAT,\n \t\t\t\t    \"Header type error\");\n \t\t\t\treturn ARCHIVE_FATAL;\n \t\t\t} else {\n \t\t\t\treturn ARCHIVE_RETRY;\n \t\t\t}\n \t}\n \n #if !defined WIN32\n \tarchive_set_error(&a->archive, ARCHIVE_ERRNO_PROGRAMMER,\n \t    \"Internal unpacker error\");\n \treturn ARCHIVE_FATAL;\n #endif\n }\n \n", "target": "// fix_start\n\tconst size_t SMALLEST_RAR5_BLOCK_SIZE = 3;\n\n// fix_end\n// fix_start\n\thdr_size = raw_hdr_size + hdr_size_len;\n\n\tif(hdr_size > (2 * 1024 * 1024)) {\n// fix_end\n// fix_start\n\tif(raw_hdr_size == 0 || hdr_size_len == 0 ||\n\t\thdr_size < SMALLEST_RAR5_BLOCK_SIZE)\n\t{\n\t\tarchive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,\n\t\t    \"Too small block encountered (%ld bytes)\",\n\t\t    raw_hdr_size);\n\n\t\treturn ARCHIVE_FATAL;\n\t}\n// fix_end\n", "cwe": "CWE-125", "cwe_name": "Out-of-bounds Read", "cve": "CVE-2020-9308", "cve_desc": "archive_read_support_format_rar5.c in libarchive before 3.4.2 attempts to unpack a RAR5 file with an invalid or corrupted header (such as a header size of zero), leading to a SIGSEGV or possibly unspecified other impact.", "project": "libarchive", "idx": 196781}
{"source": "   void Compute(OpKernelContext* context) override {\n     const Tensor& input_tensor = context->input(0);\n     const auto input_tensor_flat = input_tensor.flat<int32>();\n     const Tensor& input_splits = context->input(1);\n     const auto input_splits_flat = input_splits.flat<SPLITS_TYPE>();\n \n// bug_start\n// bug_end\n     TensorShape output_shape({input_splits.dim_size(0) - 1});\n     Tensor* output_tensor;\n     OP_REQUIRES_OK(context, context->allocate_output(\"output\", output_shape,\n                                                      &output_tensor));\n     auto output_tensor_flat = output_tensor->flat<tstring>();\n \n     int idx = 0;\n     for (int i = 1; i < input_splits_flat.size(); ++i) {\n       icu::UnicodeString unicode_string;\n       icu::UnicodeStringAppendable appendable_unicode_string(unicode_string);\n// bug_start\n// bug_end\n       for (; idx < input_splits_flat(i); ++idx) {\n         int32 code_point = input_tensor_flat(idx);\n         if (!U_IS_UNICODE_CHAR(code_point)) {\n           if (error_options_.error_on_malformatting) {\n             context->CtxFailure(errors::InvalidArgument(\n                 \"Code point is out of range for Unicode, or a noncharacter.\"));\n             return;\n           } else if (!error_options_.elide_replacement) {\n             code_point = error_options_.subst;\n           }\n         }\n         appendable_unicode_string.appendCodePoint(code_point);\n       }\n       tstring result;\n       Encode(encoding_, unicode_string, &result);\n       output_tensor_flat(i - 1) = std::move(result);\n     }\n   }\n \n", "target": "// fix_start\n    OP_REQUIRES(\n        context, input_splits_flat(0) == 0,\n        errors::InvalidArgument(\"First value in input_splits must be zero.\"));\n    OP_REQUIRES(context,\n                input_splits_flat(input_splits_flat.size() - 1) ==\n                    input_tensor_flat.size(),\n                errors::InvalidArgument(\"Last value in input_splits must be \"\n                                        \"equal to length of input_tensor.\"));\n// fix_end\n// fix_start\n      OP_REQUIRES(\n          context, input_splits_flat(i - 1) <= input_splits_flat(i),\n          errors::InvalidArgument(\n              \"Values in input_splits must be equal or in ascending order.\"));\n      OP_REQUIRES(\n          context, input_splits_flat(i) <= input_tensor_flat.size(),\n          errors::InvalidArgument(\"Values in input_splits must be less than or \"\n                                  \"equal to input_tensor length.\"));\n// fix_end\n", "cwe": "CWE-787", "cwe_name": "Out-of-bounds Write", "cve": "CVE-2021-29559", "cve_desc": "TensorFlow is an end-to-end open source platform for machine learning. An attacker can access data outside of bounds of heap allocated array in `tf.raw_ops.UnicodeEncode`. This is because the implementation(https://github.com/tensorflow/tensorflow/blob/472c1f12ad9063405737679d4f6bd43094e1d36d/tensorflow/core/kernels/unicode_ops.cc) assumes that the `input_value`/`input_splits` pair specify a valid sparse tensor. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.", "project": "tensorflow", "idx": 196791}
{"source": "   void Compute(OpKernelContext* ctx) override {\n     const Tensor& input = ctx->input(0);\n// bug_start\n    const int depth = (axis_ == -1) ? 1 : input.dim_size(axis_);\n    Tensor input_min_tensor;\n    Tensor input_max_tensor;\n// bug_end\n     Tensor* output = nullptr;\n     OP_REQUIRES_OK(ctx, ctx->allocate_output(0, input.shape(), &output));\n// bug_start\n    if (range_given_) {\n      input_min_tensor = ctx->input(1);\n      input_max_tensor = ctx->input(2);\n      if (axis_ == -1) {\n        auto min_val = input_min_tensor.scalar<T>()();\n        auto max_val = input_max_tensor.scalar<T>()();\n        OP_REQUIRES(ctx, min_val <= max_val,\n                    errors::InvalidArgument(\"Invalid range: input_min \",\n                                            min_val, \" > input_max \", max_val));\n      } else {\n        OP_REQUIRES(ctx, input_min_tensor.dim_size(0) == depth,\n                    errors::InvalidArgument(\n                        \"input_min_tensor has incorrect size, was \",\n                        input_min_tensor.dim_size(0), \" expected \", depth,\n                        \" to match dim \", axis_, \" of the input \",\n                        input_min_tensor.shape()));\n        OP_REQUIRES(ctx, input_max_tensor.dim_size(0) == depth,\n                    errors::InvalidArgument(\n                        \"input_max_tensor has incorrect size, was \",\n                        input_max_tensor.dim_size(0), \" expected \", depth,\n                        \" to match dim \", axis_, \" of the input \",\n                        input_max_tensor.shape()));\n      }\n    } else {\n      auto range_shape = (axis_ == -1) ? TensorShape({}) : TensorShape({depth});\n      OP_REQUIRES_OK(ctx, ctx->allocate_temp(DataTypeToEnum<T>::value,\n                                             range_shape, &input_min_tensor));\n      OP_REQUIRES_OK(ctx, ctx->allocate_temp(DataTypeToEnum<T>::value,\n                                             range_shape, &input_max_tensor));\n    }\n// bug_end\n \n// bug_start\n    if (axis_ == -1) {\n      functor::QuantizeAndDequantizeOneScaleFunctor<Device, T> f;\n      f(ctx->eigen_device<Device>(), input.flat<T>(), signed_input_, num_bits_,\n        range_given_, &input_min_tensor, &input_max_tensor, round_mode_,\n        narrow_range_, output->flat<T>());\n    } else {\n      functor::QuantizeAndDequantizePerChannelFunctor<Device, T> f;\n      f(ctx->eigen_device<Device>(),\n        input.template flat_inner_outer_dims<T, 3>(axis_ - 1), signed_input_,\n        num_bits_, range_given_, &input_min_tensor, &input_max_tensor,\n        round_mode_, narrow_range_,\n        output->template flat_inner_outer_dims<T, 3>(axis_ - 1));\n    }\n// bug_end\n   }\n \n", "target": "// fix_start\n\n// fix_end\n// fix_start\n// fix_end\n// fix_start\n    Tensor input_min_tensor(DataTypeToEnum<T>::value, TensorShape());\n    Tensor input_max_tensor(DataTypeToEnum<T>::value, TensorShape());\n    input_min_tensor.template scalar<T>()() = static_cast<T>(input_min_);\n    input_max_tensor.template scalar<T>()() = static_cast<T>(input_max_);\n\n    functor::QuantizeAndDequantizeOneScaleFunctor<Device, T> functor;\n    functor(ctx->eigen_device<Device>(), input.flat<T>(), signed_input_,\n            num_bits_, range_given_, &input_min_tensor, &input_max_tensor,\n            ROUND_HALF_TO_EVEN, false, output->flat<T>());\n// fix_end\n", "cwe": "CWE-787", "cwe_name": "Out-of-bounds Write", "cve": "CVE-2020-15265", "cve_desc": "In Tensorflow before version 2.4.0, an attacker can pass an invalid `axis` value to `tf.quantization.quantize_and_dequantize`. This results in accessing a dimension outside the rank of the input tensor in the C++ kernel implementation. However, dim_size only does a DCHECK to validate the argument and then uses it to access the corresponding element of an array. Since in normal builds, `DCHECK`-like macros are no-ops, this results in segfault and access out of bounds of the array. The issue is patched in eccb7ec454e6617738554a255d77f08e60ee0808 and TensorFlow 2.4.0 will be released containing the patch. TensorFlow nightly packages after this commit will also have the issue resolved.", "project": "tensorflow", "idx": 196800}
{"source": "   static void launch(OpKernelContext* context, const PoolParameters& params,\n                      const Tensor& grad_in, const Tensor& argmax,\n                      Tensor* grad_out, const bool include_batch_in_index) {\n     const DeviceBase::CpuWorkerThreads& worker_threads =\n         *(context->device()->tensorflow_cpu_worker_threads());\n \n     auto shard = [&grad_in, &argmax, &grad_out, include_batch_in_index](\n                      int64 start, int64 limit) {\n       const int64 batch_size =\n           GetTensorDim(grad_out->shape(), FORMAT_NHWC, 'N');\n       const int64 output_size_per_batch = grad_out->NumElements() / batch_size;\n       const int64 input_size_per_batch = grad_in.NumElements() / batch_size;\n \n       {\n         auto grad_out_flat = grad_out->flat<T>();\n         auto argmax_flat = argmax.flat<int64>();\n         auto grad_in_flat = grad_in.flat<T>();\n \n         const int64 output_start = start * output_size_per_batch;\n         const int64 output_end = limit * output_size_per_batch;\n         EigenMatrixMap inputShard(grad_out_flat.data() + output_start, 1,\n                                   output_end - output_start);\n         inputShard.setConstant(T(0));\n \n         const int input_start = start * input_size_per_batch;\n         const int input_end = limit * input_size_per_batch;\n         for (int64 index = input_start; index < input_end; index++) {\n// bug_start\n// bug_end\n           int64 grad_out_index = argmax_flat(index);\n           if (!include_batch_in_index) {\n             const int64 cur_batch = index / input_size_per_batch;\n             grad_out_index += cur_batch * output_size_per_batch;\n           }\n           CHECK(grad_out_index >= output_start && grad_out_index < output_end)\n               << \"Invalid output gradient index: \" << grad_out_index << \", \"\n               << output_start << \", \" << output_end;\n           grad_out_flat(grad_out_index) += grad_in_flat(index);\n         }\n       }\n     };\n \n     const int64 batch_size = GetTensorDim(grad_out->shape(), FORMAT_NHWC, 'N');\n     const int64 shard_cost = grad_out->NumElements() / batch_size;\n     Shard(worker_threads.num_threads, worker_threads.workers, batch_size,\n           shard_cost, shard);\n   }\n \n", "target": "// fix_start\n          if (index >= argmax.NumElements()) {\n            break;\n          }\n// fix_end\n", "cwe": "CWE-125", "cwe_name": "Out-of-bounds Read", "cve": "CVE-2021-29570", "cve_desc": "TensorFlow is an end-to-end open source platform for machine learning. The implementation of `tf.raw_ops.MaxPoolGradWithArgmax` can cause reads outside of bounds of heap allocated data if attacker supplies specially crafted inputs. The implementation(https://github.com/tensorflow/tensorflow/blob/ef0c008ee84bad91ec6725ddc42091e19a30cf0e/tensorflow/core/kernels/maxpooling_op.cc#L1016-L1017) uses the same value to index in two different arrays but there is no guarantee that the sizes are identical. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.", "project": "tensorflow", "idx": 196802}
{"source": " void UncompressElementOp::Compute(OpKernelContext* ctx) {\n   Tensor tensor = ctx->input(0);\n   const Variant& variant = tensor.scalar<Variant>()();\n   const CompressedElement* compressed = variant.get<CompressedElement>();\n// bug_start\n// bug_end\n \n   std::vector<Tensor> components;\n   OP_REQUIRES_OK(ctx, UncompressElement(*compressed, &components));\n   OP_REQUIRES(ctx, components.size() == output_types_.size(),\n               errors::FailedPrecondition(\"Expected \", output_types_.size(),\n                                          \" outputs from uncompress, but got \",\n                                          components.size()));\n   for (int i = 0; i < components.size(); ++i) {\n     OP_REQUIRES(\n         ctx, components[i].dtype() == output_types_[i],\n         errors::FailedPrecondition(\"Expected a tensor of type \",\n                                    DataTypeString(output_types_[i]),\n                                    \" but got a tensor of type \",\n                                    DataTypeString(components[i].dtype())));\n     ctx->set_output(i, components[i]);\n   }\n }\n \n", "target": "// fix_start\n  OP_REQUIRES(\n      ctx, compressed != nullptr,\n      errors::InvalidArgument(\n          \"Input does not contain a compressed element. Instead got tensor \",\n          tensor.DebugString()));\n// fix_end\n", "cwe": "CWE-476", "cwe_name": "NULL Pointer Dereference", "cve": "CVE-2021-37649", "cve_desc": "TensorFlow is an end-to-end open source platform for machine learning. The code for `tf.raw_ops.UncompressElement` can be made to trigger a null pointer dereference. The [implementation](https://github.com/tensorflow/tensorflow/blob/f24faa153ad31a4b51578f8181d3aaab77a1ddeb/tensorflow/core/kernels/data/experimental/compression_ops.cc#L50-L53) obtains a pointer to a `CompressedElement` from a `Variant` tensor and then proceeds to dereference it for decompressing. There is no check that the `Variant` tensor contained a `CompressedElement`, so the pointer is actually `nullptr`. We have patched the issue in GitHub commit 7bdf50bb4f5c54a4997c379092888546c97c3ebd. The fix will be included in TensorFlow 2.6.0. We will also cherrypick this commit on TensorFlow 2.5.1, TensorFlow 2.4.3, and TensorFlow 2.3.4, as these are also affected and still in supported range.", "project": "tensorflow", "idx": 196811}
{"source": " PrimitiveStatus TrustedPrimitives::UntrustedCall(uint64_t untrusted_selector,\n                                                  MessageWriter *input,\n                                                  MessageReader *output) {\n   int ret;\n \n   UntrustedCacheMalloc *untrusted_cache = UntrustedCacheMalloc::Instance();\n \n   SgxParams *const sgx_params =\n       reinterpret_cast<SgxParams *>(untrusted_cache->Malloc(sizeof(SgxParams)));\n   Cleanup clean_up(\n       [sgx_params, untrusted_cache] { untrusted_cache->Free(sgx_params); });\n   sgx_params->input_size = 0;\n   sgx_params->input = nullptr;\n   if (input) {\n     sgx_params->input_size = input->MessageSize();\n     if (sgx_params->input_size > 0) {\n       sgx_params->input = untrusted_cache->Malloc(sgx_params->input_size);\n       input->Serialize(const_cast<void *>(sgx_params->input));\n     }\n   }\n   sgx_params->output_size = 0;\n   sgx_params->output = nullptr;\n   CHECK_OCALL(\n       ocall_dispatch_untrusted_call(&ret, untrusted_selector, sgx_params));\n   if (sgx_params->input) {\n     untrusted_cache->Free(const_cast<void *>(sgx_params->input));\n   }\n// bug_start\n// bug_end\n   if (sgx_params->output) {\n     output->Deserialize(sgx_params->output, sgx_params->output_size);\n     TrustedPrimitives::UntrustedLocalFree(sgx_params->output);\n   }\n   return PrimitiveStatus::OkStatus();\n }\n \n", "target": "// fix_start\n  if (!TrustedPrimitives::IsOutsideEnclave(sgx_params->output,\n                                           sgx_params->output_size)) {\n    TrustedPrimitives::BestEffortAbort(\n        \"UntrustedCall: sgx_param output should be in untrusted memory\");\n  }\n// fix_end\n", "cwe": "CWE-125", "cwe_name": "Out-of-bounds Read", "cve": "CVE-2020-8936", "cve_desc": "An arbitrary memory overwrite vulnerability in Asylo versions up to 0.6.0 allows an attacker to make a host call to UntrustedCall. UntrustedCall failed to validate the buffer range within sgx_params and allowed the host to return a pointer that was an address within the enclave memory. This allowed an attacker to read memory values from within the enclave.", "project": "asylo", "idx": 196831}
{"source": "     StreamBufferHandle_t xStreamBufferGenericCreate( size_t xBufferSizeBytes,\n                                                      size_t xTriggerLevelBytes,\n                                                      BaseType_t xIsMessageBuffer )\n     {\n         uint8_t * pucAllocatedMemory;\n         uint8_t ucFlags;\n \n         if( xIsMessageBuffer == pdTRUE )\n         {\n             ucFlags = sbFLAGS_IS_MESSAGE_BUFFER;\n             configASSERT( xBufferSizeBytes > sbBYTES_TO_STORE_MESSAGE_LENGTH );\n         }\n         else\n         {\n             ucFlags = 0;\n             configASSERT( xBufferSizeBytes > 0 );\n         }\n \n         configASSERT( xTriggerLevelBytes <= xBufferSizeBytes );\n \n         if( xTriggerLevelBytes == ( size_t ) 0 )\n         {\n             xTriggerLevelBytes = ( size_t ) 1;\n         }\n \n// bug_start\n        xBufferSizeBytes++;\n        pucAllocatedMemory = ( uint8_t * ) pvPortMalloc( xBufferSizeBytes + sizeof( StreamBuffer_t ) );\n// bug_end\n \n         if( pucAllocatedMemory != NULL )\n         {\n             prvInitialiseNewStreamBuffer( ( StreamBuffer_t * ) pucAllocatedMemory,\n                                           pucAllocatedMemory + sizeof( StreamBuffer_t ),\n                                           xBufferSizeBytes,\n                                           xTriggerLevelBytes,\n                                           ucFlags );\n \n             traceSTREAM_BUFFER_CREATE( ( ( StreamBuffer_t * ) pucAllocatedMemory ), xIsMessageBuffer );\n         }\n         else\n         {\n             traceSTREAM_BUFFER_CREATE_FAILED( xIsMessageBuffer );\n         }\n \n         return ( StreamBufferHandle_t ) pucAllocatedMemory;\n     }\n \n", "target": "// fix_start\n        if( xBufferSizeBytes < ( xBufferSizeBytes + 1 + sizeof( StreamBuffer_t ) ) )\n        {\n            xBufferSizeBytes++;\n            pucAllocatedMemory = ( uint8_t * ) pvPortMalloc( xBufferSizeBytes + sizeof( StreamBuffer_t ) );\n        }\n        else\n        {\n            pucAllocatedMemory = NULL;\n        }\n\n// fix_end\n", "cwe": "CWE-190", "cwe_name": "Integer Overflow or Wraparound", "cve": "CVE-2021-31572", "cve_desc": "The kernel in Amazon Web Services FreeRTOS before 10.4.3 has an integer overflow in stream_buffer.c for a stream buffer.", "project": "FreeRTOS-Kernel", "idx": 196843}
{"source": " Status CompressElement(const std::vector<Tensor>& element,\n                        CompressedElement* out) {\n   std::vector<TensorProto> non_memcpy_components;\n   int64 total_size = 0;\n   for (auto& component : element) {\n     if (DataTypeCanUseMemcpy(component.dtype())) {\n// bug_start\n      total_size += DMAHelper::buffer(&component)->size();\n// bug_end\n     } else {\n       non_memcpy_components.emplace_back();\n       component.AsProtoTensorContent(&non_memcpy_components.back());\n       total_size += non_memcpy_components.back().ByteSizeLong();\n     }\n   }\n \n   tstring uncompressed;\n   uncompressed.resize_uninitialized(total_size);\n   char* position = uncompressed.mdata();\n   int non_memcpy_component_index = 0;\n   for (auto& component : element) {\n     CompressedComponentMetadata* metadata =\n         out->mutable_component_metadata()->Add();\n     metadata->set_dtype(component.dtype());\n     component.shape().AsProto(metadata->mutable_tensor_shape());\n     if (DataTypeCanUseMemcpy(component.dtype())) {\n       const TensorBuffer* buffer = DMAHelper::buffer(&component);\n// bug_start\n      memcpy(position, buffer->data(), buffer->size());\n      metadata->set_tensor_size_bytes(buffer->size());\n// bug_end\n     } else {\n       TensorProto& proto = non_memcpy_components[non_memcpy_component_index++];\n       proto.SerializeToArray(position, proto.ByteSizeLong());\n       metadata->set_tensor_size_bytes(proto.ByteSizeLong());\n     }\n     position += metadata->tensor_size_bytes();\n   }\n   DCHECK_EQ(position, uncompressed.mdata() + total_size);\n \n   if (!port::Snappy_Compress(uncompressed.mdata(), total_size,\n                              out->mutable_data())) {\n     return errors::Internal(\"Failed to compress using snappy.\");\n   }\n   VLOG(3) << \"Compressed element from \" << total_size << \" bytes to \"\n           << out->data().size() << \" bytes\";\n   return Status::OK();\n }\n \n", "target": "// fix_start\n      const TensorBuffer* buffer = DMAHelper::buffer(&component);\n      if (buffer) {\n        total_size += buffer->size();\n      }\n// fix_end\n// fix_start\n      if (buffer) {\n        memcpy(position, buffer->data(), buffer->size());\n        metadata->set_tensor_size_bytes(buffer->size());\n      }\n// fix_end\n", "cwe": "CWE-125", "cwe_name": "Out-of-bounds Read", "cve": "CVE-2021-37637", "cve_desc": "TensorFlow is an end-to-end open source platform for machine learning. It is possible to trigger a null pointer dereference in TensorFlow by passing an invalid input to `tf.raw_ops.CompressElement`. The [implementation](https://github.com/tensorflow/tensorflow/blob/47a06f40411a69c99f381495f490536972152ac0/tensorflow/core/data/compression_utils.cc#L34) was accessing the size of a buffer obtained from the return of a separate function call before validating that said buffer is valid. We have patched the issue in GitHub commit 5dc7f6981fdaf74c8c5be41f393df705841fb7c5. The fix will be included in TensorFlow 2.6.0. We will also cherrypick this commit on TensorFlow 2.5.1, TensorFlow 2.4.3, and TensorFlow 2.3.4, as these are also affected and still in supported range.", "project": "tensorflow", "idx": 196856}
{"source": "   void Compute(OpKernelContext *ctx) override {\n     const Tensor *a_indices_t, *a_values_t, *a_shape_t, *b_indices_t,\n         *b_values_t, *b_shape_t;\n     OP_REQUIRES_OK(ctx, ctx->input(\"a_indices\", &a_indices_t));\n     OP_REQUIRES_OK(ctx, ctx->input(\"a_values\", &a_values_t));\n     OP_REQUIRES_OK(ctx, ctx->input(\"a_shape\", &a_shape_t));\n     OP_REQUIRES_OK(ctx, ctx->input(\"b_indices\", &b_indices_t));\n     OP_REQUIRES_OK(ctx, ctx->input(\"b_values\", &b_values_t));\n     OP_REQUIRES_OK(ctx, ctx->input(\"b_shape\", &b_shape_t));\n \n     OP_REQUIRES(\n         ctx,\n         TensorShapeUtils::IsMatrix(a_indices_t->shape()) &&\n             TensorShapeUtils::IsMatrix(b_indices_t->shape()),\n         errors::InvalidArgument(\"Inputs a_indices and b_indices should be \"\n                                 \"matrices but received shapes: \",\n                                 a_indices_t->shape().DebugString(), \", \",\n                                 b_indices_t->shape().DebugString()));\n     OP_REQUIRES(ctx,\n                 TensorShapeUtils::IsVector(a_values_t->shape()) &&\n                     TensorShapeUtils::IsVector(b_values_t->shape()),\n                 errors::InvalidArgument(\n                     \"Inputs a_values and b_values should be vectors \"\n                     \"but received shapes: \",\n                     a_values_t->shape().DebugString(), \" and \",\n                     b_values_t->shape().DebugString()));\n \n     const int64 a_nnz = a_indices_t->dim_size(0);\n     const int64 b_nnz = b_indices_t->dim_size(0);\n// bug_start\n// bug_end\n     const auto a_values = a_values_t->vec<T>();\n     const auto b_values = b_values_t->vec<T>();\n \n     OP_REQUIRES(\n         ctx, a_values.size() == a_nnz && b_values.size() == b_nnz,\n         errors::InvalidArgument(\"Expected \", a_nnz, \" and \", b_nnz,\n                                 \" non-empty input values, got \",\n                                 a_values.size(), \" and \", b_values.size()));\n \n     OP_REQUIRES(ctx,\n                 TensorShapeUtils::IsVector(a_shape_t->shape()) &&\n                     TensorShapeUtils::IsVector(b_shape_t->shape()),\n                 errors::InvalidArgument(\n                     \"Input shapes should be a vector but received shapes \",\n                     a_shape_t->shape().DebugString(), \" and \",\n                     b_shape_t->shape().DebugString()));\n// bug_start\n// bug_end\n     OP_REQUIRES(ctx, a_shape_t->IsSameSize(*b_shape_t),\n                 errors::InvalidArgument(\n                     \"Operands do not have the same ranks; got shapes: \",\n                     a_shape_t->SummarizeValue(10), \" and \",\n                     b_shape_t->SummarizeValue(10)));\n     const auto a_shape = a_shape_t->flat<int64>();\n     const auto b_shape = b_shape_t->flat<int64>();\n     for (int i = 0; i < a_shape_t->NumElements(); ++i) {\n       OP_REQUIRES(ctx, a_shape(i) == b_shape(i),\n                   errors::InvalidArgument(\"Operands' shapes do not match: got \",\n                                           a_shape(i), \" and \", b_shape(i),\n                                           \" for dimension \", i));\n     }\n \n// bug_start\n    OP_REQUIRES(\n        ctx, a_indices_t->dim_size(1) == b_indices_t->dim_size(1),\n        errors::InvalidArgument(\n            \"Indices' dimensions do not match: got \", a_indices_t->dim_size(1),\n            \" and \", b_indices_t->dim_size(1), \" for the second dimension.\"));\n    const int num_dims = a_indices_t->dim_size(1);\n// bug_end\n     const auto a_indices_mat = a_indices_t->matrix<int64>();\n     const auto b_indices_mat = b_indices_t->matrix<int64>();\n     std::vector<T> a_augmented_values, b_augmented_values;\n     std::vector<std::pair<bool, int64>> entries_to_copy;\n     UnionSparseIndicesAndValues(a_indices_mat, a_values, a_nnz, b_indices_mat,\n                                 b_values, b_nnz, num_dims, &a_augmented_values,\n                                 &b_augmented_values, &entries_to_copy);\n \n     const int64 sum_nnz = a_augmented_values.size();\n     Tensor *output_indices_t, *output_values_t;\n     OP_REQUIRES_OK(ctx,\n                    ctx->allocate_output(0, TensorShape({sum_nnz, num_dims}),\n                                         &output_indices_t));\n     OP_REQUIRES_OK(\n         ctx, ctx->allocate_output(1, TensorShape({sum_nnz}), &output_values_t));\n     auto output_indices_mat = output_indices_t->matrix<int64>();\n \n     for (int64 i = 0; i < sum_nnz; ++i) {\n       const bool from_a = entries_to_copy[i].first;\n       const int64 idx = entries_to_copy[i].second;\n       output_indices_mat.chip<0>(i) =\n           from_a ? a_indices_mat.chip<0>(idx) : b_indices_mat.chip<0>(idx);\n     }\n \n     using UnalignedTensorMap =\n         Eigen::TensorMap<Eigen::Tensor<const T, 1, Eigen::RowMajor>,\n                          Eigen::Unaligned>;\n     auto a_augmented_values_t =\n         UnalignedTensorMap(a_augmented_values.data(), sum_nnz);\n     auto b_augmented_values_t =\n         UnalignedTensorMap(b_augmented_values.data(), sum_nnz);\n     output_values_t->flat<T>().device(ctx->eigen_device<Device>()) =\n         a_augmented_values_t.binaryExpr(b_augmented_values_t,\n                                         typename Functor::func());\n   }\n \n", "target": "// fix_start\n\n// fix_end\n// fix_start\n    const int num_dims = a_indices_t->dim_size(1);\n    OP_REQUIRES(\n        ctx, a_shape_t->NumElements() == num_dims,\n        errors::InvalidArgument(\"Second dimension of a_indices and length of \"\n                                \"a_shape must match, got \",\n                                num_dims, \" and \", a_shape_t->NumElements()));\n    OP_REQUIRES(ctx, num_dims > 0,\n                errors::InvalidArgument(\"Tensors must not be empty\"));\n// fix_end\n// fix_start\n// fix_end\n", "cwe": "CWE-369", "cwe_name": "Divide By Zero", "cve": "CVE-2021-29607", "cve_desc": "TensorFlow is an end-to-end open source platform for machine learning. Incomplete validation in `SparseAdd` results in allowing attackers to exploit undefined behavior (dereferencing null pointers) as well as write outside of bounds of heap allocated data. The implementation(https://github.com/tensorflow/tensorflow/blob/656e7673b14acd7835dc778867f84916c6d1cac2/tensorflow/core/kernels/sparse_sparse_binary_op_shared.cc) has a large set of validation for the two sparse tensor inputs (6 tensors in total), but does not validate that the tensors are not empty or that the second dimension of `*_indices` matches the size of corresponding `*_shape`. This allows attackers to send tensor triples that represent invalid sparse tensors to abuse code assumptions that are not protected by validation. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.", "project": "tensorflow", "idx": 196857}
{"source": "   bool matches(const Http::RequestHeaderMap& headers) const override {\n     if (BaseMatcherImpl::matchRoute(headers)) {\n// bug_start\n// bug_end\n       const Http::HeaderString& path = headers.Path()->value();\n       const absl::string_view query_string = Http::Utility::findQueryStringStart(path);\n       absl::string_view path_view = path.getStringView();\n       path_view.remove_suffix(query_string.length());\n       if (path_matcher_->match(path_view)) {\n         ENVOY_LOG(debug, \"Regex requirement '{}' matched.\", regex_str_);\n         return true;\n       }\n     }\n     return false;\n   }\n \n", "target": "// fix_start\n      if (headers.Path() == nullptr) {\n        return false;\n      }\n// fix_end\n", "cwe": "CWE-703", "cwe_name": "Improper Check or Handling of Exceptional Conditions", "cve": "CVE-2021-43824", "cve_desc": "Envoy is an open source edge and service proxy, designed for cloud-native applications. In affected versions a crafted request crashes Envoy when a CONNECT request is sent to JWT filter configured with regex match. This provides a denial of service attack vector. The only workaround is to not use regex in the JWT filter. Users are advised to upgrade.", "project": "envoy", "idx": 196858}
{"source": " void M_LoadDefaults (void)\n {\n     int\t\ti;\n     int\t\tlen;\n     FILE*\tf;\n     char\tdef[80];\n     char\tstrparm[100];\n     char*\tnewstring;\n     int\t\tparm;\n     boolean\tisstring;\n \n     numdefaults = sizeof(defaults)/sizeof(defaults[0]);\n     for (i=0 ; i<numdefaults ; i++)\n \t*defaults[i].location = defaults[i].defaultvalue;\n \n     i = M_CheckParm (\"-config\");\n     if (i && i<myargc-1)\n     {\n \tdefaultfile = myargv[i+1];\n \tprintf (\"\tdefault file: %s\\n\",defaultfile);\n     }\n     else\n \tdefaultfile = basedefault;\n \n     f = fopen (defaultfile, \"r\");\n     if (f)\n     {\n \twhile (!feof(f))\n \t{\n \t    isstring = false;\n// bug_start\n\t    if (fscanf (f, \"%79s %[^\\n]\\n\", def, strparm) == 2)\n// bug_end\n \t    {\n \t\tif (strparm[0] == '\"')\n \t\t{\n \t\t    isstring = true;\n \t\t    len = strlen(strparm);\n \t\t    newstring = (char *) malloc(len);\n \t\t    strparm[len-1] = 0;\n \t\t    strcpy(newstring, strparm+1);\n \t\t}\n \t\telse if (strparm[0] == '0' && strparm[1] == 'x')\n \t\t    sscanf(strparm+2, \"%x\", &parm);\n \t\telse\n \t\t    sscanf(strparm, \"%i\", &parm);\n \t\tfor (i=0 ; i<numdefaults ; i++)\n \t\t    if (!strcmp(def, defaults[i].name))\n \t\t    {\n \t\t\tif (!isstring)\n \t\t\t    *defaults[i].location = parm;\n \t\t\telse\n \t\t\t    *defaults[i].location =\n \t\t\t\t(int) newstring;\n \t\t\tbreak;\n \t\t    }\n \t    }\n \t}\n \n \tfclose (f);\n     }\n \n     for (i = 0; i < numdefaults; i++)\n     {\n         if (defaults[i].scantranslate)\n         {\n             parm = *defaults[i].location;\n             defaults[i].untranslated = parm;\n             *defaults[i].location = scantokey[parm];\n         }\n     }\n }\n \n", "target": "// fix_start\n\t    if (fscanf (f, \"%79s %99[^\\n]\\n\", def, strparm) == 2)\n// fix_end\n", "cwe": "CWE-787", "cwe_name": "Out-of-bounds Write", "cve": "CVE-2020-15007", "cve_desc": "A buffer overflow in the M_LoadDefaults function in m_misc.c in id Tech 1 (aka Doom engine) allows arbitrary code execution via an unsafe usage of fscanf, because it does not limit the number of characters to be read in a format argument.", "project": "doom-vanille", "idx": 196884}
{"source": "   void Compute(OpKernelContext* context) override {\n     typedef Eigen::Map<const Eigen::Matrix<T, Eigen::Dynamic, Eigen::Dynamic>>\n         ConstEigenMatrixMap;\n     typedef Eigen::Map<Eigen::Matrix<T, Eigen::Dynamic, Eigen::Dynamic>>\n         EigenMatrixMap;\n \n     constexpr int tensor_in_and_out_dims = 4;\n \n     const Tensor& tensor_in = context->input(0);\n     OP_REQUIRES(context, tensor_in.dims() == tensor_in_and_out_dims,\n                 errors::InvalidArgument(\"tensor_in must be 4-dimensional\"));\n \n     std::vector<int> input_size(tensor_in_and_out_dims);\n     std::vector<int> output_size(tensor_in_and_out_dims);\n     for (int i = 0; i < tensor_in_and_out_dims; ++i) {\n       input_size[i] = tensor_in.dim_size(i);\n// bug_start\n// bug_end\n     }\n     for (int i = 0; i < tensor_in_and_out_dims; ++i) {\n       output_size[i] =\n           static_cast<int>(std::floor(input_size[i] / pooling_ratio_[i]));\n       DCHECK_GT(output_size[i], 0);\n     }\n \n     std::vector<int64> row_cum_seq;\n     std::vector<int64> col_cum_seq;\n     GuardedPhiloxRandom generator;\n     generator.Init(seed_, seed2_);\n     row_cum_seq = GeneratePoolingSequence(input_size[1], output_size[1],\n                                           &generator, pseudo_random_);\n     col_cum_seq = GeneratePoolingSequence(input_size[2], output_size[2],\n                                           &generator, pseudo_random_);\n \n     Tensor* output_tensor = nullptr;\n     OP_REQUIRES_OK(context, context->allocate_output(\n                                 0,\n                                 TensorShape({output_size[0], output_size[1],\n                                              output_size[2], output_size[3]}),\n                                 &output_tensor));\n     Tensor* output_row_seq_tensor = nullptr;\n     OP_REQUIRES_OK(context,\n                    context->allocate_output(\n                        1, TensorShape({static_cast<int64>(row_cum_seq.size())}),\n                        &output_row_seq_tensor));\n     Tensor* output_col_seq_tensor = nullptr;\n     OP_REQUIRES_OK(context,\n                    context->allocate_output(\n                        2, TensorShape({static_cast<int64>(col_cum_seq.size())}),\n                        &output_col_seq_tensor));\n \n     ConstEigenMatrixMap in_mat(tensor_in.flat<T>().data(), input_size[3],\n                                input_size[2] * input_size[1] * input_size[0]);\n \n     EigenMatrixMap out_mat(output_tensor->flat<T>().data(), output_size[3],\n                            output_size[2] * output_size[1] * output_size[0]);\n     Eigen::Matrix<T, Eigen::Dynamic, 1> out_count(out_mat.cols());\n \n     out_mat.setZero();\n     out_count.setZero();\n \n     auto output_row_seq_flat = output_row_seq_tensor->flat<int64>();\n     auto output_col_seq_flat = output_col_seq_tensor->flat<int64>();\n \n     for (int i = 0; i < row_cum_seq.size(); ++i) {\n       output_row_seq_flat(i) = row_cum_seq[i];\n     }\n \n     for (int i = 0; i < col_cum_seq.size(); ++i) {\n       output_col_seq_flat(i) = col_cum_seq[i];\n     }\n \n     const int64 row_max = input_size[1] - 1;\n     const int64 col_max = input_size[2] - 1;\n     for (int64 b = 0; b < input_size[0]; ++b) {\n       for (int64 hs = 0; hs < row_cum_seq.size() - 1; ++hs) {\n         const int64 row_start = row_cum_seq[hs];\n         int64 row_end =\n             overlapping_ ? row_cum_seq[hs + 1] : row_cum_seq[hs + 1] - 1;\n         row_end = std::min(row_end, row_max);\n \n         for (int64 ws = 0; ws < col_cum_seq.size() - 1; ++ws) {\n           const int64 out_offset =\n               (b * output_size[1] + hs) * output_size[2] + ws;\n           const int64 col_start = col_cum_seq[ws];\n           int64 col_end =\n               overlapping_ ? col_cum_seq[ws + 1] : col_cum_seq[ws + 1] - 1;\n           col_end = std::min(col_end, col_max);\n           for (int64 h = row_start; h <= row_end; ++h) {\n             for (int64 w = col_start; w <= col_end; ++w) {\n               const int64 in_offset =\n                   (b * input_size[1] + h) * input_size[2] + w;\n               out_mat.col(out_offset) += in_mat.col(in_offset);\n               out_count(out_offset)++;\n             }\n           }\n         }\n       }\n     }\n     DCHECK_GT(out_count.minCoeff(), 0);\n     out_mat.array().rowwise() /= out_count.transpose().array();\n   }\n \n", "target": "// fix_start\n      OP_REQUIRES(\n          context, pooling_ratio_[i] <= input_size[i],\n          errors::InvalidArgument(\n              \"Pooling ratio cannot be bigger than input tensor dim size.\"));\n// fix_end\n", "cwe": "CWE-369", "cwe_name": "Divide By Zero", "cve": "CVE-2021-29550", "cve_desc": "TensorFlow is an end-to-end open source platform for machine learning. An attacker can cause a runtime division by zero error and denial of service in `tf.raw_ops.FractionalAvgPool`. This is because the implementation(https://github.com/tensorflow/tensorflow/blob/acc8ee69f5f46f92a3f1f11230f49c6ac266f10c/tensorflow/core/kernels/fractional_avg_pool_op.cc#L85-L89) computes a divisor quantity by dividing two user controlled values. The user controls the values of `input_size[i]` and `pooling_ratio_[i]` (via the `value.shape()` and `pooling_ratio` arguments). If the value in `input_size[i]` is smaller than the `pooling_ratio_[i]`, then the floor operation results in `output_size[i]` being 0. The `DCHECK_GT` line is a no-op outside of debug mode, so in released versions of TF this does not trigger. Later, these computed values are used as arguments(https://github.com/tensorflow/tensorflow/blob/acc8ee69f5f46f92a3f1f11230f49c6ac266f10c/tensorflow/core/kernels/fractional_avg_pool_op.cc#L96-L99) to `GeneratePoolingSequence`(https://github.com/tensorflow/tensorflow/blob/acc8ee69f5f46f92a3f1f11230f49c6ac266f10c/tensorflow/core/kernels/fractional_pool_common.cc#L100-L108). There, the first computation is a division in a modulo operation. Since `output_length` can be 0, this results in runtime crashing. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.", "project": "tensorflow", "idx": 196921}
{"source": " static void SpatialMaxPoolWithArgMaxHelper(\n     OpKernelContext* context, Tensor* output, Tensor* output_arg_max,\n     Tensor* input_backprop, const Tensor& tensor_in, const Tensor& out_backprop,\n     const PoolParameters& params, const bool include_batch_in_index) {\n   if (input_backprop != nullptr) {\n     OP_REQUIRES(\n         context, include_batch_in_index,\n         errors::Internal(\n             \"SpatialMaxPoolWithArgMaxHelper requires include_batch_in_index \"\n             \"to be True when input_backprop != nullptr\"));\n     OP_REQUIRES(\n         context, (std::is_same<Targmax, int64>::value),\n         errors::Internal(\"SpatialMaxPoolWithArgMaxHelper requires Targmax \"\n                          \"to be int64 when input_backprop != nullptr\"));\n   }\n \n   typedef Eigen::Map<const Eigen::Matrix<T, Eigen::Dynamic, Eigen::Dynamic>>\n       ConstEigenMatrixMap;\n   typedef Eigen::Map<Eigen::Matrix<T, Eigen::Dynamic, Eigen::Dynamic>>\n       EigenMatrixMap;\n   typedef Eigen::Map<Eigen::Matrix<Targmax, Eigen::Dynamic, Eigen::Dynamic>>\n       EigenIndexMatrixMap;\n \n   ConstEigenMatrixMap in_mat(\n       tensor_in.flat<T>().data(), params.depth,\n       params.tensor_in_cols * params.tensor_in_rows * params.tensor_in_batch);\n   EigenMatrixMap out_mat(\n       output->flat<T>().data(), params.depth,\n       params.out_width * params.out_height * params.tensor_in_batch);\n   EigenIndexMatrixMap out_arg_max_mat(\n       output_arg_max->flat<Targmax>().data(), params.depth,\n       params.out_width * params.out_height * params.tensor_in_batch);\n \n   const DeviceBase::CpuWorkerThreads& worker_threads =\n       *(context->device()->tensorflow_cpu_worker_threads());\n \n   auto shard = [&params, &in_mat, &out_mat, &out_arg_max_mat, &input_backprop,\n                 &output_arg_max, &out_backprop,\n                 include_batch_in_index](int64 start, int64 limit) {\n     const int32 depth = params.depth;\n     const int32 in_rows = params.tensor_in_rows;\n     const int32 in_cols = params.tensor_in_cols;\n     const int32 pad_top = params.pad_top;\n     const int32 pad_left = params.pad_left;\n     const int32 window_rows = params.window_rows;\n     const int32 window_cols = params.window_cols;\n     const int32 row_stride = params.row_stride;\n     const int32 col_stride = params.col_stride;\n     const int32 out_height = params.out_height;\n     const int32 out_width = params.out_width;\n \n     {\n       const int32 output_image_size = out_height * out_width * depth;\n       EigenMatrixMap out_shard(out_mat.data() + start * output_image_size, 1,\n                                (limit - start) * output_image_size);\n       out_shard.setConstant(Eigen::NumTraits<T>::lowest());\n       EigenIndexMatrixMap out_arg_max_shard(\n           out_arg_max_mat.data() + start * output_image_size, 1,\n           (limit - start) * output_image_size);\n       out_arg_max_shard.setConstant(kInvalidMaxPoolingIndex);\n     }\n \n     for (int64 b = start; b < limit; ++b) {\n       for (int h = 0; h < in_rows; ++h) {\n         for (int w = 0; w < in_cols; ++w) {\n           const int hpad = h + pad_top;\n           const int wpad = w + pad_left;\n           const int h_start =\n               (hpad < window_rows) ? 0 : (hpad - window_rows) / row_stride + 1;\n           const int h_end = std::min(hpad / row_stride + 1, out_height);\n           const int w_start =\n               (wpad < window_cols) ? 0 : (wpad - window_cols) / col_stride + 1;\n           const int w_end = std::min(wpad / col_stride + 1, out_width);\n           const int64 in_index = (b * in_rows + h) * in_cols + w;\n           for (int ph = h_start; ph < h_end; ++ph) {\n             const int64 out_index_base = (b * out_height + ph) * out_width;\n             for (int pw = w_start; pw < w_end; ++pw) {\n               const int64 out_index = out_index_base + pw;\n               for (int d = 0; d < depth; ++d) {\n                 const T& input_ref = in_mat.coeffRef(d, in_index);\n                 T& output_ref = out_mat.coeffRef(d, out_index);\n                 Targmax& out_arg_max_ref =\n                     out_arg_max_mat.coeffRef(d, out_index);\n                 if (output_ref < input_ref ||\n                     out_arg_max_ref == kInvalidMaxPoolingIndex) {\n                   output_ref = input_ref;\n                   if (include_batch_in_index) {\n                     out_arg_max_ref = in_index * depth + d;\n                   } else {\n                     out_arg_max_ref = (h * in_cols + w) * depth + d;\n                   }\n                 }\n               }\n             }\n           }\n         }\n       }\n     }\n \n     if (input_backprop != nullptr) {\n       auto input_backprop_flat = input_backprop->flat<T>();\n       auto out_arg_max_flat = output_arg_max->flat<int64>();\n       auto out_backprop_flat = out_backprop.flat<T>();\n \n       const int64 in_size = in_rows * in_cols * depth;\n       const int64 in_start = start * in_size;\n       const int64 in_end = limit * in_size;\n       EigenMatrixMap in_shard(input_backprop_flat.data() + in_start, 1,\n                               in_end - in_start);\n       in_shard.setConstant(T(0));\n \n       const int out_size = out_height * out_width * depth;\n       const int out_start = start * out_size;\n       const int out_end = limit * out_size;\n       for (int index = out_start; index < out_end; ++index) {\n         int input_backprop_index = out_arg_max_flat(index);\n         FastBoundsCheck(input_backprop_index - in_start, in_end - in_start);\n// bug_start\n        input_backprop_flat(input_backprop_index) += out_backprop_flat(index);\n// bug_end\n       }\n     }\n   };\n \n   const int64 shard_cost = params.tensor_in_rows * params.tensor_in_cols *\n                            params.depth * params.window_rows *\n                            params.window_cols;\n   Shard(worker_threads.num_threads, worker_threads.workers,\n         params.tensor_in_batch, shard_cost, shard);\n }\n \n", "target": "// fix_start\n        if (index < out_backprop.NumElements()) {\n          input_backprop_flat(input_backprop_index) += out_backprop_flat(index);\n        }\n// fix_end\n", "cwe": "CWE-787", "cwe_name": "Out-of-bounds Write", "cve": "CVE-2021-29579", "cve_desc": "TensorFlow is an end-to-end open source platform for machine learning. The implementation of `tf.raw_ops.MaxPoolGrad` is vulnerable to a heap buffer overflow. The implementation(https://github.com/tensorflow/tensorflow/blob/ab1e644b48c82cb71493f4362b4dd38f4577a1cf/tensorflow/core/kernels/maxpooling_op.cc#L194-L203) fails to validate that indices used to access elements of input/output arrays are valid. Whereas accesses to `input_backprop_flat` are guarded by `FastBoundsCheck`, the indexing in `out_backprop_flat` can result in OOB access. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.", "project": "tensorflow", "idx": 196935}
{"source": " extern \"C\" int64_t enc_untrusted_syscall(int sysno, ...) {\n   if (!enc_is_error_handler_set()) {\n     enc_set_error_handler(default_error_handler);\n   }\n \n   asylo::system_call::SystemCallDescriptor descriptor{sysno};\n   if (!descriptor.is_valid()) {\n     error_handler(\"system_call.cc: Invalid SystemCallDescriptor encountered.\");\n   }\n \n   std::array<uint64_t, asylo::system_call::kParameterMax> parameters;\n   va_list args;\n   va_start(args, sysno);\n   for (int i = 0; i < descriptor.parameter_count(); i++) {\n     parameters[i] = va_arg(args, uint64_t);\n   }\n   va_end(args);\n \n   asylo::primitives::Extent request;\n   asylo::primitives::PrimitiveStatus status;\n   status = asylo::system_call::SerializeRequest(sysno, parameters, &request);\n   if (!status.ok()) {\n     error_handler(\n         \"system_call.cc: Encountered serialization error when serializing \"\n         \"syscall parameters.\");\n   }\n \n   std::unique_ptr<uint8_t, MallocDeleter> request_owner(request.As<uint8_t>());\n \n   uint8_t *response_buffer;\n   size_t response_size;\n \n   if (!enc_is_syscall_dispatcher_set()) {\n     error_handler(\"system_.cc: system call dispatcher not set.\");\n   }\n   status = global_syscall_callback(request.As<uint8_t>(), request.size(),\n                                    &response_buffer, &response_size);\n   if (!status.ok()) {\n     error_handler(\n         \"system_call.cc: Callback from syscall dispatcher was unsuccessful.\");\n   }\n \n   std::unique_ptr<uint8_t, MallocDeleter> response_owner(response_buffer);\n \n   if (!response_buffer) {\n     error_handler(\n         \"system_call.cc: null response buffer received for the syscall.\");\n   }\n \n   auto response_reader =\n       asylo::system_call::MessageReader({response_buffer, response_size});\n// bug_start\n// bug_end\n   const asylo::primitives::PrimitiveStatus response_status =\n       response_reader.Validate();\n   if (!response_status.ok()) {\n     error_handler(\n         \"system_call.cc: Error deserializing response buffer into response \"\n         \"reader.\");\n   }\n \n   for (int i = 0; i < asylo::system_call::kParameterMax; i++) {\n     asylo::system_call::ParameterDescriptor parameter = descriptor.parameter(i);\n     if (parameter.is_out()) {\n       size_t size;\n       if (parameter.is_fixed()) {\n         size = parameter.size();\n       } else {\n         size = parameters[parameter.size()] * parameter.element_size();\n       }\n       const void *src = response_reader.parameter_address(i);\n       void *dst = reinterpret_cast<void *>(parameters[i]);\n       if (dst != nullptr) {\n         memcpy(dst, src, size);\n       }\n     }\n   }\n \n   uint64_t result = response_reader.header()->result;\n   if (static_cast<int64_t>(result) == -1) {\n     int klinux_errno = response_reader.header()->error_number;\n \n     if (klinux_errno != 0) {\n       errno = FromkLinuxErrno(klinux_errno);\n     }\n   }\n   return result;\n }\n \n", "target": "// fix_start\n  if (response_reader.sysno() != sysno) {\n    error_handler(\"system_call.cc: Unexpected sysno in response\");\n  }\n// fix_end\n", "cwe": "CWE-125", "cwe_name": "Out-of-bounds Read", "cve": "CVE-2021-22552", "cve_desc": "An untrusted memory read vulnerability in Asylo versions up to 0.6.1 allows an untrusted attacker to pass a syscall number in MessageReader that is then used by sysno() and can bypass validation. This can allow the attacker to read memory from within the secure enclave. We recommend updating to Asylo 0.6.3 or past https://github.com/google/asylo/commit/90d7619e9dd99bcdb6cd28c7649d741d254d9a1a", "project": "asylo", "idx": 196939}
{"source": " parseNormalModeParameters(IsoPresentation* self, uint8_t* buffer, int totalLength, int bufPos)\n {\n     int endPos = bufPos + totalLength;\n \n     self->calledPresentationSelector.size = 0;\n     self->callingPresentationSelector.size = 0;\n \n     bool hasUserData = false;\n \n     while (bufPos < endPos) {\n         uint8_t tag = buffer[bufPos++];\n         int len;\n \n         if (bufPos == endPos) {\n             if (DEBUG_PRES)\n                 printf(\"PRES: invalid message\\n\");\n             return -1;\n         }\n \n         bufPos = BerDecoder_decodeLength(buffer, &len, bufPos, endPos);\n \n         if (bufPos < 0) {\n             if (DEBUG_PRES)\n                 printf(\"PRES: wrong parameter length\\n\");\n             return -1;\n         }\n \n         switch (tag) {\n         case 0x81:\n \n             if (len > 16) {\n                 if (DEBUG_PRES)\n                     printf(\"PRES: calling-presentation-sel too large\\n\");\n             }\n             else {\n                 self->callingPresentationSelector.size = len;\n                 int i;\n                 for (i = 0; i < len; i++)\n                     self->callingPresentationSelector.value[i] = buffer[bufPos + i];\n             }\n \n             bufPos += len;\n             break;\n \n         case 0x82:\n \n             if (len > 16) {\n                 if (DEBUG_PRES)\n                     printf(\"PRES: called-presentation-sel too large\\n\");\n             }\n             else {\n                 self->calledPresentationSelector.size = len;\n                 int i;\n                 for (i = 0; i < len; i++)\n                     self->calledPresentationSelector.value[i] = buffer[bufPos + i];\n             }\n \n             bufPos += len;\n             break;\n \n         case 0x83:\n \n             if (len > 16) {\n                 if (DEBUG_PRES)\n                     printf(\"PRES: responding-presentation-sel too large\\n\");\n             }\n \n             bufPos += len;\n             break;\n \n         case 0xa4:\n             if (DEBUG_PRES)\n                 printf(\"PRES: pcd list\\n\");\n             bufPos = parsePresentationContextDefinitionList(self, buffer, len, bufPos);\n// bug_start\n// bug_end\n             break;\n \n         case 0xa5:\n \n             bufPos += len;\n             break;\n \n         case 0x61:\n             if (DEBUG_PRES)\n                 printf(\"PRES: user-data\\n\");\n \n             bufPos = parseFullyEncodedData(self, buffer, len, bufPos);\n \n             if (bufPos < 0)\n                 return -1;\n \n             if (self->nextPayload.size > 0)\n                 hasUserData = true;\n \n             break;\n \n         case 0x00:\n             break;\n \n         default:\n             if (DEBUG_PRES)\n                 printf(\"PRES: unknown tag in normal-mode\\n\");\n             bufPos += len;\n             break;\n         }\n     }\n \n     if (hasUserData == false) {\n         if (DEBUG_PRES)\n             printf(\"PRES: user-data is missing\\n\");\n \n         return -1;\n     }\n \n     return bufPos;\n }\n \n", "target": "// fix_start\n\n            if (bufPos < 0)\n                return -1;\n\n// fix_end\n", "cwe": "CWE-703", "cwe_name": "Improper Check or Handling of Exceptional Conditions", "cve": "CVE-2022-21159", "cve_desc": "A denial of service vulnerability exists in the parseNormalModeParameters functionality of MZ Automation GmbH libiec61850 1.5.0. A specially-crafted series of network requests can lead to denial of service. An attacker can send a sequence of malformed iec61850 messages to trigger this vulnerability.", "project": "libiec61850", "idx": 196991}
{"source": " #ifndef GPAC_DISABLE_ISOM_HINTING\n \n void dump_isom_sdp(GF_ISOFile *file, char *inName, Bool is_final_name)\n {\n \tconst char *sdp;\n \tu32 size, i;\n \tFILE *dump;\n \n \tif (inName) {\n \t\tchar szBuf[1024];\n \t\tstrcpy(szBuf, inName);\n \t\tif (!is_final_name) {\n \t\t\tchar *ext = strchr(szBuf, '.');\n \t\t\tif (ext) ext[0] = 0;\n \t\t\tstrcat(szBuf, \"_sdp.txt\");\n \t\t}\n \t\tdump = gf_fopen(szBuf, \"wt\");\n \t\tif (!dump) {\n \t\t\tfprintf(stderr, \"Failed to open %s for dumping\\n\", szBuf);\n \t\t\treturn;\n \t\t}\n \t} else {\n \t\tdump = stdout;\n \t\tfprintf(dump, \"* File SDP content *\\n\\n\");\n \t}\n \tgf_isom_sdp_get(file, &sdp, &size);\n// bug_start\n\tfprintf(dump, \"%s\", sdp);\n// bug_end\n \tfprintf(dump, \"\\r\\n\");\n \n \tfor (i=0; i<gf_isom_get_track_count(file); i++) {\n \t\tif (gf_isom_get_media_type(file, i+1) != GF_ISOM_MEDIA_HINT) continue;\n \t\tgf_isom_sdp_track_get(file, i+1, &sdp, &size);\n \t\tfprintf(dump, \"%s\", sdp);\n \t}\n \tfprintf(dump, \"\\n\\n\");\n \n", "target": "// fix_start\n\tif (sdp && size)\n\t\tfprintf(dump, \"%s\", sdp);\n// fix_end\n", "cwe": "CWE-476", "cwe_name": "NULL Pointer Dereference", "cve": "CVE-2020-23932", "cve_desc": "An issue was discovered in gpac before 1.0.1. A NULL pointer dereference exists in the function dump_isom_sdp located in filedump.c. It allows an attacker to cause Denial of Service.", "project": "gpac", "idx": 196997}
{"source": "   void Compute(OpKernelContext* ctx) override {\n     const Tensor& shape_tensor = ctx->input(0);\n     const Tensor& means_tensor = ctx->input(1);\n     const Tensor& stddevs_tensor = ctx->input(2);\n     const Tensor& minvals_tensor = ctx->input(3);\n     const Tensor& maxvals_tensor = ctx->input(4);\n \n     OP_REQUIRES(\n         ctx, TensorShapeUtils::IsVector(shape_tensor.shape()),\n         errors::InvalidArgument(\"Input shape should be a vector, got shape: \",\n                                 shape_tensor.shape().DebugString()));\n// bug_start\n// bug_end\n     int32 num_batches = shape_tensor.flat<int32>()(0);\n \n     int32 samples_per_batch = 1;\n     const int32 num_dims = shape_tensor.dim_size(0);\n     for (int32 i = 1; i < num_dims; i++) {\n       samples_per_batch *= shape_tensor.flat<int32>()(i);\n     }\n     const int32 num_elements = num_batches * samples_per_batch;\n \n     auto shape_vec = shape_tensor.flat<int32>();\n     TensorShape tensor_shape;\n     OP_REQUIRES_OK(ctx, TensorShapeUtils::MakeShape(\n                             shape_vec.data(), shape_vec.size(), &tensor_shape));\n     Tensor* samples_tensor;\n     OP_REQUIRES_OK(ctx, ctx->allocate_output(0, tensor_shape, &samples_tensor));\n \n     OP_REQUIRES(ctx, means_tensor.dims() <= 1,\n                 errors::InvalidArgument(\n                     \"Input means should be a scalar or vector, got shape: \",\n                     means_tensor.shape().DebugString()));\n     OP_REQUIRES(ctx, stddevs_tensor.dims() <= 1,\n                 errors::InvalidArgument(\n                     \"Input stddevs should be a scalar or vector, got shape: \",\n                     stddevs_tensor.shape().DebugString()));\n     OP_REQUIRES(ctx, minvals_tensor.dims() <= 1,\n                 errors::InvalidArgument(\n                     \"Input minvals should be a scalar or vector, got shape: \",\n                     minvals_tensor.shape().DebugString()));\n     OP_REQUIRES(ctx, maxvals_tensor.dims() <= 1,\n                 errors::InvalidArgument(\n                     \"Input maxvals should be a scalar or vector, got shape: \",\n                     maxvals_tensor.shape().DebugString()));\n \n     if ((means_tensor.dims() == 0 || means_tensor.dim_size(0) == 1) &&\n         (stddevs_tensor.dims() == 0 || stddevs_tensor.dim_size(0) == 1) &&\n         minvals_tensor.dims() == 0 && maxvals_tensor.dims() == 0) {\n       int32 size = num_batches * samples_per_batch;\n       int32 adjusted_samples = kDesiredBatchSize;\n       int32 adjusted_batches = Eigen::divup(size, adjusted_samples);\n       num_batches = adjusted_batches;\n       samples_per_batch = adjusted_samples;\n     } else {\n       OP_REQUIRES(\n           ctx,\n           TensorShapeUtils::IsScalar(means_tensor.shape()) ||\n               means_tensor.dim_size(0) == 1 ||\n               means_tensor.dim_size(0) == num_batches,\n           errors::InvalidArgument(\n               \"Input means should have length 1 or shape[0], got shape: \",\n               means_tensor.shape().DebugString()));\n       OP_REQUIRES(\n           ctx,\n           TensorShapeUtils::IsScalar(stddevs_tensor.shape()) ||\n               stddevs_tensor.dim_size(0) == 1 ||\n               stddevs_tensor.dim_size(0) == num_batches,\n           errors::InvalidArgument(\n               \"Input stddevs should have length 1 or shape[0], got shape: \",\n               stddevs_tensor.shape().DebugString()));\n       OP_REQUIRES(\n           ctx,\n           TensorShapeUtils::IsScalar(minvals_tensor.shape()) ||\n               minvals_tensor.dim_size(0) == 1 ||\n               minvals_tensor.dim_size(0) == num_batches,\n           errors::InvalidArgument(\n               \"Input minvals should have length 1 or shape[0], got shape: \",\n               minvals_tensor.shape().DebugString()));\n       OP_REQUIRES(\n           ctx,\n           TensorShapeUtils::IsScalar(maxvals_tensor.shape()) ||\n               maxvals_tensor.dim_size(0) == 1 ||\n               maxvals_tensor.dim_size(0) == num_batches,\n           errors::InvalidArgument(\n               \"Input maxvals should have length 1 or shape[0], got shape: \",\n               maxvals_tensor.shape().DebugString()));\n     }\n \n     auto truncFunctor = functor::TruncatedNormalFunctor<Device, T>();\n     random::PhiloxRandom rng =\n         generator_.ReserveSamples128(num_batches * 2 * functor::kMaxIterations *\n                                      (samples_per_batch + 3) / 4);\n     truncFunctor(ctx, ctx->eigen_device<Device>(), num_batches,\n                  samples_per_batch, num_elements, means_tensor.flat<T>(),\n                  stddevs_tensor.flat<T>(), minvals_tensor.flat<T>(),\n                  maxvals_tensor.flat<T>(), rng, samples_tensor->flat<T>());\n   }\n \n", "target": "// fix_start\n    OP_REQUIRES(ctx, shape_tensor.NumElements() > 0,\n                errors::InvalidArgument(\"Shape tensor must not be empty, got \",\n                                        shape_tensor.DebugString()));\n// fix_end\n", "cwe": "CWE-125", "cwe_name": "Out-of-bounds Read", "cve": "CVE-2021-29568", "cve_desc": "TensorFlow is an end-to-end open source platform for machine learning. An attacker can trigger undefined behavior by binding to null pointer in `tf.raw_ops.ParameterizedTruncatedNormal`. This is because the implementation(https://github.com/tensorflow/tensorflow/blob/3f6fe4dfef6f57e768260b48166c27d148f3015f/tensorflow/core/kernels/parameterized_truncated_normal_op.cc#L630) does not validate input arguments before accessing the first element of `shape`. If `shape` argument is empty, then `shape_tensor.flat<T>()` is an empty array. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.", "project": "tensorflow", "idx": 197084}
{"source": " static bool checkreturn decode_pointer_field(pb_istream_t *stream, pb_wire_type_t wire_type, pb_field_iter_t *iter)\n {\n #ifndef PB_ENABLE_MALLOC\n     PB_UNUSED(wire_type);\n     PB_UNUSED(iter);\n     PB_RETURN_ERROR(stream, \"no malloc support\");\n #else\n     pb_type_t type;\n     pb_decoder_t func;\n \n     type = iter->pos->type;\n     func = PB_DECODERS[PB_LTYPE(type)];\n \n     switch (PB_HTYPE(type))\n     {\n         case PB_HTYPE_REQUIRED:\n         case PB_HTYPE_OPTIONAL:\n         case PB_HTYPE_ONEOF:\n             if (PB_LTYPE(type) == PB_LTYPE_SUBMESSAGE &&\n                 *(void**)iter->pData != NULL)\n             {\n                 pb_release_single_field(iter);\n             }\n \n             if (PB_HTYPE(type) == PB_HTYPE_ONEOF)\n             {\n                 *(pb_size_t*)iter->pSize = iter->pos->tag;\n             }\n \n             if (PB_LTYPE(type) == PB_LTYPE_STRING ||\n                 PB_LTYPE(type) == PB_LTYPE_BYTES)\n             {\n                 return func(stream, iter->pos, iter->pData);\n             }\n             else\n             {\n                 if (!allocate_field(stream, iter->pData, iter->pos->data_size, 1))\n                     return false;\n \n                 initialize_pointer_field(*(void**)iter->pData, iter);\n                 return func(stream, iter->pos, *(void**)iter->pData);\n             }\n \n         case PB_HTYPE_REPEATED:\n             if (wire_type == PB_WT_STRING\n                 && PB_LTYPE(type) <= PB_LTYPE_LAST_PACKABLE)\n             {\n                 bool status = true;\n                 pb_size_t *size = (pb_size_t*)iter->pSize;\n                 size_t allocated_size = *size;\n                 void *pItem;\n                 pb_istream_t substream;\n \n                 if (!pb_make_string_substream(stream, &substream))\n                     return false;\n \n                 while (substream.bytes_left)\n                 {\n                     if ((size_t)*size + 1 > allocated_size)\n                     {\n                         allocated_size += (substream.bytes_left - 1) / iter->pos->data_size + 1;\n \n                         if (!allocate_field(&substream, iter->pData, iter->pos->data_size, allocated_size))\n                         {\n                             status = false;\n                             break;\n                         }\n                     }\n \n                     pItem = *(char**)iter->pData + iter->pos->data_size * (*size);\n                     initialize_pointer_field(pItem, iter);\n                     if (!func(&substream, iter->pos, pItem))\n                     {\n                         status = false;\n                         break;\n                     }\n \n                     if (*size == PB_SIZE_MAX)\n                     {\n #ifndef PB_NO_ERRMSG\n                         stream->errmsg = \"too many array entries\";\n #endif\n                         status = false;\n                         break;\n                     }\n \n                     (*size)++;\n                 }\n                 if (!pb_close_string_substream(stream, &substream))\n                     return false;\n \n                 return status;\n             }\n             else\n             {\n                 pb_size_t *size = (pb_size_t*)iter->pSize;\n                 void *pItem;\n \n                 if (*size == PB_SIZE_MAX)\n                     PB_RETURN_ERROR(stream, \"too many array entries\");\n \n// bug_start\n                (*size)++;\n                if (!allocate_field(stream, iter->pData, iter->pos->data_size, *size))\n// bug_end\n                     return false;\n \n// bug_start\n                pItem = *(char**)iter->pData + iter->pos->data_size * (*size - 1);\n// bug_end\n                 initialize_pointer_field(pItem, iter);\n                 return func(stream, iter->pos, pItem);\n             }\n \n         default:\n             PB_RETURN_ERROR(stream, \"invalid field type\");\n     }\n #endif\n }\n \n", "target": "// fix_start\n                if (!allocate_field(stream, iter->pData, iter->pos->data_size, (size_t)(*size + 1)))\n// fix_end\n// fix_start\n                pItem = *(char**)iter->pData + iter->pos->data_size * (*size);\n                (*size)++;\n// fix_end\n", "cwe": "CWE-125", "cwe_name": "Out-of-bounds Read", "cve": "CVE-2020-5235", "cve_desc": "There is a potentially exploitable out of memory condition In Nanopb before 0.4.1, 0.3.9.5, and 0.2.9.4. When nanopb is compiled with PB_ENABLE_MALLOC, the message to be decoded contains a repeated string, bytes or message field and realloc() runs out of memory when expanding the array nanopb can end up calling `free()` on a pointer value that comes from uninitialized memory. Depending on platform this can result in a crash or further memory corruption, which may be exploitable in some cases. This problem is fixed in nanopb-0.4.1, nanopb-0.3.9.5, nanopb-0.2.9.4.", "project": "nanopb", "idx": 197114}
{"source": "   void Compute(OpKernelContext* context) override {\n     typedef Eigen::Map<const Eigen::Matrix<T, Eigen::Dynamic, Eigen::Dynamic>>\n         ConstEigenMatrixMap;\n     typedef Eigen::Map<Eigen::Matrix<double, Eigen::Dynamic, Eigen::Dynamic>>\n         EigenDoubleMatrixMap;\n \n     const Tensor& orig_input_tensor_shape = context->input(0);\n     OP_REQUIRES(context,\n                 orig_input_tensor_shape.dims() == 1 &&\n                     orig_input_tensor_shape.NumElements() == 4,\n                 errors::InvalidArgument(\"original input tensor shape must be\"\n                                         \"1-dimensional and 4 elements\"));\n     const Tensor& out_backprop = context->input(1);\n     const Tensor& row_seq_tensor = context->input(2);\n     const Tensor& col_seq_tensor = context->input(3);\n \n     const int64 out_batch = out_backprop.dim_size(0);\n     const int64 out_rows = out_backprop.dim_size(1);\n     const int64 out_cols = out_backprop.dim_size(2);\n     const int64 out_depth = out_backprop.dim_size(3);\n// bug_start\n// bug_end\n \n     auto row_seq_tensor_flat = row_seq_tensor.flat<int64>();\n     auto col_seq_tensor_flat = col_seq_tensor.flat<int64>();\n     auto orig_input_tensor_shape_flat = orig_input_tensor_shape.flat<int64>();\n \n     const int64 in_batch = orig_input_tensor_shape_flat(0);\n     const int64 in_rows = orig_input_tensor_shape_flat(1);\n     const int64 in_cols = orig_input_tensor_shape_flat(2);\n     const int64 in_depth = orig_input_tensor_shape_flat(3);\n \n     constexpr int tensor_in_and_out_dims = 4;\n     TensorShape in_shape;\n     for (auto i = 0; i < tensor_in_and_out_dims; ++i) {\n       in_shape.AddDim(orig_input_tensor_shape_flat(i));\n     }\n \n     Tensor in_backprop_tensor_temp;\n     OP_REQUIRES_OK(context, context->forward_input_or_allocate_temp(\n                                 {0}, DataTypeToEnum<double>::v(), in_shape,\n                                 &in_backprop_tensor_temp));\n     in_backprop_tensor_temp.flat<double>().setZero();\n     EigenDoubleMatrixMap in_backprop_tensor_temp_mat(\n         in_backprop_tensor_temp.flat<double>().data(), in_depth,\n         in_cols * in_rows * in_batch);\n     ConstEigenMatrixMap out_backprop_mat(out_backprop.flat<T>().data(),\n                                          out_depth,\n                                          out_cols * out_rows * out_batch);\n     const int64 in_max_row_index = in_rows - 1;\n     const int64 in_max_col_index = in_cols - 1;\n     for (int64 b = 0; b < out_batch; ++b) {\n       for (int64 r = 0; r < out_rows; ++r) {\n         const int64 in_row_start = row_seq_tensor_flat(r);\n         int64 in_row_end = overlapping_ ? row_seq_tensor_flat(r + 1)\n                                         : row_seq_tensor_flat(r + 1) - 1;\n         in_row_end = std::min(in_row_end, in_max_row_index);\n         for (int64 c = 0; c < out_cols; ++c) {\n           const int64 in_col_start = col_seq_tensor_flat(c);\n           int64 in_col_end = overlapping_ ? col_seq_tensor_flat(c + 1)\n                                           : col_seq_tensor_flat(c + 1) - 1;\n           in_col_end = std::min(in_col_end, in_max_col_index);\n \n           const int64 num_elements_in_pooling_cell =\n               (in_row_end - in_row_start + 1) * (in_col_end - in_col_start + 1);\n           const int64 out_index = (b * out_rows + r) * out_cols + c;\n           for (int64 in_r = in_row_start; in_r <= in_row_end; ++in_r) {\n             for (int64 in_c = in_col_start; in_c <= in_col_end; ++in_c) {\n               const int64 in_index = (b * in_rows + in_r) * in_cols + in_c;\n               for (int64 d = 0; d < out_depth; ++d) {\n                 const double out_backprop_element = static_cast<double>(\n                     out_backprop_mat.coeffRef(d, out_index));\n                 double& in_backprop_ref =\n                     in_backprop_tensor_temp_mat.coeffRef(d, in_index);\n                 in_backprop_ref +=\n                     out_backprop_element / num_elements_in_pooling_cell;\n               }\n             }\n           }\n         }\n       }\n     }\n \n     Tensor* in_backprop_tensor = nullptr;\n     OP_REQUIRES_OK(context, context->forward_input_or_allocate_output(\n                                 {0}, 0, in_shape, &in_backprop_tensor));\n     auto in_backprop_tensor_flat = in_backprop_tensor->flat<T>();\n     auto in_backprop_tensor_temp_flat = in_backprop_tensor_temp.flat<double>();\n     for (int64 i = 0; i < in_backprop_tensor_flat.size(); ++i) {\n       in_backprop_tensor_flat(i) =\n           static_cast<T>(in_backprop_tensor_temp_flat(i));\n     }\n   }\n \n", "target": "// fix_start\n\n    OP_REQUIRES(context, row_seq_tensor.NumElements() > out_rows,\n                errors::InvalidArgument(\"Given out_backprop shape \",\n                                        out_backprop.shape().DebugString(),\n                                        \", row_seq_tensor must have at least \",\n                                        out_rows + 1, \" elements, but got \",\n                                        row_seq_tensor.NumElements()));\n    OP_REQUIRES(context, col_seq_tensor.NumElements() > out_cols,\n                errors::InvalidArgument(\"Given out_backprop shape \",\n                                        out_backprop.shape().DebugString(),\n                                        \", col_seq_tensor must have at least \",\n                                        out_cols + 1, \" elements, but got \",\n                                        col_seq_tensor.NumElements()));\n// fix_end\n", "cwe": "CWE-369", "cwe_name": "Divide By Zero", "cve": "CVE-2021-29578", "cve_desc": "TensorFlow is an end-to-end open source platform for machine learning. The implementation of `tf.raw_ops.FractionalAvgPoolGrad` is vulnerable to a heap buffer overflow. The implementation(https://github.com/tensorflow/tensorflow/blob/dcba796a28364d6d7f003f6fe733d82726dda713/tensorflow/core/kernels/fractional_avg_pool_op.cc#L216) fails to validate that the pooling sequence arguments have enough elements as required by the `out_backprop` tensor shape. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.", "project": "tensorflow", "idx": 197133}
{"source": " static bool pb_release_union_field(pb_istream_t *stream, pb_field_iter_t *field)\n {\n     pb_field_iter_t old_field = *field;\n     pb_size_t old_tag = *(pb_size_t*)field->pSize;\n     pb_size_t new_tag = field->tag;\n \n     if (old_tag == 0)\n         return true;\n \n     if (old_tag == new_tag)\n         return true;\n \n     if (!pb_field_iter_find(&old_field, old_tag))\n         PB_RETURN_ERROR(stream, \"invalid union tag\");\n \n     pb_release_single_field(&old_field);\n \n// bug_start\n// bug_end\n     return true;\n }\n \n", "target": "// fix_start\n    if (PB_ATYPE(field->type) == PB_ATYPE_POINTER)\n    {\n        *(void**)field->pField = NULL;\n        field->pData = NULL;\n    }\n\n// fix_end\n", "cwe": "CWE-763", "cwe_name": "Release of Invalid Pointer or Reference", "cve": "CVE-2021-21401", "cve_desc": "Nanopb is a small code-size Protocol Buffers implementation in ansi C. In Nanopb before versions 0.3.9.8 and 0.4.5, decoding a specifically formed message can cause invalid `free()` or `realloc()` calls if the message type contains an `oneof` field, and the `oneof` directly contains both a pointer field and a non-pointer field. If the message data first contains the non-pointer field and then the pointer field, the data of the non-pointer field is incorrectly treated as if it was a pointer value. Such message data rarely occurs in normal messages, but it is a concern when untrusted data is parsed. This has been fixed in versions 0.3.9.8 and 0.4.5. See referenced GitHub Security Advisory for more information including workarounds.", "project": "nanopb", "idx": 197172}
{"source": " void ndpi_search_h323(struct ndpi_detection_module_struct *ndpi_struct, struct ndpi_flow_struct *flow)\n {\n   struct ndpi_packet_struct *packet = &flow->packet;\n   u_int16_t dport = 0, sport = 0;\n \n   NDPI_LOG_DBG(ndpi_struct, \"search H323\\n\");\n \n   if((packet->tcp != NULL) && (packet->tcp->dest != ntohs(102))) {\n     NDPI_LOG_DBG2(ndpi_struct, \"calculated dport over tcp\\n\");\n \n     if(packet->payload_packet_len >= 4\n        && (packet->payload[0] == 0x03)\n        && (packet->payload[1] == 0x00)) {\n// bug_start\n\tstruct tpkt *t = (struct tpkt*)packet->payload;\n\tu_int16_t len = ntohs(t->len);\n// bug_end\n \n// bug_start\n\tif(packet->payload_packet_len == len) {\n// bug_end\n \n// bug_start\n\t  if(packet->payload[4] == (packet->payload_packet_len - sizeof(struct tpkt) - 1)) {\n\t    if((packet->payload[5] == 0xE0 )\n\t       || (packet->payload[5] == 0xD0 )) {\n\t      NDPI_LOG_INFO(ndpi_struct, \"found RDP\\n\");\n\t      ndpi_set_detected_protocol(ndpi_struct, flow, NDPI_PROTOCOL_RDP, NDPI_PROTOCOL_UNKNOWN);\n\t      return;\n\t    }\n// bug_end\n \t  }\n// bug_start\n// bug_end\n \n// bug_start\n\t  flow->l4.tcp.h323_valid_packets++;\n// bug_end\n \n// bug_start\n\t  if(flow->l4.tcp.h323_valid_packets >= 2) {\n\t    NDPI_LOG_INFO(ndpi_struct, \"found H323 broadcast\\n\");\n\t    ndpi_set_detected_protocol(ndpi_struct, flow, NDPI_PROTOCOL_H323, NDPI_PROTOCOL_UNKNOWN);\n\t  }\n\t} else {\n\t  NDPI_EXCLUDE_PROTO(ndpi_struct, flow);\n\t  return;\n// bug_end\n \t}\n// bug_start\n// bug_end\n       }\n// bug_start\n// bug_end\n   } else if(packet->udp != NULL) {\n     sport = ntohs(packet->udp->source), dport = ntohs(packet->udp->dest);\n     NDPI_LOG_DBG2(ndpi_struct, \"calculated dport over udp\\n\");\n \n     if(packet->payload_packet_len >= 6 && packet->payload[0] == 0x80 && packet->payload[1] == 0x08 &&\n        (packet->payload[2] == 0xe7 || packet->payload[2] == 0x26) &&\n        packet->payload[4] == 0x00 && packet->payload[5] == 0x00)\n       {\n \tNDPI_LOG_INFO(ndpi_struct, \"found H323 broadcast\\n\");\n \tndpi_set_detected_protocol(ndpi_struct, flow, NDPI_PROTOCOL_H323, NDPI_PROTOCOL_UNKNOWN);\n \treturn;\n       }\n// bug_start\n    if(sport == 1719 || dport == 1719)\n      {\n        if(packet->payload[0] == 0x16 && packet->payload[1] == 0x80 && packet->payload[4] == 0x06 && packet->payload[5] == 0x00)\n\t  {\n\t    NDPI_LOG_INFO(ndpi_struct, \"found H323 broadcast\\n\");\n\t    ndpi_set_detected_protocol(ndpi_struct, flow, NDPI_PROTOCOL_H323, NDPI_PROTOCOL_UNKNOWN);\n\t    return;\n\t  }\n        else if(packet->payload_packet_len >= 20 && packet->payload_packet_len <= 117)\n\t  {\n\t    NDPI_LOG_INFO(ndpi_struct, \"found H323 broadcast\\n\");\n\t    ndpi_set_detected_protocol(ndpi_struct, flow, NDPI_PROTOCOL_H323, NDPI_PROTOCOL_UNKNOWN);\n\t    return;\n\t  }\n        else\n\t  {\n\t    NDPI_EXCLUDE_PROTO(ndpi_struct, flow);\n\t    return;\n\t  }\n// bug_end\n       }\n// bug_start\n// bug_end\n   }\n// bug_start\n\n// bug_end\n }\n \n", "target": "// fix_start\n      struct tpkt *t = (struct tpkt*)packet->payload;\n      u_int16_t len = ntohs(t->len);\n// fix_end\n// fix_start\n      if(packet->payload_packet_len == len) {\n// fix_end\n// fix_start\n\tif(packet->payload[4] == (packet->payload_packet_len - sizeof(struct tpkt) - 1)) {\n\t  if((packet->payload[5] == 0xE0 )\n\t     || (packet->payload[5] == 0xD0 )) {\n\t    NDPI_LOG_INFO(ndpi_struct, \"found RDP\\n\");\n\t    ndpi_set_detected_protocol(ndpi_struct, flow, NDPI_PROTOCOL_RDP, NDPI_PROTOCOL_UNKNOWN);\n\t    return;\n// fix_end\n// fix_start\n\t}\n// fix_end\n// fix_start\n\tflow->l4.tcp.h323_valid_packets++;\n// fix_end\n// fix_start\n\tif(flow->l4.tcp.h323_valid_packets >= 2) {\n\t  NDPI_LOG_INFO(ndpi_struct, \"found H323 broadcast\\n\");\n\t  ndpi_set_detected_protocol(ndpi_struct, flow, NDPI_PROTOCOL_H323, NDPI_PROTOCOL_UNKNOWN);\n// fix_end\n// fix_start\n      } else {\n\tNDPI_EXCLUDE_PROTO(ndpi_struct, flow);\n\treturn;\n// fix_end\n// fix_start\n    }\n// fix_end\n// fix_start\n    if(sport == 1719 || dport == 1719) {\n      if((packet->payload_packet_len >= 5)\n\t && (packet->payload[0] == 0x16)\n\t && (packet->payload[1] == 0x80)\n\t && (packet->payload[4] == 0x06)\n\t && (packet->payload[5] == 0x00)) {\n\tNDPI_LOG_INFO(ndpi_struct, \"found H323 broadcast\\n\");\n\tndpi_set_detected_protocol(ndpi_struct, flow, NDPI_PROTOCOL_H323, NDPI_PROTOCOL_UNKNOWN);\n\treturn;\n      } else if(packet->payload_packet_len >= 20 && packet->payload_packet_len <= 117) {\n\tNDPI_LOG_INFO(ndpi_struct, \"found H323 broadcast\\n\");\n\tndpi_set_detected_protocol(ndpi_struct, flow, NDPI_PROTOCOL_H323, NDPI_PROTOCOL_UNKNOWN);\n\treturn;\n      } else {\n\tNDPI_EXCLUDE_PROTO(ndpi_struct, flow);\n\treturn;\n// fix_end\n// fix_start\n    }\n// fix_end\n// fix_start\n// fix_end\n", "cwe": "CWE-125", "cwe_name": "Out-of-bounds Read", "cve": "CVE-2020-15472", "cve_desc": "In nDPI through 3.2, the H.323 dissector is vulnerable to a heap-based buffer over-read in ndpi_search_h323 in lib/protocols/h323.c, as demonstrated by a payload packet length that is too short.", "project": "nDPI", "idx": 197178}
{"source": " Status ConvBackpropComputeDimensionsV2(\n     StringPiece label, int num_spatial_dims, const TensorShape& input_shape,\n     const TensorShape& filter_shape, const TensorShape& out_backprop_shape,\n     const gtl::ArraySlice<int32>& dilations, const std::vector<int32>& strides,\n     Padding padding, absl::Span<const int64> explicit_paddings,\n     TensorFormat data_format, ConvBackpropDimensions* dims) {\n   const int num_dims = num_spatial_dims + 2;\n   if (input_shape.dims() != num_dims) {\n     return errors::InvalidArgument(label, \": input must be \", num_dims,\n                                    \"-dimensional\");\n   }\n   if (filter_shape.dims() != num_dims) {\n     return errors::InvalidArgument(label, \": filter must be \", num_dims,\n                                    \"-dimensional\");\n   }\n   if (out_backprop_shape.dims() != num_dims) {\n     return errors::InvalidArgument(label, \": out_backprop must be \", num_dims,\n                                    \"-dimensional\");\n   }\n   int batch_dim = GetTensorBatchDimIndex(num_dims, data_format);\n   dims->batch_size = input_shape.dim_size(batch_dim);\n   if (dims->batch_size != out_backprop_shape.dim_size(batch_dim)) {\n     return errors::InvalidArgument(\n         label, \": input and out_backprop must have the same batch size.\",\n         \" Input batch: \", dims->batch_size,\n         \", outbackprop batch: \", out_backprop_shape.dim_size(batch_dim),\n         \", batch_dim: \", batch_dim);\n   }\n \n   int feature_dim = GetTensorFeatureDimIndex(num_dims, data_format);\n   dims->in_depth = input_shape.dim_size(feature_dim);\n   VLOG(2) << \"input vs filter_in depth \" << dims->in_depth << \" \"\n           << filter_shape.dim_size(num_dims - 2);\n// bug_start\n// bug_end\n   if (dims->in_depth % filter_shape.dim_size(num_dims - 2)) {\n     return errors::InvalidArgument(\n         label, \": input depth must be evenly divisible by filter depth\");\n   }\n   dims->out_depth = filter_shape.dim_size(num_dims - 1);\n   if (dims->out_depth != out_backprop_shape.dim_size(feature_dim)) {\n     return errors::InvalidArgument(\n         label, \": filter and out_backprop must have the same out_depth\");\n   }\n   dims->spatial_dims.resize(num_spatial_dims);\n   for (int i = 0; i < num_spatial_dims; ++i) {\n     int image_dim = GetTensorSpatialDimIndex(num_dims, data_format, i);\n     int64 padding_before = -1, padding_after = -1;\n     if (padding == EXPLICIT) {\n       padding_before = explicit_paddings[2 * image_dim];\n       padding_after = explicit_paddings[2 * image_dim + 1];\n     }\n     TF_RETURN_IF_ERROR(ConvBackpropExtractAndVerifyDimension(\n         label, input_shape, filter_shape, out_backprop_shape, dilations,\n         strides, padding, padding_before, padding_after, image_dim, i,\n         &dims->spatial_dims[i]));\n   }\n   return Status::OK();\n }\n \n", "target": "// fix_start\n  if (filter_shape.dim_size(num_dims - 2) <= 0) {\n    return errors ::InvalidArgument(\n        label, \": filter depth must be strictly greated than zero\");\n  }\n// fix_end\n", "cwe": "CWE-369", "cwe_name": "Divide By Zero", "cve": "CVE-2021-29524", "cve_desc": "TensorFlow is an end-to-end open source platform for machine learning. An attacker can trigger a division by 0 in `tf.raw_ops.Conv2DBackpropFilter`. This is because the implementation(https://github.com/tensorflow/tensorflow/blob/496c2630e51c1a478f095b084329acedb253db6b/tensorflow/core/kernels/conv_grad_shape_utils.cc#L130) does a modulus operation where the divisor is controlled by the caller. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.", "project": "tensorflow", "idx": 197183}
{"source": " std::vector<GetLengthType> CSoundFile::GetLength(enmGetLengthResetMode adjustMode, GetLengthTarget target)\n {\n \tstd::vector<GetLengthType> results;\n \tGetLengthType retval;\n \tretval.startOrder = target.startOrder;\n \tretval.startRow = target.startRow;\n \n \tconst bool hasSearchTarget = target.mode != GetLengthTarget::NoTarget;\n \tconst bool adjustSamplePos = (adjustMode & eAdjustSamplePositions) == eAdjustSamplePositions;\n \n \tSEQUENCEINDEX sequence = target.sequence;\n \tif(sequence >= Order.GetNumSequences()) sequence = Order.GetCurrentSequenceIndex();\n \tconst ModSequence &orderList = Order(sequence);\n \n \tGetLengthMemory memory(*this);\n \tCSoundFile::PlayState &playState = *memory.state;\n \tRowVisitor visitedRows(*this, sequence);\n \n \tplayState.m_nNextRow = playState.m_nRow = target.startRow;\n \tplayState.m_nNextOrder = playState.m_nCurrentOrder = target.startOrder;\n \n \tstd::bitset<MAX_EFFECTS> forbiddenCommands;\n \tstd::bitset<MAX_VOLCMDS> forbiddenVolCommands;\n \n \tif(adjustSamplePos)\n \t{\n \t\tforbiddenCommands.set(CMD_ARPEGGIO);             forbiddenCommands.set(CMD_PORTAMENTOUP);\n \t\tforbiddenCommands.set(CMD_PORTAMENTODOWN);       forbiddenCommands.set(CMD_XFINEPORTAUPDOWN);\n \t\tforbiddenCommands.set(CMD_NOTESLIDEUP);          forbiddenCommands.set(CMD_NOTESLIDEUPRETRIG);\n \t\tforbiddenCommands.set(CMD_NOTESLIDEDOWN);        forbiddenCommands.set(CMD_NOTESLIDEDOWNRETRIG);\n \t\tforbiddenVolCommands.set(VOLCMD_PORTAUP);        forbiddenVolCommands.set(VOLCMD_PORTADOWN);\n \n \t\tfor(CHANNELINDEX i = 0; i < GetNumChannels(); i++)\n \t\t{\n \t\t\tif(ChnSettings[i].dwFlags[CHN_MUTE]) memory.chnSettings[i].ticksToRender = GetLengthMemory::IGNORE_CHANNEL;\n \t\t}\n \t\tif(target.mode == GetLengthTarget::SeekPosition && target.pos.order < orderList.size())\n \t\t{\n \t\t\tconst PATTERNINDEX seekPat = orderList[target.pos.order];\n \t\t\tif(Patterns.IsValidPat(seekPat) && Patterns[seekPat].IsValidRow(target.pos.row))\n \t\t\t{\n \t\t\t\tconst ModCommand *m = Patterns[seekPat].GetRow(target.pos.row);\n \t\t\t\tfor(CHANNELINDEX i = 0; i < GetNumChannels(); i++, m++)\n \t\t\t\t{\n \t\t\t\t\tif(m->note == NOTE_NOTECUT || m->note == NOTE_KEYOFF || (m->note == NOTE_FADE && GetNumInstruments())\n \t\t\t\t\t\t|| (m->IsNote() && !m->IsPortamento()))\n \t\t\t\t\t{\n \t\t\t\t\t\tmemory.chnSettings[i].ticksToRender = GetLengthMemory::IGNORE_CHANNEL;\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \t}\n \n \tuint32 oldTickDuration = 0;\n \n \tfor (;;)\n \t{\n \t\tif(target.mode == GetLengthTarget::SeekSeconds && memory.elapsedTime >= target.time)\n \t\t{\n \t\t\tretval.targetReached = true;\n \t\t\tbreak;\n \t\t}\n \n \t\tuint32 rowDelay = 0, tickDelay = 0;\n \t\tplayState.m_nRow = playState.m_nNextRow;\n \t\tplayState.m_nCurrentOrder = playState.m_nNextOrder;\n \n \t\tif(orderList.IsValidPat(playState.m_nCurrentOrder) && playState.m_nRow >= Patterns[orderList[playState.m_nCurrentOrder]].GetNumRows())\n \t\t{\n \t\t\tplayState.m_nRow = 0;\n \t\t\tif(m_playBehaviour[kFT2LoopE60Restart])\n \t\t\t{\n \t\t\t\tplayState.m_nRow = playState.m_nNextPatStartRow;\n \t\t\t\tplayState.m_nNextPatStartRow = 0;\n \t\t\t}\n \t\t\tplayState.m_nCurrentOrder = ++playState.m_nNextOrder;\n \t\t}\n \n \t\tplayState.m_nPattern = playState.m_nCurrentOrder < orderList.size() ? orderList[playState.m_nCurrentOrder] : orderList.GetInvalidPatIndex();\n \t\tbool positionJumpOnThisRow = false;\n \t\tbool patternBreakOnThisRow = false;\n \t\tbool patternLoopEndedOnThisRow = false, patternLoopStartedOnThisRow = false;\n \n \t\tif(!Patterns.IsValidPat(playState.m_nPattern) && playState.m_nPattern != orderList.GetInvalidPatIndex() && target.mode == GetLengthTarget::SeekPosition && playState.m_nCurrentOrder == target.pos.order)\n \t\t{\n \t\t\tretval.targetReached = true;\n \t\t\tbreak;\n \t\t}\n \n \t\twhile(playState.m_nPattern >= Patterns.Size())\n \t\t{\n \t\t\tif((playState.m_nPattern == orderList.GetInvalidPatIndex()) || (playState.m_nCurrentOrder >= orderList.size()))\n \t\t\t{\n \t\t\t\tif(playState.m_nCurrentOrder == orderList.GetRestartPos())\n \t\t\t\t\tbreak;\n \t\t\t\telse\n \t\t\t\t\tplayState.m_nCurrentOrder = orderList.GetRestartPos();\n \t\t\t} else\n \t\t\t{\n \t\t\t\tplayState.m_nCurrentOrder++;\n \t\t\t}\n \t\t\tplayState.m_nPattern = (playState.m_nCurrentOrder < orderList.size()) ? orderList[playState.m_nCurrentOrder] : orderList.GetInvalidPatIndex();\n \t\t\tplayState.m_nNextOrder = playState.m_nCurrentOrder;\n \t\t\tif((!Patterns.IsValidPat(playState.m_nPattern)) && visitedRows.IsVisited(playState.m_nCurrentOrder, 0, true))\n \t\t\t{\n \t\t\t\tif(!hasSearchTarget || !visitedRows.GetFirstUnvisitedRow(playState.m_nNextOrder, playState.m_nRow, true))\n \t\t\t\t{\n \t\t\t\t\tbreak;\n \t\t\t\t} else\n \t\t\t\t{\n \t\t\t\t\tretval.duration = memory.elapsedTime;\n \t\t\t\t\tresults.push_back(retval);\n \t\t\t\t\tretval.startRow = playState.m_nRow;\n \t\t\t\t\tretval.startOrder = playState.m_nNextOrder;\n \t\t\t\t\tmemory.Reset();\n \n \t\t\t\t\tplayState.m_nCurrentOrder = playState.m_nNextOrder;\n \t\t\t\t\tplayState.m_nPattern = orderList[playState.m_nCurrentOrder];\n \t\t\t\t\tplayState.m_nNextRow = playState.m_nRow;\n \t\t\t\t\tbreak;\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \t\tif(playState.m_nNextOrder == ORDERINDEX_INVALID)\n \t\t{\n \t\t\tbreak;\n \t\t}\n \n \t\tif(!Patterns.IsValidPat(playState.m_nPattern))\n \t\t{\n \t\t\tif(playState.m_nCurrentOrder == orderList.GetRestartPos())\n \t\t\t{\n \t\t\t\tif(!hasSearchTarget || !visitedRows.GetFirstUnvisitedRow(playState.m_nNextOrder, playState.m_nRow, true))\n \t\t\t\t{\n \t\t\t\t\tbreak;\n \t\t\t\t} else\n \t\t\t\t{\n \t\t\t\t\tretval.duration = memory.elapsedTime;\n \t\t\t\t\tresults.push_back(retval);\n \t\t\t\t\tretval.startRow = playState.m_nRow;\n \t\t\t\t\tretval.startOrder = playState.m_nNextOrder;\n \t\t\t\t\tmemory.Reset();\n \t\t\t\t\tplayState.m_nNextRow = playState.m_nRow;\n \t\t\t\t\tcontinue;\n \t\t\t\t}\n \t\t\t}\n \t\t\tplayState.m_nNextOrder = playState.m_nCurrentOrder + 1;\n \t\t\tcontinue;\n \t\t}\n \t\tif(playState.m_nRow >= Patterns[playState.m_nPattern].GetNumRows())\n \t\t\tplayState.m_nRow = 0;\n \n \t\tif(target.mode == GetLengthTarget::SeekPosition && playState.m_nCurrentOrder == target.pos.order && playState.m_nRow == target.pos.row)\n \t\t{\n \t\t\tretval.targetReached = true;\n \t\t\tbreak;\n \t\t}\n \n \t\tif(visitedRows.IsVisited(playState.m_nCurrentOrder, playState.m_nRow, true))\n \t\t{\n \t\t\tif(!hasSearchTarget || !visitedRows.GetFirstUnvisitedRow(playState.m_nNextOrder, playState.m_nRow, true))\n \t\t\t{\n \t\t\t\tbreak;\n \t\t\t} else\n \t\t\t{\n \t\t\t\tretval.duration = memory.elapsedTime;\n \t\t\t\tresults.push_back(retval);\n \t\t\t\tretval.startRow = playState.m_nRow;\n \t\t\t\tretval.startOrder = playState.m_nNextOrder;\n \t\t\t\tmemory.Reset();\n \t\t\t\tplayState.m_nNextRow = playState.m_nRow;\n \t\t\t\tcontinue;\n \t\t\t}\n \t\t}\n \n \t\tretval.endOrder = playState.m_nCurrentOrder;\n \t\tretval.endRow = playState.m_nRow;\n \n \t\tplayState.m_nNextRow = playState.m_nRow + 1;\n \n \t\tif(playState.m_nRow >= Patterns[playState.m_nPattern].GetNumRows())\n \t\t{\n \t\t\tplayState.m_nRow = 0;\n \t\t}\n \t\tif(!playState.m_nRow)\n \t\t{\n \t\t\tfor(CHANNELINDEX chn = 0; chn < GetNumChannels(); chn++)\n \t\t\t{\n \t\t\t\tmemory.chnSettings[chn].patLoop = memory.elapsedTime;\n \t\t\t\tmemory.chnSettings[chn].patLoopSmp = playState.m_lTotalSampleCount;\n \t\t\t}\n \t\t}\n \n \t\tModChannel *pChn = playState.Chn;\n \n \t\tconst ModCommand *p = Patterns[playState.m_nPattern].GetpModCommand(playState.m_nRow, 0);\n \t\tfor(CHANNELINDEX nChn = 0; nChn < GetNumChannels(); nChn++, p++)\n \t\t{\n \t\t\tif(m_playBehaviour[kST3NoMutedChannels] && ChnSettings[nChn].dwFlags[CHN_MUTE])\n \t\t\t\tcontinue;\n \t\t\tif(p->IsPcNote())\n \t\t\t{\n #ifndef NO_PLUGINS\n \t\t\t\tif((adjustMode & eAdjust) && p->instr > 0 && p->instr <= MAX_MIXPLUGINS)\n \t\t\t\t{\n \t\t\t\t\tmemory.plugParams[std::make_pair(p->instr, p->GetValueVolCol())] = p->GetValueEffectCol();\n \t\t\t\t}\n #endif\n \t\t\t\tpChn[nChn].rowCommand.Clear();\n \t\t\t\tcontinue;\n \t\t\t}\n \t\t\tpChn[nChn].rowCommand = *p;\n \t\t\tswitch(p->command)\n \t\t\t{\n \t\t\tcase CMD_SPEED:\n \t\t\t\tSetSpeed(playState, p->param);\n \t\t\t\tbreak;\n \n \t\t\tcase CMD_TEMPO:\n \t\t\t\tif(m_playBehaviour[kMODVBlankTiming])\n \t\t\t\t{\n \t\t\t\t\tif(p->param != 0) SetSpeed(playState, p->param);\n \t\t\t\t}\n \t\t\t\tbreak;\n \n \t\t\tcase CMD_S3MCMDEX:\n \t\t\t\tif((p->param & 0xF0) == 0x60)\n \t\t\t\t{\n \t\t\t\t\ttickDelay += (p->param & 0x0F);\n \t\t\t\t} else if((p->param & 0xF0) == 0xE0 && !rowDelay)\n \t\t\t\t{\n \t\t\t\t\tif(!(GetType() & MOD_TYPE_S3M) || (p->param & 0x0F) != 0)\n \t\t\t\t\t{\n \t\t\t\t\t\trowDelay = 1 + (p->param & 0x0F);\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\tbreak;\n \n \t\t\tcase CMD_MODCMDEX:\n \t\t\t\tif((p->param & 0xF0) == 0xE0)\n \t\t\t\t{\n \t\t\t\t\trowDelay = 1 + (p->param & 0x0F);\n \t\t\t\t}\n \t\t\t\tbreak;\n \t\t\t}\n \t\t}\n \t\tif(rowDelay == 0) rowDelay = 1;\n \t\tconst uint32 numTicks = (playState.m_nMusicSpeed + tickDelay) * rowDelay;\n \t\tconst uint32 nonRowTicks = numTicks - rowDelay;\n \n \t\tfor(CHANNELINDEX nChn = 0; nChn < GetNumChannels(); pChn++, nChn++) if(!pChn->rowCommand.IsEmpty())\n \t\t{\n \t\t\tif(m_playBehaviour[kST3NoMutedChannels] && ChnSettings[nChn].dwFlags[CHN_MUTE])\n \t\t\t\tcontinue;\n \t\t\tModCommand::COMMAND command = pChn->rowCommand.command;\n \t\t\tModCommand::PARAM param = pChn->rowCommand.param;\n \t\t\tModCommand::NOTE note = pChn->rowCommand.note;\n \n \t\t\tif (pChn->rowCommand.instr)\n \t\t\t{\n \t\t\t\tpChn->nNewIns = pChn->rowCommand.instr;\n \t\t\t\tpChn->nLastNote = NOTE_NONE;\n \t\t\t\tmemory.chnSettings[nChn].vol = 0xFF;\n \t\t\t}\n \t\t\tif (pChn->rowCommand.IsNote()) pChn->nLastNote = note;\n \n \t\t\tif(pChn->rowCommand.IsNote() || pChn->rowCommand.instr)\n \t\t\t{\n \t\t\t\tSAMPLEINDEX smp = 0;\n \t\t\t\tif(GetNumInstruments())\n \t\t\t\t{\n \t\t\t\t\tModInstrument *pIns;\n \t\t\t\t\tif(pChn->nNewIns <= GetNumInstruments() && (pIns = Instruments[pChn->nNewIns]) != nullptr)\n \t\t\t\t\t{\n \t\t\t\t\t\tif(pIns->dwFlags[INS_SETPANNING])\n \t\t\t\t\t\t\tpChn->nPan = pIns->nPan;\n \t\t\t\t\t\tif(ModCommand::IsNote(note))\n \t\t\t\t\t\t\tsmp = pIns->Keyboard[note - NOTE_MIN];\n \t\t\t\t\t}\n \t\t\t\t} else\n \t\t\t\t{\n \t\t\t\t\tsmp = pChn->nNewIns;\n \t\t\t\t}\n \t\t\t\tif(smp > 0 && smp <= GetNumSamples() && Samples[smp].uFlags[CHN_PANNING])\n \t\t\t\t{\n \t\t\t\t\tpChn->nPan = Samples[smp].nPan;\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tswitch(pChn->rowCommand.volcmd)\n \t\t\t{\n \t\t\tcase VOLCMD_VOLUME:\n \t\t\t\tmemory.chnSettings[nChn].vol = pChn->rowCommand.vol;\n \t\t\t\tbreak;\n \t\t\tcase VOLCMD_VOLSLIDEUP:\n \t\t\tcase VOLCMD_VOLSLIDEDOWN:\n \t\t\t\tif(pChn->rowCommand.vol != 0)\n \t\t\t\t\tpChn->nOldVolParam = pChn->rowCommand.vol;\n \t\t\t\tbreak;\n \t\t\t}\n \n \t\t\tswitch(command)\n \t\t\t{\n \t\t\tcase CMD_POSITIONJUMP:\n \t\t\t\tpositionJumpOnThisRow = true;\n \t\t\t\tplayState.m_nNextOrder = static_cast<ORDERINDEX>(CalculateXParam(playState.m_nPattern, playState.m_nRow, nChn));\n \t\t\t\tplayState.m_nNextPatStartRow = 0;\n \t\t\t\tif(!patternBreakOnThisRow || (GetType() & (MOD_TYPE_MOD | MOD_TYPE_XM)))\n \t\t\t\t\tplayState.m_nNextRow = 0;\n \n \t\t\t\tif (adjustMode & eAdjust)\n \t\t\t\t{\n \t\t\t\t\tpChn->nPatternLoopCount = 0;\n \t\t\t\t\tpChn->nPatternLoop = 0;\n \t\t\t\t}\n \t\t\t\tbreak;\n \t\t\tcase CMD_PATTERNBREAK:\n \t\t\t\t{\n \t\t\t\t\tROWINDEX row = PatternBreak(playState, nChn, param);\n \t\t\t\t\tif(row != ROWINDEX_INVALID)\n \t\t\t\t\t{\n \t\t\t\t\t\tpatternBreakOnThisRow = true;\n \t\t\t\t\t\tplayState.m_nNextRow = row;\n \n \t\t\t\t\t\tif(!positionJumpOnThisRow)\n \t\t\t\t\t\t{\n \t\t\t\t\t\t\tplayState.m_nNextOrder = playState.m_nCurrentOrder + 1;\n \t\t\t\t\t\t}\n \t\t\t\t\t\tif(adjustMode & eAdjust)\n \t\t\t\t\t\t{\n \t\t\t\t\t\t\tpChn->nPatternLoopCount = 0;\n \t\t\t\t\t\t\tpChn->nPatternLoop = 0;\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\tbreak;\n \t\t\tcase CMD_TEMPO:\n \t\t\t\tif(!m_playBehaviour[kMODVBlankTiming])\n \t\t\t\t{\n \t\t\t\t\tTEMPO tempo(CalculateXParam(playState.m_nPattern, playState.m_nRow, nChn), 0);\n \t\t\t\t\tif ((adjustMode & eAdjust) && (GetType() & (MOD_TYPE_S3M | MOD_TYPE_IT | MOD_TYPE_MPT)))\n \t\t\t\t\t{\n \t\t\t\t\t\tif (tempo.GetInt()) pChn->nOldTempo = static_cast<uint8>(tempo.GetInt()); else tempo.Set(pChn->nOldTempo);\n \t\t\t\t\t}\n \n \t\t\t\t\tif (tempo.GetInt() >= 0x20) playState.m_nMusicTempo = tempo;\n \t\t\t\t\telse\n \t\t\t\t\t{\n \t\t\t\t\t\tTEMPO tempoDiff((tempo.GetInt() & 0x0F) * nonRowTicks, 0);\n \t\t\t\t\t\tif ((tempo.GetInt() & 0xF0) == 0x10)\n \t\t\t\t\t\t{\n \t\t\t\t\t\t\tplayState.m_nMusicTempo += tempoDiff;\n \t\t\t\t\t\t} else\n \t\t\t\t\t\t{\n \t\t\t\t\t\t\tif(tempoDiff < playState.m_nMusicTempo)\n \t\t\t\t\t\t\t\tplayState.m_nMusicTempo -= tempoDiff;\n \t\t\t\t\t\t\telse\n \t\t\t\t\t\t\t\tplayState.m_nMusicTempo.Set(0);\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \n \t\t\t\t\tTEMPO tempoMin = GetModSpecifications().GetTempoMin(), tempoMax = GetModSpecifications().GetTempoMax();\n \t\t\t\t\tif(m_playBehaviour[kTempoClamp])\n \t\t\t\t\t{\n \t\t\t\t\t\ttempoMax.Set(255);\n \t\t\t\t\t}\n \t\t\t\t\tLimit(playState.m_nMusicTempo, tempoMin, tempoMax);\n \t\t\t\t}\n \t\t\t\tbreak;\n \n \t\t\tcase CMD_S3MCMDEX:\n \t\t\t\tswitch(param & 0xF0)\n \t\t\t\t{\n \t\t\t\tcase 0x90:\n \t\t\t\t\tif(param <= 0x91)\n \t\t\t\t\t{\n \t\t\t\t\t\tpChn->dwFlags.set(CHN_SURROUND, param == 0x91);\n \t\t\t\t\t}\n \t\t\t\t\tbreak;\n \n \t\t\t\tcase 0xA0:\n \t\t\t\t\tpChn->nOldHiOffset = param & 0x0F;\n \t\t\t\t\tbreak;\n \n \t\t\t\tcase 0xB0:\n \t\t\t\t\tif (param & 0x0F)\n \t\t\t\t\t{\n \t\t\t\t\t\tpatternLoopEndedOnThisRow = true;\n \t\t\t\t\t} else\n \t\t\t\t\t{\n \t\t\t\t\t\tCHANNELINDEX firstChn = nChn, lastChn = nChn;\n \t\t\t\t\t\tif(GetType() == MOD_TYPE_S3M)\n \t\t\t\t\t\t{\n \t\t\t\t\t\t\tfirstChn = 0;\n \t\t\t\t\t\t\tlastChn = GetNumChannels() - 1;\n \t\t\t\t\t\t}\n \t\t\t\t\t\tfor(CHANNELINDEX c = firstChn; c <= lastChn; c++)\n \t\t\t\t\t\t{\n \t\t\t\t\t\t\tmemory.chnSettings[c].patLoop = memory.elapsedTime;\n \t\t\t\t\t\t\tmemory.chnSettings[c].patLoopSmp = playState.m_lTotalSampleCount;\n \t\t\t\t\t\t\tmemory.chnSettings[c].patLoopStart = playState.m_nRow;\n \t\t\t\t\t\t}\n \t\t\t\t\t\tpatternLoopStartedOnThisRow = true;\n \t\t\t\t\t}\n \t\t\t\t\tbreak;\n \n \t\t\t\tcase 0xF0:\n \t\t\t\t\tpChn->nActiveMacro = param & 0x0F;\n \t\t\t\t\tbreak;\n \t\t\t\t}\n \t\t\t\tbreak;\n \n \t\t\tcase CMD_MODCMDEX:\n \t\t\t\tswitch(param & 0xF0)\n \t\t\t\t{\n \t\t\t\tcase 0x60:\n \t\t\t\t\tif (param & 0x0F)\n \t\t\t\t\t{\n \t\t\t\t\t\tplayState.m_nNextPatStartRow = memory.chnSettings[nChn].patLoopStart;\n \t\t\t\t\t\tpatternLoopEndedOnThisRow = true;\n \t\t\t\t\t} else\n \t\t\t\t\t{\n \t\t\t\t\t\tpatternLoopStartedOnThisRow = true;\n \t\t\t\t\t\tmemory.chnSettings[nChn].patLoop = memory.elapsedTime;\n \t\t\t\t\t\tmemory.chnSettings[nChn].patLoopSmp = playState.m_lTotalSampleCount;\n \t\t\t\t\t\tmemory.chnSettings[nChn].patLoopStart = playState.m_nRow;\n \t\t\t\t\t}\n \t\t\t\t\tbreak;\n \n \t\t\t\tcase 0xF0:\n \t\t\t\t\tpChn->nActiveMacro = param & 0x0F;\n \t\t\t\t\tbreak;\n \t\t\t\t}\n \t\t\t\tbreak;\n \n \t\t\tcase CMD_XFINEPORTAUPDOWN:\n \t\t\t\tif(((param & 0xF0) == 0xA0) && !m_playBehaviour[kFT2RestrictXCommand]) pChn->nOldHiOffset = param & 0x0F;\n \t\t\t\tbreak;\n \t\t\t}\n \n \t\t\tif (!(adjustMode & eAdjust)) continue;\n \t\t\tswitch(command)\n \t\t\t{\n \t\t\tcase CMD_PORTAMENTOUP:\n \t\t\t\tif(param)\n \t\t\t\t{\n \t\t\t\t\tif(!m_playBehaviour[kFT2PortaUpDownMemory])\n \t\t\t\t\t\tpChn->nOldPortaDown = param;\n \t\t\t\t\tpChn->nOldPortaUp = param;\n \t\t\t\t}\n \t\t\t\tbreak;\n \t\t\tcase CMD_PORTAMENTODOWN:\n \t\t\t\tif(param)\n \t\t\t\t{\n \t\t\t\t\tif(!m_playBehaviour[kFT2PortaUpDownMemory])\n \t\t\t\t\t\tpChn->nOldPortaUp = param;\n \t\t\t\t\tpChn->nOldPortaDown = param;\n \t\t\t\t}\n \t\t\t\tbreak;\n \t\t\tcase CMD_TONEPORTAMENTO:\n \t\t\t\tif (param) pChn->nPortamentoSlide = param << 2;\n \t\t\t\tbreak;\n \t\t\tcase CMD_OFFSET:\n \t\t\t\tif (param) pChn->oldOffset = param << 8;\n \t\t\t\tbreak;\n \t\t\tcase CMD_VOLUMESLIDE:\n \t\t\tcase CMD_TONEPORTAVOL:\n \t\t\t\tif (param) pChn->nOldVolumeSlide = param;\n \t\t\t\tbreak;\n \t\t\tcase CMD_VOLUME:\n \t\t\t\tmemory.chnSettings[nChn].vol = param;\n \t\t\t\tbreak;\n \t\t\tcase CMD_GLOBALVOLUME:\n \t\t\t\tif(!(GetType() & GLOBALVOL_7BIT_FORMATS) && param < 128) param *= 2;\n \t\t\t\tif(param <= 128)\n \t\t\t\t{\n \t\t\t\t\tplayState.m_nGlobalVolume = param * 2;\n \t\t\t\t} else if(!(GetType() & (MOD_TYPE_IT | MOD_TYPE_MPT | MOD_TYPE_S3M)))\n \t\t\t\t{\n \t\t\t\t\tplayState.m_nGlobalVolume = 256;\n \t\t\t\t}\n \t\t\t\tbreak;\n \t\t\tcase CMD_GLOBALVOLSLIDE:\n \t\t\t\tif(m_playBehaviour[kPerChannelGlobalVolSlide])\n \t\t\t\t{\n \t\t\t\t\tif (param) pChn->nOldGlobalVolSlide = param; else param = pChn->nOldGlobalVolSlide;\n \t\t\t\t} else\n \t\t\t\t{\n \t\t\t\t\tif (param) playState.Chn[0].nOldGlobalVolSlide = param; else param = playState.Chn[0].nOldGlobalVolSlide;\n \t\t\t\t}\n \t\t\t\tif (((param & 0x0F) == 0x0F) && (param & 0xF0))\n \t\t\t\t{\n \t\t\t\t\tparam >>= 4;\n \t\t\t\t\tif (!(GetType() & GLOBALVOL_7BIT_FORMATS)) param <<= 1;\n \t\t\t\t\tplayState.m_nGlobalVolume += param << 1;\n \t\t\t\t} else if (((param & 0xF0) == 0xF0) && (param & 0x0F))\n \t\t\t\t{\n \t\t\t\t\tparam = (param & 0x0F) << 1;\n \t\t\t\t\tif (!(GetType() & GLOBALVOL_7BIT_FORMATS)) param <<= 1;\n \t\t\t\t\tplayState.m_nGlobalVolume -= param;\n \t\t\t\t} else if (param & 0xF0)\n \t\t\t\t{\n \t\t\t\t\tparam >>= 4;\n \t\t\t\t\tparam <<= 1;\n \t\t\t\t\tif (!(GetType() & GLOBALVOL_7BIT_FORMATS)) param <<= 1;\n \t\t\t\t\tplayState.m_nGlobalVolume += param * nonRowTicks;\n \t\t\t\t} else\n \t\t\t\t{\n \t\t\t\t\tparam = (param & 0x0F) << 1;\n \t\t\t\t\tif (!(GetType() & GLOBALVOL_7BIT_FORMATS)) param <<= 1;\n \t\t\t\t\tplayState.m_nGlobalVolume -= param * nonRowTicks;\n \t\t\t\t}\n \t\t\t\tLimit(playState.m_nGlobalVolume, 0, 256);\n \t\t\t\tbreak;\n \t\t\tcase CMD_CHANNELVOLUME:\n \t\t\t\tif (param <= 64) pChn->nGlobalVol = param;\n \t\t\t\tbreak;\n \t\t\tcase CMD_CHANNELVOLSLIDE:\n \t\t\t\t{\n \t\t\t\t\tif (param) pChn->nOldChnVolSlide = param; else param = pChn->nOldChnVolSlide;\n \t\t\t\t\tint32 volume = pChn->nGlobalVol;\n \t\t\t\t\tif((param & 0x0F) == 0x0F && (param & 0xF0))\n \t\t\t\t\t\tvolume += (param >> 4);\n \t\t\t\t\telse if((param & 0xF0) == 0xF0 && (param & 0x0F))\n \t\t\t\t\t\tvolume -= (param & 0x0F);\n \t\t\t\t\telse if(param & 0x0F)\n \t\t\t\t\t\tvolume -= (param & 0x0F) * nonRowTicks;\n \t\t\t\t\telse\n \t\t\t\t\t\tvolume += ((param & 0xF0) >> 4) * nonRowTicks;\n \t\t\t\t\tLimit(volume, 0, 64);\n \t\t\t\t\tpChn->nGlobalVol = volume;\n \t\t\t\t}\n \t\t\t\tbreak;\n \t\t\tcase CMD_PANNING8:\n \t\t\t\tPanning(pChn, param, Pan8bit);\n \t\t\t\tbreak;\n \t\t\tcase CMD_MODCMDEX:\n \t\t\t\tif(param < 0x10)\n \t\t\t\t{\n \t\t\t\t\tfor(CHANNELINDEX chn = 0; chn < GetNumChannels(); chn++)\n \t\t\t\t\t{\n \t\t\t\t\t\tplayState.Chn[chn].dwFlags.set(CHN_AMIGAFILTER, !(param & 1));\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\tMPT_FALLTHROUGH;\n \t\t\tcase CMD_S3MCMDEX:\n \t\t\t\tif((param & 0xF0) == 0x80)\n \t\t\t\t{\n \t\t\t\t\tPanning(pChn, (param & 0x0F), Pan4bit);\n \t\t\t\t}\n \t\t\t\tbreak;\n \n \t\t\tcase CMD_VIBRATOVOL:\n \t\t\t\tif (param) pChn->nOldVolumeSlide = param;\n \t\t\t\tparam = 0;\n \t\t\t\tMPT_FALLTHROUGH;\n \t\t\tcase CMD_VIBRATO:\n \t\t\t\tVibrato(pChn, param);\n \t\t\t\tbreak;\n \t\t\tcase CMD_FINEVIBRATO:\n \t\t\t\tFineVibrato(pChn, param);\n \t\t\t\tbreak;\n \t\t\tcase CMD_TREMOLO:\n \t\t\t\tTremolo(pChn, param);\n \t\t\t\tbreak;\n \t\t\tcase CMD_PANBRELLO:\n \t\t\t\tPanbrello(pChn, param);\n \t\t\t\tbreak;\n \t\t\t}\n \n \t\t\tswitch(pChn->rowCommand.volcmd)\n \t\t\t{\n \t\t\tcase VOLCMD_PANNING:\n \t\t\t\tPanning(pChn, pChn->rowCommand.vol, Pan6bit);\n \t\t\t\tbreak;\n \n \t\t\tcase VOLCMD_VIBRATOSPEED:\n \t\t\t\tif(m_playBehaviour[kFT2VolColVibrato])\n \t\t\t\t\tpChn->nVibratoSpeed = pChn->rowCommand.vol & 0x0F;\n \t\t\t\telse\n \t\t\t\t\tVibrato(pChn, pChn->rowCommand.vol << 4);\n \t\t\t\tbreak;\n \t\t\tcase VOLCMD_VIBRATODEPTH:\n \t\t\t\tVibrato(pChn, pChn->rowCommand.vol);\n \t\t\t\tbreak;\n \t\t\t}\n \n \t\t\tswitch(pChn->rowCommand.command)\n \t\t\t{\n \t\t\tcase CMD_VIBRATO:\n \t\t\tcase CMD_FINEVIBRATO:\n \t\t\tcase CMD_VIBRATOVOL:\n \t\t\t\tif(adjustMode & eAdjust)\n \t\t\t\t{\n \t\t\t\t\tuint32 vibTicks = ((GetType() & (MOD_TYPE_IT | MOD_TYPE_MPT)) && !m_SongFlags[SONG_ITOLDEFFECTS]) ? numTicks : nonRowTicks;\n \t\t\t\t\tuint32 inc = pChn->nVibratoSpeed * vibTicks;\n \t\t\t\t\tif(m_playBehaviour[kITVibratoTremoloPanbrello])\n \t\t\t\t\t\tinc *= 4;\n \t\t\t\t\tpChn->nVibratoPos += static_cast<uint8>(inc);\n \t\t\t\t}\n \t\t\t\tbreak;\n \n \t\t\tcase CMD_TREMOLO:\n \t\t\t\tif(adjustMode & eAdjust)\n \t\t\t\t{\n \t\t\t\t\tuint32 tremTicks = ((GetType() & (MOD_TYPE_IT | MOD_TYPE_MPT)) && !m_SongFlags[SONG_ITOLDEFFECTS]) ? numTicks : nonRowTicks;\n \t\t\t\t\tuint32 inc = pChn->nTremoloSpeed * tremTicks;\n \t\t\t\t\tif(m_playBehaviour[kITVibratoTremoloPanbrello])\n \t\t\t\t\t\tinc *= 4;\n \t\t\t\t\tpChn->nTremoloPos += static_cast<uint8>(inc);\n \t\t\t\t}\n \t\t\t\tbreak;\n \n \t\t\tcase CMD_PANBRELLO:\n \t\t\t\tif(adjustMode & eAdjust)\n \t\t\t\t{\n \t\t\t\t\tpChn->nPanbrelloPos += static_cast<uint8>(pChn->nPanbrelloSpeed * (numTicks - 1));\n \t\t\t\t\tProcessPanbrello(pChn);\n \t\t\t\t}\n \t\t\t\tbreak;\n \t\t\t}\n \t\t}\n \n \t\tif(GetType() == MOD_TYPE_XM && playState.m_nMusicSpeed == uint16_max)\n \t\t{\n \t\t\tbreak;\n \t\t}\n \n \t\tplayState.m_nCurrentRowsPerBeat = m_nDefaultRowsPerBeat;\n \t\tif(Patterns[playState.m_nPattern].GetOverrideSignature())\n \t\t{\n \t\t\tplayState.m_nCurrentRowsPerBeat = Patterns[playState.m_nPattern].GetRowsPerBeat();\n \t\t}\n \n \t\tconst uint32 tickDuration = GetTickDuration(playState);\n \t\tconst uint32 rowDuration = tickDuration * numTicks;\n \t\tmemory.elapsedTime += static_cast<double>(rowDuration) / static_cast<double>(m_MixerSettings.gdwMixingFreq);\n \t\tplayState.m_lTotalSampleCount += rowDuration;\n \n \t\tif(adjustSamplePos)\n \t\t{\n \t\t\tpChn = playState.Chn;\n \t\t\tfor(CHANNELINDEX nChn = 0; nChn < GetNumChannels(); pChn++, nChn++)\n \t\t\t{\n \t\t\t\tif(memory.chnSettings[nChn].ticksToRender == GetLengthMemory::IGNORE_CHANNEL)\n \t\t\t\t\tcontinue;\n \n \t\t\t\tuint32 startTick = 0;\n \t\t\t\tconst ModCommand &m = pChn->rowCommand;\n \t\t\t\tuint32 paramHi = m.param >> 4, paramLo = m.param & 0x0F;\n \t\t\t\tbool porta = m.command == CMD_TONEPORTAMENTO || m.command == CMD_TONEPORTAVOL || m.volcmd == VOLCMD_TONEPORTAMENTO;\n \t\t\t\tbool stopNote = patternLoopStartedOnThisRow;\n \n \t\t\t\tif(m.instr) pChn->proTrackerOffset = 0;\n \t\t\t\tif(m.IsNote())\n \t\t\t\t{\n \t\t\t\t\tif(porta && memory.chnSettings[nChn].incChanged)\n \t\t\t\t\t{\n \t\t\t\t\t\tpChn->increment = GetChannelIncrement(pChn, pChn->nPeriod, 0);\n \t\t\t\t\t}\n \t\t\t\t\tint32 setPan = pChn->nPan;\n \t\t\t\t\tpChn->nNewNote = pChn->nLastNote;\n \t\t\t\t\tif(pChn->nNewIns != 0) InstrumentChange(pChn, pChn->nNewIns, porta);\n \t\t\t\t\tNoteChange(pChn, m.note, porta);\n \t\t\t\t\tmemory.chnSettings[nChn].incChanged = true;\n \n \t\t\t\t\tif((m.command == CMD_MODCMDEX || m.command == CMD_S3MCMDEX) && (m.param & 0xF0) == 0xD0 && paramLo < numTicks)\n \t\t\t\t\t{\n \t\t\t\t\t\tstartTick = paramLo;\n \t\t\t\t\t} else if(m.command == CMD_DELAYCUT && paramHi < numTicks)\n \t\t\t\t\t{\n \t\t\t\t\t\tstartTick = paramHi;\n \t\t\t\t\t}\n \t\t\t\t\tif(rowDelay > 1 && startTick != 0 && (GetType() & (MOD_TYPE_S3M | MOD_TYPE_IT | MOD_TYPE_MPT)))\n \t\t\t\t\t{\n \t\t\t\t\t\tstartTick += (playState.m_nMusicSpeed + tickDelay) * (rowDelay - 1);\n \t\t\t\t\t}\n \t\t\t\t\tif(!porta) memory.chnSettings[nChn].ticksToRender = 0;\n \n \t\t\t\t\tif(m.command == CMD_PANNING8\n \t\t\t\t\t\t|| ((m.command == CMD_MODCMDEX || m.command == CMD_S3MCMDEX) && paramHi == 0x8)\n \t\t\t\t\t\t|| m.volcmd == VOLCMD_PANNING)\n \t\t\t\t\t{\n \t\t\t\t\t\tpChn->nPan = setPan;\n \t\t\t\t\t}\n \n \t\t\t\t\tif(m.command == CMD_OFFSET)\n \t\t\t\t\t{\n \t\t\t\t\t\tbool isExtended = false;\n \t\t\t\t\t\tSmpLength offset = CalculateXParam(playState.m_nPattern, playState.m_nRow, nChn, &isExtended);\n \t\t\t\t\t\tif(!isExtended)\n \t\t\t\t\t\t{\n \t\t\t\t\t\t\toffset <<= 8;\n \t\t\t\t\t\t\tif(offset == 0) offset = pChn->oldOffset;\n \t\t\t\t\t\t\toffset += static_cast<SmpLength>(pChn->nOldHiOffset) << 16;\n \t\t\t\t\t\t}\n \t\t\t\t\t\tSampleOffset(*pChn, offset);\n \t\t\t\t\t} else if(m.command == CMD_OFFSETPERCENTAGE)\n \t\t\t\t\t{\n \t\t\t\t\t\tSampleOffset(*pChn, Util::muldiv_unsigned(pChn->nLength, m.param, 255));\n \t\t\t\t\t} else if(m.command == CMD_REVERSEOFFSET && pChn->pModSample != nullptr)\n \t\t\t\t\t{\n \t\t\t\t\t\tmemory.RenderChannel(nChn, oldTickDuration);\n \t\t\t\t\t\tReverseSampleOffset(*pChn, m.param);\n \t\t\t\t\t\tstartTick = playState.m_nMusicSpeed - 1;\n \t\t\t\t\t} else if(m.volcmd == VOLCMD_OFFSET)\n \t\t\t\t\t{\n \t\t\t\t\t\tif(m.vol <= CountOf(pChn->pModSample->cues) && pChn->pModSample != nullptr)\n \t\t\t\t\t\t{\n \t\t\t\t\t\t\tSmpLength offset;\n \t\t\t\t\t\t\tif(m.vol == 0)\n \t\t\t\t\t\t\t\toffset = pChn->oldOffset;\n \t\t\t\t\t\t\telse\n \t\t\t\t\t\t\t\toffset = pChn->oldOffset = pChn->pModSample->cues[m.vol - 1];\n \t\t\t\t\t\t\tSampleOffset(*pChn, offset);\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t}\n \n \t\t\t\tif(m.note == NOTE_KEYOFF || m.note == NOTE_NOTECUT || (m.note == NOTE_FADE && GetNumInstruments())\n \t\t\t\t\t|| ((m.command == CMD_MODCMDEX || m.command == CMD_S3MCMDEX) && (m.param & 0xF0) == 0xC0 && paramLo < numTicks)\n \t\t\t\t\t|| (m.command == CMD_DELAYCUT && paramLo != 0 && startTick + paramLo < numTicks))\n \t\t\t\t{\n \t\t\t\t\tstopNote = true;\n \t\t\t\t}\n \n \t\t\t\tif(m.command == CMD_VOLUME)\n \t\t\t\t{\n \t\t\t\t\tpChn->nVolume = m.param * 4;\n \t\t\t\t} else if(m.volcmd == VOLCMD_VOLUME)\n \t\t\t\t{\n \t\t\t\t\tpChn->nVolume = m.vol * 4;\n \t\t\t\t}\n \n \t\t\t\tif(pChn->pModSample && !stopNote)\n \t\t\t\t{\n \t\t\t\t\tif(m.command < MAX_EFFECTS)\n \t\t\t\t\t{\n \t\t\t\t\t\tif(forbiddenCommands[m.command])\n \t\t\t\t\t\t{\n \t\t\t\t\t\t\tstopNote = true;\n \t\t\t\t\t\t} else if(m.command == CMD_MODCMDEX)\n \t\t\t\t\t\t{\n \t\t\t\t\t\t\tswitch(m.param & 0xF0)\n \t\t\t\t\t\t\t{\n \t\t\t\t\t\t\tcase 0x10:\n \t\t\t\t\t\t\tcase 0x20:\n \t\t\t\t\t\t\t\tstopNote = true;\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \n \t\t\t\t\tif(m.volcmd < forbiddenVolCommands.size() && forbiddenVolCommands[m.volcmd])\n \t\t\t\t\t{\n \t\t\t\t\t\tstopNote = true;\n \t\t\t\t\t}\n \t\t\t\t}\n \n \t\t\t\tif(stopNote)\n \t\t\t\t{\n \t\t\t\t\tpChn->Stop();\n \t\t\t\t\tmemory.chnSettings[nChn].ticksToRender = 0;\n \t\t\t\t} else\n \t\t\t\t{\n \t\t\t\t\tif(oldTickDuration != tickDuration && oldTickDuration != 0)\n \t\t\t\t\t{\n \t\t\t\t\t\tmemory.RenderChannel(nChn, oldTickDuration);\n \t\t\t\t\t}\n \n \t\t\t\t\tswitch(m.command)\n \t\t\t\t\t{\n \t\t\t\t\tcase CMD_TONEPORTAVOL:\n \t\t\t\t\tcase CMD_VOLUMESLIDE:\n \t\t\t\t\tcase CMD_VIBRATOVOL:\n \t\t\t\t\t\tif(m.param || (GetType() != MOD_TYPE_MOD))\n \t\t\t\t\t\t{\n \t\t\t\t\t\t\tfor(uint32 i = 0; i < numTicks; i++)\n \t\t\t\t\t\t\t{\n \t\t\t\t\t\t\t\tpChn->isFirstTick = (i == 0);\n \t\t\t\t\t\t\t\tVolumeSlide(pChn, m.param);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}\n \t\t\t\t\t\tbreak;\n \n \t\t\t\t\tcase CMD_MODCMDEX:\n \t\t\t\t\t\tif((m.param & 0x0F) || (GetType() & (MOD_TYPE_XM | MOD_TYPE_MT2)))\n \t\t\t\t\t\t{\n \t\t\t\t\t\t\tpChn->isFirstTick = true;\n \t\t\t\t\t\t\tswitch(m.param & 0xF0)\n \t\t\t\t\t\t\t{\n \t\t\t\t\t\t\tcase 0xA0: FineVolumeUp(pChn, m.param & 0x0F, false); break;\n \t\t\t\t\t\t\tcase 0xB0: FineVolumeDown(pChn, m.param & 0x0F, false); break;\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}\n \t\t\t\t\t\tbreak;\n \n \t\t\t\t\tcase CMD_S3MCMDEX:\n \t\t\t\t\t\tif(m.param == 0x9E)\n \t\t\t\t\t\t{\n \t\t\t\t\t\t\tmemory.RenderChannel(nChn, oldTickDuration);\n \t\t\t\t\t\t\tpChn->dwFlags.reset(CHN_PINGPONGFLAG);\n \t\t\t\t\t\t} else if(m.param == 0x9F)\n \t\t\t\t\t\t{\n \t\t\t\t\t\t\tmemory.RenderChannel(nChn, oldTickDuration);\n \t\t\t\t\t\t\tpChn->dwFlags.set(CHN_PINGPONGFLAG);\n \t\t\t\t\t\t\tif(!pChn->position.GetInt() && pChn->nLength && (m.IsNote() || !pChn->dwFlags[CHN_LOOP]))\n \t\t\t\t\t\t\t{\n \t\t\t\t\t\t\t\tpChn->position.Set(pChn->nLength - 1, SamplePosition::fractMax);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t} else if((m.param & 0xF0) == 0x70)\n \t\t\t\t\t\t{\n \t\t\t\t\t\t}\n \t\t\t\t\t\tbreak;\n \t\t\t\t\t}\n \t\t\t\t\tpChn->isFirstTick = true;\n \t\t\t\t\tswitch(m.volcmd)\n \t\t\t\t\t{\n \t\t\t\t\tcase VOLCMD_FINEVOLUP:\t\tFineVolumeUp(pChn, m.vol, m_playBehaviour[kITVolColMemory]); break;\n \t\t\t\t\tcase VOLCMD_FINEVOLDOWN:\tFineVolumeDown(pChn, m.vol, m_playBehaviour[kITVolColMemory]); break;\n \t\t\t\t\tcase VOLCMD_VOLSLIDEUP:\n \t\t\t\t\tcase VOLCMD_VOLSLIDEDOWN:\n \t\t\t\t\t\t{\n \t\t\t\t\t\t\tModCommand::VOL vol = m.vol;\n \t\t\t\t\t\t\tif(vol == 0 && m_playBehaviour[kITVolColMemory])\n \t\t\t\t\t\t\t{\n \t\t\t\t\t\t\t\tvol = pChn->nOldVolParam;\n \t\t\t\t\t\t\t\tif(vol == 0)\n \t\t\t\t\t\t\t\t\tbreak;\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\tif(m.volcmd == VOLCMD_VOLSLIDEUP)\n \t\t\t\t\t\t\t\tvol <<= 4;\n \t\t\t\t\t\t\tfor(uint32 i = 0; i < numTicks; i++)\n \t\t\t\t\t\t\t{\n \t\t\t\t\t\t\t\tpChn->isFirstTick = (i == 0);\n \t\t\t\t\t\t\t\tVolumeSlide(pChn, vol);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}\n \t\t\t\t\t\tbreak;\n \t\t\t\t\t}\n \n \t\t\t\t\tif(porta)\n \t\t\t\t\t{\n \t\t\t\t\t\tuint32 portaTick = memory.chnSettings[nChn].ticksToRender + startTick + 1;\n \t\t\t\t\t\tmemory.chnSettings[nChn].ticksToRender += numTicks;\n \t\t\t\t\t\tmemory.RenderChannel(nChn, tickDuration, portaTick);\n \t\t\t\t\t} else\n \t\t\t\t\t{\n \t\t\t\t\t\tmemory.chnSettings[nChn].ticksToRender += (numTicks - startTick);\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \t\toldTickDuration = tickDuration;\n \n \t\tif(patternLoopEndedOnThisRow\n \t\t\t&& (!m_playBehaviour[kFT2PatternLoopWithJumps] || !(positionJumpOnThisRow || patternBreakOnThisRow))\n \t\t\t&& (!m_playBehaviour[kITPatternLoopWithJumps] || !positionJumpOnThisRow))\n \t\t{\n \t\t\tstd::map<double, int> startTimes;\n \t\t\tpChn = playState.Chn;\n \t\t\tfor(CHANNELINDEX nChn = 0; nChn < GetNumChannels(); nChn++, pChn++)\n \t\t\t{\n \t\t\t\tModCommand::COMMAND command = pChn->rowCommand.command;\n \t\t\t\tModCommand::PARAM param = pChn->rowCommand.param;\n \t\t\t\tif((command == CMD_S3MCMDEX && param >= 0xB1 && param <= 0xBF)\n \t\t\t\t\t|| (command == CMD_MODCMDEX && param >= 0x61 && param <= 0x6F))\n \t\t\t\t{\n \t\t\t\t\tconst double start = memory.chnSettings[nChn].patLoop;\n \t\t\t\t\tif(!startTimes[start]) startTimes[start] = 1;\n \t\t\t\t\tstartTimes[start] = mpt::lcm(startTimes[start], 1 + (param & 0x0F));\n \t\t\t\t}\n \t\t\t}\n \t\t\tfor(const auto &i : startTimes)\n \t\t\t{\n \t\t\t\tmemory.elapsedTime += (memory.elapsedTime - i.first) * (double)(i.second - 1);\n \t\t\t\tfor(CHANNELINDEX nChn = 0; nChn < GetNumChannels(); nChn++, pChn++)\n \t\t\t\t{\n \t\t\t\t\tif(memory.chnSettings[nChn].patLoop == i.first)\n \t\t\t\t\t{\n \t\t\t\t\t\tplayState.m_lTotalSampleCount += (playState.m_lTotalSampleCount - memory.chnSettings[nChn].patLoopSmp) * (i.second - 1);\n \t\t\t\t\t\tif(m_playBehaviour[kITPatternLoopTargetReset] || (GetType() == MOD_TYPE_S3M))\n \t\t\t\t\t\t{\n \t\t\t\t\t\t\tmemory.chnSettings[nChn].patLoop = memory.elapsedTime;\n \t\t\t\t\t\t\tmemory.chnSettings[nChn].patLoopSmp = playState.m_lTotalSampleCount;\n \t\t\t\t\t\t\tmemory.chnSettings[nChn].patLoopStart = playState.m_nRow + 1;\n \t\t\t\t\t\t}\n \t\t\t\t\t\tbreak;\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \t\t\tif(GetType() == MOD_TYPE_IT)\n \t\t\t{\n// bug_start\n\t\t\t\tfor(CHANNELINDEX nChn = 0; nChn < GetNumChannels(); nChn++)\n// bug_end\n \t\t\t\t{\n \t\t\t\t\tif((pChn->rowCommand.command == CMD_S3MCMDEX && pChn->rowCommand.param >= 0xB1 && pChn->rowCommand.param <= 0xBF))\n \t\t\t\t\t{\n \t\t\t\t\t\tmemory.chnSettings[nChn].patLoop = memory.elapsedTime;\n \t\t\t\t\t\tmemory.chnSettings[nChn].patLoopSmp = playState.m_lTotalSampleCount;\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \t}\n \n \tif(adjustSamplePos)\n \t{\n \t\tfor(CHANNELINDEX nChn = 0; nChn < GetNumChannels(); nChn++)\n \t\t{\n \t\t\tif(memory.chnSettings[nChn].ticksToRender != GetLengthMemory::IGNORE_CHANNEL)\n \t\t\t{\n \t\t\t\tmemory.RenderChannel(nChn, oldTickDuration);\n \t\t\t}\n \t\t}\n \t}\n \n \tif(retval.targetReached || target.mode == GetLengthTarget::NoTarget)\n \t{\n \t\tretval.lastOrder = playState.m_nCurrentOrder;\n \t\tretval.lastRow = playState.m_nRow;\n \t}\n \tretval.duration = memory.elapsedTime;\n \tresults.push_back(retval);\n \n \tif(adjustMode & eAdjust)\n \t{\n \t\tif(retval.targetReached || target.mode == GetLengthTarget::NoTarget)\n \t\t{\n \t\t\tm_PlayState = std::move(playState);\n \t\t\tm_PlayState.m_nNextRow = m_PlayState.m_nRow;\n \t\t\tm_PlayState.m_nFrameDelay = m_PlayState.m_nPatternDelay = 0;\n \t\t\tm_PlayState.m_nTickCount = Util::MaxValueOfType(m_PlayState.m_nTickCount) - 1;\n \t\t\tm_PlayState.m_bPositionChanged = true;\n \t\t\tfor(CHANNELINDEX n = 0; n < GetNumChannels(); n++)\n \t\t\t{\n \t\t\t\tif(m_PlayState.Chn[n].nLastNote != NOTE_NONE)\n \t\t\t\t{\n \t\t\t\t\tm_PlayState.Chn[n].nNewNote = m_PlayState.Chn[n].nLastNote;\n \t\t\t\t}\n \t\t\t\tif(memory.chnSettings[n].vol != 0xFF && !adjustSamplePos)\n \t\t\t\t{\n \t\t\t\t\tm_PlayState.Chn[n].nVolume = std::min(memory.chnSettings[n].vol, uint8(64)) * 4;\n \t\t\t\t}\n \t\t\t}\n \n #ifndef NO_PLUGINS\n \t\t\tstd::bitset<MAX_MIXPLUGINS> plugSetProgram;\n \t\t\tfor(const auto &param : memory.plugParams)\n \t\t\t{\n \t\t\t\tPLUGINDEX plug = param.first.first - 1;\n \t\t\t\tIMixPlugin *plugin = m_MixPlugins[plug].pMixPlugin;\n \t\t\t\tif(plugin != nullptr)\n \t\t\t\t{\n \t\t\t\t\tif(!plugSetProgram[plug])\n \t\t\t\t\t{\n \t\t\t\t\t\tplugSetProgram.set(plug);\n \t\t\t\t\t\tplugin->BeginSetProgram();\n \t\t\t\t\t}\n \t\t\t\t\tplugin->SetParameter(param.first.second, param.second / PlugParamValue(ModCommand::maxColumnValue));\n \t\t\t\t}\n \t\t\t}\n \t\t\tif(plugSetProgram.any())\n \t\t\t{\n \t\t\t\tfor(PLUGINDEX i = 0; i < MAX_MIXPLUGINS; i++)\n \t\t\t\t{\n \t\t\t\t\tif(plugSetProgram[i])\n \t\t\t\t\t{\n \t\t\t\t\t\tm_MixPlugins[i].pMixPlugin->EndSetProgram();\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n #endif\n \t\t} else if(adjustMode != eAdjustOnSuccess)\n \t\t{\n \t\t\tm_PlayState.m_nMusicSpeed = m_nDefaultSpeed;\n \t\t\tm_PlayState.m_nMusicTempo = m_nDefaultTempo;\n \t\t\tm_PlayState.m_nGlobalVolume = m_nDefaultGlobalVolume;\n \t\t}\n \t\tif(sequence != Order.GetCurrentSequenceIndex())\n \t\t{\n \t\t\tOrder.SetSequence(sequence);\n \t\t}\n \t\tvisitedSongRows.Set(visitedRows);\n \t}\n \n \treturn results;\n \n }\n \n", "target": "// fix_start\n\t\t\t\tpChn = playState.Chn;\n\t\t\t\tfor(CHANNELINDEX nChn = 0; nChn < GetNumChannels(); nChn++, pChn++)\n// fix_end\n", "cwe": "CWE-125", "cwe_name": "Out-of-bounds Read", "cve": "CVE-2018-10017", "cve_desc": "soundlib/Snd_fx.cpp in OpenMPT before 1.27.07.00 and libopenmpt before 0.3.8 allows remote attackers to cause a denial of service (out-of-bounds read) via an IT or MO3 file with many nested pattern loops.", "project": "openmpt", "idx": 197202}
{"source": " static bool checkreturn decode_pointer_field(pb_istream_t *stream, pb_wire_type_t wire_type, pb_field_iterator_t *iter)\n {\n #ifndef PB_ENABLE_MALLOC\n     UNUSED(wire_type);\n     UNUSED(iter);\n     PB_RETURN_ERROR(stream, \"no malloc support\");\n #else\n     pb_type_t type;\n     pb_decoder_t func;\n \n     type = iter->pos->type;\n     func = PB_DECODERS[PB_LTYPE(type)];\n \n     switch (PB_HTYPE(type))\n     {\n         case PB_HTYPE_REQUIRED:\n         case PB_HTYPE_OPTIONAL:\n             if (PB_LTYPE(type) == PB_LTYPE_SUBMESSAGE &&\n                 *(void**)iter->pData != NULL)\n             {\n                 pb_release_single_field(iter);\n             }\n \n             if (PB_LTYPE(type) == PB_LTYPE_STRING ||\n                 PB_LTYPE(type) == PB_LTYPE_BYTES)\n             {\n                 return func(stream, iter->pos, iter->pData);\n             }\n             else\n             {\n                 if (!allocate_field(stream, iter->pData, iter->pos->data_size, 1))\n                     return false;\n \n                 initialize_pointer_field(*(void**)iter->pData, iter);\n                 return func(stream, iter->pos, *(void**)iter->pData);\n             }\n \n         case PB_HTYPE_REPEATED:\n             if (wire_type == PB_WT_STRING\n                 && PB_LTYPE(type) <= PB_LTYPE_LAST_PACKABLE)\n             {\n                 bool status = true;\n                 size_t *size = (size_t*)iter->pSize;\n                 size_t allocated_size = *size;\n                 void *pItem;\n                 pb_istream_t substream;\n \n                 if (!pb_make_string_substream(stream, &substream))\n                     return false;\n \n                 while (substream.bytes_left)\n                 {\n                     if (*size + 1 > allocated_size)\n                     {\n                         allocated_size += (substream.bytes_left - 1) / iter->pos->data_size + 1;\n \n                         if (!allocate_field(&substream, iter->pData, iter->pos->data_size, allocated_size))\n                         {\n                             status = false;\n                             break;\n                         }\n                     }\n \n                     pItem = *(uint8_t**)iter->pData + iter->pos->data_size * (*size);\n                     initialize_pointer_field(pItem, iter);\n                     if (!func(&substream, iter->pos, pItem))\n                     {\n                         status = false;\n                         break;\n                     }\n                     (*size)++;\n                 }\n                 pb_close_string_substream(stream, &substream);\n \n                 return status;\n             }\n             else\n             {\n                 size_t *size = (size_t*)iter->pSize;\n                 void *pItem;\n \n// bug_start\n                (*size)++;\n                if (!allocate_field(stream, iter->pData, iter->pos->data_size, *size))\n// bug_end\n                     return false;\n \n// bug_start\n                pItem = *(uint8_t**)iter->pData + iter->pos->data_size * (*size - 1);\n// bug_end\n                 initialize_pointer_field(pItem, iter);\n                 return func(stream, iter->pos, pItem);\n             }\n \n         default:\n             PB_RETURN_ERROR(stream, \"invalid field type\");\n     }\n #endif\n }\n \n", "target": "// fix_start\n                if (!allocate_field(stream, iter->pData, iter->pos->data_size, (size_t)(*size + 1)))\n// fix_end\n// fix_start\n                pItem = *(uint8_t**)iter->pData + iter->pos->data_size * (*size);\n                (*size)++;\n// fix_end\n", "cwe": "CWE-125", "cwe_name": "Out-of-bounds Read", "cve": "CVE-2020-5235", "cve_desc": "There is a potentially exploitable out of memory condition In Nanopb before 0.4.1, 0.3.9.5, and 0.2.9.4. When nanopb is compiled with PB_ENABLE_MALLOC, the message to be decoded contains a repeated string, bytes or message field and realloc() runs out of memory when expanding the array nanopb can end up calling `free()` on a pointer value that comes from uninitialized memory. Depending on platform this can result in a crash or further memory corruption, which may be exploitable in some cases. This problem is fixed in nanopb-0.4.1, nanopb-0.3.9.5, nanopb-0.2.9.4.", "project": "nanopb", "idx": 197204}
{"source": " GF_Err flac_dmx_process(GF_Filter *filter)\n {\n \tGF_FLACDmxCtx *ctx = gf_filter_get_udta(filter);\n \tGF_FilterPacket *pck, *dst_pck;\n \tu8 *output;\n \tu8 *start;\n \tBool final_flush=GF_FALSE;\n \tu32 pck_size, remain, prev_pck_size;\n \tu64 cts = GF_FILTER_NO_TS;\n \tFLACHeader hdr;\n \n// bug_start\n// bug_end\n \tif (!ctx->duration.num)\n \t\tflac_dmx_check_dur(filter, ctx);\n \n \tif (ctx->opid && !ctx->is_playing)\n \t\treturn GF_OK;\n \n \tpck = gf_filter_pid_get_packet(ctx->ipid);\n \tif (!pck) {\n \t\tif (gf_filter_pid_is_eos(ctx->ipid)) {\n \t\t\tif (!ctx->flac_buffer_size) {\n \t\t\t\tif (ctx->opid)\n \t\t\t\t\tgf_filter_pid_set_eos(ctx->opid);\n \t\t\t\tif (ctx->src_pck) gf_filter_pck_unref(ctx->src_pck);\n \t\t\t\tctx->src_pck = NULL;\n \t\t\t\treturn GF_EOS;\n \t\t\t}\n \t\t\tfinal_flush = GF_TRUE;\n \t\t} else {\n \t\t\treturn GF_OK;\n \t\t}\n \t}\n \n \tprev_pck_size = ctx->flac_buffer_size;\n \tif (pck && !ctx->resume_from) {\n \t\tu8 *data = (u8 *) gf_filter_pck_get_data(pck, &pck_size);\n \n \t\tif (ctx->byte_offset != GF_FILTER_NO_BO) {\n \t\t\tu64 byte_offset = gf_filter_pck_get_byte_offset(pck);\n \t\t\tif (!ctx->flac_buffer_size) {\n \t\t\t\tctx->byte_offset = byte_offset;\n \t\t\t} else if (ctx->byte_offset + ctx->flac_buffer_size != byte_offset) {\n \t\t\t\tctx->byte_offset = GF_FILTER_NO_BO;\n \t\t\t\tif ((byte_offset != GF_FILTER_NO_BO) && (byte_offset>ctx->flac_buffer_size) ) {\n \t\t\t\t\tctx->byte_offset = byte_offset - ctx->flac_buffer_size;\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \n \t\tif (ctx->flac_buffer_size + pck_size > ctx->flac_buffer_alloc) {\n \t\t\tctx->flac_buffer_alloc = ctx->flac_buffer_size + pck_size;\n \t\t\tctx->flac_buffer = gf_realloc(ctx->flac_buffer, ctx->flac_buffer_alloc);\n \t\t}\n \t\tmemcpy(ctx->flac_buffer + ctx->flac_buffer_size, data, pck_size);\n \t\tctx->flac_buffer_size += pck_size;\n \t}\n \n \tif (ctx->timescale && pck) {\n \t\tcts = gf_filter_pck_get_cts(pck);\n \t}\n \n \tif (cts == GF_FILTER_NO_TS) {\n \t\tprev_pck_size = 0;\n \t}\n \n \tremain = ctx->flac_buffer_size;\n \tstart = ctx->flac_buffer;\n \n \tif (ctx->resume_from) {\n \t\tstart += ctx->resume_from - 1;\n \t\tremain -= ctx->resume_from - 1;\n \t\tctx->resume_from = 0;\n \t}\n \n \twhile (remain>2) {\n \t\tu32 next_frame=0, nb_samp;\n \t\tu32 cur_size = remain-2;\n \t\tu8 *cur_buf = start+2;\n \t\tu8 *hdr_start = NULL;\n \n \t\tif (final_flush) {\n \t\t\tnext_frame = remain;\n \t\t} else {\n \t\t\twhile (cur_size) {\n \t\t\t\thdr_start = memchr(cur_buf, 0xFF, cur_size);\n \t\t\t\tif (!hdr_start) break;\n \t\t\t\tnext_frame = (u32) (hdr_start-start);\n \t\t\t\tif (next_frame == remain)\n \t\t\t\t\tbreak;\n \n \t\t\t\tif ((hdr_start[1]&0xFC) == 0xF8) {\n \t\t\t\t\tif (flac_parse_header(ctx, hdr_start, (u32) remain - next_frame, &hdr))\n \t\t\t\t\t\tbreak;\n \t\t\t\t}\n \t\t\t\tcur_buf = hdr_start+1;\n \t\t\t\tcur_size = (u32) (cur_buf - start);\n \t\t\t\tassert(cur_size<=remain);\n \t\t\t\tcur_size = remain - cur_size;\n \t\t\t\thdr_start = NULL;\n \t\t\t}\n \t\t\tif (!hdr_start) break;\n \t\t\tif (next_frame == remain)\n \t\t\t\tbreak;\n \t\t}\n \n \n \t\tif (!ctx->initialized) {\n \t\t\tu32 size = next_frame;\n \t\t\tu32 dsi_end = 0;\n \t\t\tgf_bs_reassign_buffer(ctx->bs, ctx->flac_buffer, size);\n \t\t\tu32 magic = gf_bs_read_u32(ctx->bs);\n \t\t\tif (magic != GF_4CC('f','L','a','C')) {\n// bug_start\n\n// bug_end\n \t\t\t}\n \t\t\twhile (gf_bs_available(ctx->bs)) {\n \t\t\t\tBool last = gf_bs_read_int(ctx->bs, 1);\n \t\t\t\tu32 type = gf_bs_read_int(ctx->bs, 7);\n \t\t\t\tu32 len = gf_bs_read_int(ctx->bs, 24);\n \n \t\t\t\tif (type==0) {\n \t\t\t\t\tu16 min_block_size = gf_bs_read_u16(ctx->bs);\n \t\t\t\t\tu16 max_block_size = gf_bs_read_u16(ctx->bs);\n \t\t\t\t\tgf_bs_read_u24(ctx->bs);\n \t\t\t\t\tgf_bs_read_u24(ctx->bs);\n \t\t\t\t\tctx->sample_rate = gf_bs_read_int(ctx->bs, 20);\n \t\t\t\t\tctx->nb_channels = 1 + gf_bs_read_int(ctx->bs, 3);\n \t\t\t\t\tctx->bits_per_sample = 1 + gf_bs_read_int(ctx->bs, 5);\n \t\t\t\t\tif (min_block_size==max_block_size) ctx->block_size = min_block_size;\n \t\t\t\t\telse ctx->block_size = 0;\n \n \t\t\t\t\tctx->duration.num = gf_bs_read_long_int(ctx->bs, 36);\n \t\t\t\t\tctx->duration.den = ctx->sample_rate;\n \t\t\t\t\tgf_bs_skip_bytes(ctx->bs, 16);\n \t\t\t\t\tdsi_end = (u32) gf_bs_get_position(ctx->bs);\n \n \t\t\t\t} else {\n \t\t\t\t\tgf_bs_skip_bytes(ctx->bs, len);\n \t\t\t\t}\n \t\t\t\tif (last) break;\n \t\t\t}\n// bug_start\n// bug_end\n \t\t\tflac_dmx_check_pid(filter, ctx, ctx->flac_buffer+4, dsi_end-4);\n \t\t\tremain -= size;\n \t\t\tstart += size;\n \t\t\tctx->initialized = GF_TRUE;\n \t\t\tif (!ctx->is_playing) break;\n \t\t\tcontinue;\n \t\t}\n \n \t\tif ((start[0] != 0xFF) && ((start[1]&0xFC) != 0xF8)) {\n \t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_PARSER, (\"[FLACDmx] invalid frame, droping %d bytes and resyncing\\n\", next_frame));\n \t\t\tstart += next_frame;\n \t\t\tremain -= next_frame;\n \t\t\tcontinue;\n \t\t}\n \n \t\tflac_parse_header(ctx,start, next_frame, &hdr);\n \t\tif (hdr.sample_rate != ctx->sample_rate) {\n \t\t\tctx->sample_rate = hdr.sample_rate;\n \t\t\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_SAMPLE_RATE, & PROP_UINT(ctx->sample_rate));\n \t\t}\n \n \t\tnb_samp = hdr.block_size;\n \n \t\tif (ctx->in_seek) {\n \t\t\tu64 nb_samples_at_seek = (u64) (ctx->start_range * ctx->sample_rate);\n \t\t\tif (ctx->cts + nb_samp >= nb_samples_at_seek) {\n \t\t\t\tctx->in_seek = GF_FALSE;\n \t\t\t}\n \t\t}\n \n \t\tif (ctx->timescale && !prev_pck_size && (cts != GF_FILTER_NO_TS) ) {\n \t\t\tctx->cts = cts;\n \t\t\tcts = GF_FILTER_NO_TS;\n \t\t}\n \n \t\tif (!ctx->in_seek) {\n \t\t\tdst_pck = gf_filter_pck_new_alloc(ctx->opid, next_frame, &output);\n \t\t\tmemcpy(output, start, next_frame);\n \n \t\t\tgf_filter_pck_set_cts(dst_pck, ctx->cts);\n \t\t\tif (!ctx->timescale || (ctx->timescale==ctx->sample_rate) )\n \t\t\t\tgf_filter_pck_set_duration(dst_pck, nb_samp);\n \t\t\telse {\n \t\t\t\tgf_filter_pck_set_duration(dst_pck, (nb_samp * ctx->timescale) / ctx->sample_rate);\n \t\t\t}\n \t\t\tgf_filter_pck_set_sap(dst_pck, GF_FILTER_SAP_1);\n \t\t\tgf_filter_pck_set_framing(dst_pck, GF_TRUE, GF_TRUE);\n \n \t\t\tif (ctx->byte_offset != GF_FILTER_NO_BO) {\n \t\t\t\tgf_filter_pck_set_byte_offset(dst_pck, ctx->byte_offset);\n \t\t\t}\n \t\t\tgf_filter_pck_send(dst_pck);\n \t\t}\n \t\tflac_dmx_update_cts(ctx, nb_samp);\n \n \t\tassert (start[0] == 0xFF);\n \t\tassert((start[1]&0xFC) == 0xF8);\n \n \t\tstart += next_frame;\n \t\tassert(remain >= next_frame);\n \t\tremain -= next_frame;\n \n \t}\n \n \tif (!pck) {\n \t\tctx->flac_buffer_size = 0;\n \t\treturn flac_dmx_process(filter);\n \t} else {\n \t\tif (remain < ctx->flac_buffer_size) {\n \t\t\tmemmove(ctx->flac_buffer, start, remain);\n \t\t}\n \t\tctx->flac_buffer_size = remain;\n \t\tgf_filter_pid_drop_packet(ctx->ipid);\n \t}\n \treturn GF_OK;\n }\n \n", "target": "// fix_start\n\tif (ctx->in_error)\n\t\treturn GF_NON_COMPLIANT_BITSTREAM;\n\n// fix_end\n// fix_start\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_PARSER, (\"[FLACDmx] invalid FLAC magic\\n\"));\n\t\t\t\tctx->in_error = GF_TRUE;\n\t\t\t\tctx->flac_buffer_size = 0;\n\t\t\t\tif (pck)\n\t\t\t\t\tgf_filter_pid_drop_packet(ctx->ipid);\n\t\t\t\treturn GF_NON_COMPLIANT_BITSTREAM;\n// fix_end\n// fix_start\n\t\t\tif (!dsi_end) {\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_PARSER, (\"[FLACDmx] invalid FLAC header\\n\"));\n\t\t\t\tctx->in_error = GF_TRUE;\n\t\t\t\tctx->flac_buffer_size = 0;\n\t\t\t\tif (pck)\n\t\t\t\t\tgf_filter_pid_drop_packet(ctx->ipid);\n\t\t\t\treturn GF_NON_COMPLIANT_BITSTREAM;\n\t\t\t}\n// fix_end\n", "cwe": "CWE-787", "cwe_name": "Out-of-bounds Write", "cve": "CVE-2021-29279", "cve_desc": "There is a integer overflow in function filter_core/filter_props.c:gf_props_assign_value in GPAC 1.0.1. In which, the arg const GF_PropertyValue *value,maybe value->value.data.size is a negative number. In result, memcpy in gf_props_assign_value failed.", "project": "gpac", "idx": 197240}
{"source": " export_desktop_file (const char         *app,\n                      const char         *branch,\n                      const char         *arch,\n                      GKeyFile           *metadata,\n                      const char * const *previous_ids,\n                      int                 parent_fd,\n                      const char         *name,\n                      struct stat        *stat_buf,\n                      char              **target,\n                      GCancellable       *cancellable,\n                      GError            **error)\n {\n   gboolean ret = FALSE;\n   glnx_autofd int desktop_fd = -1;\n   g_autofree char *tmpfile_name = g_strdup_printf (\"export-desktop-XXXXXX\");\n   g_autoptr(GOutputStream) out_stream = NULL;\n   g_autofree gchar *data = NULL;\n   gsize data_len;\n   g_autofree gchar *new_data = NULL;\n   gsize new_data_len;\n   g_autoptr(GKeyFile) keyfile = NULL;\n   g_autofree gchar *old_exec = NULL;\n   gint old_argc;\n   g_auto(GStrv) old_argv = NULL;\n   g_auto(GStrv) groups = NULL;\n   GString *new_exec = NULL;\n   g_autofree char *escaped_app = maybe_quote (app);\n   g_autofree char *escaped_branch = maybe_quote (branch);\n   g_autofree char *escaped_arch = maybe_quote (arch);\n   int i;\n \n   if (!flatpak_openat_noatime (parent_fd, name, &desktop_fd, cancellable, error))\n     goto out;\n \n   if (!read_fd (desktop_fd, stat_buf, &data, &data_len, error))\n     goto out;\n \n   keyfile = g_key_file_new ();\n   if (!g_key_file_load_from_data (keyfile, data, data_len, G_KEY_FILE_KEEP_TRANSLATIONS, error))\n     goto out;\n \n   if (g_str_has_suffix (name, \".service\"))\n     {\n       g_autofree gchar *dbus_name = NULL;\n       g_autofree gchar *expected_dbus_name = g_strndup (name, strlen (name) - strlen (\".service\"));\n \n       dbus_name = g_key_file_get_string (keyfile, \"D-BUS Service\", \"Name\", NULL);\n \n       if (dbus_name == NULL || strcmp (dbus_name, expected_dbus_name) != 0)\n         {\n           return flatpak_fail_error (error, FLATPAK_ERROR_EXPORT_FAILED,\n                                      _(\"D-Bus service file '%s' has wrong name\"), name);\n         }\n     }\n \n   if (g_str_has_suffix (name, \".desktop\"))\n     {\n       gsize length;\n       g_auto(GStrv) tags = g_key_file_get_string_list (metadata,\n                                                        \"Application\",\n                                                        \"tags\", &length,\n                                                        NULL);\n \n       if (tags != NULL)\n         {\n           g_key_file_set_string_list (keyfile,\n                                       G_KEY_FILE_DESKTOP_GROUP,\n                                       \"X-Flatpak-Tags\",\n                                       (const char * const *) tags, length);\n         }\n \n       g_key_file_set_string (keyfile, G_KEY_FILE_DESKTOP_GROUP, \"X-Flatpak\", app);\n \n       if (previous_ids != NULL)\n         {\n           const char *X_FLATPAK_RENAMED_FROM = \"X-Flatpak-RenamedFrom\";\n           g_auto(GStrv) renamed_from = g_key_file_get_string_list (keyfile,\n                                                                    G_KEY_FILE_DESKTOP_GROUP,\n                                                                    X_FLATPAK_RENAMED_FROM,\n                                                                    NULL, NULL);\n           g_autoptr(GPtrArray) merged = g_ptr_array_new_with_free_func (g_free);\n           g_autoptr(GHashTable) seen = g_hash_table_new (g_str_hash, g_str_equal);\n           const char *new_suffix;\n \n           for (i = 0; renamed_from != NULL && renamed_from[i] != NULL; i++)\n             {\n               if (!g_hash_table_contains (seen, renamed_from[i]))\n                 {\n                   gchar *copy = g_strdup (renamed_from[i]);\n                   g_hash_table_insert (seen, copy, copy);\n                   g_ptr_array_add (merged, g_steal_pointer (&copy));\n                 }\n             }\n \n           g_assert (g_str_has_prefix (name, app));\n           new_suffix = name + strlen (app);\n \n           for (i = 0; previous_ids[i] != NULL; i++)\n             {\n               g_autofree gchar *previous_desktop = g_strconcat (previous_ids[i], new_suffix, NULL);\n               if (!g_hash_table_contains (seen, previous_desktop))\n                 {\n                   g_hash_table_insert (seen, previous_desktop, previous_desktop);\n                   g_ptr_array_add (merged, g_steal_pointer (&previous_desktop));\n                 }\n             }\n \n           if (merged->len > 0)\n             {\n               g_ptr_array_add (merged, NULL);\n               g_key_file_set_string_list (keyfile,\n                                           G_KEY_FILE_DESKTOP_GROUP,\n                                           X_FLATPAK_RENAMED_FROM,\n                                           (const char * const *) merged->pdata,\n                                           merged->len - 1);\n             }\n         }\n     }\n \n   groups = g_key_file_get_groups (keyfile, NULL);\n \n   for (i = 0; groups[i] != NULL; i++)\n     {\n       g_auto(GStrv) flatpak_run_opts = g_key_file_get_string_list (keyfile, groups[i], \"X-Flatpak-RunOptions\", NULL, NULL);\n       g_autofree char *flatpak_run_args = format_flatpak_run_args_from_run_opts (flatpak_run_opts);\n \n       g_key_file_remove_key (keyfile, groups[i], \"X-Flatpak-RunOptions\", NULL);\n       g_key_file_remove_key (keyfile, groups[i], \"TryExec\", NULL);\n \n       g_key_file_remove_key (keyfile, groups[i], \"X-GNOME-Bugzilla-ExtraInfoScript\", NULL);\n \n       new_exec = g_string_new (\"\");\n       g_string_append_printf (new_exec,\n                               FLATPAK_BINDIR \"/flatpak run --branch=%s --arch=%s\",\n                               escaped_branch,\n                               escaped_arch);\n \n       if (flatpak_run_args != NULL)\n         g_string_append_printf (new_exec, \"%s\", flatpak_run_args);\n \n       old_exec = g_key_file_get_string (keyfile, groups[i], \"Exec\", NULL);\n       if (old_exec && g_shell_parse_argv (old_exec, &old_argc, &old_argv, NULL) && old_argc >= 1)\n         {\n           int j;\n           g_autofree char *command = maybe_quote (old_argv[0]);\n \n           g_string_append_printf (new_exec, \" --command=%s\", command);\n \n           for (j = 1; j < old_argc; j++)\n             {\n               if (strcasecmp (old_argv[j], \"%f\") == 0 ||\n                   strcasecmp (old_argv[j], \"%u\") == 0)\n                 {\n                   g_string_append (new_exec, \" --file-forwarding\");\n                   break;\n                 }\n             }\n \n           g_string_append (new_exec, \" \");\n           g_string_append (new_exec, escaped_app);\n \n           for (j = 1; j < old_argc; j++)\n             {\n               g_autofree char *arg = maybe_quote (old_argv[j]);\n \n               if (strcasecmp (arg, \"%f\") == 0)\n                 g_string_append_printf (new_exec, \" @@ %s @@\", arg);\n               else if (strcasecmp (arg, \"%u\") == 0)\n                 g_string_append_printf (new_exec, \" @@u %s @@\", arg);\n               else if (g_str_has_prefix (arg, \"@@\"))\n// bug_start\n                g_print (_(\"Skipping invalid Exec argument %s\\n\"), arg);\n// bug_end\n               else\n                 g_string_append_printf (new_exec, \" %s\", arg);\n             }\n         }\n       else\n         {\n           g_string_append (new_exec, \" \");\n           g_string_append (new_exec, escaped_app);\n         }\n \n       g_key_file_set_string (keyfile, groups[i], G_KEY_FILE_DESKTOP_KEY_EXEC, new_exec->str);\n     }\n \n   new_data = g_key_file_to_data (keyfile, &new_data_len, error);\n   if (new_data == NULL)\n     goto out;\n \n   if (!flatpak_open_in_tmpdir_at (parent_fd, 0755, tmpfile_name, &out_stream, cancellable, error))\n     goto out;\n \n   if (!g_output_stream_write_all (out_stream, new_data, new_data_len, NULL, cancellable, error))\n     goto out;\n \n   if (!g_output_stream_close (out_stream, cancellable, error))\n     goto out;\n \n   if (target)\n     *target = g_steal_pointer (&tmpfile_name);\n \n   ret = TRUE;\n out:\n \n   if (new_exec != NULL)\n     g_string_free (new_exec, TRUE);\n \n   return ret;\n }\n \n", "target": "// fix_start\n                {\n                  flatpak_fail_error (error, FLATPAK_ERROR_EXPORT_FAILED,\n                                     _(\"Invalid Exec argument %s\"), arg);\n                  goto out;\n                }\n// fix_end\n", "cwe": "CWE-94", "cwe_name": "Improper Control of Generation of Code ('Code Injection')", "cve": "CVE-2021-21381", "cve_desc": "Flatpak is a system for building, distributing, and running sandboxed desktop applications on Linux. In Flatpack since version 0.9.4 and before version 1.10.2 has a vulnerability in the \"file forwarding\" feature which can be used by an attacker to gain access to files that would not ordinarily be allowed by the app's permissions. By putting the special tokens `@@` and/or `@@u` in the Exec field of a Flatpak app's .desktop file, a malicious app publisher can trick flatpak into behaving as though the user had chosen to open a target file with their Flatpak app, which automatically makes that file available to the Flatpak app. This is fixed in version 1.10.2. A minimal solution is the first commit \"`Disallow @@ and @@U usage in desktop files`\". The follow-up commits \"`dir: Reserve the whole @@ prefix`\" and \"`dir: Refuse to export .desktop files with suspicious uses of @@ tokens`\" are recommended, but not strictly required. As a workaround, avoid installing Flatpak apps from untrusted sources, or check the contents of the exported `.desktop` files in `exports/share/applications/*.desktop` (typically `~/.local/share/flatpak/exports/share/applications/*.desktop` and `/var/lib/flatpak/exports/share/applications/*.desktop`) to make sure that literal filenames do not follow `@@` or `@@u`.", "project": "flatpak", "idx": 197260}
{"source": " Status SparseTensorToCSRSparseMatrixCPUFunctor::operator()(\n     const int64 batch_size, const int num_rows,\n     TTypes<int64>::ConstMatrix indices, TTypes<int32>::Vec batch_ptr,\n     TTypes<int32>::Vec csr_row_ptr, TTypes<int32>::Vec csr_col_ind) {\n   if (batch_ptr.size() != batch_size + 1) {\n     return errors::InvalidArgument(\n         \"Expected batch_ptr.size() == batch_size + 1. Got: \", batch_ptr.size(),\n         \" vs. \", batch_size + 1);\n   }\n   if (csr_row_ptr.size() != batch_size * (num_rows + 1)) {\n     return errors::InvalidArgument(\n         \"Expected csr_row_ptr.size() == batch_size * (num_rows + 1). Got: \",\n         csr_row_ptr.size(), \" vs. \", batch_size * (num_rows + 1));\n   }\n \n   const int64 total_nnz = indices.dimension(0);\n   const int rank = indices.dimension(1);\n   if (rank == 2 && batch_size != 1) {\n     return errors::InvalidArgument(\n         \"Expected batch_size == 1 when rank is 2. Got batch_size: \",\n         batch_size);\n   }\n   if (csr_col_ind.size() != total_nnz) {\n     return errors::InvalidArgument(\n         \"Expected csr_col_ind.size() == total_nnz. Got: \", csr_col_ind.size(),\n         \" vs. \", total_nnz);\n   }\n \n   int prev_batch = -1;\n   if (rank == 2) {\n     batch_ptr(0) = 0;\n     ++prev_batch;\n \n     for (int64 i = 0; i < total_nnz; ++i) {\n// bug_start\n// bug_end\n       csr_row_ptr(indices(i, 0) + 1) += 1;\n       csr_col_ind(i) = indices(i, 1);\n     }\n   } else {\n     for (int64 i = 0; i < total_nnz; ++i) {\n       const int cur_batch = indices(i, 0);\n       csr_row_ptr(cur_batch * (num_rows + 1) + indices(i, 1) + 1) += 1;\n       csr_col_ind(i) = indices(i, 2);\n \n       while (prev_batch < cur_batch) {\n         batch_ptr(prev_batch + 1) = i;\n         ++prev_batch;\n       }\n     }\n   }\n   while (prev_batch < batch_size) {\n     batch_ptr(prev_batch + 1) = total_nnz;\n     ++prev_batch;\n   }\n \n   for (int batch_idx = 0; batch_idx < batch_size; ++batch_idx) {\n     auto* row_ptr_batch = csr_row_ptr.data() + batch_idx * (num_rows + 1);\n     std::partial_sum(row_ptr_batch, row_ptr_batch + num_rows + 1,\n                      row_ptr_batch);\n   }\n   return Status::OK();\n }\n \n", "target": "// fix_start\n      int64 ix = indices(i, 0) + 1;\n      if (ix >= csr_row_ptr.size()) {\n        return errors::InvalidArgument(\"Got an index \", ix,\n                                       \" that is outside of csr_row_ptr\");\n      }\n// fix_end\n", "cwe": "CWE-369", "cwe_name": "Divide By Zero", "cve": "CVE-2021-29545", "cve_desc": "TensorFlow is an end-to-end open source platform for machine learning. An attacker can trigger a denial of service via a `CHECK`-fail in converting sparse tensors to CSR Sparse matrices. This is because the implementation(https://github.com/tensorflow/tensorflow/blob/800346f2c03a27e182dd4fba48295f65e7790739/tensorflow/core/kernels/sparse/kernels.cc#L66) does a double redirection to access an element of an array allocated on the heap. If the value at `indices(i, 0)` is such that `indices(i, 0) + 1` is outside the bounds of `csr_row_ptr`, this results in writing outside of bounds of heap allocated data. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.", "project": "tensorflow", "idx": 197301}
{"source": " TfLiteStatus EvalSimple(TfLiteContext* context, TfLiteNode* node,\n                         const TfLiteTensor* lookup, const TfLiteTensor* value,\n                         TfLiteTensor* output) {\n   const int row_size = SizeOfDimension(value, 0);\n// bug_start\n// bug_end\n   const int row_bytes = value->bytes / row_size;\n \n   char* output_raw = GetTensorData<char>(output);\n   const char* value_raw = GetTensorData<char>(value);\n   const int32_t* lookup_data = GetTensorData<int32_t>(lookup);\n   for (int i = 0; i < SizeOfDimension(lookup, 0); i++) {\n     int idx = lookup_data[i];\n     if (idx >= row_size || idx < 0) {\n       context->ReportError(context,\n                            \"Embedding Lookup: index out of bounds. \"\n                            \"Got %d, and bounds are [0, %d]\",\n                            idx, row_size - 1);\n       return kTfLiteError;\n     } else {\n       std::memcpy(output_raw + i * row_bytes, value_raw + idx * row_bytes,\n                   row_bytes);\n     }\n   }\n \n   return kTfLiteOk;\n }\n \n", "target": "// fix_start\n  if (row_size == 0) {\n    return kTfLiteOk;\n  }\n// fix_end\n", "cwe": "CWE-369", "cwe_name": "Divide By Zero", "cve": "CVE-2021-29596", "cve_desc": "TensorFlow is an end-to-end open source platform for machine learning. The implementation of the `EmbeddingLookup` TFLite operator is vulnerable to a division by zero error(https://github.com/tensorflow/tensorflow/blob/e4b29809543b250bc9b19678ec4776299dd569ba/tensorflow/lite/kernels/embedding_lookup.cc#L73-L74). An attacker can craft a model such that the first dimension of the `value` input is 0. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.", "project": "tensorflow", "idx": 197303}
{"source": "   explicit ReverseSequenceOp(OpKernelConstruction* context)\n       : OpKernel(context) {\n     OP_REQUIRES_OK(context, context->GetAttr(\"batch_dim\", &batch_dim_));\n     OP_REQUIRES_OK(context, context->GetAttr(\"seq_dim\", &seq_dim_));\n// bug_start\n// bug_end\n   }\n \n", "target": "// fix_start\n    OP_REQUIRES(context, batch_dim_ >= 0,\n                errors::InvalidArgument(\"Invalid batch_dim \", batch_dim_));\n    OP_REQUIRES(context, seq_dim_ >= 0,\n                errors::InvalidArgument(\"Invalid seq_dim \", seq_dim_));\n// fix_end\n", "cwe": "CWE-787", "cwe_name": "Out-of-bounds Write", "cve": "CVE-2021-29575", "cve_desc": "TensorFlow is an end-to-end open source platform for machine learning. The implementation of `tf.raw_ops.ReverseSequence` allows for stack overflow and/or `CHECK`-fail based denial of service. The implementation(https://github.com/tensorflow/tensorflow/blob/5b3b071975e01f0d250c928b2a8f901cd53b90a7/tensorflow/core/kernels/reverse_sequence_op.cc#L114-L118) fails to validate that `seq_dim` and `batch_dim` arguments are valid. Negative values for `seq_dim` can result in stack overflow or `CHECK`-failure, depending on the version of Eigen code used to implement the operation. Similar behavior can be exhibited by invalid values of `batch_dim`. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.", "project": "tensorflow", "idx": 197404}
{"source": " static int ssl_verify_cert(struct tunnel *tunnel)\n {\n \tint ret = -1;\n \tint cert_valid = 0;\n \tunsigned char digest[SHA256LEN];\n \tunsigned int len;\n \tstruct x509_digest *elem;\n \tchar digest_str[SHA256STRLEN], *subject, *issuer;\n \tchar *line;\n \tint i;\n \tX509_NAME *subj;\n \n \tSSL_set_verify(tunnel->ssl_handle, SSL_VERIFY_PEER, NULL);\n \n \tX509 *cert = SSL_get_peer_certificate(tunnel->ssl_handle);\n \tif (cert == NULL) {\n \t\tlog_error(\"Unable to get gateway certificate.\\n\");\n \t\treturn 1;\n \t}\n \n \tsubj = X509_get_subject_name(cert);\n \n #ifdef HAVE_X509_CHECK_HOST\n \tif (X509_check_host(cert, tunnel->config->gateway_host,\n \t                    0, 0, NULL) == 1)\n \t\tcert_valid = 1;\n #else\n// bug_start\n\tchar common_name[FIELD_SIZE + 1];\n\tif (subj\n\t    && X509_NAME_get_text_by_NID(subj, NID_commonName, common_name,\n\t                                 FIELD_SIZE) > 0\n\t    && strncasecmp(common_name, tunnel->config->gateway_host,\n\t                   FIELD_SIZE) == 0)\n\t\tcert_valid = 1;\n// bug_end\n #endif\n \n \tif (cert_valid\n \t    && SSL_get_verify_result(tunnel->ssl_handle) == X509_V_OK) {\n \t\tlog_debug(\"Gateway certificate validation succeeded.\\n\");\n \t\tret = 0;\n \t\tgoto free_cert;\n \t}\n \tlog_debug(\"Gateway certificate validation failed.\\n\");\n \n \tif (X509_digest(cert, EVP_sha256(), digest, &len) <= 0\n \t    || len != SHA256LEN) {\n \t\tlog_error(\"Could not compute certificate sha256 digest.\\n\");\n \t\tgoto free_cert;\n \t}\n \tfor (i = 0; i < SHA256LEN; i++)\n \t\tsprintf(&digest_str[2 * i], \"%02x\", digest[i]);\n \tdigest_str[SHA256STRLEN - 1] = '\\0';\n \tfor (elem = tunnel->config->cert_whitelist; elem != NULL;\n \t     elem = elem->next)\n \t\tif (memcmp(digest_str, elem->data, SHA256STRLEN - 1) == 0)\n \t\t\tbreak;\n \tif (elem != NULL) {\n \t\tlog_debug(\"Gateway certificate digest found in white list.\\n\");\n \t\tret = 0;\n \t\tgoto free_cert;\n \t}\n \n \tsubject = X509_NAME_oneline(subj, NULL, 0);\n \tissuer = X509_NAME_oneline(X509_get_issuer_name(cert), NULL, 0);\n \n \tlog_error(\"Gateway certificate validation failed, and the certificate digest in not in the local whitelist. If you trust it, rerun with:\\n\");\n \tlog_error(\"    --trusted-cert %s\\n\", digest_str);\n \tlog_error(\"or add this line to your config file:\\n\");\n \tlog_error(\"    trusted-cert = %s\\n\", digest_str);\n \tlog_error(\"Gateway certificate:\\n\");\n \tlog_error(\"    subject:\\n\");\n \tfor (line = strtok(subject, \"/\"); line != NULL;\n \t     line = strtok(NULL, \"/\"))\n \t\tlog_error(\"        %s\\n\", line);\n \tlog_error(\"    issuer:\\n\");\n \tfor (line = strtok(issuer, \"/\"); line != NULL;\n \t     line = strtok(NULL, \"/\"))\n \t\tlog_error(\"        %s\\n\", line);\n \tlog_error(\"    sha256 digest:\\n\");\n \tlog_error(\"        %s\\n\", digest_str);\n \n free_cert:\n \tX509_free(cert);\n \treturn ret;\n }\n \n", "target": "// fix_start\n\tif (validate_hostname(tunnel->config->gateway_host, cert) == MatchFound)\n \t\tcert_valid = 1;\n// fix_end\n", "cwe": "CWE-295", "cwe_name": "Improper Certificate Validation", "cve": "CVE-2020-7043", "cve_desc": "An issue was discovered in openfortivpn 1.11.0 when used with OpenSSL before 1.0.2. tunnel.c mishandles certificate validation because hostname comparisons do not consider '\\0' characters, as demonstrated by a good.example.com\\x00evil.example.com attack.", "project": "openfortivpn", "idx": 197415}
{"source": " void CleanWriters(GF_List *writers)\n {\n \twhile (gf_list_count(writers)) {\n \t\tTrackWriter *writer = (TrackWriter*)gf_list_get(writers, 0);\n// bug_start\n// bug_end\n \t\tgf_isom_box_del(writer->stco);\n \t\tgf_isom_box_del((GF_Box *)writer->stsc);\n \t\tgf_free(writer);\n \t\tgf_list_rem(writers, 0);\n \t}\n }\n \n", "target": "// fix_start\n\t\tgf_list_del_item(writer->stbl->child_boxes, writer->stco);\n\t\tgf_list_del_item(writer->stbl->child_boxes, writer->stsc);\n// fix_end\n", "cwe": "CWE-416", "cwe_name": "Use After Free", "cve": "CVE-2020-35980", "cve_desc": "An issue was discovered in GPAC version 0.8.0 and 1.0.1. There is a use-after-free in the function gf_isom_box_del() in isomedia/box_funcs.c.", "project": "gpac", "idx": 197417}
{"source": " GF_Err stbl_GetSampleInfos(GF_SampleTableBox *stbl, u32 sampleNumber, u64 *offset, u32 *chunkNumber, u32 *descIndex, GF_StscEntry **out_ent)\n {\n \tGF_Err e;\n \tu32 i, k, offsetInChunk, size, chunk_num;\n \tGF_ChunkOffsetBox *stco;\n \tGF_ChunkLargeOffsetBox *co64;\n \tGF_StscEntry *ent;\n \n \t(*offset) = 0;\n \t(*chunkNumber) = (*descIndex) = 0;\n \tif (out_ent) (*out_ent) = NULL;\n \tif (!stbl || !sampleNumber) return GF_BAD_PARAM;\n \tif (!stbl->ChunkOffset || !stbl->SampleToChunk || !stbl->SampleSize) return GF_ISOM_INVALID_FILE;\n \n \tif (stbl->SampleSize && stbl->SampleToChunk->nb_entries == stbl->SampleSize->sampleCount) {\n \t\tent = &stbl->SampleToChunk->entries[sampleNumber-1];\n \t\tif (!ent) return GF_BAD_PARAM;\n \t\t(*descIndex) = ent->sampleDescriptionIndex;\n \t\t(*chunkNumber) = sampleNumber;\n \t\tif (out_ent) *out_ent = ent;\n \t\tif ( stbl->ChunkOffset->type == GF_ISOM_BOX_TYPE_STCO) {\n \t\t\tstco = (GF_ChunkOffsetBox *)stbl->ChunkOffset;\n \t\t\tif (!stco->offsets) return GF_ISOM_INVALID_FILE;\n// bug_start\n// bug_end\n \n \t\t\t(*offset) = (u64) stco->offsets[sampleNumber - 1];\n \t\t} else {\n \t\t\tco64 = (GF_ChunkLargeOffsetBox *)stbl->ChunkOffset;\n \t\t\tif (!co64->offsets) return GF_ISOM_INVALID_FILE;\n// bug_start\n// bug_end\n \n \t\t\t(*offset) = co64->offsets[sampleNumber - 1];\n \t\t}\n \t\treturn GF_OK;\n \t}\n \n \tif (stbl->SampleToChunk->firstSampleInCurrentChunk &&\n \t        (stbl->SampleToChunk->firstSampleInCurrentChunk <= sampleNumber)) {\n \n \t\ti = stbl->SampleToChunk->currentIndex;\n \t\tent = &stbl->SampleToChunk->entries[stbl->SampleToChunk->currentIndex];\n \t\tGetGhostNum(ent, i, stbl->SampleToChunk->nb_entries, stbl);\n \t\tk = stbl->SampleToChunk->currentChunk;\n \t}\n \telse {\n \t\ti = 0;\n \t\tstbl->SampleToChunk->currentIndex = 0;\n \t\tstbl->SampleToChunk->currentChunk = 1;\n \t\tstbl->SampleToChunk->ghostNumber = 1;\n \t\tstbl->SampleToChunk->firstSampleInCurrentChunk = 1;\n \t\tent = &stbl->SampleToChunk->entries[0];\n \t\tGetGhostNum(ent, 0, stbl->SampleToChunk->nb_entries, stbl);\n \t\tk = stbl->SampleToChunk->currentChunk;\n \t}\n \n \tfor (; i < stbl->SampleToChunk->nb_entries; i++) {\n \t\tassert(stbl->SampleToChunk->firstSampleInCurrentChunk <= sampleNumber);\n \t\tif (k > stbl->SampleToChunk->ghostNumber) {\n \t\t\treturn GF_ISOM_INVALID_FILE;\n \t\t}\n \n \n \t\tu32 max_chunks_in_entry = stbl->SampleToChunk->ghostNumber - k;\n \t\tu32 nb_chunks_for_sample = sampleNumber - stbl->SampleToChunk->firstSampleInCurrentChunk;\n \t\tif (ent->samplesPerChunk)\n \t\t\tnb_chunks_for_sample /= ent->samplesPerChunk;\n \n \t\tif (\n \t\t\t(nb_chunks_for_sample <= max_chunks_in_entry)\n \t\t\t&& (stbl->SampleToChunk->firstSampleInCurrentChunk + (nb_chunks_for_sample+1) * ent->samplesPerChunk > sampleNumber)\n \t\t) {\n \n \t\t\tstbl->SampleToChunk->firstSampleInCurrentChunk += nb_chunks_for_sample * ent->samplesPerChunk;\n \t\t\tstbl->SampleToChunk->currentChunk += nb_chunks_for_sample;\n \t\t\tgoto sample_found;\n \t\t}\n \t\tmax_chunks_in_entry += 1;\n \t\tstbl->SampleToChunk->firstSampleInCurrentChunk += max_chunks_in_entry * ent->samplesPerChunk;\n \t\tstbl->SampleToChunk->currentChunk += max_chunks_in_entry;\n \n \t\tif (i+1 != stbl->SampleToChunk->nb_entries) {\n \t\t\tent = &stbl->SampleToChunk->entries[i+1];\n \t\t\tGetGhostNum(ent, i+1, stbl->SampleToChunk->nb_entries, stbl);\n \t\t\tstbl->SampleToChunk->currentIndex = i+1;\n \t\t\tstbl->SampleToChunk->currentChunk = 1;\n \t\t\tk = 1;\n \t\t}\n \t}\n \treturn GF_ISOM_INVALID_FILE;\n \n sample_found:\n \n \t(*descIndex) = ent->sampleDescriptionIndex;\n \t(*chunkNumber) = chunk_num = ent->firstChunk + stbl->SampleToChunk->currentChunk - 1;\n \tif (out_ent) *out_ent = ent;\n \tif (! *chunkNumber)\n \t\treturn GF_ISOM_INVALID_FILE;\n \n \toffsetInChunk = 0;\n \tif (stbl->SampleSize && stbl->SampleSize->sampleSize) {\n \t\tu32 diff = sampleNumber - stbl->SampleToChunk->firstSampleInCurrentChunk;\n \t\toffsetInChunk += diff * stbl->SampleSize->sampleSize;\n \t} else if ((stbl->r_last_chunk_num == chunk_num) && (stbl->r_last_sample_num == sampleNumber)) {\n \t\toffsetInChunk = stbl->r_last_offset_in_chunk;\n \t} else if ((stbl->r_last_chunk_num == chunk_num) && (stbl->r_last_sample_num + 1 == sampleNumber)) {\n \t\te = stbl_GetSampleSize(stbl->SampleSize, stbl->r_last_sample_num, &size);\n \t\tif (e) return e;\n \t\tstbl->r_last_offset_in_chunk += size;\n \t\tstbl->r_last_sample_num = sampleNumber;\n \t\toffsetInChunk = stbl->r_last_offset_in_chunk;\n \t} else {\n \t\tfor (i = stbl->SampleToChunk->firstSampleInCurrentChunk; i < sampleNumber; i++) {\n \t\t\te = stbl_GetSampleSize(stbl->SampleSize, i, &size);\n \t\t\tif (e) return e;\n \t\t\toffsetInChunk += size;\n \t\t}\n \t\tstbl->r_last_chunk_num = chunk_num;\n \t\tstbl->r_last_sample_num = sampleNumber;\n \t\tstbl->r_last_offset_in_chunk = offsetInChunk;\n \t}\n \tif ( stbl->ChunkOffset->type == GF_ISOM_BOX_TYPE_STCO) {\n \t\tstco = (GF_ChunkOffsetBox *)stbl->ChunkOffset;\n \t\tif (stco->nb_entries < (*chunkNumber) ) return GF_ISOM_INVALID_FILE;\n \t\t(*offset) = (u64) stco->offsets[(*chunkNumber) - 1] + (u64) offsetInChunk;\n \t} else {\n \t\tco64 = (GF_ChunkLargeOffsetBox *)stbl->ChunkOffset;\n \t\tif (co64->nb_entries < (*chunkNumber) ) return GF_ISOM_INVALID_FILE;\n \t\t(*offset) = co64->offsets[(*chunkNumber) - 1] + (u64) offsetInChunk;\n \t}\n \treturn GF_OK;\n }\n \n", "target": "// fix_start\n\t\t\tif (stco->nb_entries < sampleNumber) return GF_ISOM_INVALID_FILE;\n// fix_end\n// fix_start\n\t\t\tif (co64->nb_entries < sampleNumber) return GF_ISOM_INVALID_FILE;\n// fix_end\n", "cwe": "CWE-416", "cwe_name": "Use After Free", "cve": "CVE-2021-31256", "cve_desc": "Memory leak in the stbl_GetSampleInfos function in MP4Box in GPAC 1.0.1 allows attackers to read memory via a crafted file.", "project": "gpac", "idx": 197433}
{"source": " static mf_t *open_mf_pattern(void *talloc_ctx, struct demuxer *d, char *filename)\n {\n     struct mp_log *log = d->log;\n     int error_count = 0;\n     int count = 0;\n \n     mf_t *mf = talloc_zero(talloc_ctx, mf_t);\n     mf->log = log;\n \n     if (filename[0] == '@') {\n         struct stream *s = stream_create(filename + 1,\n                             d->stream_origin | STREAM_READ, d->cancel, d->global);\n         if (s) {\n             while (1) {\n                 char buf[512];\n                 int len = stream_read_peek(s, buf, sizeof(buf));\n                 if (!len)\n                     break;\n                 bstr data = (bstr){buf, len};\n                 int pos = bstrchr(data, '\\n');\n                 data = bstr_splice(data, 0, pos < 0 ? data.len : pos + 1);\n                 bstr fname = bstr_strip(data);\n                 if (fname.len) {\n                     if (bstrchr(fname, '\\0') >= 0) {\n                         mp_err(log, \"invalid filename\\n\");\n                         break;\n                     }\n                     char *entry = bstrto0(mf, fname);\n                     if (!mp_path_exists(entry)) {\n                         mp_verbose(log, \"file not found: '%s'\\n\", entry);\n                     } else {\n                         MP_TARRAY_APPEND(mf, mf->names, mf->nr_of_files, entry);\n                     }\n                 }\n                 stream_seek_skip(s, stream_tell(s) + data.len);\n             }\n             free_stream(s);\n \n             mp_info(log, \"number of files: %d\\n\", mf->nr_of_files);\n             goto exit_mf;\n         }\n         mp_info(log, \"%s is not indirect filelist\\n\", filename + 1);\n     }\n \n     if (strchr(filename, ',')) {\n         mp_info(log, \"filelist: %s\\n\", filename);\n         bstr bfilename = bstr0(filename);\n \n         while (bfilename.len) {\n             bstr bfname;\n             bstr_split_tok(bfilename, \",\", &bfname, &bfilename);\n             char *fname2 = bstrdup0(mf, bfname);\n \n             if (!mp_path_exists(fname2))\n                 mp_verbose(log, \"file not found: '%s'\\n\", fname2);\n             else {\n                 mf_add(mf, fname2);\n             }\n             talloc_free(fname2);\n         }\n         mp_info(log, \"number of files: %d\\n\", mf->nr_of_files);\n \n         goto exit_mf;\n     }\n \n// bug_start\n    char *fname = talloc_size(mf, strlen(filename) + 32);\n// bug_end\n \n #if HAVE_GLOB\n     if (!strchr(filename, '%')) {\n         strcpy(fname, filename);\n         if (!strchr(filename, '*'))\n             strcat(fname, \"*\");\n \n         mp_info(log, \"search expr: %s\\n\", fname);\n \n         glob_t gg;\n         if (glob(fname, 0, NULL, &gg)) {\n             talloc_free(mf);\n             return NULL;\n         }\n \n         for (int i = 0; i < gg.gl_pathc; i++) {\n             if (mp_path_isdir(gg.gl_pathv[i]))\n                 continue;\n             mf_add(mf, gg.gl_pathv[i]);\n         }\n         mp_info(log, \"number of files: %d\\n\", mf->nr_of_files);\n         globfree(&gg);\n         goto exit_mf;\n     }\n #endif\n \n// bug_start\n// bug_end\n     mp_info(log, \"search expr: %s\\n\", filename);\n \n     while (error_count < 5) {\n// bug_start\n        sprintf(fname, filename, count++);\n// bug_end\n         if (!mp_path_exists(fname)) {\n             error_count++;\n             mp_verbose(log, \"file not found: '%s'\\n\", fname);\n         } else {\n             mf_add(mf, fname);\n         }\n     }\n \n     mp_info(log, \"number of files: %d\\n\", mf->nr_of_files);\n \n exit_mf:\n     return mf;\n }\n \n", "target": "// fix_start\n    size_t fname_avail = strlen(filename) + 32;\n    char *fname = talloc_size(mf, fname_avail);\n// fix_end\n// fix_start\n    const char *f = filename;\n    int MAXDIGS = 3, nspec = 0, bad_spec = 0, c;\n\n    while (nspec < 2 && (c = *f++)) {\n        if (c != '%')\n            continue;\n        if (*f != '%') {\n            nspec++;\n            if (*f == '.')\n                f++;\n            for (int ndig = 0; mp_isdigit(*f) && ndig < MAXDIGS; ndig++, f++)\n                ;\n            if (*f != 'd') {\n                bad_spec++;\n                break;\n            }\n        }\n        f++;\n    }\n\n    if (bad_spec || nspec != 1) {\n        mp_err(log, \"unsupported expr format: '%s'\\n\", filename);\n        goto exit_mf;\n    }\n\n// fix_end\n// fix_start\n        if (snprintf(fname, fname_avail, filename, count++) >= fname_avail) {\n            mp_err(log, \"format result too long: '%s'\\n\", filename);\n            goto exit_mf;\n        }\n// fix_end\n", "cwe": "CWE-134", "cwe_name": "Use of Externally-Controlled Format String", "cve": "CVE-2021-30145", "cve_desc": "A format string vulnerability in mpv through 0.33.0 allows user-assisted remote attackers to achieve code execution via a crafted m3u playlist file.", "project": "mpv", "idx": 197465}
{"source": " CallResult<bool> JSObject::putComputedWithReceiver_RJS(\n     Handle<JSObject> selfHandle,\n     Runtime *runtime,\n     Handle<> nameValHandle,\n     Handle<> valueHandle,\n     Handle<> receiver,\n     PropOpFlags opFlags) {\n   assert(\n       !opFlags.getMustExist() &&\n       \"mustExist flag cannot be used with computed properties\");\n \n   if (selfHandle->flags_.fastIndexProperties) {\n     if (auto arrayIndex = toArrayIndexFastPath(*nameValHandle)) {\n       if (selfHandle.getHermesValue().getRaw() == receiver->getRaw()) {\n         if (haveOwnIndexed(selfHandle.get(), runtime, *arrayIndex)) {\n           auto result =\n               setOwnIndexed(selfHandle, runtime, *arrayIndex, valueHandle);\n           if (LLVM_UNLIKELY(result == ExecutionStatus::EXCEPTION))\n             return ExecutionStatus::EXCEPTION;\n           if (LLVM_LIKELY(*result))\n             return true;\n           if (opFlags.getThrowOnError()) {\n             return runtime->raiseTypeError(\n                 \"Cannot assign to read-only property\");\n           }\n           return false;\n         }\n       }\n     }\n   }\n \n   auto converted = toPropertyKeyIfObject(runtime, nameValHandle);\n   if (LLVM_UNLIKELY(converted == ExecutionStatus::EXCEPTION)) {\n     return ExecutionStatus::EXCEPTION;\n   }\n   auto nameValPrimitiveHandle = *converted;\n \n   ComputedPropertyDescriptor desc;\n \n   MutableHandle<JSObject> propObj{runtime};\n   if (LLVM_UNLIKELY(\n           getComputedPrimitiveDescriptor(\n               selfHandle, runtime, nameValPrimitiveHandle, propObj, desc) ==\n           ExecutionStatus::EXCEPTION)) {\n     return ExecutionStatus::EXCEPTION;\n   }\n \n   if (propObj) {\n \n     if (LLVM_LIKELY(\n             selfHandle == propObj &&\n             selfHandle.getHermesValue().getRaw() == receiver->getRaw() &&\n             !desc.flags.accessor && !desc.flags.internalSetter &&\n             !desc.flags.hostObject && !desc.flags.proxyObject &&\n             desc.flags.writable)) {\n       if (LLVM_UNLIKELY(\n               setComputedSlotValue(selfHandle, runtime, desc, valueHandle) ==\n               ExecutionStatus::EXCEPTION)) {\n         return ExecutionStatus::EXCEPTION;\n       }\n       return true;\n     }\n \n     if (LLVM_UNLIKELY(desc.flags.accessor)) {\n       auto *accessor = vmcast<PropertyAccessor>(\n           getComputedSlotValue(propObj.get(), runtime, desc));\n \n       if (!accessor->setter) {\n         if (opFlags.getThrowOnError()) {\n           return runtime->raiseTypeErrorForValue(\n               \"Cannot assign to property \",\n               nameValPrimitiveHandle,\n               \" which has only a getter\");\n         }\n         return false;\n       }\n \n       if (accessor->setter.get(runtime)->executeCall1(\n               runtime->makeHandle(accessor->setter),\n               runtime,\n               receiver,\n               valueHandle.get()) == ExecutionStatus::EXCEPTION) {\n         return ExecutionStatus::EXCEPTION;\n       }\n       return true;\n     }\n \n     if (LLVM_UNLIKELY(desc.flags.proxyObject)) {\n       assert(\n           !opFlags.getMustExist() &&\n           \"MustExist cannot be used with Proxy objects\");\n       CallResult<Handle<>> key = toPropertyKey(runtime, nameValPrimitiveHandle);\n       if (key == ExecutionStatus::EXCEPTION)\n         return ExecutionStatus::EXCEPTION;\n       CallResult<bool> setRes =\n           JSProxy::setComputed(propObj, runtime, *key, valueHandle, receiver);\n       if (LLVM_UNLIKELY(setRes == ExecutionStatus::EXCEPTION)) {\n         return ExecutionStatus::EXCEPTION;\n       }\n       if (!*setRes && opFlags.getThrowOnError()) {\n         return runtime->raiseTypeError(\n             TwineChar16(\"Proxy trap returned false for property\"));\n       }\n       return setRes;\n     }\n \n     if (LLVM_UNLIKELY(!desc.flags.writable)) {\n       if (desc.flags.staticBuiltin) {\n         SymbolID id{};\n         LAZY_TO_IDENTIFIER(runtime, nameValPrimitiveHandle, id);\n         return raiseErrorForOverridingStaticBuiltin(\n             selfHandle, runtime, runtime->makeHandle(id));\n       }\n       if (opFlags.getThrowOnError()) {\n         return runtime->raiseTypeErrorForValue(\n             \"Cannot assign to read-only property \", nameValPrimitiveHandle, \"\");\n       }\n       return false;\n     }\n \n     if (selfHandle == propObj && desc.flags.internalSetter) {\n       SymbolID id{};\n       LAZY_TO_IDENTIFIER(runtime, nameValPrimitiveHandle, id);\n       return internalSetter(\n           selfHandle,\n           runtime,\n           id,\n           desc.castToNamedPropertyDescriptorRef(),\n           valueHandle,\n           opFlags);\n     }\n   }\n \n \n   MutableHandle<JSObject> receiverHandle{runtime, *selfHandle};\n   if (selfHandle.getHermesValue().getRaw() != receiver->getRaw() ||\n       receiverHandle->isHostObject() || receiverHandle->isProxyObject()) {\n     if (selfHandle.getHermesValue().getRaw() != receiver->getRaw()) {\n       receiverHandle = dyn_vmcast<JSObject>(*receiver);\n     }\n     if (!receiverHandle) {\n       return false;\n     }\n     CallResult<bool> descDefinedRes = getOwnComputedPrimitiveDescriptor(\n         receiverHandle, runtime, nameValPrimitiveHandle, IgnoreProxy::No, desc);\n     if (LLVM_UNLIKELY(descDefinedRes == ExecutionStatus::EXCEPTION)) {\n       return ExecutionStatus::EXCEPTION;\n     }\n     DefinePropertyFlags dpf;\n     if (*descDefinedRes) {\n       if (LLVM_UNLIKELY(desc.flags.accessor || !desc.flags.writable)) {\n         return false;\n       }\n \n       if (LLVM_LIKELY(\n               !desc.flags.internalSetter && !receiverHandle->isHostObject() &&\n               !receiverHandle->isProxyObject())) {\n         if (LLVM_UNLIKELY(\n                 setComputedSlotValue(\n                     receiverHandle, runtime, desc, valueHandle) ==\n                 ExecutionStatus::EXCEPTION)) {\n           return ExecutionStatus::EXCEPTION;\n         }\n         return true;\n       }\n     }\n \n     if (LLVM_UNLIKELY(\n             desc.flags.internalSetter || receiverHandle->isHostObject() ||\n             receiverHandle->isProxyObject())) {\n// bug_start\n// bug_end\n       SymbolID id{};\n       LAZY_TO_IDENTIFIER(runtime, nameValPrimitiveHandle, id);\n       if (desc.flags.internalSetter) {\n         return internalSetter(\n             receiverHandle,\n             runtime,\n             id,\n             desc.castToNamedPropertyDescriptorRef(),\n             valueHandle,\n             opFlags);\n// bug_start\n      } else if (receiverHandle->isHostObject()) {\n        return vmcast<HostObject>(receiverHandle.get())->set(id, *valueHandle);\n// bug_end\n       }\n       assert(\n// bug_start\n          receiverHandle->isProxyObject() && \"descriptor flags are impossible\");\n      if (*descDefinedRes) {\n        dpf.setValue = 1;\n      } else {\n        dpf = DefinePropertyFlags::getDefaultNewPropertyFlags();\n      }\n      return JSProxy::defineOwnProperty(\n          receiverHandle,\n          runtime,\n          nameValPrimitiveHandle,\n          dpf,\n          valueHandle,\n          opFlags);\n// bug_end\n     }\n   }\n \n   if (LLVM_UNLIKELY(!receiverHandle->isExtensible())) {\n     if (opFlags.getThrowOnError()) {\n       return runtime->raiseTypeError(\n           \"cannot add a new property\");\n     }\n     return false;\n   }\n \n   if (receiverHandle->flags_.indexedStorage) {\n     OptValue<uint32_t> arrayIndex;\n     MutableHandle<StringPrimitive> strPrim{runtime};\n     TO_ARRAY_INDEX(runtime, nameValPrimitiveHandle, strPrim, arrayIndex);\n     if (arrayIndex) {\n       if (auto *array = dyn_vmcast<JSArray>(receiverHandle.get())) {\n         if (LLVM_UNLIKELY(*arrayIndex >= JSArray::getLength(array))) {\n           auto cr = putNamed_RJS(\n               receiverHandle,\n               runtime,\n               Predefined::getSymbolID(Predefined::length),\n               runtime->makeHandle(\n                   HermesValue::encodeNumberValue(*arrayIndex + 1)),\n               opFlags);\n           if (LLVM_UNLIKELY(cr == ExecutionStatus::EXCEPTION))\n             return ExecutionStatus::EXCEPTION;\n           if (LLVM_UNLIKELY(!*cr))\n             return false;\n         }\n       }\n \n       auto result =\n           setOwnIndexed(receiverHandle, runtime, *arrayIndex, valueHandle);\n       if (LLVM_UNLIKELY(result == ExecutionStatus::EXCEPTION))\n         return ExecutionStatus::EXCEPTION;\n       if (LLVM_LIKELY(*result))\n         return true;\n \n       if (opFlags.getThrowOnError()) {\n         return runtime->raiseTypeError(\"Cannot assign to read-only property\");\n       }\n       return false;\n     }\n   }\n \n   SymbolID id{};\n   LAZY_TO_IDENTIFIER(runtime, nameValPrimitiveHandle, id);\n \n   return addOwnProperty(\n       receiverHandle,\n       runtime,\n       id,\n       DefinePropertyFlags::getDefaultNewPropertyFlags(),\n       valueHandle,\n       opFlags);\n }\n \n", "target": "// fix_start\n      if (receiverHandle->isProxyObject()) {\n        if (*descDefinedRes) {\n          dpf.setValue = 1;\n        } else {\n          dpf = DefinePropertyFlags::getDefaultNewPropertyFlags();\n        }\n        return JSProxy::defineOwnProperty(\n            receiverHandle,\n            runtime,\n            nameValPrimitiveHandle,\n            dpf,\n            valueHandle,\n            opFlags);\n      }\n// fix_end\n// fix_start\n// fix_end\n// fix_start\n          receiverHandle->isHostObject() && \"descriptor flags are impossible\");\n      return vmcast<HostObject>(receiverHandle.get())->set(id, *valueHandle);\n// fix_end\n", "cwe": "CWE-125", "cwe_name": "Out-of-bounds Read", "cve": "CVE-2020-1915", "cve_desc": "An out-of-bounds read in the JavaScript Interpreter in Facebook Hermes prior to commit 8cb935cd3b2321c46aa6b7ed8454d95c75a7fca0 allows attackers to cause a denial of service attack or possible further memory corruption via crafted JavaScript. Note that this is only exploitable if the application using Hermes permits evaluation of untrusted JavaScript. Hence, most React Native applications are not affected.", "project": "hermes", "idx": 197476}
{"source": "   void Compute(OpKernelContext* context) override {\n     std::unordered_map<int64, int64> old_row_to_new_row_map;\n     std::vector<bool> row_id_present;\n     const Tensor* row_remapping_t;\n     OP_REQUIRES_OK(context, context->input(\"row_remapping\", &row_remapping_t));\n     const auto row_remapping = row_remapping_t->vec<int64>();\n     OP_REQUIRES(context, row_remapping.size() == num_rows_,\n                 errors::InvalidArgument(strings::StrCat(\n                     \"Size of row_remapping is \", row_remapping.size(),\n                     \" instead of being equal to num_rows=\", num_rows_)));\n     OP_REQUIRES_OK(context, RemapVectorToMap(row_remapping, &row_id_present,\n                                              &old_row_to_new_row_map));\n \n     int64 min_old_row = -1;\n     int64 max_old_row = -1;\n     for (int i = 0; i < row_remapping.size(); ++i) {\n       if (min_old_row < 0 ||\n           (row_remapping(i) >= 0 && row_remapping(i) < min_old_row)) {\n         min_old_row = row_remapping(i);\n       }\n       if (max_old_row < 0 ||\n           (row_remapping(i) >= 0 && row_remapping(i) > max_old_row)) {\n         max_old_row = row_remapping(i);\n       }\n     }\n \n     std::unordered_map<int64, int64> old_col_to_new_col_map;\n     std::vector<bool> col_id_present;\n     const Tensor* col_remapping_t;\n     OP_REQUIRES_OK(context, context->input(\"col_remapping\", &col_remapping_t));\n     const auto col_remapping = col_remapping_t->vec<int64>();\n     const bool remap_cols = col_remapping.size() > 0;\n     if (remap_cols) {\n       OP_REQUIRES(\n           context, col_remapping.size() == num_cols_,\n           errors::InvalidArgument(strings::StrCat(\n               \"Provided col_remapping, but its size is \", col_remapping.size(),\n               \" instead of being equal to num_cols=\", num_cols_)));\n       OP_REQUIRES_OK(context, RemapVectorToMap(col_remapping, &col_id_present,\n                                                &old_col_to_new_col_map));\n     } else {\n       col_id_present.clear();\n       col_id_present.resize(num_cols_, true);\n     }\n \n     const Tensor* ckpt_path_t;\n     OP_REQUIRES_OK(context, context->input(\"ckpt_path\", &ckpt_path_t));\n// bug_start\n// bug_end\n     const string& ckpt_path = ckpt_path_t->scalar<tstring>()();\n     const Tensor* old_tensor_name_t;\n     OP_REQUIRES_OK(context,\n                    context->input(\"old_tensor_name\", &old_tensor_name_t));\n     const string& old_tensor_name = old_tensor_name_t->scalar<tstring>()();\n \n     LOG(INFO) << \"Processing checkpoint : \" << ckpt_path;\n     BundleReader reader(context->env(), ckpt_path);\n     OP_REQUIRES_OK(context, reader.status());\n \n     DataType tensor_type;\n     TensorShape tensor_shape;\n     OP_REQUIRES_OK(context, reader.LookupDtypeAndShape(\n                                 old_tensor_name, &tensor_type, &tensor_shape));\n     OP_REQUIRES(context, tensor_type == DT_FLOAT,\n                 errors::InvalidArgument(strings::StrCat(\n                     \"Tensor \", old_tensor_name, \" has invalid type \",\n                     DataTypeString(tensor_type), \" instead of expected type \",\n                     DataTypeString(DT_FLOAT))));\n     OP_REQUIRES(\n         context, tensor_shape.dims() == 2,\n         errors::InvalidArgument(strings::StrCat(\n             \"Tensor \", old_tensor_name, \" has shape \",\n             tensor_shape.DebugString(), \" of invalid rank \",\n             tensor_shape.dims(), \" instead of expected shape of rank 2.\")));\n \n     if (!remap_cols) {\n       OP_REQUIRES(context, num_cols_ == tensor_shape.dim_size(1),\n                   errors::InvalidArgument(strings::StrCat(\n                       \"Tensor \", old_tensor_name, \" has shape \",\n                       tensor_shape.DebugString(),\n                       \", where the size of its 2nd dimension is \",\n                       tensor_shape.dim_size(1),\n                       \" instead of being equal to num_cols=\", num_cols_)));\n     }\n \n     std::vector<TensorSlice> tensor_slices;\n     TensorSlice slice(tensor_shape.dims());\n     if (min_old_row >= 0 && max_old_row >= 0) {\n       int64 row_start = min_old_row;\n       while (row_start <= max_old_row) {\n         const int64 slice_length =\n             max_rows_in_memory_ <= 0\n                 ? max_old_row - row_start + 1\n                 : std::min(max_rows_in_memory_, max_old_row - row_start + 1);\n         slice.set_start(0, row_start);\n         slice.set_length(0, slice_length);\n         tensor_slices.push_back(slice);\n         row_start += slice_length;\n       }\n     }\n \n     Tensor* output_matrix_t = nullptr;\n     OP_REQUIRES_OK(context,\n                    context->allocate_output(\"output_matrix\",\n                                             TensorShape({num_rows_, num_cols_}),\n                                             &output_matrix_t));\n     auto output_matrix = output_matrix_t->matrix<float>();\n \n     int64 row_index = min_old_row;\n     int64 rows_copied = 0;\n     Tensor loaded_tensor_t;\n     for (const TensorSlice& tensor_slice : tensor_slices) {\n       LOG(INFO) << \"Loading slice \" << tensor_slice.DebugString();\n       TensorShape slice_shape;\n       OP_REQUIRES_OK(context,\n                      tensor_slice.SliceTensorShape(tensor_shape, &slice_shape));\n       if (loaded_tensor_t.shape() != slice_shape) {\n         loaded_tensor_t = Tensor(DT_FLOAT, slice_shape);\n       }\n       OP_REQUIRES_OK(context, reader.LookupSlice(old_tensor_name, tensor_slice,\n                                                  &loaded_tensor_t));\n \n       for (int row = 0; row < loaded_tensor_t.dim_size(0); ++row, ++row_index) {\n         if (row_index % 500000 == min_old_row) {\n           LOG(INFO) << \"Processing old row \" << row_index;\n         }\n \n         const int64* new_row_ptr =\n             gtl::FindOrNull(old_row_to_new_row_map, row_index);\n         if (new_row_ptr == nullptr) {\n           continue;\n         }\n         ++rows_copied;\n         const int64 new_row = *new_row_ptr;\n \n         const auto& loaded_tensor = loaded_tensor_t.matrix<float>();\n         for (int old_col = 0; old_col < loaded_tensor_t.dim_size(1);\n              ++old_col) {\n           int64 new_col = old_col;\n           if (remap_cols) {\n             const int64* new_col_ptr =\n                 gtl::FindOrNull(old_col_to_new_col_map, old_col);\n             if (new_col_ptr == nullptr) {\n               continue;\n             }\n             new_col = *new_col_ptr;\n           }\n \n           OP_REQUIRES(context,\n                       new_row < num_rows_ && new_col < num_cols_ &&\n                           new_row >= 0 && new_col >= 0,\n                       errors::Internal(strings::StrCat(\n                           \"new_row=\", new_row, \" and new_col=\", new_col,\n                           \" should have been less than num_rows_=\", num_rows_,\n                           \" and num_cols_=\", num_cols_,\n                           \" and non-negative. This should never have happened \"\n                           \"if the code were correct. Please file a bug.\")));\n           output_matrix(new_row, new_col) = loaded_tensor(row, old_col);\n         }\n       }\n     }\n     LOG(INFO) << \"Copied \" << rows_copied << \" rows from old matrix (with \"\n               << tensor_shape.dim_size(0) << \" rows) to new matrix (with \"\n               << num_rows_ << \" rows).\";\n \n     const Tensor* initializing_values_t;\n     OP_REQUIRES_OK(\n         context, context->input(\"initializing_values\", &initializing_values_t));\n     const auto initializing_values = initializing_values_t->flat<float>();\n     int64 initializing_values_index = 0;\n     for (int i = 0; i < num_rows_; ++i) {\n       for (int j = 0; j < num_cols_; ++j) {\n         if (row_id_present[i] && col_id_present[j]) continue;\n         OP_REQUIRES(\n             context, initializing_values_index < initializing_values.size(),\n             errors::InvalidArgument(\n                 \"initializing_values contained \", initializing_values.size(),\n                 \" elements, but more missing values remain.\"));\n         output_matrix(i, j) = initializing_values(initializing_values_index);\n         ++initializing_values_index;\n       }\n     }\n \n     OP_REQUIRES(\n         context, initializing_values_index == initializing_values.size(),\n         errors::InvalidArgument(\n             \"initializing_values contained \", initializing_values.size(),\n             \" elements, but only \", initializing_values_index,\n             \" elements were used to fill in missing values.\"));\n   }\n \n", "target": "// fix_start\n    OP_REQUIRES(\n        context, ckpt_path_t->NumElements() == 1,\n        errors::InvalidArgument(\"The `ckpt_path` tensor must have exactly one \"\n                                \"element, got tensor of shape \",\n                                ckpt_path_t->shape().DebugString()));\n// fix_end\n", "cwe": "CWE-369", "cwe_name": "Divide By Zero", "cve": "CVE-2021-29561", "cve_desc": "TensorFlow is an end-to-end open source platform for machine learning. An attacker can cause a denial of service by exploiting a `CHECK`-failure coming from `tf.raw_ops.LoadAndRemapMatrix`. This is because the implementation(https://github.com/tensorflow/tensorflow/blob/d94227d43aa125ad8b54115c03cece54f6a1977b/tensorflow/core/kernels/ragged_tensor_to_tensor_op.cc#L219-L222) assumes that the `ckpt_path` is always a valid scalar. However, an attacker can send any other tensor as the first argument of `LoadAndRemapMatrix`. This would cause the rank `CHECK` in `scalar<T>()()` to trigger and terminate the process. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.", "project": "tensorflow", "idx": 197512}
{"source": "   void Compute(OpKernelContext* ctx) override {\n     const Tensor& input = ctx->input(0);\n// bug_start\n// bug_end\n     const float input_min_float = ctx->input(1).flat<float>()(0);\n     const float input_max_float = ctx->input(2).flat<float>()(0);\n     Tensor* output_min = nullptr;\n     OP_REQUIRES_OK(ctx, ctx->allocate_output(0, TensorShape({}), &output_min));\n     Tensor* output_max = nullptr;\n     OP_REQUIRES_OK(ctx, ctx->allocate_output(1, TensorShape({}), &output_max));\n \n     qint32 used_min_quantized;\n     qint32 used_max_quantized;\n     CalculateUsedRange(input, &used_min_quantized, &used_max_quantized);\n \n     const float used_min_float = std::min(\n         0.0f,\n         QuantizedToFloat(used_min_quantized, input_min_float, input_max_float));\n     const float used_max_float =\n         QuantizedToFloat(used_max_quantized, input_min_float, input_max_float);\n \n     output_min->flat<float>().setConstant(used_min_float);\n     output_max->flat<float>().setConstant(used_max_float);\n   }\n \n", "target": "// fix_start\n    OP_REQUIRES(ctx, ctx->input(1).NumElements() > 0,\n                errors::InvalidArgument(\"Input min must not be empty.\"));\n    OP_REQUIRES(ctx, ctx->input(2).NumElements() > 0,\n                errors::InvalidArgument(\"Input max must not be empty.\"));\n// fix_end\n", "cwe": "CWE-125", "cwe_name": "Out-of-bounds Read", "cve": "CVE-2021-29569", "cve_desc": "TensorFlow is an end-to-end open source platform for machine learning. The implementation of `tf.raw_ops.MaxPoolGradWithArgmax` can cause reads outside of bounds of heap allocated data if attacker supplies specially crafted inputs. The implementation(https://github.com/tensorflow/tensorflow/blob/ac328eaa3870491ababc147822cd04e91a790643/tensorflow/core/kernels/requantization_range_op.cc#L49-L50) assumes that the `input_min` and `input_max` tensors have at least one element, as it accesses the first element in two arrays. If the tensors are empty, `.flat<T>()` is an empty object, backed by an empty array. Hence, accesing even the 0th element is a read outside the bounds. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.", "project": "tensorflow", "idx": 197575}
{"source": "   void Compute(OpKernelContext* ctx) override {\n     const Tensor& shape_t = ctx->input(0);\n     const Tensor& alpha_t = ctx->input(1);\n \n     OP_REQUIRES(ctx,\n                 TensorShapeUtils::IsVector(shape_t.shape()) &&\n                     (shape_t.dtype() == DataType::DT_INT32 ||\n                      shape_t.dtype() == DataType::DT_INT64),\n                 errors::InvalidArgument(\n                     \"shape must be a vector of {int32,int64}, got shape: \",\n                     shape_t.DebugString()));\n     TensorShape samples_shape;\n     if (shape_t.dtype() == DataType::DT_INT32) {\n       auto vec = shape_t.flat<int32>();\n       OP_REQUIRES_OK(ctx, TensorShapeUtils::MakeShape(vec.data(), vec.size(),\n                                                       &samples_shape));\n     } else if (shape_t.dtype() == DataType::DT_INT64) {\n       auto vec = shape_t.flat<int64>();\n       OP_REQUIRES_OK(ctx, TensorShapeUtils::MakeShape(vec.data(), vec.size(),\n                                                       &samples_shape));\n     }\n     const int64 samples_per_alpha = samples_shape.num_elements();\n \n     samples_shape.AppendShape(alpha_t.shape());\n     Tensor* samples_t = nullptr;\n     OP_REQUIRES_OK(ctx, ctx->allocate_output(0, samples_shape, &samples_t));\n \n     if (samples_shape.num_elements() == 0) return;\n \n     using random::PhiloxRandom;\n \n     typedef random::NormalDistribution<PhiloxRandom, double> Normal;\n     typedef random::UniformDistribution<PhiloxRandom, double> Uniform;\n #define UNIFORM(X)                                    \\\n   if (uniform_remaining == 0) {                       \\\n     uniform_remaining = Uniform::kResultElementCount; \\\n     uniform_result = uniform(&gen);                   \\\n   }                                                   \\\n   uniform_remaining--;                                \\\n   double X = uniform_result[uniform_remaining]\n \n     static constexpr int kReservedSamplesPerOutput = 256;\n \n     const auto alpha_flat = alpha_t.flat<T>().data();\n     const int64 num_alphas = alpha_t.NumElements();\n     OP_REQUIRES(ctx, num_alphas > 0,\n                 errors::InvalidArgument(\n                     \"Input alpha should have non-zero element count, got: \",\n                     num_alphas));\n     auto samples_flat = samples_t->flat<T>().data();\n     PhiloxRandom rng = generator_.ReserveRandomOutputs(\n         samples_per_alpha * num_alphas, kReservedSamplesPerOutput);\n \n \n     auto DoWork = [samples_per_alpha, num_alphas, &rng, samples_flat,\n// bug_start\n                   alpha_flat](int start_output, int limit_output) {\n// bug_end\n       using Eigen::numext::exp;\n       using Eigen::numext::log;\n       using Eigen::numext::log1p;\n       using Eigen::numext::pow;\n \n \n       Normal normal;\n       Uniform uniform;\n       typename Normal::ResultType norm_result;\n       typename Uniform::ResultType uniform_result;\n       for (int64 output_idx = start_output; output_idx < limit_output;\n            ) {\n         int64 alpha_idx = output_idx / samples_per_alpha;\n \n         T* const samples_alpha_offset = samples_flat + alpha_idx;\n \n         const double alpha = static_cast<double>(alpha_flat[alpha_idx]);\n \n         DISABLE_FLOAT_EQUALITY_WARNING\n         if (alpha == static_cast<double>(1.0)) {\n           ENABLE_FLOAT_EQUALITY_WARNING\n           for (int64 sample_idx = output_idx % samples_per_alpha;\n                sample_idx < samples_per_alpha && output_idx < limit_output;\n                sample_idx++, output_idx++) {\n             PhiloxRandom gen = rng;\n             gen.Skip(kReservedSamplesPerOutput * output_idx);\n             int16 uniform_remaining = 0;\n             UNIFORM(u);\n             const double res = -log1p(-u);\n             samples_alpha_offset[sample_idx * num_alphas] = static_cast<T>(res);\n           }\n         } else {\n           const bool alpha_less_than_one = alpha < 1;\n           const double d = alpha + (alpha_less_than_one ? 2.0 / 3 : -1.0 / 3);\n           const double c = 1.0 / 3 / sqrt(d);\n \n           for (int64 sample_idx = output_idx % samples_per_alpha;\n                sample_idx < samples_per_alpha && output_idx < limit_output;\n                sample_idx++, output_idx++) {\n             PhiloxRandom gen = rng;\n             gen.Skip(kReservedSamplesPerOutput * output_idx);\n             int16 norm_remaining = 0;\n             int16 uniform_remaining = 0;\n \n             while (true) {\n               if (norm_remaining == 0) {\n                 norm_remaining = Normal::kResultElementCount;\n                 norm_result = normal(&gen);\n               }\n               norm_remaining--;\n               const double x = norm_result[norm_remaining];\n               double v = 1 + c * x;\n               if (v <= 0) {\n                 continue;\n               }\n               v = v * v * v;\n               UNIFORM(u);\n               if ((u < 1 - 0.0331 * (x * x) * (x * x)) ||\n                   (log(u) < 0.5 * x * x + d * (1 - v + log(v)))) {\n                 double res = d * v;\n                 if (alpha_less_than_one) {\n                   UNIFORM(b);\n                   res *= pow(b, 1 / alpha);\n                 }\n                 samples_alpha_offset[sample_idx * num_alphas] =\n                     static_cast<T>(res);\n                 break;\n               }\n             }\n           }\n         }\n       }\n     };\n #undef UNIFORM\n     static const int kElementCost = 85 + 2 * Normal::kElementCost +\n                                     Uniform::kElementCost +\n                                     3 * PhiloxRandom::kElementCost;\n     auto worker_threads = *(ctx->device()->tensorflow_cpu_worker_threads());\n     Shard(worker_threads.num_threads, worker_threads.workers,\n           num_alphas * samples_per_alpha, kElementCost, DoWork);\n   }\n \n", "target": "// fix_start\n                   alpha_flat](int64 start_output, int64 limit_output) {\n// fix_end\n", "cwe": "CWE-703", "cwe_name": "Improper Check or Handling of Exceptional Conditions", "cve": "CVE-2020-15202", "cve_desc": "In Tensorflow before versions 1.15.4, 2.0.3, 2.1.2, 2.2.1 and 2.3.1, the `Shard` API in TensorFlow expects the last argument to be a function taking two `int64` (i.e., `long long`) arguments. However, there are several places in TensorFlow where a lambda taking `int` or `int32` arguments is being used. In these cases, if the amount of work to be parallelized is large enough, integer truncation occurs. Depending on how the two arguments of the lambda are used, this can result in segfaults, read/write outside of heap allocated arrays, stack overflows, or data corruption. The issue is patched in commits 27b417360cbd671ef55915e4bb6bb06af8b8a832 and ca8c013b5e97b1373b3bb1c97ea655e69f31a575, and is released in TensorFlow versions 1.15.4, 2.0.3, 2.1.2, 2.2.1, or 2.3.1.", "project": "tensorflow", "idx": 197649}
{"source": " static int dwa_uncompress(EXRContext *s, const uint8_t *src, int compressed_size,\n                           int uncompressed_size, EXRThreadData *td)\n {\n     int64_t version, lo_usize, lo_size;\n     int64_t ac_size, dc_size, rle_usize, rle_csize, rle_raw_size;\n     int64_t ac_count, dc_count, ac_compression;\n     const int dc_w = td->xsize >> 3;\n     const int dc_h = td->ysize >> 3;\n     GetByteContext gb, agb;\n     int skip, ret;\n \n     if (compressed_size <= 88)\n         return AVERROR_INVALIDDATA;\n \n     version = AV_RL64(src + 0);\n     if (version != 2)\n         return AVERROR_INVALIDDATA;\n \n     lo_usize = AV_RL64(src + 8);\n     lo_size = AV_RL64(src + 16);\n     ac_size = AV_RL64(src + 24);\n     dc_size = AV_RL64(src + 32);\n     rle_csize = AV_RL64(src + 40);\n     rle_usize = AV_RL64(src + 48);\n     rle_raw_size = AV_RL64(src + 56);\n     ac_count = AV_RL64(src + 64);\n     dc_count = AV_RL64(src + 72);\n     ac_compression = AV_RL64(src + 80);\n \n     if (compressed_size < 88LL + lo_size + ac_size + dc_size + rle_csize)\n         return AVERROR_INVALIDDATA;\n \n     bytestream2_init(&gb, src + 88, compressed_size - 88);\n     skip = bytestream2_get_le16(&gb);\n     if (skip < 2)\n         return AVERROR_INVALIDDATA;\n \n     bytestream2_skip(&gb, skip - 2);\n \n     if (lo_size > 0) {\n         if (lo_usize > uncompressed_size)\n             return AVERROR_INVALIDDATA;\n         bytestream2_skip(&gb, lo_size);\n     }\n \n     if (ac_size > 0) {\n         unsigned long dest_len = ac_count * 2LL;\n         GetByteContext agb = gb;\n \n         if (ac_count > 3LL * td->xsize * s->scan_lines_per_block)\n             return AVERROR_INVALIDDATA;\n \n         av_fast_padded_malloc(&td->ac_data, &td->ac_size, dest_len);\n         if (!td->ac_data)\n             return AVERROR(ENOMEM);\n \n         switch (ac_compression) {\n         case 0:\n             ret = huf_uncompress(s, td, &agb, (int16_t *)td->ac_data, ac_count);\n             if (ret < 0)\n                 return ret;\n             break;\n         case 1:\n             if (uncompress(td->ac_data, &dest_len, agb.buffer, ac_size) != Z_OK ||\n                 dest_len != ac_count * 2LL)\n                 return AVERROR_INVALIDDATA;\n             break;\n         default:\n             return AVERROR_INVALIDDATA;\n         }\n \n         bytestream2_skip(&gb, ac_size);\n     }\n \n// bug_start\n    if (dc_size > 0) {\n// bug_end\n         unsigned long dest_len = dc_count * 2LL;\n         GetByteContext agb = gb;\n \n// bug_start\n        if (dc_count > (6LL * td->xsize * td->ysize + 63) / 64)\n// bug_end\n             return AVERROR_INVALIDDATA;\n \n         av_fast_padded_malloc(&td->dc_data, &td->dc_size, FFALIGN(dest_len, 64) * 2);\n         if (!td->dc_data)\n             return AVERROR(ENOMEM);\n \n         if (uncompress(td->dc_data + FFALIGN(dest_len, 64), &dest_len, agb.buffer, dc_size) != Z_OK ||\n             (dest_len != dc_count * 2LL))\n             return AVERROR_INVALIDDATA;\n \n         s->dsp.predictor(td->dc_data + FFALIGN(dest_len, 64), dest_len);\n         s->dsp.reorder_pixels(td->dc_data, td->dc_data + FFALIGN(dest_len, 64), dest_len);\n \n         bytestream2_skip(&gb, dc_size);\n     }\n \n     if (rle_raw_size > 0 && rle_csize > 0 && rle_usize > 0) {\n         unsigned long dest_len = rle_usize;\n \n         av_fast_padded_malloc(&td->rle_data, &td->rle_size, rle_usize);\n         if (!td->rle_data)\n             return AVERROR(ENOMEM);\n \n         av_fast_padded_malloc(&td->rle_raw_data, &td->rle_raw_size, rle_raw_size);\n         if (!td->rle_raw_data)\n             return AVERROR(ENOMEM);\n \n         if (uncompress(td->rle_data, &dest_len, gb.buffer, rle_csize) != Z_OK ||\n             (dest_len != rle_usize))\n             return AVERROR_INVALIDDATA;\n \n         ret = rle(td->rle_raw_data, td->rle_data, rle_usize, rle_raw_size);\n         if (ret < 0)\n             return ret;\n         bytestream2_skip(&gb, rle_csize);\n     }\n \n     bytestream2_init(&agb, td->ac_data, ac_count * 2);\n \n     for (int y = 0; y < td->ysize; y += 8) {\n         for (int x = 0; x < td->xsize; x += 8) {\n             memset(td->block, 0, sizeof(td->block));\n \n             for (int j = 0; j < 3; j++) {\n                 float *block = td->block[j];\n                 const int idx = (x >> 3) + (y >> 3) * dc_w + dc_w * dc_h * j;\n                 uint16_t *dc = (uint16_t *)td->dc_data;\n                 union av_intfloat32 dc_val;\n \n                 dc_val.i = half2float(dc[idx], s->mantissatable,\n                                       s->exponenttable, s->offsettable);\n \n                 block[0] = dc_val.f;\n                 ac_uncompress(s, &agb, block);\n                 dct_inverse(block);\n             }\n \n             {\n                 const float scale = s->pixel_type == EXR_FLOAT ? 2.f : 1.f;\n                 const int o = s->nb_channels == 4;\n                 float *bo = ((float *)td->uncompressed_data) +\n                     y * td->xsize * s->nb_channels + td->xsize * (o + 0) + x;\n                 float *go = ((float *)td->uncompressed_data) +\n                     y * td->xsize * s->nb_channels + td->xsize * (o + 1) + x;\n                 float *ro = ((float *)td->uncompressed_data) +\n                     y * td->xsize * s->nb_channels + td->xsize * (o + 2) + x;\n                 float *yb = td->block[0];\n                 float *ub = td->block[1];\n                 float *vb = td->block[2];\n \n                 for (int yy = 0; yy < 8; yy++) {\n                     for (int xx = 0; xx < 8; xx++) {\n                         const int idx = xx + yy * 8;\n \n                         convert(yb[idx], ub[idx], vb[idx], &bo[xx], &go[xx], &ro[xx]);\n \n                         bo[xx] = to_linear(bo[xx], scale);\n                         go[xx] = to_linear(go[xx], scale);\n                         ro[xx] = to_linear(ro[xx], scale);\n                     }\n \n                     bo += td->xsize * s->nb_channels;\n                     go += td->xsize * s->nb_channels;\n                     ro += td->xsize * s->nb_channels;\n                 }\n             }\n         }\n     }\n \n     if (s->nb_channels < 4)\n         return 0;\n \n     for (int y = 0; y < td->ysize && td->rle_raw_data; y++) {\n         uint32_t *ao = ((uint32_t *)td->uncompressed_data) + y * td->xsize * s->nb_channels;\n         uint8_t *ai0 = td->rle_raw_data + y * td->xsize;\n         uint8_t *ai1 = td->rle_raw_data + y * td->xsize + rle_raw_size / 2;\n \n         for (int x = 0; x < td->xsize; x++) {\n             uint16_t ha = ai0[x] | (ai1[x] << 8);\n \n             ao[x] = half2float(ha, s->mantissatable, s->exponenttable, s->offsettable);\n         }\n     }\n \n     return 0;\n }\n \n", "target": "// fix_start\n    {\n// fix_end\n// fix_start\n        if (dc_count != dc_w * dc_h * 3)\n// fix_end\n", "cwe": "CWE-20", "cwe_name": "Improper Input Validation", "cve": "CVE-2021-33815", "cve_desc": "dwa_uncompress in libavcodec/exr.c in FFmpeg 4.4 allows an out-of-bounds array access because dc_count is not strictly checked.", "project": "FFmpeg", "idx": 197652}
{"source": "   Status ValidateInputsGenerateOutputs(\n       OpKernelContext* ctx, const Tensor** inputs, const Tensor** seq_len,\n       Tensor** log_prob, OpOutputList* decoded_indices,\n       OpOutputList* decoded_values, OpOutputList* decoded_shape) const {\n     Status status = ctx->input(\"inputs\", inputs);\n     if (!status.ok()) return status;\n     status = ctx->input(\"sequence_length\", seq_len);\n     if (!status.ok()) return status;\n \n     const TensorShape& inputs_shape = (*inputs)->shape();\n \n     if (inputs_shape.dims() != 3) {\n       return errors::InvalidArgument(\"inputs is not a 3-Tensor\");\n// bug_start\n// bug_end\n     }\n \n     const int64 max_time = inputs_shape.dim_size(0);\n     const int64 batch_size = inputs_shape.dim_size(1);\n \n     if (max_time == 0) {\n       return errors::InvalidArgument(\"max_time is 0\");\n     }\n     if (!TensorShapeUtils::IsVector((*seq_len)->shape())) {\n       return errors::InvalidArgument(\"sequence_length is not a vector\");\n     }\n \n     if (!(batch_size == (*seq_len)->dim_size(0))) {\n       return errors::FailedPrecondition(\n           \"len(sequence_length) != batch_size.  \",\n           \"len(sequence_length):  \", (*seq_len)->dim_size(0),\n           \" batch_size: \", batch_size);\n     }\n \n     auto seq_len_t = (*seq_len)->vec<int32>();\n \n     for (int b = 0; b < batch_size; ++b) {\n       if (!(seq_len_t(b) <= max_time)) {\n         return errors::FailedPrecondition(\"sequence_length(\", b,\n                                           \") <= \", max_time);\n       }\n     }\n \n     Status s = ctx->allocate_output(\n         \"log_probability\", TensorShape({batch_size, top_paths_}), log_prob);\n     if (!s.ok()) return s;\n \n     s = ctx->output_list(\"decoded_indices\", decoded_indices);\n     if (!s.ok()) return s;\n     s = ctx->output_list(\"decoded_values\", decoded_values);\n     if (!s.ok()) return s;\n     s = ctx->output_list(\"decoded_shape\", decoded_shape);\n     if (!s.ok()) return s;\n \n     return Status::OK();\n   }\n \n", "target": "// fix_start\n    }\n    if (inputs_shape.num_elements() == 0) {\n      return errors::InvalidArgument(\"inputs must not be empty\");\n// fix_end\n", "cwe": "CWE-369", "cwe_name": "Divide By Zero", "cve": "CVE-2021-29581", "cve_desc": "TensorFlow is an end-to-end open source platform for machine learning. Due to lack of validation in `tf.raw_ops.CTCBeamSearchDecoder`, an attacker can trigger denial of service via segmentation faults. The implementation(https://github.com/tensorflow/tensorflow/blob/a74768f8e4efbda4def9f16ee7e13cf3922ac5f7/tensorflow/core/kernels/ctc_decoder_ops.cc#L68-L79) fails to detect cases when the input tensor is empty and proceeds to read data from a null buffer. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.", "project": "tensorflow", "idx": 197664}
{"source": "// bug_start\n  void ValidateInputs(OpKernelContext* ctx,\n                      const CSRSparseMatrix& sparse_matrix,\n                      const Tensor& permutation_indices, int* batch_size,\n                      int64* num_rows) {\n    OP_REQUIRES(ctx, sparse_matrix.dtype() == DataTypeToEnum<T>::value,\n                errors::InvalidArgument(\n                    \"Asked for a CSRSparseMatrix of type \",\n                    DataTypeString(DataTypeToEnum<T>::value),\n                    \" but saw dtype: \", DataTypeString(sparse_matrix.dtype())));\n// bug_end\n \n     const Tensor& dense_shape = sparse_matrix.dense_shape();\n     const int rank = dense_shape.dim_size(0);\n// bug_start\n    OP_REQUIRES(ctx, rank == 2 || rank == 3,\n                errors::InvalidArgument(\"sparse matrix must have rank 2 or 3; \",\n                                        \"but dense_shape has size \", rank));\n// bug_end\n     const int row_dim = (rank == 2) ? 0 : 1;\n     auto dense_shape_vec = dense_shape.vec<int64>();\n     *num_rows = dense_shape_vec(row_dim);\n     const int64 num_cols = dense_shape_vec(row_dim + 1);\n// bug_start\n    OP_REQUIRES(ctx, *num_rows == num_cols,\n                errors::InvalidArgument(\"sparse matrix must be square; got: \",\n                                        *num_rows, \" != \", num_cols));\n// bug_end\n     const TensorShape& perm_shape = permutation_indices.shape();\n// bug_start\n    OP_REQUIRES(\n        ctx, perm_shape.dims() + 1 == rank,\n        errors::InvalidArgument(\n            \"sparse matrix must have the same rank as permutation; got: \", rank,\n            \" != \", perm_shape.dims(), \" + 1.\"));\n    OP_REQUIRES(\n        ctx, perm_shape.dim_size(rank - 2) == *num_rows,\n        errors::InvalidArgument(\n            \"permutation must have the same number of elements in each batch \"\n            \"as the number of rows in sparse matrix; got: \",\n            perm_shape.dim_size(rank - 2), \" != \", *num_rows));\n// bug_end\n \n     *batch_size = sparse_matrix.batch_size();\n     if (*batch_size > 1) {\n// bug_start\n      OP_REQUIRES(\n          ctx, perm_shape.dim_size(0) == *batch_size,\n          errors::InvalidArgument(\"permutation must have the same batch size \"\n                                  \"as sparse matrix; got: \",\n                                  perm_shape.dim_size(0), \" != \", *batch_size));\n// bug_end\n     }\n// bug_start\n// bug_end\n   }\n \n", "target": "// fix_start\n  Status ValidateInputs(const CSRSparseMatrix& sparse_matrix,\n                        const Tensor& permutation_indices, int* batch_size,\n                        int64* num_rows) {\n    if (sparse_matrix.dtype() != DataTypeToEnum<T>::value)\n      return errors::InvalidArgument(\n          \"Asked for a CSRSparseMatrix of type \",\n          DataTypeString(DataTypeToEnum<T>::value),\n          \" but saw dtype: \", DataTypeString(sparse_matrix.dtype()));\n// fix_end\n// fix_start\n    if (rank < 2 || rank > 3)\n      return errors::InvalidArgument(\"sparse matrix must have rank 2 or 3; \",\n                                     \"but dense_shape has size \", rank);\n// fix_end\n// fix_start\n    if (*num_rows != num_cols)\n      return errors::InvalidArgument(\n          \"sparse matrix must be square; got: \", *num_rows, \" != \", num_cols);\n// fix_end\n// fix_start\n    if (perm_shape.dims() + 1 != rank)\n      return errors::InvalidArgument(\n          \"sparse matrix must have the same rank as permutation; got: \", rank,\n          \" != \", perm_shape.dims(), \" + 1.\");\n    if (perm_shape.dim_size(rank - 2) != *num_rows)\n      return errors::InvalidArgument(\n          \"permutation must have the same number of elements in each batch \"\n          \"as the number of rows in sparse matrix; got: \",\n          perm_shape.dim_size(rank - 2), \" != \", *num_rows);\n// fix_end\n// fix_start\n      if (perm_shape.dim_size(0) != *batch_size)\n        return errors::InvalidArgument(\n            \"permutation must have the same batch size \"\n            \"as sparse matrix; got: \",\n            perm_shape.dim_size(0), \" != \", *batch_size);\n// fix_end\n// fix_start\n\n    return Status::OK();\n// fix_end\n", "cwe": "CWE-476", "cwe_name": "NULL Pointer Dereference", "cve": "CVE-2021-29530", "cve_desc": "TensorFlow is an end-to-end open source platform for machine learning. An attacker can trigger a null pointer dereference by providing an invalid `permutation` to `tf.raw_ops.SparseMatrixSparseCholesky`. This is because the implementation(https://github.com/tensorflow/tensorflow/blob/080f1d9e257589f78b3ffb75debf584168aa6062/tensorflow/core/kernels/sparse/sparse_cholesky_op.cc#L85-L86) fails to properly validate the input arguments. Although `ValidateInputs` is called and there are checks in the body of this function, the code proceeds to the next line in `ValidateInputs` since `OP_REQUIRES`(https://github.com/tensorflow/tensorflow/blob/080f1d9e257589f78b3ffb75debf584168aa6062/tensorflow/core/framework/op_requires.h#L41-L48) is a macro that only exits the current function. Thus, the first validation condition that fails in `ValidateInputs` will cause an early return from that function. However, the caller will continue execution from the next line. The fix is to either explicitly check `context->status()` or to convert `ValidateInputs` to return a `Status`. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.", "project": "tensorflow", "idx": 197715}
{"source": " void dmar_free_irte(const struct intr_source *intr_src, uint16_t index)\n {\n \tstruct dmar_drhd_rt *dmar_unit;\n \tunion dmar_ir_entry *ir_table, *ir_entry;\n \tunion pci_bdf sid;\n \n \tif (intr_src->is_msi) {\n \t\tdmar_unit = device_to_dmaru((uint8_t)intr_src->src.msi.bits.b, intr_src->src.msi.fields.devfun);\n \t} else {\n \t\tdmar_unit = ioapic_to_dmaru(intr_src->src.ioapic_id, &sid);\n \t}\n \n// bug_start\n\tif (is_dmar_unit_valid(dmar_unit, sid)) {\n// bug_end\n \t\tir_table = (union dmar_ir_entry *)hpa2hva(dmar_unit->ir_table_addr);\n \t\tir_entry = ir_table + index;\n \t\tir_entry->bits.remap.present = 0x0UL;\n \n \t\tiommu_flush_cache(ir_entry, sizeof(union dmar_ir_entry));\n \t\tdmar_invalid_iec(dmar_unit, index, 0U, false);\n \n \t\tif (!is_irte_reserved(dmar_unit, index)) {\n \t\t\tspinlock_obtain(&dmar_unit->lock);\n \t\t\tbitmap_clear_nolock(index & 0x3FU, &dmar_unit->irte_alloc_bitmap[index >> 6U]);\n \t\t\tspinlock_release(&dmar_unit->lock);\n \t\t}\n \t}\n \n }\n \n", "target": "// fix_start\n\tif (is_dmar_unit_valid(dmar_unit, sid) && (index < CONFIG_MAX_IR_ENTRIES)) {\n// fix_end\n", "cwe": "CWE-787", "cwe_name": "Out-of-bounds Write", "cve": "CVE-2021-36148", "cve_desc": "An issue was discovered in ACRN before 2.5. dmar_free_irte in hypervisor/arch/x86/vtd.c allows an irte_alloc_bitmap buffer overflow.", "project": "acrn-hypervisor", "idx": 197721}
{"source": " static void ndpi_reset_packet_line_info(struct ndpi_packet_struct *packet) {\n   packet->parsed_lines = 0, packet->empty_line_position_set = 0, packet->host_line.ptr = NULL,\n     packet->host_line.len = 0, packet->referer_line.ptr = NULL, packet->referer_line.len = 0,\n     packet->content_line.ptr = NULL, packet->content_line.len = 0, packet->accept_line.ptr = NULL,\n     packet->accept_line.len = 0, packet->user_agent_line.ptr = NULL, packet->user_agent_line.len = 0,\n     packet->http_url_name.ptr = NULL, packet->http_url_name.len = 0, packet->http_encoding.ptr = NULL,\n     packet->http_encoding.len = 0, packet->http_transfer_encoding.ptr = NULL, packet->http_transfer_encoding.len = 0,\n// bug_start\n    packet->http_contentlen.ptr = NULL, packet->http_contentlen.len = 0, packet->http_cookie.ptr = NULL,\n// bug_end\n     packet->http_cookie.len = 0, packet->http_origin.len = 0, packet->http_origin.ptr = NULL,\n     packet->http_x_session_type.ptr = NULL, packet->http_x_session_type.len = 0, packet->server_line.ptr = NULL,\n     packet->server_line.len = 0, packet->http_method.ptr = NULL, packet->http_method.len = 0,\n     packet->http_response.ptr = NULL, packet->http_response.len = 0, packet->http_num_headers = 0;\n }\n \n", "target": "// fix_start\n    packet->http_contentlen.ptr = NULL, packet->http_contentlen.len = 0, packet->content_disposition_line.ptr = NULL,\n    packet->content_disposition_line.len = 0, packet->http_cookie.ptr = NULL,\n// fix_end\n", "cwe": "CWE-787", "cwe_name": "Out-of-bounds Write", "cve": "CVE-2020-15475", "cve_desc": "In nDPI through 3.2, ndpi_reset_packet_line_info in lib/ndpi_main.c omits certain reinitialization, leading to a use-after-free.", "project": "nDPI", "idx": 197747}
{"source": " bool FromkLinuxSockAddr(const struct klinux_sockaddr *input,\n                         socklen_t input_len, struct sockaddr *output,\n                         socklen_t *output_len,\n                         void (*abort_handler)(const char *)) {\n   if (!input || !output || !output_len || input_len == 0) {\n     output = nullptr;\n     return false;\n   }\n \n   int16_t klinux_family = input->klinux_sa_family;\n   if (klinux_family == kLinux_AF_UNIX) {\n// bug_start\n// bug_end\n     struct klinux_sockaddr_un *klinux_sockaddr_un_in =\n         const_cast<struct klinux_sockaddr_un *>(\n             reinterpret_cast<const struct klinux_sockaddr_un *>(input));\n \n     struct sockaddr_un sockaddr_un_out;\n     sockaddr_un_out.sun_family = AF_UNIX;\n     InitializeToZeroArray(sockaddr_un_out.sun_path);\n     ReinterpretCopyArray(\n         sockaddr_un_out.sun_path, klinux_sockaddr_un_in->klinux_sun_path,\n         std::min(sizeof(sockaddr_un_out.sun_path),\n                  sizeof(klinux_sockaddr_un_in->klinux_sun_path)));\n     CopySockaddr(&sockaddr_un_out, sizeof(sockaddr_un_out), output, output_len);\n   } else if (klinux_family == kLinux_AF_INET) {\n// bug_start\n// bug_end\n     struct klinux_sockaddr_in *klinux_sockaddr_in_in =\n         const_cast<struct klinux_sockaddr_in *>(\n             reinterpret_cast<const struct klinux_sockaddr_in *>(input));\n \n     struct sockaddr_in sockaddr_in_out;\n     sockaddr_in_out.sin_family = AF_INET;\n     sockaddr_in_out.sin_port = klinux_sockaddr_in_in->klinux_sin_port;\n     InitializeToZeroSingle(&sockaddr_in_out.sin_addr);\n     ReinterpretCopySingle(&sockaddr_in_out.sin_addr,\n                           &klinux_sockaddr_in_in->klinux_sin_addr);\n     InitializeToZeroArray(sockaddr_in_out.sin_zero);\n     ReinterpretCopyArray(sockaddr_in_out.sin_zero,\n                          klinux_sockaddr_in_in->klinux_sin_zero);\n     CopySockaddr(&sockaddr_in_out, sizeof(sockaddr_in_out), output, output_len);\n   } else if (klinux_family == kLinux_AF_INET6) {\n// bug_start\n// bug_end\n     struct klinux_sockaddr_in6 *klinux_sockaddr_in6_in =\n         const_cast<struct klinux_sockaddr_in6 *>(\n             reinterpret_cast<const struct klinux_sockaddr_in6 *>(input));\n \n     struct sockaddr_in6 sockaddr_in6_out;\n     sockaddr_in6_out.sin6_family = AF_INET6;\n     sockaddr_in6_out.sin6_port = klinux_sockaddr_in6_in->klinux_sin6_port;\n     sockaddr_in6_out.sin6_flowinfo =\n         klinux_sockaddr_in6_in->klinux_sin6_flowinfo;\n     sockaddr_in6_out.sin6_scope_id =\n         klinux_sockaddr_in6_in->klinux_sin6_scope_id;\n     InitializeToZeroSingle(&sockaddr_in6_out.sin6_addr);\n     ReinterpretCopySingle(&sockaddr_in6_out.sin6_addr,\n                           &klinux_sockaddr_in6_in->klinux_sin6_addr);\n     CopySockaddr(&sockaddr_in6_out, sizeof(sockaddr_in6_out), output,\n                  output_len);\n   } else if (klinux_family == kLinux_AF_UNSPEC) {\n     output = nullptr;\n     *output_len = 0;\n   } else {\n     if (abort_handler != nullptr) {\n       std::string message = absl::StrCat(\n           \"Type conversion error - Unsupported AF family: \", klinux_family);\n       abort_handler(message.c_str());\n     } else {\n       abort();\n     }\n   }\n   return true;\n }\n \n", "target": "// fix_start\n    if (input_len < sizeof(struct klinux_sockaddr_un)) {\n      return false;\n    }\n\n// fix_end\n// fix_start\n    if (input_len < sizeof(struct klinux_sockaddr_in)) {\n      return false;\n    }\n// fix_end\n// fix_start\n    if (input_len < sizeof(struct klinux_sockaddr_in6)) {\n      return false;\n    }\n\n// fix_end\n", "cwe": "CWE-787", "cwe_name": "Out-of-bounds Write", "cve": "CVE-2020-8938", "cve_desc": "An arbitrary memory overwrite vulnerability in Asylo versions up to 0.6.0 allows an attacker to make a host call to FromkLinuxSockAddr with attacker controlled content and size of klinux_addr which allows an attacker to write memory values from within the enclave. We recommend upgrading past commit a37fb6a0e7daf30134dbbf357c9a518a1026aa02", "project": "asylo", "idx": 197757}
{"source": "   void Compute(OpKernelContext* context) override {\n     const Tensor& input = context->input(0);\n// bug_start\n    const float input_min = context->input(1).flat<float>()(0);\n    const float input_max = context->input(2).flat<float>()(0);\n// bug_end\n     const Tensor& mean = context->input(3);\n// bug_start\n    const float mean_min = context->input(4).flat<float>()(0);\n    const float mean_max = context->input(5).flat<float>()(0);\n// bug_end\n     const Tensor& var = context->input(6);\n// bug_start\n    const float var_min = context->input(7).flat<float>()(0);\n    const float var_max = context->input(8).flat<float>()(0);\n// bug_end\n     const Tensor& beta = context->input(9);\n// bug_start\n    const float beta_min = context->input(10).flat<float>()(0);\n    const float beta_max = context->input(11).flat<float>()(0);\n// bug_end\n     const Tensor& gamma = context->input(12);\n// bug_start\n    const float gamma_min = context->input(13).flat<float>()(0);\n    const float gamma_max = context->input(14).flat<float>()(0);\n// bug_end\n \n     OP_REQUIRES(context, input.dims() == 4,\n                 errors::InvalidArgument(\"input must be 4-dimensional\",\n                                         input.shape().DebugString()));\n     OP_REQUIRES(context, mean.dims() == 1,\n                 errors::InvalidArgument(\"mean must be 1-dimensional\",\n                                         mean.shape().DebugString()));\n     OP_REQUIRES(context, var.dims() == 1,\n                 errors::InvalidArgument(\"var must be 1-dimensional\",\n                                         var.shape().DebugString()));\n     OP_REQUIRES(context, beta.dims() == 1,\n                 errors::InvalidArgument(\"beta must be 1-dimensional\",\n                                         beta.shape().DebugString()));\n     OP_REQUIRES(context, gamma.dims() == 1,\n                 errors::InvalidArgument(\"gamma must be 1-dimensional\",\n                                         gamma.shape().DebugString()));\n// bug_start\n// bug_end\n \n     Tensor* output = nullptr;\n     OP_REQUIRES_OK(context,\n                    context->allocate_output(0, input.shape(), &output));\n     float output_min;\n     float output_max;\n     FixedPointBatchNorm<T1, T2>(input, input_min, input_max, mean, mean_min,\n                                 mean_max, var, var_min, var_max, beta, beta_min,\n                                 beta_max, gamma, gamma_min, gamma_max,\n                                 variance_epsilon_, scale_after_normalization_,\n                                 output, &output_min, &output_max);\n \n     Tensor* output_min_tensor = nullptr;\n     OP_REQUIRES_OK(context,\n                    context->allocate_output(1, {}, &output_min_tensor));\n     output_min_tensor->flat<float>()(0) = output_min;\n \n     Tensor* output_max_tensor = nullptr;\n     OP_REQUIRES_OK(context,\n                    context->allocate_output(2, {}, &output_max_tensor));\n     output_max_tensor->flat<float>()(0) = output_max;\n   }\n \n", "target": "// fix_start\n    const auto& input_min_tensor = context->input(1);\n    OP_REQUIRES(context, input_min_tensor.NumElements() == 1,\n                errors::InvalidArgument(\"input_min must have 1 element\"));\n    const float input_min = input_min_tensor.flat<float>()(0);\n    const auto& input_max_tensor = context->input(2);\n    OP_REQUIRES(context, input_max_tensor.NumElements() == 1,\n                errors::InvalidArgument(\"input_max must have 1 element\"));\n    const float input_max = input_max_tensor.flat<float>()(0);\n// fix_end\n// fix_start\n    const auto& mean_min_tensor = context->input(4);\n    OP_REQUIRES(context, mean_min_tensor.NumElements() == 1,\n                errors::InvalidArgument(\"mean_min must have 1 element\"));\n    const float mean_min = mean_min_tensor.flat<float>()(0);\n    const auto& mean_max_tensor = context->input(5);\n    OP_REQUIRES(context, mean_max_tensor.NumElements() == 1,\n                errors::InvalidArgument(\"mean_max must have 1 element\"));\n    const float mean_max = mean_max_tensor.flat<float>()(0);\n// fix_end\n// fix_start\n    const auto& var_min_tensor = context->input(7);\n    OP_REQUIRES(context, var_min_tensor.NumElements() == 1,\n                errors::InvalidArgument(\"var_min must have 1 element\"));\n    const float var_min = var_min_tensor.flat<float>()(0);\n    const auto& var_max_tensor = context->input(8);\n    OP_REQUIRES(context, var_max_tensor.NumElements() == 1,\n                errors::InvalidArgument(\"var_max must have 1 element\"));\n    const float var_max = var_max_tensor.flat<float>()(0);\n// fix_end\n// fix_start\n    const auto& beta_min_tensor = context->input(10);\n    OP_REQUIRES(context, beta_min_tensor.NumElements() == 1,\n                errors::InvalidArgument(\"beta_min must have 1 element\"));\n    const float beta_min = beta_min_tensor.flat<float>()(0);\n    const auto& beta_max_tensor = context->input(11);\n    OP_REQUIRES(context, beta_max_tensor.NumElements() == 1,\n                errors::InvalidArgument(\"beta_max must have 1 element\"));\n    const float beta_max = beta_max_tensor.flat<float>()(0);\n// fix_end\n// fix_start\n    const auto& gamma_min_tensor = context->input(13);\n    OP_REQUIRES(context, gamma_min_tensor.NumElements() == 1,\n                errors::InvalidArgument(\"gamma_min must have 1 element\"));\n    const float gamma_min = gamma_min_tensor.flat<float>()(0);\n    const auto& gamma_max_tensor = context->input(14);\n    OP_REQUIRES(context, gamma_max_tensor.NumElements() == 1,\n                errors::InvalidArgument(\"gamma_max must have 1 element\"));\n    const float gamma_max = gamma_max_tensor.flat<float>()(0);\n// fix_end\n// fix_start\n    OP_REQUIRES(context, mean.NumElements() > 1,\n                errors::InvalidArgument(\"Must have at least a mean value\",\n                                        gamma.shape().DebugString()));\n    OP_REQUIRES(context, mean.NumElements() > 1,\n                errors::InvalidArgument(\"Must have at least a mean value\"));\n    const auto last_dim = input.shape().dims() - 1;\n    OP_REQUIRES(context,\n                mean.shape().dim_size(0) == input.shape().dim_size(last_dim),\n                errors::InvalidArgument(\"Must provide as many means as the \"\n                                        \"last dimension of the input tensor: \",\n                                        mean.shape().DebugString(), \" vs. \",\n                                        input.shape().DebugString()));\n    OP_REQUIRES(\n        context, mean.shape().dim_size(0) == var.shape().dim_size(0),\n        errors::InvalidArgument(\n            \"Mean and variance tensors must have the same shape: \",\n            mean.shape().DebugString(), \" vs. \", var.shape().DebugString()));\n    OP_REQUIRES(\n        context, mean.shape().dim_size(0) == beta.shape().dim_size(0),\n        errors::InvalidArgument(\n            \"Mean and beta tensors must have the same shape: \",\n            mean.shape().DebugString(), \" vs. \", beta.shape().DebugString()));\n    OP_REQUIRES(\n        context, mean.shape().dim_size(0) == gamma.shape().dim_size(0),\n        errors::InvalidArgument(\n            \"Mean and gamma tensors must have the same shape: \",\n            mean.shape().DebugString(), \" vs. \", gamma.shape().DebugString()));\n// fix_end\n", "cwe": "CWE-369", "cwe_name": "Divide By Zero", "cve": "CVE-2021-29547", "cve_desc": "TensorFlow is an end-to-end open source platform for machine learning. An attacker can cause a segfault and denial of service via accessing data outside of bounds in `tf.raw_ops.QuantizedBatchNormWithGlobalNormalization`. This is because the implementation(https://github.com/tensorflow/tensorflow/blob/55a97caa9e99c7f37a0bbbeb414dc55553d3ae7f/tensorflow/core/kernels/quantized_batch_norm_op.cc#L176-L189) assumes the inputs are not empty. If any of these inputs is empty, `.flat<T>()` is an empty buffer, so accessing the element at index 0 is accessing data outside of bounds. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.", "project": "tensorflow", "idx": 197761}
{"source": " ImmutableConstantOp::ImmutableConstantOp(OpKernelConstruction* context)\n     : OpKernel(context) {\n   OP_REQUIRES_OK(context,\n                  context->GetAttr(kMemoryRegionNameAttr, &region_name_));\n   OP_REQUIRES_OK(context, context->GetAttr(kDTypeAttr, &dtype_));\n// bug_start\n// bug_end\n   OP_REQUIRES_OK(context, context->GetAttr(kShapeAttr, &shape_));\n }\n \n", "target": "// fix_start\n  OP_REQUIRES(context, dtype_ != DT_RESOURCE && dtype_ != DT_VARIANT,\n              errors::InvalidArgument(\n                  \"Resource and variant dtypes are invalid for this op.\"));\n// fix_end\n", "cwe": "CWE-703", "cwe_name": "Improper Check or Handling of Exceptional Conditions", "cve": "CVE-2021-29539", "cve_desc": "TensorFlow is an end-to-end open source platform for machine learning. Calling `tf.raw_ops.ImmutableConst`(https://www.tensorflow.org/api_docs/python/tf/raw_ops/ImmutableConst) with a `dtype` of `tf.resource` or `tf.variant` results in a segfault in the implementation as code assumes that the tensor contents are pure scalars. We have patched the issue in 4f663d4b8f0bec1b48da6fa091a7d29609980fa4 and will release TensorFlow 2.5.0 containing the patch. TensorFlow nightly packages after this commit will also have the issue resolved. If using `tf.raw_ops.ImmutableConst` in code, you can prevent the segfault by inserting a filter for the `dtype` argument.", "project": "tensorflow", "idx": 197806}
{"source": " void *UntrustedCacheMalloc::GetBuffer() {\n   void **buffers = nullptr;\n   void *buffer;\n   bool is_pool_empty;\n \n   {\n     LockGuard spin_lock(&lock_);\n     is_pool_empty = buffer_pool_.empty();\n     if (is_pool_empty) {\n       buffers =\n           primitives::AllocateUntrustedBuffers(kPoolIncrement, kPoolEntrySize);\n       for (int i = 0; i < kPoolIncrement; i++) {\n// bug_start\n        if (!buffers[i] ||\n            !TrustedPrimitives::IsOutsideEnclave(buffers[i], kPoolEntrySize)) {\n          abort();\n// bug_end\n         }\n// bug_start\n        buffer_pool_.push(buffers[i]);\n// bug_end\n       }\n     }\n     buffer = buffer_pool_.top();\n     buffer_pool_.pop();\n     busy_buffers_.insert(buffer);\n   }\n \n   if (is_pool_empty) {\n     Free(buffers);\n   }\n   return buffer;\n }\n \n", "target": "// fix_start\n        void *buf = buffers[i];\n        if (!buf || !TrustedPrimitives::IsOutsideEnclave(buf, kPoolEntrySize)) {\n          TrustedPrimitives::BestEffortAbort(\n              \"Cached buffer is not outside the enclave\");\n// fix_end\n// fix_start\n        buffer_pool_.push(buf);\n// fix_end\n", "cwe": "CWE-200", "cwe_name": "Exposure of Sensitive Information to an Unauthorized Actor", "cve": "CVE-2021-22550", "cve_desc": "An attacker can modify the pointers in enclave memory to overwrite arbitrary memory addresses within the secure enclave. It is recommended to update past 0.6.3 or git commit https://github.com/google/asylo/commit/a47ef55db2337d29de19c50cd29b0deb2871d31c", "project": "asylo", "idx": 197832}
{"source": " ImagingPcxDecode(Imaging im, ImagingCodecState state, UINT8* buf, Py_ssize_t bytes)\n {\n     UINT8 n;\n     UINT8* ptr;\n \n// bug_start\n    if (strcmp(im->mode, \"1\") == 0 && state->xsize > state->bytes * 8) {\n        state->errcode = IMAGING_CODEC_OVERRUN;\n        return -1;\n    } else if (strcmp(im->mode, \"P\") == 0 && state->xsize > state->bytes) {\n// bug_end\n         state->errcode = IMAGING_CODEC_OVERRUN;\n         return -1;\n     }\n \n     ptr = buf;\n \n     for (;;) {\n \n \tif (bytes < 1)\n \t    return ptr - buf;\n \n \tif ((*ptr & 0xC0) == 0xC0) {\n \n \t    if (bytes < 2)\n \t\treturn ptr - buf;\n \n \t    n = ptr[0] & 0x3F;\n \n \t    while (n > 0) {\n \t\tif (state->x >= state->bytes) {\n \t\t    state->errcode = IMAGING_CODEC_OVERRUN;\n \t\t    break;\n \t\t}\n \t\tstate->buffer[state->x++] = ptr[1];\n \t\tn--;\n \t    }\n \n \t    ptr += 2; bytes -= 2;\n \n \t} else {\n \n \t    state->buffer[state->x++] = ptr[0];\n \t    ptr++; bytes--;\n \n \t}\n \n \tif (state->x >= state->bytes) {\n         if (state->bytes % state->xsize && state->bytes > state->xsize) {\n             int bands = state->bytes / state->xsize;\n             int stride = state->bytes / bands;\n             int i;\n             for (i=1; i< bands; i++) {\n                 memmove(&state->buffer[i*state->xsize],\n                         &state->buffer[i*stride],\n                         state->xsize);\n             }\n         }\n \t    state->shuffle((UINT8*) im->image[state->y + state->yoff] +\n \t\t\t   state->xoff * im->pixelsize, state->buffer,\n \t\t\t   state->xsize);\n \n \t    state->x = 0;\n \n \t    if (++state->y >= state->ysize) {\n \t\treturn -1;\n \t    }\n \t}\n \n     }\n }\n \n", "target": "// fix_start\n    if ((state->xsize * state->bits + 7) / 8 > state->bytes) {\n// fix_end\n", "cwe": "CWE-125", "cwe_name": "Out-of-bounds Read", "cve": "CVE-2020-10378", "cve_desc": "In libImaging/PcxDecode.c in Pillow before 7.1.0, an out-of-bounds read can occur when reading PCX files where state->shuffle is instructed to read beyond state->buffer.", "project": "Pillow", "idx": 197848}
{"source": " GF_Err Media_RewriteODFrame(GF_MediaBox *mdia, GF_ISOSample *sample)\n {\n \tGF_Err e;\n \tGF_ODCodec *ODdecode;\n \tGF_ODCodec *ODencode;\n \tGF_ODCom *com;\n \n \tGF_ESDUpdate *esdU, *esdU2;\n \tGF_ESDRemove *esdR, *esdR2;\n \tGF_ODUpdate *odU, *odU2;\n \n \tGF_ObjectDescriptor *od;\n \tGF_IsomObjectDescriptor *isom_od;\n \tGF_ESD *esd;\n \tGF_ES_ID_Ref *ref;\n \tGF_Descriptor *desc;\n \tGF_TrackReferenceTypeBox *mpod;\n \tu32 i, j, skipped;\n \n \tif (!mdia || !sample || !sample->data || !sample->dataLength) return GF_BAD_PARAM;\n \n \tmpod = NULL;\n \te = Track_FindRef(mdia->mediaTrack, GF_ISOM_BOX_TYPE_MPOD, &mpod);\n \tif (e) return e;\n \tif (!mpod || !mpod->trackIDs) return GF_OK;\n \n \tODdecode = gf_odf_codec_new();\n \tif (!ODdecode) return GF_OUT_OF_MEM;\n \tODencode = gf_odf_codec_new();\n \tif (!ODencode) {\n \t\tgf_odf_codec_del(ODdecode);\n \t\treturn GF_OUT_OF_MEM;\n \t}\n \te = gf_odf_codec_set_au(ODdecode, sample->data, sample->dataLength);\n \tif (e) goto err_exit;\n \te = gf_odf_codec_decode(ODdecode);\n \tif (e) goto err_exit;\n \n \twhile (1) {\n \t\tcom = gf_odf_codec_get_com(ODdecode);\n \t\tif (!com) break;\n \n \t\tswitch (com->tag) {\n \t\tcase GF_ODF_OD_UPDATE_TAG:\n \t\t\todU = (GF_ODUpdate *) com;\n \t\t\todU2 = (GF_ODUpdate *) gf_odf_com_new(GF_ODF_OD_UPDATE_TAG);\n \n \t\t\ti=0;\n \t\t\twhile ((desc = (GF_Descriptor*)gf_list_enum(odU->objectDescriptors, &i))) {\n \t\t\t\tswitch (desc->tag) {\n \t\t\t\tcase GF_ODF_OD_TAG:\n \t\t\t\tcase GF_ODF_ISOM_OD_TAG:\n \t\t\t\tcase GF_ODF_ISOM_IOD_TAG:\n \t\t\t\t\tbreak;\n \t\t\t\tdefault:\n \t\t\t\t\treturn GF_ISOM_INVALID_FILE;\n \t\t\t\t}\n \t\t\t\te = gf_odf_desc_copy(desc, (GF_Descriptor **)&isom_od);\n \t\t\t\tif (e) goto err_exit;\n \n \t\t\t\tif (desc->tag == GF_ODF_ISOM_IOD_TAG) {\n \t\t\t\t\tod = (GF_ObjectDescriptor *) gf_malloc(sizeof(GF_InitialObjectDescriptor));\n \t\t\t\t} else {\n \t\t\t\t\tod = (GF_ObjectDescriptor *) gf_malloc(sizeof(GF_ObjectDescriptor));\n \t\t\t\t}\n \t\t\t\tif (!od) {\n \t\t\t\t\te = GF_OUT_OF_MEM;\n \t\t\t\t\tgoto err_exit;\n \t\t\t\t}\n \t\t\t\tod->ESDescriptors = gf_list_new();\n \t\t\t\tod->objectDescriptorID = isom_od->objectDescriptorID;\n \t\t\t\tod->tag = GF_ODF_OD_TAG;\n \t\t\t\tod->URLString = isom_od->URLString;\n \t\t\t\tisom_od->URLString = NULL;\n \t\t\t\tod->extensionDescriptors = isom_od->extensionDescriptors;\n \t\t\t\tisom_od->extensionDescriptors = NULL;\n \t\t\t\tod->IPMP_Descriptors = isom_od->IPMP_Descriptors;\n \t\t\t\tisom_od->IPMP_Descriptors = NULL;\n \t\t\t\tod->OCIDescriptors = isom_od->OCIDescriptors;\n \t\t\t\tisom_od->OCIDescriptors = NULL;\n \n \t\t\t\tif (isom_od->tag == GF_ODF_ISOM_IOD_TAG) {\n \t\t\t\t\t((GF_InitialObjectDescriptor *)od)->audio_profileAndLevel = ((GF_IsomInitialObjectDescriptor *)isom_od)->audio_profileAndLevel;\n \t\t\t\t\t((GF_InitialObjectDescriptor *)od)->inlineProfileFlag = ((GF_IsomInitialObjectDescriptor *)isom_od)->inlineProfileFlag;\n \t\t\t\t\t((GF_InitialObjectDescriptor *)od)->graphics_profileAndLevel = ((GF_IsomInitialObjectDescriptor *)isom_od)->graphics_profileAndLevel;\n \t\t\t\t\t((GF_InitialObjectDescriptor *)od)->OD_profileAndLevel = ((GF_IsomInitialObjectDescriptor *)isom_od)->OD_profileAndLevel;\n \t\t\t\t\t((GF_InitialObjectDescriptor *)od)->scene_profileAndLevel = ((GF_IsomInitialObjectDescriptor *)isom_od)->scene_profileAndLevel;\n \t\t\t\t\t((GF_InitialObjectDescriptor *)od)->visual_profileAndLevel = ((GF_IsomInitialObjectDescriptor *)isom_od)->visual_profileAndLevel;\n \t\t\t\t\t((GF_InitialObjectDescriptor *)od)->IPMPToolList = ((GF_IsomInitialObjectDescriptor *)isom_od)->IPMPToolList;\n \t\t\t\t\t((GF_IsomInitialObjectDescriptor *)isom_od)->IPMPToolList = NULL;\n \t\t\t\t}\n \n \t\t\t\tj=0;\n \t\t\t\twhile ((ref = (GF_ES_ID_Ref*)gf_list_enum(isom_od->ES_ID_RefDescriptors, &j))) {\n// bug_start\n\t\t\t\t\tif (!mpod->trackIDs || gf_isom_get_track_from_id(mdia->mediaTrack->moov, mpod->trackIDs[ref->trackRef - 1]) == NULL) continue;\n// bug_end\n \t\t\t\t\te = GetESDForTime(mdia->mediaTrack->moov, mpod->trackIDs[ref->trackRef - 1], sample->DTS, &esd);\n \t\t\t\t\tif (!e) e = gf_odf_desc_add_desc((GF_Descriptor *) od, (GF_Descriptor *) esd);\n \t\t\t\t\tif (e) {\n \t\t\t\t\t\tgf_odf_desc_del((GF_Descriptor *)od);\n \t\t\t\t\t\tgf_odf_com_del((GF_ODCom **)&odU2);\n \t\t\t\t\t\tgf_odf_desc_del((GF_Descriptor *)isom_od);\n \t\t\t\t\t\tgf_odf_com_del((GF_ODCom **)&odU);\n \t\t\t\t\t\tgoto err_exit;\n \t\t\t\t\t}\n \n \t\t\t\t}\n \t\t\t\tgf_odf_desc_del((GF_Descriptor *)isom_od);\n \t\t\t\tgf_list_add(odU2->objectDescriptors, od);\n \t\t\t}\n \t\t\tgf_odf_com_del((GF_ODCom **)&odU);\n \t\t\tgf_odf_codec_add_com(ODencode, (GF_ODCom *)odU2);\n \t\t\tbreak;\n \n \t\tcase GF_ODF_ESD_UPDATE_TAG:\n \t\t\tesdU = (GF_ESDUpdate *) com;\n \t\t\tesdU2 = (GF_ESDUpdate *) gf_odf_com_new(GF_ODF_ESD_UPDATE_TAG);\n \t\t\tesdU2->ODID = esdU->ODID;\n \t\t\ti=0;\n \t\t\twhile ((ref = (GF_ES_ID_Ref*)gf_list_enum(esdU->ESDescriptors, &i))) {\n// bug_start\n// bug_end\n \t\t\t\tif (gf_isom_get_track_from_id(mdia->mediaTrack->moov, mpod->trackIDs[ref->trackRef - 1]) == NULL) continue;\n \t\t\t\te = GetESDForTime(mdia->mediaTrack->moov, mpod->trackIDs[ref->trackRef - 1], sample->DTS, &esd);\n \t\t\t\tif (e) goto err_exit;\n \t\t\t\tgf_list_add(esdU2->ESDescriptors, esd);\n \t\t\t}\n \t\t\tgf_odf_com_del((GF_ODCom **)&esdU);\n \t\t\tgf_odf_codec_add_com(ODencode, (GF_ODCom *)esdU2);\n \t\t\tbreak;\n \n \t\tcase GF_ODF_ESD_REMOVE_REF_TAG:\n \t\t\tesdR = (GF_ESDRemove *) com;\n \t\t\tesdR2 = (GF_ESDRemove *) gf_odf_com_new(GF_ODF_ESD_REMOVE_TAG);\n \t\t\tesdR2->ODID = esdR->ODID;\n \t\t\tesdR2->NbESDs = esdR->NbESDs;\n \t\t\tesdR2->ES_ID = (unsigned short*)gf_malloc(sizeof(u32) * esdR->NbESDs);\n \t\t\tif (!esdR2->ES_ID) {\n \t\t\t\te = GF_OUT_OF_MEM;\n \t\t\t\tgoto err_exit;\n \t\t\t}\n \t\t\tskipped = 0;\n \t\t\tfor (i = 0; i < esdR->NbESDs; i++) {\n// bug_start\n// bug_end\n \t\t\t\tif (gf_isom_get_track_from_id(mdia->mediaTrack->moov, mpod->trackIDs[esdR->ES_ID[i] - 1]) == NULL) {\n \t\t\t\t\tskipped ++;\n \t\t\t\t} else {\n \t\t\t\t\tesdR2->ES_ID[i - skipped] = mpod->trackIDs[esdR->ES_ID[i] - 1];\n \t\t\t\t}\n \t\t\t}\n \t\t\tif (skipped && (skipped != esdR2->NbESDs) ) {\n \t\t\t\tesdR2->NbESDs -= skipped;\n \t\t\t\tesdR2->ES_ID = (unsigned short*)gf_realloc(esdR2->ES_ID, sizeof(u32) * esdR2->NbESDs);\n \t\t\t}\n \t\t\tgf_odf_com_del((GF_ODCom **)&esdR);\n \t\t\tgf_odf_codec_add_com(ODencode, (GF_ODCom *)esdR2);\n \t\t\tbreak;\n \n \t\tdefault:\n \t\t\te = gf_odf_codec_add_com(ODencode, com);\n \t\t\tif (e) goto err_exit;\n \t\t}\n \t}\n \te = gf_odf_codec_encode(ODencode, 1);\n \tif (e) goto err_exit;\n \n \tgf_free(sample->data);\n \tsample->data = NULL;\n \tsample->dataLength = 0;\n \te = gf_odf_codec_get_au(ODencode, &sample->data, &sample->dataLength);\n \n err_exit:\n \tgf_odf_codec_del(ODdecode);\n \tgf_odf_codec_del(ODencode);\n \treturn e;\n }\n \n", "target": "// fix_start\n\t\t\t\t\tif (!mpod->trackIDs || !ref->trackRef || (ref->trackRef>mpod->trackIDCount)) continue;\n\t\t\t\t\tif (gf_isom_get_track_from_id(mdia->mediaTrack->moov, mpod->trackIDs[ref->trackRef - 1]) == NULL) continue;\n// fix_end\n// fix_start\n\t\t\t\tif (!mpod->trackIDs || !ref->trackRef || (ref->trackRef>mpod->trackIDCount)) continue;\n// fix_end\n// fix_start\n\t\t\t\tif (!mpod->trackIDs || !esdR->ES_ID[i] || (esdR->ES_ID[i]>mpod->trackIDCount)) continue;\n// fix_end\n", "cwe": "CWE-476", "cwe_name": "NULL Pointer Dereference", "cve": "CVE-2021-32440", "cve_desc": "The Media_RewriteODFrame function in GPAC 1.0.1 allows attackers to cause a denial of service (NULL pointer dereference) via a crafted file in the MP4Box command.", "project": "gpac", "idx": 197890}
{"source": " TfLiteStatus Eval(TfLiteContext* context, TfLiteNode* node) {\n   const TfLiteTensor* output_shape;\n   TF_LITE_ENSURE_OK(\n       context, GetInputSafe(context, node, kOutputShapeTensor, &output_shape));\n   const TfLiteTensor* weights;\n   TF_LITE_ENSURE_OK(context,\n                     GetInputSafe(context, node, kWeightsTensor, &weights));\n   const TfLiteTensor* input;\n   TF_LITE_ENSURE_OK(context,\n                     GetInputSafe(context, node, kDataInputTensor, &input));\n   const TfLiteTensor* bias =\n       (NumInputs(node) == 4)\n           ? GetOptionalInputTensor(context, node, kBiasTensor)\n           : nullptr;\n   TfLiteTensor* output;\n   TF_LITE_ENSURE_OK(context,\n                     GetOutputSafe(context, node, kOutputTensor, &output));\n   OpData* data = reinterpret_cast<OpData*>(node->user_data);\n   TfLiteTensor* col2im = data->has_col2im\n                              ? GetTemporary(context, node, data->col2im_index)\n                              : nullptr;\n   TfLiteTensor* transposed_weights =\n       data->weights_are_transposed\n           ? GetTemporary(context, node, data->transposed_weights_index)\n           : nullptr;\n   const auto* params =\n       reinterpret_cast<TfLiteTransposeConvParams*>(node->builtin_data);\n// bug_start\n// bug_end\n \n   if (IsDynamicTensor(output)) {\n     TF_LITE_ENSURE_OK(context, ResizeTensor(context, output_shape, output));\n   }\n   if (data->has_col2im && IsDynamicTensor(col2im)) {\n     TF_LITE_ENSURE_OK(context, ResizeCol2ImTensor(context, output_shape,\n                                                   weights, input, col2im));\n   }\n \n   const int width = SizeOfDimension(output, 2);\n   const int height = SizeOfDimension(output, 1);\n   const int filter_width = SizeOfDimension(weights, 2);\n   const int filter_height = SizeOfDimension(weights, 1);\n \n   int unused_output_height, unused_output_width;\n   data->padding = ComputePaddingHeightWidth(\n       params->stride_height, params->stride_width, 1, 1, height, width,\n       filter_height, filter_width, params->padding, &unused_output_height,\n       &unused_output_width);\n \n   switch (input->type) {\n     case kTfLiteFloat32: {\n       if (data->weights_are_transposed) {\n         if (!IsConstantTensor(weights)) {\n           ResizeAndTransposeWeights(context, weights, transposed_weights);\n         }\n       }\n       EvalFloat<kernel_type>(context, params, data, input, weights, bias,\n                              transposed_weights, col2im, output);\n       break;\n     }\n     case kTfLiteUInt8: {\n       TfLiteTensor* scratch_buffer;\n       TF_LITE_ENSURE_OK(\n           context, GetTemporarySafe(context, node, data->scratch_tensor_index,\n                                     &scratch_buffer));\n       if (IsDynamicTensor(scratch_buffer)) {\n         TF_LITE_ENSURE_OK(context,\n                           ResizeTensor(context, output_shape, scratch_buffer));\n       }\n       if (data->weights_are_transposed) {\n         if (!IsConstantTensor(weights)) {\n           ResizeAndTransposeWeights(context, weights, transposed_weights);\n         }\n       }\n       EvalQuantized<kernel_type>(context, params, data, input, weights,\n                                  transposed_weights, bias, col2im, output,\n                                  scratch_buffer);\n       break;\n     }\n     case kTfLiteInt8: {\n       TfLiteTensor* scratch_buffer;\n       TF_LITE_ENSURE_OK(\n           context, GetTemporarySafe(context, node, data->scratch_tensor_index,\n                                     &scratch_buffer));\n       if (IsDynamicTensor(scratch_buffer)) {\n         TF_LITE_ENSURE_OK(context,\n                           ResizeTensor(context, output_shape, scratch_buffer));\n       }\n       if (data->weights_are_transposed && !IsConstantTensor(weights)) {\n         ResizeAndTransposeWeights(context, weights, transposed_weights);\n       }\n       EvalQuantizedPerChannel<kernel_type>(context, params, data, input,\n                                            weights, transposed_weights, bias,\n                                            col2im, output, scratch_buffer);\n       break;\n     }\n     case kTfLiteInt16: {\n       TfLiteTensor* scratch_buffer;\n       TF_LITE_ENSURE_OK(\n           context, GetTemporarySafe(context, node, data->scratch_tensor_index,\n                                     &scratch_buffer));\n       if (IsDynamicTensor(scratch_buffer)) {\n         TF_LITE_ENSURE_OK(context,\n                           ResizeTensor(context, output_shape, scratch_buffer));\n       }\n       if (data->weights_are_transposed && !IsConstantTensor(weights)) {\n         ResizeAndTransposeWeights(context, weights, transposed_weights);\n       }\n       EvalQuantizedPerChannel16x8(context, params, data, input, weights,\n                                   transposed_weights, bias, col2im, output,\n                                   scratch_buffer);\n       break;\n     }\n     default:\n       context->ReportError(context, \"Type '%s' is not currently supported.\",\n                            TfLiteTypeGetName(input->type));\n       return kTfLiteError;\n   }\n   return kTfLiteOk;\n }\n \n", "target": "// fix_start\n\n  TF_LITE_ENSURE(context, params->stride_height > 0);\n  TF_LITE_ENSURE(context, params->stride_width > 0);\n// fix_end\n", "cwe": "CWE-369", "cwe_name": "Divide By Zero", "cve": "CVE-2021-29588", "cve_desc": "TensorFlow is an end-to-end open source platform for machine learning. The optimized implementation of the `TransposeConv` TFLite operator is [vulnerable to a division by zero error](https://github.com/tensorflow/tensorflow/blob/0d45ea1ca641b21b73bcf9c00e0179cda284e7e7/tensorflow/lite/kernels/internal/optimized/optimized_ops.h#L5221-L5222). An attacker can craft a model such that `stride_{h,w}` values are 0. Code calling this function must validate these arguments. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.", "project": "tensorflow", "idx": 197892}
{"source": " int ecall_restore(const char *input, uint64_t input_len, char **output,\n                   uint64_t *output_len) {\n   if (!asylo::primitives::TrustedPrimitives::IsOutsideEnclave(input,\n                                                               input_len) ||\n       !asylo::primitives::TrustedPrimitives::IsOutsideEnclave(\n// bug_start\n          output_len, sizeof(uint64_t))) {\n// bug_end\n     asylo::primitives::TrustedPrimitives::BestEffortAbort(\n         \"ecall_restore: input/output found to not be in untrusted memory.\");\n   }\n   int result = 0;\n   size_t tmp_output_len;\n   try {\n     result = asylo::Restore(input, static_cast<size_t>(input_len), output,\n                             &tmp_output_len);\n   } catch (...) {\n     LOG(FATAL) << \"Uncaught exception in enclave\";\n   }\n \n   if (output_len) {\n     *output_len = static_cast<uint64_t>(tmp_output_len);\n   }\n   return result;\n }\n \n", "target": "// fix_start\n          output_len, sizeof(uint64_t)) ||\n      !asylo::primitives::TrustedPrimitives::IsOutsideEnclave(output,\n                                                              *output_len)) {\n// fix_end\n", "cwe": "CWE-787", "cwe_name": "Out-of-bounds Write", "cve": "CVE-2020-8944", "cve_desc": "An arbitrary memory write vulnerability in Asylo versions up to 0.6.0 allows an untrusted attacker to make a call to ecall_restore using the attribute output which fails to check the range of a pointer. An attacker can use this pointer to write to arbitrary memory addresses including those within the secure enclave We recommend upgrading past commit 382da2b8b09cbf928668a2445efb778f76bd9c8a", "project": "asylo", "idx": 197910}
{"source": " CString CWebSock::GetSkinPath(const CString& sSkinName) {\n// bug_start\n    CString sRet = CZNC::Get().GetZNCPath() + \"/webskins/\" + sSkinName;\n// bug_end\n \n     if (!CFile::IsDir(sRet)) {\n// bug_start\n        sRet = CZNC::Get().GetCurPath() + \"/webskins/\" + sSkinName;\n// bug_end\n \n         if (!CFile::IsDir(sRet)) {\n// bug_start\n            sRet = CString(_SKINDIR_) + \"/\" + sSkinName;\n// bug_end\n         }\n     }\n \n     return sRet + \"/\";\n }\n \n", "target": "// fix_start\n    const CString sSkin = sSkinName.Replace_n(\"/\", \"_\").Replace_n(\".\", \"_\");\n\n    CString sRet = CZNC::Get().GetZNCPath() + \"/webskins/\" + sSkin;\n// fix_end\n// fix_start\n        sRet = CZNC::Get().GetCurPath() + \"/webskins/\" + sSkin;\n// fix_end\n// fix_start\n            sRet = CString(_SKINDIR_) + \"/\" + sSkin;\n// fix_end\n", "cwe": "CWE-22", "cwe_name": "Path Traversal", "cve": "CVE-2018-14056", "cve_desc": "ZNC before 1.7.1-rc1 is prone to a path traversal flaw via ../ in a web skin name to access files outside of the intended skins directories.", "project": "znc", "idx": 197927}
{"source": "// bug_start\nGF_Err gf_isom_set_extraction_slc(GF_ISOFile *the_file, u32 trackNumber, u32 StreamDescriptionIndex, const GF_SLConfig *slConfig)\n// bug_end\n {\n \tGF_TrackBox *trak;\n \tGF_SampleEntryBox *entry;\n \tGF_Err e;\n// bug_start\n\tGF_SLConfig **slc;\n// bug_end\n \n \ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n \tif (!trak) return GF_BAD_PARAM;\n \n \te = Media_GetSampleDesc(trak->Media, StreamDescriptionIndex, &entry, NULL);\n \tif (e) return e;\n \n// bug_start\n// bug_end\n \tswitch (entry->type) {\n \tcase GF_ISOM_BOX_TYPE_MP4S:\n \t\tif (((GF_MPEGSampleEntryBox *)entry)->esd->desc->slConfig->predefined != SLPredef_MP4) return GF_BAD_PARAM;\n// bug_start\n\t\tslc = & ((GF_MPEGSampleEntryBox *)entry)->slc;\n// bug_end\n \t\tbreak;\n \tcase GF_ISOM_BOX_TYPE_MP4A:\n \t\tif (((GF_MPEGAudioSampleEntryBox *)entry)->esd->desc->slConfig->predefined != SLPredef_MP4) return GF_BAD_PARAM;\n// bug_start\n\t\tslc = & ((GF_MPEGAudioSampleEntryBox *)entry)->slc;\n// bug_end\n \t\tbreak;\n \tcase GF_ISOM_BOX_TYPE_MP4V:\n \t\tif (((GF_MPEGVisualSampleEntryBox *)entry)->esd->desc->slConfig->predefined != SLPredef_MP4) return GF_BAD_PARAM;\n// bug_start\n\t\tslc = & ((GF_MPEGVisualSampleEntryBox *)entry)->slc;\n// bug_end\n \t\tbreak;\n \tdefault:\n \t\treturn GF_BAD_PARAM;\n \t}\n \n// bug_start\n\tif (*slc) {\n\t\tgf_odf_desc_del((GF_Descriptor *)*slc);\n\t\t*slc = NULL;\n\t}\n\tif (!slConfig) return GF_OK;\n\treturn gf_odf_desc_copy((GF_Descriptor *) slConfig, (GF_Descriptor **) slc);\n// bug_end\n }\n \n", "target": "// fix_start\nGF_Err gf_isom_get_extraction_slc(GF_ISOFile *the_file, u32 trackNumber, u32 StreamDescriptionIndex, GF_SLConfig **slConfig)\n// fix_end\n// fix_start\n\tGF_SLConfig *slc;\n// fix_end\n// fix_start\n\tslc = NULL;\n\t*slConfig = NULL;\n// fix_end\n// fix_start\n\t\tslc = ((GF_MPEGSampleEntryBox *)entry)->slc;\n// fix_end\n// fix_start\n\t\tslc = ((GF_MPEGAudioSampleEntryBox *)entry)->slc;\n// fix_end\n// fix_start\n\t\tslc = ((GF_MPEGVisualSampleEntryBox *)entry)->slc;\n// fix_end\n// fix_start\n\tif (!slc) return GF_OK;\n\treturn gf_odf_desc_copy((GF_Descriptor *) slc, (GF_Descriptor **) slConfig);\n// fix_end\n", "cwe": "CWE-476", "cwe_name": "NULL Pointer Dereference", "cve": "CVE-2021-31258", "cve_desc": "The gf_isom_set_extraction_slc function in GPAC 1.0.1 allows attackers to cause a denial of service (NULL pointer dereference) via a crafted file in the MP4Box command.", "project": "gpac", "idx": 197972}
{"source": " inline size_t codepoint_length(const char *s8, size_t l) {\n   if (l) {\n     auto b = static_cast<uint8_t>(s8[0]);\n     if ((b & 0x80) == 0) {\n       return 1;\n// bug_start\n    } else if ((b & 0xE0) == 0xC0) {\n// bug_end\n       return 2;\n// bug_start\n    } else if ((b & 0xF0) == 0xE0) {\n// bug_end\n       return 3;\n// bug_start\n    } else if ((b & 0xF8) == 0xF0) {\n// bug_end\n       return 4;\n     }\n   }\n   return 0;\n }\n \n", "target": "// fix_start\n    } else if ((b & 0xE0) == 0xC0 && l >= 2) {\n// fix_end\n// fix_start\n    } else if ((b & 0xF0) == 0xE0 && l >= 3) {\n// fix_end\n// fix_start\n    } else if ((b & 0xF8) == 0xF0 && l >= 4) {\n// fix_end\n", "cwe": "CWE-125", "cwe_name": "Out-of-bounds Read", "cve": "CVE-2020-23915", "cve_desc": "An issue was discovered in cpp-peglib through v0.1.12. peg::resolve_escape_sequence() in peglib.h has a heap-based buffer over-read.", "project": "cpp-peglib", "idx": 197987}
{"source": "   void Compute(OpKernelContext* context) override {\n     const Tensor* reverse_index_map_t;\n     const Tensor* grad_values_t;\n     OP_REQUIRES_OK(context,\n                    context->input(\"reverse_index_map\", &reverse_index_map_t));\n     OP_REQUIRES_OK(context, context->input(\"grad_values\", &grad_values_t));\n \n     const CPUDevice& d = context->eigen_device<CPUDevice>();\n \n     OP_REQUIRES(\n         context, TensorShapeUtils::IsVector(reverse_index_map_t->shape()),\n         errors::InvalidArgument(\"reverse_index_map must be a vector, saw: \",\n                                 reverse_index_map_t->shape().DebugString()));\n// bug_start\n// bug_end\n \n     const auto reverse_index_map = reverse_index_map_t->vec<int64>();\n     const auto grad_values = grad_values_t->vec<T>();\n \n     const int64 N = reverse_index_map_t->shape().dim_size(0);\n     const int64 N_full = grad_values_t->shape().dim_size(0);\n \n     Tensor* d_values_t;\n     OP_REQUIRES_OK(context, context->allocate_output(\n                                 \"d_values\", TensorShape({N}), &d_values_t));\n     auto d_values = d_values_t->vec<T>();\n     Tensor* d_default_value_t;\n     OP_REQUIRES_OK(context,\n                    context->allocate_output(\"d_default_value\", TensorShape({}),\n                                             &d_default_value_t));\n     T& d_default_value = d_default_value_t->scalar<T>()();\n     d_default_value = T();\n \n     Tensor visited_t;\n     OP_REQUIRES_OK(context, context->allocate_temp(\n                                 DT_BOOL, TensorShape({N_full}), &visited_t));\n     auto visited = visited_t.vec<bool>();\n     visited.device(d) = visited.constant(false);\n \n     for (int i = 0; i < N; ++i) {\n// bug_start\n      d_values(i) = grad_values(reverse_index_map(i));\n      visited(reverse_index_map(i)) = true;\n// bug_end\n     }\n     for (int j = 0; j < N_full; ++j) {\n       if (!visited(j)) {\n         d_default_value += grad_values(j);\n       }\n     }\n   }\n \n", "target": "// fix_start\n    OP_REQUIRES(context, TensorShapeUtils::IsVector(grad_values_t->shape()),\n                errors::InvalidArgument(\"grad_values must be a vector, saw: \",\n                                        grad_values_t->shape().DebugString()));\n// fix_end\n// fix_start\n      int64 reverse_index = reverse_index_map(i);\n      OP_REQUIRES(\n          context, 0 <= reverse_index && reverse_index < N_full,\n          errors::InvalidArgument(\"Elements in reverse index must be in [0, \",\n                                  N_full, \") but got \", reverse_index));\n      d_values(i) = grad_values(reverse_index);\n      visited(reverse_index) = true;\n// fix_end\n", "cwe": "CWE-703", "cwe_name": "Improper Check or Handling of Exceptional Conditions", "cve": "CVE-2020-15194", "cve_desc": "In Tensorflow before versions 1.15.4, 2.0.3, 2.1.2, 2.2.1 and 2.3.1, the `SparseFillEmptyRowsGrad` implementation has incomplete validation of the shapes of its arguments. Although `reverse_index_map_t` and `grad_values_t` are accessed in a similar pattern, only `reverse_index_map_t` is validated to be of proper shape. Hence, malicious users can pass a bad `grad_values_t` to trigger an assertion failure in `vec`, causing denial of service in serving installations. The issue is patched in commit 390611e0d45c5793c7066110af37c8514e6a6c54, and is released in TensorFlow versions 1.15.4, 2.0.3, 2.1.2, 2.2.1, or 2.3.1.\"", "project": "tensorflow", "idx": 197988}
{"source": " GF_Err stbl_AppendSize(GF_SampleTableBox *stbl, u32 size, u32 nb_pack)\n {\n \tu32 i;\n// bug_start\n\tif (!nb_pack) nb_pack = 1;\n// bug_end\n \n \tif (!stbl->SampleSize->sampleCount) {\n \t\tstbl->SampleSize->sampleSize = size;\n \t\tstbl->SampleSize->sampleCount += nb_pack;\n \t\treturn GF_OK;\n \t}\n \tif (stbl->SampleSize->sampleSize && (stbl->SampleSize->sampleSize==size)) {\n \t\tstbl->SampleSize->sampleCount += nb_pack;\n \t\treturn GF_OK;\n \t}\n// bug_start\n// bug_end\n \tif (!stbl->SampleSize->sizes || (stbl->SampleSize->sampleCount+nb_pack > stbl->SampleSize->alloc_size)) {\n \t\tBool init_table = (stbl->SampleSize->sizes==NULL) ? 1 : 0;\n \t\tALLOC_INC(stbl->SampleSize->alloc_size);\n// bug_start\n\t\tif (stbl->SampleSize->sampleCount+nb_pack > stbl->SampleSize->alloc_size)\n// bug_end\n \t\t\tstbl->SampleSize->alloc_size = stbl->SampleSize->sampleCount+nb_pack;\n// bug_start\n// bug_end\n \n \t\tstbl->SampleSize->sizes = (u32 *)gf_realloc(stbl->SampleSize->sizes, sizeof(u32)*stbl->SampleSize->alloc_size);\n \t\tif (!stbl->SampleSize->sizes) return GF_OUT_OF_MEM;\n \t\tmemset(&stbl->SampleSize->sizes[stbl->SampleSize->sampleCount], 0, sizeof(u32) * (stbl->SampleSize->alloc_size - stbl->SampleSize->sampleCount) );\n \n \t\tif (init_table) {\n \t\t\tfor (i=0; i<stbl->SampleSize->sampleCount; i++)\n \t\t\t\tstbl->SampleSize->sizes[i] = stbl->SampleSize->sampleSize;\n \t\t}\n \t}\n \tstbl->SampleSize->sampleSize = 0;\n \tfor (i=0; i<nb_pack; i++) {\n \t\tstbl->SampleSize->sizes[stbl->SampleSize->sampleCount+i] = size;\n \t}\n \tstbl->SampleSize->sampleCount += nb_pack;\n \tif (size > stbl->SampleSize->max_size)\n \t\tstbl->SampleSize->max_size = size;\n \tstbl->SampleSize->total_size += size;\n \tstbl->SampleSize->total_samples += nb_pack;\n \treturn GF_OK;\n }\n \n", "target": "// fix_start\n\tCHECK_PACK(GF_ISOM_INVALID_FILE)\n// fix_end\n// fix_start\n\n// fix_end\n// fix_start\n\t\tif (stbl->SampleSize->sampleCount+nb_pack > stbl->SampleSize->alloc_size) {\n// fix_end\n// fix_start\n\t\t}\n// fix_end\n", "cwe": "CWE-787", "cwe_name": "Out-of-bounds Write", "cve": "CVE-2021-32439", "cve_desc": "Buffer overflow in the stbl_AppendSize function in MP4Box in GPAC 1.0.1 allows attackers to cause a denial of service or execute arbitrary code via a crafted file.", "project": "gpac", "idx": 197993}
{"source": "   void Compute(OpKernelContext* context) override {\n     const Tensor& x = context->input(0);\n     const Tensor& y = context->input(1);\n     const float min_x = context->input(2).flat<float>()(0);\n     const float max_x = context->input(3).flat<float>()(0);\n     const float min_y = context->input(4).flat<float>()(0);\n     const float max_y = context->input(5).flat<float>()(0);\n \n     BCast bcast(BCast::FromShape(x.shape()), BCast::FromShape(y.shape()));\n     if (!bcast.IsValid()) {\n       context->SetStatus(errors::InvalidArgument(\n           \"Incompatible shapes: \", x.shape().DebugString(), \" vs. \",\n           y.shape().DebugString()));\n       return;\n     }\n     Tensor* z;\n     OP_REQUIRES_OK(context, context->allocate_output(\n                                 0, BCast::ToShape(bcast.output_shape()), &z));\n \n     OP_REQUIRES(context, (max_x > min_x),\n                 errors::InvalidArgument(\"max_x must be larger than min_x.\"));\n     OP_REQUIRES(context, (max_y > min_y),\n                 errors::InvalidArgument(\"max_y must be larger than min_y.\"));\n     const T* x_data = x.flat<T>().data();\n     const T* y_data = y.flat<T>().data();\n     Toutput* z_data = z->flat<Toutput>().data();\n \n     const float smallest_min = std::min(min_x, min_y);\n     const float largest_max = std::max(max_x, max_y);\n     const float biggest_range =\n         std::max(std::abs(smallest_min), std::abs(largest_max));\n     const float output_range = (biggest_range * (1 << 14));\n     const float min_z_value = -output_range;\n     const float max_z_value = output_range;\n \n     const int ndims = bcast.x_reshape().size();\n     if (ndims <= 1) {\n       if (x.NumElements() == 1) {\n         ScalarAddition<T, Toutput>(context, y_data, min_y, max_y,\n                                    y.NumElements(), x_data[0], min_x, max_x,\n                                    min_z_value, max_z_value, z_data);\n       } else if (y.NumElements() == 1) {\n         ScalarAddition<T, Toutput>(context, x_data, min_x, max_x,\n                                    x.NumElements(), y_data[0], min_y, max_y,\n                                    min_z_value, max_z_value, z_data);\n       } else {\n         VectorAddition<T, Toutput>(context, x_data, min_x, max_x, y_data, min_y,\n                                    max_y, x.NumElements(), min_z_value,\n                                    max_z_value, z_data);\n       }\n     } else if (ndims == 2) {\n       const T* vector_data;\n       int64 vector_num_elements;\n       float vector_min;\n       float vector_max;\n       const T* tensor_data;\n       int64 tensor_num_elements;\n       float tensor_min;\n       float tensor_max;\n       if (x.NumElements() < y.NumElements()) {\n         vector_data = x_data;\n         vector_num_elements = x.NumElements();\n         vector_min = min_x;\n         vector_max = max_x;\n         tensor_data = y_data;\n         tensor_num_elements = y.NumElements();\n         tensor_min = min_y;\n         tensor_max = max_y;\n       } else {\n         vector_data = y_data;\n         vector_num_elements = y.NumElements();\n         vector_min = min_y;\n         vector_max = max_y;\n         tensor_data = x_data;\n         tensor_num_elements = x.NumElements();\n         tensor_min = min_x;\n         tensor_max = max_x;\n       }\n// bug_start\n// bug_end\n       VectorTensorAddition<T, Toutput>(\n           vector_data, vector_min, vector_max, vector_num_elements, tensor_data,\n           tensor_min, tensor_max, tensor_num_elements, min_z_value, max_z_value,\n           z_data);\n     } else {\n       LOG(INFO) << \"ndims=\" << ndims;\n       LOG(INFO) << \"bcast.x_reshape()=\"\n                 << TensorShape(bcast.x_reshape()).DebugString();\n       LOG(INFO) << \"bcast.y_reshape()=\"\n                 << TensorShape(bcast.y_reshape()).DebugString();\n       LOG(INFO) << \"bcast.x_bcast()=\"\n                 << TensorShape(bcast.x_bcast()).DebugString();\n       LOG(INFO) << \"bcast.y_bcast()=\"\n                 << TensorShape(bcast.y_bcast()).DebugString();\n \n       context->SetStatus(errors::Unimplemented(\n           \"Broadcast between \", context->input(0).shape().DebugString(),\n           \" and \", context->input(1).shape().DebugString(),\n           \" is not supported yet.\"));\n       return;\n     }\n \n     Tensor* z_min = nullptr;\n     OP_REQUIRES_OK(context, context->allocate_output(1, {}, &z_min));\n     z_min->flat<float>()(0) = min_z_value;\n \n     Tensor* z_max = nullptr;\n     OP_REQUIRES_OK(context, context->allocate_output(2, {}, &z_max));\n     z_max->flat<float>()(0) = max_z_value;\n   }\n \n", "target": "// fix_start\n      OP_REQUIRES(context, vector_num_elements > 0,\n                  errors::InvalidArgument(\"Must have some elements to add\"));\n// fix_end\n", "cwe": "CWE-369", "cwe_name": "Divide By Zero", "cve": "CVE-2021-29549", "cve_desc": "TensorFlow is an end-to-end open source platform for machine learning. An attacker can cause a runtime division by zero error and denial of service in `tf.raw_ops.QuantizedBatchNormWithGlobalNormalization`. This is because the implementation(https://github.com/tensorflow/tensorflow/blob/6f26b3f3418201479c264f2a02000880d8df151c/tensorflow/core/kernels/quantized_add_op.cc#L289-L295) computes a modulo operation without validating that the divisor is not zero. Since `vector_num_elements` is determined based on input shapes(https://github.com/tensorflow/tensorflow/blob/6f26b3f3418201479c264f2a02000880d8df151c/tensorflow/core/kernels/quantized_add_op.cc#L522-L544), a user can trigger scenarios where this quantity is 0. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.", "project": "tensorflow", "idx": 198002}
{"source": " void OneHotComputeImpl(const OneHotContext& op_context) {\n   int prefix_dim_size = 1;\n   for (int i = 0; i < op_context.axis; ++i) {\n     prefix_dim_size *= op_context.indices->dims->data[i];\n// bug_start\n// bug_end\n   }\n   const int suffix_dim_size = NumElements(op_context.indices) / prefix_dim_size;\n   const int depth = *op_context.depth->data.i32;\n \n   const T on_value = *GetTensorData<T>(op_context.on_value);\n   const T off_value = *GetTensorData<T>(op_context.off_value);\n \n   T* output = GetTensorData<T>(op_context.output);\n   const TI* indices = GetTensorData<TI>(op_context.indices);\n   for (int i = 0; i < prefix_dim_size; ++i) {\n     for (int j = 0; j < depth; ++j) {\n       for (int k = 0; k < suffix_dim_size; ++k, ++output) {\n         *output = static_cast<int>(indices[i * suffix_dim_size + k]) == j\n                       ? on_value\n                       : off_value;\n       }\n     }\n   }\n }\n \n", "target": "// fix_start\n  }\n  if (prefix_dim_size == 0) {\n    return;\n// fix_end\n", "cwe": "CWE-369", "cwe_name": "Divide By Zero", "cve": "CVE-2021-29600", "cve_desc": "TensorFlow is an end-to-end open source platform for machine learning. The implementation of the `OneHot` TFLite operator is vulnerable to a division by zero error(https://github.com/tensorflow/tensorflow/blob/f61c57bd425878be108ec787f4d96390579fb83e/tensorflow/lite/kernels/one_hot.cc#L68-L72). An attacker can craft a model such that at least one of the dimensions of `indices` would be 0. In turn, the `prefix_dim_size` value would become 0. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.", "project": "tensorflow", "idx": 198007}
{"source": "   void Compute(OpKernelContext* context) override {\n     const int64 axis_input = context->input(0).scalar<int64>()();\n     const Tensor& input_indices = context->input(1);\n     const Tensor& input_values = context->input(2);\n     const Tensor& input_shape = context->input(3);\n \n     OP_REQUIRES(context, TensorShapeUtils::IsMatrix(input_indices.shape()),\n                 errors::InvalidArgument(\n                     \"Input indices should be a matrix but received shape \",\n                     input_indices.shape().DebugString()));\n     OP_REQUIRES(context, TensorShapeUtils::IsVector(input_values.shape()),\n                 errors::InvalidArgument(\n                     \"Input values should be a vector but received shape \",\n                     input_indices.shape().DebugString()));\n     OP_REQUIRES(context, TensorShapeUtils::IsVector(input_shape.shape()),\n                 errors::InvalidArgument(\n                     \"Input shape should be a vector but received shape \",\n                     input_shape.shape().DebugString()));\n \n     const int64 input_rank = input_shape.vec<int64>().size();\n     const int64 axis = (axis_input < 0) ? input_rank + axis_input : axis_input;\n \n     OP_REQUIRES(\n         context, axis >= 0 && axis < input_rank,\n         errors::InvalidArgument(\"Input axis should be in range [\", -input_rank,\n                                 \", \", input_rank, \"), got \", axis_input));\n \n     OP_REQUIRES(context,\n                 num_split_ >= 1 && num_split_ <= input_shape.vec<int64>()(axis),\n                 errors::InvalidArgument(\"Input num_split should be between 1 \"\n                                         \"and the splitting dimension size (\",\n                                         input_shape.vec<int64>()(axis),\n                                         \"), got \", num_split_));\n \n// bug_start\n// bug_end\n     sparse::SparseTensor sparse_tensor;\n     OP_REQUIRES_OK(context,\n// bug_start\n                   sparse::SparseTensor::Create(\n                       input_indices, input_values,\n                       TensorShape(input_shape.vec<int64>()), &sparse_tensor));\n// bug_end\n \n     std::vector<sparse::SparseTensor> outputs;\n     OP_REQUIRES_OK(context, sparse::SparseTensor::Split<T>(\n                                 sparse_tensor, axis, num_split_, &outputs));\n \n     for (int slice_index = 0; slice_index < num_split_; ++slice_index) {\n       context->set_output(slice_index, outputs[slice_index].indices());\n       context->set_output(slice_index + num_split_,\n                           outputs[slice_index].values());\n       Tensor* shape = nullptr;\n       OP_REQUIRES_OK(context, context->allocate_output(\n                                   slice_index + 2 * num_split_,\n                                   {outputs[slice_index].dims()}, &shape));\n       auto output_shape = outputs[slice_index].shape();\n       for (int dim = 0; dim < outputs[slice_index].dims(); ++dim) {\n         shape->vec<int64>()(dim) = output_shape[dim];\n       }\n     }\n   }\n \n", "target": "// fix_start\n    TensorShape dense_shape;\n    const auto input_shape_flat = input_shape.flat<int64>();\n    for (int i = 0; i < input_shape.NumElements(); i++) {\n      OP_REQUIRES_OK(context,\n                     dense_shape.AddDimWithStatus(input_shape_flat(i)));\n    }\n\n// fix_end\n// fix_start\n                   sparse::SparseTensor::Create(input_indices, input_values,\n                                                dense_shape, &sparse_tensor));\n// fix_end\n", "cwe": "CWE-369", "cwe_name": "Divide By Zero", "cve": "CVE-2021-29584", "cve_desc": "TensorFlow is an end-to-end open source platform for machine learning. An attacker can trigger a denial of service via a `CHECK`-fail in caused by an integer overflow in constructing a new tensor shape. This is because the implementation(https://github.com/tensorflow/tensorflow/blob/0908c2f2397c099338b901b067f6495a5b96760b/tensorflow/core/kernels/sparse_split_op.cc#L66-L70) builds a dense shape without checking that the dimensions would not result in overflow. The `TensorShape` constructor(https://github.com/tensorflow/tensorflow/blob/6f9896890c4c703ae0a0845394086e2e1e523299/tensorflow/core/framework/tensor_shape.cc#L183-L188) uses a `CHECK` operation which triggers when `InitDims`(https://github.com/tensorflow/tensorflow/blob/6f9896890c4c703ae0a0845394086e2e1e523299/tensorflow/core/framework/tensor_shape.cc#L212-L296) returns a non-OK status. This is a legacy implementation of the constructor and operations should use `BuildTensorShapeBase` or `AddDimWithStatus` to prevent `CHECK`-failures in the presence of overflows. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.", "project": "tensorflow", "idx": 198015}
{"source": " GF_Err gf_hinter_finalize(GF_ISOFile *file, GF_SDP_IODProfile IOD_Profile, u32 bandwidth)\n {\n \tu32 i, sceneT, odT, descIndex, size, size64;\n \tGF_InitialObjectDescriptor *iod;\n \tGF_SLConfig slc;\n \tGF_ISOSample *samp;\n \tBool remove_ocr;\n \tu8 *buffer;\n \tchar buf64[5000], sdpLine[5100];\n \n \n \tgf_isom_sdp_clean(file);\n \n \tif (bandwidth) {\n \t\tsprintf(buf64, \"b=AS:%d\", bandwidth);\n \t\tgf_isom_sdp_add_line(file, buf64);\n \t}\n     if (gf_sys_is_test_mode()) {\n         sprintf(buf64, \"a=x-copyright: %s\", \"MP4/3GP File hinted with GPAC - (c) Telecom ParisTech (http://gpac.io)\");\n     } else {\n         sprintf(buf64, \"a=x-copyright: MP4/3GP File hinted with GPAC %s - %s\", gf_gpac_version(), gf_gpac_copyright() );\n     }\n \tgf_isom_sdp_add_line(file, buf64);\n \n \tif (IOD_Profile == GF_SDP_IOD_NONE) return GF_OK;\n \n \todT = sceneT = 0;\n \tfor (i=0; i<gf_isom_get_track_count(file); i++) {\n \t\tif (!gf_isom_is_track_in_root_od(file, i+1)) continue;\n \t\tswitch (gf_isom_get_media_type(file,i+1)) {\n \t\tcase GF_ISOM_MEDIA_OD:\n \t\t\todT = i+1;\n \t\t\tbreak;\n \t\tcase GF_ISOM_MEDIA_SCENE:\n \t\t\tsceneT = i+1;\n \t\t\tbreak;\n \t\t}\n \t}\n \tremove_ocr = 0;\n \tif (IOD_Profile == GF_SDP_IOD_ISMA_STRICT) {\n \t\tIOD_Profile = GF_SDP_IOD_ISMA;\n \t\tremove_ocr = 1;\n \t}\n \n \tif ( (IOD_Profile == GF_SDP_IOD_ISMA) && !sceneT ) return GF_BAD_PARAM;\n \n \tiod = (GF_InitialObjectDescriptor *) gf_isom_get_root_od(file);\n \tif (!iod) return GF_NOT_SUPPORTED;\n \n \tif (IOD_Profile == GF_SDP_IOD_ISMA) {\n \t\tGF_ESD *esd;\n \t\tBool is_ok = 1;\n \t\twhile (gf_list_count(iod->ESDescriptors)) {\n \t\t\tesd = (GF_ESD*)gf_list_get(iod->ESDescriptors, 0);\n \t\t\tgf_odf_desc_del((GF_Descriptor *) esd);\n \t\t\tgf_list_rem(iod->ESDescriptors, 0);\n \t\t}\n \n \n \t\tif (odT) {\n \t\t\tesd = gf_isom_get_esd(file, odT, 1);\n \t\t\tif (gf_isom_get_sample_count(file, odT)==1) {\n \t\t\t\tsamp = gf_isom_get_sample(file, odT, 1, &descIndex);\n \t\t\t\tif (samp && gf_hinter_can_embbed_data(samp->data, samp->dataLength, GF_STREAM_OD)) {\n \t\t\t\t\tInitSL_NULL(&slc);\n \t\t\t\t\tslc.predefined = 0;\n \t\t\t\t\tslc.hasRandomAccessUnitsOnlyFlag = 1;\n \t\t\t\t\tslc.timeScale = slc.timestampResolution = gf_isom_get_media_timescale(file, odT);\n \t\t\t\t\tslc.OCRResolution = 1000;\n \t\t\t\t\tslc.startCTS = samp->DTS+samp->CTS_Offset;\n \t\t\t\t\tslc.startDTS = samp->DTS;\n \t\t\t\t\tgf_isom_set_extraction_slc(file, odT, 1, &slc);\n \n \t\t\t\t\tsize64 = gf_base64_encode(samp->data, samp->dataLength, buf64, 2000);\n \t\t\t\t\tbuf64[size64] = 0;\n \t\t\t\t\tsprintf(sdpLine, \"data:application/mpeg4-od-au;base64,%s\", buf64);\n \n \t\t\t\t\tesd->decoderConfig->avgBitrate = 0;\n \t\t\t\t\tesd->decoderConfig->bufferSizeDB = samp->dataLength;\n \t\t\t\t\tesd->decoderConfig->maxBitrate = 0;\n \t\t\t\t\tsize64 = (u32) strlen(sdpLine)+1;\n \t\t\t\t\tesd->URLString = (char*)gf_malloc(sizeof(char) * size64);\n \t\t\t\t\tstrcpy(esd->URLString, sdpLine);\n \t\t\t\t} else {\n \t\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_RTP, (\"[rtp hinter] OD sample too large to be embedded in IOD - ISMA disabled\\n\"));\n \t\t\t\t\tis_ok = 0;\n \t\t\t\t}\n \t\t\t\tgf_isom_sample_del(&samp);\n \t\t\t}\n \t\t\tif (remove_ocr) esd->OCRESID = 0;\n \t\t\telse if (esd->OCRESID == esd->ESID) esd->OCRESID = 0;\n \n \t\t\tgf_list_add(iod->ESDescriptors, esd);\n \t\t}\n \n \t\tesd = gf_isom_get_esd(file, sceneT, 1);\n \t\tif (gf_isom_get_sample_count(file, sceneT)==1) {\n \t\t\tsamp = gf_isom_get_sample(file, sceneT, 1, &descIndex);\n// bug_start\n\t\t\tif (gf_hinter_can_embbed_data(samp->data, samp->dataLength, GF_STREAM_SCENE)) {\n// bug_end\n \n \t\t\t\tslc.timeScale = slc.timestampResolution = gf_isom_get_media_timescale(file, sceneT);\n \t\t\t\tslc.OCRResolution = 1000;\n \t\t\t\tslc.startCTS = samp->DTS+samp->CTS_Offset;\n \t\t\t\tslc.startDTS = samp->DTS;\n \t\t\t\tgf_isom_set_extraction_slc(file, sceneT, 1, &slc);\n \t\t\t\tsize64 = gf_base64_encode(samp->data, samp->dataLength, buf64, 2000);\n \t\t\t\tbuf64[size64] = 0;\n \t\t\t\tsprintf(sdpLine, \"data:application/mpeg4-bifs-au;base64,%s\", buf64);\n \n \t\t\t\tesd->decoderConfig->avgBitrate = 0;\n \t\t\t\tesd->decoderConfig->bufferSizeDB = samp->dataLength;\n \t\t\t\tesd->decoderConfig->maxBitrate = 0;\n \t\t\t\tesd->URLString = (char*)gf_malloc(sizeof(char) * (strlen(sdpLine)+1));\n \t\t\t\tstrcpy(esd->URLString, sdpLine);\n \t\t\t} else {\n \t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_RTP, (\"[rtp hinter] Scene description sample too large to be embedded in IOD - ISMA disabled\\n\"));\n \t\t\t\tis_ok = 0;\n \t\t\t}\n \t\t\tgf_isom_sample_del(&samp);\n \t\t}\n \t\tif (remove_ocr) esd->OCRESID = 0;\n \t\telse if (esd->OCRESID == esd->ESID) esd->OCRESID = 0;\n \n \t\tgf_list_add(iod->ESDescriptors, esd);\n \n \t\tif (is_ok) {\n \t\t\tu32 has_a, has_v, has_i_a, has_i_v;\n \t\t\thas_a = has_v = has_i_a = has_i_v = 0;\n \t\t\tfor (i=0; i<gf_isom_get_track_count(file); i++) {\n \t\t\t\tesd = gf_isom_get_esd(file, i+1, 1);\n \t\t\t\tif (!esd) continue;\n \t\t\t\tif (esd->decoderConfig->streamType==GF_STREAM_VISUAL) {\n \t\t\t\t\tif (esd->decoderConfig->objectTypeIndication==GF_CODECID_MPEG4_PART2) has_i_v ++;\n \t\t\t\t\telse has_v++;\n \t\t\t\t} else if (esd->decoderConfig->streamType==GF_STREAM_AUDIO) {\n \t\t\t\t\tif (esd->decoderConfig->objectTypeIndication==GF_CODECID_AAC_MPEG4) has_i_a ++;\n \t\t\t\t\telse has_a++;\n \t\t\t\t}\n \t\t\t\tgf_odf_desc_del((GF_Descriptor *)esd);\n \t\t\t}\n \t\t\tif (!has_v && !has_a && (has_i_v<=1) && (has_i_a<=1)) {\n \t\t\t\tsprintf(sdpLine, \"a=isma-compliance:1,1.0,1\");\n \t\t\t\tgf_isom_sdp_add_line(file, sdpLine);\n \t\t\t}\n \t\t}\n \t}\n \n \tbuffer = NULL;\n \tsize = 0;\n \tgf_odf_desc_write((GF_Descriptor *) iod, &buffer, &size);\n \tgf_odf_desc_del((GF_Descriptor *)iod);\n \n \tsize64 = gf_base64_encode(buffer, size, buf64, 2000);\n \tbuf64[size64] = 0;\n \tgf_free(buffer);\n \n \tsprintf(sdpLine, \"a=mpeg4-iod:\\\"data:application/mpeg4-iod;base64,%s\\\"\", buf64);\n \tgf_isom_sdp_add_line(file, sdpLine);\n \n \treturn GF_OK;\n }\n \n", "target": "// fix_start\n\t\t\tif (samp && gf_hinter_can_embbed_data(samp->data, samp->dataLength, GF_STREAM_SCENE)) {\n// fix_end\n", "cwe": "CWE-476", "cwe_name": "NULL Pointer Dereference", "cve": "CVE-2021-32437", "cve_desc": "The gf_hinter_finalize function in GPAC 1.0.1 allows attackers to cause a denial of service (NULL pointer dereference) via a crafted file in the MP4Box command.", "project": "gpac", "idx": 198018}
{"source": " Status GraphConstructor::MakeEdge(Node* src, int output_index, Node* dst,\n                                   int input_index) {\n// bug_start\n// bug_end\n   DataType src_out = src->output_type(output_index);\n   DataType dst_in = dst->input_type(input_index);\n   if (!TypesCompatible(dst_in, src_out)) {\n     return errors::InvalidArgument(\n         \"Input \", input_index, \" of node \", dst->name(), \" was passed \",\n         DataTypeString(src_out), \" from \", src->name(), \":\", output_index,\n         \" incompatible with expected \", DataTypeString(dst_in), \".\");\n   }\n   g_->AddEdge(src, output_index, dst, input_index);\n   return Status::OK();\n }\n \n", "target": "// fix_start\n  if (output_index >= src->num_outputs()) {\n    return errors::InvalidArgument(\n        \"Output \", output_index, \" of node \", src->name(),\n        \" does not exist. Node only has \", src->num_outputs(), \" outputs.\");\n  }\n  if (input_index >= dst->num_inputs()) {\n    return errors::InvalidArgument(\n        \"Input \", input_index, \" of node \", dst->name(),\n        \" does not exist. Node only has \", dst->num_inputs(), \" inputs.\");\n  }\n\n// fix_end\n", "cwe": "CWE-369", "cwe_name": "Divide By Zero", "cve": "CVE-2020-26271", "cve_desc": "In affected versions of TensorFlow under certain cases, loading a saved model can result in accessing uninitialized memory while building the computation graph. The MakeEdge function creates an edge between one output tensor of the src node (given by output_index) and the input slot of the dst node (given by input_index). This is only possible if the types of the tensors on both sides coincide, so the function begins by obtaining the corresponding DataType values and comparing these for equality. However, there is no check that the indices point to inside of the arrays they index into. Thus, this can result in accessing data out of bounds of the corresponding heap allocated arrays. In most scenarios, this can manifest as unitialized data access, but if the index points far away from the boundaries of the arrays this can be used to leak addresses from the library. This is fixed in versions 1.15.5, 2.0.4, 2.1.3, 2.2.2, 2.3.2, and 2.4.0.", "project": "tensorflow", "idx": 198049}
{"source": " static int download(struct SPDBDownloader *pd) {\n \tSPDBDownloaderOpt *opt = pd->opt;\n// bug_start\n\tchar *curl_cmd = NULL;\n\tchar *extractor_cmd = NULL;\n\tchar *abspath_to_archive = NULL;\n\tchar *abspath_to_file = NULL;\n\tchar *archive_name = NULL;\n\tsize_t archive_name_len = 0;\n\tchar *symbol_store_path = NULL;\n\tchar *dbg_file = NULL;\n\tchar *guid = NULL;\n\tchar *archive_name_escaped  = NULL;\n\tchar *user_agent = NULL;\n\tchar *symbol_server = NULL;\n\n// bug_end\n \tint res = 0;\n \tint cmd_ret;\n// bug_start\n// bug_end\n \tif (!opt->dbg_file || !*opt->dbg_file) {\n \t\treturn 0;\n \t}\n// bug_start\n\tif (!checkCurl ()) {\n\t\treturn 0;\n\t}\n\tarchive_name_len = strlen (opt->dbg_file);\n\tarchive_name = malloc (archive_name_len + 1);\n\tif (!archive_name) {\n\t\treturn 0;\n\t}\n\tmemcpy (archive_name, opt->dbg_file, archive_name_len + 1);\n\tarchive_name[archive_name_len - 1] = '_';\n\tsymbol_store_path = r_str_escape (opt->symbol_store_path);\n\tdbg_file = r_str_escape (opt->dbg_file);\n\tguid = r_str_escape (opt->guid);\n\tarchive_name_escaped = r_str_escape (archive_name);\n\tuser_agent = r_str_escape (opt->user_agent);\n\tsymbol_server = r_str_escape (opt->symbol_server);\n// bug_end\n \n// bug_start\n\tabspath_to_archive = r_str_newf (\"%s%s%s%s%s%s%s\",\n\t\t\t    symbol_store_path, R_SYS_DIR,\n\t\t\t    dbg_file, R_SYS_DIR,\n\t\t\t    guid, R_SYS_DIR,\n\t\t\t    archive_name_escaped);\n// bug_end\n \n// bug_start\n\tabspath_to_file = strdup (abspath_to_archive);\n\tabspath_to_file[strlen (abspath_to_file) - 1] = 'b';\n// bug_end\n \tif (r_file_exists (abspath_to_file)) {\n \t\teprintf (\"File already downloaded.\\n\");\n// bug_start\n\t\tR_FREE (user_agent);\n\t\tR_FREE (abspath_to_archive);\n\t\tR_FREE (archive_name_escaped);\n\t\tR_FREE (symbol_store_path);\n\t\tR_FREE (dbg_file);\n\t\tR_FREE (guid);\n\t\tR_FREE (archive_name);\n\t\tR_FREE (abspath_to_file);\n\t\tR_FREE (symbol_server);\n// bug_end\n \t\treturn 1;\n \t}\n \n \tif (checkExtract () || opt->extract == 0) {\n// bug_start\n\t\tres = 1;\n// bug_end\n \n// bug_start\n\t\tcurl_cmd = r_str_newf (\"curl -sfLA \\\"%s\\\" \\\"%s/%s/%s/%s\\\" --create-dirs -o \\\"%s\\\"\",\n\t\t                       user_agent,\n\t\t                       symbol_server,\n\t\t\t\t\t\t\t   dbg_file,\n\t\t\t\t\t\t\t   guid,\n\t\t                       archive_name_escaped,\n\t\t                       abspath_to_archive);\n// bug_end\n #if __WINDOWS__\n// bug_start\n\t\tconst char *cabextractor = \"expand\";\n\t\tconst char *format = \"%s %s %s\";\n// bug_end\n \n// bug_start\n\t\textractor_cmd = r_str_newf (format, cabextractor,\n\t\t\tabspath_to_archive, abspath_to_file);\n#else\n\t\tconst char *cabextractor = \"cabextract\";\n\t\tconst char *format = \"%s -d \\\"%s\\\" \\\"%s\\\"\";\n\t\tchar *abspath_to_dir = r_file_dirname (abspath_to_archive);\n\t\textractor_cmd = r_str_newf (format, cabextractor, abspath_to_dir, abspath_to_archive);\n\t\tR_FREE (abspath_to_dir);\n#endif\n\t\teprintf (\"Attempting to download compressed pdb in %s\\n\", abspath_to_archive);\n\t\tif ((cmd_ret = r_sys_cmd (curl_cmd) != 0)) {\n\t\t\teprintf(\"curl exited with error %d\\n\", cmd_ret);\n\t\t\tres = 0;\n\t\t}\n\t\teprintf (\"Attempting to decompress pdb\\n\");\n\t\tif (opt->extract > 0) {\n// bug_end\n \t\t\tif (res && ((cmd_ret = r_sys_cmd (extractor_cmd)) != 0)) {\n \t\t\t\teprintf (\"cab extractor exited with error %d\\n\", cmd_ret);\n \t\t\t\tres = 0;\n \t\t\t}\n \t\t\tr_file_rm (abspath_to_archive);\n \t\t}\n// bug_start\n\t\tR_FREE (curl_cmd);\n// bug_end\n \t}\n \tif (res == 0) {\n \t\teprintf (\"Falling back to uncompressed pdb\\n\");\n// bug_start\n\t\tres = 1;\n\n\t\tarchive_name_escaped[strlen (archive_name_escaped) - 1] = 'b';\n\n\t\tcurl_cmd = r_str_newf (\"curl -sfLA \\\"%s\\\" \\\"%s/%s/%s/%s\\\" --create-dirs -o \\\"%s\\\"\",\n\t\t                       opt->user_agent,\n\t\t                       opt->symbol_server,\n\t\t                       opt->dbg_file,\n\t\t                       opt->guid,\n\t\t                       archive_name_escaped,\n\t\t                       abspath_to_file);\n// bug_end\n \t\teprintf (\"Attempting to download uncompressed pdb in %s\\n\", abspath_to_file);\n// bug_start\n\t\tif ((cmd_ret = r_sys_cmd (curl_cmd) != 0)) {\n\t\t\teprintf(\"curl exited with error %d\\n\", cmd_ret);\n\t\t\tres = 0;\n\t\t}\n\t\tR_FREE (curl_cmd);\n// bug_end\n \t}\n// bug_start\n\tR_FREE (abspath_to_archive);\n\tR_FREE (abspath_to_file);\n\tR_FREE (archive_name);\n\tR_FREE (extractor_cmd);\n\tR_FREE (symbol_store_path);\n\tR_FREE (dbg_file);\n\tR_FREE (guid);\n\tR_FREE (archive_name_escaped);\n\tR_FREE (user_agent);\n\tR_FREE (symbol_server);\n// bug_end\n \treturn res;\n }\n \n", "target": "// fix_start\n// fix_end\n// fix_start\n\n// fix_end\n// fix_start\n// fix_end\n// fix_start\n\tchar *abspath_to_file = r_str_newf (\"%s%s%s%s%s%s%s\",\n\t\topt->symbol_store_path, R_SYS_DIR,\n\t\topt->dbg_file, R_SYS_DIR,\n\t\topt->guid, R_SYS_DIR,\n\t\topt->dbg_file);\n// fix_end\n// fix_start\n// fix_end\n// fix_start\n\t\tfree (abspath_to_file);\n// fix_end\n// fix_start\n\t\tchar *extractor_cmd = NULL;\n\t\tchar *archive_name = strdup (opt->dbg_file);\n\t\tarchive_name[strlen (archive_name) - 1] = '_';\n\t\tchar *abspath_to_archive = r_str_newf (\"%s%s%s%s%s%s%s\",\n\t\t\topt->symbol_store_path, R_SYS_DIR,\n\t\t\topt->dbg_file, R_SYS_DIR,\n\t\t\topt->guid, R_SYS_DIR,\n\t\t\tarchive_name);\n// fix_end\n// fix_start\n\t\teprintf (\"Attempting to download compressed pdb in %s\\n\", abspath_to_archive);\n\t\tchar *abs_arch_esc = r_str_escape_sh (abspath_to_archive);\n// fix_end\n// fix_start\n\t\tchar *abs_file_esc = r_str_escape_sh (abspath_to_file);\n\t\textractor_cmd = r_str_newf (\"expand \\\"%s\\\" \\\"%s\\\"\", abs_arch_esc, abs_file_esc);\n\t\tfree (abs_file_esc);\n#else\n\t\tchar *abspath_to_dir = r_file_dirname (abspath_to_archive);\n\t\tchar *abs_dir_esc = r_str_escape_sh (abspath_to_dir);\n\t\textractor_cmd = r_str_newf (\"cabextract -d \\\"%s\\\" \\\"%s\\\"\", abs_arch_esc, abs_dir_esc);\n\t\tfree (abs_dir_esc);\n\t\tfree (abspath_to_dir);\n#endif\n\t\tfree (abs_arch_esc);\n\t\tres = download_and_write (opt, archive_name);\n// fix_end\n// fix_start\n\t\tif (opt->extract > 0 && res) {\n\t\t\teprintf (\"Attempting to decompress pdb\\n\");\n// fix_end\n// fix_start\n\t\tfree (archive_name);\n\t\tfree (abspath_to_archive);\n// fix_end\n// fix_start\n// fix_end\n// fix_start\n\t\tres = download_and_write (opt, opt->dbg_file);\n// fix_end\n// fix_start\n\tfree (abspath_to_file);\n// fix_end\n", "cwe": "CWE-78", "cwe_name": "Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')", "cve": "CVE-2020-15121", "cve_desc": "In radare2 before version 4.5.0, malformed PDB file names in the PDB server path cause shell injection. To trigger the problem it's required to open the executable in radare2 and run idpd to trigger the download. The shell code will execute, and will create a file called pwned in the current directory.", "project": "radare2", "idx": 198095}
{"source": " service_info *FindServiceEventURLPath(\n \tservice_table *table, const char *eventURLPath)\n {\n \tservice_info *finger = NULL;\n \turi_type parsed_url;\n \turi_type parsed_url_in;\n \n// bug_start\n\tif (table &&\n\t\tparse_uri(eventURLPath, strlen(eventURLPath), &parsed_url_in) ==\n\t\t\tHTTP_SUCCESS) {\n// bug_end\n \t\tfinger = table->serviceList;\n \t\twhile (finger) {\n \t\t\tif (finger->eventURL) {\n \t\t\t\tif (parse_uri(finger->eventURL,\n \t\t\t\t\t    strlen(finger->eventURL),\n \t\t\t\t\t    &parsed_url) == HTTP_SUCCESS) {\n \t\t\t\t\tif (!token_cmp(&parsed_url.pathquery,\n \t\t\t\t\t\t    &parsed_url_in.pathquery)) {\n \t\t\t\t\t\treturn finger;\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \t\t\tfinger = finger->next;\n \t\t}\n \t}\n \n \treturn NULL;\n }\n \n", "target": "// fix_start\n\tif (!table || !eventURLPath) {\n\t\treturn NULL;\n\t}\n\tif (parse_uri(eventURLPath, strlen(eventURLPath), &parsed_url_in) ==\n\t\tHTTP_SUCCESS) {\n// fix_end\n", "cwe": "CWE-476", "cwe_name": "NULL Pointer Dereference", "cve": "CVE-2020-13848", "cve_desc": "Portable UPnP SDK (aka libupnp) 1.12.1 and earlier allows remote attackers to cause a denial of service (crash) via a crafted SSDP message due to a NULL pointer dereference in the functions FindServiceControlURLPath and FindServiceEventURLPath in genlib/service_table/service_table.c.", "project": "pupnp", "idx": 198108}
{"source": " service_info *FindServiceControlURLPath(\n \tservice_table *table, const char *controlURLPath)\n {\n \tservice_info *finger = NULL;\n \turi_type parsed_url;\n \turi_type parsed_url_in;\n \n// bug_start\n\tif (table && parse_uri(controlURLPath,\n\t\t\t     strlen(controlURLPath),\n\t\t\t     &parsed_url_in) == HTTP_SUCCESS) {\n// bug_end\n \t\tfinger = table->serviceList;\n \t\twhile (finger) {\n \t\t\tif (finger->controlURL) {\n \t\t\t\tif (parse_uri(finger->controlURL,\n \t\t\t\t\t    strlen(finger->controlURL),\n \t\t\t\t\t    &parsed_url) == HTTP_SUCCESS) {\n \t\t\t\t\tif (!token_cmp(&parsed_url.pathquery,\n \t\t\t\t\t\t    &parsed_url_in.pathquery)) {\n \t\t\t\t\t\treturn finger;\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \t\t\tfinger = finger->next;\n \t\t}\n \t}\n \n \treturn NULL;\n }\n \n", "target": "// fix_start\n\tif (!table || !controlURLPath) {\n\t\treturn NULL;\n\t}\n\tif (parse_uri(controlURLPath, strlen(controlURLPath), &parsed_url_in) ==\n\t\tHTTP_SUCCESS) {\n// fix_end\n", "cwe": "CWE-476", "cwe_name": "NULL Pointer Dereference", "cve": "CVE-2020-13848", "cve_desc": "Portable UPnP SDK (aka libupnp) 1.12.1 and earlier allows remote attackers to cause a denial of service (crash) via a crafted SSDP message due to a NULL pointer dereference in the functions FindServiceControlURLPath and FindServiceEventURLPath in genlib/service_table/service_table.c.", "project": "pupnp", "idx": 198109}
{"source": "   void Compute(OpKernelContext* context) override {\n     const Tensor& x = context->input(0);\n     const Tensor& y = context->input(1);\n// bug_start\n    const float min_x = context->input(2).flat<float>()(0);\n    const float max_x = context->input(3).flat<float>()(0);\n    const float min_y = context->input(4).flat<float>()(0);\n    const float max_y = context->input(5).flat<float>()(0);\n// bug_end\n \n     BCast bcast(BCast::FromShape(x.shape()), BCast::FromShape(y.shape()));\n     if (!bcast.IsValid()) {\n       context->SetStatus(errors::InvalidArgument(\n           \"Incompatible shapes: \", x.shape().DebugString(), \" vs. \",\n           y.shape().DebugString()));\n       return;\n     }\n     Tensor* z;\n     OP_REQUIRES_OK(context, context->allocate_output(\n                                 0, BCast::ToShape(bcast.output_shape()), &z));\n \n     OP_REQUIRES(context, (max_x > min_x),\n                 errors::InvalidArgument(\"max_x must be larger than min_a.\"));\n     OP_REQUIRES(context, (max_y > min_y),\n                 errors::InvalidArgument(\"max_x must be larger than min_b.\"));\n     const int32 offset_x = FloatToQuantizedUnclamped<T>(0.0f, min_x, max_x);\n     const int32 offset_y = FloatToQuantizedUnclamped<T>(0.0f, min_y, max_y);\n     const T* x_data = x.flat<T>().data();\n     const T* y_data = y.flat<T>().data();\n     Toutput* z_data = z->flat<Toutput>().data();\n \n     const int ndims = bcast.x_reshape().size();\n     if (ndims <= 1) {\n       if (x.NumElements() == 1) {\n         ScalarMultiply<T, Toutput>(context, y_data, offset_y, y.NumElements(),\n                                    x_data[0], offset_x, z_data);\n       } else if (y.NumElements() == 1) {\n         ScalarMultiply<T, Toutput>(context, x_data, offset_x, x.NumElements(),\n                                    y_data[0], offset_y, z_data);\n       } else {\n         VectorMultiply<T, Toutput>(context, x_data, offset_x, y_data, offset_y,\n                                    x.NumElements(), z_data);\n       }\n     } else if (ndims == 2) {\n       const T* vector_data;\n       int64 vector_num_elements;\n       int32 vector_offset;\n       const T* tensor_data;\n       int64 tensor_num_elements;\n       int32 tensor_offset;\n       if (x.NumElements() < y.NumElements()) {\n         vector_data = x_data;\n         vector_num_elements = x.NumElements();\n         vector_offset = offset_x;\n         tensor_data = y_data;\n         tensor_num_elements = y.NumElements();\n         tensor_offset = offset_y;\n       } else {\n         vector_data = y_data;\n         vector_num_elements = y.NumElements();\n         vector_offset = offset_y;\n         tensor_data = x_data;\n         tensor_num_elements = x.NumElements();\n         tensor_offset = offset_x;\n       }\n       if (vector_num_elements == 0) {\n         context->SetStatus(\n             errors::InvalidArgument(\"vector must have at least 1 element\"));\n         return;\n       }\n       VectorTensorMultiply<T, Toutput>(\n           vector_data, vector_offset, vector_num_elements, tensor_data,\n           tensor_offset, tensor_num_elements, z_data);\n     } else {\n       LOG(INFO) << \"ndims=\" << ndims;\n       LOG(INFO) << \"bcast.x_reshape()=\"\n                 << TensorShape(bcast.x_reshape()).DebugString();\n       LOG(INFO) << \"bcast.y_reshape()=\"\n                 << TensorShape(bcast.y_reshape()).DebugString();\n       LOG(INFO) << \"bcast.x_bcast()=\"\n                 << TensorShape(bcast.x_bcast()).DebugString();\n       LOG(INFO) << \"bcast.y_bcast()=\"\n                 << TensorShape(bcast.y_bcast()).DebugString();\n \n       context->SetStatus(errors::Unimplemented(\n           \"Broadcast between \", context->input(0).shape().DebugString(),\n           \" and \", context->input(1).shape().DebugString(),\n           \" is not supported yet.\"));\n       return;\n     }\n \n     float min_z_value;\n     float max_z_value;\n     QuantizationRangeForMultiplication<T, T, Toutput>(\n         min_x, max_x, min_y, max_y, &min_z_value, &max_z_value);\n     Tensor* z_min = nullptr;\n     OP_REQUIRES_OK(context, context->allocate_output(1, {}, &z_min));\n     z_min->flat<float>()(0) = min_z_value;\n \n     Tensor* z_max = nullptr;\n     OP_REQUIRES_OK(context, context->allocate_output(2, {}, &z_max));\n     z_max->flat<float>()(0) = max_z_value;\n   }\n \n", "target": "// fix_start\n    auto& min_x_tensor = context->input(2);\n    OP_REQUIRES(context, TensorShapeUtils::IsScalar(min_x_tensor.shape()),\n                errors::InvalidArgument(\"min_x must be a scalar\"));\n    const float min_x = min_x_tensor.flat<float>()(0);\n    auto& max_x_tensor = context->input(3);\n    OP_REQUIRES(context, TensorShapeUtils::IsScalar(max_x_tensor.shape()),\n                errors::InvalidArgument(\"max_x must be a scalar\"));\n    const float max_x = max_x_tensor.flat<float>()(0);\n    auto& min_y_tensor = context->input(4);\n    OP_REQUIRES(context, TensorShapeUtils::IsScalar(min_y_tensor.shape()),\n                errors::InvalidArgument(\"min_y must be a scalar\"));\n    const float min_y = min_y_tensor.flat<float>()(0);\n    auto& max_y_tensor = context->input(5);\n    OP_REQUIRES(context, TensorShapeUtils::IsScalar(max_y_tensor.shape()),\n                errors::InvalidArgument(\"max_y must be a scalar\"));\n    const float max_y = max_y_tensor.flat<float>()(0);\n// fix_end\n", "cwe": "CWE-787", "cwe_name": "Out-of-bounds Write", "cve": "CVE-2021-29535", "cve_desc": "TensorFlow is an end-to-end open source platform for machine learning. An attacker can cause a heap buffer overflow in `QuantizedMul` by passing in invalid thresholds for the quantization. This is because the implementation(https://github.com/tensorflow/tensorflow/blob/87cf4d3ea9949051e50ca3f071fc909538a51cd0/tensorflow/core/kernels/quantized_mul_op.cc#L287-L290) assumes that the 4 arguments are always valid scalars and tries to access the numeric value directly. However, if any of these tensors is empty, then `.flat<T>()` is an empty buffer and accessing the element at position 0 results in overflow. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.", "project": "tensorflow", "idx": 198110}
{"source": " inline int MatchingDim(const RuntimeShape& shape1, int index1,\n                        const RuntimeShape& shape2, int index2) {\n   TFLITE_DCHECK_EQ(shape1.Dims(index1), shape2.Dims(index2));\n// bug_start\n  return shape1.Dims(index1);\n// bug_end\n }\n \n", "target": "// fix_start\n  return std::min(shape1.Dims(index1), shape2.Dims(index2));\n// fix_end\n", "cwe": "CWE-125", "cwe_name": "Out-of-bounds Read", "cve": "CVE-2020-15208", "cve_desc": "In tensorflow-lite before versions 1.15.4, 2.0.3, 2.1.2, 2.2.1 and 2.3.1, when determining the common dimension size of two tensors, TFLite uses a `DCHECK` which is no-op outside of debug compilation modes. Since the function always returns the dimension of the first tensor, malicious attackers can craft cases where this is larger than that of the second tensor. In turn, this would result in reads/writes outside of bounds since the interpreter will wrongly assume that there is enough data in both tensors. The issue is patched in commit 8ee24e7949a203d234489f9da2c5bf45a7d5157d, and is released in TensorFlow versions 1.15.4, 2.0.3, 2.1.2, 2.2.1, or 2.3.1.", "project": "tensorflow", "idx": 198111}
{"source": "   void Compute(OpKernelContext* ctx) override {\n     ReshapeOp::Compute(ctx);\n// bug_start\n// bug_end\n \n// bug_start\n    const float input_min_float = ctx->input(2).flat<float>()(0);\n    const float input_max_float = ctx->input(3).flat<float>()(0);\n// bug_end\n     Tensor* output_min = nullptr;\n     OP_REQUIRES_OK(ctx, ctx->allocate_output(1, TensorShape({}), &output_min));\n     output_min->flat<float>()(0) = input_min_float;\n \n     Tensor* output_max = nullptr;\n     OP_REQUIRES_OK(ctx, ctx->allocate_output(2, TensorShape({}), &output_max));\n     output_max->flat<float>()(0) = input_max_float;\n   }\n \n", "target": "// fix_start\n    if (!ctx->status().ok()) {\n      return;\n    }\n// fix_end\n// fix_start\n    const auto& input_min_float_tensor = ctx->input(2);\n    const auto& input_min_float_shape = input_min_float_tensor.shape();\n    OP_REQUIRES(ctx,\n                TensorShapeUtils::IsScalar(input_min_float_shape) ||\n                    (TensorShapeUtils::IsVector(input_min_float_shape) &&\n                     (input_min_float_shape.dim_size(0) == 1)),\n                errors::InvalidArgument(\n                    \"input_min must be a scalar or a vector of 1 element\"));\n    const float input_min_float = input_min_float_tensor.flat<float>()(0);\n    const auto& input_max_float_tensor = ctx->input(3);\n    const auto& input_max_float_shape = input_max_float_tensor.shape();\n    OP_REQUIRES(ctx,\n                TensorShapeUtils::IsScalar(input_max_float_shape) ||\n                    (TensorShapeUtils::IsVector(input_max_float_shape) &&\n                     (input_max_float_shape.dim_size(0) == 1)),\n                errors::InvalidArgument(\n                    \"input_max must be a scalar or a vector of 1 element\"));\n    const float input_max_float = input_max_float_tensor.flat<float>()(0);\n\n// fix_end\n", "cwe": "CWE-787", "cwe_name": "Out-of-bounds Write", "cve": "CVE-2021-29536", "cve_desc": "TensorFlow is an end-to-end open source platform for machine learning. An attacker can cause a heap buffer overflow in `QuantizedReshape` by passing in invalid thresholds for the quantization. This is because the implementation(https://github.com/tensorflow/tensorflow/blob/a324ac84e573fba362a5e53d4e74d5de6729933e/tensorflow/core/kernels/quantized_reshape_op.cc#L38-L55) assumes that the 2 arguments are always valid scalars and tries to access the numeric value directly. However, if any of these tensors is empty, then `.flat<T>()` is an empty buffer and accessing the element at position 0 results in overflow. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.", "project": "tensorflow", "idx": 198140}
{"source": " content::WebContents* WebContents::OpenURLFromTab(\n     content::WebContents* source,\n     const content::OpenURLParams& params) {\n   if (params.disposition != WindowOpenDisposition::CURRENT_TAB) {\n     Emit(\"-new-window\", params.url, \"\", params.disposition, \"\", params.referrer,\n          params.post_data);\n     return nullptr;\n   }\n \n// bug_start\n  if (Emit(\"will-navigate\", params.url))\n    return nullptr;\n\n// bug_end\n   if (IsDestroyed())\n     return nullptr;\n \n   return CommonWebContentsDelegate::OpenURLFromTab(source, params);\n }\n \n", "target": "// fix_start\n// fix_end\n", "cwe": "CWE-284", "cwe_name": "Improper Access Control", "cve": "CVE-2020-15174", "cve_desc": "In Electron before versions 11.0.0-beta.1, 10.0.1, 9.3.0 or 8.5.1 the `will-navigate` event that apps use to prevent navigations to unexpected destinations as per our security recommendations can be bypassed when a sub-frame performs a top-frame navigation across sites. The issue is patched in versions 11.0.0-beta.1, 10.0.1, 9.3.0 or 8.5.1 As a workaround sandbox all your iframes using the sandbox attribute. This will prevent them creating top-frame navigations and is good practice anyway.", "project": "electron", "idx": 198143}
{"source": " otError Commissioner::GeneratePskc(const char *              aPassPhrase,\n                                    const char *              aNetworkName,\n                                    const Mac::ExtendedPanId &aExtPanId,\n                                    Pskc &                    aPskc)\n {\n// bug_start\n    otError     error      = OT_ERROR_NONE;\n    const char *saltPrefix = \"Thread\";\n    uint8_t     salt[OT_PBKDF2_SALT_MAX_LEN];\n    uint16_t    saltLen = 0;\n// bug_end\n \n// bug_start\n    VerifyOrExit((strlen(aPassPhrase) >= OT_COMMISSIONING_PASSPHRASE_MIN_SIZE) &&\n                     (strlen(aPassPhrase) <= OT_COMMISSIONING_PASSPHRASE_MAX_SIZE) &&\n                     (strlen(aNetworkName) <= OT_NETWORK_NAME_MAX_SIZE),\n// bug_end\n                  error = OT_ERROR_INVALID_ARGS);\n \n     memset(salt, 0, sizeof(salt));\n// bug_start\n    memcpy(salt, saltPrefix, strlen(saltPrefix));\n    saltLen += static_cast<uint16_t>(strlen(saltPrefix));\n// bug_end\n \n     memcpy(salt + saltLen, aExtPanId.m8, sizeof(aExtPanId));\n     saltLen += OT_EXT_PAN_ID_SIZE;\n \n// bug_start\n    memcpy(salt + saltLen, aNetworkName, strlen(aNetworkName));\n    saltLen += static_cast<uint16_t>(strlen(aNetworkName));\n// bug_end\n \n// bug_start\n    otPbkdf2Cmac(reinterpret_cast<const uint8_t *>(aPassPhrase), static_cast<uint16_t>(strlen(aPassPhrase)),\n                 reinterpret_cast<const uint8_t *>(salt), saltLen, 16384, OT_PSKC_MAX_SIZE, aPskc.m8);\n// bug_end\n \n exit:\n     return error;\n }\n \n", "target": "// fix_start\n    otError    error        = OT_ERROR_NONE;\n    const char saltPrefix[] = \"Thread\";\n    uint8_t    salt[OT_PBKDF2_SALT_MAX_LEN];\n    uint16_t   saltLen = 0;\n    uint16_t   passphraseLen;\n    uint8_t    networkNameLen;\n// fix_end\n// fix_start\n    passphraseLen  = static_cast<uint16_t>(strnlen(aPassPhrase, OT_COMMISSIONING_PASSPHRASE_MAX_SIZE + 1));\n    networkNameLen = static_cast<uint8_t>(strnlen(aNetworkName, OT_NETWORK_NAME_MAX_SIZE + 1));\n\n    VerifyOrExit((passphraseLen >= OT_COMMISSIONING_PASSPHRASE_MIN_SIZE) &&\n                     (passphraseLen <= OT_COMMISSIONING_PASSPHRASE_MAX_SIZE) &&\n                     (networkNameLen <= OT_NETWORK_NAME_MAX_SIZE),\n// fix_end\n// fix_start\n    memcpy(salt, saltPrefix, sizeof(saltPrefix) - 1);\n    saltLen += static_cast<uint16_t>(sizeof(saltPrefix) - 1);\n// fix_end\n// fix_start\n    memcpy(salt + saltLen, aNetworkName, networkNameLen);\n    saltLen += networkNameLen;\n// fix_end\n// fix_start\n    otPbkdf2Cmac(reinterpret_cast<const uint8_t *>(aPassPhrase), passphraseLen, reinterpret_cast<const uint8_t *>(salt),\n                 saltLen, 16384, OT_PSKC_MAX_SIZE, aPskc.m8);\n// fix_end\n", "cwe": "CWE-787", "cwe_name": "Out-of-bounds Write", "cve": "CVE-2019-20791", "cve_desc": "OpenThread before 2019-12-13 has a stack-based buffer overflow in MeshCoP::Commissioner::GeneratePskc.", "project": "openthread", "idx": 198147}
{"source": " Status KernelAndDeviceOp::Run(\n     ScopedStepContainer* step_container, const EagerKernelArgs& inputs,\n     std::vector<EagerKernelRet>* outputs,\n     CancellationManager* cancellation_manager,\n     const absl::optional<EagerRemoteFunctionParams>& remote_func_params) {\n   OpKernelContext::Params params;\n   params.device = device_;\n   params.frame_iter = FrameAndIter(0, 0);\n   params.inputs = inputs.GetTensorValues();\n   params.op_kernel = kernel_.get();\n   params.resource_manager = device_->resource_manager();\n   params.input_alloc_attrs = &input_alloc_attrs_;\n   params.output_attr_array = output_alloc_attrs_.data();\n   params.function_library = flr_;\n   params.slice_reader_cache = &slice_reader_cache_;\n   params.rendezvous = rendezvous_;\n   OpExecutionState* op_execution_state = nullptr;\n \n   CancellationManager default_cancellation_manager;\n   if (cancellation_manager) {\n     params.cancellation_manager = cancellation_manager;\n   } else if (kernel_->is_deferred()) {\n     op_execution_state = new OpExecutionState;\n     params.cancellation_manager = &op_execution_state->cancellation_manager;\n     params.inc_num_deferred_ops_function = [op_execution_state]() {\n       op_execution_state->Ref();\n     };\n     params.dec_num_deferred_ops_function = [op_execution_state]() {\n       op_execution_state->Unref();\n     };\n   } else {\n     params.cancellation_manager = &default_cancellation_manager;\n   }\n \n   params.log_memory = log_memory_;\n \n   params.runner = get_runner();\n \n   params.step_container =\n       step_container == nullptr ? &step_container_ : step_container;\n   auto step_container_cleanup = gtl::MakeCleanup([step_container, this] {\n     if (step_container == nullptr) {\n       this->step_container_.CleanUp();\n     }\n   });\n \n   params.collective_executor =\n       collective_executor_ ? collective_executor_->get() : nullptr;\n \n   OpKernelContext context(&params);\n \n   {\n     port::ScopedFlushDenormal flush;\n     port::ScopedSetRound round(FE_TONEAREST);\n     profiler::AnnotatedTraceMe activity(\n         [&] { return kernel_->TraceString(context, false); },\n         profiler::TraceMeLevel::kInfo);\n     device_->Compute(kernel_.get(), &context);\n   }\n \n   if (op_execution_state != nullptr) {\n     op_execution_state->Unref();\n   }\n \n   if (!context.status().ok()) return context.status();\n \n   if (outputs != nullptr) {\n     outputs->clear();\n     for (int i = 0; i < context.num_outputs(); ++i) {\n// bug_start\n      outputs->push_back(Tensor(*context.mutable_output(i)));\n// bug_end\n     }\n   }\n   return Status::OK();\n }\n \n", "target": "// fix_start\n      const auto* output_tensor = context.mutable_output(i);\n      if (output_tensor != nullptr) {\n        outputs->push_back(Tensor(*output_tensor));\n      } else {\n        outputs->push_back(Tensor());\n      }\n// fix_end\n", "cwe": "CWE-369", "cwe_name": "Divide By Zero", "cve": "CVE-2020-15190", "cve_desc": "In Tensorflow before versions 1.15.4, 2.0.3, 2.1.2, 2.2.1 and 2.3.1, the `tf.raw_ops.Switch` operation takes as input a tensor and a boolean and outputs two tensors. Depending on the boolean value, one of the tensors is exactly the input tensor whereas the other one should be an empty tensor. However, the eager runtime traverses all tensors in the output. Since only one of the tensors is defined, the other one is `nullptr`, hence we are binding a reference to `nullptr`. This is undefined behavior and reported as an error if compiling with `-fsanitize=null`. In this case, this results in a segmentation fault The issue is patched in commit da8558533d925694483d2c136a9220d6d49d843c, and is released in TensorFlow versions 1.15.4, 2.0.3, 2.1.2, 2.2.1, or 2.3.1.", "project": "tensorflow", "idx": 198174}
{"source": "   void Compute(OpKernelContext* ctx) override {\n     const auto splits = ctx->input(0).flat<int64>();\n     const auto values = ctx->input(1).flat<Tidx>();\n     const Tensor& size_t = ctx->input(2);\n     const auto weights = ctx->input(3).flat<T>();\n     const int64 weights_size = weights.size();\n \n     Tidx size = size_t.scalar<Tidx>()();\n     OP_REQUIRES(\n         ctx, size >= 0,\n         errors::InvalidArgument(\"size (\", size, \") must be non-negative\"));\n \n     int num_rows = splits.size() - 1;\n     int num_values = values.size();\n     int batch_idx = 0;\n// bug_start\n// bug_end\n \n     Tensor* out_t;\n     OP_REQUIRES_OK(\n         ctx, ctx->allocate_output(0, TensorShape({num_rows, size}), &out_t));\n     functor::SetZeroFunctor<Device, T> fill;\n     fill(ctx->eigen_device<Device>(), out_t->flat<T>());\n     const auto out = out_t->matrix<T>();\n \n     for (int idx = 0; idx < num_values; ++idx) {\n       while (idx >= splits(batch_idx)) {\n         batch_idx++;\n       }\n       Tidx bin = values(idx);\n       OP_REQUIRES(ctx, bin >= 0,\n                   errors::InvalidArgument(\"Input must be non-negative\"));\n       if (bin < size) {\n         if (binary_output_) {\n           out(batch_idx - 1, bin) = T(1);\n         } else {\n           T value = (weights_size > 0) ? weights(idx) : T(1);\n           out(batch_idx - 1, bin) += value;\n         }\n       }\n     }\n   }\n \n", "target": "// fix_start\n\n    OP_REQUIRES(ctx, splits(0) == 0,\n                errors::InvalidArgument(\"Splits must start with 0, not with \",\n                                        splits(0)));\n\n    OP_REQUIRES(ctx, splits(num_rows) == num_values,\n                errors::InvalidArgument(\n                    \"Splits must end with the number of values, got \",\n                    splits(num_rows), \" instead of \", num_values));\n// fix_end\n", "cwe": "CWE-703", "cwe_name": "Improper Check or Handling of Exceptional Conditions", "cve": "CVE-2021-29512", "cve_desc": "TensorFlow is an end-to-end open source platform for machine learning. If the `splits` argument of `RaggedBincount` does not specify a valid `SparseTensor`(https://www.tensorflow.org/api_docs/python/tf/sparse/SparseTensor), then an attacker can trigger a heap buffer overflow. This will cause a read from outside the bounds of the `splits` tensor buffer in the implementation of the `RaggedBincount` op(https://github.com/tensorflow/tensorflow/blob/8b677d79167799f71c42fd3fa074476e0295413a/tensorflow/core/kernels/bincount_op.cc#L430-L433). Before the `for` loop, `batch_idx` is set to 0. The user controls the `splits` array, making it contain only one element, 0. Thus, the code in the `while` loop would increment `batch_idx` and then try to read `splits(1)`, which is outside of bounds. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2 and TensorFlow 2.3.3, as these are also affected.", "project": "tensorflow", "idx": 198180}
{"source": "   void Compute(OpKernelContext* context) override {\n     const Tensor* input_indices;\n     const Tensor* input_values;\n     const Tensor* input_shape;\n     SparseTensorsMap* map;\n \n     OP_REQUIRES_OK(context, context->input(\"sparse_indices\", &input_indices));\n     OP_REQUIRES_OK(context, context->input(\"sparse_values\", &input_values));\n     OP_REQUIRES_OK(context, context->input(\"sparse_shape\", &input_shape));\n     OP_REQUIRES_OK(context, GetMap(context, true , &map));\n \n     OP_REQUIRES(context, TensorShapeUtils::IsMatrix(input_indices->shape()),\n                 errors::InvalidArgument(\n                     \"Input indices should be a matrix but received shape \",\n                     input_indices->shape().DebugString()));\n \n     OP_REQUIRES(context, TensorShapeUtils::IsVector(input_values->shape()),\n                 errors::InvalidArgument(\n                     \"Input values should be a vector but received shape \",\n                     input_values->shape().DebugString()));\n \n     OP_REQUIRES(context, TensorShapeUtils::IsVector(input_shape->shape()),\n                 errors::InvalidArgument(\n                     \"Input shape should be a vector but received shape \",\n                     input_shape->shape().DebugString()));\n \n     int rank = input_shape->NumElements();\n \n     OP_REQUIRES(\n         context, rank > 1,\n         errors::InvalidArgument(\n             \"Rank of input SparseTensor should be > 1, but saw rank: \", rank));\n \n// bug_start\n    TensorShape tensor_input_shape(input_shape->vec<int64>());\n// bug_end\n     gtl::InlinedVector<int64, 8> std_order(rank);\n     std::iota(std_order.begin(), std_order.end(), 0);\n     SparseTensor input_st;\n     OP_REQUIRES_OK(context, SparseTensor::Create(*input_indices, *input_values,\n                                                  tensor_input_shape, std_order,\n                                                  &input_st));\n \n// bug_start\n    auto input_shape_t = input_shape->vec<int64>();\n    const int64 N = input_shape_t(0);\n// bug_end\n \n     Tensor sparse_handles(DT_INT64, TensorShape({N}));\n     auto sparse_handles_t = sparse_handles.vec<int64>();\n \n     OP_REQUIRES_OK(context, input_st.IndicesValid());\n \n     TensorShape output_shape;\n     OP_REQUIRES_OK(context, TensorShapeUtils::MakeShape(\n// bug_start\n                                input_shape_t.data() + 1,\n// bug_end\n                                 input_shape->NumElements() - 1, &output_shape));\n \n     std::unordered_set<int64> visited;\n     sparse::GroupIterable minibatch = input_st.group({0});\n     for (const auto& subset : minibatch) {\n       const int64 b = subset.group()[0];\n       visited.insert(b);\n       OP_REQUIRES(\n           context, b > -1 && b < N,\n           errors::InvalidArgument(\n               \"Received unexpected column 0 value in input SparseTensor: \", b,\n               \" < 0 or >= N (= \", N, \")\"));\n \n       const auto indices = subset.indices();\n       const auto values = subset.values<T>();\n       const int64 num_entries = values.size();\n \n       Tensor output_indices = Tensor(DT_INT64, {num_entries, rank - 1});\n       Tensor output_values = Tensor(DataTypeToEnum<T>::value, {num_entries});\n \n       auto output_indices_t = output_indices.matrix<int64>();\n       auto output_values_t = output_values.vec<T>();\n \n       for (int i = 0; i < num_entries; ++i) {\n         for (int d = 1; d < rank; ++d) {\n           output_indices_t(i, d - 1) = indices(i, d);\n         }\n         output_values_t(i) = values(i);\n       }\n \n       SparseTensor st_i;\n       OP_REQUIRES_OK(context,\n                      SparseTensor::Create(output_indices, output_values,\n                                           output_shape, &st_i));\n       int64 handle;\n       OP_REQUIRES_OK(context, map->AddSparseTensor(context, st_i, &handle));\n       sparse_handles_t(b) = handle;\n     }\n \n     if (visited.size() < N) {\n       Tensor empty_indices(DT_INT64, {0, rank - 1});\n       Tensor empty_values(DataTypeToEnum<T>::value, {0});\n       SparseTensor empty_st;\n       OP_REQUIRES_OK(context, SparseTensor::Create(empty_indices, empty_values,\n                                                    output_shape, &empty_st));\n \n       for (int64 b = 0; b < N; ++b) {\n         if (visited.find(b) == visited.end()) {\n           int64 handle;\n           OP_REQUIRES_OK(context,\n                          map->AddSparseTensor(context, empty_st, &handle));\n           sparse_handles_t(b) = handle;\n         }\n       }\n     }\n \n     context->set_output(0, sparse_handles);\n   }\n \n", "target": "// fix_start\n    auto input_shape_vec = input_shape->vec<int64>();\n    int new_num_elements = 1;\n    bool overflow_ocurred = false;\n    for (int i = 0; i < input_shape_vec.size(); i++) {\n      new_num_elements =\n          MultiplyWithoutOverflow(new_num_elements, input_shape_vec(i));\n      if (new_num_elements < 0) {\n        overflow_ocurred = true;\n      }\n    }\n\n    OP_REQUIRES(\n        context, !overflow_ocurred,\n        errors::Internal(\"Encountered overflow from large input shape.\"));\n\n    TensorShape tensor_input_shape(input_shape_vec);\n// fix_end\n// fix_start\n    const int64 N = input_shape_vec(0);\n// fix_end\n// fix_start\n                                input_shape_vec.data() + 1,\n// fix_end\n", "cwe": "CWE-369", "cwe_name": "Divide By Zero", "cve": "CVE-2021-29523", "cve_desc": "TensorFlow is an end-to-end open source platform for machine learning. An attacker can trigger a denial of service via a `CHECK`-fail in `tf.raw_ops.AddManySparseToTensorsMap`. This is because the implementation(https://github.com/tensorflow/tensorflow/blob/6f9896890c4c703ae0a0845394086e2e1e523299/tensorflow/core/kernels/sparse_tensors_map_ops.cc#L257) takes the values specified in `sparse_shape` as dimensions for the output shape. The `TensorShape` constructor(https://github.com/tensorflow/tensorflow/blob/6f9896890c4c703ae0a0845394086e2e1e523299/tensorflow/core/framework/tensor_shape.cc#L183-L188) uses a `CHECK` operation which triggers when `InitDims`(https://github.com/tensorflow/tensorflow/blob/6f9896890c4c703ae0a0845394086e2e1e523299/tensorflow/core/framework/tensor_shape.cc#L212-L296) returns a non-OK status. This is a legacy implementation of the constructor and operations should use `BuildTensorShapeBase` or `AddDimWithStatus` to prevent `CHECK`-failures in the presence of overflows. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.", "project": "tensorflow", "idx": 198191}
{"source": " static int parse_playlist(HLSContext *c, const char *url,\n                           struct playlist *pls, AVIOContext *in)\n {\n     int ret = 0, is_segment = 0, is_variant = 0;\n     int64_t duration = 0;\n     enum KeyType key_type = KEY_NONE;\n     uint8_t iv[16] = \"\";\n     int has_iv = 0;\n     char key[MAX_URL_SIZE] = \"\";\n     char line[MAX_URL_SIZE];\n     const char *ptr;\n     int close_in = 0;\n     int64_t seg_offset = 0;\n     int64_t seg_size = -1;\n     uint8_t *new_url = NULL;\n     struct variant_info variant_info;\n     char tmp_str[MAX_URL_SIZE];\n     struct segment *cur_init_section = NULL;\n \n     if (!in) {\n #if 1\n         AVDictionary *opts = NULL;\n         close_in = 1;\n         av_dict_set(&opts, \"seekable\", \"0\", 0);\n \n         av_dict_set(&opts, \"user-agent\", c->user_agent, 0);\n         av_dict_set(&opts, \"cookies\", c->cookies, 0);\n         av_dict_set(&opts, \"headers\", c->headers, 0);\n \n         ret = avio_open2(&in, url, AVIO_FLAG_READ,\n                          c->interrupt_callback, &opts);\n         av_dict_free(&opts);\n         if (ret < 0)\n             return ret;\n #else\n         ret = open_in(c, &in, url);\n         if (ret < 0)\n             return ret;\n         close_in = 1;\n #endif\n     }\n \n     if (av_opt_get(in, \"location\", AV_OPT_SEARCH_CHILDREN, &new_url) >= 0)\n         url = new_url;\n \n     read_chomp_line(in, line, sizeof(line));\n     if (strcmp(line, \"#EXTM3U\")) {\n         ret = AVERROR_INVALIDDATA;\n         goto fail;\n     }\n \n     if (pls) {\n         free_segment_list(pls);\n         pls->finished = 0;\n         pls->type = PLS_TYPE_UNSPECIFIED;\n     }\n     while (!avio_feof(in)) {\n         read_chomp_line(in, line, sizeof(line));\n         if (av_strstart(line, \"#EXT-X-STREAM-INF:\", &ptr)) {\n             is_variant = 1;\n             memset(&variant_info, 0, sizeof(variant_info));\n             ff_parse_key_value(ptr, (ff_parse_key_val_cb) handle_variant_args,\n                                &variant_info);\n         } else if (av_strstart(line, \"#EXT-X-KEY:\", &ptr)) {\n             struct key_info info = {{0}};\n             ff_parse_key_value(ptr, (ff_parse_key_val_cb) handle_key_args,\n                                &info);\n             key_type = KEY_NONE;\n             has_iv = 0;\n             if (!strcmp(info.method, \"AES-128\"))\n                 key_type = KEY_AES_128;\n             if (!strcmp(info.method, \"SAMPLE-AES\"))\n                 key_type = KEY_SAMPLE_AES;\n             if (!strncmp(info.iv, \"0x\", 2) || !strncmp(info.iv, \"0X\", 2)) {\n                 ff_hex_to_data(iv, info.iv + 2);\n                 has_iv = 1;\n             }\n             av_strlcpy(key, info.uri, sizeof(key));\n         } else if (av_strstart(line, \"#EXT-X-MEDIA:\", &ptr)) {\n             struct rendition_info info = {{0}};\n             ff_parse_key_value(ptr, (ff_parse_key_val_cb) handle_rendition_args,\n                                &info);\n             new_rendition(c, &info, url);\n         } else if (av_strstart(line, \"#EXT-X-TARGETDURATION:\", &ptr)) {\n             ret = ensure_playlist(c, &pls, url);\n             if (ret < 0)\n                 goto fail;\n             pls->target_duration = atoi(ptr) * AV_TIME_BASE;\n         } else if (av_strstart(line, \"#EXT-X-MEDIA-SEQUENCE:\", &ptr)) {\n             ret = ensure_playlist(c, &pls, url);\n             if (ret < 0)\n                 goto fail;\n             pls->start_seq_no = atoi(ptr);\n         } else if (av_strstart(line, \"#EXT-X-PLAYLIST-TYPE:\", &ptr)) {\n             ret = ensure_playlist(c, &pls, url);\n             if (ret < 0)\n                 goto fail;\n             if (!strcmp(ptr, \"EVENT\"))\n                 pls->type = PLS_TYPE_EVENT;\n             else if (!strcmp(ptr, \"VOD\"))\n                 pls->type = PLS_TYPE_VOD;\n         } else if (av_strstart(line, \"#EXT-X-MAP:\", &ptr)) {\n             struct init_section_info info = {{0}};\n             ret = ensure_playlist(c, &pls, url);\n             if (ret < 0)\n                 goto fail;\n             ff_parse_key_value(ptr, (ff_parse_key_val_cb) handle_init_section_args,\n                                &info);\n             cur_init_section = new_init_section(pls, &info, url);\n         } else if (av_strstart(line, \"#EXT-X-ENDLIST\", &ptr)) {\n             if (pls)\n                 pls->finished = 1;\n         } else if (av_strstart(line, \"#EXTINF:\", &ptr)) {\n             is_segment = 1;\n             duration   = atof(ptr) * AV_TIME_BASE;\n         } else if (av_strstart(line, \"#EXT-X-BYTERANGE:\", &ptr)) {\n             seg_size = atoi(ptr);\n             ptr = strchr(ptr, '@');\n             if (ptr)\n                 seg_offset = atoi(ptr+1);\n         } else if (av_strstart(line, \"#\", NULL)) {\n             continue;\n         } else if (line[0]) {\n             if (is_variant) {\n                 if (!new_variant(c, &variant_info, line, url)) {\n                     ret = AVERROR(ENOMEM);\n                     goto fail;\n                 }\n                 is_variant = 0;\n             }\n             if (is_segment) {\n                 struct segment *seg;\n                 if (!pls) {\n                     if (!new_variant(c, 0, url, NULL)) {\n                         ret = AVERROR(ENOMEM);\n                         goto fail;\n                     }\n                     pls = c->playlists[c->n_playlists - 1];\n                 }\n                 seg = av_malloc(sizeof(struct segment));\n                 if (!seg) {\n                     ret = AVERROR(ENOMEM);\n                     goto fail;\n                 }\n// bug_start\n                seg->duration = duration;\n                seg->key_type = key_type;\n// bug_end\n                 if (has_iv) {\n                     memcpy(seg->iv, iv, sizeof(iv));\n                 } else {\n                     int seq = pls->start_seq_no + pls->n_segments;\n                     memset(seg->iv, 0, sizeof(seg->iv));\n                     AV_WB32(seg->iv + 12, seq);\n                 }\n \n                 if (key_type != KEY_NONE) {\n                     ff_make_absolute_url(tmp_str, sizeof(tmp_str), url, key);\n                     seg->key = av_strdup(tmp_str);\n                     if (!seg->key) {\n                         av_free(seg);\n                         ret = AVERROR(ENOMEM);\n                         goto fail;\n                     }\n                 } else {\n                     seg->key = NULL;\n                 }\n \n                 ff_make_absolute_url(tmp_str, sizeof(tmp_str), url, line);\n                 seg->url = av_strdup(tmp_str);\n                 if (!seg->url) {\n                     av_free(seg->key);\n                     av_free(seg);\n                     ret = AVERROR(ENOMEM);\n                     goto fail;\n                 }\n \n// bug_start\n// bug_end\n                 dynarray_add(&pls->segments, &pls->n_segments, seg);\n                 is_segment = 0;\n \n                 seg->size = seg_size;\n                 if (seg_size >= 0) {\n                     seg->url_offset = seg_offset;\n                     seg_offset += seg_size;\n                     seg_size = -1;\n                 } else {\n                     seg->url_offset = 0;\n                     seg_offset = 0;\n                 }\n \n                 seg->init_section = cur_init_section;\n             }\n         }\n     }\n     if (pls)\n         pls->last_load_time = av_gettime_relative();\n \n fail:\n     av_free(new_url);\n     if (close_in)\n         avio_close(in);\n     return ret;\n }\n \n", "target": "// fix_start\n// fix_end\n// fix_start\n                if (duration < 0.001 * AV_TIME_BASE) {\n                    duration = 0.001 * AV_TIME_BASE;\n                }\n                seg->duration = duration;\n                seg->key_type = key_type;\n// fix_end\n", "cwe": "CWE-416", "cwe_name": "Use After Free", "cve": "CVE-2020-13904", "cve_desc": "FFmpeg 2.8 and 4.2.3 has a use-after-free via a crafted EXTINF duration in an m3u8 file because parse_playlist in libavformat/hls.c frees a pointer, and later that pointer is accessed in av_probe_input_format3 in libavformat/format.c.", "project": "FFmpeg", "idx": 198208}
{"source": " GF_Err latm_dmx_process(GF_Filter *filter)\n {\n \tGF_LATMDmxCtx *ctx = gf_filter_get_udta(filter);\n \tGF_FilterPacket *pck, *dst_pck;\n \tu32 pos;\n// bug_start\n\tu8 *data, *output;\n\tu32 pck_size, prev_pck_size;\n// bug_end\n \tu64 cts = GF_FILTER_NO_TS;\n \n \tif (ctx->in_error)\n \t\treturn ctx->in_error;\n \n \tif (!ctx->duration.num)\n \t\tlatm_dmx_check_dur(filter, ctx);\n \n \tif (ctx->opid && !ctx->is_playing)\n \t\treturn GF_OK;\n \n \tpck = gf_filter_pid_get_packet(ctx->ipid);\n \tif (!pck) {\n \t\tif (gf_filter_pid_is_eos(ctx->ipid)) {\n \t\t\tif (!ctx->latm_buffer_size) {\n \t\t\t\tif (ctx->opid)\n \t\t\t\t\tgf_filter_pid_set_eos(ctx->opid);\n \t\t\t\tif (ctx->src_pck) gf_filter_pck_unref(ctx->src_pck);\n \t\t\t\tctx->src_pck = NULL;\n \t\t\t\treturn GF_EOS;\n \t\t\t}\n \t\t} else {\n \t\t\treturn GF_OK;\n \t\t}\n// bug_start\n// bug_end\n \t}\n// bug_start\n\n\tdata = (char *) gf_filter_pck_get_data(pck, &pck_size);\n// bug_end\n \n \tif (ctx->timescale && pck) {\n \t\tcts = gf_filter_pck_get_cts(pck);\n \t}\n \n \tprev_pck_size = ctx->latm_buffer_size;\n \n \tif (pck && !ctx->resume_from) {\n \t\tif (ctx->latm_buffer_size + pck_size > ctx->latm_buffer_alloc) {\n \t\t\tctx->latm_buffer_alloc = ctx->latm_buffer_size + pck_size;\n \t\t\tctx->latm_buffer = gf_realloc(ctx->latm_buffer, ctx->latm_buffer_alloc);\n \t\t}\n \t\tmemcpy(ctx->latm_buffer + ctx->latm_buffer_size, data, pck_size);\n \t\tctx->latm_buffer_size += pck_size;\n \t}\n \n \tif (!ctx->bs) ctx->bs = gf_bs_new(ctx->latm_buffer, ctx->latm_buffer_size, GF_BITSTREAM_READ);\n \telse gf_bs_reassign_buffer(ctx->bs, ctx->latm_buffer, ctx->latm_buffer_size);\n \n \tif (ctx->resume_from) {\n \t\tgf_bs_seek(ctx->bs, ctx->resume_from-1);\n \t\tctx->resume_from = 0;\n \t}\n \n \tif (cts == GF_FILTER_NO_TS)\n \t\tprev_pck_size = 0;\n \n \n \twhile (1) {\n \t\tpos = (u32) gf_bs_get_position(ctx->bs);\n \t\tu8 latm_buffer[4096];\n \t\tu32 latm_frame_size = 4096;\n \t\tif (!latm_dmx_sync_frame_bs(ctx->bs,&ctx->acfg, &latm_frame_size, latm_buffer, NULL)) break;\n \n \t\tif (ctx->in_seek) {\n \t\t\tu64 nb_samples_at_seek = (u64) (ctx->start_range * GF_M4ASampleRates[ctx->sr_idx]);\n \t\t\tif (ctx->cts + ctx->dts_inc >= nb_samples_at_seek) {\n \t\t\t\tctx->in_seek = GF_FALSE;\n \t\t\t}\n \t\t}\n \n \t\tlatm_dmx_check_pid(filter, ctx);\n \n \t\tif (!ctx->is_playing) {\n \t\t\tctx->resume_from = pos+1;\n \t\t\treturn GF_OK;\n \t\t}\n \n \t\tif (!ctx->in_seek) {\n \t\t\tGF_FilterSAPType sap = GF_FILTER_SAP_1;\n \n \t\t\tdst_pck = gf_filter_pck_new_alloc(ctx->opid, latm_frame_size, &output);\n \t\t\tif (ctx->src_pck) gf_filter_pck_merge_properties(ctx->src_pck, dst_pck);\n \n \t\t\tmemcpy(output, latm_buffer, latm_frame_size);\n \n \t\t\tgf_filter_pck_set_cts(dst_pck, ctx->cts);\n \t\t\tgf_filter_pck_set_duration(dst_pck, ctx->dts_inc);\n \t\t\tgf_filter_pck_set_framing(dst_pck, GF_TRUE, GF_TRUE);\n \n \t\t\tif (ctx->acfg.base_object_type==GF_CODECID_USAC) {\n \t\t\t\tif (latm_frame_size && (output[0] & 0x80) && !ctx->prev_sap) {\n \t\t\t\t\tsap = GF_FILTER_SAP_1;\n \t\t\t\t\tctx->prev_sap = GF_TRUE;\n \t\t\t\t} else {\n \t\t\t\t\tsap = GF_FILTER_SAP_NONE;\n \t\t\t\t\tctx->prev_sap = GF_FALSE;\n \t\t\t\t}\n \t\t\t}\n \t\t\tgf_filter_pck_set_sap(dst_pck, sap);\n \n \t\t\tgf_filter_pck_send(dst_pck);\n \t\t}\n \t\tlatm_dmx_update_cts(ctx);\n \n \t\tif (prev_pck_size) {\n \t\t\tpos = (u32) gf_bs_get_position(ctx->bs);\n \t\t\tif (prev_pck_size<=pos) {\n \t\t\t\tprev_pck_size=0;\n \t\t\t\tif (ctx->src_pck) gf_filter_pck_unref(ctx->src_pck);\n \t\t\t\tctx->src_pck = pck;\n \t\t\t\tif (pck)\n \t\t\t\t\tgf_filter_pck_ref_props(&ctx->src_pck);\n \t\t\t}\n \t\t}\n \t}\n \n \tif (pck) {\n \t\tpos = (u32) gf_bs_get_position(ctx->bs);\n \t\tassert(ctx->latm_buffer_size >= pos);\n \t\tmemmove(ctx->latm_buffer, ctx->latm_buffer+pos, ctx->latm_buffer_size - pos);\n \t\tctx->latm_buffer_size -= pos;\n \t\tgf_filter_pid_drop_packet(ctx->ipid);\n \t\tassert(!ctx->resume_from);\n \t} else {\n \t\tctx->latm_buffer_size = 0;\n \t\treturn latm_dmx_process(filter);\n \t}\n \treturn GF_OK;\n }\n \n", "target": "// fix_start\n\tu8 *data=NULL, *output;\n\tu32 pck_size=0, prev_pck_size;\n// fix_end\n// fix_start\n\t} else {\n\t\tdata = (char *) gf_filter_pck_get_data(pck, &pck_size);\n// fix_end\n// fix_start\n// fix_end\n", "cwe": "CWE-476", "cwe_name": "NULL Pointer Dereference", "cve": "CVE-2021-30199", "cve_desc": "In filters/reframe_latm.c in GPAC 1.0.1 there is a Null Pointer Dereference, when gf_filter_pck_get_data is called. The first arg pck may be null with a crafted mp4 file,which results in a crash.", "project": "gpac", "idx": 198278}
{"source": " static GF_Err gf_isom_parse_movie_boxes_internal(GF_ISOFile *mov, u32 *boxType, u64 *bytesMissing, Bool progressive_mode)\n {\n \tGF_Box *a;\n \tu64 totSize, mdat_end=0;\n \tGF_Err e = GF_OK;\n \n #ifndef\tGPAC_DISABLE_ISOM_FRAGMENTS\n \tif (mov->single_moof_mode && mov->single_moof_state == 2) {\n \t\treturn e;\n \t}\n \n \ttotSize = mov->current_top_box_start;\n \tif (mov->bytes_removed) {\n \t\tassert(totSize >= mov->bytes_removed);\n \t\ttotSize -= mov->bytes_removed;\n \t}\n \tgf_bs_seek(mov->movieFileMap->bs, totSize);\n #endif\n \n \n \twhile (gf_bs_available(mov->movieFileMap->bs)) {\n \t\t*bytesMissing = 0;\n #ifndef\tGPAC_DISABLE_ISOM_FRAGMENTS\n \t\tmov->current_top_box_start = gf_bs_get_position(mov->movieFileMap->bs) + mov->bytes_removed;\n \t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[iso file] Parsing a top-level box at position %d\\n\", mov->current_top_box_start));\n #endif\n \n \t\te = gf_isom_parse_root_box(&a, mov->movieFileMap->bs, boxType, bytesMissing, progressive_mode);\n \n \t\tif (e >= 0) {\n \n \t\t} else if (e == GF_ISOM_INCOMPLETE_FILE) {\n \t\t\tif (mov->openMode != GF_ISOM_OPEN_READ) {\n \t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Incomplete MDAT while file is not read-only\\n\"));\n \t\t\t\treturn GF_ISOM_INVALID_FILE;\n \t\t\t}\n \t\t\tif ((mov->openMode == GF_ISOM_OPEN_READ) && !progressive_mode) {\n \t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Incomplete file while reading for dump - aborting parsing\\n\"));\n \t\t\t\tbreak;\n \t\t\t}\n \t\t\treturn e;\n \t\t} else {\n \t\t\treturn e;\n \t\t}\n \n \t\tswitch (a->type) {\n \t\tcase GF_ISOM_BOX_TYPE_MOOV:\n \t\t\tif (mov->moov) {\n \t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Duplicate MOOV detected!\\n\"));\n \t\t\t\tgf_isom_box_del(a);\n \t\t\t\treturn GF_ISOM_INVALID_FILE;\n \t\t\t}\n \t\t\tmov->moov = (GF_MovieBox *)a;\n \t\t\tmov->original_moov_offset = mov->current_top_box_start;\n \t\t\tmov->moov->mov = mov;\n #ifndef GPAC_DISABLE_ISOM_FRAGMENTS\n \t\t\tif (mov->moov->mvex) mov->moov->mvex->mov = mov;\n \n #ifdef GF_ENABLE_CTRN\n \t\t\tif (! (mov->FragmentsFlags & GF_ISOM_FRAG_READ_DEBUG)) {\n \t\t\t\tgf_isom_setup_traf_inheritance(mov);\n \t\t\t}\n #endif\n \n #endif\n \t\t\te = gf_list_add(mov->TopBoxes, a);\n \t\t\tif (e) return e;\n \n \t\t\ttotSize += a->size;\n \n             if (!mov->moov->mvhd) {\n                 GF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Missing MovieHeaderBox\\n\"));\n                 return GF_ISOM_INVALID_FILE;\n             }\n \n             if (mov->meta) {\n \t\t\t\tgf_isom_meta_restore_items_ref(mov, mov->meta);\n \t\t\t}\n \n \t\t\tif (mov->FragmentsFlags & GF_ISOM_FRAG_READ_DEBUG) {\n \t\t\t\tu32 k;\n \t\t\t\tfor (k=0; k<gf_list_count(mov->moov->trackList); k++) {\n \t\t\t\t\tGF_TrackBox *trak = (GF_TrackBox *)gf_list_get(mov->moov->trackList, k);\n \n \t\t\t\t\tif (trak->sample_encryption) {\n \t\t\t\t\t\te = senc_Parse(mov->movieFileMap->bs, trak, NULL, trak->sample_encryption);\n \t\t\t\t\t\tif (e) return e;\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t} else {\n \t\t\t\tu32 k;\n \t\t\t\tfor (k=0; k<gf_list_count(mov->moov->trackList); k++) {\n \t\t\t\t\tGF_TrackBox *trak = (GF_TrackBox *)gf_list_get(mov->moov->trackList, k);\n \t\t\t\t\tif (trak->Media->information->sampleTable->sampleGroups) {\n \t\t\t\t\t\tconvert_compact_sample_groups(trak->Media->information->sampleTable->child_boxes, trak->Media->information->sampleTable->sampleGroups);\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \n             if (mdat_end && mov->signal_frag_bounds && !(mov->FragmentsFlags & GF_ISOM_FRAG_READ_DEBUG) ) {\n                 gf_isom_push_mdat_end(mov, mdat_end);\n                 mdat_end=0;\n             }\n \t\t\tbreak;\n \n \t\tcase GF_ISOM_BOX_TYPE_META:\n \t\t\tif (mov->meta) {\n \t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Duplicate META detected!\\n\"));\n \t\t\t\tgf_isom_box_del(a);\n \t\t\t\treturn GF_ISOM_INVALID_FILE;\n \t\t\t}\n \t\t\tmov->meta = (GF_MetaBox *)a;\n \t\t\tmov->original_meta_offset = mov->current_top_box_start;\n \t\t\te = gf_list_add(mov->TopBoxes, a);\n \t\t\tif (e) {\n \t\t\t\treturn e;\n \t\t\t}\n \t\t\ttotSize += a->size;\n             if (mov->moov) {\n \t\t\t\tgf_isom_meta_restore_items_ref(mov, mov->meta);\n \t\t\t}\n \t\t\tbreak;\n \n \t\tcase GF_ISOM_BOX_TYPE_MDAT:\n \t\t\tif (!mov->first_data_toplevel_offset) {\n \t\t\t\tmov->first_data_toplevel_offset = mov->current_top_box_start;\n \t\t\t\tmov->first_data_toplevel_size = a->size;\n \t\t\t}\n \t\t\ttotSize += a->size;\n \t\t\tif (mov->openMode == GF_ISOM_OPEN_READ) {\n \t\t\t\tif (!mov->mdat) {\n \t\t\t\t\tmov->mdat = (GF_MediaDataBox *) a;\n \t\t\t\t\te = gf_list_add(mov->TopBoxes, mov->mdat);\n \t\t\t\t\tif (e) {\n \t\t\t\t\t\treturn e;\n \t\t\t\t\t}\n \t\t\t\t}\n #ifndef\tGPAC_DISABLE_ISOM_FRAGMENTS\n \t\t\t\telse if (mov->FragmentsFlags & GF_ISOM_FRAG_READ_DEBUG) gf_list_add(mov->TopBoxes, a);\n #endif\n \t\t\t\telse gf_isom_box_del(a);\n \n \n \t\t\t\tif (mov->signal_frag_bounds && !(mov->FragmentsFlags & GF_ISOM_FRAG_READ_DEBUG) ) {\n                     mdat_end = gf_bs_get_position(mov->movieFileMap->bs);\n                     if (mov->moov) {\n                         gf_isom_push_mdat_end(mov, mdat_end);\n                         mdat_end=0;\n                     }\n \t\t\t\t}\n \t\t\t}\n \t\t\telse if (!mov->mdat && (mov->openMode != GF_ISOM_OPEN_READ) && (mov->openMode != GF_ISOM_OPEN_KEEP_FRAGMENTS)) {\n \t\t\t\tgf_isom_box_del(a);\n \t\t\t\tmov->mdat = (GF_MediaDataBox *) gf_isom_box_new(GF_ISOM_BOX_TYPE_MDAT);\n \t\t\t\tif (!mov->mdat) return GF_OUT_OF_MEM;\n \t\t\t\te = gf_list_add(mov->TopBoxes, mov->mdat);\n \t\t\t\tif (e) {\n \t\t\t\t\treturn e;\n \t\t\t\t}\n \t\t\t} else {\n \t\t\t\tgf_isom_box_del(a);\n \t\t\t}\n \t\t\tbreak;\n \t\tcase GF_ISOM_BOX_TYPE_FTYP:\n \t\t\tif (mov->brand) {\n \t\t\t\tgf_isom_box_del(a);\n \t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Duplicate 'ftyp' detected!\\n\"));\n \t\t\t\treturn GF_ISOM_INVALID_FILE;\n \t\t\t}\n \t\t\tmov->brand = (GF_FileTypeBox *)a;\n \t\t\ttotSize += a->size;\n \t\t\te = gf_list_add(mov->TopBoxes, a);\n \t\t\tif (e) return e;\n \t\t\tbreak;\n \n \t\tcase GF_ISOM_BOX_TYPE_OTYP:\n \t\t\tif (mov->otyp) {\n \t\t\t\tgf_isom_box_del(a);\n \t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Duplicate 'otyp' detected!\\n\"));\n \t\t\t\treturn GF_ISOM_INVALID_FILE;\n \t\t\t}\n \n \t\t\tif (mov->FragmentsFlags & GF_ISOM_FRAG_READ_DEBUG) {\n \t\t\t\tmov->otyp = (GF_Box *)a;\n \t\t\t\ttotSize += a->size;\n \t\t\t\te = gf_list_add(mov->TopBoxes, a);\n \t\t\t\tif (e) return e;\n \t\t\t} else {\n \t\t\t\tGF_FileTypeBox *brand = (GF_FileTypeBox *) gf_isom_box_find_child(a->child_boxes, GF_ISOM_BOX_TYPE_FTYP);\n \t\t\t\tif (brand) {\n \t\t\t\t\ts32 pos;\n \t\t\t\t\tgf_list_del_item(a->child_boxes, brand);\n \t\t\t\t\tpos = gf_list_del_item(mov->TopBoxes, mov->brand);\n \t\t\t\t\tgf_isom_box_del((GF_Box *) mov->brand);\n \t\t\t\t\tmov->brand = brand;\n \t\t\t\t\tif (pos<0) pos=0;\n \t\t\t\t\tgf_list_insert(mov->TopBoxes, brand, pos);\n \t\t\t\t}\n// bug_start\n// bug_end\n \t\t\t}\n \t\t\tbreak;\n \n \t\tcase GF_ISOM_BOX_TYPE_PDIN:\n \t\t\tif (mov->pdin) {\n \t\t\t\tgf_isom_box_del(a);\n \t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Duplicate 'pdin'' detected!\\n\"));\n \t\t\t\treturn GF_ISOM_INVALID_FILE;\n \t\t\t}\n \t\t\tmov->pdin = (GF_ProgressiveDownloadBox *) a;\n \t\t\ttotSize += a->size;\n \t\t\te = gf_list_add(mov->TopBoxes, a);\n \t\t\tif (e) return e;\n \t\t\tbreak;\n \n \n #ifndef\tGPAC_DISABLE_ISOM_FRAGMENTS\n \t\tcase GF_ISOM_BOX_TYPE_STYP:\n \t\t{\n \t\t\tu32 brand = ((GF_FileTypeBox *)a)->majorBrand;\n \t\t\tswitch (brand) {\n \t\t\tcase GF_ISOM_BRAND_SISX:\n \t\t\tcase GF_ISOM_BRAND_RISX:\n \t\t\tcase GF_ISOM_BRAND_SSSS:\n \t\t\t\tmov->is_index_segment = GF_TRUE;\n \t\t\t\tbreak;\n \t\t\tdefault:\n \t\t\t\tbreak;\n \t\t\t}\n \t\t}\n \n \t\tcase GF_ISOM_BOX_TYPE_SIDX:\n \t\tcase GF_ISOM_BOX_TYPE_SSIX:\n \t\t\tif (mov->moov && !mov->first_data_toplevel_offset) {\n \t\t\t\tmov->first_data_toplevel_offset = mov->current_top_box_start;\n \t\t\t\tmov->first_data_toplevel_size = a->size;\n \t\t\t}\n \t\t\ttotSize += a->size;\n \t\t\tif (mov->FragmentsFlags & GF_ISOM_FRAG_READ_DEBUG) {\n \t\t\t\te = gf_list_add(mov->TopBoxes, a);\n \t\t\t\tif (e) return e;\n \t\t\t} else if (mov->signal_frag_bounds && !(mov->FragmentsFlags & GF_ISOM_FRAG_READ_DEBUG)  && (mov->openMode!=GF_ISOM_OPEN_KEEP_FRAGMENTS)\n \t\t\t) {\n \t\t\t\tif (a->type==GF_ISOM_BOX_TYPE_SIDX) {\n \t\t\t\t\tif (mov->root_sidx) gf_isom_box_del( (GF_Box *) mov->root_sidx);\n \t\t\t\t\tmov->root_sidx = (GF_SegmentIndexBox *) a;\n \t\t\t\t\tmov->sidx_start_offset = mov->current_top_box_start;\n \t\t\t\t\tmov->sidx_end_offset = gf_bs_get_position(mov->movieFileMap->bs);\n \n \t\t\t\t}\n \t\t\t\telse if (a->type==GF_ISOM_BOX_TYPE_STYP) {\n \t\t\t\t\tmov->styp_start_offset = mov->current_top_box_start;\n \n \t\t\t\t\tif (mov->seg_styp) gf_isom_box_del(mov->seg_styp);\n \t\t\t\t\tmov->seg_styp = a;\n \t\t\t\t} else if (a->type==GF_ISOM_BOX_TYPE_SSIX) {\n \t\t\t\t\tif (mov->seg_ssix) gf_isom_box_del(mov->seg_ssix);\n \t\t\t\t\tmov->seg_ssix = a;\n \t\t\t\t} else {\n \t\t\t\t\tgf_isom_box_del(a);\n \t\t\t\t}\n \t\t\t\tgf_isom_push_mdat_end(mov, mov->current_top_box_start);\n \t\t\t} else if (!mov->NextMoofNumber && (a->type==GF_ISOM_BOX_TYPE_SIDX)) {\n \t\t\t\tif (mov->main_sidx) gf_isom_box_del( (GF_Box *) mov->main_sidx);\n \t\t\t\tmov->main_sidx = (GF_SegmentIndexBox *) a;\n \t\t\t\tmov->main_sidx_end_pos = mov->current_top_box_start + a->size;\n \t\t\t} else {\n \t\t\t\tgf_isom_box_del(a);\n \t\t\t}\n \t\t\tbreak;\n \n \t\tcase GF_ISOM_BOX_TYPE_MOOF:\n \t\t\tgf_isom_disable_inplace_rewrite(mov);\n \t\t\tif (!mov->moov) {\n \t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[iso file] Movie fragment but no moov (yet) - possibly broken parsing!\\n\"));\n \t\t\t}\n \t\t\tif (mov->single_moof_mode) {\n \t\t\t\tmov->single_moof_state++;\n \t\t\t\tif (mov->single_moof_state > 1) {\n \t\t\t\t\tgf_isom_box_del(a);\n \t\t\t\t\treturn GF_OK;\n \t\t\t\t}\n \t\t\t}\n \t\t\t((GF_MovieFragmentBox *)a)->mov = mov;\n \n \t\t\ttotSize += a->size;\n \t\t\tmov->moof = (GF_MovieFragmentBox *) a;\n \n \t\t\tFixTrackID(mov);\n \t\t\tif (! (mov->FragmentsFlags & GF_ISOM_FRAG_READ_DEBUG)) {\n \t\t\t\tFixSDTPInTRAF(mov->moof);\n \t\t\t} else {\n \t\t\t\tu32 k;\n \t\t\t\tfor (k=0; k<gf_list_count(mov->moof->TrackList); k++) {\n \t\t\t\t\tGF_TrackFragmentBox *traf = (GF_TrackFragmentBox *)gf_list_get(mov->moof->TrackList, k);\n \t\t\t\t\tif (traf->sampleGroups) {\n \t\t\t\t\t\tconvert_compact_sample_groups(traf->child_boxes, traf->sampleGroups);\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tif (mov->FragmentsFlags & GF_ISOM_FRAG_READ_DEBUG) {\n \t\t\t\tu32 k;\n \t\t\t\tgf_list_add(mov->TopBoxes, a);\n \t\t\t\tif (mov->moov) {\n \t\t\t\t\tfor (k=0; k<gf_list_count(mov->moof->TrackList); k++) {\n \t\t\t\t\t\tGF_TrackFragmentBox *traf = gf_list_get(mov->moof->TrackList, k);\n \t\t\t\t\t\tif (traf->tfhd && mov->moov->mvex && mov->moov->mvex->TrackExList) {\n \t\t\t\t\t\t\tGF_TrackBox *trak = gf_isom_get_track_from_id(mov->moov, traf->tfhd->trackID);\n \t\t\t\t\t\t\tu32 j=0;\n \t\t\t\t\t\t\twhile ((traf->trex = (GF_TrackExtendsBox*)gf_list_enum(mov->moov->mvex->TrackExList, &j))) {\n \t\t\t\t\t\t\t\tif (traf->trex->trackID == traf->tfhd->trackID) {\n \t\t\t\t\t\t\t\t\tif (!traf->trex->track) traf->trex->track = trak;\n \t\t\t\t\t\t\t\t\tbreak;\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\ttraf->trex = NULL;\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}\n \t\t\t\t\t\tif (traf->trex && traf->tfhd && traf->trex->track && traf->sample_encryption) {\n \t\t\t\t\t\t\tGF_TrackBox *trak = GetTrackbyID(mov->moov, traf->tfhd->trackID);\n \t\t\t\t\t\t\ttrak->current_traf_stsd_idx = traf->tfhd->sample_desc_index ? traf->tfhd->sample_desc_index : traf->trex->def_sample_desc_index;\n \t\t\t\t\t\t\te = senc_Parse(mov->movieFileMap->bs, trak, traf, traf->sample_encryption);\n \t\t\t\t\t\t\tif (e) return e;\n \t\t\t\t\t\t\ttrak->current_traf_stsd_idx = 0;\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t} else {\n \t\t\t\t\tfor (k=0; k<gf_list_count(mov->moof->TrackList); k++) {\n \t\t\t\t\t\tGF_TrackFragmentBox *traf = gf_list_get(mov->moof->TrackList, k);\n \t\t\t\t\t\tif (traf->sample_encryption) {\n \t\t\t\t\t\t\te = senc_Parse(mov->movieFileMap->bs, NULL, traf, traf->sample_encryption);\n \t\t\t\t\t\t\tif (e) return e;\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \n \t\t\t\t}\n \t\t\t} else if (mov->openMode==GF_ISOM_OPEN_KEEP_FRAGMENTS) {\n \t\t\t\tmov->NextMoofNumber = mov->moof->mfhd->sequence_number+1;\n \t\t\t\tmov->moof = NULL;\n \t\t\t\tgf_isom_box_del(a);\n \t\t\t} else {\n \t\t\t\te = MergeFragment((GF_MovieFragmentBox *)a, mov);\n \t\t\t\tgf_isom_box_del(a);\n \t\t\t\tif (e) return e;\n \t\t\t}\n \n \t\t\tif (mov->root_sidx) {\n \t\t\t\tgf_isom_box_del((GF_Box *) mov->root_sidx);\n \t\t\t\tmov->root_sidx = NULL;\n \t\t\t}\n \t\t\tif (mov->root_ssix) {\n \t\t\t\tgf_isom_box_del(mov->seg_ssix);\n \t\t\t\tmov->root_ssix = NULL;\n \t\t\t}\n \t\t\tif (mov->seg_styp) {\n \t\t\t\tgf_isom_box_del(mov->seg_styp);\n \t\t\t\tmov->seg_styp = NULL;\n \t\t\t}\n \t\t\tmov->sidx_start_offset = 0;\n \t\t\tmov->sidx_end_offset = 0;\n \t\t\tmov->styp_start_offset = 0;\n \t\t\tbreak;\n #endif\n \t\tcase GF_ISOM_BOX_TYPE_UNKNOWN:\n \t\t{\n \t\t\tGF_UnknownBox *box = (GF_UnknownBox*)a;\n \t\t\tif (box->original_4cc == GF_ISOM_BOX_TYPE_JP) {\n \t\t\t\tu8 *c = (u8 *) box->data;\n \t\t\t\tif ((box->dataSize==4) && (GF_4CC(c[0],c[1],c[2],c[3])==(u32)0x0D0A870A))\n \t\t\t\t\tmov->is_jp2 = 1;\n \t\t\t\tgf_isom_box_del(a);\n \t\t\t} else {\n \t\t\t\te = gf_list_add(mov->TopBoxes, a);\n \t\t\t\tif (e) return e;\n \t\t\t}\n \t\t}\n \t\tbreak;\n \n \t\tcase GF_ISOM_BOX_TYPE_PRFT:\n #ifndef GPAC_DISABLE_ISOM_FRAGMENTS\n \t\t\tif (!(mov->FragmentsFlags & GF_ISOM_FRAG_READ_DEBUG)) {\n \t\t\t\tif (mov->last_producer_ref_time)\n \t\t\t\t\tgf_isom_box_del(a);\n \t\t\t\telse\n \t\t\t\t\tmov->last_producer_ref_time = (GF_ProducerReferenceTimeBox *)a;\n \t\t\t\tbreak;\n \t\t\t}\n #endif\n \n \t\tdefault:\n \t\t\ttotSize += a->size;\n \t\t\te = gf_list_add(mov->TopBoxes, a);\n \t\t\tif (e) return e;\n \t\t\tbreak;\n \t\t}\n \n #ifndef\tGPAC_DISABLE_ISOM_FRAGMENTS\n \t\tmov->current_top_box_start = gf_bs_get_position(mov->movieFileMap->bs) + mov->bytes_removed;\n #endif\n \t}\n \n \tif (!mov->moov && !mov->meta\n #ifndef GPAC_DISABLE_ISOM_FRAGMENTS\n \t        && !mov->moof && !mov->is_index_segment\n #endif\n \t   ) {\n \t\treturn GF_ISOM_INCOMPLETE_FILE;\n \t}\n \tif (!gf_opts_get_bool(\"core\", \"no-check\")) {\n \t\tif (mov->moov && !mov->moov->mvhd) {\n \t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Missing MVHD in MOOV!\\n\"));\n \t\t\treturn GF_ISOM_INVALID_FILE;\n \t\t}\n \n \t\tif (mov->meta && !mov->meta->handler) {\n \t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Missing handler in META!\\n\"));\n \t\t\treturn GF_ISOM_INVALID_FILE;\n \t\t}\n \t}\n \n #ifndef GPAC_DISABLE_ISOM_WRITE\n \n \tif (mov->moov) {\n \t\tmov->interleavingTime = mov->moov->mvhd->timeScale;\n \n #ifndef\tGPAC_DISABLE_ISOM_FRAGMENTS\n \t\tif ((mov->openMode > GF_ISOM_OPEN_READ) && (mov->openMode != GF_ISOM_OPEN_KEEP_FRAGMENTS) && mov->moov->mvex) {\n \t\t\tgf_isom_box_del_parent(&mov->moov->child_boxes, (GF_Box *)mov->moov->mvex);\n \t\t\tmov->moov->mvex = NULL;\n \t\t}\n #endif\n \n \t}\n \n \tif (!mov->mdat && (mov->openMode != GF_ISOM_OPEN_READ) && (mov->openMode != GF_ISOM_OPEN_KEEP_FRAGMENTS)) {\n \t\tmov->mdat = (GF_MediaDataBox *) gf_isom_box_new(GF_ISOM_BOX_TYPE_MDAT);\n \t\tif (!mov->mdat) return GF_OUT_OF_MEM;\n \t\te = gf_list_add(mov->TopBoxes, mov->mdat);\n \t\tif (e) return e;\n \t}\n #endif\n \n \treturn GF_OK;\n }\n \n", "target": "// fix_start\n\t\t\t\tgf_isom_box_del(a);\n// fix_end\n", "cwe": "CWE-401", "cwe_name": "Missing Release of Memory after Effective Lifetime", "cve": "CVE-2021-33364", "cve_desc": "Memory leak in the def_parent_box_new function in MP4Box in GPAC 1.0.1 allows attackers to read memory via a crafted file.", "project": "gpac", "idx": 198286}
{"source": " multi_process_incoming_link(struct multi_context *m, struct multi_instance *instance, const unsigned int mpp_flags)\n {\n     struct gc_arena gc = gc_new();\n \n     struct context *c;\n     struct mroute_addr src, dest;\n     unsigned int mroute_flags;\n     struct multi_instance *mi;\n     bool ret = true;\n     bool floated = false;\n \n     if (m->pending)\n     {\n         return true;\n     }\n \n     if (!instance)\n     {\n #ifdef MULTI_DEBUG_EVENT_LOOP\n         printf(\"TCP/UDP -> TUN [%d]\\n\", BLEN(&m->top.c2.buf));\n #endif\n         multi_set_pending(m, multi_get_create_instance_udp(m, &floated));\n     }\n     else\n     {\n         multi_set_pending(m, instance);\n     }\n \n     if (m->pending)\n     {\n         set_prefix(m->pending);\n \n         c = &m->pending->context;\n \n         if (!instance)\n         {\n             c->c2.buf = m->top.c2.buf;\n \n             if (!floated)\n             {\n                 c->c2.from = m->top.c2.from;\n             }\n         }\n \n         if (BLEN(&c->c2.buf) > 0)\n         {\n             struct link_socket_info *lsi;\n             const uint8_t *orig_buf;\n \n \n             perf_push(PERF_PROC_IN_LINK);\n             lsi = get_link_socket_info(c);\n             orig_buf = c->c2.buf.data;\n             if (process_incoming_link_part1(c, lsi, floated))\n             {\n// bug_start\n                if (floated)\n// bug_end\n                 {\n                     multi_process_float(m, m->pending);\n                 }\n \n                 process_incoming_link_part2(c, lsi, orig_buf);\n             }\n             perf_pop();\n \n             if (TUNNEL_TYPE(m->top.c1.tuntap) == DEV_TYPE_TUN)\n             {\n                 mroute_flags = mroute_extract_addr_from_packet(&src,\n                                                                &dest,\n                                                                NULL,\n                                                                NULL,\n                                                                0,\n                                                                &c->c2.to_tun,\n                                                                DEV_TYPE_TUN);\n \n                 if (!(mroute_flags & MROUTE_EXTRACT_SUCCEEDED))\n                 {\n                     c->c2.to_tun.len = 0;\n                 }\n                 else if (multi_get_instance_by_virtual_addr(m, &src, true) != m->pending)\n                 {\n                     if ( (src.type & MR_ADDR_MASK) == MR_ADDR_IPV6\n                          && IN6_IS_ADDR_LINKLOCAL(&src.v6.addr) )\n                     {\n                     }\n                     else\n                     {\n                         msg(D_MULTI_DROPPED, \"MULTI: bad source address from client [%s], packet dropped\",\n                             mroute_addr_print(&src, &gc));\n                     }\n                     c->c2.to_tun.len = 0;\n                 }\n                 else if (m->enable_c2c)\n                 {\n                     if (mroute_flags & MROUTE_EXTRACT_MCAST)\n                     {\n                         multi_bcast(m, &c->c2.to_tun, m->pending, NULL, 0);\n                     }\n                     else\n                     {\n                         ASSERT(!(mroute_flags & MROUTE_EXTRACT_BCAST));\n                         mi = multi_get_instance_by_virtual_addr(m, &dest, true);\n \n                         if (mi)\n                         {\n #ifdef ENABLE_PF\n                             if (!pf_c2c_test(&c->c2.pf, c->c2.tls_multi,\n                                              &mi->context.c2.pf,\n                                              mi->context.c2.tls_multi,\n                                              \"tun_c2c\"))\n                             {\n                                 msg(D_PF_DROPPED, \"PF: client -> client[%s] packet dropped by TUN packet filter\",\n                                     mi_prefix(mi));\n                             }\n                             else\n #endif\n                             {\n                                 multi_unicast(m, &c->c2.to_tun, mi);\n                                 register_activity(c, BLEN(&c->c2.to_tun));\n                             }\n                             c->c2.to_tun.len = 0;\n                         }\n                     }\n                 }\n #ifdef ENABLE_PF\n                 if (c->c2.to_tun.len && !pf_addr_test(&c->c2.pf, c, &dest,\n                                                       \"tun_dest_addr\"))\n                 {\n                     msg(D_PF_DROPPED, \"PF: client -> addr[%s] packet dropped by TUN packet filter\",\n                         mroute_addr_print_ex(&dest, MAPF_SHOW_ARP, &gc));\n                     c->c2.to_tun.len = 0;\n                 }\n #endif\n             }\n             else if (TUNNEL_TYPE(m->top.c1.tuntap) == DEV_TYPE_TAP)\n             {\n                 uint16_t vid = 0;\n #ifdef ENABLE_PF\n                 struct mroute_addr edest;\n                 mroute_addr_reset(&edest);\n #endif\n \n                 if (m->top.options.vlan_tagging)\n                 {\n                     if (vlan_is_tagged(&c->c2.to_tun))\n                     {\n                         msg(D_VLAN_DEBUG, \"dropping incoming VLAN-tagged frame\");\n                         c->c2.to_tun.len = 0;\n                     }\n                     else\n                     {\n                         vid = c->options.vlan_pvid;\n                     }\n                 }\n                 mroute_flags = mroute_extract_addr_from_packet(&src,\n                                                                &dest,\n                                                                NULL,\n #ifdef ENABLE_PF\n                                                                &edest,\n #else\n                                                                NULL,\n #endif\n                                                                vid,\n                                                                &c->c2.to_tun,\n                                                                DEV_TYPE_TAP);\n \n                 if (mroute_flags & MROUTE_EXTRACT_SUCCEEDED)\n                 {\n                     if (multi_learn_addr(m, m->pending, &src, 0) == m->pending)\n                     {\n                         if (m->enable_c2c)\n                         {\n                             if (mroute_flags & (MROUTE_EXTRACT_BCAST|MROUTE_EXTRACT_MCAST))\n                             {\n                                 multi_bcast(m, &c->c2.to_tun, m->pending, NULL,\n                                             vid);\n                             }\n                             else\n                             {\n                                 mi = multi_get_instance_by_virtual_addr(m, &dest, false);\n \n                                 if (mi)\n                                 {\n #ifdef ENABLE_PF\n                                     if (!pf_c2c_test(&c->c2.pf, c->c2.tls_multi,\n                                                      &mi->context.c2.pf,\n                                                      mi->context.c2.tls_multi,\n                                                      \"tap_c2c\"))\n                                     {\n                                         msg(D_PF_DROPPED, \"PF: client -> client[%s] packet dropped by TAP packet filter\",\n                                             mi_prefix(mi));\n                                     }\n                                     else\n #endif\n                                     {\n                                         multi_unicast(m, &c->c2.to_tun, mi);\n                                         register_activity(c, BLEN(&c->c2.to_tun));\n                                     }\n                                     c->c2.to_tun.len = 0;\n                                 }\n                             }\n                         }\n #ifdef ENABLE_PF\n                         if (c->c2.to_tun.len && !pf_addr_test(&c->c2.pf, c,\n                                                               &edest,\n                                                               \"tap_dest_addr\"))\n                         {\n                             msg(D_PF_DROPPED, \"PF: client -> addr[%s] packet dropped by TAP packet filter\",\n                                 mroute_addr_print_ex(&edest, MAPF_SHOW_ARP, &gc));\n                             c->c2.to_tun.len = 0;\n                         }\n #endif\n                     }\n                     else\n                     {\n                         msg(D_MULTI_DROPPED, \"MULTI: bad source address from client [%s], packet dropped\",\n                             mroute_addr_print(&src, &gc));\n                         c->c2.to_tun.len = 0;\n                     }\n                 }\n                 else\n                 {\n                     c->c2.to_tun.len = 0;\n                 }\n             }\n         }\n \n         ret = multi_process_post(m, m->pending, mpp_flags);\n \n         clear_prefix();\n     }\n \n     gc_free(&gc);\n     return ret;\n }\n \n", "target": "// fix_start\n                if (floated && c->c2.buf.len > 0)\n// fix_end\n", "cwe": "CWE-476", "cwe_name": "NULL Pointer Dereference", "cve": "CVE-2020-11810", "cve_desc": "An issue was discovered in OpenVPN 2.4.x before 2.4.9. An attacker can inject a data channel v2 (P_DATA_V2) packet using a victim's peer-id. Normally such packets are dropped, but if this packet arrives before the data channel crypto parameters have been initialized, the victim's connection will be dropped. This requires careful timing due to the small time window (usually within a few seconds) between the victim client connection starting and the server PUSH_REPLY response back to the client. This attack will only work if Negotiable Cipher Parameters (NCP) is in use.", "project": "openvpn", "idx": 198315}
{"source": " GF_Err MergeTrack(GF_TrackBox *trak, GF_TrackFragmentBox *traf, GF_MovieFragmentBox *moof_box, u64 moof_offset, s32 compressed_diff, u64 *cumulated_offset, Bool is_first_merge)\n {\n \tu32 i, j, chunk_size, track_num;\n \tu64 base_offset, data_offset, traf_duration;\n \tu32 def_duration, DescIndex, def_size, def_flags;\n \tu32 duration, size, flags, prev_trun_data_offset, sample_index;\n \tu8 pad, sync;\n \tu16 degr;\n \tBool first_samp_in_traf=GF_TRUE;\n \tBool store_traf_map=GF_FALSE;\n \tu8 *moof_template=NULL;\n \tu32 moof_template_size=0;\n \tBool is_seg_start = GF_FALSE;\n \tu64 seg_start=0, sidx_start=0, sidx_end=0, frag_start=0, last_dts=0;\n \tGF_TrackFragmentRunBox *trun;\n \tGF_TrunEntry *ent;\n #ifdef GF_ENABLE_CTRN\n \tGF_TrackFragmentBox *traf_ref = NULL;\n #endif\n \n \tGF_Err stbl_AppendTime(GF_SampleTableBox *stbl, u32 duration, u32 nb_pack);\n \tGF_Err stbl_AppendSize(GF_SampleTableBox *stbl, u32 size, u32 nb_pack);\n \tGF_Err stbl_AppendChunk(GF_SampleTableBox *stbl, u64 offset);\n \tGF_Err stbl_AppendSampleToChunk(GF_SampleTableBox *stbl, u32 DescIndex, u32 samplesInChunk);\n \tGF_Err stbl_AppendCTSOffset(GF_SampleTableBox *stbl, s32 CTSOffset);\n \tGF_Err stbl_AppendRAP(GF_SampleTableBox *stbl, u8 isRap);\n \tGF_Err stbl_AppendPadding(GF_SampleTableBox *stbl, u8 padding);\n \tGF_Err stbl_AppendDegradation(GF_SampleTableBox *stbl, u16 DegradationPriority);\n \n \tif (trak->Header->trackID != traf->tfhd->trackID) return GF_OK;\n \tif (!trak->Media->information->sampleTable\n \t\t|| !trak->Media->information->sampleTable->SampleSize\n \t\t|| !trak->Media->information->sampleTable->TimeToSample\n \t\t|| !trak->Media->information->sampleTable->SampleToChunk\n \t\t|| !trak->Media->information->sampleTable->ChunkOffset\n \t) {\n \t\treturn GF_ISOM_INVALID_FILE;\n \t}\n \n \tif (!traf->trex->track)\n \t\ttraf->trex->track = trak;\n \n \tDescIndex = (traf->tfhd->flags & GF_ISOM_TRAF_SAMPLE_DESC) ? traf->tfhd->sample_desc_index : traf->trex->def_sample_desc_index;\n \tif (!DescIndex) {\n \t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] default sample description set to 0, likely broken ! Fixing to 1\\n\" ));\n \t\tDescIndex = 1;\n \t} else if (DescIndex > gf_list_count(trak->Media->information->sampleTable->SampleDescription->child_boxes)) {\n \t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] default sample description set to %d but only %d sample description(s), likely broken ! Fixing to 1\\n\", DescIndex, gf_list_count(trak->Media->information->sampleTable->SampleDescription->child_boxes)));\n \t\tDescIndex = 1;\n \t}\n #ifdef GF_ENABLE_CTRN\n \tif (traf->trex->inherit_from_traf_id) {\n \t\tu32 traf_count = gf_list_count(moof_box->TrackList);\n \t\tfor (i=0; i<traf_count; i++) {\n \t\t\tGF_TrackFragmentBox *atraf = gf_list_get(moof_box->TrackList, i);\n \t\t\tif (atraf->tfhd && atraf->tfhd->trackID==traf->trex->inherit_from_traf_id) {\n \t\t\t\ttraf_ref = atraf;\n \t\t\t\tbreak;\n \t\t\t}\n \t\t}\n \t}\n #endif\n \n \tdef_duration = (traf->tfhd->flags & GF_ISOM_TRAF_SAMPLE_DUR) ? traf->tfhd->def_sample_duration : traf->trex->def_sample_duration;\n \tdef_size = (traf->tfhd->flags & GF_ISOM_TRAF_SAMPLE_SIZE) ? traf->tfhd->def_sample_size : traf->trex->def_sample_size;\n \tdef_flags = (traf->tfhd->flags & GF_ISOM_TRAF_SAMPLE_FLAGS) ? traf->tfhd->def_sample_flags : traf->trex->def_sample_flags;\n \n \tbase_offset = moof_offset;\n \tif (traf->tfhd->flags & GF_ISOM_TRAF_BASE_OFFSET)\n \t\tbase_offset = traf->tfhd->base_data_offset;\n \telse if (!(traf->tfhd->flags & GF_ISOM_MOOF_BASE_OFFSET))\n \t\tbase_offset = *cumulated_offset;\n \n \tchunk_size = 0;\n \tprev_trun_data_offset = 0;\n \tdata_offset = 0;\n \ttraf_duration = 0;\n \n \tif (traf->tfdt && is_first_merge) {\n #ifndef GPAC_DISABLE_LOG\n \t\tif (trak->moov->mov->NextMoofNumber && trak->present_in_scalable_segment && trak->sample_count_at_seg_start && (trak->dts_at_seg_start != traf->tfdt->baseMediaDecodeTime)) {\n \t\t\ts32 drift = (s32) ((s64) traf->tfdt->baseMediaDecodeTime - (s64)trak->dts_at_seg_start);\n \t\t\tif (drift<0)  {\n \t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[iso file] Warning: TFDT timing \"LLD\" less than cumulated timing \"LLD\" - using tfdt\\n\", traf->tfdt->baseMediaDecodeTime, trak->dts_at_seg_start ));\n \t\t\t} else {\n \t\t\t\tGF_LOG(GF_LOG_INFO, GF_LOG_CONTAINER, (\"[iso file] TFDT timing \"LLD\" higher than cumulated timing \"LLD\" (last sample got extended in duration)\\n\", traf->tfdt->baseMediaDecodeTime, trak->dts_at_seg_start ));\n \t\t\t}\n \t\t}\n #endif\n \t\ttrak->dts_at_seg_start = traf->tfdt->baseMediaDecodeTime;\n \t}\n \telse if (traf->tfxd) {\n \t\ttrak->dts_at_seg_start = traf->tfxd->absolute_time_in_track_timescale;\n \t}\n \n \tif (traf->tfxd) {\n \t\ttrak->last_tfxd_value = traf->tfxd->absolute_time_in_track_timescale;\n \t\ttrak->last_tfxd_value += traf->tfxd->fragment_duration_in_track_timescale;\n \t}\n \tif (traf->tfrf) {\n \t\tif (trak->tfrf) gf_isom_box_del_parent(&trak->child_boxes, (GF_Box *)trak->tfrf);\n \t\ttrak->tfrf = traf->tfrf;\n \t\tgf_list_del_item(traf->child_boxes, traf->tfrf);\n \t\tgf_list_add(trak->child_boxes, trak->tfrf);\n \t}\n \n \tif (trak->moov->mov->signal_frag_bounds) {\n \t\tstore_traf_map = GF_TRUE;\n \t\tif (is_first_merge) {\n \t\t\tGF_MovieFragmentBox *moof_clone = NULL;\n \t\t\tgf_isom_box_freeze_order((GF_Box *)moof_box);\n \t\t\tgf_isom_clone_box((GF_Box *)moof_box, (GF_Box **)&moof_clone);\n \n \t\t\tif (moof_clone) {\n \t\t\t\tGF_BitStream *bs;\n \t\t\t\tfor (i=0; i<gf_list_count(moof_clone->TrackList); i++) {\n \t\t\t\t\tGF_TrackFragmentBox *traf_clone = gf_list_get(moof_clone->TrackList, i);\n \t\t\t\t\tgf_isom_box_array_reset_parent(&traf_clone->child_boxes, traf_clone->TrackRuns);\n \t\t\t\t\tgf_isom_box_array_reset_parent(&traf_clone->child_boxes, traf_clone->sampleGroups);\n \t\t\t\t\tgf_isom_box_array_reset_parent(&traf_clone->child_boxes, traf_clone->sampleGroupsDescription);\n \t\t\t\t\tgf_isom_box_array_reset_parent(&traf_clone->child_boxes, traf_clone->sub_samples);\n \t\t\t\t\tgf_isom_box_array_reset_parent(&traf_clone->child_boxes, traf_clone->sai_offsets);\n \t\t\t\t\tgf_isom_box_array_reset_parent(&traf_clone->child_boxes, traf_clone->sai_sizes);\n \t\t\t\t\tif (traf_clone->sample_encryption) {\n \t\t\t\t\t\tgf_isom_box_del_parent(&traf_clone->child_boxes, (GF_Box *) traf_clone->sample_encryption);\n \t\t\t\t\t\ttraf_clone->sample_encryption = NULL;\n \t\t\t\t\t}\n \t\t\t\t\tif (traf_clone->sdtp) {\n \t\t\t\t\t\tgf_isom_box_del_parent(&traf_clone->child_boxes, (GF_Box *) traf_clone->sdtp);\n \t\t\t\t\t\ttraf_clone->sdtp = NULL;\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\tgf_isom_box_size((GF_Box *)moof_clone);\n \t\t\t\tbs = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);\n \n \t\t\t\tif (trak->moov->mov->seg_styp) {\n \t\t\t\t\tgf_isom_box_size(trak->moov->mov->seg_styp);\n \t\t\t\t\tgf_isom_box_write(trak->moov->mov->seg_styp, bs);\n \t\t\t\t}\n \t\t\t\tif (trak->moov->mov->root_sidx) {\n \t\t\t\t\tgf_isom_box_size((GF_Box *)trak->moov->mov->root_sidx);\n \t\t\t\t\tgf_isom_box_write((GF_Box *)trak->moov->mov->root_sidx, bs);\n \t\t\t\t}\n \t\t\t\tif (trak->moov->mov->seg_ssix) {\n \t\t\t\t\tgf_isom_box_size(trak->moov->mov->seg_ssix);\n \t\t\t\t\tgf_isom_box_write(trak->moov->mov->seg_ssix, bs);\n \t\t\t\t}\n \t\t\t\tgf_isom_box_write((GF_Box *)moof_clone, bs);\n \t\t\t\tgf_isom_box_del((GF_Box*)moof_clone);\n \n \t\t\t\tgf_bs_get_content(bs, &moof_template, &moof_template_size);\n \t\t\t\tgf_bs_del(bs);\n \t\t\t}\n \t\t}\n \t\tif (trak->moov->mov->seg_styp) {\n \t\t\tis_seg_start = GF_TRUE;\n \t\t\tseg_start = trak->moov->mov->styp_start_offset;\n \t\t}\n \t\tif (trak->moov->mov->root_sidx) {\n \t\t\tis_seg_start = GF_TRUE;\n \t\t\tsidx_start = trak->moov->mov->sidx_start_offset;\n \t\t\tsidx_end = trak->moov->mov->sidx_end_offset;\n \t\t\tif (! seg_start || (sidx_start<seg_start))\n \t\t\t\tseg_start = sidx_start;\n \t\t}\n \t\tfrag_start = trak->moov->mov->current_top_box_start;\n \t}\n \telse if (trak->moov->mov->store_traf_map) {\n \t\tstore_traf_map = GF_TRUE;\n \t}\n \n \n \tsample_index = 0;\n \ti=0;\n \twhile ((trun = (GF_TrackFragmentRunBox *)gf_list_enum(traf->TrackRuns, &i))) {\n \t\tfor (j=0; j<trun->sample_count; j++) {\n \t\t\tGF_Err e;\n \t\t\ts32 cts_offset=0;\n \t\t\tif (j<trun->nb_samples) {\n \t\t\t\tent = &trun->samples[j];\n \t\t\t} else {\n \t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Track %d doesn't have enough trun entries (%d) compared to sample count (%d) in run\\n\", traf->trex->trackID, trun->nb_samples, trun->sample_count ));\n \t\t\t\tbreak;\n \t\t\t}\n \t\t\tsize = def_size;\n \t\t\tduration = def_duration;\n \t\t\tflags = def_flags;\n \n \t\t\tcts_offset = ent->CTS_Offset;\n \n #ifdef GF_ENABLE_CTRN\n \t\t\tif (trun->use_ctrn) {\n \t\t\t\tif (!j && (trun->ctrn_flags & GF_ISOM_CTRN_FIRST_SAMPLE) ) {\n \t\t\t\t\tif (trun->ctrn_first_dur) duration = ent->Duration;\n \t\t\t\t\tif (trun->ctrn_first_size) size = ent->size;\n \t\t\t\t\tif (trun->ctrn_first_ctts) flags = ent->flags;\n \t\t\t\t} else {\n \t\t\t\t\tif (trun->ctrn_dur) duration = ent->Duration;\n \t\t\t\t\tif (trun->ctrn_size) size = ent->size;\n \t\t\t\t\tif (trun->ctrn_sample_flags) flags = ent->flags;\n \t\t\t\t}\n \t\t\t\tif (trun->ctrn_flags & 0xF0) {\n \t\t\t\t\tGF_TrunEntry *ref_entry;\n \t\t\t\t\tif (!traf_ref) {\n \t\t\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Track %d use traf inheritance to track ID %d but reference traf not found\\n\", traf->trex->trackID, traf->trex->inherit_from_traf_id ));\n \t\t\t\t\t\tbreak;\n \t\t\t\t\t}\n \t\t\t\t\tref_entry = traf_get_sample_entry(traf_ref, sample_index);\n \t\t\t\t\tif (!ref_entry) {\n \t\t\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Track %d use traf inheritance but sample %d not found in reference traf\\n\", traf->trex->trackID, sample_index+1 ));\n \t\t\t\t\t\tbreak;\n \t\t\t\t\t}\n \t\t\t\t\tif (trun->ctrn_flags & GF_ISOM_CTRN_INHERIT_DUR)\n \t\t\t\t\t\tduration = ref_entry->Duration;\n \t\t\t\t\tif (trun->ctrn_flags & GF_ISOM_CTRN_INHERIT_SIZE)\n \t\t\t\t\t\tsize = ref_entry->size;\n \t\t\t\t\tif (trun->ctrn_flags & GF_ISOM_CTRN_INHERIT_FLAGS)\n \t\t\t\t\t\tflags = ref_entry->flags;\n \t\t\t\t\tif (trun->ctrn_flags & GF_ISOM_CTRN_INHERIT_CTSO)\n \t\t\t\t\t\tcts_offset = ref_entry->CTS_Offset;\n \t\t\t\t}\n \n \t\t\t} else\n #endif\n \t\t\t{\n \t\t\t\tif (trun->flags & GF_ISOM_TRUN_DURATION) duration = ent->Duration;\n \t\t\t\tif (trun->flags & GF_ISOM_TRUN_SIZE) size = ent->size;\n \t\t\t\tif (trun->flags & GF_ISOM_TRUN_FLAGS) {\n \t\t\t\t\tflags = ent->flags;\n \t\t\t\t} else if (!j && (trun->flags & GF_ISOM_TRUN_FIRST_FLAG)) {\n \t\t\t\t\tflags = trun->first_sample_flags;\n \t\t\t\t}\n \t\t\t}\n \t\t\tsample_index++;\n \t\t\tent->size = size;\n \t\t\tent->Duration = duration;\n \t\t\tent->flags = flags;\n \t\t\tent->CTS_Offset = cts_offset;\n \n \t\t\tlast_dts += duration;\n \n \t\t\tif (!trak->Media->information->sampleTable->SampleSize) {\n \t\t\t\ttrak->Media->information->sampleTable->SampleSize = (GF_SampleSizeBox *) gf_isom_box_new_parent(&trak->Media->information->sampleTable->child_boxes, GF_ISOM_BOX_TYPE_STSZ);\n \t\t\t\tif (!trak->Media->information->sampleTable->SampleSize)\n \t\t\t\t\treturn GF_OUT_OF_MEM;\n \t\t\t}\n \t\t\te = stbl_AppendSize(trak->Media->information->sampleTable, size, ent->nb_pack);\n \t\t\tif (e) return e;\n \n \t\t\tif (!trak->Media->information->sampleTable->TimeToSample) {\n \t\t\t\ttrak->Media->information->sampleTable->TimeToSample = (GF_TimeToSampleBox *) gf_isom_box_new_parent(&trak->Media->information->sampleTable->child_boxes, GF_ISOM_BOX_TYPE_STTS);\n \t\t\t\tif (!trak->Media->information->sampleTable->TimeToSample)\n \t\t\t\t\treturn GF_OUT_OF_MEM;\n \t\t\t}\n \t\t\te = stbl_AppendTime(trak->Media->information->sampleTable, duration, ent->nb_pack);\n \t\t\tif (e) return e;\n \n \t\t\tif (!j) {\n \t\t\t\tu64 final_offset;\n \t\t\t\tdata_offset = base_offset;\n \t\t\t\tif (trun->flags & GF_ISOM_TRUN_DATA_OFFSET) {\n \t\t\t\t\tdata_offset += trun->data_offset;\n \t\t\t\t\tchunk_size = 0;\n \t\t\t\t\tprev_trun_data_offset = trun->data_offset;\n \t\t\t\t\tif (trun->data_offset>=0) {\n \t\t\t\t\t\tdata_offset -= compressed_diff;\n \t\t\t\t\t\tprev_trun_data_offset -= compressed_diff;\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\telse if (prev_trun_data_offset) {\n \t\t\t\t\tdata_offset += prev_trun_data_offset + chunk_size;\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\tdata_offset += chunk_size;\n \t\t\t\t\tif ((i==1) && (trun->data_offset>=0)) {\n \t\t\t\t\t\tdata_offset -= compressed_diff;\n \t\t\t\t\t}\n \t\t\t\t}\n \n \t\t\t\tfinal_offset = data_offset;\n \t\t\t\tif (trak->moov->compressed_diff) {\n \t\t\t\t\tfinal_offset += trak->moov->compressed_diff;\n \t\t\t\t}\n \n \t\t\t\tif (!trak->Media->information->sampleTable->ChunkOffset) {\n \t\t\t\t\ttrak->Media->information->sampleTable->ChunkOffset = gf_isom_box_new_parent(&trak->Media->information->sampleTable->child_boxes, GF_ISOM_BOX_TYPE_STCO);\n \t\t\t\t\tif (!trak->Media->information->sampleTable->ChunkOffset)\n \t\t\t\t\t\treturn GF_OUT_OF_MEM;\n \t\t\t\t}\n \t\t\t\te = stbl_AppendChunk(trak->Media->information->sampleTable, final_offset);\n \t\t\t\tif (e) return e;\n \t\t\t\tif (!trak->Media->information->sampleTable->SampleToChunk) {\n \t\t\t\t\ttrak->Media->information->sampleTable->SampleToChunk = (GF_SampleToChunkBox *) gf_isom_box_new_parent(&trak->Media->information->sampleTable->child_boxes, GF_ISOM_BOX_TYPE_STSC);\n \t\t\t\t\tif (!trak->Media->information->sampleTable->SampleToChunk)\n \t\t\t\t\t\treturn GF_OUT_OF_MEM;\n \t\t\t\t}\n \t\t\t\te = stbl_AppendSampleToChunk(trak->Media->information->sampleTable,\n \t\t\t\t                         DescIndex, trun->sample_count);\n \t\t\t\tif (e) return e;\n \t\t\t}\n \t\t\tchunk_size += size;\n \n \t\t\tif (store_traf_map && first_samp_in_traf) {\n \t\t\t\tfirst_samp_in_traf = GF_FALSE;\n \t\t\t\te = stbl_AppendTrafMap(trak->Media->information->sampleTable, is_seg_start, seg_start, frag_start, moof_template, moof_template_size, sidx_start, sidx_end);\n \t\t\t\tif (e) return e;\n \t\t\t\tmoof_template = NULL;\n \t\t\t\tmoof_template_size = 0;\n \t\t\t}\n \t\t\tif (ent->nb_pack>1) {\n \t\t\t\tj+= ent->nb_pack-1;\n \t\t\t\ttraf_duration += ent->nb_pack*duration;\n \t\t\t\tcontinue;\n \t\t\t}\n \n \t\t\ttraf_duration += duration;\n \n \t\t\te = stbl_AppendCTSOffset(trak->Media->information->sampleTable, cts_offset);\n \t\t\tif (e) return e;\n \t\t\tsync = GF_ISOM_GET_FRAG_SYNC(flags);\n \t\t\tif (trak->Media->information->sampleTable->no_sync_found && sync) {\n \t\t\t\ttrak->Media->information->sampleTable->no_sync_found = 0;\n \t\t\t}\n \t\t\te = stbl_AppendRAP(trak->Media->information->sampleTable, sync);\n \t\t\tif (e) return e;\n \t\t\tpad = GF_ISOM_GET_FRAG_PAD(flags);\n \t\t\tif (pad) {\n \t\t\t\te = stbl_AppendPadding(trak->Media->information->sampleTable, pad);\n \t\t\t\tif (e) return e;\n \t\t\t}\n \t\t\tdegr = GF_ISOM_GET_FRAG_DEG(flags);\n \t\t\tif (degr) {\n \t\t\t\te = stbl_AppendDegradation(trak->Media->information->sampleTable, degr);\n \t\t\t\tif (e) return e;\n \t\t\t}\n \t\t\te = stbl_AppendDependencyType(trak->Media->information->sampleTable, GF_ISOM_GET_FRAG_LEAD(flags), GF_ISOM_GET_FRAG_DEPENDS(flags), GF_ISOM_GET_FRAG_DEPENDED(flags), GF_ISOM_GET_FRAG_REDUNDANT(flags));\n \t\t\tif (e) return e;\n \t\t}\n \t}\n \n \tif (trak->moov->mov->is_smooth && !traf->tfdt && !traf->tfxd) {\n \t\tif (is_first_merge)\n \t\t\ttrak->dts_at_seg_start = trak->dts_at_next_seg_start;\n \t\ttrak->dts_at_next_seg_start += last_dts;\n \t}\n \tif (traf_duration && trak->editBox && trak->editBox->editList) {\n \t\tfor (i=0; i<gf_list_count(trak->editBox->editList->entryList); i++) {\n \t\t\tGF_EdtsEntry *edts_e = gf_list_get(trak->editBox->editList->entryList, i);\n \t\t\tif (edts_e->was_empty_dur) {\n \t\t\t\tu64 extend_dur = traf_duration;\n \t\t\t\textend_dur *= trak->moov->mvhd->timeScale;\n \t\t\t\textend_dur /= trak->Media->mediaHeader->timeScale;\n \t\t\t\tedts_e->segmentDuration += extend_dur;\n \t\t\t}\n \t\t\telse if (!edts_e->segmentDuration) {\n \t\t\t\tedts_e->was_empty_dur = GF_TRUE;\n \t\t\t\tif ((s64) traf_duration > edts_e->mediaTime)\n \t\t\t\t\ttraf_duration -= edts_e->mediaTime;\n \t\t\t\telse\n \t\t\t\t\ttraf_duration = 0;\n \n \t\t\t\tedts_e->segmentDuration = traf_duration;\n \t\t\t\tedts_e->segmentDuration *= trak->moov->mvhd->timeScale;\n \t\t\t\tedts_e->segmentDuration /= trak->Media->mediaHeader->timeScale;\n \t\t\t}\n \n \t\t}\n \t}\n \n \t*cumulated_offset = data_offset + chunk_size;\n \n \tif (traf->sampleGroups) {\n \t\tGF_List *groups;\n \t\tGF_List *groupDescs;\n \t\tBool is_identical_sgpd = GF_TRUE;\n \t\tu32 *new_idx = NULL, new_idx_count=0;\n \n \t\tif (!trak->Media->information->sampleTable->sampleGroups)\n \t\t\ttrak->Media->information->sampleTable->sampleGroups = gf_list_new();\n \n \t\tif (!trak->Media->information->sampleTable->sampleGroupsDescription)\n \t\t\ttrak->Media->information->sampleTable->sampleGroupsDescription = gf_list_new();\n \n \t\tgroupDescs = trak->Media->information->sampleTable->sampleGroupsDescription;\n \t\tfor (i=0; i<gf_list_count(traf->sampleGroupsDescription); i++) {\n \t\t\tGF_SampleGroupDescriptionBox *new_sgdesc = NULL;\n \t\t\tGF_SampleGroupDescriptionBox *sgdesc = gf_list_get(traf->sampleGroupsDescription, i);\n \t\t\tfor (j=0; j<gf_list_count(groupDescs); j++) {\n \t\t\t\tnew_sgdesc = gf_list_get(groupDescs, j);\n \t\t\t\tif (new_sgdesc->grouping_type==sgdesc->grouping_type) break;\n \t\t\t\tnew_sgdesc = NULL;\n \t\t\t}\n \t\t\tif (!new_sgdesc) {\n \t\t\t\tgf_list_add(groupDescs, sgdesc);\n \t\t\t\tgf_list_add(trak->Media->information->sampleTable->child_boxes, sgdesc);\n \t\t\t\tgf_list_rem(traf->sampleGroupsDescription, i);\n \t\t\t\tgf_list_del_item(traf->child_boxes, sgdesc);\n \t\t\t\ti--;\n \t\t\t}\n \t\t\telse {\n \t\t\t\tu32 count;\n \n \t\t\t\tis_identical_sgpd = gf_isom_is_identical_sgpd(new_sgdesc, sgdesc, 0);\n \t\t\t\tif (is_identical_sgpd)\n \t\t\t\t\tcontinue;\n \n \t\t\t\tnew_idx_count = gf_list_count(sgdesc->group_descriptions);\n \t\t\t\tnew_idx = (u32 *)gf_malloc(new_idx_count * sizeof(u32));\n \t\t\t\tif (!new_idx) return GF_OUT_OF_MEM;\n \n \t\t\t\tcount = 0;\n \t\t\t\twhile (gf_list_count(sgdesc->group_descriptions)) {\n \t\t\t\t\tvoid *sgpd_entry = gf_list_get(sgdesc->group_descriptions, 0);\n \t\t\t\t\tBool new_entry = GF_TRUE;\n \n \t\t\t\t\tfor (j = 0; j < gf_list_count(new_sgdesc->group_descriptions); j++) {\n \t\t\t\t\t\tvoid *ptr = gf_list_get(new_sgdesc->group_descriptions, j);\n \t\t\t\t\t\tif (gf_isom_is_identical_sgpd(sgpd_entry, ptr, new_sgdesc->grouping_type)) {\n \t\t\t\t\t\t\tnew_idx[count] = j + 1;\n \t\t\t\t\t\t\tcount ++;\n \t\t\t\t\t\t\tnew_entry = GF_FALSE;\n \t\t\t\t\t\t\tgf_free(sgpd_entry);\n \t\t\t\t\t\t\tbreak;\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \n \t\t\t\t\tif (new_entry) {\n \t\t\t\t\t\tgf_list_add(new_sgdesc->group_descriptions, sgpd_entry);\n \t\t\t\t\t\tnew_idx[count] = gf_list_count(new_sgdesc->group_descriptions);\n \t\t\t\t\t\tcount ++;\n \t\t\t\t\t}\n \n \t\t\t\t\tgf_list_rem(sgdesc->group_descriptions, 0);\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \n \t\tgroups = trak->Media->information->sampleTable->sampleGroups;\n \t\tfor (i=0; i<gf_list_count(traf->sampleGroups); i++) {\n \t\t\tGF_SampleGroupBox *stbl_group = NULL;\n \t\t\tGF_SampleGroupBox *frag_group = gf_list_get(traf->sampleGroups, i);\n \n \n \t\t\tfor (j=0; j<gf_list_count(groups); j++) {\n \t\t\t\tstbl_group = gf_list_get(groups, j);\n \t\t\t\tif ((frag_group->grouping_type==stbl_group->grouping_type) && (frag_group->grouping_type_parameter==stbl_group->grouping_type_parameter))\n \t\t\t\t\tbreak;\n \t\t\t\tstbl_group = NULL;\n \t\t\t}\n \t\t\tif (!stbl_group) {\n \t\t\t\tstbl_group = (GF_SampleGroupBox *) gf_isom_box_new_parent(&trak->Media->information->sampleTable->child_boxes, GF_ISOM_BOX_TYPE_SBGP);\n \t\t\t\tif (!stbl_group) return GF_OUT_OF_MEM;\n \t\t\t\tstbl_group->grouping_type = frag_group->grouping_type;\n \t\t\t\tstbl_group->grouping_type_parameter = frag_group->grouping_type_parameter;\n \t\t\t\tstbl_group->version = frag_group->version;\n \t\t\t\tgf_list_add(groups, stbl_group);\n \t\t\t}\n \n \t\t\tif (is_identical_sgpd) {\n \t\t\t\tfor (j = 0; j < frag_group->entry_count; j++)\n \t\t\t\t\tfrag_group->sample_entries[j].group_description_index &= 0x0FFFF;\n \t\t\t\tif (frag_group->entry_count && stbl_group->entry_count &&\n \t\t\t\t        (frag_group->sample_entries[0].group_description_index==stbl_group->sample_entries[stbl_group->entry_count-1].group_description_index)\n \t\t\t\t   ) {\n \t\t\t\t\tstbl_group->sample_entries[stbl_group->entry_count - 1].sample_count += frag_group->sample_entries[0].sample_count;\n \t\t\t\t\tif (frag_group->entry_count>1) {\n \t\t\t\t\t\tstbl_group->sample_entries = gf_realloc(stbl_group->sample_entries, sizeof(GF_SampleGroupEntry) * (stbl_group->entry_count + frag_group->entry_count - 1));\n \t\t\t\t\t\tmemcpy(&stbl_group->sample_entries[stbl_group->entry_count], &frag_group->sample_entries[1], sizeof(GF_SampleGroupEntry) * (frag_group->entry_count - 1));\n \t\t\t\t\t\tstbl_group->entry_count += frag_group->entry_count - 1;\n \t\t\t\t\t}\n \t\t\t\t} else {\n \t\t\t\t\tstbl_group->sample_entries = gf_realloc(stbl_group->sample_entries, sizeof(GF_SampleGroupEntry) * (stbl_group->entry_count + frag_group->entry_count));\n \t\t\t\t\tmemcpy(&stbl_group->sample_entries[stbl_group->entry_count], &frag_group->sample_entries[0], sizeof(GF_SampleGroupEntry) * frag_group->entry_count);\n \t\t\t\t\tstbl_group->entry_count += frag_group->entry_count;\n \t\t\t\t}\n \t\t\t} else {\n \t\t\t\tstbl_group->sample_entries = gf_realloc(stbl_group->sample_entries, sizeof(GF_SampleGroupEntry) * (stbl_group->entry_count + frag_group->entry_count));\n \t\t\t\tfor (j = 0; j < frag_group->entry_count; j++) {\n \t\t\t\t\tu32 sgidx = frag_group->sample_entries[j].group_description_index;\n \t\t\t\t\tif (sgidx > 0x10000) {\n \t\t\t\t\t\tsgidx -= 0x10001;\n \t\t\t\t\t\tif (sgidx>=new_idx_count) {\n \t\t\t\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[isobmf] corrupted sample group index in fragment %d but only %d group descriptions in fragment\\n\", sgidx, new_idx_count));\n \t\t\t\t\t\t} else {\n \t\t\t\t\t\t\tfrag_group->sample_entries[j].group_description_index = new_idx[sgidx];\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\tmemcpy(&stbl_group->sample_entries[stbl_group->entry_count], &frag_group->sample_entries[0], sizeof(GF_SampleGroupEntry) * frag_group->entry_count);\n \t\t\t\tstbl_group->entry_count += frag_group->entry_count;\n \t\t\t}\n \t\t}\n \n \t\tif (new_idx) gf_free(new_idx);\n \t}\n \n \ttrack_num = gf_isom_get_tracknum_from_id(trak->moov, trak->Header->trackID);\n \tif (gf_isom_is_cenc_media(trak->moov->mov, track_num, DescIndex)\n \t\t|| traf->sample_encryption) {\n \t\tGF_SampleEncryptionBox *senc = NULL;\n \t\tu32 scheme_type;\n \t\tgf_isom_get_cenc_info(trak->moov->mov, track_num, DescIndex, NULL, &scheme_type, NULL);\n \n \t\tif (traf->sample_encryption) {\n \t\t\tfor (i = 0; i < gf_list_count(trak->Media->information->sampleTable->child_boxes); i++) {\n \t\t\t\tGF_Box *a = (GF_Box *)gf_list_get(trak->Media->information->sampleTable->child_boxes, i);\n \t\t\t\tif (a->type != traf->sample_encryption->type) continue;\n \n \t\t\t\tif ((a->type ==GF_ISOM_BOX_TYPE_UUID) && (((GF_UUIDBox *)a)->internal_4cc == GF_ISOM_BOX_UUID_PSEC)) {\n \t\t\t\t\tsenc = (GF_SampleEncryptionBox *)a;\n \t\t\t\t\tbreak;\n \t\t\t\t}\n \t\t\t\telse if (a->type ==GF_ISOM_BOX_TYPE_SENC) {\n \t\t\t\t\tsenc = (GF_SampleEncryptionBox *)a;\n \t\t\t\t\tbreak;\n \t\t\t\t}\n \t\t\t}\n \t\t\tif (!senc && trak->sample_encryption)\n \t\t\t\tsenc = trak->sample_encryption;\n \n \t\t\tif (!senc) {\n \t\t\t\tif (traf->sample_encryption->piff_type==1) {\n \t\t\t\t\tsenc = (GF_SampleEncryptionBox *)gf_isom_create_piff_psec_box(1, 0x2, 0, 0, NULL);\n \t\t\t\t} else {\n \t\t\t\t\tsenc = gf_isom_create_samp_enc_box(1, 0x2);\n \t\t\t\t}\n \n \t\t\t\tif (!trak->Media->information->sampleTable->child_boxes) trak->Media->information->sampleTable->child_boxes = gf_list_new();\n \n \t\t\t\ttrak->sample_encryption = senc;\n \t\t\t\tif (!trak->child_boxes) trak->child_boxes = gf_list_new();\n \t\t\t\tgf_list_add(trak->child_boxes, senc);\n \t\t\t}\n \t\t}\n \n \t\tif (gf_isom_cenc_has_saiz_saio_traf(traf, scheme_type)) {\n \t\t\tu32 nb_saio;\n \t\t\tu32 aux_info_type;\n \t\t\tu64 offset;\n \t\t\tGF_Err e;\n \t\t\tBool is_encrypted;\n \t\t\tGF_SampleAuxiliaryInfoOffsetBox *saio = NULL;\n \t\t\tGF_SampleAuxiliaryInfoSizeBox *saiz = NULL;\n \n \t\t\toffset = nb_saio = 0;\n \n \t\t\tfor (i = 0; i < gf_list_count(traf->sai_offsets); i++) {\n \t\t\t\tsaio = (GF_SampleAuxiliaryInfoOffsetBox *)gf_list_get(traf->sai_offsets, i);\n \t\t\t\taux_info_type = saio->aux_info_type;\n \t\t\t\tif (!aux_info_type) aux_info_type = scheme_type;\n \n \t\t\t\tif ((aux_info_type == GF_ISOM_CENC_SCHEME) || (aux_info_type == GF_ISOM_CBC_SCHEME) ||\n \t\t\t\t\t(aux_info_type == GF_ISOM_CENS_SCHEME) || (aux_info_type == GF_ISOM_CBCS_SCHEME) ||\n \t\t\t\t\t(gf_list_count(traf->sai_offsets) == 1)) {\n// bug_start\n\t\t\t\t\toffset = saio->offsets[0] + moof_offset;\n\t\t\t\t\tnb_saio = saio->entry_count;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n// bug_end\n \t\t\t}\n \t\t\tfor (i = 0; i < gf_list_count(traf->sai_sizes); i++) {\n \t\t\t\tsaiz = (GF_SampleAuxiliaryInfoSizeBox *)gf_list_get(traf->sai_sizes, i);\n \t\t\t\taux_info_type = saiz->aux_info_type;\n \t\t\t\tif (!aux_info_type) aux_info_type = scheme_type;\n \t\t\t\tif ((aux_info_type == GF_ISOM_CENC_SCHEME) || (aux_info_type == GF_ISOM_CBC_SCHEME) ||\n \t\t\t\t\t(aux_info_type == GF_ISOM_CENS_SCHEME) || (aux_info_type == GF_ISOM_CBCS_SCHEME) ||\n \t\t\t\t\t(gf_list_count(traf->sai_sizes) == 1)) {\n \t\t\t\t\tbreak;\n \t\t\t\t}\n// bug_start\n// bug_end\n \t\t\t}\n \t\t\tif (saiz && saio && senc) {\n \t\t\t\tfor (i = 0; i < saiz->sample_count; i++) {\n \t\t\t\t\tGF_CENCSampleAuxInfo *sai;\n \t\t\t\t\tconst u8 *key_info=NULL;\n \t\t\t\t\tu32 key_info_size;\n \t\t\t\t\tu64 cur_position;\n \t\t\t\t\tif (nb_saio != 1)\n \t\t\t\t\t\toffset = saio->offsets[i] + moof_offset;\n \t\t\t\t\tsize = saiz->default_sample_info_size ? saiz->default_sample_info_size : saiz->sample_info_size[i];\n \n \t\t\t\t\tcur_position = gf_bs_get_position(trak->moov->mov->movieFileMap->bs);\n \t\t\t\t\tgf_bs_seek(trak->moov->mov->movieFileMap->bs, offset);\n \n \t\t\t\t\tGF_SAFEALLOC(sai, GF_CENCSampleAuxInfo);\n \t\t\t\t\tif (!sai) return GF_OUT_OF_MEM;\n \n \t\t\t\t\te = gf_isom_get_sample_cenc_info_internal(trak, traf, senc, i+1, &is_encrypted, NULL, NULL, &key_info, &key_info_size);\n \t\t\t\t\tif (e) {\n \t\t\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[isobmf] could not get cenc info for sample %d: %s\\n\", i+1, gf_error_to_string(e) ));\n \t\t\t\t\t\treturn e;\n \t\t\t\t\t}\n \n \t\t\t\t\tif (is_encrypted) {\n \t\t\t\t\t\tsai->cenc_data_size = size;\n \t\t\t\t\t\tsai->cenc_data = gf_malloc(sizeof(u8)*size);\n \t\t\t\t\t\tif (!sai->cenc_data) return GF_OUT_OF_MEM;\n \t\t\t\t\t\tgf_bs_read_data(trak->moov->mov->movieFileMap->bs, sai->cenc_data, sai->cenc_data_size);\n \t\t\t\t\t} else {\n \t\t\t\t\t\tsai->isNotProtected=1;\n \t\t\t\t\t}\n \n \t\t\t\t\tif (key_info) {\n \t\t\t\t\t\tif (!key_info[0]) {\n \t\t\t\t\t\t\tif (size > key_info[3])\n \t\t\t\t\t\t\t\tsenc->flags = 0x00000002;\n \t\t\t\t\t\t}\n \t\t\t\t\t\telse {\n \t\t\t\t\t\t\tsenc->flags = 0x00000002;\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \n \n \t\t\t\t\tgf_bs_seek(trak->moov->mov->movieFileMap->bs, cur_position);\n \n \t\t\t\t\tgf_list_add(senc->samp_aux_info, sai);\n \n \t\t\t\t\te = gf_isom_cenc_merge_saiz_saio(senc, trak->Media->information->sampleTable, offset, size);\n \t\t\t\t\tif (e) return e;\n \t\t\t\t\tif (nb_saio == 1)\n \t\t\t\t\t\toffset += size;\n \t\t\t\t}\n \t\t\t}\n \t\t} else if (traf->sample_encryption) {\n \t\t\tsenc_Parse(trak->moov->mov->movieFileMap->bs, trak, traf, traf->sample_encryption);\n \t\t\ttrak->sample_encryption->AlgorithmID = traf->sample_encryption->AlgorithmID;\n \t\t\tif (!trak->sample_encryption->IV_size)\n \t\t\t\ttrak->sample_encryption->IV_size = traf->sample_encryption->IV_size;\n \t\t\tif (!trak->sample_encryption->samp_aux_info) trak->sample_encryption->samp_aux_info = gf_list_new();\n \t\t\tgf_list_transfer(trak->sample_encryption->samp_aux_info, traf->sample_encryption->samp_aux_info);\n \t\t\tif (traf->sample_encryption->flags & 0x00000002)\n \t\t\t\ttrak->sample_encryption->flags |= 0x00000002;\n \t\t}\n \t}\n \treturn GF_OK;\n }\n \n", "target": "// fix_start\n\t\t\t\t\tif (saio->offsets && saio->entry_count) {\n\t\t\t\t\t\toffset = saio->offsets[0] + moof_offset;\n\t\t\t\t\t\tnb_saio = saio->entry_count;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tsaio = NULL;\n// fix_end\n// fix_start\n\t\t\t\tsaiz = NULL;\n// fix_end\n", "cwe": "CWE-476", "cwe_name": "NULL Pointer Dereference", "cve": "CVE-2021-31260", "cve_desc": "The MergeTrack function in GPAC 1.0.1 allows attackers to cause a denial of service (NULL pointer dereference) via a crafted file in the MP4Box command.", "project": "gpac", "idx": 198316}
{"source": " TfLiteStatus Prepare(TfLiteContext* context, TfLiteNode* node) {\n   auto* params =\n       reinterpret_cast<TfLiteConcatenationParams*>(node->builtin_data);\n   int axis = params->axis;\n   int num_inputs = node->inputs->size;\n \n   const TfLiteTensor* t0;\n   TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, 0, &t0));\n   TfLiteType input_type = t0->type;\n   if (axis < 0) axis += t0->dims->size;\n   TF_LITE_ENSURE(context, axis >= 0);\n   TF_LITE_ENSURE(context, axis < t0->dims->size);\n \n   TF_LITE_ENSURE_EQ(context, params->activation, kTfLiteActNone);\n   TF_LITE_ENSURE(context,\n                  input_type == kTfLiteFloat32 || input_type == kTfLiteUInt8 ||\n                      input_type == kTfLiteInt8 || input_type == kTfLiteInt16 ||\n                      input_type == kTfLiteInt32 || input_type == kTfLiteInt64 ||\n                      input_type == kTfLiteBool);\n \n   int sum_axis = t0->dims->data[axis];\n   for (int i = 1; i < num_inputs; ++i) {\n     const TfLiteTensor* t;\n     TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, i, &t));\n     TF_LITE_ENSURE_EQ(context, t->dims->size, t0->dims->size);\n     TF_LITE_ENSURE_EQ(context, t->type, input_type);\n     for (int d = 0; d < t0->dims->size; ++d) {\n       if (d == axis) {\n// bug_start\n// bug_end\n         sum_axis += t->dims->data[axis];\n       } else {\n         TF_LITE_ENSURE_EQ(context, t->dims->data[d], t0->dims->data[d]);\n       }\n     }\n   }\n \n   TfLiteIntArray* output_size = TfLiteIntArrayCreate(t0->dims->size);\n   for (int d = 0; d < t0->dims->size; ++d) {\n     output_size->data[d] = (d == axis) ? sum_axis : t0->dims->data[d];\n   }\n \n   TfLiteTensor* output;\n   TF_LITE_ENSURE_OK(context, GetOutputSafe(context, node, 0, &output));\n   TF_LITE_ENSURE_TYPES_EQ(context, output->type, input_type);\n \n   if (input_type == kTfLiteInt8) {\n     VectorOfTensors<int8_t> all_inputs(*context, *node->inputs);\n     for (int i = 0; i < node->inputs->size; ++i) {\n       const TfLiteTensor* t;\n       TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, i, &t));\n       TF_LITE_ENSURE_EQ(context, t->params.scale, output->params.scale);\n       TF_LITE_ENSURE_EQ(context, t->params.zero_point,\n                         output->params.zero_point);\n     }\n   }\n \n   if (input_type == kTfLiteInt16) {\n     for (int i = 0; i < node->inputs->size; ++i) {\n       const TfLiteTensor* t = GetInput(context, node, i);\n       TF_LITE_ENSURE_EQ(context, t->params.zero_point, 0);\n     }\n     TF_LITE_ENSURE_EQ(context, output->params.zero_point, 0);\n   }\n \n   return context->ResizeTensor(context, output, output_size);\n }\n \n", "target": "// fix_start\n        TF_LITE_ENSURE(context, t->dims->data[axis] >= 0);\n        TF_LITE_ENSURE(context, t->dims->data[axis] <=\n                                    std::numeric_limits<int>::max() - sum_axis);\n// fix_end\n", "cwe": "CWE-476", "cwe_name": "NULL Pointer Dereference", "cve": "CVE-2021-29601", "cve_desc": "TensorFlow is an end-to-end open source platform for machine learning. The TFLite implementation of concatenation is vulnerable to an integer overflow issue(https://github.com/tensorflow/tensorflow/blob/7b7352a724b690b11bfaae2cd54bc3907daf6285/tensorflow/lite/kernels/concatenation.cc#L70-L76). An attacker can craft a model such that the dimensions of one of the concatenation input overflow the values of `int`. TFLite uses `int` to represent tensor dimensions, whereas TF uses `int64`. Hence, valid TF models can trigger an integer overflow when converted to TFLite format. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.", "project": "tensorflow", "idx": 198349}
{"source": " \tPong(const std::string& cookie, const std::string& server = \"\")\n \t\t: ClientProtocol::Message(\"PONG\", ServerInstance->Config->GetServerName())\n \t{\n// bug_start\n\t\tPushParamRef(ServerInstance->Config->GetServerName());\n\t\tif (!server.empty())\n\t\t\tPushParamRef(server);\n// bug_end\n \t\tPushParamRef(cookie);\n \t}\n \n", "target": "// fix_start\n\t\tif (server.empty())\n\t\t\tPushParamRef(ServerInstance->Config->GetServerName());\n\t\telse\n\t\t\tPushParam(server);\n// fix_end\n", "cwe": "CWE-200", "cwe_name": "Exposure of Sensitive Information to an Unauthorized Actor", "cve": "CVE-2021-33586", "cve_desc": "InspIRCd 3.8.0 through 3.9.x before 3.10.0 allows any user (able to connect to the server) to access recently deallocated memory, aka the \"malformed PONG\" issue.", "project": "inspircd", "idx": 198370}
{"source": " static int cbs_jpeg_split_fragment(CodedBitstreamContext *ctx,\n                                    CodedBitstreamFragment *frag,\n                                    int header)\n {\n     AVBufferRef *data_ref;\n     uint8_t *data;\n     size_t data_size;\n     int unit, start, end, marker, next_start, next_marker;\n     int err, i, j, length;\n \n     if (frag->data_size < 4) {\n         return AVERROR_INVALIDDATA;\n     }\n \n     for (i = 0; i + 1 < frag->data_size && frag->data[i] != 0xff; i++);\n     if (i > 0) {\n         av_log(ctx->log_ctx, AV_LOG_WARNING, \"Discarding %d bytes at \"\n                \"beginning of image.\\n\", i);\n     }\n     for (++i; i + 1 < frag->data_size && frag->data[i] == 0xff; i++);\n     if (i + 1 >= frag->data_size && frag->data[i]) {\n         av_log(ctx->log_ctx, AV_LOG_ERROR, \"Invalid JPEG image: \"\n                \"no SOI marker found.\\n\");\n         return AVERROR_INVALIDDATA;\n     }\n     marker = frag->data[i];\n     if (marker != JPEG_MARKER_SOI) {\n         av_log(ctx->log_ctx, AV_LOG_ERROR, \"Invalid JPEG image: first \"\n                \"marker is %02x, should be SOI.\\n\", marker);\n         return AVERROR_INVALIDDATA;\n     }\n     for (++i; i + 1 < frag->data_size && frag->data[i] == 0xff; i++);\n     if (i + 1 >= frag->data_size) {\n         av_log(ctx->log_ctx, AV_LOG_ERROR, \"Invalid JPEG image: \"\n                \"no image content found.\\n\");\n         return AVERROR_INVALIDDATA;\n     }\n     marker = frag->data[i];\n     start  = i + 1;\n \n     for (unit = 0;; unit++) {\n         if (marker == JPEG_MARKER_EOI) {\n             break;\n         } else if (marker == JPEG_MARKER_SOS) {\n             for (i = start; i + 1 < frag->data_size; i++) {\n                 if (frag->data[i] != 0xff)\n                     continue;\n                 end = i;\n                 for (++i; i + 1 < frag->data_size &&\n                           frag->data[i] == 0xff; i++);\n                 if (i + 1 >= frag->data_size) {\n                     next_marker = -1;\n                 } else {\n                     if (frag->data[i] == 0x00)\n                         continue;\n                     next_marker = frag->data[i];\n                     next_start  = i + 1;\n                 }\n                 break;\n             }\n         } else {\n             i = start;\n             if (i + 2 > frag->data_size) {\n                 av_log(ctx->log_ctx, AV_LOG_ERROR, \"Invalid JPEG image: \"\n                        \"truncated at %02x marker.\\n\", marker);\n                 return AVERROR_INVALIDDATA;\n             }\n             length = AV_RB16(frag->data + i);\n             if (i + length > frag->data_size) {\n                 av_log(ctx->log_ctx, AV_LOG_ERROR, \"Invalid JPEG image: \"\n                        \"truncated at %02x marker segment.\\n\", marker);\n                 return AVERROR_INVALIDDATA;\n             }\n             end = start + length;\n \n             i = end;\n             if (frag->data[i] != 0xff) {\n                 next_marker = -1;\n             } else {\n                 for (++i; i + 1 < frag->data_size &&\n                           frag->data[i] == 0xff; i++);\n                 if (i + 1 >= frag->data_size) {\n                     next_marker = -1;\n                 } else {\n                     next_marker = frag->data[i];\n                     next_start  = i + 1;\n                 }\n             }\n         }\n \n         if (marker == JPEG_MARKER_SOS) {\n             length = AV_RB16(frag->data + start);\n \n// bug_start\n// bug_end\n             data_ref = NULL;\n             data     = av_malloc(end - start +\n                                  AV_INPUT_BUFFER_PADDING_SIZE);\n             if (!data)\n                 return AVERROR(ENOMEM);\n \n             memcpy(data, frag->data + start, length);\n             for (i = start + length, j = length; i < end; i++, j++) {\n                 if (frag->data[i] == 0xff) {\n                     while (frag->data[i] == 0xff)\n                         ++i;\n                     data[j] = 0xff;\n                 } else {\n                     data[j] = frag->data[i];\n                 }\n             }\n             data_size = j;\n \n             memset(data + data_size, 0, AV_INPUT_BUFFER_PADDING_SIZE);\n \n         } else {\n             data      = frag->data + start;\n             data_size = end - start;\n             data_ref  = frag->data_ref;\n         }\n \n         err = ff_cbs_insert_unit_data(ctx, frag, unit, marker,\n                                       data, data_size, data_ref);\n         if (err < 0) {\n             if (!data_ref)\n                 av_freep(&data);\n             return err;\n         }\n \n         if (next_marker == -1)\n             break;\n         marker = next_marker;\n         start  = next_start;\n     }\n \n     return 0;\n }\n \n", "target": "// fix_start\n            if (length > end - start)\n                return AVERROR_INVALIDDATA;\n\n// fix_end\n", "cwe": "CWE-787", "cwe_name": "Out-of-bounds Write", "cve": "CVE-2020-12284", "cve_desc": "cbs_jpeg_split_fragment in libavcodec/cbs_jpeg.c in FFmpeg 4.1 and 4.2.2 has a heap-based buffer overflow during JPEG_MARKER_SOS handling because of a missing length check.", "project": "FFmpeg", "idx": 198372}
{"source": " TfLiteStatus ResizeOutput(TfLiteContext* context, const TfLiteTensor* input,\n                           const TfLiteTensor* axis, TfLiteTensor* output) {\n   int axis_value;\n   if (axis->type == kTfLiteInt64) {\n     axis_value = static_cast<int>(*GetTensorData<int64_t>(axis));\n   } else {\n     axis_value = *GetTensorData<int>(axis);\n   }\n   if (axis_value < 0) {\n     axis_value += NumDimensions(input);\n   }\n \n// bug_start\n// bug_end\n   TfLiteIntArray* output_dims = TfLiteIntArrayCreate(NumDimensions(input) - 1);\n   int j = 0;\n   for (int i = 0; i < NumDimensions(input); ++i) {\n     if (i != axis_value) {\n       output_dims->data[j] = SizeOfDimension(input, i);\n       ++j;\n     }\n   }\n   return context->ResizeTensor(context, output, output_dims);\n }\n \n", "target": "// fix_start\n  TF_LITE_ENSURE(context, axis_value >= 0);\n  TF_LITE_ENSURE(context, axis_value < NumDimensions(input));\n\n// fix_end\n", "cwe": "CWE-787", "cwe_name": "Out-of-bounds Write", "cve": "CVE-2021-29603", "cve_desc": "TensorFlow is an end-to-end open source platform for machine learning. A specially crafted TFLite model could trigger an OOB write on heap in the TFLite implementation of `ArgMin`/`ArgMax`(https://github.com/tensorflow/tensorflow/blob/102b211d892f3abc14f845a72047809b39cc65ab/tensorflow/lite/kernels/arg_min_max.cc#L52-L59). If `axis_value` is not a value between 0 and `NumDimensions(input)`, then the condition in the `if` is never true, so code writes past the last valid element of `output_dims->data`. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.", "project": "tensorflow", "idx": 198396}
{"source": " mrb_realloc(mrb_state *mrb, void *p, size_t len)\n {\n   void *p2;\n \n   p2 = mrb_realloc_simple(mrb, p, len);\n   if (len == 0) return p2;\n   if (p2 == NULL) {\n// bug_start\n    mrb_free(mrb, p);\n// bug_end\n     mrb->gc.out_of_memory = TRUE;\n     mrb_raise_nomemory(mrb);\n   }\n   else {\n     mrb->gc.out_of_memory = FALSE;\n   }\n \n   return p2;\n }\n \n", "target": "// fix_start\n// fix_end\n", "cwe": "CWE-415", "cwe_name": "Double Free", "cve": "CVE-2020-36401", "cve_desc": "mruby 2.1.2 has a double free in mrb_default_allocf (called from mrb_free and obj_free).", "project": "mruby", "idx": 198402}
{"source": "   Status GetFirstDimensionSize(OpKernelContext* context, INDEX_TYPE* result) {\n     const Tensor first_partition_tensor =\n         context->input(kFirstPartitionInputIndex);\n// bug_start\n// bug_end\n     const RowPartitionType first_partition_type = row_partition_types_[0];\n     switch (first_partition_type) {\n       case RowPartitionType::FIRST_DIM_SIZE:\n         *result = first_partition_tensor.scalar<INDEX_TYPE>()();\n         return Status::OK();\n       case RowPartitionType::VALUE_ROWIDS:\n         return errors::InvalidArgument(\n             \"Cannot handle VALUE_ROWIDS in first dimension.\");\n       case RowPartitionType::ROW_SPLITS:\n         *result = first_partition_tensor.shape().dim_size(0) - 1;\n         return Status::OK();\n       default:\n         return errors::InvalidArgument(\n             \"Cannot handle type \",\n             RowPartitionTypeToString(first_partition_type));\n     }\n   }\n \n", "target": "// fix_start\n    if (row_partition_types_.empty()) {\n      return errors::InvalidArgument(\"No row_partition_types given.\");\n    }\n// fix_end\n", "cwe": "CWE-125", "cwe_name": "Out-of-bounds Read", "cve": "CVE-2021-37638", "cve_desc": "TensorFlow is an end-to-end open source platform for machine learning. Sending invalid argument for `row_partition_types` of `tf.raw_ops.RaggedTensorToTensor` API results in a null pointer dereference and undefined behavior. The [implementation](https://github.com/tensorflow/tensorflow/blob/47a06f40411a69c99f381495f490536972152ac0/tensorflow/core/kernels/ragged_tensor_to_tensor_op.cc#L328) accesses the first element of a user supplied list of values without validating that the provided list is not empty. We have patched the issue in GitHub commit 301ae88b331d37a2a16159b65b255f4f9eb39314. The fix will be included in TensorFlow 2.6.0. We will also cherrypick this commit on TensorFlow 2.5.1, TensorFlow 2.4.3, and TensorFlow 2.3.4, as these are also affected and still in supported range.", "project": "tensorflow", "idx": 198407}
{"source": "   void Compute(OpKernelContext *ctx) override {\n     const Tensor *a_indices, *b_indices, *a_values_t, *b_values_t, *a_shape,\n         *b_shape, *thresh_t;\n \n     OP_REQUIRES_OK(ctx, ctx->input(\"a_indices\", &a_indices));\n     OP_REQUIRES_OK(ctx, ctx->input(\"b_indices\", &b_indices));\n     OP_REQUIRES(ctx,\n                 TensorShapeUtils::IsMatrix(a_indices->shape()) &&\n                     TensorShapeUtils::IsMatrix(b_indices->shape()),\n                 errors::InvalidArgument(\n                     \"Input indices should be matrices but received shapes: \",\n                     a_indices->shape().DebugString(), \" and \",\n                     b_indices->shape().DebugString()));\n     const int64 a_nnz = a_indices->dim_size(0);\n     const int64 b_nnz = b_indices->dim_size(0);\n// bug_start\n// bug_end\n \n     OP_REQUIRES_OK(ctx, ctx->input(\"a_values\", &a_values_t));\n     OP_REQUIRES_OK(ctx, ctx->input(\"b_values\", &b_values_t));\n \n     OP_REQUIRES(ctx,\n                 TensorShapeUtils::IsVector(a_values_t->shape()) &&\n                     TensorShapeUtils::IsVector(b_values_t->shape()),\n                 errors::InvalidArgument(\n                     \"Input values should be vectors but received shapes: \",\n                     a_values_t->shape().DebugString(), \" and \",\n                     b_values_t->shape().DebugString()));\n     auto a_values = ctx->input(1).vec<T>();\n     auto b_values = ctx->input(4).vec<T>();\n     OP_REQUIRES(\n         ctx, a_values.size() == a_nnz && b_values.size() == b_nnz,\n         errors::InvalidArgument(\"Expected \", a_nnz, \" and \", b_nnz,\n                                 \" non-empty input values, got \",\n                                 a_values.size(), \" and \", b_values.size()));\n \n     OP_REQUIRES_OK(ctx, ctx->input(\"a_shape\", &a_shape));\n     OP_REQUIRES_OK(ctx, ctx->input(\"b_shape\", &b_shape));\n     OP_REQUIRES(ctx,\n                 TensorShapeUtils::IsVector(a_shape->shape()) &&\n                     TensorShapeUtils::IsVector(b_shape->shape()),\n                 errors::InvalidArgument(\n                     \"Input shapes should be a vector but received shapes \",\n                     a_shape->shape().DebugString(), \" and \",\n                     b_shape->shape().DebugString()));\n     OP_REQUIRES(\n// bug_start\n// bug_end\n         ctx, a_shape->IsSameSize(*b_shape),\n         errors::InvalidArgument(\n             \"Operands do not have the same ranks; got shapes: \",\n             a_shape->SummarizeValue(10), \" and \", b_shape->SummarizeValue(10)));\n     const auto a_shape_flat = a_shape->flat<int64>();\n     const auto b_shape_flat = b_shape->flat<int64>();\n     for (int i = 0; i < a_shape->NumElements(); ++i) {\n       OP_REQUIRES(ctx, a_shape_flat(i) == b_shape_flat(i),\n                   errors::InvalidArgument(\n                       \"Operands' shapes do not match: got \", a_shape_flat(i),\n                       \" and \", b_shape_flat(i), \" for dimension \", i));\n     }\n \n     OP_REQUIRES_OK(ctx, ctx->input(\"thresh\", &thresh_t));\n     OP_REQUIRES(ctx, TensorShapeUtils::IsScalar(thresh_t->shape()),\n                 errors::InvalidArgument(\n                     \"The magnitude threshold must be a scalar: got shape \",\n                     thresh_t->shape().DebugString()));\n     const Treal thresh = thresh_t->scalar<Treal>()();\n \n     auto a_indices_mat = a_indices->matrix<int64>();\n     auto b_indices_mat = b_indices->matrix<int64>();\n     std::vector<std::pair<bool, int64>> entries_to_copy;\n     entries_to_copy.reserve(a_nnz + b_nnz);\n     std::vector<T> out_values;\n// bug_start\n    const int num_dims = a_shape->dim_size(0);\n\n    OP_REQUIRES(ctx, num_dims > 0,\n                errors::InvalidArgument(\"Invalid input_a shape. Received: \",\n                                        a_shape->DebugString()));\n// bug_end\n \n     int64 i = 0, j = 0;\n     T s;\n     while (i < a_nnz && j < b_nnz) {\n       switch (sparse::DimComparator::cmp(a_indices_mat, b_indices_mat, i, j,\n                                          num_dims)) {\n         case -1:\n           entries_to_copy.emplace_back(true, i);\n           out_values.push_back(a_values(i));\n           ++i;\n           break;\n         case 0:\n           s = a_values(i) + b_values(j);\n           if (thresh <= std::abs(s)) {\n             entries_to_copy.emplace_back(true, i);\n             out_values.push_back(s);\n           }\n           ++i;\n           ++j;\n           break;\n         case 1:\n           entries_to_copy.emplace_back(false, j);\n           out_values.push_back(b_values(j));\n           ++j;\n           break;\n       }\n     }\n \n #define HANDLE_LEFTOVERS(A_OR_B, IDX, IS_A)     \\\n   while (IDX < A_OR_B##_nnz) {                  \\\n     entries_to_copy.emplace_back(IS_A, IDX);    \\\n     out_values.push_back(A_OR_B##_values(IDX)); \\\n     ++IDX;                                      \\\n   }\n \n     HANDLE_LEFTOVERS(a, i, true);\n     HANDLE_LEFTOVERS(b, j, false);\n #undef HANDLE_LEFTOVERS\n \n     const int64 sum_nnz = out_values.size();\n     Tensor *out_indices_t, *out_values_t;\n     OP_REQUIRES_OK(ctx,\n                    ctx->allocate_output(0, TensorShape({sum_nnz, num_dims}),\n                                         &out_indices_t));\n     OP_REQUIRES_OK(\n         ctx, ctx->allocate_output(1, TensorShape({sum_nnz}), &out_values_t));\n     auto out_indices_mat = out_indices_t->matrix<int64>();\n     auto out_values_flat = out_values_t->vec<T>();\n \n     for (i = 0; i < sum_nnz; ++i) {\n       const bool from_a = entries_to_copy[i].first;\n       const int64 idx = entries_to_copy[i].second;\n       out_indices_mat.chip<0>(i) =\n           from_a ? a_indices_mat.chip<0>(idx) : b_indices_mat.chip<0>(idx);\n     }\n     if (sum_nnz > 0) {\n       std::copy_n(out_values.begin(), sum_nnz, &out_values_flat(0));\n     }\n     ctx->set_output(2, *a_shape);\n   }\n \n", "target": "// fix_start\n    const int num_dims = a_indices->dim_size(1);\n    OP_REQUIRES(ctx, b_indices->dim_size(1) == num_dims,\n                errors::InvalidArgument(\n                    \"Input indices must have the same dimension, got \",\n                    num_dims, \" and \", b_indices->dim_size(1)));\n// fix_end\n// fix_start\n        ctx, a_shape->NumElements() == num_dims,\n        errors::InvalidArgument(\"Second dimension of a_indices and length of \"\n                                \"a_shape must match, got \",\n                                num_dims, \" and \", a_shape->NumElements()));\n    OP_REQUIRES(ctx, num_dims > 0,\n                errors::InvalidArgument(\"Tesors must not be empty\"));\n    OP_REQUIRES(\n// fix_end\n// fix_start\n// fix_end\n", "cwe": "CWE-787", "cwe_name": "Out-of-bounds Write", "cve": "CVE-2021-29609", "cve_desc": "TensorFlow is an end-to-end open source platform for machine learning. Incomplete validation in `SparseAdd` results in allowing attackers to exploit undefined behavior (dereferencing null pointers) as well as write outside of bounds of heap allocated data. The implementation(https://github.com/tensorflow/tensorflow/blob/656e7673b14acd7835dc778867f84916c6d1cac2/tensorflow/core/kernels/sparse_add_op.cc) has a large set of validation for the two sparse tensor inputs (6 tensors in total), but does not validate that the tensors are not empty or that the second dimension of `*_indices` matches the size of corresponding `*_shape`. This allows attackers to send tensor triples that represent invalid sparse tensors to abuse code assumptions that are not protected by validation. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.", "project": "tensorflow", "idx": 198409}
{"source": "   void Compute(OpKernelContext* context) override {\n     const Tensor& image = context->input(0);\n     OP_REQUIRES(context, image.dims() == 3,\n                 errors::InvalidArgument(\"image must be 3-dimensional\",\n                                         image.shape().DebugString()));\n// bug_start\n// bug_end\n     OP_REQUIRES(\n         context,\n         FastBoundsCheck(image.NumElements(), std::numeric_limits<int32>::max()),\n         errors::InvalidArgument(\"image cannot have >= int32 max elements\"));\n     const int32 height = static_cast<int32>(image.dim_size(0));\n     const int32 width = static_cast<int32>(image.dim_size(1));\n     const int32 channels = static_cast<int32>(image.dim_size(2));\n \n     const int32 max_row_width = std::numeric_limits<int32>::max() / 2;\n \n     OP_REQUIRES(context, FastBoundsCheck(width * channels, max_row_width),\n                 errors::InvalidArgument(\"image too wide to encode\"));\n \n     OP_REQUIRES(context, channels >= 1 && channels <= 4,\n                 errors::InvalidArgument(\n                     \"image must have 1, 2, 3, or 4 channels, got \", channels));\n \n     Tensor* output = nullptr;\n     OP_REQUIRES_OK(context,\n                    context->allocate_output(0, TensorShape({}), &output));\n     if (desired_channel_bits_ == 8) {\n       OP_REQUIRES(context,\n                   png::WriteImageToBuffer(\n                       image.flat<uint8>().data(), width, height,\n                       width * channels, channels, desired_channel_bits_,\n                       compression_, &output->scalar<tstring>()(), nullptr),\n                   errors::Internal(\"PNG encoding failed\"));\n     } else {\n       OP_REQUIRES(context,\n                   png::WriteImageToBuffer(\n                       image.flat<uint16>().data(), width, height,\n                       width * channels * 2, channels, desired_channel_bits_,\n                       compression_, &output->scalar<tstring>()(), nullptr),\n                   errors::Internal(\"PNG encoding failed\"));\n     }\n   }\n \n", "target": "// fix_start\n    OP_REQUIRES(context, image.NumElements() > 0,\n                errors::Internal(\"Invalid image provided.\"));\n// fix_end\n", "cwe": "CWE-787", "cwe_name": "Out-of-bounds Write", "cve": "CVE-2021-29531", "cve_desc": "TensorFlow is an end-to-end open source platform for machine learning. An attacker can trigger a `CHECK` fail in PNG encoding by providing an empty input tensor as the pixel data. This is because the implementation(https://github.com/tensorflow/tensorflow/blob/e312e0791ce486a80c9d23110841525c6f7c3289/tensorflow/core/kernels/image/encode_png_op.cc#L57-L60) only validates that the total number of pixels in the image does not overflow. Thus, an attacker can send an empty matrix for encoding. However, if the tensor is empty, then the associated buffer is `nullptr`. Hence, when calling `png::WriteImageToBuffer`(https://github.com/tensorflow/tensorflow/blob/e312e0791ce486a80c9d23110841525c6f7c3289/tensorflow/core/kernels/image/encode_png_op.cc#L79-L93), the first argument (i.e., `image.flat<T>().data()`) is `NULL`. This then triggers the `CHECK_NOTNULL` in the first line of `png::WriteImageToBuffer`(https://github.com/tensorflow/tensorflow/blob/e312e0791ce486a80c9d23110841525c6f7c3289/tensorflow/core/lib/png/png_io.cc#L345-L349). Since `image` is null, this results in `abort` being called after printing the stacktrace. Effectively, this allows an attacker to mount a denial of service attack. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.", "project": "tensorflow", "idx": 198430}
{"source": " scanner_scan_all (parser_context_t *context_p,\n                   const uint8_t *arg_list_p,\n                   const uint8_t *arg_list_end_p,\n                   const uint8_t *source_p,\n                   const uint8_t *source_end_p)\n {\n   scanner_context_t scanner_context;\n \n #if ENABLED (JERRY_PARSER_DUMP_BYTE_CODE)\n   if (context_p->is_show_opcodes)\n   {\n     JERRY_DEBUG_MSG (\"\\n--- Scanning start ---\\n\\n\");\n   }\n #endif\n \n   scanner_context.context_status_flags = context_p->status_flags;\n   scanner_context.status_flags = SCANNER_CONTEXT_NO_FLAGS;\n #if ENABLED (JERRY_DEBUGGER)\n   if (JERRY_CONTEXT (debugger_flags) & JERRY_DEBUGGER_CONNECTED)\n   {\n     scanner_context.status_flags |= SCANNER_CONTEXT_DEBUGGER_ENABLED;\n   }\n #endif\n #if ENABLED (JERRY_ES2015)\n   scanner_context.binding_type = SCANNER_BINDING_NONE;\n   scanner_context.active_binding_list_p = NULL;\n #endif\n   scanner_context.active_literal_pool_p = NULL;\n   scanner_context.active_switch_statement.last_case_p = NULL;\n   scanner_context.end_arguments_p = NULL;\n #if ENABLED (JERRY_ES2015)\n   scanner_context.async_source_p = NULL;\n #endif\n \n   context_p->u.scanner_context_p = &scanner_context;\n \n   parser_stack_init (context_p);\n \n   PARSER_TRY (context_p->try_buffer)\n   {\n     context_p->line = 1;\n     context_p->column = 1;\n \n     if (arg_list_p == NULL)\n     {\n       context_p->source_p = source_p;\n       context_p->source_end_p = source_end_p;\n \n       uint16_t status_flags = SCANNER_LITERAL_POOL_FUNCTION_WITHOUT_ARGUMENTS | SCANNER_LITERAL_POOL_CAN_EVAL;\n \n       if (context_p->status_flags & PARSER_IS_STRICT)\n       {\n         status_flags |= SCANNER_LITERAL_POOL_IS_STRICT;\n       }\n \n       scanner_literal_pool_t *literal_pool_p = scanner_push_literal_pool (context_p, &scanner_context, status_flags);\n       literal_pool_p->source_p = source_p;\n \n       parser_stack_push_uint8 (context_p, SCAN_STACK_SCRIPT);\n \n       lexer_next_token (context_p);\n       scanner_check_directives (context_p, &scanner_context);\n     }\n     else\n     {\n       context_p->source_p = arg_list_p;\n       context_p->source_end_p = arg_list_end_p;\n \n       uint16_t status_flags = SCANNER_LITERAL_POOL_FUNCTION;\n \n       if (context_p->status_flags & PARSER_IS_STRICT)\n       {\n         status_flags |= SCANNER_LITERAL_POOL_IS_STRICT;\n       }\n \n #if ENABLED (JERRY_ES2015)\n       if (context_p->status_flags & PARSER_IS_GENERATOR_FUNCTION)\n       {\n         status_flags |= SCANNER_LITERAL_POOL_GENERATOR;\n       }\n #endif\n \n       scanner_push_literal_pool (context_p, &scanner_context, status_flags);\n       scanner_context.mode = SCAN_MODE_FUNCTION_ARGUMENTS;\n       parser_stack_push_uint8 (context_p, SCAN_STACK_SCRIPT_FUNCTION);\n \n       context_p->token.type = LEXER_LEFT_PAREN;\n     }\n \n     while (true)\n     {\n       lexer_token_type_t type = (lexer_token_type_t) context_p->token.type;\n       scan_stack_modes_t stack_top = (scan_stack_modes_t) context_p->stack_top_uint8;\n \n       switch (scanner_context.mode)\n       {\n         case SCAN_MODE_PRIMARY_EXPRESSION:\n         {\n           if (type == LEXER_ADD\n               || type == LEXER_SUBTRACT\n               || LEXER_IS_UNARY_OP_TOKEN (type))\n           {\n             break;\n           }\n         }\n         case SCAN_MODE_PRIMARY_EXPRESSION_AFTER_NEW:\n         {\n           if (scanner_scan_primary_expression (context_p, &scanner_context, type, stack_top) != SCAN_NEXT_TOKEN)\n           {\n             continue;\n           }\n           break;\n         }\n #if ENABLED (JERRY_ES2015)\n         case SCAN_MODE_CLASS_DECLARATION:\n         {\n           if (context_p->token.type == LEXER_KEYW_EXTENDS)\n           {\n             parser_stack_push_uint8 (context_p, SCAN_STACK_CLASS_EXTENDS);\n             scanner_context.mode = SCAN_MODE_PRIMARY_EXPRESSION;\n             break;\n           }\n           else if (context_p->token.type != LEXER_LEFT_BRACE)\n           {\n             scanner_raise_error (context_p);\n           }\n \n           scanner_context.mode = SCAN_MODE_CLASS_METHOD;\n         }\n         case SCAN_MODE_CLASS_METHOD:\n         {\n           JERRY_ASSERT (stack_top == SCAN_STACK_IMPLICIT_CLASS_CONSTRUCTOR\n                         || stack_top == SCAN_STACK_EXPLICIT_CLASS_CONSTRUCTOR);\n \n           lexer_skip_empty_statements (context_p);\n \n           lexer_scan_identifier (context_p);\n \n           if (context_p->token.type == LEXER_RIGHT_BRACE)\n           {\n             scanner_source_start_t source_start;\n \n             parser_stack_pop_uint8 (context_p);\n \n             if (stack_top == SCAN_STACK_IMPLICIT_CLASS_CONSTRUCTOR)\n             {\n               parser_stack_pop (context_p, &source_start, sizeof (scanner_source_start_t));\n             }\n \n             stack_top = context_p->stack_top_uint8;\n \n             JERRY_ASSERT (stack_top == SCAN_STACK_CLASS_STATEMENT || stack_top == SCAN_STACK_CLASS_EXPRESSION);\n \n             if (stack_top == SCAN_STACK_CLASS_STATEMENT)\n             {\n               scanner_context.mode = SCAN_MODE_STATEMENT_END;\n               continue;\n             }\n \n             scanner_context.mode = SCAN_MODE_POST_PRIMARY_EXPRESSION;\n             parser_stack_pop_uint8 (context_p);\n             break;\n           }\n \n           if (context_p->token.type == LEXER_LITERAL\n               && LEXER_IS_IDENT_OR_STRING (context_p->token.lit_location.type)\n               && lexer_compare_literal_to_string (context_p, \"constructor\", 11))\n           {\n             if (stack_top == SCAN_STACK_IMPLICIT_CLASS_CONSTRUCTOR)\n             {\n               scanner_source_start_t source_start;\n               parser_stack_pop_uint8 (context_p);\n               parser_stack_pop (context_p, &source_start, sizeof (scanner_source_start_t));\n \n               scanner_info_t *info_p = scanner_insert_info (context_p, source_start.source_p, sizeof (scanner_info_t));\n               info_p->type = SCANNER_TYPE_CLASS_CONSTRUCTOR;\n               parser_stack_push_uint8 (context_p, SCAN_STACK_EXPLICIT_CLASS_CONSTRUCTOR);\n             }\n           }\n \n           if (lexer_token_is_identifier (context_p, \"static\", 6))\n           {\n             lexer_scan_identifier (context_p);\n           }\n \n           parser_stack_push_uint8 (context_p, SCAN_STACK_FUNCTION_PROPERTY);\n           scanner_context.mode = SCAN_MODE_FUNCTION_ARGUMENTS;\n \n           uint16_t literal_pool_flags = SCANNER_LITERAL_POOL_FUNCTION;\n \n           if (lexer_token_is_identifier (context_p, \"get\", 3)\n               || lexer_token_is_identifier (context_p, \"set\", 3))\n           {\n             lexer_scan_identifier (context_p);\n \n             if (context_p->token.type == LEXER_LEFT_PAREN)\n             {\n               scanner_push_literal_pool (context_p, &scanner_context, SCANNER_LITERAL_POOL_FUNCTION);\n               continue;\n             }\n           }\n           else if (lexer_token_is_identifier (context_p, \"async\", 5))\n           {\n             lexer_scan_identifier (context_p);\n \n             if (context_p->token.type == LEXER_LEFT_PAREN)\n             {\n               scanner_push_literal_pool (context_p, &scanner_context, SCANNER_LITERAL_POOL_FUNCTION);\n               continue;\n             }\n \n             literal_pool_flags |= SCANNER_LITERAL_POOL_ASYNC;\n \n             if (context_p->token.type == LEXER_MULTIPLY)\n             {\n               lexer_scan_identifier (context_p);\n               literal_pool_flags |= SCANNER_LITERAL_POOL_GENERATOR;\n             }\n           }\n           else if (context_p->token.type == LEXER_MULTIPLY)\n           {\n             lexer_scan_identifier (context_p);\n             literal_pool_flags |= SCANNER_LITERAL_POOL_GENERATOR;\n           }\n \n           if (context_p->token.type == LEXER_LEFT_SQUARE)\n           {\n             parser_stack_push_uint8 (context_p, SCANNER_FROM_LITERAL_POOL_TO_COMPUTED (literal_pool_flags));\n             scanner_context.mode = SCAN_MODE_PRIMARY_EXPRESSION;\n             break;\n           }\n \n           if (context_p->token.type != LEXER_LITERAL)\n           {\n             scanner_raise_error (context_p);\n           }\n \n           if (literal_pool_flags & SCANNER_LITERAL_POOL_GENERATOR)\n           {\n             context_p->status_flags |= PARSER_IS_GENERATOR_FUNCTION;\n           }\n \n           scanner_push_literal_pool (context_p, &scanner_context, literal_pool_flags);\n           lexer_next_token (context_p);\n           continue;\n         }\n #endif\n         case SCAN_MODE_POST_PRIMARY_EXPRESSION:\n         {\n           if (scanner_scan_post_primary_expression (context_p, &scanner_context, type, stack_top))\n           {\n             break;\n           }\n           type = (lexer_token_type_t) context_p->token.type;\n         }\n         case SCAN_MODE_PRIMARY_EXPRESSION_END:\n         {\n           if (scanner_scan_primary_expression_end (context_p, &scanner_context, type, stack_top) != SCAN_NEXT_TOKEN)\n           {\n             continue;\n           }\n           break;\n         }\n         case SCAN_MODE_STATEMENT_OR_TERMINATOR:\n         {\n           if (type == LEXER_RIGHT_BRACE || type == LEXER_EOS)\n           {\n             scanner_context.mode = SCAN_MODE_STATEMENT_END;\n             continue;\n           }\n         }\n         case SCAN_MODE_STATEMENT:\n         {\n           if (scanner_scan_statement (context_p, &scanner_context, type, stack_top) != SCAN_NEXT_TOKEN)\n           {\n             continue;\n           }\n           break;\n         }\n         case SCAN_MODE_STATEMENT_END:\n         {\n           if (scanner_scan_statement_end (context_p, &scanner_context, type) != SCAN_NEXT_TOKEN)\n           {\n             continue;\n           }\n \n           if (context_p->token.type == LEXER_EOS)\n           {\n             goto scan_completed;\n           }\n \n           break;\n         }\n         case SCAN_MODE_VAR_STATEMENT:\n         {\n #if ENABLED (JERRY_ES2015)\n           if (type == LEXER_LEFT_SQUARE || type == LEXER_LEFT_BRACE)\n           {\n             uint8_t binding_type = SCANNER_BINDING_VAR;\n \n             if (stack_top == SCAN_STACK_LET || stack_top == SCAN_STACK_FOR_LET_START)\n             {\n               binding_type = SCANNER_BINDING_LET;\n             }\n             else if (stack_top == SCAN_STACK_CONST || stack_top == SCAN_STACK_FOR_CONST_START)\n             {\n               binding_type = SCANNER_BINDING_CONST;\n             }\n \n             scanner_push_destructuring_pattern (context_p, &scanner_context, binding_type, false);\n \n             if (type == LEXER_LEFT_SQUARE)\n             {\n               parser_stack_push_uint8 (context_p, SCAN_STACK_ARRAY_LITERAL);\n               scanner_context.mode = SCAN_MODE_BINDING;\n               break;\n             }\n \n             parser_stack_push_uint8 (context_p, SCAN_STACK_OBJECT_LITERAL);\n             scanner_context.mode = SCAN_MODE_PROPERTY_NAME;\n             continue;\n           }\n #endif\n \n           if (type != LEXER_LITERAL\n               || context_p->token.lit_location.type != LEXER_IDENT_LITERAL)\n           {\n             scanner_raise_error (context_p);\n           }\n \n           lexer_lit_location_t *literal_p = scanner_add_literal (context_p, &scanner_context);\n \n #if ENABLED (JERRY_ES2015)\n           if (stack_top != SCAN_STACK_VAR && stack_top != SCAN_STACK_FOR_VAR_START)\n           {\n             scanner_detect_invalid_let (context_p, literal_p);\n \n             if (stack_top == SCAN_STACK_LET || stack_top == SCAN_STACK_FOR_LET_START)\n             {\n               literal_p->type |= SCANNER_LITERAL_IS_LET;\n             }\n             else\n             {\n               JERRY_ASSERT (stack_top == SCAN_STACK_CONST || stack_top == SCAN_STACK_FOR_CONST_START);\n               literal_p->type |= SCANNER_LITERAL_IS_CONST;\n             }\n \n             lexer_next_token (context_p);\n \n             if (literal_p->type & SCANNER_LITERAL_IS_USED)\n             {\n               literal_p->type |= SCANNER_LITERAL_EARLY_CREATE;\n             }\n             else if (context_p->token.type == LEXER_ASSIGN)\n             {\n               scanner_binding_literal_t binding_literal;\n               binding_literal.literal_p = literal_p;\n \n               parser_stack_push (context_p, &binding_literal, sizeof (scanner_binding_literal_t));\n               parser_stack_push_uint8 (context_p, SCAN_STACK_BINDING_INIT);\n             }\n           }\n           else\n           {\n             if (!(literal_p->type & SCANNER_LITERAL_IS_VAR))\n             {\n               scanner_detect_invalid_var (context_p, &scanner_context, literal_p);\n               literal_p->type |= SCANNER_LITERAL_IS_VAR;\n \n               if (scanner_context.active_literal_pool_p->status_flags & SCANNER_LITERAL_POOL_IN_WITH)\n               {\n                 literal_p->type |= SCANNER_LITERAL_NO_REG;\n               }\n             }\n \n             lexer_next_token (context_p);\n           }\n #else\n           literal_p->type |= SCANNER_LITERAL_IS_VAR;\n \n           if (scanner_context.active_literal_pool_p->status_flags & SCANNER_LITERAL_POOL_IN_WITH)\n           {\n             literal_p->type |= SCANNER_LITERAL_NO_REG;\n           }\n \n           lexer_next_token (context_p);\n #endif\n \n #if ENABLED (JERRY_ES2015_MODULE_SYSTEM)\n           if (scanner_context.active_literal_pool_p->status_flags & SCANNER_LITERAL_POOL_IN_EXPORT)\n           {\n             literal_p->type |= SCANNER_LITERAL_NO_REG;\n           }\n #endif\n \n           switch (context_p->token.type)\n           {\n             case LEXER_ASSIGN:\n             {\n               scanner_context.mode = SCAN_MODE_PRIMARY_EXPRESSION;\n             }\n             case LEXER_COMMA:\n             {\n               lexer_next_token (context_p);\n               continue;\n             }\n           }\n \n           if (SCANNER_IS_FOR_START (stack_top))\n           {\n #if ENABLED (JERRY_ES2015_MODULE_SYSTEM)\n             JERRY_ASSERT (!(scanner_context.active_literal_pool_p->status_flags & SCANNER_LITERAL_POOL_IN_EXPORT));\n #endif\n \n             if (context_p->token.type != LEXER_SEMICOLON\n                 && context_p->token.type != LEXER_KEYW_IN\n                 && !SCANNER_IDENTIFIER_IS_OF ())\n             {\n               scanner_raise_error (context_p);\n             }\n \n             scanner_context.mode = SCAN_MODE_PRIMARY_EXPRESSION_END;\n             continue;\n           }\n \n #if ENABLED (JERRY_ES2015)\n           JERRY_ASSERT (stack_top == SCAN_STACK_VAR || stack_top == SCAN_STACK_LET || stack_top == SCAN_STACK_CONST);\n #else\n           JERRY_ASSERT (stack_top == SCAN_STACK_VAR);\n #endif\n \n #if ENABLED (JERRY_ES2015_MODULE_SYSTEM)\n           scanner_context.active_literal_pool_p->status_flags &= (uint16_t) ~SCANNER_LITERAL_POOL_IN_EXPORT;\n #endif\n \n           scanner_context.mode = SCAN_MODE_STATEMENT_END;\n           parser_stack_pop_uint8 (context_p);\n           continue;\n         }\n         case SCAN_MODE_FUNCTION_ARGUMENTS:\n         {\n           JERRY_ASSERT (stack_top == SCAN_STACK_SCRIPT_FUNCTION\n                         || stack_top == SCAN_STACK_FUNCTION_STATEMENT\n                         || stack_top == SCAN_STACK_FUNCTION_EXPRESSION\n                         || stack_top == SCAN_STACK_FUNCTION_PROPERTY);\n \n           scanner_literal_pool_t *literal_pool_p = scanner_context.active_literal_pool_p;\n \n           JERRY_ASSERT (literal_pool_p != NULL && (literal_pool_p->status_flags & SCANNER_LITERAL_POOL_FUNCTION));\n \n           literal_pool_p->source_p = context_p->source_p;\n \n #if ENABLED (JERRY_ES2015)\n           if (JERRY_UNLIKELY (scanner_context.async_source_p != NULL))\n           {\n             literal_pool_p->status_flags |= SCANNER_LITERAL_POOL_ASYNC;\n             literal_pool_p->source_p = scanner_context.async_source_p;\n             scanner_context.async_source_p = NULL;\n           }\n #endif\n \n           if (type != LEXER_LEFT_PAREN)\n           {\n             scanner_raise_error (context_p);\n           }\n           lexer_next_token (context_p);\n \n #if ENABLED (JERRY_ES2015)\n         }\n         case SCAN_MODE_CONTINUE_FUNCTION_ARGUMENTS:\n         {\n #endif\n           if (context_p->token.type != LEXER_RIGHT_PAREN && context_p->token.type != LEXER_EOS)\n           {\n #if ENABLED (JERRY_ES2015)\n             lexer_lit_location_t *argument_literal_p;\n #endif\n \n             while (true)\n             {\n #if ENABLED (JERRY_ES2015)\n               if (context_p->token.type == LEXER_THREE_DOTS)\n               {\n                 scanner_context.active_literal_pool_p->status_flags |= SCANNER_LITERAL_POOL_ARGUMENTS_UNMAPPED;\n \n                 lexer_next_token (context_p);\n               }\n \n               if (context_p->token.type == LEXER_LEFT_SQUARE || context_p->token.type == LEXER_LEFT_BRACE)\n               {\n                 argument_literal_p = NULL;\n                 break;\n               }\n #endif\n \n               if (context_p->token.type != LEXER_LITERAL\n                   || context_p->token.lit_location.type != LEXER_IDENT_LITERAL)\n               {\n                 scanner_raise_error (context_p);\n               }\n \n #if ENABLED (JERRY_ES2015)\n               argument_literal_p = scanner_append_argument (context_p, &scanner_context);\n #else\n               scanner_append_argument (context_p, &scanner_context);\n #endif\n \n               lexer_next_token (context_p);\n \n               if (context_p->token.type != LEXER_COMMA)\n               {\n                 break;\n               }\n               lexer_next_token (context_p);\n             }\n \n #if ENABLED (JERRY_ES2015)\n             if (argument_literal_p == NULL)\n             {\n               scanner_context.active_literal_pool_p->status_flags |= SCANNER_LITERAL_POOL_ARGUMENTS_UNMAPPED;\n \n               parser_stack_push_uint8 (context_p, SCAN_STACK_FUNCTION_PARAMETERS);\n               scanner_append_hole (context_p, &scanner_context);\n               scanner_push_destructuring_pattern (context_p, &scanner_context, SCANNER_BINDING_ARG, false);\n \n               if (context_p->token.type == LEXER_LEFT_SQUARE)\n               {\n                 parser_stack_push_uint8 (context_p, SCAN_STACK_ARRAY_LITERAL);\n                 scanner_context.mode = SCAN_MODE_BINDING;\n                 break;\n               }\n \n               parser_stack_push_uint8 (context_p, SCAN_STACK_OBJECT_LITERAL);\n               scanner_context.mode = SCAN_MODE_PROPERTY_NAME;\n               continue;\n             }\n \n             if (context_p->token.type == LEXER_ASSIGN)\n             {\n               scanner_context.active_literal_pool_p->status_flags |= SCANNER_LITERAL_POOL_ARGUMENTS_UNMAPPED;\n \n               parser_stack_push_uint8 (context_p, SCAN_STACK_FUNCTION_PARAMETERS);\n               scanner_context.mode = SCAN_MODE_PRIMARY_EXPRESSION;\n \n               if (argument_literal_p->type & SCANNER_LITERAL_IS_USED)\n               {\n                 JERRY_ASSERT (argument_literal_p->type & SCANNER_LITERAL_EARLY_CREATE);\n                 break;\n               }\n \n               scanner_binding_literal_t binding_literal;\n               binding_literal.literal_p = argument_literal_p;\n \n               parser_stack_push (context_p, &binding_literal, sizeof (scanner_binding_literal_t));\n               parser_stack_push_uint8 (context_p, SCAN_STACK_BINDING_INIT);\n               break;\n             }\n #endif\n           }\n \n           if (context_p->token.type == LEXER_EOS && stack_top == SCAN_STACK_SCRIPT_FUNCTION)\n           {\n             scanner_info_t *scanner_info_p = (scanner_info_t *) scanner_malloc (context_p, sizeof (scanner_info_t));\n             scanner_info_p->next_p = context_p->next_scanner_info_p;\n             scanner_info_p->source_p = NULL;\n             scanner_info_p->type = SCANNER_TYPE_END_ARGUMENTS;\n             scanner_context.end_arguments_p = scanner_info_p;\n \n             context_p->next_scanner_info_p = scanner_info_p;\n             context_p->source_p = source_p;\n             context_p->source_end_p = source_end_p;\n             context_p->line = 1;\n             context_p->column = 1;\n \n             scanner_filter_arguments (context_p, &scanner_context);\n             lexer_next_token (context_p);\n             scanner_check_directives (context_p, &scanner_context);\n             continue;\n           }\n \n           if (context_p->token.type != LEXER_RIGHT_PAREN)\n           {\n             scanner_raise_error (context_p);\n           }\n \n           lexer_next_token (context_p);\n \n           if (context_p->token.type != LEXER_LEFT_BRACE)\n           {\n             scanner_raise_error (context_p);\n           }\n \n           scanner_filter_arguments (context_p, &scanner_context);\n           lexer_next_token (context_p);\n           scanner_check_directives (context_p, &scanner_context);\n           continue;\n         }\n         case SCAN_MODE_PROPERTY_NAME:\n         {\n           JERRY_ASSERT (stack_top == SCAN_STACK_OBJECT_LITERAL);\n \n           if (lexer_scan_identifier (context_p))\n           {\n             lexer_check_property_modifier (context_p);\n           }\n \n #if ENABLED (JERRY_ES2015)\n           if (context_p->token.type == LEXER_LEFT_SQUARE)\n           {\n             parser_stack_push_uint8 (context_p, SCAN_STACK_COMPUTED_PROPERTY);\n             scanner_context.mode = SCAN_MODE_PRIMARY_EXPRESSION;\n             break;\n           }\n #endif\n \n           if (context_p->token.type == LEXER_RIGHT_BRACE)\n           {\n             scanner_context.mode = SCAN_MODE_PRIMARY_EXPRESSION_END;\n             continue;\n           }\n \n           if (context_p->token.type == LEXER_PROPERTY_GETTER\n #if ENABLED (JERRY_ES2015)\n               || context_p->token.type == LEXER_KEYW_ASYNC\n               || context_p->token.type == LEXER_MULTIPLY\n #endif\n               || context_p->token.type == LEXER_PROPERTY_SETTER)\n           {\n             uint16_t literal_pool_flags = SCANNER_LITERAL_POOL_FUNCTION;\n \n #if ENABLED (JERRY_ES2015)\n             if (context_p->token.type == LEXER_MULTIPLY)\n             {\n               literal_pool_flags |= SCANNER_LITERAL_POOL_GENERATOR;\n             }\n             else if (context_p->token.type == LEXER_KEYW_ASYNC)\n             {\n               literal_pool_flags |= SCANNER_LITERAL_POOL_ASYNC;\n \n               if (lexer_consume_generator (context_p))\n               {\n                 literal_pool_flags |= SCANNER_LITERAL_POOL_GENERATOR;\n               }\n             }\n #endif\n \n             parser_stack_push_uint8 (context_p, SCAN_STACK_FUNCTION_PROPERTY);\n             lexer_scan_identifier (context_p);\n \n #if ENABLED (JERRY_ES2015)\n             if (context_p->token.type == LEXER_LEFT_SQUARE)\n             {\n               parser_stack_push_uint8 (context_p, SCANNER_FROM_LITERAL_POOL_TO_COMPUTED (literal_pool_flags));\n               scanner_context.mode = SCAN_MODE_PRIMARY_EXPRESSION;\n               break;\n             }\n #endif\n \n             if (context_p->token.type != LEXER_LITERAL)\n             {\n               scanner_raise_error (context_p);\n             }\n \n             scanner_push_literal_pool (context_p, &scanner_context, literal_pool_flags);\n             scanner_context.mode = SCAN_MODE_FUNCTION_ARGUMENTS;\n             break;\n           }\n \n           if (context_p->token.type != LEXER_LITERAL)\n           {\n             scanner_raise_error (context_p);\n           }\n \n #if ENABLED (JERRY_ES2015)\n           parser_line_counter_t start_line = context_p->token.line;\n           parser_line_counter_t start_column = context_p->token.column;\n           bool is_ident = (context_p->token.lit_location.type == LEXER_IDENT_LITERAL);\n #endif\n \n           lexer_next_token (context_p);\n \n #if ENABLED (JERRY_ES2015)\n           if (context_p->token.type == LEXER_LEFT_PAREN)\n           {\n             scanner_push_literal_pool (context_p, &scanner_context, SCANNER_LITERAL_POOL_FUNCTION);\n \n             parser_stack_push_uint8 (context_p, SCAN_STACK_FUNCTION_PROPERTY);\n             scanner_context.mode = SCAN_MODE_FUNCTION_ARGUMENTS;\n             continue;\n           }\n \n           if (is_ident\n               && (context_p->token.type == LEXER_COMMA\n                   || context_p->token.type == LEXER_RIGHT_BRACE\n                   || context_p->token.type == LEXER_ASSIGN))\n           {\n             context_p->source_p = context_p->token.lit_location.char_p;\n             context_p->line = start_line;\n             context_p->column = start_column;\n \n             lexer_next_token (context_p);\n \n             JERRY_ASSERT (context_p->token.type != LEXER_LITERAL\n                           || context_p->token.lit_location.type == LEXER_IDENT_LITERAL);\n \n             if (context_p->token.type != LEXER_LITERAL)\n             {\n               scanner_raise_error (context_p);\n             }\n \n             if (scanner_context.binding_type != SCANNER_BINDING_NONE)\n             {\n               scanner_context.mode = SCAN_MODE_BINDING;\n               continue;\n             }\n \n             scanner_add_reference (context_p, &scanner_context);\n \n             lexer_next_token (context_p);\n \n             if (context_p->token.type == LEXER_ASSIGN)\n             {\n               scanner_context.mode = SCAN_MODE_PRIMARY_EXPRESSION;\n               break;\n             }\n \n             scanner_context.mode = SCAN_MODE_PRIMARY_EXPRESSION_END;\n             continue;\n           }\n #endif\n \n           if (context_p->token.type != LEXER_COLON)\n           {\n             scanner_raise_error (context_p);\n           }\n \n           scanner_context.mode = SCAN_MODE_PRIMARY_EXPRESSION;\n \n #if ENABLED (JERRY_ES2015)\n           if (scanner_context.binding_type != SCANNER_BINDING_NONE)\n           {\n             scanner_context.mode = SCAN_MODE_BINDING;\n           }\n #endif\n           break;\n         }\n #if ENABLED (JERRY_ES2015)\n         case SCAN_MODE_BINDING:\n         {\n           JERRY_ASSERT (scanner_context.binding_type == SCANNER_BINDING_VAR\n                         || scanner_context.binding_type == SCANNER_BINDING_LET\n                         || scanner_context.binding_type == SCANNER_BINDING_CATCH\n                         || scanner_context.binding_type == SCANNER_BINDING_CONST\n                         || scanner_context.binding_type == SCANNER_BINDING_ARG\n                         || scanner_context.binding_type == SCANNER_BINDING_ARROW_ARG);\n \n           if (type == LEXER_THREE_DOTS)\n           {\n             lexer_next_token (context_p);\n             type = (lexer_token_type_t) context_p->token.type;\n           }\n \n           if (type == LEXER_LEFT_SQUARE || type == LEXER_LEFT_BRACE)\n           {\n             scanner_push_destructuring_pattern (context_p, &scanner_context, scanner_context.binding_type, true);\n \n             if (type == LEXER_LEFT_SQUARE)\n             {\n               parser_stack_push_uint8 (context_p, SCAN_STACK_ARRAY_LITERAL);\n               break;\n             }\n \n             parser_stack_push_uint8 (context_p, SCAN_STACK_OBJECT_LITERAL);\n             scanner_context.mode = SCAN_MODE_PROPERTY_NAME;\n             continue;\n           }\n \n           if (type != LEXER_LITERAL || context_p->token.lit_location.type != LEXER_IDENT_LITERAL)\n           {\n             scanner_context.mode = SCAN_MODE_PRIMARY_EXPRESSION;\n             continue;\n           }\n \n           lexer_lit_location_t *literal_p = scanner_add_literal (context_p, &scanner_context);\n \n           scanner_context.mode = SCAN_MODE_POST_PRIMARY_EXPRESSION;\n \n           if (scanner_context.binding_type == SCANNER_BINDING_VAR)\n           {\n             if (!(literal_p->type & SCANNER_LITERAL_IS_VAR))\n             {\n               scanner_detect_invalid_var (context_p, &scanner_context, literal_p);\n               literal_p->type |= SCANNER_LITERAL_IS_VAR;\n \n               if (scanner_context.active_literal_pool_p->status_flags & SCANNER_LITERAL_POOL_IN_WITH)\n               {\n                 literal_p->type |= SCANNER_LITERAL_NO_REG;\n               }\n             }\n             break;\n           }\n \n           if (scanner_context.binding_type == SCANNER_BINDING_ARROW_ARG)\n           {\n             literal_p->type |= SCANNER_LITERAL_IS_ARG | SCANNER_LITERAL_IS_ARROW_DESTRUCTURED_ARG;\n \n             if (literal_p->type & SCANNER_LITERAL_IS_USED)\n             {\n               literal_p->type |= SCANNER_LITERAL_EARLY_CREATE;\n               break;\n             }\n           }\n           else\n           {\n             scanner_detect_invalid_let (context_p, literal_p);\n \n             if (scanner_context.binding_type <= SCANNER_BINDING_CATCH)\n             {\n               JERRY_ASSERT ((scanner_context.binding_type == SCANNER_BINDING_LET)\n                             || (scanner_context.binding_type == SCANNER_BINDING_CATCH));\n \n               literal_p->type |= SCANNER_LITERAL_IS_LET;\n             }\n             else\n             {\n               literal_p->type |= SCANNER_LITERAL_IS_CONST;\n \n               if (scanner_context.binding_type == SCANNER_BINDING_ARG)\n               {\n                 literal_p->type |= SCANNER_LITERAL_IS_ARG;\n \n                 if (literal_p->type & SCANNER_LITERAL_IS_USED)\n                 {\n                   literal_p->type |= SCANNER_LITERAL_EARLY_CREATE;\n                   break;\n                 }\n               }\n             }\n \n             if (literal_p->type & SCANNER_LITERAL_IS_USED)\n             {\n               literal_p->type |= SCANNER_LITERAL_EARLY_CREATE;\n               break;\n             }\n           }\n \n           scanner_binding_item_t *binding_item_p;\n           binding_item_p = (scanner_binding_item_t *) scanner_malloc (context_p, sizeof (scanner_binding_item_t));\n \n           binding_item_p->next_p = scanner_context.active_binding_list_p->items_p;\n           binding_item_p->literal_p = literal_p;\n \n           scanner_context.active_binding_list_p->items_p = binding_item_p;\n \n           lexer_next_token (context_p);\n           if (context_p->token.type != LEXER_ASSIGN)\n           {\n             continue;\n           }\n \n           scanner_binding_literal_t binding_literal;\n           binding_literal.literal_p = literal_p;\n \n           parser_stack_push (context_p, &binding_literal, sizeof (scanner_binding_literal_t));\n           parser_stack_push_uint8 (context_p, SCAN_STACK_BINDING_INIT);\n \n           scanner_context.mode = SCAN_MODE_PRIMARY_EXPRESSION;\n           break;\n         }\n #endif\n       }\n \n       lexer_next_token (context_p);\n     }\n \n scan_completed:\n     if (context_p->stack_top_uint8 != SCAN_STACK_SCRIPT\n         && context_p->stack_top_uint8 != SCAN_STACK_SCRIPT_FUNCTION)\n     {\n       scanner_raise_error (context_p);\n     }\n \n     scanner_pop_literal_pool (context_p, &scanner_context);\n \n #if ENABLED (JERRY_ES2015)\n     JERRY_ASSERT (scanner_context.active_binding_list_p == NULL);\n #endif\n     JERRY_ASSERT (scanner_context.active_literal_pool_p == NULL);\n \n #ifndef JERRY_NDEBUG\n     scanner_context.context_status_flags |= PARSER_SCANNING_SUCCESSFUL;\n #endif\n   }\n   PARSER_CATCH\n   {\n// bug_start\n    if (context_p->error != PARSER_ERR_OUT_OF_MEMORY)\n    {\n      context_p->error = PARSER_ERR_NO_ERROR;\n    }\n\n// bug_end\n #if ENABLED (JERRY_ES2015)\n     while (scanner_context.active_binding_list_p != NULL)\n     {\n       scanner_pop_binding_list (&scanner_context);\n     }\n #endif\n \n// bug_start\n    PARSER_TRY (context_p->try_buffer)\n// bug_end\n     {\n// bug_start\n#if ENABLED (JERRY_ES2015)\n      if (scanner_context.status_flags & SCANNER_CONTEXT_THROW_ERR_ASYNC_FUNCTION)\n// bug_end\n       {\n// bug_start\n        JERRY_ASSERT (scanner_context.async_source_p != NULL);\n\n        scanner_info_t *info_p;\n        info_p = scanner_insert_info (context_p, scanner_context.async_source_p, sizeof (scanner_info_t));\n        info_p->type = SCANNER_TYPE_ERR_ASYNC_FUNCTION;\n// bug_end\n       }\n// bug_start\n#endif\n\n      while (scanner_context.active_literal_pool_p != NULL)\n// bug_end\n       {\n// bug_start\n        scanner_pop_literal_pool (context_p, &scanner_context);\n// bug_end\n       }\n// bug_start\n// bug_end\n     }\n// bug_start\n    PARSER_CATCH\n// bug_end\n     {\n// bug_start\n      JERRY_ASSERT (context_p->error == PARSER_ERR_NO_ERROR);\n\n// bug_end\n       while (scanner_context.active_literal_pool_p != NULL)\n       {\n         scanner_literal_pool_t *literal_pool_p = scanner_context.active_literal_pool_p;\n \n         scanner_context.active_literal_pool_p = literal_pool_p->prev_p;\n \n         parser_list_free (&literal_pool_p->literal_pool);\n         scanner_free (literal_pool_p, sizeof (scanner_literal_pool_t));\n       }\n// bug_start\n// bug_end\n     }\n// bug_start\n    PARSER_TRY_END\n\n#if ENABLED (JERRY_ES2015)\n    context_p->status_flags &= (uint32_t) ~PARSER_IS_GENERATOR_FUNCTION;\n#endif\n// bug_end\n   }\n   PARSER_TRY_END\n \n   context_p->status_flags = scanner_context.context_status_flags;\n   scanner_reverse_info_list (context_p);\n \n #if ENABLED (JERRY_PARSER_DUMP_BYTE_CODE)\n   if (context_p->is_show_opcodes)\n   {\n     scanner_info_t *info_p = context_p->next_scanner_info_p;\n     const uint8_t *source_start_p = (arg_list_p == NULL) ? source_p : arg_list_p;\n \n     while (info_p->type != SCANNER_TYPE_END)\n     {\n       const char *name_p = NULL;\n       bool print_location = false;\n \n       switch (info_p->type)\n       {\n         case SCANNER_TYPE_END_ARGUMENTS:\n         {\n           JERRY_DEBUG_MSG (\"  END_ARGUMENTS\\n\");\n           source_start_p = source_p;\n           break;\n         }\n         case SCANNER_TYPE_FUNCTION:\n         case SCANNER_TYPE_BLOCK:\n         {\n           const uint8_t *prev_source_p = info_p->source_p - 1;\n           const uint8_t *data_p;\n \n           if (info_p->type == SCANNER_TYPE_FUNCTION)\n           {\n             data_p = (const uint8_t *) (info_p + 1);\n \n             JERRY_DEBUG_MSG (\"  FUNCTION: flags: 0x%x declarations: %d\",\n                              (int) info_p->u8_arg,\n                              (int) info_p->u16_arg);\n           }\n           else\n           {\n             data_p = (const uint8_t *) (info_p + 1);\n \n             JERRY_DEBUG_MSG (\"  BLOCK:\");\n           }\n \n           JERRY_DEBUG_MSG (\" source:%d\\n\", (int) (info_p->source_p - source_start_p));\n \n           while (data_p[0] != SCANNER_STREAM_TYPE_END)\n           {\n             switch (data_p[0] & SCANNER_STREAM_TYPE_MASK)\n             {\n               case SCANNER_STREAM_TYPE_VAR:\n               {\n                 JERRY_DEBUG_MSG (\"    VAR \");\n                 break;\n               }\n #if ENABLED (JERRY_ES2015)\n               case SCANNER_STREAM_TYPE_LET:\n               {\n                 JERRY_DEBUG_MSG (\"    LET \");\n                 break;\n               }\n               case SCANNER_STREAM_TYPE_CONST:\n               {\n                 JERRY_DEBUG_MSG (\"    CONST \");\n                 break;\n               }\n               case SCANNER_STREAM_TYPE_LOCAL:\n               {\n                 JERRY_DEBUG_MSG (\"    LOCAL \");\n                 break;\n               }\n #endif\n #if ENABLED (JERRY_ES2015_MODULE_SYSTEM)\n               case SCANNER_STREAM_TYPE_IMPORT:\n               {\n                 JERRY_DEBUG_MSG (\"    IMPORT \");\n                 break;\n               }\n #endif\n               case SCANNER_STREAM_TYPE_ARG:\n               {\n                 JERRY_DEBUG_MSG (\"    ARG \");\n                 break;\n               }\n #if ENABLED (JERRY_ES2015)\n               case SCANNER_STREAM_TYPE_DESTRUCTURED_ARG:\n               {\n                 JERRY_DEBUG_MSG (\"    DESTRUCTURED_ARG \");\n                 break;\n               }\n #endif\n               case SCANNER_STREAM_TYPE_ARG_FUNC:\n               {\n                 JERRY_DEBUG_MSG (\"    ARG_FUNC \");\n                 break;\n               }\n #if ENABLED (JERRY_ES2015)\n               case SCANNER_STREAM_TYPE_DESTRUCTURED_ARG_FUNC:\n               {\n                 JERRY_DEBUG_MSG (\"    DESTRUCTURED_ARG_FUNC \");\n                 break;\n               }\n #endif\n               case SCANNER_STREAM_TYPE_FUNC:\n               {\n                 JERRY_DEBUG_MSG (\"    FUNC \");\n                 break;\n               }\n               default:\n               {\n                 JERRY_ASSERT ((data_p[0] & SCANNER_STREAM_TYPE_MASK) == SCANNER_STREAM_TYPE_HOLE);\n                 JERRY_DEBUG_MSG (\"    HOLE\\n\");\n                 data_p++;\n                 continue;\n               }\n             }\n \n             size_t length;\n \n             if (!(data_p[0] & SCANNER_STREAM_UINT16_DIFF))\n             {\n               if (data_p[2] != 0)\n               {\n                 prev_source_p += data_p[2];\n                 length = 2 + 1;\n               }\n               else\n               {\n                 memcpy (&prev_source_p, data_p + 2 + 1, sizeof (const uint8_t *));\n                 length = 2 + 1 + sizeof (const uint8_t *);\n               }\n             }\n             else\n             {\n               int32_t diff = ((int32_t) data_p[2]) | ((int32_t) data_p[3]) << 8;\n \n               if (diff <= UINT8_MAX)\n               {\n                 diff = -diff;\n               }\n \n               prev_source_p += diff;\n               length = 2 + 2;\n             }\n \n #if ENABLED (JERRY_ES2015)\n             if (data_p[0] & SCANNER_STREAM_EARLY_CREATE)\n             {\n               JERRY_ASSERT (data_p[0] & SCANNER_STREAM_NO_REG);\n               JERRY_DEBUG_MSG (\"*\");\n             }\n #endif\n \n             if (data_p[0] & SCANNER_STREAM_NO_REG)\n             {\n               JERRY_DEBUG_MSG (\"* \");\n             }\n \n             JERRY_DEBUG_MSG (\"'%.*s'\\n\", data_p[1], (char *) prev_source_p);\n             prev_source_p += data_p[1];\n             data_p += length;\n           }\n           break;\n         }\n         case SCANNER_TYPE_WHILE:\n         {\n           name_p = \"WHILE\";\n           print_location = true;\n           break;\n         }\n         case SCANNER_TYPE_FOR:\n         {\n           scanner_for_info_t *for_info_p = (scanner_for_info_t *) info_p;\n           JERRY_DEBUG_MSG (\"  FOR: source:%d expression:%d[%d:%d] end:%d[%d:%d]\\n\",\n                            (int) (for_info_p->info.source_p - source_start_p),\n                            (int) (for_info_p->expression_location.source_p - source_start_p),\n                            (int) for_info_p->expression_location.line,\n                            (int) for_info_p->expression_location.column,\n                            (int) (for_info_p->end_location.source_p - source_start_p),\n                            (int) for_info_p->end_location.line,\n                            (int) for_info_p->end_location.column);\n           break;\n         }\n         case SCANNER_TYPE_FOR_IN:\n         {\n           name_p = \"FOR-IN\";\n           print_location = true;\n           break;\n         }\n #if ENABLED (JERRY_ES2015)\n         case SCANNER_TYPE_FOR_OF:\n         {\n           name_p = \"FOR-OF\";\n           print_location = true;\n           break;\n         }\n #endif\n         case SCANNER_TYPE_SWITCH:\n         {\n           JERRY_DEBUG_MSG (\"  SWITCH: source:%d\\n\",\n                            (int) (info_p->source_p - source_start_p));\n \n           scanner_case_info_t *current_case_p = ((scanner_switch_info_t *) info_p)->case_p;\n \n           while (current_case_p != NULL)\n           {\n             JERRY_DEBUG_MSG (\"    CASE: location:%d[%d:%d]\\n\",\n                              (int) (current_case_p->location.source_p - source_start_p),\n                              (int) current_case_p->location.line,\n                              (int) current_case_p->location.column);\n \n             current_case_p = current_case_p->next_p;\n           }\n           break;\n         }\n         case SCANNER_TYPE_CASE:\n         {\n           name_p = \"CASE\";\n           print_location = true;\n           break;\n         }\n #if ENABLED (JERRY_ES2015)\n         case SCANNER_TYPE_INITIALIZER:\n         {\n           name_p = \"INITIALIZER\";\n           print_location = true;\n           break;\n         }\n         case SCANNER_TYPE_CLASS_CONSTRUCTOR:\n         {\n           JERRY_DEBUG_MSG (\"  CLASS-CONSTRUCTOR: source:%d\\n\",\n                            (int) (info_p->source_p - source_start_p));\n           print_location = false;\n           break;\n         }\n         case SCANNER_TYPE_LET_EXPRESSION:\n         {\n           JERRY_DEBUG_MSG (\"  LET_EXPRESSION: source:%d\\n\",\n                            (int) (info_p->source_p - source_start_p));\n           break;\n         }\n         case SCANNER_TYPE_ERR_REDECLARED:\n         {\n           JERRY_DEBUG_MSG (\"  ERR_REDECLARED: source:%d\\n\",\n                            (int) (info_p->source_p - source_start_p));\n           break;\n         }\n         case SCANNER_TYPE_ERR_ASYNC_FUNCTION:\n         {\n           JERRY_DEBUG_MSG (\"  ERR_ASYNC_FUNCTION: source:%d\\n\",\n                            (int) (info_p->source_p - source_start_p));\n           break;\n         }\n #endif\n       }\n \n       if (print_location)\n       {\n         scanner_location_info_t *location_info_p = (scanner_location_info_t *) info_p;\n         JERRY_DEBUG_MSG (\"  %s: source:%d location:%d[%d:%d]\\n\",\n                          name_p,\n                          (int) (location_info_p->info.source_p - source_start_p),\n                          (int) (location_info_p->location.source_p - source_start_p),\n                          (int) location_info_p->location.line,\n                          (int) location_info_p->location.column);\n       }\n \n       info_p = info_p->next_p;\n     }\n \n     JERRY_DEBUG_MSG (\"\\n--- Scanning end ---\\n\\n\");\n   }\n #endif\n \n   parser_stack_free (context_p);\n }\n \n", "target": "// fix_start\n// fix_end\n// fix_start\n    if (JERRY_UNLIKELY (context_p->error != PARSER_ERR_OUT_OF_MEMORY))\n// fix_end\n// fix_start\n      context_p->error = PARSER_ERR_NO_ERROR;\n\n      PARSER_TRY (context_p->try_buffer)\n// fix_end\n// fix_start\n  #if ENABLED (JERRY_ES2015)\n        if (scanner_context.status_flags & SCANNER_CONTEXT_THROW_ERR_ASYNC_FUNCTION)\n        {\n          JERRY_ASSERT (scanner_context.async_source_p != NULL);\n\n          scanner_info_t *info_p;\n          info_p = scanner_insert_info (context_p, scanner_context.async_source_p, sizeof (scanner_info_t));\n          info_p->type = SCANNER_TYPE_ERR_ASYNC_FUNCTION;\n        }\n  #endif\n\n        while (scanner_context.active_literal_pool_p != NULL)\n        {\n          scanner_pop_literal_pool (context_p, &scanner_context);\n        }\n// fix_end\n// fix_start\n      PARSER_CATCH\n// fix_end\n// fix_start\n        JERRY_ASSERT (context_p->error == PARSER_ERR_OUT_OF_MEMORY);\n// fix_end\n// fix_start\n      PARSER_TRY_END\n// fix_end\n// fix_start\n\n    JERRY_ASSERT (context_p->error == PARSER_ERR_NO_ERROR || context_p->error == PARSER_ERR_OUT_OF_MEMORY);\n\n    if (context_p->error == PARSER_ERR_OUT_OF_MEMORY)\n// fix_end\n// fix_start\n// fix_end\n// fix_start\n\n      parser_stack_free (context_p);\n      return;\n// fix_end\n// fix_start\n// fix_end\n", "cwe": "CWE-703", "cwe_name": "Improper Check or Handling of Exceptional Conditions", "cve": "CVE-2020-13649", "cve_desc": "parser/js/js-scanner.c in JerryScript 2.2.0 mishandles errors during certain out-of-memory conditions, as demonstrated by a scanner_reverse_info_list NULL pointer dereference and a scanner_scan_all assertion failure.", "project": "jerryscript", "idx": 198440}
{"source": " TfLiteStatus Prepare(TfLiteContext* context, TfLiteNode* node) {\n   auto* params =\n       reinterpret_cast<TfLiteSpaceToDepthParams*>(node->builtin_data);\n \n   TF_LITE_ENSURE_EQ(context, NumInputs(node), 1);\n   TF_LITE_ENSURE_EQ(context, NumOutputs(node), 1);\n \n   const TfLiteTensor* input;\n   TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, kInputTensor, &input));\n   TfLiteTensor* output;\n   TF_LITE_ENSURE_OK(context,\n                     GetOutputSafe(context, node, kOutputTensor, &output));\n \n   TF_LITE_ENSURE_EQ(context, NumDimensions(input), 4);\n \n   auto data_type = output->type;\n   TF_LITE_ENSURE(context,\n                  data_type == kTfLiteFloat32 || data_type == kTfLiteUInt8 ||\n                      data_type == kTfLiteInt8 || data_type == kTfLiteInt32 ||\n                      data_type == kTfLiteInt64);\n   TF_LITE_ENSURE_TYPES_EQ(context, input->type, output->type);\n \n   const int block_size = params->block_size;\n// bug_start\n// bug_end\n   const int input_height = input->dims->data[1];\n   const int input_width = input->dims->data[2];\n   int output_height = input_height / block_size;\n   int output_width = input_width / block_size;\n \n   TF_LITE_ENSURE_EQ(context, input_height, output_height * block_size);\n   TF_LITE_ENSURE_EQ(context, input_width, output_width * block_size);\n \n   TfLiteIntArray* output_size = TfLiteIntArrayCreate(4);\n   output_size->data[0] = input->dims->data[0];\n   output_size->data[1] = output_height;\n   output_size->data[2] = output_width;\n   output_size->data[3] = input->dims->data[3] * block_size * block_size;\n \n   return context->ResizeTensor(context, output, output_size);\n }\n \n", "target": "// fix_start\n  TF_LITE_ENSURE(context, block_size > 0);\n// fix_end\n", "cwe": "CWE-369", "cwe_name": "Divide By Zero", "cve": "CVE-2021-29587", "cve_desc": "TensorFlow is an end-to-end open source platform for machine learning. The `Prepare` step of the `SpaceToDepth` TFLite operator does not check for 0 before division(https://github.com/tensorflow/tensorflow/blob/5f7975d09eac0f10ed8a17dbb6f5964977725adc/tensorflow/lite/kernels/space_to_depth.cc#L63-L67). An attacker can craft a model such that `params->block_size` would be zero. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.", "project": "tensorflow", "idx": 198448}
{"source": " void gf_isom_cenc_get_default_info_internal(GF_TrackBox *trak, u32 sampleDescriptionIndex, u32 *container_type, Bool *default_IsEncrypted, u8 *crypt_byte_block, u8 *skip_byte_block, const u8 **key_info, u32 *key_info_size)\n {\n \tGF_ProtectionSchemeInfoBox *sinf;\n \n \n \tif (default_IsEncrypted) *default_IsEncrypted = GF_FALSE;\n \tif (crypt_byte_block) *crypt_byte_block = 0;\n \tif (skip_byte_block) *skip_byte_block = 0;\n \tif (container_type) *container_type = 0;\n \tif (key_info) *key_info = NULL;\n \tif (key_info_size) *key_info_size = 0;\n \n \tsinf = isom_get_sinf_entry(trak, sampleDescriptionIndex, GF_ISOM_CENC_SCHEME, NULL);\n \tif (!sinf) sinf = isom_get_sinf_entry(trak, sampleDescriptionIndex, GF_ISOM_CBC_SCHEME, NULL);\n \tif (!sinf) sinf = isom_get_sinf_entry(trak, sampleDescriptionIndex, GF_ISOM_CENS_SCHEME, NULL);\n \tif (!sinf) sinf = isom_get_sinf_entry(trak, sampleDescriptionIndex, GF_ISOM_CBCS_SCHEME, NULL);\n \tif (!sinf) sinf = isom_get_sinf_entry(trak, sampleDescriptionIndex, GF_ISOM_PIFF_SCHEME, NULL);\n \n \tif (!sinf) {\n \t\tu32 i, nb_stsd = gf_list_count(trak->Media->information->sampleTable->SampleDescription->child_boxes);\n \t\tfor (i=0; i<nb_stsd; i++) {\n \t\t\tGF_ProtectionSchemeInfoBox *a_sinf;\n \t\t\tGF_SampleEntryBox *sentry=NULL;\n \t\t\tif (i+1==sampleDescriptionIndex) continue;\n \t\t\tsentry = gf_list_get(trak->Media->information->sampleTable->SampleDescription->child_boxes, i);\n \t\t\ta_sinf = (GF_ProtectionSchemeInfoBox *) gf_isom_box_find_child(sentry->child_boxes, GF_ISOM_BOX_TYPE_SINF);\n \t\t\tif (!a_sinf) continue;\n \t\t\treturn;\n \t\t}\n \t}\n \n \tif (sinf && sinf->info && sinf->info->tenc) {\n \t\tif (default_IsEncrypted) *default_IsEncrypted = sinf->info->tenc->isProtected;\n \t\tif (crypt_byte_block) *crypt_byte_block = sinf->info->tenc->crypt_byte_block;\n \t\tif (skip_byte_block) *skip_byte_block = sinf->info->tenc->skip_byte_block;\n \t\tif (key_info) *key_info = sinf->info->tenc->key_info;\n \t\tif (key_info_size) {\n \t\t\t*key_info_size = 20;\n \t\t\tif (!sinf->info->tenc->key_info[3])\n \t\t\t\t*key_info_size += 1 + sinf->info->tenc->key_info[20];\n \t\t}\n \n \t\tif (container_type) *container_type = GF_ISOM_BOX_TYPE_SENC;\n \t} else if (sinf && sinf->info && sinf->info->piff_tenc) {\n \t\tif (default_IsEncrypted) *default_IsEncrypted = GF_TRUE;\n \t\tif (key_info) *key_info = sinf->info->piff_tenc->key_info;\n \t\tif (key_info_size) *key_info_size = 19;\n \t\tif (container_type) *container_type = GF_ISOM_BOX_UUID_PSEC;\n \t} else {\n \t\tu32 i, count = 0;\n \t\tGF_CENCSampleEncryptionGroupEntry *seig_entry = NULL;\n \n \t\tif (!trak->moov->mov->is_smooth)\n \t\t\tcount = gf_list_count(trak->Media->information->sampleTable->sampleGroupsDescription);\n \n \t\tfor (i=0; i<count; i++) {\n \t\t\tGF_SampleGroupDescriptionBox *sgdesc = (GF_SampleGroupDescriptionBox*)gf_list_get(trak->Media->information->sampleTable->sampleGroupsDescription, i);\n \t\t\tif (sgdesc->grouping_type!=GF_ISOM_SAMPLE_GROUP_SEIG) continue;\n \t\t\tif (sgdesc->default_description_index)\n \t\t\t\tseig_entry = gf_list_get(sgdesc->group_descriptions, sgdesc->default_description_index-1);\n \t\t\telse\n \t\t\t\tseig_entry = gf_list_get(sgdesc->group_descriptions, 0);\n// bug_start\n\t\t\tif (!seig_entry->key_info[0])\n// bug_end\n \t\t\t\tseig_entry = NULL;\n \t\t\tbreak;\n \t\t}\n \t\tif (seig_entry) {\n \t\t\tif (default_IsEncrypted) *default_IsEncrypted = seig_entry->IsProtected;\n \t\t\tif (crypt_byte_block) *crypt_byte_block = seig_entry->crypt_byte_block;\n \t\t\tif (skip_byte_block) *skip_byte_block = seig_entry->skip_byte_block;\n \t\t\tif (key_info) *key_info = seig_entry->key_info;\n \t\t\tif (key_info_size) *key_info_size = seig_entry->key_info_size;\n \t\t\tif (container_type) *container_type = GF_ISOM_BOX_TYPE_SENC;\n \t\t} else {\n \t\t\tif (! trak->moov->mov->is_smooth ) {\n \t\t\t\ttrak->moov->mov->is_smooth = GF_TRUE;\n \t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[iso file] senc box without tenc, assuming MS smooth+piff\\n\"));\n \t\t\t}\n \t\t\tif (default_IsEncrypted) *default_IsEncrypted = GF_TRUE;\n \t\t\tif (container_type) *container_type = GF_ISOM_BOX_UUID_PSEC;\n \t\t}\n \t}\n \n \tif (container_type && trak->sample_encryption) {\n \t\tif (trak->sample_encryption->type == GF_ISOM_BOX_TYPE_SENC) *container_type = GF_ISOM_BOX_TYPE_SENC;\n \t\telse if (trak->sample_encryption->type == GF_ISOM_BOX_TYPE_UUID) *container_type = ((GF_UUIDBox*)trak->sample_encryption)->internal_4cc;\n \t}\n }\n \n", "target": "// fix_start\n\t\t\tif (seig_entry && !seig_entry->key_info[0])\n// fix_end\n", "cwe": "CWE-476", "cwe_name": "NULL Pointer Dereference", "cve": "CVE-2021-31259", "cve_desc": "The gf_isom_cenc_get_default_info_internal function in GPAC 1.0.1 allows attackers to cause a denial of service (NULL pointer dereference) via a crafted file in the MP4Box command.", "project": "gpac", "idx": 198469}
{"source": " inline Status SparseTensor::Split(const SparseTensor& input_tensor,\n                                   const int split_dim, const int num_split,\n                                   std::vector<SparseTensor>* result) {\n   std::vector<Tensor> output_indices;\n   std::vector<Tensor> output_values;\n   std::vector<TensorShape> output_shapes;\n   output_indices.reserve(num_split);\n   output_values.reserve(num_split);\n   output_shapes.reserve(num_split);\n \n   std::vector<typename TTypes<int64>::Matrix> output_indices_t;\n   std::vector<typename TTypes<T>::Vec> output_values_t;\n   output_indices_t.reserve(num_split);\n   output_values_t.reserve(num_split);\n   auto input_values_t = input_tensor.values().vec<T>();\n   auto input_indices_t = input_tensor.indices().matrix<int64>();\n \n   std::vector<int> num_values(num_split, 0);\n   const int num_dim = input_tensor.shape().size();\n   const int split_dim_size = input_tensor.shape()[split_dim];\n   const int split_size = split_dim_size / num_split;\n \n   if (!(num_split > 0 && num_split <= split_dim_size)) {\n     return errors::InvalidArgument(\"num_split must be in the interval (0, \",\n                                    split_dim_size, \"]\");\n   }\n   if (!(split_dim >= 0 && split_dim < num_dim)) {\n     return errors::InvalidArgument(\"num_dim must be in the interval [0, \",\n                                    num_dim, \")\");\n   }\n \n   const int residual = split_dim_size % num_split;\n   for (int i = 0; i < input_tensor.indices().dim_size(0); ++i) {\n     const int dim = input_tensor.indices().matrix<int64>()(i, split_dim);\n     int slice_index = GetSliceIndex(dim, split_size, residual);\n// bug_start\n// bug_end\n     num_values[slice_index]++;\n   }\n \n   for (int i = 0; i < num_split; ++i) {\n     output_indices.emplace_back(DT_INT64,\n                                 TensorShape({num_values[i], num_dim}));\n     output_values.emplace_back(DataTypeToEnum<T>::v(),\n                                TensorShape({num_values[i]}));\n     output_shapes.emplace_back(input_tensor.shape());\n     output_indices_t.emplace_back(output_indices[i].matrix<int64>());\n     output_values_t.emplace_back(output_values[i].vec<T>());\n     const int size = GetSliceShape(i, split_size, residual);\n     output_shapes[i].set_dim(split_dim, size);\n   }\n \n   std::vector<int> values_inserted_in_slice(num_split, 0);\n   for (int i = 0; i < input_tensor.indices().dim_size(0); ++i) {\n     const int dim = input_indices_t(i, split_dim);\n     const int slice_index = GetSliceIndex(dim, split_size, residual);\n     const int slice_dim = values_inserted_in_slice[slice_index]++;\n     output_values_t[slice_index](slice_dim) = input_values_t(i);\n     for (int j = 0; j < num_dim; ++j) {\n       const int64 original_dim = input_indices_t(i, j);\n       output_indices_t[slice_index](slice_dim, j) =\n           (j == split_dim)\n               ? GetDimensionInSlice(original_dim, split_size, residual)\n               : original_dim;\n     }\n   }\n \n   result->clear();\n   result->reserve(num_split);\n   for (int i = 0; i < num_split; ++i) {\n     SparseTensor tensor;\n     Status create_status =\n         Create(output_indices[i], output_values[i], output_shapes[i], &tensor);\n     if (!create_status.ok()) {\n       return create_status;\n     }\n     result->push_back(std::move(tensor));\n   }\n   return Status::OK();\n }\n \n", "target": "// fix_start\n    if (slice_index >= num_values.size()) {\n      return errors::InvalidArgument(\"Slice index \", slice_index,\n                                     \" is larger than num_split.\");\n    }\n// fix_end\n", "cwe": "CWE-703", "cwe_name": "Improper Check or Handling of Exceptional Conditions", "cve": "CVE-2021-29558", "cve_desc": "TensorFlow is an end-to-end open source platform for machine learning. An attacker can cause a heap buffer overflow in `tf.raw_ops.SparseSplit`. This is because the implementation(https://github.com/tensorflow/tensorflow/blob/699bff5d961f0abfde8fa3f876e6d241681fbef8/tensorflow/core/util/sparse/sparse_tensor.h#L528-L530) accesses an array element based on a user controlled offset. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.", "project": "tensorflow", "idx": 198557}
{"source": " file_continue(i_ctx_t *i_ctx_p)\n {\n     os_ptr op = osp;\n     es_ptr pscratch = esp - 2;\n     file_enum *pfen = r_ptr(esp - 1, file_enum);\n     int devlen = esp[-3].value.intval;\n     gx_io_device *iodev = r_ptr(esp - 4, gx_io_device);\n     uint len = r_size(pscratch);\n     uint code;\n \n     if (len < devlen)\n         return_error(gs_error_rangecheck);\n// bug_start\n    memcpy((char *)pscratch->value.bytes, iodev->dname, devlen);\n    code = iodev->procs.enumerate_next(pfen, (char *)pscratch->value.bytes + devlen,\n                len - devlen);\n    if (code == ~(uint) 0) {\n        esp -= 5;\n        return o_pop_estack;\n    } else if (code > len)\n        return_error(gs_error_rangecheck);\n    else {\n        push(1);\n        ref_assign(op, pscratch);\n        r_set_size(op, code + devlen);\n        push_op_estack(file_continue);\n        *++esp = pscratch[2];\n        return o_push_estack;\n    }\n// bug_end\n }\n \n", "target": "// fix_start\n\n    do {\n        memcpy((char *)pscratch->value.bytes, iodev->dname, devlen);\n        code = iodev->procs.enumerate_next(pfen, (char *)pscratch->value.bytes + devlen,\n                    len - devlen);\n        if (code == ~(uint) 0) {\n            esp -= 5;\n            return o_pop_estack;\n        } else if (code > len)\n            return_error(gs_error_rangecheck);\n        else if (iodev != iodev_default(imemory)\n              || (check_file_permissions_reduced(i_ctx_p, (char *)pscratch->value.bytes, code + devlen, \"PermitFileReading\")) == 0) {\n            push(1);\n            ref_assign(op, pscratch);\n            r_set_size(op, code + devlen);\n            push_op_estack(file_continue);\n            *++esp = pscratch[2];\n            return o_push_estack;\n        }\n    } while(1);\n// fix_end\n", "cwe": "CWE-200", "cwe_name": "Exposure of Sensitive Information to an Unauthorized Actor", "cve": "CVE-2013-5653", "cve_desc": "The getenv and filenameforall functions in Ghostscript 9.10 ignore the \"-dSAFER\" argument, which allows remote attackers to read data via a crafted postscript file.", "project": "ghostpdl", "idx": 198559}
{"source": " calculateNumTiles (int *numTiles,\n \t\t   int numLevels,\n \t\t   int min, int max,\n \t\t   int size,\n \t\t   LevelRoundingMode rmode)\n {\n     for (int i = 0; i < numLevels; i++)\n     {\n// bug_start\n        int l = levelSize (min, max, i, rmode);\n        if (l > std::numeric_limits<int>::max() - size + 1)\n            throw IEX_NAMESPACE::ArgExc (\"Invalid size.\");\n\n// bug_end\n         numTiles[i] = (l + size - 1) / size;\n     }\n }\n \n", "target": "// fix_start\n        Int64 l = levelSize (min, max, i, rmode);\n// fix_end\n", "cwe": "CWE-190", "cwe_name": "Integer Overflow or Wraparound", "cve": "CVE-2021-3475", "cve_desc": "There is a flaw in OpenEXR in versions before 3.0.0-beta. An attacker who can submit a crafted file to be processed by OpenEXR could cause an integer overflow, potentially leading to problems with application availability.", "project": "openexr", "idx": 198573}
{"source": " ins_comp_get_next_word_or_line(\n \tbuf_T\t*ins_buf,\n \tpos_T\t*cur_match_pos,\n \tint\t*match_len,\n \tint\t*cont_s_ipos)\n {\n     char_u\t*ptr;\n     int\t\tlen;\n \n     *match_len = 0;\n     ptr = ml_get_buf(ins_buf, cur_match_pos->lnum, FALSE) +\n \tcur_match_pos->col;\n     if (ctrl_x_mode_line_or_eval())\n     {\n \tif (compl_status_adding())\n \t{\n \t    if (cur_match_pos->lnum >= ins_buf->b_ml.ml_line_count)\n \t\treturn NULL;\n \t    ptr = ml_get_buf(ins_buf, cur_match_pos->lnum + 1, FALSE);\n \t    if (!p_paste)\n \t\tptr = skipwhite(ptr);\n \t}\n \tlen = (int)STRLEN(ptr);\n     }\n     else\n     {\n \tchar_u\t*tmp_ptr = ptr;\n \n// bug_start\n\tif (compl_status_adding())\n// bug_end\n \t{\n \t    tmp_ptr += compl_length;\n \t    if (vim_iswordp(tmp_ptr))\n \t\treturn NULL;\n \t    tmp_ptr = find_word_start(tmp_ptr);\n \t}\n \ttmp_ptr = find_word_end(tmp_ptr);\n \tlen = (int)(tmp_ptr - ptr);\n \n \tif (compl_status_adding() && len == compl_length)\n \t{\n \t    if (cur_match_pos->lnum < ins_buf->b_ml.ml_line_count)\n \t    {\n \t\tSTRNCPY(IObuff, ptr, len);\n \t\tptr = ml_get_buf(ins_buf, cur_match_pos->lnum + 1, FALSE);\n \t\ttmp_ptr = ptr = skipwhite(ptr);\n \t\ttmp_ptr = find_word_start(tmp_ptr);\n \t\ttmp_ptr = find_word_end(tmp_ptr);\n \t\tif (tmp_ptr > ptr)\n \t\t{\n \t\t    if (*ptr != ')' && IObuff[len - 1] != TAB)\n \t\t    {\n \t\t\tif (IObuff[len - 1] != ' ')\n \t\t\t    IObuff[len++] = ' ';\n \t\t\tif (p_js\n \t\t\t\t&& (IObuff[len - 2] == '.'\n \t\t\t\t    || (vim_strchr(p_cpo, CPO_JOINSP)\n \t\t\t\t\t== NULL\n \t\t\t\t\t&& (IObuff[len - 2] == '?'\n \t\t\t\t\t    || IObuff[len - 2] == '!'))))\n \t\t\t    IObuff[len++] = ' ';\n \t\t    }\n \t\t    if (tmp_ptr - ptr >= IOSIZE - len)\n \t\t\ttmp_ptr = ptr + IOSIZE - len - 1;\n \t\t    STRNCPY(IObuff + len, ptr, tmp_ptr - ptr);\n \t\t    len += (int)(tmp_ptr - ptr);\n \t\t    *cont_s_ipos = TRUE;\n \t\t}\n \t\tIObuff[len] = NUL;\n \t\tptr = IObuff;\n \t    }\n \t    if (len == compl_length)\n \t\treturn NULL;\n \t}\n     }\n \n     *match_len = len;\n     return ptr;\n }\n \n", "target": "// fix_start\n\tif (compl_status_adding() && compl_length <= (int)STRLEN(tmp_ptr))\n// fix_end\n", "cwe": "CWE-787", "cwe_name": "Out-of-bounds Write", "cve": "CVE-2022-2571", "cve_desc": "Heap-based Buffer Overflow in GitHub repository vim/vim prior to 9.0.0101.", "project": "vim", "idx": 198585}
{"source": " nosy_ioctl(struct file *file, unsigned int cmd, unsigned long arg)\n {\n \tstruct client *client = file->private_data;\n \tspinlock_t *client_list_lock = &client->lynx->client_list_lock;\n \tstruct nosy_stats stats;\n// bug_start\n// bug_end\n \n \tswitch (cmd) {\n \tcase NOSY_IOC_GET_STATS:\n \t\tspin_lock_irq(client_list_lock);\n \t\tstats.total_packet_count = client->buffer.total_packet_count;\n \t\tstats.lost_packet_count  = client->buffer.lost_packet_count;\n \t\tspin_unlock_irq(client_list_lock);\n \n \t\tif (copy_to_user((void __user *) arg, &stats, sizeof stats))\n \t\t\treturn -EFAULT;\n \t\telse\n \t\t\treturn 0;\n \n \tcase NOSY_IOC_START:\n// bug_start\n// bug_end\n \t\tspin_lock_irq(client_list_lock);\n// bug_start\n\t\tlist_add_tail(&client->link, &client->lynx->client_list);\n// bug_end\n \t\tspin_unlock_irq(client_list_lock);\n \n// bug_start\n\t\treturn 0;\n// bug_end\n \n \tcase NOSY_IOC_STOP:\n \t\tspin_lock_irq(client_list_lock);\n \t\tlist_del_init(&client->link);\n \t\tspin_unlock_irq(client_list_lock);\n \n \t\treturn 0;\n \n \tcase NOSY_IOC_FILTER:\n \t\tspin_lock_irq(client_list_lock);\n \t\tclient->tcode_mask = arg;\n \t\tspin_unlock_irq(client_list_lock);\n \n \t\treturn 0;\n \n \tdefault:\n \t\treturn -EINVAL;\n \t}\n }\n \n", "target": "// fix_start\n\tint ret;\n// fix_end\n// fix_start\n\t\tret = -EBUSY;\n// fix_end\n// fix_start\n\t\tif (list_empty(&client->link)) {\n\t\t\tlist_add_tail(&client->link, &client->lynx->client_list);\n\t\t\tret = 0;\n\t\t}\n// fix_end\n// fix_start\n\t\treturn ret;\n// fix_end\n", "cwe": "CWE-416", "cwe_name": "Use After Free", "cve": "CVE-2021-3483", "cve_desc": "A flaw was found in the Nosy driver in the Linux kernel. This issue allows a device to be inserted twice into a doubly-linked list, leading to a use-after-free when one of these devices is removed. The highest threat from this vulnerability is to confidentiality, integrity, as well as system availability. Versions before kernel 5.12-rc6 are affected", "project": "linux", "idx": 198639}
{"source": " bool ItemStackMetadata::setString(const std::string &name, const std::string &var)\n {\n// bug_start\n\tbool result = Metadata::setString(name, var);\n\tif (name == TOOLCAP_KEY)\n// bug_end\n \t\tupdateToolCapabilities();\n \treturn result;\n }\n \n", "target": "// fix_start\n\tstd::string clean_name = name;\n\tstd::string clean_var = var;\n\tsanitize_string(clean_name);\n\tsanitize_string(clean_var);\n\n\tbool result = Metadata::setString(clean_name, clean_var);\n\tif (clean_name == TOOLCAP_KEY)\n// fix_end\n", "cwe": "CWE-74", "cwe_name": "Improper Neutralization of Special Elements in Output Used by a Downstream Component ('Injection')", "cve": "CVE-2022-24300", "cve_desc": "Minetest before 5.4.0 allows attackers to add or modify arbitrary meta fields of the same item stack as saved user input, aka ItemStack meta injection.", "project": "minetest", "idx": 198663}
{"source": " static void unzzip_cat_file(ZZIP_DIR* disk, char* name, FILE* out)\n {\n     ZZIP_FILE* file = zzip_file_open (disk, name, 0);\n     if (file)\n     {\n \tchar buffer[1024]; int len;\n// bug_start\n\twhile ((len = zzip_file_read (file, buffer, 1024)))\n// bug_end\n \t{\n \t    fwrite (buffer, 1, len, out);\n \t}\n \n \tzzip_file_close (file);\n     }\n }\n \n", "target": "// fix_start\n\twhile (0 < (len = zzip_file_read (file, buffer, 1024)))\n// fix_end\n", "cwe": "CWE-835", "cwe_name": "Loop with Unreachable Exit Condition ('Infinite Loop')", "cve": "CVE-2020-18442", "cve_desc": "Infinite Loop in zziplib v0.13.69 allows remote attackers to cause a denial of service via the return value \"zzip_file_read\" in the function \"unzzip_cat_file\".", "project": "zziplib", "idx": 198733}
{"source": " static int dissect_dvb_s2_bb(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void *data _U_)\n {\n     proto_item *ti;\n     proto_tree *dvb_s2_bb_tree;\n \n     guint8      input8, matype1;\n     guint8      sync_flag = 0;\n     guint16     input16, bb_data_len = 0, user_packet_length;\n \n     int         sub_dissected        = 0, flag_is_ms = 0, new_off = 0;\n \n     static int * const bb_header_bitfields[] = {\n         &hf_dvb_s2_bb_matype1_gs,\n         &hf_dvb_s2_bb_matype1_mis,\n         &hf_dvb_s2_bb_matype1_acm,\n         &hf_dvb_s2_bb_matype1_issyi,\n         &hf_dvb_s2_bb_matype1_npd,\n         &hf_dvb_s2_bb_matype1_low_ro,\n         NULL\n     };\n \n     col_append_str(pinfo->cinfo, COL_PROTOCOL, \"BB \");\n     col_append_str(pinfo->cinfo, COL_INFO, \"Baseband \");\n \n     ti = proto_tree_add_item(tree, proto_dvb_s2_bb, tvb, 0, DVB_S2_BB_HEADER_LEN, ENC_NA);\n     dvb_s2_bb_tree = proto_item_add_subtree(ti, ett_dvb_s2_bb);\n \n     matype1 = tvb_get_guint8(tvb, DVB_S2_BB_OFFS_MATYPE1);\n     new_off += 1;\n \n     if (BIT_IS_CLEAR(matype1, DVB_S2_BB_MIS_POS))\n         flag_is_ms = 1;\n \n     proto_tree_add_bitmask_with_flags(dvb_s2_bb_tree, tvb, DVB_S2_BB_OFFS_MATYPE1, hf_dvb_s2_bb_matype1,\n         ett_dvb_s2_bb_matype1, bb_header_bitfields, ENC_BIG_ENDIAN, BMT_NO_FLAGS);\n \n     input8 = tvb_get_guint8(tvb, DVB_S2_BB_OFFS_MATYPE1);\n \n     if ((pinfo->fd->num == 1) && (_use_low_rolloff_value != 0)) {\n         _use_low_rolloff_value = 0;\n     }\n     if (((input8 & 0x03) == 3) && !_use_low_rolloff_value) {\n       _use_low_rolloff_value = 1;\n     }\n     if (_use_low_rolloff_value) {\n        proto_tree_add_item(dvb_s2_bb_tree, hf_dvb_s2_bb_matype1_low_ro, tvb,\n                            DVB_S2_BB_OFFS_MATYPE1, 1, ENC_BIG_ENDIAN);\n     } else {\n        proto_tree_add_item(dvb_s2_bb_tree, hf_dvb_s2_bb_matype1_high_ro, tvb,\n                            DVB_S2_BB_OFFS_MATYPE1, 1, ENC_BIG_ENDIAN);\n     }\n \n     input8 = tvb_get_guint8(tvb, DVB_S2_BB_OFFS_MATYPE2);\n     new_off += 1;\n     if (flag_is_ms) {\n         proto_tree_add_uint_format_value(dvb_s2_bb_tree, hf_dvb_s2_bb_matype2, tvb,\n                                    DVB_S2_BB_OFFS_MATYPE2, 1, input8, \"Input Stream Identifier (ISI): %d\",\n                                    input8);\n     } else {\n         proto_tree_add_uint_format_value(dvb_s2_bb_tree, hf_dvb_s2_bb_matype2, tvb,\n                                    DVB_S2_BB_OFFS_MATYPE2, 1, input8, \"reserved\");\n     }\n \n     user_packet_length = input16 = tvb_get_ntohs(tvb, DVB_S2_BB_OFFS_UPL);\n     new_off += 2;\n \n     proto_tree_add_uint_format(dvb_s2_bb_tree, hf_dvb_s2_bb_upl, tvb,\n                                DVB_S2_BB_OFFS_UPL, 2, input16, \"User Packet Length: %d bits (%d bytes)\",\n                                (guint16) input16, (guint16) input16 / 8);\n \n     bb_data_len = input16 = tvb_get_ntohs(tvb, DVB_S2_BB_OFFS_DFL);\n     bb_data_len /= 8;\n     new_off += 2;\n \n     proto_tree_add_uint_format_value(dvb_s2_bb_tree, hf_dvb_s2_bb_dfl, tvb,\n                                DVB_S2_BB_OFFS_DFL, 2, input16, \"%d bits (%d bytes)\", input16, input16 / 8);\n \n     new_off += 1;\n     sync_flag = tvb_get_guint8(tvb, DVB_S2_BB_OFFS_SYNC);\n     proto_tree_add_item(dvb_s2_bb_tree, hf_dvb_s2_bb_sync, tvb, DVB_S2_BB_OFFS_SYNC, 1, ENC_BIG_ENDIAN);\n \n     new_off += 2;\n     proto_tree_add_item(dvb_s2_bb_tree, hf_dvb_s2_bb_syncd, tvb, DVB_S2_BB_OFFS_SYNCD, 2, ENC_BIG_ENDIAN);\n \n     new_off += 1;\n     proto_tree_add_checksum(dvb_s2_bb_tree, tvb, DVB_S2_BB_OFFS_CRC, hf_dvb_s2_bb_crc, hf_dvb_s2_bb_crc_status, &ei_dvb_s2_bb_crc, pinfo,\n         compute_crc8(tvb, DVB_S2_BB_HEADER_LEN - 1, 0), ENC_NA, PROTO_CHECKSUM_VERIFY);\n \n     switch (matype1 & DVB_S2_BB_TSGS_MASK) {\n     case DVB_S2_BB_TSGS_GENERIC_CONTINUOUS:\n         if (BIT_IS_SET(matype1, DVB_S2_BB_ISSYI_POS)) {\n             expert_add_info(pinfo, ti, &ei_dvb_s2_bb_issy_invalid);\n         }\n         if (BIT_IS_SET(matype1, DVB_S2_BB_NPD_POS)) {\n             expert_add_info(pinfo, ti, &ei_dvb_s2_bb_npd_invalid);\n         }\n         if (user_packet_length != 0x0000) {\n             expert_add_info_format(pinfo, ti, &ei_dvb_s2_bb_upl_invalid,\n                 \"UPL is 0x%04x. It must be 0x0000 for GSE packets.\", user_packet_length);\n         }\n \n \n         if (dvb_s2_df_dissection) {\n             while (bb_data_len) {\n                 if (sync_flag == DVB_S2_BB_SYNC_EIP_CRC32 && bb_data_len == DVB_S2_BB_EIP_CRC32_LEN) {\n                     proto_tree_add_item(dvb_s2_bb_tree, hf_dvb_s2_bb_eip_crc32, tvb, new_off, bb_data_len, ENC_NA);\n                     bb_data_len = 0;\n                     new_off += DVB_S2_BB_EIP_CRC32_LEN;\n                 } else {\n                     sub_dissected = dissect_dvb_s2_gse(tvb_new_subset_length(tvb, new_off, bb_data_len), pinfo, tree, NULL);\n                     new_off += sub_dissected;\n \n                     if ((sub_dissected <= bb_data_len) && (sub_dissected >= DVB_S2_GSE_MINSIZE)) {\n                         bb_data_len -= sub_dissected;\n                         if (bb_data_len < DVB_S2_GSE_MINSIZE)\n                             bb_data_len = 0;\n// bug_start\n// bug_end\n                     }\n                 }\n             }\n         } else {\n             proto_tree_add_item(dvb_s2_bb_tree, hf_dvb_s2_bb_df, tvb, new_off, bb_data_len, ENC_NA);\n             new_off += bb_data_len;\n         }\n         break;\n \n     case DVB_S2_BB_TSGS_GENERIC_PACKETIZED:\n         proto_tree_add_item(tree, hf_dvb_s2_bb_packetized, tvb, new_off, bb_data_len, ENC_NA);\n         new_off += bb_data_len;\n         break;\n \n     case DVB_S2_BB_TSGS_TRANSPORT_STREAM:\n         proto_tree_add_item(tree, hf_dvb_s2_bb_transport, tvb, new_off, bb_data_len, ENC_NA);\n         new_off += bb_data_len;\n         break;\n \n     default:\n         proto_tree_add_item(tree, hf_dvb_s2_bb_reserved, tvb, new_off, bb_data_len, ENC_NA);\n         new_off += bb_data_len;\n         expert_add_info(pinfo, ti, &ei_dvb_s2_bb_reserved);\n         break;\n     }\n \n     return new_off;\n }\n \n", "target": "// fix_start\n                    } else {\n                        bb_data_len = 0;\n// fix_end\n", "cwe": "CWE-835", "cwe_name": "Loop with Unreachable Exit Condition ('Infinite Loop')", "cve": "CVE-2021-22222", "cve_desc": "Infinite loop in DVB-S2-BB dissector in Wireshark 3.4.0 to 3.4.5 allows denial of service via packet injection or crafted capture file", "project": "wireshark", "idx": 198763}
{"source": " static void set_error_response(h2_stream *stream, int http_status)\n {\n// bug_start\n    if (!h2_stream_is_ready(stream)) {\n// bug_end\n         stream->rtmp->http_status = http_status;\n     }\n }\n \n", "target": "// fix_start\n    if (!h2_stream_is_ready(stream) && stream->rtmp) {\n// fix_end\n", "cwe": "CWE-476", "cwe_name": "NULL Pointer Dereference", "cve": "CVE-2021-31618", "cve_desc": "Apache HTTP Server protocol handler for the HTTP/2 protocol checks received request headers against the size limitations as configured for the server and used for the HTTP/1 protocol as well. On violation of these restrictions and HTTP response is sent to the client with a status code indicating why the request was rejected. This rejection response was not fully initialised in the HTTP/2 protocol handler if the offending header was the very first one received or appeared in a a footer. This led to a NULL pointer dereference on initialised memory, crashing reliably the child process. Since such a triggering HTTP/2 request is easy to craft and submit, this can be exploited to DoS the server. This issue affected mod_http2 1.15.17 and Apache HTTP Server version 2.4.47 only. Apache HTTP Server 2.4.47 was never released.", "project": "httpd", "idx": 198837}
{"source": " parse_reg_exp (re_string_t *regexp, regex_t *preg, re_token_t *token,\n \t       reg_syntax_t syntax, Idx nest, reg_errcode_t *err)\n {\n   re_dfa_t *dfa = preg->buffer;\n   bin_tree_t *tree, *branch = NULL;\n// bug_start\n// bug_end\n   tree = parse_branch (regexp, preg, token, syntax, nest, err);\n   if (BE (*err != REG_NOERROR && tree == NULL, 0))\n     return NULL;\n \n   while (token->type == OP_ALT)\n     {\n       fetch_token (token, regexp, syntax | RE_CARET_ANCHORS_HERE);\n       if (token->type != OP_ALT && token->type != END_OF_RE\n \t  && (nest == 0 || token->type != OP_CLOSE_SUBEXP))\n \t{\n// bug_start\n// bug_end\n \t  branch = parse_branch (regexp, preg, token, syntax, nest, err);\n \t  if (BE (*err != REG_NOERROR && branch == NULL, 0))\n \t    {\n \t      if (tree != NULL)\n \t\tpostorder (tree, free_tree, NULL);\n \t      return NULL;\n \t    }\n// bug_start\n// bug_end\n \t}\n       else\n \tbranch = NULL;\n       tree = create_tree (dfa, tree, branch, OP_ALT);\n       if (BE (tree == NULL, 0))\n \t{\n \t  *err = REG_ESPACE;\n \t  return NULL;\n \t}\n     }\n   return tree;\n }\n \n", "target": "// fix_start\n  bitset_word_t initial_bkref_map = dfa->completed_bkref_map;\n// fix_end\n// fix_start\n\t  bitset_word_t accumulated_bkref_map = dfa->completed_bkref_map;\n\t  dfa->completed_bkref_map = initial_bkref_map;\n// fix_end\n// fix_start\n\t  dfa->completed_bkref_map |= accumulated_bkref_map;\n// fix_end\n", "cwe": "CWE-19", "cwe_name": "Data Handling", "cve": "CVE-2009-5155", "cve_desc": "In the GNU C Library (aka glibc or libc6) before 2.28, parse_reg_exp in posix/regcomp.c misparses alternatives, which allows attackers to cause a denial of service (assertion failure and application exit) or trigger an incorrect result by attempting a regular-expression match.", "project": "gnulib", "idx": 198942}
{"source": " xmlDocPtr soap_xmlParseFile(const char *filename TSRMLS_DC)\n {\n \txmlParserCtxtPtr ctxt = NULL;\n \txmlDocPtr ret;\n \tzend_bool old_allow_url_fopen;\n \n \n \told_allow_url_fopen = PG(allow_url_fopen);\n \tPG(allow_url_fopen) = 1;\n \tctxt = xmlCreateFileParserCtxt(filename);\n \tPG(allow_url_fopen) = old_allow_url_fopen;\n \tif (ctxt) {\n \t\tzend_bool old;\n \n \t\tctxt->keepBlanks = 0;\n \t\tctxt->sax->ignorableWhitespace = soap_ignorableWhitespace;\n \t\tctxt->sax->comment = soap_Comment;\n \t\tctxt->sax->warning = NULL;\n \t\tctxt->sax->error = NULL;\n// bug_start\n\t\told = php_libxml_disable_entity_loader(1);\n// bug_end\n \t\txmlParseDocument(ctxt);\n// bug_start\n\t\tphp_libxml_disable_entity_loader(old);\n// bug_end\n \t\tif (ctxt->wellFormed) {\n \t\t\tret = ctxt->myDoc;\n \t\t\tif (ret->URL == NULL && ctxt->directory != NULL) {\n \t\t\t\tret->URL = xmlCharStrdup(ctxt->directory);\n \t\t\t}\n \t\t} else {\n \t\t\tret = NULL;\n \t\t\txmlFreeDoc(ctxt->myDoc);\n \t\t\tctxt->myDoc = NULL;\n \t\t}\n \t\txmlFreeParserCtxt(ctxt);\n \t} else {\n \t\tret = NULL;\n \t}\n \n \n \tif (ret) {\n \t\tcleanup_xml_node((xmlNodePtr)ret);\n \t}\n \treturn ret;\n }\n \n", "target": "// fix_start\n\t\told = php_libxml_disable_entity_loader(1 TSRMLS_CC);\n// fix_end\n// fix_start\n\t\tphp_libxml_disable_entity_loader(old TSRMLS_CC);\n// fix_end\n", "cwe": "CWE-200", "cwe_name": "Exposure of Sensitive Information to an Unauthorized Actor", "cve": "CVE-2013-1643", "cve_desc": "The SOAP parser in PHP before 5.3.23 and 5.4.x before 5.4.13 allows remote attackers to read arbitrary files via a SOAP WSDL file containing an XML external entity declaration in conjunction with an entity reference, related to an XML External Entity (XXE) issue in the soap_xmlParseFile and soap_xmlParseMemory functions.  NOTE: this vulnerability exists because of an incorrect fix for CVE-2013-1824.", "project": "php-src", "idx": 198943}
{"source": " xmlDocPtr soap_xmlParseMemory(const void *buf, size_t buf_size)\n {\n \txmlParserCtxtPtr ctxt = NULL;\n \txmlDocPtr ret;\n// bug_start\n// bug_end\n \n \tctxt = xmlCreateMemoryParserCtxt(buf, buf_size);\n \tif (ctxt) {\n \t\tzend_bool old;\n \n \t\tctxt->sax->ignorableWhitespace = soap_ignorableWhitespace;\n \t\tctxt->sax->comment = soap_Comment;\n \t\tctxt->sax->warning = NULL;\n \t\tctxt->sax->error = NULL;\n #if LIBXML_VERSION >= 20703\n \t\tctxt->options |= XML_PARSE_HUGE;\n #endif\n// bug_start\n\t\told = php_libxml_disable_entity_loader(1);\n// bug_end\n \t\txmlParseDocument(ctxt);\n// bug_start\n\t\tphp_libxml_disable_entity_loader(old);\n// bug_end\n \t\tif (ctxt->wellFormed) {\n \t\t\tret = ctxt->myDoc;\n \t\t\tif (ret->URL == NULL && ctxt->directory != NULL) {\n \t\t\t\tret->URL = xmlCharStrdup(ctxt->directory);\n \t\t\t}\n \t\t} else {\n \t\t\tret = NULL;\n \t\t\txmlFreeDoc(ctxt->myDoc);\n \t\t\tctxt->myDoc = NULL;\n \t\t}\n \t\txmlFreeParserCtxt(ctxt);\n \t} else {\n \t\tret = NULL;\n \t}\n \n \n \treturn ret;\n }\n \n", "target": "// fix_start\n\n\tTSRMLS_FETCH();\n// fix_end\n// fix_start\n\t\told = php_libxml_disable_entity_loader(1 TSRMLS_CC);\n// fix_end\n// fix_start\n\t\tphp_libxml_disable_entity_loader(old TSRMLS_CC);\n// fix_end\n", "cwe": "CWE-200", "cwe_name": "Exposure of Sensitive Information to an Unauthorized Actor", "cve": "CVE-2013-1643", "cve_desc": "The SOAP parser in PHP before 5.3.23 and 5.4.x before 5.4.13 allows remote attackers to read arbitrary files via a SOAP WSDL file containing an XML external entity declaration in conjunction with an entity reference, related to an XML External Entity (XXE) issue in the soap_xmlParseFile and soap_xmlParseMemory functions.  NOTE: this vulnerability exists because of an incorrect fix for CVE-2013-1824.", "project": "php-src", "idx": 198944}
{"source": " size_t intsetBlobLen(intset *is) {\n// bug_start\n    return sizeof(intset)+intrev32ifbe(is->length)*intrev32ifbe(is->encoding);\n// bug_end\n }\n \n", "target": "// fix_start\n    return sizeof(intset)+(size_t)intrev32ifbe(is->length)*intrev32ifbe(is->encoding);\n// fix_end\n", "cwe": "CWE-190", "cwe_name": "Integer Overflow or Wraparound", "cve": "CVE-2021-29478", "cve_desc": "Redis is an open source (BSD licensed), in-memory data structure store, used as a database, cache, and message broker. An integer overflow bug in Redis 6.2 before 6.2.3 could be exploited to corrupt the heap and potentially result with remote code execution. Redis 6.0 and earlier are not directly affected by this issue. The problem is fixed in version 6.2.3. An additional workaround to mitigate the problem without patching the `redis-server` executable is to prevent users from modifying the `set-max-intset-entries` configuration parameter. This can be done using ACL to restrict unprivileged users from using the `CONFIG SET` command.", "project": "redis", "idx": 199227}
{"source": " static int php_openssl_validate_iv(char **piv, size_t *piv_len, size_t iv_required_len,\n \t\tzend_bool *free_iv, EVP_CIPHER_CTX *cipher_ctx, struct php_openssl_cipher_mode *mode)\n {\n \tchar *iv_new;\n// bug_start\n\n\tif (*piv_len == iv_required_len) {\n\t\treturn SUCCESS;\n\t}\n// bug_end\n \n \tif (mode->is_aead) {\n \t\tif (EVP_CIPHER_CTX_ctrl(cipher_ctx, mode->aead_ivlen_flag, *piv_len, NULL) != 1) {\n \t\t\tphp_error_docref(NULL, E_WARNING, \"Setting of IV length for AEAD mode failed\");\n \t\t\treturn FAILURE;\n \t\t}\n// bug_start\n// bug_end\n \t\treturn SUCCESS;\n \t}\n \n \tiv_new = ecalloc(1, iv_required_len + 1);\n \n \tif (*piv_len == 0) {\n \t\t*piv_len = iv_required_len;\n \t\t*piv = iv_new;\n \t\t*free_iv = 1;\n \t\treturn SUCCESS;\n \n \t}\n \n \tif (*piv_len < iv_required_len) {\n \t\tphp_error_docref(NULL, E_WARNING,\n \t\t\t\t\"IV passed is only %zd bytes long, cipher expects an IV of precisely %zd bytes, padding with \\\\0\",\n \t\t\t\t*piv_len, iv_required_len);\n \t\tmemcpy(iv_new, *piv, *piv_len);\n \t\t*piv_len = iv_required_len;\n \t\t*piv = iv_new;\n \t\t*free_iv = 1;\n \t\treturn SUCCESS;\n \t}\n \n \tphp_error_docref(NULL, E_WARNING,\n \t\t\t\"IV passed is %zd bytes long which is longer than the %zd expected by selected cipher, truncating\",\n \t\t\t*piv_len, iv_required_len);\n \tmemcpy(iv_new, *piv, iv_required_len);\n \t*piv_len = iv_required_len;\n \t*piv = iv_new;\n \t*free_iv = 1;\n \treturn SUCCESS;\n \n }\n \n", "target": "// fix_start\n// fix_end\n// fix_start\n\t\treturn SUCCESS;\n\t}\n\n\tif (*piv_len == iv_required_len) {\n// fix_end\n", "cwe": "CWE-326", "cwe_name": "Inadequate Encryption Strength", "cve": "CVE-2020-7069", "cve_desc": "In PHP versions 7.2.x below 7.2.34, 7.3.x below 7.3.23 and 7.4.x below 7.4.11, when AES-CCM mode is used with openssl_encrypt() function with 12 bytes IV, only first 7 bytes of the IV is actually used. This can lead to both decreased security and incorrect encryption data.", "project": "php-src", "idx": 199700}
{"source": " static __latent_entropy struct task_struct *copy_process(\n \t\t\t\t\tstruct pid *pid,\n \t\t\t\t\tint trace,\n \t\t\t\t\tint node,\n \t\t\t\t\tstruct kernel_clone_args *args)\n {\n \tint pidfd = -1, retval;\n \tstruct task_struct *p;\n \tstruct multiprocess_signals delayed;\n \tstruct file *pidfile = NULL;\n \tu64 clone_flags = args->flags;\n \tstruct nsproxy *nsp = current->nsproxy;\n \n \tif ((clone_flags & (CLONE_NEWNS|CLONE_FS)) == (CLONE_NEWNS|CLONE_FS))\n \t\treturn ERR_PTR(-EINVAL);\n \n \tif ((clone_flags & (CLONE_NEWUSER|CLONE_FS)) == (CLONE_NEWUSER|CLONE_FS))\n \t\treturn ERR_PTR(-EINVAL);\n \n \tif ((clone_flags & CLONE_THREAD) && !(clone_flags & CLONE_SIGHAND))\n \t\treturn ERR_PTR(-EINVAL);\n \n \tif ((clone_flags & CLONE_SIGHAND) && !(clone_flags & CLONE_VM))\n \t\treturn ERR_PTR(-EINVAL);\n \n \tif ((clone_flags & CLONE_PARENT) &&\n \t\t\t\tcurrent->signal->flags & SIGNAL_UNKILLABLE)\n \t\treturn ERR_PTR(-EINVAL);\n \n \tif (clone_flags & CLONE_THREAD) {\n \t\tif ((clone_flags & (CLONE_NEWUSER | CLONE_NEWPID)) ||\n \t\t    (task_active_pid_ns(current) != nsp->pid_ns_for_children))\n \t\t\treturn ERR_PTR(-EINVAL);\n \t}\n \n \tif (clone_flags & (CLONE_THREAD | CLONE_VM)) {\n \t\tif (nsp->time_ns != nsp->time_ns_for_children)\n \t\t\treturn ERR_PTR(-EINVAL);\n \t}\n \n \tif (clone_flags & CLONE_PIDFD) {\n \t\tif (clone_flags & (CLONE_DETACHED | CLONE_THREAD))\n \t\t\treturn ERR_PTR(-EINVAL);\n \t}\n \n \tsigemptyset(&delayed.signal);\n \tINIT_HLIST_NODE(&delayed.node);\n \n \tspin_lock_irq(&current->sighand->siglock);\n \tif (!(clone_flags & CLONE_THREAD))\n \t\thlist_add_head(&delayed.node, &current->signal->multiprocess);\n \trecalc_sigpending();\n \tspin_unlock_irq(&current->sighand->siglock);\n \tretval = -ERESTARTNOINTR;\n \tif (signal_pending(current))\n \t\tgoto fork_out;\n \n \tretval = -ENOMEM;\n \tp = dup_task_struct(current, node);\n \tif (!p)\n \t\tgoto fork_out;\n \n \tp->set_child_tid = (clone_flags & CLONE_CHILD_SETTID) ? args->child_tid : NULL;\n \tp->clear_child_tid = (clone_flags & CLONE_CHILD_CLEARTID) ? args->child_tid : NULL;\n \n \tftrace_graph_init_task(p);\n \n \trt_mutex_init_task(p);\n \n \tlockdep_assert_irqs_enabled();\n #ifdef CONFIG_PROVE_LOCKING\n \tDEBUG_LOCKS_WARN_ON(!p->softirqs_enabled);\n #endif\n \tretval = -EAGAIN;\n \tif (atomic_read(&p->real_cred->user->processes) >=\n \t\t\ttask_rlimit(p, RLIMIT_NPROC)) {\n \t\tif (p->real_cred->user != INIT_USER &&\n \t\t    !capable(CAP_SYS_RESOURCE) && !capable(CAP_SYS_ADMIN))\n \t\t\tgoto bad_fork_free;\n \t}\n \tcurrent->flags &= ~PF_NPROC_EXCEEDED;\n \n \tretval = copy_creds(p, clone_flags);\n \tif (retval < 0)\n \t\tgoto bad_fork_free;\n \n \tretval = -EAGAIN;\n \tif (data_race(nr_threads >= max_threads))\n \t\tgoto bad_fork_cleanup_count;\n \n \tdelayacct_tsk_init(p);\n \tp->flags &= ~(PF_SUPERPRIV | PF_WQ_WORKER | PF_IDLE);\n \tp->flags |= PF_FORKNOEXEC;\n \tINIT_LIST_HEAD(&p->children);\n \tINIT_LIST_HEAD(&p->sibling);\n \trcu_copy_process(p);\n \tp->vfork_done = NULL;\n \tspin_lock_init(&p->alloc_lock);\n \n \tinit_sigpending(&p->pending);\n \n \tp->utime = p->stime = p->gtime = 0;\n #ifdef CONFIG_ARCH_HAS_SCALED_CPUTIME\n \tp->utimescaled = p->stimescaled = 0;\n #endif\n \tprev_cputime_init(&p->prev_cputime);\n \n #ifdef CONFIG_VIRT_CPU_ACCOUNTING_GEN\n \tseqcount_init(&p->vtime.seqcount);\n \tp->vtime.starttime = 0;\n \tp->vtime.state = VTIME_INACTIVE;\n #endif\n \n #ifdef CONFIG_IO_URING\n \tp->io_uring = NULL;\n #endif\n \n #if defined(SPLIT_RSS_COUNTING)\n \tmemset(&p->rss_stat, 0, sizeof(p->rss_stat));\n #endif\n \n \tp->default_timer_slack_ns = current->timer_slack_ns;\n \n #ifdef CONFIG_PSI\n \tp->psi_flags = 0;\n #endif\n \n \ttask_io_accounting_init(&p->ioac);\n \tacct_clear_integrals(p);\n \n \tposix_cputimers_init(&p->posix_cputimers);\n \n \tp->io_context = NULL;\n \taudit_set_context(p, NULL);\n \tcgroup_fork(p);\n #ifdef CONFIG_NUMA\n \tp->mempolicy = mpol_dup(p->mempolicy);\n \tif (IS_ERR(p->mempolicy)) {\n \t\tretval = PTR_ERR(p->mempolicy);\n \t\tp->mempolicy = NULL;\n \t\tgoto bad_fork_cleanup_threadgroup_lock;\n \t}\n #endif\n #ifdef CONFIG_CPUSETS\n \tp->cpuset_mem_spread_rotor = NUMA_NO_NODE;\n \tp->cpuset_slab_spread_rotor = NUMA_NO_NODE;\n \tseqcount_spinlock_init(&p->mems_allowed_seq, &p->alloc_lock);\n #endif\n #ifdef CONFIG_TRACE_IRQFLAGS\n \tmemset(&p->irqtrace, 0, sizeof(p->irqtrace));\n \tp->irqtrace.hardirq_disable_ip\t= _THIS_IP_;\n \tp->irqtrace.softirq_enable_ip\t= _THIS_IP_;\n \tp->softirqs_enabled\t\t= 1;\n \tp->softirq_context\t\t= 0;\n #endif\n \n \tp->pagefault_disabled = 0;\n \n #ifdef CONFIG_LOCKDEP\n \tlockdep_init_task(p);\n #endif\n \n #ifdef CONFIG_DEBUG_MUTEXES\n \tp->blocked_on = NULL;\n #endif\n #ifdef CONFIG_BCACHE\n \tp->sequential_io\t= 0;\n \tp->sequential_io_avg\t= 0;\n #endif\n \n \tretval = sched_fork(clone_flags, p);\n \tif (retval)\n \t\tgoto bad_fork_cleanup_policy;\n \n \tretval = perf_event_init_task(p);\n \tif (retval)\n \t\tgoto bad_fork_cleanup_policy;\n \tretval = audit_alloc(p);\n \tif (retval)\n \t\tgoto bad_fork_cleanup_perf;\n \tshm_init_task(p);\n \tretval = security_task_alloc(p, clone_flags);\n \tif (retval)\n \t\tgoto bad_fork_cleanup_audit;\n \tretval = copy_semundo(clone_flags, p);\n \tif (retval)\n \t\tgoto bad_fork_cleanup_security;\n \tretval = copy_files(clone_flags, p);\n \tif (retval)\n \t\tgoto bad_fork_cleanup_semundo;\n \tretval = copy_fs(clone_flags, p);\n \tif (retval)\n \t\tgoto bad_fork_cleanup_files;\n \tretval = copy_sighand(clone_flags, p);\n \tif (retval)\n \t\tgoto bad_fork_cleanup_fs;\n \tretval = copy_signal(clone_flags, p);\n \tif (retval)\n \t\tgoto bad_fork_cleanup_sighand;\n \tretval = copy_mm(clone_flags, p);\n \tif (retval)\n \t\tgoto bad_fork_cleanup_signal;\n \tretval = copy_namespaces(clone_flags, p);\n \tif (retval)\n \t\tgoto bad_fork_cleanup_mm;\n \tretval = copy_io(clone_flags, p);\n \tif (retval)\n \t\tgoto bad_fork_cleanup_namespaces;\n \tretval = copy_thread(clone_flags, args->stack, args->stack_size, p, args->tls);\n \tif (retval)\n \t\tgoto bad_fork_cleanup_io;\n \n \tstackleak_task_init(p);\n \n \tif (pid != &init_struct_pid) {\n \t\tpid = alloc_pid(p->nsproxy->pid_ns_for_children, args->set_tid,\n \t\t\t\targs->set_tid_size);\n \t\tif (IS_ERR(pid)) {\n \t\t\tretval = PTR_ERR(pid);\n \t\t\tgoto bad_fork_cleanup_thread;\n \t\t}\n \t}\n \n \tif (clone_flags & CLONE_PIDFD) {\n \t\tretval = get_unused_fd_flags(O_RDWR | O_CLOEXEC);\n \t\tif (retval < 0)\n \t\t\tgoto bad_fork_free_pid;\n \n \t\tpidfd = retval;\n \n \t\tpidfile = anon_inode_getfile(\"[pidfd]\", &pidfd_fops, pid,\n \t\t\t\t\t      O_RDWR | O_CLOEXEC);\n \t\tif (IS_ERR(pidfile)) {\n \t\t\tput_unused_fd(pidfd);\n \t\t\tretval = PTR_ERR(pidfile);\n \t\t\tgoto bad_fork_free_pid;\n \t\t}\n \t\tget_pid(pid);\n \n \t\tretval = put_user(pidfd, args->pidfd);\n \t\tif (retval)\n \t\t\tgoto bad_fork_put_pidfd;\n \t}\n \n #ifdef CONFIG_BLOCK\n \tp->plug = NULL;\n #endif\n \tfutex_init_task(p);\n \n \tif ((clone_flags & (CLONE_VM|CLONE_VFORK)) == CLONE_VM)\n \t\tsas_ss_reset(p);\n \n \tuser_disable_single_step(p);\n \tclear_tsk_thread_flag(p, TIF_SYSCALL_TRACE);\n #ifdef TIF_SYSCALL_EMU\n \tclear_tsk_thread_flag(p, TIF_SYSCALL_EMU);\n #endif\n \tclear_tsk_latency_tracing(p);\n \n \tp->pid = pid_nr(pid);\n \tif (clone_flags & CLONE_THREAD) {\n// bug_start\n\t\tp->exit_signal = -1;\n// bug_end\n \t\tp->group_leader = current->group_leader;\n \t\tp->tgid = current->tgid;\n \t} else {\n// bug_start\n\t\tif (clone_flags & CLONE_PARENT)\n\t\t\tp->exit_signal = current->group_leader->exit_signal;\n\t\telse\n\t\t\tp->exit_signal = args->exit_signal;\n// bug_end\n \t\tp->group_leader = p;\n \t\tp->tgid = p->pid;\n \t}\n \n \tp->nr_dirtied = 0;\n \tp->nr_dirtied_pause = 128 >> (PAGE_SHIFT - 10);\n \tp->dirty_paused_when = 0;\n \n \tp->pdeath_signal = 0;\n \tINIT_LIST_HEAD(&p->thread_group);\n \tp->task_works = NULL;\n \n \tretval = cgroup_can_fork(p, args);\n \tif (retval)\n \t\tgoto bad_fork_put_pidfd;\n \n \n \tp->start_time = ktime_get_ns();\n \tp->start_boottime = ktime_get_boottime_ns();\n \n \twrite_lock_irq(&tasklist_lock);\n \n \tif (clone_flags & (CLONE_PARENT|CLONE_THREAD)) {\n \t\tp->real_parent = current->real_parent;\n \t\tp->parent_exec_id = current->parent_exec_id;\n// bug_start\n// bug_end\n \t} else {\n \t\tp->real_parent = current;\n \t\tp->parent_exec_id = current->self_exec_id;\n// bug_start\n// bug_end\n \t}\n \n \tklp_copy_process(p);\n \n \tspin_lock(&current->sighand->siglock);\n \n \tcopy_seccomp(p);\n \n \trseq_fork(p, clone_flags);\n \n \tif (unlikely(!(ns_of_pid(pid)->pid_allocated & PIDNS_ADDING))) {\n \t\tretval = -ENOMEM;\n \t\tgoto bad_fork_cancel_cgroup;\n \t}\n \n \tif (fatal_signal_pending(current)) {\n \t\tretval = -EINTR;\n \t\tgoto bad_fork_cancel_cgroup;\n \t}\n \n \tif (pidfile)\n \t\tfd_install(pidfd, pidfile);\n \n \tinit_task_pid_links(p);\n \tif (likely(p->pid)) {\n \t\tptrace_init_task(p, (clone_flags & CLONE_PTRACE) || trace);\n \n \t\tinit_task_pid(p, PIDTYPE_PID, pid);\n \t\tif (thread_group_leader(p)) {\n \t\t\tinit_task_pid(p, PIDTYPE_TGID, pid);\n \t\t\tinit_task_pid(p, PIDTYPE_PGID, task_pgrp(current));\n \t\t\tinit_task_pid(p, PIDTYPE_SID, task_session(current));\n \n \t\t\tif (is_child_reaper(pid)) {\n \t\t\t\tns_of_pid(pid)->child_reaper = p;\n \t\t\t\tp->signal->flags |= SIGNAL_UNKILLABLE;\n \t\t\t}\n \t\t\tp->signal->shared_pending.signal = delayed.signal;\n \t\t\tp->signal->tty = tty_kref_get(current->signal->tty);\n \t\t\tp->signal->has_child_subreaper = p->real_parent->signal->has_child_subreaper ||\n \t\t\t\t\t\t\t p->real_parent->signal->is_child_subreaper;\n \t\t\tlist_add_tail(&p->sibling, &p->real_parent->children);\n \t\t\tlist_add_tail_rcu(&p->tasks, &init_task.tasks);\n \t\t\tattach_pid(p, PIDTYPE_TGID);\n \t\t\tattach_pid(p, PIDTYPE_PGID);\n \t\t\tattach_pid(p, PIDTYPE_SID);\n \t\t\t__this_cpu_inc(process_counts);\n \t\t} else {\n \t\t\tcurrent->signal->nr_threads++;\n \t\t\tatomic_inc(&current->signal->live);\n \t\t\trefcount_inc(&current->signal->sigcnt);\n \t\t\ttask_join_group_stop(p);\n \t\t\tlist_add_tail_rcu(&p->thread_group,\n \t\t\t\t\t  &p->group_leader->thread_group);\n \t\t\tlist_add_tail_rcu(&p->thread_node,\n \t\t\t\t\t  &p->signal->thread_head);\n \t\t}\n \t\tattach_pid(p, PIDTYPE_PID);\n \t\tnr_threads++;\n \t}\n \ttotal_forks++;\n \thlist_del_init(&delayed.node);\n \tspin_unlock(&current->sighand->siglock);\n \tsyscall_tracepoint_update(p);\n \twrite_unlock_irq(&tasklist_lock);\n \n \tproc_fork_connector(p);\n \tsched_post_fork(p);\n \tcgroup_post_fork(p, args);\n \tperf_event_fork(p);\n \n \ttrace_task_newtask(p, clone_flags);\n \tuprobe_copy_process(p, clone_flags);\n \n \tcopy_oom_score_adj(clone_flags, p);\n \n \treturn p;\n \n bad_fork_cancel_cgroup:\n \tspin_unlock(&current->sighand->siglock);\n \twrite_unlock_irq(&tasklist_lock);\n \tcgroup_cancel_fork(p, args);\n bad_fork_put_pidfd:\n \tif (clone_flags & CLONE_PIDFD) {\n \t\tfput(pidfile);\n \t\tput_unused_fd(pidfd);\n \t}\n bad_fork_free_pid:\n \tif (pid != &init_struct_pid)\n \t\tfree_pid(pid);\n bad_fork_cleanup_thread:\n \texit_thread(p);\n bad_fork_cleanup_io:\n \tif (p->io_context)\n \t\texit_io_context(p);\n bad_fork_cleanup_namespaces:\n \texit_task_namespaces(p);\n bad_fork_cleanup_mm:\n \tif (p->mm) {\n \t\tmm_clear_owner(p->mm, p);\n \t\tmmput(p->mm);\n \t}\n bad_fork_cleanup_signal:\n \tif (!(clone_flags & CLONE_THREAD))\n \t\tfree_signal_struct(p->signal);\n bad_fork_cleanup_sighand:\n \t__cleanup_sighand(p->sighand);\n bad_fork_cleanup_fs:\n \texit_fs(p);\n bad_fork_cleanup_files:\n \texit_files(p);\n bad_fork_cleanup_semundo:\n \texit_sem(p);\n bad_fork_cleanup_security:\n \tsecurity_task_free(p);\n bad_fork_cleanup_audit:\n \taudit_free(p);\n bad_fork_cleanup_perf:\n \tperf_event_free_task(p);\n bad_fork_cleanup_policy:\n \tlockdep_free_task(p);\n #ifdef CONFIG_NUMA\n \tmpol_put(p->mempolicy);\n bad_fork_cleanup_threadgroup_lock:\n #endif\n \tdelayacct_tsk_free(p);\n bad_fork_cleanup_count:\n \tatomic_dec(&p->cred->user->processes);\n \texit_creds(p);\n bad_fork_free:\n \tp->state = TASK_DEAD;\n \tput_task_stack(p);\n \tdelayed_free_task(p);\n fork_out:\n \tspin_lock_irq(&current->sighand->siglock);\n \thlist_del_init(&delayed.node);\n \tspin_unlock_irq(&current->sighand->siglock);\n \treturn ERR_PTR(retval);\n }\n \n", "target": "// fix_start\n// fix_end\n// fix_start\n// fix_end\n// fix_start\n\t\tif (clone_flags & CLONE_THREAD)\n\t\t\tp->exit_signal = -1;\n\t\telse\n\t\t\tp->exit_signal = current->group_leader->exit_signal;\n// fix_end\n// fix_start\n\t\tp->exit_signal = args->exit_signal;\n// fix_end\n", "cwe": "CWE-665", "cwe_name": "Improper Initialization", "cve": "CVE-2020-35508", "cve_desc": "A flaw possibility of race condition and incorrect initialization of the process id was found in the Linux kernel child/parent process identification handling while filtering signal handlers. A local attacker is able to abuse this flaw to bypass checks to send any signal to a privileged process.", "project": "linux", "idx": 199840}
{"source": " UINT rdpgfx_read_rect16(wStream* s, RECTANGLE_16* rect16)\n {\n \tif (Stream_GetRemainingLength(s) < 8)\n \t{\n \t\tWLog_ERR(TAG, \"not enough data!\");\n \t\treturn ERROR_INVALID_DATA;\n \t}\n \n \tStream_Read_UINT16(s, rect16->left);\n \tStream_Read_UINT16(s, rect16->top);\n \tStream_Read_UINT16(s, rect16->right);\n \tStream_Read_UINT16(s, rect16->bottom);\n// bug_start\n// bug_end\n \treturn CHANNEL_RC_OK;\n }\n \n", "target": "// fix_start\n\tif (rect16->left >= rect16->right)\n\t\treturn ERROR_INVALID_DATA;\n\tif (rect16->top >= rect16->bottom)\n\t\treturn ERROR_INVALID_DATA;\n// fix_end\n", "cwe": "CWE-190", "cwe_name": "Integer Overflow or Wraparound", "cve": "CVE-2020-15103", "cve_desc": "In FreeRDP less than or equal to 2.1.2, an integer overflow exists due to missing input sanitation in rdpegfx channel. All FreeRDP clients are affected. The input rectangles from the server are not checked against local surface coordinates and blindly accepted. A malicious server can send data that will crash the client later on (invalid length arguments to a `memcpy`) This has been fixed in 2.2.0. As a workaround, stop using command line arguments /gfx, /gfx-h264 and /network:auto", "project": "FreeRDP", "idx": 199860}
{"source": " BOOL update_recv(rdpUpdate* update, wStream* s)\n {\n \tBOOL rc = FALSE;\n \tUINT16 updateType;\n \trdpContext* context = update->context;\n \n \tif (Stream_GetRemainingLength(s) < 2)\n \t{\n \t\tWLog_ERR(TAG, \"Stream_GetRemainingLength(s) < 2\");\n \t\treturn FALSE;\n \t}\n \n \tStream_Read_UINT16(s, updateType);\n// bug_start\n\tWLog_Print(update->log, WLOG_TRACE, \"%s Update Data PDU\", UPDATE_TYPE_STRINGS[updateType]);\n// bug_end\n \n \tif (!update_begin_paint(update))\n \t\tgoto fail;\n \n \tswitch (updateType)\n \t{\n \t\tcase UPDATE_TYPE_ORDERS:\n \t\t\trc = update_recv_orders(update, s);\n \t\t\tbreak;\n \n \t\tcase UPDATE_TYPE_BITMAP:\n \t\t{\n \t\t\tBITMAP_UPDATE* bitmap_update = update_read_bitmap_update(update, s);\n \n \t\t\tif (!bitmap_update)\n \t\t\t{\n \t\t\t\tWLog_ERR(TAG, \"UPDATE_TYPE_BITMAP - update_read_bitmap_update() failed\");\n \t\t\t\tgoto fail;\n \t\t\t}\n \n \t\t\trc = IFCALLRESULT(FALSE, update->BitmapUpdate, context, bitmap_update);\n \t\t\tfree_bitmap_update(update->context, bitmap_update);\n \t\t}\n \t\tbreak;\n \n \t\tcase UPDATE_TYPE_PALETTE:\n \t\t{\n \t\t\tPALETTE_UPDATE* palette_update = update_read_palette(update, s);\n \n \t\t\tif (!palette_update)\n \t\t\t{\n \t\t\t\tWLog_ERR(TAG, \"UPDATE_TYPE_PALETTE - update_read_palette() failed\");\n \t\t\t\tgoto fail;\n \t\t\t}\n \n \t\t\trc = IFCALLRESULT(FALSE, update->Palette, context, palette_update);\n \t\t\tfree_palette_update(context, palette_update);\n \t\t}\n \t\tbreak;\n \n \t\tcase UPDATE_TYPE_SYNCHRONIZE:\n \t\t\tif (!update_read_synchronize(update, s))\n \t\t\t\tgoto fail;\n \t\t\trc = IFCALLRESULT(TRUE, update->Synchronize, context);\n \t\t\tbreak;\n \n \t\tdefault:\n \t\t\tbreak;\n \t}\n \n fail:\n \n \tif (!update_end_paint(update))\n \t\trc = FALSE;\n \n \tif (!rc)\n \t{\n \t\tWLog_ERR(TAG, \"UPDATE_TYPE %s [%\" PRIu16 \"] failed\", update_type_to_string(updateType),\n \t\t         updateType);\n \t\treturn FALSE;\n \t}\n \n \treturn TRUE;\n }\n \n", "target": "// fix_start\n\tWLog_Print(update->log, WLOG_TRACE, \"%s Update Data PDU\", update_type_to_string(updateType));\n// fix_end\n", "cwe": "CWE-125", "cwe_name": "Out-of-bounds Read", "cve": "CVE-2020-11019", "cve_desc": "In FreeRDP less than or equal to 2.0.0, when running with logger set to \"WLOG_TRACE\", a possible crash of application could occur due to a read of an invalid array index. Data could be printed as string to local terminal. This has been fixed in 2.1.0.", "project": "FreeRDP", "idx": 199894}
{"source": "// bug_start\nstatic int may_create_in_sticky(struct dentry * const dir,\n// bug_end\n \t\t\t\tstruct inode * const inode)\n {\n \tif ((!sysctl_protected_fifos && S_ISFIFO(inode->i_mode)) ||\n \t    (!sysctl_protected_regular && S_ISREG(inode->i_mode)) ||\n// bug_start\n\t    likely(!(dir->d_inode->i_mode & S_ISVTX)) ||\n\t    uid_eq(inode->i_uid, dir->d_inode->i_uid) ||\n// bug_end\n \t    uid_eq(current_fsuid(), inode->i_uid))\n \t\treturn 0;\n \n// bug_start\n\tif (likely(dir->d_inode->i_mode & 0002) ||\n\t    (dir->d_inode->i_mode & 0020 &&\n// bug_end\n \t     ((sysctl_protected_fifos >= 2 && S_ISFIFO(inode->i_mode)) ||\n \t      (sysctl_protected_regular >= 2 && S_ISREG(inode->i_mode))))) {\n \t\tconst char *operation = S_ISFIFO(inode->i_mode) ?\n \t\t\t\t\t\"sticky_create_fifo\" :\n \t\t\t\t\t\"sticky_create_regular\";\n \t\taudit_log_path_denied(AUDIT_ANOM_CREAT, operation);\n \t\treturn -EACCES;\n \t}\n \treturn 0;\n }\n \n", "target": "// fix_start\nstatic int may_create_in_sticky(umode_t dir_mode, kuid_t dir_uid,\n// fix_end\n// fix_start\n\t    likely(!(dir_mode & S_ISVTX)) ||\n\t    uid_eq(inode->i_uid, dir_uid) ||\n// fix_end\n// fix_start\n\tif (likely(dir_mode & 0002) ||\n\t    (dir_mode & 0020 &&\n// fix_end\n", "cwe": "CWE-284", "cwe_name": "Improper Access Control", "cve": "CVE-2020-8428", "cve_desc": "fs/namei.c in the Linux kernel before 5.5 has a may_create_in_sticky use-after-free, which allows local users to cause a denial of service (OOPS) or possibly obtain sensitive information from kernel memory, aka CID-d0cb50185ae9. One attack vector may be an open system call for a UNIX domain socket, if the socket is being moved to a new parent directory and its old parent directory is being removed.", "project": "linux", "idx": 199916}
{"source": " CallResult<HermesValue> Interpreter::interpretFunction(\n     Runtime *runtime,\n     InterpreterState &state) {\n   struct IPSaver {\n     IPSaver(Runtime *runtime)\n         : ip_(runtime->getCurrentIP()), runtime_(runtime) {}\n \n     ~IPSaver() {\n       runtime_->setCurrentIP(ip_);\n     }\n \n    private:\n     const Inst *ip_;\n     Runtime *runtime_;\n   };\n   IPSaver ipSaver(runtime);\n \n #ifndef HERMES_ENABLE_DEBUGGER\n   static_assert(!SingleStep, \"can't use single-step mode without the debugger\");\n #endif\n   static_assert(\n       HiddenClass::kDictionaryThreshold <=\n           SegmentedArray::kValueToSegmentThreshold,\n       \"Cannot avoid branches in cache check if the dictionary \"\n       \"crossover point is larger than the inline storage\");\n \n   CodeBlock *curCodeBlock = state.codeBlock;\n   const Inst *ip = nullptr;\n   PinnedHermesValue *frameRegs;\n   bool strictMode;\n   PropOpFlags defaultPropOpFlags;\n \n #define CAPTURE_IP_ASSIGN_NO_INVALIDATE(dst, expr) \\\n   runtime->setCurrentIP(ip);                       \\\n   dst = expr;                                      \\\n   ip = runtime->getCurrentIP();\n \n #ifdef NDEBUG\n \n #define CAPTURE_IP(expr)     \\\n   runtime->setCurrentIP(ip); \\\n   (void)expr;                \\\n   ip = runtime->getCurrentIP();\n \n #define CAPTURE_IP_ASSIGN(dst, expr) CAPTURE_IP_ASSIGN_NO_INVALIDATE(dst, expr)\n \n #else\n \n #define CAPTURE_IP(expr)        \\\n   runtime->setCurrentIP(ip);    \\\n   (void)expr;                   \\\n   ip = runtime->getCurrentIP(); \\\n   runtime->invalidateCurrentIP();\n \n #define CAPTURE_IP_ASSIGN(dst, expr) \\\n   runtime->setCurrentIP(ip);         \\\n   dst = expr;                        \\\n   ip = runtime->getCurrentIP();      \\\n   runtime->invalidateCurrentIP();\n \n #endif\n// bug_start\n// bug_end\n \n   LLVM_DEBUG(dbgs() << \"interpretFunction() called\\n\");\n \n   ScopedNativeDepthTracker depthTracker{runtime};\n   if (LLVM_UNLIKELY(depthTracker.overflowed())) {\n     return runtime->raiseStackOverflow(Runtime::StackOverflowKind::NativeStack);\n   }\n \n   if (!SingleStep) {\n     if (auto jitPtr = runtime->jitContext_.compile(runtime, curCodeBlock)) {\n       return (*jitPtr)(runtime);\n     }\n   }\n \n   GCScope gcScope(runtime);\n   MutableHandle<> tmpHandle(runtime);\n   CallResult<HermesValue> res{ExecutionStatus::EXCEPTION};\n   CallResult<PseudoHandle<>> resPH{ExecutionStatus::EXCEPTION};\n   CallResult<Handle<Arguments>> resArgs{ExecutionStatus::EXCEPTION};\n   CallResult<bool> boolRes{ExecutionStatus::EXCEPTION};\n \n   static constexpr unsigned KEEP_HANDLES = 1;\n   assert(\n       gcScope.getHandleCountDbg() == KEEP_HANDLES &&\n       \"scope has unexpected number of handles\");\n \n   INIT_OPCODE_PROFILER;\n \n #if !defined(HERMESVM_PROFILER_EXTERN)\n tailCall:\n #endif\n   PROFILER_ENTER_FUNCTION(curCodeBlock);\n \n #ifdef HERMES_ENABLE_DEBUGGER\n   runtime->getDebugger().willEnterCodeBlock(curCodeBlock);\n #endif\n \n   runtime->getCodeCoverageProfiler().markExecuted(runtime, curCodeBlock);\n \n   curCodeBlock->incrementExecutionCount();\n \n   if (!SingleStep) {\n     auto newFrame = runtime->setCurrentFrameToTopOfStack();\n     runtime->saveCallerIPInStackFrame();\n #ifndef NDEBUG\n     runtime->invalidateCurrentIP();\n #endif\n \n     frameRegs = &newFrame.getFirstLocalRef();\n \n #ifndef NDEBUG\n     LLVM_DEBUG(\n         dbgs() << \"function entry: stackLevel=\" << runtime->getStackLevel()\n                << \", argCount=\" << runtime->getCurrentFrame().getArgCount()\n                << \", frameSize=\" << curCodeBlock->getFrameSize() << \"\\n\");\n \n     LLVM_DEBUG(\n         dbgs() << \" callee \"\n                << DumpHermesValue(\n                       runtime->getCurrentFrame().getCalleeClosureOrCBRef())\n                << \"\\n\");\n     LLVM_DEBUG(\n         dbgs() << \"   this \"\n                << DumpHermesValue(runtime->getCurrentFrame().getThisArgRef())\n                << \"\\n\");\n     for (uint32_t i = 0; i != runtime->getCurrentFrame()->getArgCount(); ++i) {\n       LLVM_DEBUG(\n           dbgs() << \"   \" << llvh::format_decimal(i, 4) << \" \"\n                  << DumpHermesValue(runtime->getCurrentFrame().getArgRef(i))\n                  << \"\\n\");\n     }\n #endif\n \n     if (LLVM_UNLIKELY(!runtime->checkAndAllocStack(\n             curCodeBlock->getFrameSize() +\n                 StackFrameLayout::CalleeExtraRegistersAtStart,\n             HermesValue::encodeUndefinedValue())))\n       goto stackOverflow;\n \n     ip = (Inst const *)curCodeBlock->begin();\n \n     if (LLVM_UNLIKELY(curCodeBlock->getHeaderFlags().isCallProhibited(\n             newFrame.isConstructorCall()))) {\n       if (!newFrame.isConstructorCall()) {\n         CAPTURE_IP(\n             runtime->raiseTypeError(\"Class constructor invoked without new\"));\n       } else {\n         CAPTURE_IP(runtime->raiseTypeError(\"Function is not a constructor\"));\n       }\n       goto handleExceptionInParent;\n     }\n   } else {\n     frameRegs = &runtime->getCurrentFrame().getFirstLocalRef();\n     ip = (Inst const *)(curCodeBlock->begin() + state.offset);\n   }\n \n   assert((const uint8_t *)ip < curCodeBlock->end() && \"CodeBlock is empty\");\n \n   INIT_STATE_FOR_CODEBLOCK(curCodeBlock);\n \n #define BEFORE_OP_CODE                                                       \\\n   {                                                                          \\\n     UPDATE_OPCODE_TIME_SPENT;                                                \\\n     HERMES_SLOW_ASSERT(                                                      \\\n         curCodeBlock->contains(ip) && \"curCodeBlock must contain ip\");       \\\n     HERMES_SLOW_ASSERT((printDebugInfo(curCodeBlock, frameRegs, ip), true)); \\\n     HERMES_SLOW_ASSERT(                                                      \\\n         gcScope.getHandleCountDbg() == KEEP_HANDLES &&                       \\\n         \"unaccounted handles were created\");                                 \\\n     HERMES_SLOW_ASSERT(tmpHandle->isUndefined() && \"tmpHandle not cleared\"); \\\n     RECORD_OPCODE_START_TIME;                                                \\\n     INC_OPCODE_COUNT;                                                        \\\n   }\n \n #ifdef HERMESVM_INDIRECT_THREADING\n   static void *opcodeDispatch[] = {\n #define DEFINE_OPCODE(name) &&case_##name,\n #include \"hermes/BCGen/HBC/BytecodeList.def\"\n       &&case__last};\n \n #define CASE(name) case_##name:\n #define DISPATCH                                \\\n   BEFORE_OP_CODE;                               \\\n   if (SingleStep) {                             \\\n     state.codeBlock = curCodeBlock;             \\\n     state.offset = CUROFFSET;                   \\\n     return HermesValue::encodeUndefinedValue(); \\\n   }                                             \\\n   goto *opcodeDispatch[(unsigned)ip->opCode]\n \n #else\n \n #define CASE(name) case OpCode::name:\n #define DISPATCH                                \\\n   if (SingleStep) {                             \\\n     state.codeBlock = curCodeBlock;             \\\n     state.offset = CUROFFSET;                   \\\n     return HermesValue::encodeUndefinedValue(); \\\n   }                                             \\\n   continue\n \n #endif\n \n #define RUN_DEBUGGER_ASYNC_BREAK(flags)                                      \\\n   do {                                                                       \\\n     CAPTURE_IP_ASSIGN(                                                       \\\n         auto dRes,                                                           \\\n         runDebuggerUpdatingState(                                            \\\n             (uint8_t)(flags) &                                               \\\n                     (uint8_t)Runtime::AsyncBreakReasonBits::DebuggerExplicit \\\n                 ? Debugger::RunReason::AsyncBreakExplicit                    \\\n                 : Debugger::RunReason::AsyncBreakImplicit,                   \\\n             runtime,                                                         \\\n             curCodeBlock,                                                    \\\n             ip,                                                              \\\n             frameRegs));                                                     \\\n     if (dRes == ExecutionStatus::EXCEPTION)                                  \\\n       goto exception;                                                        \\\n   } while (0)\n \n   for (;;) {\n     BEFORE_OP_CODE;\n \n #ifdef HERMESVM_INDIRECT_THREADING\n     goto *opcodeDispatch[(unsigned)ip->opCode];\n #else\n     switch (ip->opCode)\n #endif\n     {\n       const Inst *nextIP;\n       uint32_t idVal;\n       bool tryProp;\n       uint32_t callArgCount;\n       HermesValue::RawType callNewTarget;\n \n #define CASE_OUTOFLINE(name)                                         \\\n   CASE(name) {                                                       \\\n     CAPTURE_IP_ASSIGN(auto res, case##name(runtime, frameRegs, ip)); \\\n     if (LLVM_UNLIKELY(res == ExecutionStatus::EXCEPTION)) {          \\\n       goto exception;                                                \\\n     }                                                                \\\n     gcScope.flushToSmallCount(KEEP_HANDLES);                         \\\n     ip = NEXTINST(name);                                             \\\n     DISPATCH;                                                        \\\n   }\n \n #define BINOP(name, oper)                                                  \\\n   CASE(name) {                                                             \\\n     if (LLVM_LIKELY(O2REG(name).isNumber() && O3REG(name).isNumber())) {   \\\n                                                            \\\n       CASE(name##N) {                                                      \\\n         O1REG(name) = HermesValue::encodeDoubleValue(                      \\\n             oper(O2REG(name).getNumber(), O3REG(name).getNumber()));       \\\n         ip = NEXTINST(name);                                               \\\n         DISPATCH;                                                          \\\n       }                                                                    \\\n     }                                                                      \\\n     CAPTURE_IP_ASSIGN(res, toNumber_RJS(runtime, Handle<>(&O2REG(name)))); \\\n     if (res == ExecutionStatus::EXCEPTION)                                 \\\n       goto exception;                                                      \\\n     double left = res->getDouble();                                        \\\n     CAPTURE_IP_ASSIGN(res, toNumber_RJS(runtime, Handle<>(&O3REG(name)))); \\\n     if (res == ExecutionStatus::EXCEPTION)                                 \\\n       goto exception;                                                      \\\n     O1REG(name) =                                                          \\\n         HermesValue::encodeDoubleValue(oper(left, res->getDouble()));      \\\n     gcScope.flushToSmallCount(KEEP_HANDLES);                               \\\n     ip = NEXTINST(name);                                                   \\\n     DISPATCH;                                                              \\\n   }\n \n #define SHIFTOP(name, oper, lConv, lType, returnType)                      \\\n   CASE(name) {                                                             \\\n     if (LLVM_LIKELY(                                                       \\\n             O2REG(name).isNumber() &&                                      \\\n             O3REG(name).isNumber())) {                     \\\n       auto lnum = static_cast<lType>(                                      \\\n           hermes::truncateToInt32(O2REG(name).getNumber()));               \\\n       auto rnum = static_cast<uint32_t>(                                   \\\n                       hermes::truncateToInt32(O3REG(name).getNumber())) &  \\\n           0x1f;                                                            \\\n       O1REG(name) = HermesValue::encodeDoubleValue(                        \\\n           static_cast<returnType>(lnum oper rnum));                        \\\n       ip = NEXTINST(name);                                                 \\\n       DISPATCH;                                                            \\\n     }                                                                      \\\n     CAPTURE_IP_ASSIGN(res, lConv(runtime, Handle<>(&O2REG(name))));        \\\n     if (res == ExecutionStatus::EXCEPTION) {                               \\\n       goto exception;                                                      \\\n     }                                                                      \\\n     auto lnum = static_cast<lType>(res->getNumber());                      \\\n     CAPTURE_IP_ASSIGN(res, toUInt32_RJS(runtime, Handle<>(&O3REG(name)))); \\\n     if (res == ExecutionStatus::EXCEPTION) {                               \\\n       goto exception;                                                      \\\n     }                                                                      \\\n     auto rnum = static_cast<uint32_t>(res->getNumber()) & 0x1f;            \\\n     gcScope.flushToSmallCount(KEEP_HANDLES);                               \\\n     O1REG(name) = HermesValue::encodeDoubleValue(                          \\\n         static_cast<returnType>(lnum oper rnum));                          \\\n     ip = NEXTINST(name);                                                   \\\n     DISPATCH;                                                              \\\n   }\n \n #define BITWISEBINOP(name, oper)                                               \\\n   CASE(name) {                                                                 \\\n     if (LLVM_LIKELY(O2REG(name).isNumber() && O3REG(name).isNumber())) {       \\\n                                                                \\\n       O1REG(name) = HermesValue::encodeDoubleValue(                            \\\n           hermes::truncateToInt32(O2REG(name).getNumber())                     \\\n               oper hermes::truncateToInt32(O3REG(name).getNumber()));          \\\n       ip = NEXTINST(name);                                                     \\\n       DISPATCH;                                                                \\\n     }                                                                          \\\n     CAPTURE_IP_ASSIGN(res, toInt32_RJS(runtime, Handle<>(&O2REG(name))));      \\\n     if (res == ExecutionStatus::EXCEPTION) {                                   \\\n       goto exception;                                                          \\\n     }                                                                          \\\n     int32_t left = res->getNumberAs<int32_t>();                                \\\n     CAPTURE_IP_ASSIGN(res, toInt32_RJS(runtime, Handle<>(&O3REG(name))));      \\\n     if (res == ExecutionStatus::EXCEPTION) {                                   \\\n       goto exception;                                                          \\\n     }                                                                          \\\n     O1REG(name) =                                                              \\\n         HermesValue::encodeNumberValue(left oper res->getNumberAs<int32_t>()); \\\n     gcScope.flushToSmallCount(KEEP_HANDLES);                                   \\\n     ip = NEXTINST(name);                                                       \\\n     DISPATCH;                                                                  \\\n   }\n \n #define CONDOP(name, oper, operFuncName)                                 \\\n   CASE(name) {                                                           \\\n     if (LLVM_LIKELY(O2REG(name).isNumber() && O3REG(name).isNumber())) { \\\n                                                          \\\n       O1REG(name) = HermesValue::encodeBoolValue(                        \\\n           O2REG(name).getNumber() oper O3REG(name).getNumber());         \\\n       ip = NEXTINST(name);                                               \\\n       DISPATCH;                                                          \\\n     }                                                                    \\\n     CAPTURE_IP_ASSIGN(                                                   \\\n         boolRes,                                                         \\\n         operFuncName(                                                    \\\n             runtime, Handle<>(&O2REG(name)), Handle<>(&O3REG(name))));   \\\n     if (boolRes == ExecutionStatus::EXCEPTION)                           \\\n       goto exception;                                                    \\\n     gcScope.flushToSmallCount(KEEP_HANDLES);                             \\\n     O1REG(name) = HermesValue::encodeBoolValue(boolRes.getValue());      \\\n     ip = NEXTINST(name);                                                 \\\n     DISPATCH;                                                            \\\n   }\n \n #define JCOND_IMPL(name, suffix, oper, operFuncName, trueDest, falseDest) \\\n   CASE(name##suffix) {                                                    \\\n     if (LLVM_LIKELY(                                                      \\\n             O2REG(name##suffix).isNumber() &&                             \\\n             O3REG(name##suffix).isNumber())) {                            \\\n                                                           \\\n       CASE(name##N##suffix) {                                             \\\n         if (O2REG(name##N##suffix)                                        \\\n                 .getNumber() oper O3REG(name##N##suffix)                  \\\n                 .getNumber()) {                                           \\\n           ip = trueDest;                                                  \\\n           DISPATCH;                                                       \\\n         }                                                                 \\\n         ip = falseDest;                                                   \\\n         DISPATCH;                                                         \\\n       }                                                                   \\\n     }                                                                     \\\n     CAPTURE_IP_ASSIGN(                                                    \\\n         boolRes,                                                          \\\n         operFuncName(                                                     \\\n             runtime,                                                      \\\n             Handle<>(&O2REG(name##suffix)),                               \\\n             Handle<>(&O3REG(name##suffix))));                             \\\n     if (boolRes == ExecutionStatus::EXCEPTION)                            \\\n       goto exception;                                                     \\\n     gcScope.flushToSmallCount(KEEP_HANDLES);                              \\\n     if (boolRes.getValue()) {                                             \\\n       ip = trueDest;                                                      \\\n       DISPATCH;                                                           \\\n     }                                                                     \\\n     ip = falseDest;                                                       \\\n     DISPATCH;                                                             \\\n   }\n \n #define JCOND_STRICT_EQ_IMPL(name, suffix, trueDest, falseDest)         \\\n   CASE(name##suffix) {                                                  \\\n     if (strictEqualityTest(O2REG(name##suffix), O3REG(name##suffix))) { \\\n       ip = trueDest;                                                    \\\n       DISPATCH;                                                         \\\n     }                                                                   \\\n     ip = falseDest;                                                     \\\n     DISPATCH;                                                           \\\n   }\n \n #define JCOND_EQ_IMPL(name, suffix, trueDest, falseDest) \\\n   CASE(name##suffix) {                                   \\\n     CAPTURE_IP_ASSIGN(                                   \\\n         res,                                             \\\n         abstractEqualityTest_RJS(                        \\\n             runtime,                                     \\\n             Handle<>(&O2REG(name##suffix)),              \\\n             Handle<>(&O3REG(name##suffix))));            \\\n     if (res == ExecutionStatus::EXCEPTION) {             \\\n       goto exception;                                    \\\n     }                                                    \\\n     gcScope.flushToSmallCount(KEEP_HANDLES);             \\\n     if (res->getBool()) {                                \\\n       ip = trueDest;                                     \\\n       DISPATCH;                                          \\\n     }                                                    \\\n     ip = falseDest;                                      \\\n     DISPATCH;                                            \\\n   }\n \n #define JCOND(name, oper, operFuncName) \\\n   JCOND_IMPL(                           \\\n       J##name,                          \\\n       ,                                 \\\n       oper,                             \\\n       operFuncName,                     \\\n       IPADD(ip->iJ##name.op1),          \\\n       NEXTINST(J##name));               \\\n   JCOND_IMPL(                           \\\n       J##name,                          \\\n       Long,                             \\\n       oper,                             \\\n       operFuncName,                     \\\n       IPADD(ip->iJ##name##Long.op1),    \\\n       NEXTINST(J##name##Long));         \\\n   JCOND_IMPL(                           \\\n       JNot##name,                       \\\n       ,                                 \\\n       oper,                             \\\n       operFuncName,                     \\\n       NEXTINST(JNot##name),             \\\n       IPADD(ip->iJNot##name.op1));      \\\n   JCOND_IMPL(                           \\\n       JNot##name,                       \\\n       Long,                             \\\n       oper,                             \\\n       operFuncName,                     \\\n       NEXTINST(JNot##name##Long),       \\\n       IPADD(ip->iJNot##name##Long.op1));\n \n #define LOAD_CONST(name, value) \\\n   CASE(name) {                  \\\n     O1REG(name) = value;        \\\n     ip = NEXTINST(name);        \\\n     DISPATCH;                   \\\n   }\n \n #define LOAD_CONST_CAPTURE_IP(name, value) \\\n   CASE(name) {                             \\\n     CAPTURE_IP_ASSIGN(O1REG(name), value); \\\n     ip = NEXTINST(name);                   \\\n     DISPATCH;                              \\\n   }\n \n       CASE(Mov) {\n         O1REG(Mov) = O2REG(Mov);\n         ip = NEXTINST(Mov);\n         DISPATCH;\n       }\n \n       CASE(MovLong) {\n         O1REG(MovLong) = O2REG(MovLong);\n         ip = NEXTINST(MovLong);\n         DISPATCH;\n       }\n \n       CASE(LoadParam) {\n         if (LLVM_LIKELY(ip->iLoadParam.op2 <= FRAME.getArgCount())) {\n           O1REG(LoadParam) = FRAME.getArgRef((int32_t)ip->iLoadParam.op2 - 1);\n           ip = NEXTINST(LoadParam);\n           DISPATCH;\n         }\n         O1REG(LoadParam) = HermesValue::encodeUndefinedValue();\n         ip = NEXTINST(LoadParam);\n         DISPATCH;\n       }\n \n       CASE(LoadParamLong) {\n         if (LLVM_LIKELY(ip->iLoadParamLong.op2 <= FRAME.getArgCount())) {\n           O1REG(LoadParamLong) =\n               FRAME.getArgRef((int32_t)ip->iLoadParamLong.op2 - 1);\n           ip = NEXTINST(LoadParamLong);\n           DISPATCH;\n         }\n         O1REG(LoadParamLong) = HermesValue::encodeUndefinedValue();\n         ip = NEXTINST(LoadParamLong);\n         DISPATCH;\n       }\n \n       CASE(CoerceThisNS) {\n         if (LLVM_LIKELY(O2REG(CoerceThisNS).isObject())) {\n           O1REG(CoerceThisNS) = O2REG(CoerceThisNS);\n         } else if (\n             O2REG(CoerceThisNS).isNull() || O2REG(CoerceThisNS).isUndefined()) {\n           O1REG(CoerceThisNS) = runtime->global_;\n         } else {\n           tmpHandle = O2REG(CoerceThisNS);\n           nextIP = NEXTINST(CoerceThisNS);\n           goto coerceThisSlowPath;\n         }\n         ip = NEXTINST(CoerceThisNS);\n         DISPATCH;\n       }\n       CASE(LoadThisNS) {\n         if (LLVM_LIKELY(FRAME.getThisArgRef().isObject())) {\n           O1REG(LoadThisNS) = FRAME.getThisArgRef();\n         } else if (\n             FRAME.getThisArgRef().isNull() ||\n             FRAME.getThisArgRef().isUndefined()) {\n           O1REG(LoadThisNS) = runtime->global_;\n         } else {\n           tmpHandle = FRAME.getThisArgRef();\n           nextIP = NEXTINST(LoadThisNS);\n           goto coerceThisSlowPath;\n         }\n         ip = NEXTINST(LoadThisNS);\n         DISPATCH;\n       }\n     coerceThisSlowPath : {\n       CAPTURE_IP_ASSIGN(res, toObject(runtime, tmpHandle));\n       if (LLVM_UNLIKELY(res == ExecutionStatus::EXCEPTION)) {\n         goto exception;\n       }\n       O1REG(CoerceThisNS) = res.getValue();\n       tmpHandle.clear();\n       gcScope.flushToSmallCount(KEEP_HANDLES);\n       ip = nextIP;\n       DISPATCH;\n     }\n \n       CASE(ConstructLong) {\n         callArgCount = (uint32_t)ip->iConstructLong.op3;\n         nextIP = NEXTINST(ConstructLong);\n         callNewTarget = O2REG(ConstructLong).getRaw();\n         goto doCall;\n       }\n       CASE(CallLong) {\n         callArgCount = (uint32_t)ip->iCallLong.op3;\n         nextIP = NEXTINST(CallLong);\n         callNewTarget = HermesValue::encodeUndefinedValue().getRaw();\n         goto doCall;\n       }\n \n       CASE(Call1) {\n         callArgCount = 1;\n         nextIP = NEXTINST(Call1);\n         StackFramePtr fr{runtime->stackPointer_};\n         fr.getArgRefUnsafe(-1) = O3REG(Call1);\n         callNewTarget = HermesValue::encodeUndefinedValue().getRaw();\n         goto doCall;\n       }\n \n       CASE(Call2) {\n         callArgCount = 2;\n         nextIP = NEXTINST(Call2);\n         StackFramePtr fr{runtime->stackPointer_};\n         fr.getArgRefUnsafe(-1) = O3REG(Call2);\n         fr.getArgRefUnsafe(0) = O4REG(Call2);\n         callNewTarget = HermesValue::encodeUndefinedValue().getRaw();\n         goto doCall;\n       }\n \n       CASE(Call3) {\n         callArgCount = 3;\n         nextIP = NEXTINST(Call3);\n         StackFramePtr fr{runtime->stackPointer_};\n         fr.getArgRefUnsafe(-1) = O3REG(Call3);\n         fr.getArgRefUnsafe(0) = O4REG(Call3);\n         fr.getArgRefUnsafe(1) = O5REG(Call3);\n         callNewTarget = HermesValue::encodeUndefinedValue().getRaw();\n         goto doCall;\n       }\n \n       CASE(Call4) {\n         callArgCount = 4;\n         nextIP = NEXTINST(Call4);\n         StackFramePtr fr{runtime->stackPointer_};\n         fr.getArgRefUnsafe(-1) = O3REG(Call4);\n         fr.getArgRefUnsafe(0) = O4REG(Call4);\n         fr.getArgRefUnsafe(1) = O5REG(Call4);\n         fr.getArgRefUnsafe(2) = O6REG(Call4);\n         callNewTarget = HermesValue::encodeUndefinedValue().getRaw();\n         goto doCall;\n       }\n \n       CASE(Construct) {\n         callArgCount = (uint32_t)ip->iConstruct.op3;\n         nextIP = NEXTINST(Construct);\n         callNewTarget = O2REG(Construct).getRaw();\n         goto doCall;\n       }\n       CASE(Call) {\n         callArgCount = (uint32_t)ip->iCall.op3;\n         nextIP = NEXTINST(Call);\n         callNewTarget = HermesValue::encodeUndefinedValue().getRaw();\n       }\n \n     doCall : {\n #ifdef HERMES_ENABLE_DEBUGGER\n       if (uint8_t asyncFlags =\n               runtime->testAndClearDebuggerAsyncBreakRequest()) {\n         RUN_DEBUGGER_ASYNC_BREAK(asyncFlags);\n         gcScope.flushToSmallCount(KEEP_HANDLES);\n         DISPATCH;\n       }\n #endif\n \n       CAPTURE_IP_ASSIGN_NO_INVALIDATE(\n           auto newFrame,\n           StackFramePtr::initFrame(\n               runtime->stackPointer_,\n               FRAME,\n               ip,\n               curCodeBlock,\n               callArgCount - 1,\n               O2REG(Call),\n               HermesValue::fromRaw(callNewTarget)));\n       (void)newFrame;\n \n       SLOW_DEBUG(dumpCallArguments(dbgs(), runtime, newFrame));\n \n       if (auto *func = dyn_vmcast<JSFunction>(O2REG(Call))) {\n         assert(!SingleStep && \"can't single-step a call\");\n \n #ifdef HERMES_ENABLE_ALLOCATION_LOCATION_TRACES\n         runtime->pushCallStack(curCodeBlock, ip);\n #endif\n \n         CodeBlock *calleeBlock = func->getCodeBlock();\n         calleeBlock->lazyCompile(runtime);\n #if defined(HERMESVM_PROFILER_EXTERN)\n         CAPTURE_IP_ASSIGN_NO_INVALIDATE(\n             res, runtime->interpretFunction(calleeBlock));\n         if (LLVM_UNLIKELY(res == ExecutionStatus::EXCEPTION)) {\n           goto exception;\n         }\n         O1REG(Call) = *res;\n         gcScope.flushToSmallCount(KEEP_HANDLES);\n         ip = nextIP;\n         DISPATCH;\n #else\n         if (auto jitPtr = runtime->jitContext_.compile(runtime, calleeBlock)) {\n           res = (*jitPtr)(runtime);\n           if (LLVM_UNLIKELY(res == ExecutionStatus::EXCEPTION))\n             goto exception;\n           O1REG(Call) = *res;\n           SLOW_DEBUG(\n               dbgs() << \"JIT return value r\" << (unsigned)ip->iCall.op1 << \"=\"\n                      << DumpHermesValue(O1REG(Call)) << \"\\n\");\n           gcScope.flushToSmallCount(KEEP_HANDLES);\n           ip = nextIP;\n           DISPATCH;\n         }\n         curCodeBlock = calleeBlock;\n         goto tailCall;\n #endif\n       }\n       CAPTURE_IP_ASSIGN_NO_INVALIDATE(\n           resPH, Interpreter::handleCallSlowPath(runtime, &O2REG(Call)));\n       if (LLVM_UNLIKELY(resPH == ExecutionStatus::EXCEPTION)) {\n         goto exception;\n       }\n       O1REG(Call) = std::move(resPH->get());\n       SLOW_DEBUG(\n           dbgs() << \"native return value r\" << (unsigned)ip->iCall.op1 << \"=\"\n                  << DumpHermesValue(O1REG(Call)) << \"\\n\");\n       gcScope.flushToSmallCount(KEEP_HANDLES);\n       ip = nextIP;\n       DISPATCH;\n     }\n \n       CASE(CallDirect)\n       CASE(CallDirectLongIndex) {\n #ifdef HERMES_ENABLE_DEBUGGER\n         if (uint8_t asyncFlags =\n                 runtime->testAndClearDebuggerAsyncBreakRequest()) {\n           RUN_DEBUGGER_ASYNC_BREAK(asyncFlags);\n           gcScope.flushToSmallCount(KEEP_HANDLES);\n           DISPATCH;\n         }\n #endif\n \n         CAPTURE_IP_ASSIGN(\n             CodeBlock * calleeBlock,\n             ip->opCode == OpCode::CallDirect\n                 ? curCodeBlock->getRuntimeModule()->getCodeBlockMayAllocate(\n                       ip->iCallDirect.op3)\n                 : curCodeBlock->getRuntimeModule()->getCodeBlockMayAllocate(\n                       ip->iCallDirectLongIndex.op3));\n \n         CAPTURE_IP_ASSIGN_NO_INVALIDATE(\n             auto newFrame,\n             StackFramePtr::initFrame(\n                 runtime->stackPointer_,\n                 FRAME,\n                 ip,\n                 curCodeBlock,\n                 (uint32_t)ip->iCallDirect.op2 - 1,\n                 HermesValue::encodeNativePointer(calleeBlock),\n                 HermesValue::encodeUndefinedValue()));\n         (void)newFrame;\n \n         LLVM_DEBUG(dumpCallArguments(dbgs(), runtime, newFrame));\n \n         assert(!SingleStep && \"can't single-step a call\");\n \n         calleeBlock->lazyCompile(runtime);\n #if defined(HERMESVM_PROFILER_EXTERN)\n         CAPTURE_IP_ASSIGN_NO_INVALIDATE(\n             res, runtime->interpretFunction(calleeBlock));\n         if (LLVM_UNLIKELY(res == ExecutionStatus::EXCEPTION)) {\n           goto exception;\n         }\n         O1REG(CallDirect) = *res;\n         gcScope.flushToSmallCount(KEEP_HANDLES);\n         ip = ip->opCode == OpCode::CallDirect ? NEXTINST(CallDirect)\n                                               : NEXTINST(CallDirectLongIndex);\n         DISPATCH;\n #else\n         if (auto jitPtr = runtime->jitContext_.compile(runtime, calleeBlock)) {\n           res = (*jitPtr)(runtime);\n           if (LLVM_UNLIKELY(res == ExecutionStatus::EXCEPTION))\n             goto exception;\n           O1REG(CallDirect) = *res;\n           LLVM_DEBUG(\n               dbgs() << \"JIT return value r\" << (unsigned)ip->iCallDirect.op1\n                      << \"=\" << DumpHermesValue(O1REG(Call)) << \"\\n\");\n           gcScope.flushToSmallCount(KEEP_HANDLES);\n           ip = ip->opCode == OpCode::CallDirect ? NEXTINST(CallDirect)\n                                                 : NEXTINST(CallDirectLongIndex);\n           DISPATCH;\n         }\n         curCodeBlock = calleeBlock;\n         goto tailCall;\n #endif\n       }\n \n       CASE(CallBuiltin) {\n         NativeFunction *nf =\n             runtime->getBuiltinNativeFunction(ip->iCallBuiltin.op2);\n \n         CAPTURE_IP_ASSIGN(\n             auto newFrame,\n             StackFramePtr::initFrame(\n                 runtime->stackPointer_,\n                 FRAME,\n                 ip,\n                 curCodeBlock,\n                 (uint32_t)ip->iCallBuiltin.op3 - 1,\n                 nf,\n                 false));\n         newFrame.getThisArgRef() = HermesValue::encodeUndefinedValue();\n \n         SLOW_DEBUG(dumpCallArguments(dbgs(), runtime, newFrame));\n \n         CAPTURE_IP_ASSIGN(resPH, NativeFunction::_nativeCall(nf, runtime));\n         if (LLVM_UNLIKELY(resPH == ExecutionStatus::EXCEPTION))\n           goto exception;\n         O1REG(CallBuiltin) = std::move(resPH->get());\n         SLOW_DEBUG(\n             dbgs() << \"native return value r\" << (unsigned)ip->iCallBuiltin.op1\n                    << \"=\" << DumpHermesValue(O1REG(CallBuiltin)) << \"\\n\");\n         gcScope.flushToSmallCount(KEEP_HANDLES);\n         ip = NEXTINST(CallBuiltin);\n         DISPATCH;\n       }\n \n       CASE(CompleteGenerator) {\n         auto *innerFn = vmcast<GeneratorInnerFunction>(\n             runtime->getCurrentFrame().getCalleeClosure());\n         innerFn->setState(GeneratorInnerFunction::State::Completed);\n         ip = NEXTINST(CompleteGenerator);\n         DISPATCH;\n       }\n \n       CASE(SaveGenerator) {\n// bug_start\n        nextIP = IPADD(ip->iSaveGenerator.op1);\n        goto doSaveGen;\n// bug_end\n       }\n       CASE(SaveGeneratorLong) {\n// bug_start\n        nextIP = IPADD(ip->iSaveGeneratorLong.op1);\n        goto doSaveGen;\n      }\n\n    doSaveGen : {\n      auto *innerFn = vmcast<GeneratorInnerFunction>(\n          runtime->getCurrentFrame().getCalleeClosure());\n\n      innerFn->saveStack(runtime);\n      innerFn->setNextIP(nextIP);\n      innerFn->setState(GeneratorInnerFunction::State::SuspendedYield);\n      ip = NEXTINST(SaveGenerator);\n      DISPATCH;\n    }\n// bug_end\n \n       CASE(StartGenerator) {\n         auto *innerFn = vmcast<GeneratorInnerFunction>(\n             runtime->getCurrentFrame().getCalleeClosure());\n         if (innerFn->getState() ==\n             GeneratorInnerFunction::State::SuspendedStart) {\n           nextIP = NEXTINST(StartGenerator);\n         } else {\n           nextIP = innerFn->getNextIP();\n           innerFn->restoreStack(runtime);\n         }\n         innerFn->setState(GeneratorInnerFunction::State::Executing);\n         ip = nextIP;\n         DISPATCH;\n       }\n \n       CASE(ResumeGenerator) {\n         auto *innerFn = vmcast<GeneratorInnerFunction>(\n             runtime->getCurrentFrame().getCalleeClosure());\n         O1REG(ResumeGenerator) = innerFn->getResult();\n         O2REG(ResumeGenerator) = HermesValue::encodeBoolValue(\n             innerFn->getAction() == GeneratorInnerFunction::Action::Return);\n         innerFn->clearResult(runtime);\n         if (innerFn->getAction() == GeneratorInnerFunction::Action::Throw) {\n           runtime->setThrownValue(O1REG(ResumeGenerator));\n           goto exception;\n         }\n         ip = NEXTINST(ResumeGenerator);\n         DISPATCH;\n       }\n \n       CASE(Ret) {\n #ifdef HERMES_ENABLE_DEBUGGER\n         if (uint8_t asyncFlags =\n                 runtime->testAndClearDebuggerAsyncBreakRequest()) {\n           RUN_DEBUGGER_ASYNC_BREAK(asyncFlags);\n           gcScope.flushToSmallCount(KEEP_HANDLES);\n           DISPATCH;\n         }\n #endif\n \n         PROFILER_EXIT_FUNCTION(curCodeBlock);\n \n #ifdef HERMES_ENABLE_ALLOCATION_LOCATION_TRACES\n         runtime->popCallStack();\n #endif\n \n         res = O1REG(Ret);\n \n         ip = FRAME.getSavedIP();\n         curCodeBlock = FRAME.getSavedCodeBlock();\n \n         frameRegs =\n             &runtime->restoreStackAndPreviousFrame(FRAME).getFirstLocalRef();\n \n         SLOW_DEBUG(\n             dbgs() << \"function exit: restored stackLevel=\"\n                    << runtime->getStackLevel() << \"\\n\");\n \n         if (!curCodeBlock) {\n           SLOW_DEBUG(dbgs() << \"function exit: returning to native code\\n\");\n           return res;\n         }\n \n #if defined(HERMESVM_PROFILER_EXTERN)\n         return res;\n #endif\n \n         INIT_STATE_FOR_CODEBLOCK(curCodeBlock);\n         O1REG(Call) = res.getValue();\n         ip = nextInstCall(ip);\n         DISPATCH;\n       }\n \n       CASE(Catch) {\n         assert(!runtime->thrownValue_.isEmpty() && \"Invalid thrown value\");\n         assert(\n             !isUncatchableError(runtime->thrownValue_) &&\n             \"Uncatchable thrown value was caught\");\n         O1REG(Catch) = runtime->thrownValue_;\n         runtime->clearThrownValue();\n #ifdef HERMES_ENABLE_DEBUGGER\n         runtime->debugger_.finishedUnwindingException();\n #endif\n         ip = NEXTINST(Catch);\n         DISPATCH;\n       }\n \n       CASE(Throw) {\n         runtime->thrownValue_ = O1REG(Throw);\n         SLOW_DEBUG(\n             dbgs() << \"Exception thrown: \"\n                    << DumpHermesValue(runtime->thrownValue_) << \"\\n\");\n         goto exception;\n       }\n \n       CASE(ThrowIfUndefinedInst) {\n         if (LLVM_UNLIKELY(O1REG(ThrowIfUndefinedInst).isUndefined())) {\n           SLOW_DEBUG(\n               dbgs() << \"Throwing ReferenceError for undefined variable\");\n           CAPTURE_IP(runtime->raiseReferenceError(\n               \"accessing an uninitialized variable\"));\n           goto exception;\n         }\n         ip = NEXTINST(ThrowIfUndefinedInst);\n         DISPATCH;\n       }\n \n       CASE(Debugger) {\n         SLOW_DEBUG(dbgs() << \"debugger statement executed\\n\");\n #ifdef HERMES_ENABLE_DEBUGGER\n         {\n           if (!runtime->debugger_.isDebugging()) {\n             CAPTURE_IP_ASSIGN(\n                 auto res,\n                 runDebuggerUpdatingState(\n                     Debugger::RunReason::Opcode,\n                     runtime,\n                     curCodeBlock,\n                     ip,\n                     frameRegs));\n             if (res == ExecutionStatus::EXCEPTION) {\n               goto exception;\n             }\n           }\n           auto breakpointOpt = runtime->debugger_.getBreakpointLocation(ip);\n           if (breakpointOpt.hasValue()) {\n             curCodeBlock->uninstallBreakpointAtOffset(\n                 CUROFFSET, breakpointOpt->opCode);\n             if (ip->opCode == OpCode::Debugger) {\n               ip = NEXTINST(Debugger);\n             } else {\n               InterpreterState newState{curCodeBlock, (uint32_t)CUROFFSET};\n               CAPTURE_IP_ASSIGN(\n                   ExecutionStatus status, runtime->stepFunction(newState));\n               curCodeBlock->installBreakpointAtOffset(CUROFFSET);\n               if (status == ExecutionStatus::EXCEPTION) {\n                 goto exception;\n               }\n               curCodeBlock = newState.codeBlock;\n               ip = newState.codeBlock->getOffsetPtr(newState.offset);\n               INIT_STATE_FOR_CODEBLOCK(curCodeBlock);\n               frameRegs = &runtime->getCurrentFrame().getFirstLocalRef();\n             }\n           } else if (ip->opCode == OpCode::Debugger) {\n             ip = NEXTINST(Debugger);\n           }\n           gcScope.flushToSmallCount(KEEP_HANDLES);\n         }\n         DISPATCH;\n #else\n         ip = NEXTINST(Debugger);\n         DISPATCH;\n #endif\n       }\n \n       CASE(AsyncBreakCheck) {\n         if (LLVM_UNLIKELY(runtime->hasAsyncBreak())) {\n #ifdef HERMES_ENABLE_DEBUGGER\n           if (uint8_t asyncFlags =\n                   runtime->testAndClearDebuggerAsyncBreakRequest()) {\n             RUN_DEBUGGER_ASYNC_BREAK(asyncFlags);\n           }\n #endif\n           if (runtime->testAndClearTimeoutAsyncBreakRequest()) {\n             CAPTURE_IP_ASSIGN(auto nRes, runtime->notifyTimeout());\n             if (nRes == ExecutionStatus::EXCEPTION) {\n               goto exception;\n             }\n           }\n         }\n         gcScope.flushToSmallCount(KEEP_HANDLES);\n \n         ip = NEXTINST(AsyncBreakCheck);\n         DISPATCH;\n       }\n \n       CASE(ProfilePoint) {\n #ifdef HERMESVM_PROFILER_BB\n         auto pointIndex = ip->iProfilePoint.op1;\n         SLOW_DEBUG(llvh::dbgs() << \"ProfilePoint: \" << pointIndex << \"\\n\");\n         CAPTURE_IP(runtime->getBasicBlockExecutionInfo().executeBlock(\n             curCodeBlock, pointIndex));\n #endif\n         ip = NEXTINST(ProfilePoint);\n         DISPATCH;\n       }\n \n       CASE(Unreachable) {\n         llvm_unreachable(\"Hermes bug: unreachable instruction\");\n       }\n \n       CASE(CreateClosure) {\n         idVal = ip->iCreateClosure.op3;\n         nextIP = NEXTINST(CreateClosure);\n         goto createClosure;\n       }\n       CASE(CreateClosureLongIndex) {\n         idVal = ip->iCreateClosureLongIndex.op3;\n         nextIP = NEXTINST(CreateClosureLongIndex);\n         goto createClosure;\n       }\n     createClosure : {\n       auto *runtimeModule = curCodeBlock->getRuntimeModule();\n       CAPTURE_IP_ASSIGN(\n           O1REG(CreateClosure),\n           JSFunction::create(\n               runtime,\n               runtimeModule->getDomain(runtime),\n               Handle<JSObject>::vmcast(&runtime->functionPrototype),\n               Handle<Environment>::vmcast(&O2REG(CreateClosure)),\n               runtimeModule->getCodeBlockMayAllocate(idVal))\n               .getHermesValue());\n       gcScope.flushToSmallCount(KEEP_HANDLES);\n       ip = nextIP;\n       DISPATCH;\n     }\n \n       CASE(CreateGeneratorClosure) {\n         CAPTURE_IP_ASSIGN(\n             auto res,\n             createGeneratorClosure(\n                 runtime,\n                 curCodeBlock->getRuntimeModule(),\n                 ip->iCreateClosure.op3,\n                 Handle<Environment>::vmcast(&O2REG(CreateGeneratorClosure))));\n         if (LLVM_UNLIKELY(res == ExecutionStatus::EXCEPTION)) {\n           goto exception;\n         }\n         O1REG(CreateGeneratorClosure) = res->getHermesValue();\n         res->invalidate();\n         gcScope.flushToSmallCount(KEEP_HANDLES);\n         ip = NEXTINST(CreateGeneratorClosure);\n         DISPATCH;\n       }\n       CASE(CreateGeneratorClosureLongIndex) {\n         CAPTURE_IP_ASSIGN(\n             auto res,\n             createGeneratorClosure(\n                 runtime,\n                 curCodeBlock->getRuntimeModule(),\n                 ip->iCreateClosureLongIndex.op3,\n                 Handle<Environment>::vmcast(\n                     &O2REG(CreateGeneratorClosureLongIndex))));\n         if (LLVM_UNLIKELY(res == ExecutionStatus::EXCEPTION)) {\n           goto exception;\n         }\n         O1REG(CreateGeneratorClosureLongIndex) = res->getHermesValue();\n         res->invalidate();\n         gcScope.flushToSmallCount(KEEP_HANDLES);\n         ip = NEXTINST(CreateGeneratorClosureLongIndex);\n         DISPATCH;\n       }\n \n       CASE(CreateGenerator) {\n         CAPTURE_IP_ASSIGN(\n             auto res,\n             createGenerator_RJS(\n                 runtime,\n                 curCodeBlock->getRuntimeModule(),\n                 ip->iCreateGenerator.op3,\n                 Handle<Environment>::vmcast(&O2REG(CreateGenerator)),\n                 FRAME.getNativeArgs()));\n         if (LLVM_UNLIKELY(res == ExecutionStatus::EXCEPTION)) {\n           goto exception;\n         }\n         O1REG(CreateGenerator) = res->getHermesValue();\n         res->invalidate();\n         gcScope.flushToSmallCount(KEEP_HANDLES);\n         ip = NEXTINST(CreateGenerator);\n         DISPATCH;\n       }\n       CASE(CreateGeneratorLongIndex) {\n         CAPTURE_IP_ASSIGN(\n             auto res,\n             createGenerator_RJS(\n                 runtime,\n                 curCodeBlock->getRuntimeModule(),\n                 ip->iCreateGeneratorLongIndex.op3,\n                 Handle<Environment>::vmcast(&O2REG(CreateGeneratorLongIndex)),\n                 FRAME.getNativeArgs()));\n         if (LLVM_UNLIKELY(res == ExecutionStatus::EXCEPTION)) {\n           goto exception;\n         }\n         O1REG(CreateGeneratorLongIndex) = res->getHermesValue();\n         res->invalidate();\n         gcScope.flushToSmallCount(KEEP_HANDLES);\n         ip = NEXTINST(CreateGeneratorLongIndex);\n         DISPATCH;\n       }\n \n       CASE(GetEnvironment) {\n         Environment *curEnv =\n             FRAME.getCalleeClosureUnsafe()->getEnvironment(runtime);\n         for (unsigned level = ip->iGetEnvironment.op2; level; --level) {\n           assert(curEnv && \"invalid environment relative level\");\n           curEnv = curEnv->getParentEnvironment(runtime);\n         }\n         O1REG(GetEnvironment) = HermesValue::encodeObjectValue(curEnv);\n         ip = NEXTINST(GetEnvironment);\n         DISPATCH;\n       }\n \n       CASE(CreateEnvironment) {\n         tmpHandle = HermesValue::encodeObjectValue(\n             FRAME.getCalleeClosureUnsafe()->getEnvironment(runtime));\n \n         CAPTURE_IP_ASSIGN(\n             res,\n             Environment::create(\n                 runtime,\n                 tmpHandle->getPointer() ? Handle<Environment>::vmcast(tmpHandle)\n                                         : Handle<Environment>::vmcast_or_null(\n                                               &runtime->nullPointer_),\n                 curCodeBlock->getEnvironmentSize()));\n         if (res == ExecutionStatus::EXCEPTION) {\n           goto exception;\n         }\n         O1REG(CreateEnvironment) = *res;\n #ifdef HERMES_ENABLE_DEBUGGER\n         FRAME.getDebugEnvironmentRef() = *res;\n #endif\n         tmpHandle = HermesValue::encodeUndefinedValue();\n         gcScope.flushToSmallCount(KEEP_HANDLES);\n         ip = NEXTINST(CreateEnvironment);\n         DISPATCH;\n       }\n \n       CASE(StoreToEnvironment) {\n         vmcast<Environment>(O1REG(StoreToEnvironment))\n             ->slot(ip->iStoreToEnvironment.op2)\n             .set(O3REG(StoreToEnvironment), &runtime->getHeap());\n         ip = NEXTINST(StoreToEnvironment);\n         DISPATCH;\n       }\n       CASE(StoreToEnvironmentL) {\n         vmcast<Environment>(O1REG(StoreToEnvironmentL))\n             ->slot(ip->iStoreToEnvironmentL.op2)\n             .set(O3REG(StoreToEnvironmentL), &runtime->getHeap());\n         ip = NEXTINST(StoreToEnvironmentL);\n         DISPATCH;\n       }\n \n       CASE(StoreNPToEnvironment) {\n         vmcast<Environment>(O1REG(StoreNPToEnvironment))\n             ->slot(ip->iStoreNPToEnvironment.op2)\n             .setNonPtr(O3REG(StoreNPToEnvironment), &runtime->getHeap());\n         ip = NEXTINST(StoreNPToEnvironment);\n         DISPATCH;\n       }\n       CASE(StoreNPToEnvironmentL) {\n         vmcast<Environment>(O1REG(StoreNPToEnvironmentL))\n             ->slot(ip->iStoreNPToEnvironmentL.op2)\n             .setNonPtr(O3REG(StoreNPToEnvironmentL), &runtime->getHeap());\n         ip = NEXTINST(StoreNPToEnvironmentL);\n         DISPATCH;\n       }\n \n       CASE(LoadFromEnvironment) {\n         O1REG(LoadFromEnvironment) =\n             vmcast<Environment>(O2REG(LoadFromEnvironment))\n                 ->slot(ip->iLoadFromEnvironment.op3);\n         ip = NEXTINST(LoadFromEnvironment);\n         DISPATCH;\n       }\n \n       CASE(LoadFromEnvironmentL) {\n         O1REG(LoadFromEnvironmentL) =\n             vmcast<Environment>(O2REG(LoadFromEnvironmentL))\n                 ->slot(ip->iLoadFromEnvironmentL.op3);\n         ip = NEXTINST(LoadFromEnvironmentL);\n         DISPATCH;\n       }\n \n       CASE(GetGlobalObject) {\n         O1REG(GetGlobalObject) = runtime->global_;\n         ip = NEXTINST(GetGlobalObject);\n         DISPATCH;\n       }\n \n       CASE(GetNewTarget) {\n         O1REG(GetNewTarget) = FRAME.getNewTargetRef();\n         ip = NEXTINST(GetNewTarget);\n         DISPATCH;\n       }\n \n       CASE(DeclareGlobalVar) {\n         DefinePropertyFlags dpf =\n             DefinePropertyFlags::getDefaultNewPropertyFlags();\n         dpf.configurable = 0;\n         dpf.setValue = 0;\n \n         CAPTURE_IP_ASSIGN(\n             auto res,\n             JSObject::defineOwnProperty(\n                 runtime->getGlobal(),\n                 runtime,\n                 ID(ip->iDeclareGlobalVar.op1),\n                 dpf,\n                 Runtime::getUndefinedValue(),\n                 PropOpFlags().plusThrowOnError()));\n         if (res == ExecutionStatus::EXCEPTION) {\n           assert(\n               !runtime->getGlobal()->isProxyObject() &&\n               \"global can't be a proxy object\");\n           NamedPropertyDescriptor desc;\n           CAPTURE_IP_ASSIGN(\n               auto res,\n               JSObject::getOwnNamedDescriptor(\n                   runtime->getGlobal(),\n                   runtime,\n                   ID(ip->iDeclareGlobalVar.op1),\n                   desc));\n           if (!res) {\n             goto exception;\n           } else {\n             runtime->clearThrownValue();\n           }\n         }\n         gcScope.flushToSmallCount(KEEP_HANDLES);\n         ip = NEXTINST(DeclareGlobalVar);\n         DISPATCH;\n       }\n \n       CASE(TryGetByIdLong) {\n         tryProp = true;\n         idVal = ip->iTryGetByIdLong.op4;\n         nextIP = NEXTINST(TryGetByIdLong);\n         goto getById;\n       }\n       CASE(GetByIdLong) {\n         tryProp = false;\n         idVal = ip->iGetByIdLong.op4;\n         nextIP = NEXTINST(GetByIdLong);\n         goto getById;\n       }\n       CASE(GetByIdShort) {\n         tryProp = false;\n         idVal = ip->iGetByIdShort.op4;\n         nextIP = NEXTINST(GetByIdShort);\n         goto getById;\n       }\n       CASE(TryGetById) {\n         tryProp = true;\n         idVal = ip->iTryGetById.op4;\n         nextIP = NEXTINST(TryGetById);\n         goto getById;\n       }\n       CASE(GetById) {\n         tryProp = false;\n         idVal = ip->iGetById.op4;\n         nextIP = NEXTINST(GetById);\n       }\n     getById : {\n       ++NumGetById;\n       CallResult<HermesValue> propRes{ExecutionStatus::EXCEPTION};\n       if (LLVM_LIKELY(O2REG(GetById).isObject())) {\n         auto *obj = vmcast<JSObject>(O2REG(GetById));\n         auto cacheIdx = ip->iGetById.op3;\n         auto *cacheEntry = curCodeBlock->getReadCacheEntry(cacheIdx);\n \n #ifdef HERMESVM_PROFILER_BB\n         {\n           HERMES_SLOW_ASSERT(\n               gcScope.getHandleCountDbg() == KEEP_HANDLES &&\n               \"unaccounted handles were created\");\n           auto objHandle = runtime->makeHandle(obj);\n           auto cacheHCPtr = vmcast_or_null<HiddenClass>(static_cast<GCCell *>(\n               cacheEntry->clazz.get(runtime, &runtime->getHeap())));\n           CAPTURE_IP(runtime->recordHiddenClass(\n               curCodeBlock, ip, ID(idVal), obj->getClass(runtime), cacheHCPtr));\n           obj = objHandle.get();\n         }\n         gcScope.flushToSmallCount(KEEP_HANDLES);\n #endif\n         auto clazzGCPtr = obj->getClassGCPtr();\n #ifndef NDEBUG\n         if (clazzGCPtr.get(runtime)->isDictionary())\n           ++NumGetByIdDict;\n #else\n         (void)NumGetByIdDict;\n #endif\n \n         if (LLVM_LIKELY(cacheEntry->clazz == clazzGCPtr.getStorageType())) {\n           ++NumGetByIdCacheHits;\n           CAPTURE_IP_ASSIGN(\n               O1REG(GetById),\n               JSObject::getNamedSlotValue<PropStorage::Inline::Yes>(\n                   obj, runtime, cacheEntry->slot));\n           ip = nextIP;\n           DISPATCH;\n         }\n         auto id = ID(idVal);\n         NamedPropertyDescriptor desc;\n         CAPTURE_IP_ASSIGN(\n             OptValue<bool> fastPathResult,\n             JSObject::tryGetOwnNamedDescriptorFast(obj, runtime, id, desc));\n         if (LLVM_LIKELY(\n                 fastPathResult.hasValue() && fastPathResult.getValue()) &&\n             !desc.flags.accessor) {\n           ++NumGetByIdFastPaths;\n \n           auto *clazz = clazzGCPtr.getNonNull(runtime);\n           if (LLVM_LIKELY(!clazz->isDictionaryNoCache()) &&\n               LLVM_LIKELY(cacheIdx != hbc::PROPERTY_CACHING_DISABLED)) {\n #ifdef HERMES_SLOW_DEBUG\n             if (cacheEntry->clazz &&\n                 cacheEntry->clazz != clazzGCPtr.getStorageType())\n               ++NumGetByIdCacheEvicts;\n #else\n             (void)NumGetByIdCacheEvicts;\n #endif\n             cacheEntry->clazz = clazzGCPtr.getStorageType();\n             cacheEntry->slot = desc.slot;\n           }\n \n           CAPTURE_IP_ASSIGN(\n               O1REG(GetById), JSObject::getNamedSlotValue(obj, runtime, desc));\n           ip = nextIP;\n           DISPATCH;\n         }\n \n         if (fastPathResult.hasValue() && !fastPathResult.getValue() &&\n             !obj->isProxyObject()) {\n           CAPTURE_IP_ASSIGN(JSObject * parent, obj->getParent(runtime));\n           if (parent &&\n               cacheEntry->clazz == parent->getClassGCPtr().getStorageType() &&\n               LLVM_LIKELY(!obj->isLazy())) {\n             ++NumGetByIdProtoHits;\n             CAPTURE_IP_ASSIGN(\n                 O1REG(GetById),\n                 JSObject::getNamedSlotValue(parent, runtime, cacheEntry->slot));\n             ip = nextIP;\n             DISPATCH;\n           }\n         }\n \n #ifdef HERMES_SLOW_DEBUG\n         CAPTURE_IP_ASSIGN(\n             JSObject * propObj,\n             JSObject::getNamedDescriptor(\n                 Handle<JSObject>::vmcast(&O2REG(GetById)), runtime, id, desc));\n         if (propObj) {\n           if (desc.flags.accessor)\n             ++NumGetByIdAccessor;\n           else if (propObj != vmcast<JSObject>(O2REG(GetById)))\n             ++NumGetByIdProto;\n         } else {\n           ++NumGetByIdNotFound;\n         }\n #else\n         (void)NumGetByIdAccessor;\n         (void)NumGetByIdProto;\n         (void)NumGetByIdNotFound;\n #endif\n #ifdef HERMES_SLOW_DEBUG\n         auto *savedClass = cacheIdx != hbc::PROPERTY_CACHING_DISABLED\n             ? cacheEntry->clazz.get(runtime, &runtime->getHeap())\n             : nullptr;\n #endif\n         ++NumGetByIdSlow;\n         CAPTURE_IP_ASSIGN(\n             resPH,\n             JSObject::getNamed_RJS(\n                 Handle<JSObject>::vmcast(&O2REG(GetById)),\n                 runtime,\n                 id,\n                 !tryProp ? defaultPropOpFlags\n                          : defaultPropOpFlags.plusMustExist(),\n                 cacheIdx != hbc::PROPERTY_CACHING_DISABLED ? cacheEntry\n                                                            : nullptr));\n         if (LLVM_UNLIKELY(resPH == ExecutionStatus::EXCEPTION)) {\n           goto exception;\n         }\n #ifdef HERMES_SLOW_DEBUG\n         if (cacheIdx != hbc::PROPERTY_CACHING_DISABLED && savedClass &&\n             cacheEntry->clazz.get(runtime, &runtime->getHeap()) != savedClass) {\n           ++NumGetByIdCacheEvicts;\n         }\n #endif\n       } else {\n         ++NumGetByIdTransient;\n         assert(!tryProp && \"TryGetById can only be used on the global object\");\n         CAPTURE_IP_ASSIGN(\n             resPH,\n             Interpreter::getByIdTransient_RJS(\n                 runtime, Handle<>(&O2REG(GetById)), ID(idVal)));\n         if (LLVM_UNLIKELY(resPH == ExecutionStatus::EXCEPTION)) {\n           goto exception;\n         }\n       }\n       O1REG(GetById) = resPH->get();\n       gcScope.flushToSmallCount(KEEP_HANDLES);\n       ip = nextIP;\n       DISPATCH;\n     }\n \n       CASE(TryPutByIdLong) {\n         tryProp = true;\n         idVal = ip->iTryPutByIdLong.op4;\n         nextIP = NEXTINST(TryPutByIdLong);\n         goto putById;\n       }\n       CASE(PutByIdLong) {\n         tryProp = false;\n         idVal = ip->iPutByIdLong.op4;\n         nextIP = NEXTINST(PutByIdLong);\n         goto putById;\n       }\n       CASE(TryPutById) {\n         tryProp = true;\n         idVal = ip->iTryPutById.op4;\n         nextIP = NEXTINST(TryPutById);\n         goto putById;\n       }\n       CASE(PutById) {\n         tryProp = false;\n         idVal = ip->iPutById.op4;\n         nextIP = NEXTINST(PutById);\n       }\n     putById : {\n       ++NumPutById;\n       if (LLVM_LIKELY(O1REG(PutById).isObject())) {\n         auto *obj = vmcast<JSObject>(O1REG(PutById));\n         auto cacheIdx = ip->iPutById.op3;\n         auto *cacheEntry = curCodeBlock->getWriteCacheEntry(cacheIdx);\n \n #ifdef HERMESVM_PROFILER_BB\n         {\n           HERMES_SLOW_ASSERT(\n               gcScope.getHandleCountDbg() == KEEP_HANDLES &&\n               \"unaccounted handles were created\");\n           auto objHandle = runtime->makeHandle(obj);\n           auto cacheHCPtr = vmcast_or_null<HiddenClass>(static_cast<GCCell *>(\n               cacheEntry->clazz.get(runtime, &runtime->getHeap())));\n           CAPTURE_IP(runtime->recordHiddenClass(\n               curCodeBlock, ip, ID(idVal), obj->getClass(runtime), cacheHCPtr));\n           obj = objHandle.get();\n         }\n         gcScope.flushToSmallCount(KEEP_HANDLES);\n #endif\n         auto clazzGCPtr = obj->getClassGCPtr();\n         if (LLVM_LIKELY(cacheEntry->clazz == clazzGCPtr.getStorageType())) {\n           ++NumPutByIdCacheHits;\n           CAPTURE_IP(JSObject::setNamedSlotValue<PropStorage::Inline::Yes>(\n               obj, runtime, cacheEntry->slot, O2REG(PutById)));\n           ip = nextIP;\n           DISPATCH;\n         }\n         auto id = ID(idVal);\n         NamedPropertyDescriptor desc;\n         CAPTURE_IP_ASSIGN(\n             OptValue<bool> hasOwnProp,\n             JSObject::tryGetOwnNamedDescriptorFast(obj, runtime, id, desc));\n         if (LLVM_LIKELY(hasOwnProp.hasValue() && hasOwnProp.getValue()) &&\n             !desc.flags.accessor && desc.flags.writable &&\n             !desc.flags.internalSetter) {\n           ++NumPutByIdFastPaths;\n \n           auto *clazz = clazzGCPtr.getNonNull(runtime);\n           if (LLVM_LIKELY(!clazz->isDictionary()) &&\n               LLVM_LIKELY(cacheIdx != hbc::PROPERTY_CACHING_DISABLED)) {\n #ifdef HERMES_SLOW_DEBUG\n             if (cacheEntry->clazz &&\n                 cacheEntry->clazz != clazzGCPtr.getStorageType())\n               ++NumPutByIdCacheEvicts;\n #else\n             (void)NumPutByIdCacheEvicts;\n #endif\n             cacheEntry->clazz = clazzGCPtr.getStorageType();\n             cacheEntry->slot = desc.slot;\n           }\n \n           CAPTURE_IP(JSObject::setNamedSlotValue(\n               obj, runtime, desc.slot, O2REG(PutById)));\n           ip = nextIP;\n           DISPATCH;\n         }\n \n         CAPTURE_IP_ASSIGN(\n             auto putRes,\n             JSObject::putNamed_RJS(\n                 Handle<JSObject>::vmcast(&O1REG(PutById)),\n                 runtime,\n                 id,\n                 Handle<>(&O2REG(PutById)),\n                 !tryProp ? defaultPropOpFlags\n                          : defaultPropOpFlags.plusMustExist()));\n         if (LLVM_UNLIKELY(putRes == ExecutionStatus::EXCEPTION)) {\n           goto exception;\n         }\n       } else {\n         ++NumPutByIdTransient;\n         assert(!tryProp && \"TryPutById can only be used on the global object\");\n         CAPTURE_IP_ASSIGN(\n             auto retStatus,\n             Interpreter::putByIdTransient_RJS(\n                 runtime,\n                 Handle<>(&O1REG(PutById)),\n                 ID(idVal),\n                 Handle<>(&O2REG(PutById)),\n                 strictMode));\n         if (retStatus == ExecutionStatus::EXCEPTION) {\n           goto exception;\n         }\n       }\n       gcScope.flushToSmallCount(KEEP_HANDLES);\n       ip = nextIP;\n       DISPATCH;\n     }\n \n       CASE(GetByVal) {\n         CallResult<HermesValue> propRes{ExecutionStatus::EXCEPTION};\n         if (LLVM_LIKELY(O2REG(GetByVal).isObject())) {\n           CAPTURE_IP_ASSIGN(\n               resPH,\n               JSObject::getComputed_RJS(\n                   Handle<JSObject>::vmcast(&O2REG(GetByVal)),\n                   runtime,\n                   Handle<>(&O3REG(GetByVal))));\n           if (LLVM_UNLIKELY(resPH == ExecutionStatus::EXCEPTION)) {\n             goto exception;\n           }\n         } else {\n           CAPTURE_IP_ASSIGN(\n               resPH,\n               Interpreter::getByValTransient_RJS(\n                   runtime,\n                   Handle<>(&O2REG(GetByVal)),\n                   Handle<>(&O3REG(GetByVal))));\n           if (LLVM_UNLIKELY(resPH == ExecutionStatus::EXCEPTION)) {\n             goto exception;\n           }\n         }\n         gcScope.flushToSmallCount(KEEP_HANDLES);\n         O1REG(GetByVal) = resPH->get();\n         ip = NEXTINST(GetByVal);\n         DISPATCH;\n       }\n \n       CASE(PutByVal) {\n         if (LLVM_LIKELY(O1REG(PutByVal).isObject())) {\n           CAPTURE_IP_ASSIGN(\n               auto putRes,\n               JSObject::putComputed_RJS(\n                   Handle<JSObject>::vmcast(&O1REG(PutByVal)),\n                   runtime,\n                   Handle<>(&O2REG(PutByVal)),\n                   Handle<>(&O3REG(PutByVal)),\n                   defaultPropOpFlags));\n           if (LLVM_UNLIKELY(putRes == ExecutionStatus::EXCEPTION)) {\n             goto exception;\n           }\n         } else {\n           CAPTURE_IP_ASSIGN(\n               auto retStatus,\n               Interpreter::putByValTransient_RJS(\n                   runtime,\n                   Handle<>(&O1REG(PutByVal)),\n                   Handle<>(&O2REG(PutByVal)),\n                   Handle<>(&O3REG(PutByVal)),\n                   strictMode));\n           if (LLVM_UNLIKELY(retStatus == ExecutionStatus::EXCEPTION)) {\n             goto exception;\n           }\n         }\n         gcScope.flushToSmallCount(KEEP_HANDLES);\n         ip = NEXTINST(PutByVal);\n         DISPATCH;\n       }\n \n       CASE(PutOwnByIndexL) {\n         nextIP = NEXTINST(PutOwnByIndexL);\n         idVal = ip->iPutOwnByIndexL.op3;\n         goto putOwnByIndex;\n       }\n       CASE(PutOwnByIndex) {\n         nextIP = NEXTINST(PutOwnByIndex);\n         idVal = ip->iPutOwnByIndex.op3;\n       }\n     putOwnByIndex : {\n       tmpHandle = HermesValue::encodeDoubleValue(idVal);\n       CAPTURE_IP(JSObject::defineOwnComputedPrimitive(\n           Handle<JSObject>::vmcast(&O1REG(PutOwnByIndex)),\n           runtime,\n           tmpHandle,\n           DefinePropertyFlags::getDefaultNewPropertyFlags(),\n           Handle<>(&O2REG(PutOwnByIndex))));\n       gcScope.flushToSmallCount(KEEP_HANDLES);\n       tmpHandle.clear();\n       ip = nextIP;\n       DISPATCH;\n     }\n \n       CASE(GetPNameList) {\n         CAPTURE_IP_ASSIGN(\n             auto pRes, handleGetPNameList(runtime, frameRegs, ip));\n         if (LLVM_UNLIKELY(pRes == ExecutionStatus::EXCEPTION)) {\n           goto exception;\n         }\n         gcScope.flushToSmallCount(KEEP_HANDLES);\n         ip = NEXTINST(GetPNameList);\n         DISPATCH;\n       }\n \n       CASE(GetNextPName) {\n         {\n           assert(\n               vmisa<BigStorage>(O2REG(GetNextPName)) &&\n               \"GetNextPName's second op must be BigStorage\");\n           auto obj = Handle<JSObject>::vmcast(&O3REG(GetNextPName));\n           auto arr = Handle<BigStorage>::vmcast(&O2REG(GetNextPName));\n           uint32_t idx = O4REG(GetNextPName).getNumber();\n           uint32_t size = O5REG(GetNextPName).getNumber();\n           MutableHandle<JSObject> propObj{runtime};\n           while (idx < size) {\n             tmpHandle = arr->at(idx);\n             ComputedPropertyDescriptor desc;\n             CAPTURE_IP(JSObject::getComputedPrimitiveDescriptor(\n                 obj, runtime, tmpHandle, propObj, desc));\n             if (LLVM_LIKELY(propObj))\n               break;\n             ++idx;\n           }\n           if (idx < size) {\n             if (tmpHandle->isNumber()) {\n               CAPTURE_IP_ASSIGN(auto status, toString_RJS(runtime, tmpHandle));\n               assert(\n                   status == ExecutionStatus::RETURNED &&\n                   \"toString on number cannot fail\");\n               tmpHandle = status->getHermesValue();\n             }\n             O1REG(GetNextPName) = tmpHandle.get();\n             O4REG(GetNextPName) = HermesValue::encodeNumberValue(idx + 1);\n           } else {\n             O1REG(GetNextPName) = HermesValue::encodeUndefinedValue();\n           }\n         }\n         gcScope.flushToSmallCount(KEEP_HANDLES);\n         tmpHandle.clear();\n         ip = NEXTINST(GetNextPName);\n         DISPATCH;\n       }\n \n       CASE(ToNumber) {\n         if (LLVM_LIKELY(O2REG(ToNumber).isNumber())) {\n           O1REG(ToNumber) = O2REG(ToNumber);\n           ip = NEXTINST(ToNumber);\n         } else {\n           CAPTURE_IP_ASSIGN(\n               res, toNumber_RJS(runtime, Handle<>(&O2REG(ToNumber))));\n           if (res == ExecutionStatus::EXCEPTION)\n             goto exception;\n           gcScope.flushToSmallCount(KEEP_HANDLES);\n           O1REG(ToNumber) = res.getValue();\n           ip = NEXTINST(ToNumber);\n         }\n         DISPATCH;\n       }\n \n       CASE(ToInt32) {\n         CAPTURE_IP_ASSIGN(res, toInt32_RJS(runtime, Handle<>(&O2REG(ToInt32))));\n         if (LLVM_UNLIKELY(res == ExecutionStatus::EXCEPTION))\n           goto exception;\n         gcScope.flushToSmallCount(KEEP_HANDLES);\n         O1REG(ToInt32) = res.getValue();\n         ip = NEXTINST(ToInt32);\n         DISPATCH;\n       }\n \n       CASE(AddEmptyString) {\n         if (LLVM_LIKELY(O2REG(AddEmptyString).isString())) {\n           O1REG(AddEmptyString) = O2REG(AddEmptyString);\n           ip = NEXTINST(AddEmptyString);\n         } else {\n           CAPTURE_IP_ASSIGN(\n               res,\n               toPrimitive_RJS(\n                   runtime,\n                   Handle<>(&O2REG(AddEmptyString)),\n                   PreferredType::NONE));\n           if (LLVM_UNLIKELY(res == ExecutionStatus::EXCEPTION))\n             goto exception;\n           tmpHandle = res.getValue();\n           CAPTURE_IP_ASSIGN(auto strRes, toString_RJS(runtime, tmpHandle));\n           if (LLVM_UNLIKELY(strRes == ExecutionStatus::EXCEPTION))\n             goto exception;\n           tmpHandle.clear();\n           gcScope.flushToSmallCount(KEEP_HANDLES);\n           O1REG(AddEmptyString) = strRes->getHermesValue();\n           ip = NEXTINST(AddEmptyString);\n         }\n         DISPATCH;\n       }\n \n       CASE(Jmp) {\n         ip = IPADD(ip->iJmp.op1);\n         DISPATCH;\n       }\n       CASE(JmpLong) {\n         ip = IPADD(ip->iJmpLong.op1);\n         DISPATCH;\n       }\n       CASE(JmpTrue) {\n         if (toBoolean(O2REG(JmpTrue)))\n           ip = IPADD(ip->iJmpTrue.op1);\n         else\n           ip = NEXTINST(JmpTrue);\n         DISPATCH;\n       }\n       CASE(JmpTrueLong) {\n         if (toBoolean(O2REG(JmpTrueLong)))\n           ip = IPADD(ip->iJmpTrueLong.op1);\n         else\n           ip = NEXTINST(JmpTrueLong);\n         DISPATCH;\n       }\n       CASE(JmpFalse) {\n         if (!toBoolean(O2REG(JmpFalse)))\n           ip = IPADD(ip->iJmpFalse.op1);\n         else\n           ip = NEXTINST(JmpFalse);\n         DISPATCH;\n       }\n       CASE(JmpFalseLong) {\n         if (!toBoolean(O2REG(JmpFalseLong)))\n           ip = IPADD(ip->iJmpFalseLong.op1);\n         else\n           ip = NEXTINST(JmpFalseLong);\n         DISPATCH;\n       }\n       CASE(JmpUndefined) {\n         if (O2REG(JmpUndefined).isUndefined())\n           ip = IPADD(ip->iJmpUndefined.op1);\n         else\n           ip = NEXTINST(JmpUndefined);\n         DISPATCH;\n       }\n       CASE(JmpUndefinedLong) {\n         if (O2REG(JmpUndefinedLong).isUndefined())\n           ip = IPADD(ip->iJmpUndefinedLong.op1);\n         else\n           ip = NEXTINST(JmpUndefinedLong);\n         DISPATCH;\n       }\n       CASE(Add) {\n         if (LLVM_LIKELY(\n                 O2REG(Add).isNumber() &&\n                 O3REG(Add).isNumber())) {\n           CASE(AddN) {\n             O1REG(Add) = HermesValue::encodeDoubleValue(\n                 O2REG(Add).getNumber() + O3REG(Add).getNumber());\n             ip = NEXTINST(Add);\n             DISPATCH;\n           }\n         }\n         CAPTURE_IP_ASSIGN(\n             res,\n             addOp_RJS(runtime, Handle<>(&O2REG(Add)), Handle<>(&O3REG(Add))));\n         if (res == ExecutionStatus::EXCEPTION) {\n           goto exception;\n         }\n         gcScope.flushToSmallCount(KEEP_HANDLES);\n         O1REG(Add) = res.getValue();\n         ip = NEXTINST(Add);\n         DISPATCH;\n       }\n \n       CASE(BitNot) {\n         if (LLVM_LIKELY(O2REG(BitNot).isNumber())) {\n           O1REG(BitNot) = HermesValue::encodeDoubleValue(\n               ~hermes::truncateToInt32(O2REG(BitNot).getNumber()));\n           ip = NEXTINST(BitNot);\n           DISPATCH;\n         }\n         CAPTURE_IP_ASSIGN(res, toInt32_RJS(runtime, Handle<>(&O2REG(BitNot))));\n         if (res == ExecutionStatus::EXCEPTION) {\n           goto exception;\n         }\n         gcScope.flushToSmallCount(KEEP_HANDLES);\n         O1REG(BitNot) = HermesValue::encodeDoubleValue(\n             ~static_cast<int32_t>(res->getNumber()));\n         ip = NEXTINST(BitNot);\n         DISPATCH;\n       }\n \n       CASE(GetArgumentsLength) {\n         if (O2REG(GetArgumentsLength).isUndefined()) {\n           O1REG(GetArgumentsLength) =\n               HermesValue::encodeNumberValue(FRAME.getArgCount());\n           ip = NEXTINST(GetArgumentsLength);\n           DISPATCH;\n         }\n         assert(\n             O2REG(GetArgumentsLength).isObject() &&\n             \"arguments lazy register is not an object\");\n         CAPTURE_IP_ASSIGN(\n             resPH,\n             JSObject::getNamed_RJS(\n                 Handle<JSObject>::vmcast(&O2REG(GetArgumentsLength)),\n", "target": "// fix_start\n\n#define DONT_CAPTURE_IP(expr)      \\\n  do {                             \\\n    NoAllocScope noAlloc(runtime); \\\n    (void)expr;                    \\\n  } while (false)\n// fix_end\n// fix_start\n        DONT_CAPTURE_IP(\n            saveGenerator(runtime, frameRegs, IPADD(ip->iSaveGenerator.op1)));\n        ip = NEXTINST(SaveGenerator);\n        DISPATCH;\n// fix_end\n// fix_start\n        DONT_CAPTURE_IP(saveGenerator(\n            runtime, frameRegs, IPADD(ip->iSaveGeneratorLong.op1)));\n        ip = NEXTINST(SaveGeneratorLong);\n        DISPATCH;\n      }\n// fix_end\n", "cwe": "CWE-703", "cwe_name": "Improper Check or Handling of Exceptional Conditions", "cve": "CVE-2020-1914", "cve_desc": "A logic vulnerability when handling the SaveGeneratorLong instruction in Facebook Hermes prior to commit b2021df620824627f5a8c96615edbd1eb7fdddfc allows attackers to potentially read out of bounds or theoretically execute arbitrary code via crafted JavaScript. Note that this is only exploitable if the application using Hermes permits evaluation of untrusted JavaScript. Hence, most React Native applications are not affected.", "project": "hermes", "idx": 199924}
{"source": " rfbSendRectEncodingRaw(rfbClientPtr cl,\n                        int x,\n                        int y,\n                        int w,\n                        int h)\n {\n     rfbFramebufferUpdateRectHeader rect;\n     int nlines;\n     int bytesPerLine = w * (cl->format.bitsPerPixel / 8);\n     char *fbptr = (cl->scaledScreen->frameBuffer + (cl->scaledScreen->paddedWidthInBytes * y)\n                    + (x * (cl->scaledScreen->bitsPerPixel / 8)));\n// bug_start\n// bug_end\n \n     if (cl->ublen > 0) {\n         if (!rfbSendUpdateBuf(cl))\n             return FALSE;\n     }\n \n     rect.r.x = Swap16IfLE(x);\n     rect.r.y = Swap16IfLE(y);\n     rect.r.w = Swap16IfLE(w);\n     rect.r.h = Swap16IfLE(h);\n     rect.encoding = Swap32IfLE(rfbEncodingRaw);\n \n     memcpy(&cl->updateBuf[cl->ublen], (char *)&rect,sz_rfbFramebufferUpdateRectHeader);\n     cl->ublen += sz_rfbFramebufferUpdateRectHeader;\n \n \n     rfbStatRecordEncodingSent(cl, rfbEncodingRaw, sz_rfbFramebufferUpdateRectHeader + bytesPerLine * h,\n         sz_rfbFramebufferUpdateRectHeader + bytesPerLine * h);\n \n     nlines = (UPDATE_BUF_SIZE - cl->ublen) / bytesPerLine;\n \n     while (TRUE) {\n         if (nlines > h)\n             nlines = h;\n \n         (*cl->translateFn)(cl->translateLookupTable,\n \t\t\t   &(cl->screen->serverFormat),\n                            &cl->format, fbptr, &cl->updateBuf[cl->ublen],\n                            cl->scaledScreen->paddedWidthInBytes, w, nlines);\n \n         cl->ublen += nlines * bytesPerLine;\n         h -= nlines;\n \n         if (h == 0)\n             return TRUE;\n \n \n         if (!rfbSendUpdateBuf(cl))\n             return FALSE;\n \n         fbptr += (cl->scaledScreen->paddedWidthInBytes * nlines);\n \n         nlines = (UPDATE_BUF_SIZE - cl->ublen) / bytesPerLine;\n         if (nlines == 0) {\n             rfbErr(\"rfbSendRectEncodingRaw: send buffer too small for %d \"\n                    \"bytes per line\\n\", bytesPerLine);\n             rfbCloseClient(cl);\n             return FALSE;\n         }\n     }\n }\n \n", "target": "// fix_start\n\n    if(!h || !w)\n\treturn TRUE;\n// fix_end\n", "cwe": "CWE-369", "cwe_name": "Divide By Zero", "cve": "CVE-2020-25708", "cve_desc": "A divide by zero issue was found to occur in libvncserver-0.9.12. A malicious client could use this flaw to send a specially crafted message that, when processed by the VNC server, would lead to a floating point exception, resulting in a denial of service.", "project": "libvncserver", "idx": 199948}
{"source": " pixFewColorsOctcubeQuantMixed(PIX       *pixs,\n                               l_int32    level,\n                               l_int32    darkthresh,\n                               l_int32    lightthresh,\n                               l_int32    diffthresh,\n                               l_float32  minfract,\n                               l_int32    maxspan)\n {\n l_int32    i, j, w, h, wplc, wplm, wpld, ncolors, index;\n l_int32    rval, gval, bval, val, minval, maxval;\n l_int32   *lut;\n l_uint32  *datac, *datam, *datad, *linec, *linem, *lined;\n// bug_start\nPIX       *pixc, *pixm, *pixg, *pixd;\n// bug_end\n PIXCMAP   *cmap, *cmapd;\n \n     PROCNAME(\"pixFewColorsOctcubeQuantMixed\");\n \n     if (!pixs || pixGetDepth(pixs) != 32)\n         return (PIX *)ERROR_PTR(\"pixs undefined or not 32 bpp\", procName, NULL);\n     if (level <= 0) level = 3;\n     if (level > 6)\n         return (PIX *)ERROR_PTR(\"invalid level\", procName, NULL);\n     if (darkthresh <= 0) darkthresh = 20;\n     if (lightthresh <= 0) lightthresh = 244;\n     if (diffthresh <= 0) diffthresh = 20;\n     if (minfract <= 0.0) minfract = 0.05;\n     if (maxspan <= 2) maxspan = 15;\n \n// bug_start\n    if ((pixc = pixFewColorsOctcubeQuant1(pixs, level)) == NULL)\n// bug_end\n         return (PIX *)ERROR_PTR(\"too many colors\", procName, NULL);\n// bug_start\n// bug_end\n \n     cmap = pixGetColormap(pixc);\n     ncolors = pixcmapGetCount(cmap);\n     cmapd = pixcmapCreate(8);\n     lut = (l_int32 *)LEPT_CALLOC(256, sizeof(l_int32));\n     for (i = 0; i < 256; i++)\n         lut[i] = -1;\n     for (i = 0, index = 0; i < ncolors; i++) {\n         pixcmapGetColor(cmap, i, &rval, &gval, &bval);\n         minval = L_MIN(rval, gval);\n         minval = L_MIN(minval, bval);\n         if (minval > lightthresh)\n             continue;\n         maxval = L_MAX(rval, gval);\n         maxval = L_MAX(maxval, bval);\n         if (maxval < darkthresh)\n             continue;\n \n         if (maxval - minval >= diffthresh) {\n             pixcmapAddColor(cmapd, rval, gval, bval);\n             lut[i] = index;\n             index++;\n         }\n     }\n \n     pixGetDimensions(pixs, &w, &h, NULL);\n     pixd = pixCreate(w, h, 8);\n     pixSetColormap(pixd, cmapd);\n     pixm = pixCreate(w, h, 1);\n     datac = pixGetData(pixc);\n     datam = pixGetData(pixm);\n     datad = pixGetData(pixd);\n     wplc = pixGetWpl(pixc);\n     wplm = pixGetWpl(pixm);\n     wpld = pixGetWpl(pixd);\n     for (i = 0; i < h; i++) {\n         linec = datac + i * wplc;\n         linem = datam + i * wplm;\n         lined = datad + i * wpld;\n         for (j = 0; j < w; j++) {\n             val = GET_DATA_BYTE(linec, j);\n             if (lut[val] == -1)\n                 SET_DATA_BIT(linem, j);\n             else\n                 SET_DATA_BYTE(lined, j, lut[val]);\n         }\n     }\n \n     pixg = pixConvertTo8(pixs, 0);\n     pixGrayQuantFromHisto(pixd, pixg, pixm, minfract, maxspan);\n \n     LEPT_FREE(lut);\n     pixDestroy(&pixc);\n     pixDestroy(&pixm);\n     pixDestroy(&pixg);\n     return pixd;\n }\n \n", "target": "// fix_start\nPIX       *pix1, *pixc, *pixm, *pixg, *pixd;\n// fix_end\n// fix_start\n    if ((pix1 = pixFewColorsOctcubeQuant1(pixs, level)) == NULL)\n// fix_end\n// fix_start\n    pixc = pixConvertTo8(pix1, 1);\n    pixDestroy(&pix1);\n// fix_end\n", "cwe": "CWE-125", "cwe_name": "Out-of-bounds Read", "cve": "CVE-2020-36281", "cve_desc": "Leptonica before 1.80.0 allows a heap-based buffer over-read in pixFewColorsOctcubeQuantMixed in colorquant1.c.", "project": "leptonica", "idx": 199976}
{"source": " void rfbScaledScreenUpdateRect(rfbScreenInfoPtr screen, rfbScreenInfoPtr ptr, int x0, int y0, int w0, int h0)\n {\n     int x,y,w,v,z;\n     int x1, y1, w1, h1;\n     int bitsPerPixel, bytesPerPixel, bytesPerLine, areaX, areaY, area2;\n     unsigned char *srcptr, *dstptr;\n \n     if (screen==ptr) return;\n \n     x1 = x0;\n     y1 = y0;\n     w1 = w0;\n     h1 = h0;\n \n     rfbScaledCorrection(screen, ptr, &x1, &y1, &w1, &h1, \"rfbScaledScreenUpdateRect\");\n     x0 = ScaleX(ptr, screen, x1);\n     y0 = ScaleY(ptr, screen, y1);\n     w0 = ScaleX(ptr, screen, w1);\n     h0 = ScaleY(ptr, screen, h1);\n \n     bitsPerPixel = screen->bitsPerPixel;\n     bytesPerPixel = bitsPerPixel / 8;\n     bytesPerLine = w1 * bytesPerPixel;\n     srcptr = (unsigned char *)(screen->frameBuffer +\n      (y0 * screen->paddedWidthInBytes + x0 * bytesPerPixel));\n     dstptr = (unsigned char *)(ptr->frameBuffer +\n      ( y1 * ptr->paddedWidthInBytes + x1 * bytesPerPixel));\n     areaX = ScaleX(ptr,screen,1);\n     areaY = ScaleY(ptr,screen,1);\n     area2 = areaX*areaY;\n \n \n     if ((x1+w1) > (ptr->width))\n     {\n       if (x1==0) w1=ptr->width; else x1 = ptr->width - w1;\n     }\n     if ((y1+h1) > (ptr->height))\n     {\n       if (y1==0) h1=ptr->height; else y1 = ptr->height - h1;\n     }\n \n     if (screen->serverFormat.trueColour) {\n       unsigned char *srcptr2;\n       unsigned long pixel_value, red, green, blue;\n       unsigned int redShift = screen->serverFormat.redShift;\n       unsigned int greenShift = screen->serverFormat.greenShift;\n       unsigned int blueShift = screen->serverFormat.blueShift;\n       unsigned long redMax = screen->serverFormat.redMax;\n       unsigned long greenMax = screen->serverFormat.greenMax;\n       unsigned long blueMax = screen->serverFormat.blueMax;\n \n      for (y = 0; y < h1; y++) {\n        for (x = 0; x < w1; x++) {\n          red = green = blue = 0;\n          for (w = 0; w < areaX; w++) {\n            for (v = 0; v < areaY; v++) {\n              srcptr2 = &srcptr[(((x * areaX) + w) * bytesPerPixel) +\n                                (v * screen->paddedWidthInBytes)];\n              pixel_value = 0;\n \n \n              switch (bytesPerPixel) {\n              case 4: pixel_value = *((unsigned int *)srcptr2);   break;\n              case 2: pixel_value = *((unsigned short *)srcptr2); break;\n              case 1: pixel_value = *((unsigned char *)srcptr2);  break;\n              default:\n                for (z = 0; z < bytesPerPixel; z++)\n// bug_start\n                 pixel_value += (srcptr2[z] << (8 * z));\n// bug_end\n                 break;\n               }\n \n             red += ((pixel_value >> redShift) & redMax);\n             green += ((pixel_value >> greenShift) & greenMax);\n             blue += ((pixel_value >> blueShift) & blueMax);\n \n            }\n          }\n          red /= area2;\n          green /= area2;\n          blue /= area2;\n          pixel_value = ((red & redMax) << redShift) | ((green & greenMax) << greenShift) | ((blue & blueMax) << blueShift);\n \n          switch (bytesPerPixel) {\n          case 4: *((unsigned int *)dstptr)   = (unsigned int)   pixel_value; break;\n          case 2: *((unsigned short *)dstptr) = (unsigned short) pixel_value; break;\n          case 1: *((unsigned char *)dstptr)  = (unsigned char)  pixel_value; break;\n          default:\n            for (z = 0; z < bytesPerPixel; z++)\n              dstptr[z]=(pixel_value >> (8 * z)) & 0xff;\n             break;\n           }\n           dstptr += bytesPerPixel;\n        }\n        srcptr += (screen->paddedWidthInBytes * areaY);\n        dstptr += (ptr->paddedWidthInBytes - bytesPerLine);\n      }\n    } else\n    {\n      for (y = y1; y < (y1+h1); y++) {\n        for (x = x1; x < (x1+w1); x++)\n          memcpy (&ptr->frameBuffer[(y *ptr->paddedWidthInBytes) + (x * bytesPerPixel)],\n                  &screen->frameBuffer[(y * areaY * screen->paddedWidthInBytes) + (x *areaX * bytesPerPixel)], bytesPerPixel);\n      }\n   }\n }\n \n", "target": "// fix_start\n                 pixel_value += ((unsigned long)srcptr2[z] << (8 * z));\n// fix_end\n", "cwe": "CWE-787", "cwe_name": "Out-of-bounds Write", "cve": "CVE-2020-14401", "cve_desc": "An issue was discovered in LibVNCServer before 0.9.13. libvncserver/scale.c has a pixel_value integer overflow.", "project": "libvncserver", "idx": 199993}
{"source": "     yaffsfs_istat(TSK_FS_INFO *fs, TSK_FS_ISTAT_FLAG_ENUM flags, FILE * hFile, TSK_INUM_T inum,\n     TSK_DADDR_T numblock, int32_t sec_skew)\n {\n     TSK_FS_META *fs_meta;\n     TSK_FS_FILE *fs_file;\n     YAFFSFS_INFO *yfs = (YAFFSFS_INFO *)fs;\n     char ls[12];\n     YAFFSFS_PRINT_ADDR print;\n// bug_start\n    char timeBuf[32];\n// bug_end\n     YaffsCacheObject * obj = NULL;\n     YaffsCacheVersion * version = NULL;\n     YaffsHeader * header = NULL;\n \n     yaffscache_version_find_by_inode(yfs, inum, &version, &obj);\n \n     if ((fs_file = tsk_fs_file_open_meta(fs, NULL, inum)) == NULL) {\n         return 1;\n     }\n     fs_meta = fs_file->meta;\n \n     tsk_fprintf(hFile, \"inode: %\" PRIuINUM \"\\n\", inum);\n     tsk_fprintf(hFile, \"%sAllocated\\n\",\n         (fs_meta->flags & TSK_FS_META_FLAG_ALLOC) ? \"\" : \"Not \");\n \n     if (fs_meta->link)\n         tsk_fprintf(hFile, \"symbolic link to: %s\\n\", fs_meta->link);\n \n     tsk_fprintf(hFile, \"uid / gid: %\" PRIuUID \" / %\" PRIuGID \"\\n\",\n         fs_meta->uid, fs_meta->gid);\n \n     tsk_fs_meta_make_ls(fs_meta, ls, sizeof(ls));\n     tsk_fprintf(hFile, \"mode: %s\\n\", ls);\n \n     tsk_fprintf(hFile, \"size: %\" PRIdOFF \"\\n\", fs_meta->size);\n     tsk_fprintf(hFile, \"num of links: %d\\n\", fs_meta->nlink);\n \n     if(version != NULL){\n         yaffsfs_read_header(yfs, &header, version->ycv_header_chunk->ycc_offset);\n         if(header != NULL){\n             tsk_fprintf(hFile, \"Name: %s\\n\", header->name);\n         }\n     }\n \n     if (sec_skew != 0) {\n         tsk_fprintf(hFile, \"\\nAdjusted Inode Times:\\n\");\n         fs_meta->mtime -= sec_skew;\n         fs_meta->atime -= sec_skew;\n         fs_meta->ctime -= sec_skew;\n \n         tsk_fprintf(hFile, \"Accessed:\\t%s\\n\",\n             tsk_fs_time_to_str(fs_meta->atime, timeBuf));\n         tsk_fprintf(hFile, \"File Modified:\\t%s\\n\",\n             tsk_fs_time_to_str(fs_meta->mtime, timeBuf));\n         tsk_fprintf(hFile, \"Inode Modified:\\t%s\\n\",\n             tsk_fs_time_to_str(fs_meta->ctime, timeBuf));\n \n         fs_meta->mtime += sec_skew;\n         fs_meta->atime += sec_skew;\n         fs_meta->ctime += sec_skew;\n \n         tsk_fprintf(hFile, \"\\nOriginal Inode Times:\\n\");\n     }\n     else {\n         tsk_fprintf(hFile, \"\\nInode Times:\\n\");\n     }\n \n     tsk_fprintf(hFile, \"Accessed:\\t%s\\n\",\n         tsk_fs_time_to_str(fs_meta->atime, timeBuf));\n     tsk_fprintf(hFile, \"File Modified:\\t%s\\n\",\n         tsk_fs_time_to_str(fs_meta->mtime, timeBuf));\n     tsk_fprintf(hFile, \"Inode Modified:\\t%s\\n\",\n         tsk_fs_time_to_str(fs_meta->ctime, timeBuf));\n \n     if(version != NULL){\n         tsk_fprintf(hFile, \"\\nHeader Chunk:\\n\");\n         tsk_fprintf(hFile, \"%\" PRIuDADDR \"\\n\", (version->ycv_header_chunk->ycc_offset / (yfs->page_size + yfs->spare_size)));\n     }\n \n     if (numblock > 0) {\n         TSK_OFF_T lower_size = numblock * fs->block_size;\n         fs_meta->size = (lower_size < fs_meta->size)?(lower_size):(fs_meta->size);\n     }\n     tsk_fprintf(hFile, \"\\nData Chunks:\\n\");\n \n \n     if (flags & TSK_FS_ISTAT_RUNLIST){\n         const TSK_FS_ATTR *fs_attr_default =\n             tsk_fs_file_attr_get_type(fs_file,\n                 TSK_FS_ATTR_TYPE_DEFAULT, 0, 0);\n         if (fs_attr_default && (fs_attr_default->flags & TSK_FS_ATTR_NONRES)) {\n             if (tsk_fs_attr_print(fs_attr_default, hFile)) {\n                 tsk_fprintf(hFile, \"\\nError creating run lists  \");\n                 tsk_error_print(hFile);\n                 tsk_error_reset();\n             }\n         }\n     }\n     else {\n         print.idx = 0;\n         print.hFile = hFile;\n \n         if (tsk_fs_file_walk(fs_file, TSK_FS_FILE_WALK_FLAG_AONLY,\n             (TSK_FS_FILE_WALK_CB)print_addr_act, (void *)&print)) {\n             tsk_fprintf(hFile, \"\\nError reading file:  \");\n             tsk_error_print(hFile);\n             tsk_error_reset();\n         }\n         else if (print.idx != 0) {\n             tsk_fprintf(hFile, \"\\n\");\n         }\n     }\n \n     tsk_fs_file_close(fs_file);\n \n     return 0;\n }\n \n", "target": "// fix_start\n    char timeBuf[128];\n// fix_end\n", "cwe": "CWE-125", "cwe_name": "Out-of-bounds Read", "cve": "CVE-2020-10232", "cve_desc": "In version 4.8.0 and earlier of The Sleuth Kit (TSK), there is a stack buffer overflow vulnerability in the YAFFS file timestamp parsing logic in yaffsfs_istat() in fs/yaffs.c.", "project": "sleuthkit", "idx": 200108}
{"source": " xmlParseBalancedChunkMemoryRecover(xmlDocPtr doc, xmlSAXHandlerPtr sax,\n      void *user_data, int depth, const xmlChar *string, xmlNodePtr *lst,\n      int recover) {\n     xmlParserCtxtPtr ctxt;\n     xmlDocPtr newDoc;\n     xmlSAXHandlerPtr oldsax = NULL;\n     xmlNodePtr content, newRoot;\n     int size;\n     int ret = 0;\n \n     if (depth > 40) {\n \treturn(XML_ERR_ENTITY_LOOP);\n     }\n \n \n     if (lst != NULL)\n         *lst = NULL;\n     if (string == NULL)\n         return(-1);\n \n     size = xmlStrlen(string);\n \n     ctxt = xmlCreateMemoryParserCtxt((char *) string, size);\n     if (ctxt == NULL) return(-1);\n     ctxt->userData = ctxt;\n     if (sax != NULL) {\n \toldsax = ctxt->sax;\n         ctxt->sax = sax;\n \tif (user_data != NULL)\n \t    ctxt->userData = user_data;\n     }\n     newDoc = xmlNewDoc(BAD_CAST \"1.0\");\n     if (newDoc == NULL) {\n \txmlFreeParserCtxt(ctxt);\n \treturn(-1);\n     }\n     newDoc->properties = XML_DOC_INTERNAL;\n     if ((doc != NULL) && (doc->dict != NULL)) {\n         xmlDictFree(ctxt->dict);\n \tctxt->dict = doc->dict;\n \txmlDictReference(ctxt->dict);\n \tctxt->str_xml = xmlDictLookup(ctxt->dict, BAD_CAST \"xml\", 3);\n \tctxt->str_xmlns = xmlDictLookup(ctxt->dict, BAD_CAST \"xmlns\", 5);\n \tctxt->str_xml_ns = xmlDictLookup(ctxt->dict, XML_XML_NAMESPACE, 36);\n \tctxt->dictNames = 1;\n     } else {\n \txmlCtxtUseOptionsInternal(ctxt, XML_PARSE_NODICT, NULL);\n     }\n     if (doc != NULL) {\n \tnewDoc->intSubset = doc->intSubset;\n \tnewDoc->extSubset = doc->extSubset;\n     }\n     newRoot = xmlNewDocNode(newDoc, NULL, BAD_CAST \"pseudoroot\", NULL);\n     if (newRoot == NULL) {\n \tif (sax != NULL)\n \t    ctxt->sax = oldsax;\n \txmlFreeParserCtxt(ctxt);\n \tnewDoc->intSubset = NULL;\n \tnewDoc->extSubset = NULL;\n         xmlFreeDoc(newDoc);\n \treturn(-1);\n     }\n     xmlAddChild((xmlNodePtr) newDoc, newRoot);\n     nodePush(ctxt, newRoot);\n     if (doc == NULL) {\n \tctxt->myDoc = newDoc;\n     } else {\n \tctxt->myDoc = newDoc;\n \tnewDoc->children->doc = doc;\n \txmlSearchNsByHref(doc, (xmlNodePtr)doc, XML_XML_NAMESPACE);\n \tnewDoc->oldNs = doc->oldNs;\n     }\n     ctxt->instate = XML_PARSER_CONTENT;\n     ctxt->input_id = 2;\n     ctxt->depth = depth;\n \n     ctxt->validate = 0;\n     ctxt->loadsubset = 0;\n     xmlDetectSAX2(ctxt);\n \n     if ( doc != NULL ){\n         content = doc->children;\n         doc->children = NULL;\n         xmlParseContent(ctxt);\n         doc->children = content;\n     }\n     else {\n         xmlParseContent(ctxt);\n     }\n     if ((RAW == '<') && (NXT(1) == '/')) {\n \txmlFatalErr(ctxt, XML_ERR_NOT_WELL_BALANCED, NULL);\n     } else if (RAW != 0) {\n \txmlFatalErr(ctxt, XML_ERR_EXTRA_CONTENT, NULL);\n     }\n     if (ctxt->node != newDoc->children) {\n \txmlFatalErr(ctxt, XML_ERR_NOT_WELL_BALANCED, NULL);\n     }\n \n     if (!ctxt->wellFormed) {\n         if (ctxt->errNo == 0)\n \t    ret = 1;\n \telse\n \t    ret = ctxt->errNo;\n     } else {\n       ret = 0;\n     }\n \n     if ((lst != NULL) && ((ret == 0) || (recover == 1))) {\n \txmlNodePtr cur;\n \n \tcur = newDoc->children->children;\n \t*lst = cur;\n \twhile (cur != NULL) {\n \t    xmlSetTreeDoc(cur, doc);\n \t    cur->parent = NULL;\n \t    cur = cur->next;\n \t}\n \tnewDoc->children->children = NULL;\n     }\n \n     if (sax != NULL)\n \tctxt->sax = oldsax;\n     xmlFreeParserCtxt(ctxt);\n     newDoc->intSubset = NULL;\n     newDoc->extSubset = NULL;\n// bug_start\n    newDoc->oldNs = NULL;\n// bug_end\n     xmlFreeDoc(newDoc);\n \n     return(ret);\n }\n \n", "target": "// fix_start\n    if(doc != NULL)\n\tnewDoc->oldNs = NULL;\n// fix_end\n", "cwe": "CWE-401", "cwe_name": "Missing Release of Memory after Effective Lifetime", "cve": "CVE-2019-19956", "cve_desc": "xmlParseBalancedChunkMemoryRecover in parser.c in libxml2 before 2.9.10 has a memory leak related to newDoc->oldNs.", "project": "libxml2", "idx": 200109}
{"source": " void *_zend_shared_memdup(void *source, size_t size, zend_bool free_source TSRMLS_DC)\n {\n \tvoid **old_p, *retval;\n \n \tif (zend_hash_index_find(&xlat_table, (ulong)source, (void **)&old_p) == SUCCESS) {\n \t\treturn *old_p;\n \t}\n \tretval = ZCG(mem);;\n \tZCG(mem) = (void*)(((char*)ZCG(mem)) + ZEND_ALIGNED_SIZE(size));\n \tmemcpy(retval, source, size);\n// bug_start\n// bug_end\n \tif (free_source) {\n \t\tinterned_efree((char*)source);\n \t}\n// bug_start\n\tzend_shared_alloc_register_xlat_entry(source, retval);\n// bug_end\n \treturn retval;\n }\n \n", "target": "// fix_start\n\tzend_shared_alloc_register_xlat_entry(source, retval);\n// fix_end\n// fix_start\n// fix_end\n", "cwe": "CWE-416", "cwe_name": "Use After Free", "cve": "CVE-2015-1351", "cve_desc": "Use-after-free vulnerability in the _zend_shared_memdup function in zend_shared_alloc.c in the OPcache extension in PHP through 5.6.7 allows remote attackers to cause a denial of service or possibly have unspecified other impact via unknown vectors.", "project": "php-src", "idx": 200327}
{"source": " xmlEncodeEntitiesInternal(xmlDocPtr doc, const xmlChar *input, int attr) {\n     const xmlChar *cur = input;\n     xmlChar *buffer = NULL;\n     xmlChar *out = NULL;\n     size_t buffer_size = 0;\n     int html = 0;\n \n     if (input == NULL) return(NULL);\n     if (doc != NULL)\n         html = (doc->type == XML_HTML_DOCUMENT_NODE);\n \n     buffer_size = 1000;\n     buffer = (xmlChar *) xmlMalloc(buffer_size * sizeof(xmlChar));\n     if (buffer == NULL) {\n         xmlEntitiesErrMemory(\"xmlEncodeEntities: malloc failed\");\n \treturn(NULL);\n     }\n     out = buffer;\n \n     while (*cur != '\\0') {\n         size_t indx = out - buffer;\n         if (indx + 100 > buffer_size) {\n \n \t    growBufferReentrant();\n \t    out = &buffer[indx];\n \t}\n \n \tif (*cur == '<') {\n \t    const xmlChar *end;\n \n \t    if (html && attr &&\n \t        (cur[1] == '!') && (cur[2] == '-') && (cur[3] == '-') &&\n \t        ((end = xmlStrstr(cur, BAD_CAST \"-->\")) != NULL)) {\n \t        while (cur != end) {\n \t\t    *out++ = *cur++;\n \t\t    indx = out - buffer;\n \t\t    if (indx + 100 > buffer_size) {\n \t\t\tgrowBufferReentrant();\n \t\t\tout = &buffer[indx];\n \t\t    }\n \t\t}\n \t\t*out++ = *cur++;\n \t\t*out++ = *cur++;\n \t\t*out++ = *cur++;\n \t\tcontinue;\n \t    }\n \t    *out++ = '&';\n \t    *out++ = 'l';\n \t    *out++ = 't';\n \t    *out++ = ';';\n \t} else if (*cur == '>') {\n \t    *out++ = '&';\n \t    *out++ = 'g';\n \t    *out++ = 't';\n \t    *out++ = ';';\n \t} else if (*cur == '&') {\n \t    if (html && attr && (cur[1] == '{') &&\n \t        (strchr((const char *) cur, '}'))) {\n \t        while (*cur != '}') {\n \t\t    *out++ = *cur++;\n \t\t    indx = out - buffer;\n \t\t    if (indx + 100 > buffer_size) {\n \t\t\tgrowBufferReentrant();\n \t\t\tout = &buffer[indx];\n \t\t    }\n \t\t}\n \t\t*out++ = *cur++;\n \t\tcontinue;\n \t    }\n \t    *out++ = '&';\n \t    *out++ = 'a';\n \t    *out++ = 'm';\n \t    *out++ = 'p';\n \t    *out++ = ';';\n \t} else if (((*cur >= 0x20) && (*cur < 0x80)) ||\n \t    (*cur == '\\n') || (*cur == '\\t') || ((html) && (*cur == '\\r'))) {\n \t    *out++ = *cur;\n \t} else if (*cur >= 0x80) {\n \t    if (((doc != NULL) && (doc->encoding != NULL)) || (html)) {\n \t\t*out++ = *cur;\n \t    } else {\n \t\tchar buf[11], *ptr;\n \t\tint val = 0, l = 1;\n \n// bug_start\n\t\tif (*cur < 0xC0) {\n// bug_end\n \t\t    xmlEntitiesErr(XML_CHECK_NOT_UTF8,\n \t\t\t    \"xmlEncodeEntities: input not UTF-8\");\n \t\t    if (doc != NULL)\n \t\t\tdoc->encoding = xmlStrdup(BAD_CAST \"ISO-8859-1\");\n \t\t    snprintf(buf, sizeof(buf), \"&#%d;\", *cur);\n \t\t    buf[sizeof(buf) - 1] = 0;\n \t\t    ptr = buf;\n \t\t    while (*ptr != 0) *out++ = *ptr++;\n \t\t    cur++;\n \t\t    continue;\n \t\t} else if (*cur < 0xE0) {\n                     val = (cur[0]) & 0x1F;\n \t\t    val <<= 6;\n \t\t    val |= (cur[1]) & 0x3F;\n \t\t    l = 2;\n \t\t} else if (*cur < 0xF0) {\n                     val = (cur[0]) & 0x0F;\n \t\t    val <<= 6;\n \t\t    val |= (cur[1]) & 0x3F;\n \t\t    val <<= 6;\n \t\t    val |= (cur[2]) & 0x3F;\n \t\t    l = 3;\n \t\t} else if (*cur < 0xF8) {\n                     val = (cur[0]) & 0x07;\n \t\t    val <<= 6;\n \t\t    val |= (cur[1]) & 0x3F;\n \t\t    val <<= 6;\n \t\t    val |= (cur[2]) & 0x3F;\n \t\t    val <<= 6;\n \t\t    val |= (cur[3]) & 0x3F;\n \t\t    l = 4;\n \t\t}\n \t\tif ((l == 1) || (!IS_CHAR(val))) {\n \t\t    xmlEntitiesErr(XML_ERR_INVALID_CHAR,\n \t\t\t\"xmlEncodeEntities: char out of range\\n\");\n \t\t    if (doc != NULL)\n \t\t\tdoc->encoding = xmlStrdup(BAD_CAST \"ISO-8859-1\");\n \t\t    snprintf(buf, sizeof(buf), \"&#%d;\", *cur);\n \t\t    buf[sizeof(buf) - 1] = 0;\n \t\t    ptr = buf;\n \t\t    while (*ptr != 0) *out++ = *ptr++;\n \t\t    cur++;\n \t\t    continue;\n \t\t}\n \t\tsnprintf(buf, sizeof(buf), \"&#x%X;\", val);\n \t\tbuf[sizeof(buf) - 1] = 0;\n \t\tptr = buf;\n \t\twhile (*ptr != 0) *out++ = *ptr++;\n \t\tcur += l;\n \t\tcontinue;\n \t    }\n \t} else if (IS_BYTE_CHAR(*cur)) {\n \t    char buf[11], *ptr;\n \n \t    snprintf(buf, sizeof(buf), \"&#%d;\", *cur);\n \t    buf[sizeof(buf) - 1] = 0;\n             ptr = buf;\n \t    while (*ptr != 0) *out++ = *ptr++;\n \t}\n \tcur++;\n     }\n     *out = 0;\n     return(buffer);\n \n mem_error:\n     xmlEntitiesErrMemory(\"xmlEncodeEntities: realloc failed\");\n     xmlFree(buffer);\n     return(NULL);\n }\n \n", "target": "// fix_start\n\t\tif (((cur[0] & 0xC0) != 0xC0) ||\n\t\t    ((cur[1] & 0xC0) != 0x80) ||\n\t\t    (((cur[0] & 0xE0) == 0xE0) && ((cur[2] & 0xC0) != 0x80)) ||\n\t\t    (((cur[0] & 0xF0) == 0xF0) && ((cur[3] & 0xC0) != 0x80)) ||\n\t\t    (((cur[0] & 0xF8) == 0xF8))) {\n// fix_end\n", "cwe": "CWE-787", "cwe_name": "Out-of-bounds Write", "cve": "CVE-2021-3517", "cve_desc": "There is a flaw in the xml entity encoding functionality of libxml2 in versions before 2.9.11. An attacker who is able to supply a crafted file to be processed by an application linked with the affected functionality of libxml2 could trigger an out-of-bounds read. The most likely impact of this flaw is to application availability, with some potential impact to confidentiality and integrity if an attacker is able to use memory information to further exploit the application.", "project": "libxml2", "idx": 200381}
{"source": " sync_create_state_control(Slapi_Entry *e, LDAPControl **ctrlp, int type, Sync_Cookie *cookie)\n {\n     int rc;\n     BerElement *ber;\n     struct berval *bvp;\n     char *uuid;\n// bug_start\n    Slapi_Attr *attr;\n    Slapi_Value *val;\n// bug_end\n \n     if (type == LDAP_SYNC_NONE || ctrlp == NULL || (ber = der_alloc()) == NULL) {\n         return (LDAP_OPERATIONS_ERROR);\n     }\n \n     *ctrlp = NULL;\n \n     slapi_entry_attr_find(e, SLAPI_ATTR_UNIQUEID, &attr);\n     slapi_attr_first_value(attr, &val);\n// bug_start\n// bug_end\n     uuid = sync_nsuniqueid2uuid(slapi_value_get_string(val));\n     if ((rc = ber_printf(ber, \"{eo\", type, uuid, 16)) != -1) {\n         if (cookie) {\n             char *cookiestr = sync_cookie2str(cookie);\n             rc = ber_printf(ber, \"s}\", cookiestr);\n             slapi_ch_free((void **)&cookiestr);\n         } else {\n             rc = ber_printf(ber, \"}\");\n         }\n     }\n     if (rc != -1) {\n         rc = ber_flatten(ber, &bvp);\n     }\n     ber_free(ber, 1);\n     slapi_ch_free((void **)&uuid);\n \n     if (rc == -1) {\n         return (LDAP_OPERATIONS_ERROR);\n     }\n \n     *ctrlp = (LDAPControl *)slapi_ch_malloc(sizeof(LDAPControl));\n     (*ctrlp)->ldctl_iscritical = 0;\n     (*ctrlp)->ldctl_oid = slapi_ch_strdup(LDAP_CONTROL_SYNC_STATE);\n     (*ctrlp)->ldctl_value = *bvp;\n \n     bvp->bv_val = NULL;\n     ber_bvfree(bvp);\n \n     return (LDAP_SUCCESS);\n }\n \n", "target": "// fix_start\n    Slapi_Attr *attr = NULL;\n    Slapi_Value *val = NULL;\n// fix_end\n// fix_start\n    if ((attr == NULL) || (val == NULL)) {\n        slapi_log_err(SLAPI_LOG_ERR, SYNC_PLUGIN_SUBSYSTEM,\n\t\t      \"sync_create_state_control - Entries are missing nsuniqueid. Unable to proceed.\\n\");\n        return (LDAP_OPERATIONS_ERROR);\n    }\n// fix_end\n", "cwe": "CWE-476", "cwe_name": "NULL Pointer Dereference", "cve": "CVE-2021-3514", "cve_desc": "When using a sync_repl client in 389-ds-base, an authenticated attacker can cause a NULL pointer dereference using a specially crafted query, causing a crash.", "project": "389-ds-base", "idx": 200413}
{"source": " static int blosc_c(struct thread_context* thread_context, int32_t bsize,\n// bug_start\n                   int32_t leftoverblock, int32_t ntbytes, int32_t maxbytes,\n// bug_end\n                    const uint8_t* src, const int32_t offset, uint8_t* dest,\n                    uint8_t* tmp, uint8_t* tmp2) {\n   blosc2_context* context = thread_context->parent_context;\n   int dont_split = (context->header_flags & 0x10) >> 4;\n   int dict_training = context->use_dict && context->dict_cdict == NULL;\n   int32_t j, neblock, nstreams;\n   int32_t cbytes;\n   int32_t ctbytes = 0;\n   int64_t maxout;\n   int32_t typesize = context->typesize;\n   const char* compname;\n   int accel;\n   const uint8_t* _src;\n   uint8_t *_tmp = tmp, *_tmp2 = tmp2;\n   uint8_t *_tmp3 = thread_context->tmp4;\n   int last_filter_index = last_filter(context->filters, 'c');\n   bool memcpyed = context->header_flags & (uint8_t)BLOSC_MEMCPYED;\n \n   if (last_filter_index >= 0 || context->prefilter != NULL) {\n     if (memcpyed && context->prefilter != NULL) {\n       _src = pipeline_c(thread_context, bsize, src, offset, dest, _tmp2, _tmp3);\n \n       if (_src == NULL) {\n         return -9;\n       }\n       return bsize;\n     }\n     _src = pipeline_c(thread_context, bsize, src, offset, _tmp, _tmp2, _tmp3);\n \n     if (_src == NULL) {\n       return -9;\n     }\n   } else {\n     _src = src + offset;\n   }\n \n   assert(context->clevel > 0);\n \n   accel = get_accel(context);\n \n   if (!dont_split && !leftoverblock && !dict_training) {\n     nstreams = (int32_t)typesize;\n   }\n   else {\n     nstreams = 1;\n   }\n   neblock = bsize / nstreams;\n   for (j = 0; j < nstreams; j++) {\n     if (!dict_training) {\n       dest += sizeof(int32_t);\n       ntbytes += sizeof(int32_t);\n       ctbytes += sizeof(int32_t);\n     }\n \n     const uint8_t* ip = (uint8_t*)_src + j * neblock;\n     const uint8_t* ipbound = (uint8_t*)_src + (j + 1) * neblock;\n     if (get_run(ip, ipbound)) {\n       int32_t value = _src[j * neblock];\n// bug_start\n// bug_end\n       _sw32(dest - 4, -value);\n       continue;\n     }\n \n     maxout = neblock;\n   #if defined(HAVE_SNAPPY)\n     if (context->compcode == BLOSC_SNAPPY) {\n       maxout = (int32_t)snappy_max_compressed_length((size_t)neblock);\n     }\n   #endif\n// bug_start\n    if (ntbytes + maxout > maxbytes) {\n      maxout = (int64_t)maxbytes - (int64_t)ntbytes;\n// bug_end\n       if (maxout <= 0) {\n         return 0;\n       }\n     }\n     if (dict_training) {\n       memcpy(dest, _src + j * neblock, (unsigned int)neblock);\n       cbytes = (int32_t)neblock;\n     }\n     else if (context->compcode == BLOSC_BLOSCLZ) {\n       cbytes = blosclz_compress(context->clevel, _src + j * neblock,\n                                 (int)neblock, dest, (int)maxout);\n     }\n   #if defined(HAVE_LZ4)\n     else if (context->compcode == BLOSC_LZ4) {\n       void *hash_table = NULL;\n     #ifdef HAVE_IPP\n       hash_table = (void*)thread_context->lz4_hash_table;\n     #endif\n       cbytes = lz4_wrap_compress((char*)_src + j * neblock, (size_t)neblock,\n                                  (char*)dest, (size_t)maxout, accel, hash_table);\n     }\n     else if (context->compcode == BLOSC_LZ4HC) {\n       cbytes = lz4hc_wrap_compress((char*)_src + j * neblock, (size_t)neblock,\n                                    (char*)dest, (size_t)maxout, context->clevel);\n     }\n   #endif\n   #if defined(HAVE_LIZARD)\n     else if (context->compcode == BLOSC_LIZARD) {\n       cbytes = lizard_wrap_compress((char*)_src + j * neblock, (size_t)neblock,\n                                     (char*)dest, (size_t)maxout, accel);\n     }\n   #endif\n   #if defined(HAVE_SNAPPY)\n     else if (context->compcode == BLOSC_SNAPPY) {\n       cbytes = snappy_wrap_compress((char*)_src + j * neblock, (size_t)neblock,\n                                     (char*)dest, (size_t)maxout);\n     }\n   #endif\n   #if defined(HAVE_ZLIB)\n     else if (context->compcode == BLOSC_ZLIB) {\n       cbytes = zlib_wrap_compress((char*)_src + j * neblock, (size_t)neblock,\n                                   (char*)dest, (size_t)maxout, context->clevel);\n     }\n   #endif\n   #if defined(HAVE_ZSTD)\n     else if (context->compcode == BLOSC_ZSTD) {\n       cbytes = zstd_wrap_compress(thread_context,\n                                   (char*)_src + j * neblock, (size_t)neblock,\n                                   (char*)dest, (size_t)maxout, context->clevel);\n     }\n   #endif\n \n     else {\n       blosc_compcode_to_compname(context->compcode, &compname);\n       fprintf(stderr, \"Blosc has not been compiled with '%s' \", compname);\n       fprintf(stderr, \"compression support.  Please use one having it.\");\n       return -5;\n     }\n \n     if (cbytes > maxout) {\n       return -1;\n     }\n     if (cbytes < 0) {\n       return -2;\n     }\n     if (!dict_training) {\n       if (cbytes == 0 || cbytes == neblock) {\n// bug_start\n        if ((ntbytes + neblock) > maxbytes) {\n// bug_end\n           return 0;\n         }\n         memcpy(dest, _src + j * neblock, (unsigned int)neblock);\n         cbytes = neblock;\n       }\n       _sw32(dest - 4, cbytes);\n     }\n     dest += cbytes;\n     ntbytes += cbytes;\n     ctbytes += cbytes;\n   }\n \n   return ctbytes;\n }\n \n", "target": "// fix_start\n                   int32_t leftoverblock, int32_t ntbytes, int32_t destsize,\n// fix_end\n// fix_start\n      if (ntbytes > destsize) {\n        return -1;\n      }\n// fix_end\n// fix_start\n    if (ntbytes + maxout > destsize) {\n      maxout = (int64_t)destsize - (int64_t)ntbytes;\n// fix_end\n// fix_start\n        if ((ntbytes + neblock) > destsize) {\n// fix_end\n", "cwe": "CWE-787", "cwe_name": "Out-of-bounds Write", "cve": "CVE-2020-29367", "cve_desc": "blosc2.c in Blosc C-Blosc2 through 2.0.0.beta.5 has a heap-based buffer overflow when there is a lack of space to write compressed data.", "project": "c-blosc2", "idx": 200450}
{"source": " copy_ciphersuites(gnutls_session_t session,\n \t\t  gnutls_buffer_st * cdata, int add_scsv)\n {\n \tint ret;\n// bug_start\n\tuint8_t cipher_suites[MAX_CIPHERSUITE_SIZE + 2];\n// bug_end\n \tint cipher_suites_size;\n \tsize_t init_length = cdata->length;\n \n \tret =\n \t    _gnutls_supported_ciphersuites(session, cipher_suites,\n \t\t\t\t\t   sizeof(cipher_suites) - 2);\n \tif (ret < 0)\n \t\treturn gnutls_assert_val(ret);\n \n \tret =\n \t    _gnutls_remove_unwanted_ciphersuites(session, cipher_suites,\n \t\t\t\t\t\t ret, NULL, 0);\n \tif (ret < 0)\n \t\treturn gnutls_assert_val(ret);\n \n \tif (ret == 0)\n \t\treturn\n \t\t    gnutls_assert_val(GNUTLS_E_INSUFFICIENT_CREDENTIALS);\n \n \tcipher_suites_size = ret;\n \tif (add_scsv) {\n \t\tcipher_suites[cipher_suites_size] = 0x00;\n \t\tcipher_suites[cipher_suites_size + 1] = 0xff;\n \t\tcipher_suites_size += 2;\n \n \t\tret = _gnutls_ext_sr_send_cs(session);\n \t\tif (ret < 0)\n \t\t\treturn gnutls_assert_val(ret);\n \t}\n \n// bug_start\n// bug_end\n \tret =\n \t    _gnutls_buffer_append_data_prefix(cdata, 16, cipher_suites,\n \t\t\t\t\t      cipher_suites_size);\n \tif (ret < 0)\n \t\treturn gnutls_assert_val(ret);\n \n \tret = cdata->length - init_length;\n \n \treturn ret;\n }\n \n", "target": "// fix_start\n\tuint8_t cipher_suites[MAX_CIPHERSUITE_SIZE + 4];\n// fix_end\n// fix_start\n\tif (session->internals.priorities.fallback) {\n\t\tcipher_suites[cipher_suites_size] =\n\t\t\tGNUTLS_FALLBACK_SCSV_MAJOR;\n\t\tcipher_suites[cipher_suites_size + 1] =\n\t\t\tGNUTLS_FALLBACK_SCSV_MINOR;\n\t\tcipher_suites_size += 2;\n\t}\n\n// fix_end\n", "cwe": "CWE-310", "cwe_name": "Cryptographic Issues", "cve": "CVE-2014-3566", "cve_desc": "The SSL protocol 3.0, as used in OpenSSL through 1.0.1i and other products, uses nondeterministic CBC padding, which makes it easier for man-in-the-middle attackers to obtain cleartext data via a padding-oracle attack, aka the \"POODLE\" issue.", "project": "gnutls", "idx": 200462}
{"source": " gdImagePtr gdImageCreateFromXpm (char *filename)\n {\n \tXpmInfo info;\n \tXpmImage image;\n \tint i, j, k, number;\n \tchar buf[5];\n \tgdImagePtr im = 0;\n \tint *pointer;\n \tint red = 0, green = 0, blue = 0;\n \tint *colors;\n \tint ret;\n \n \tret = XpmReadFileToXpmImage(filename, &image, &info);\n \tif (ret != XpmSuccess) {\n \t\treturn 0;\n \t}\n// bug_start\n// bug_end\n \n \tif (!(im = gdImageCreate(image.width, image.height))) {\n \t\tgoto done;\n \t}\n \n// bug_start\n\tnumber = image.ncolors;\n// bug_end\n \tcolors = (int *) safe_emalloc(number, sizeof(int), 0);\n \tfor (i = 0; i < number; i++) {\n \t\tswitch (strlen (image.colorTable[i].c_color)) {\n \t\t\tcase 4:\n \t\t\t\tbuf[1] = '\\0';\n \t\t\t\tbuf[0] = image.colorTable[i].c_color[1];\n \t\t\t\tred = strtol(buf, NULL, 16);\n \n \t\t\t\tbuf[0] = image.colorTable[i].c_color[2];\n \t\t\t\tgreen = strtol(buf, NULL, 16);\n \n \t\t\t\tbuf[0] = image.colorTable[i].c_color[3];\n \t\t\t\tblue = strtol(buf, NULL, 16);\n \t\t\t\tbreak;\n \n \t\t\tcase 7:\n \t\t\t\tbuf[2] = '\\0';\n \t\t\t\tbuf[0] = image.colorTable[i].c_color[1];\n \t\t\t\tbuf[1] = image.colorTable[i].c_color[2];\n \t\t\t\tred = strtol(buf, NULL, 16);\n \n \t\t\t\tbuf[0] = image.colorTable[i].c_color[3];\n \t\t\t\tbuf[1] = image.colorTable[i].c_color[4];\n \t\t\t\tgreen = strtol(buf, NULL, 16);\n \n \t\t\t\tbuf[0] = image.colorTable[i].c_color[5];\n \t\t\t\tbuf[1] = image.colorTable[i].c_color[6];\n \t\t\t\tblue = strtol(buf, NULL, 16);\n \t\t\t\tbreak;\n \n \t\t\tcase 10:\n \t\t\t\tbuf[3] = '\\0';\n \t\t\t\tbuf[0] = image.colorTable[i].c_color[1];\n \t\t\t\tbuf[1] = image.colorTable[i].c_color[2];\n \t\t\t\tbuf[2] = image.colorTable[i].c_color[3];\n \t\t\t\tred = strtol(buf, NULL, 16);\n \t\t\t\tred /= 64;\n \n \t\t\t\tbuf[0] = image.colorTable[i].c_color[4];\n \t\t\t\tbuf[1] = image.colorTable[i].c_color[5];\n \t\t\t\tbuf[2] = image.colorTable[i].c_color[6];\n \t\t\t\tgreen = strtol(buf, NULL, 16);\n \t\t\t\tgreen /= 64;\n \n \t\t\t\tbuf[0] = image.colorTable[i].c_color[7];\n \t\t\t\tbuf[1] = image.colorTable[i].c_color[8];\n \t\t\t\tbuf[2] = image.colorTable[i].c_color[9];\n \t\t\t\tblue = strtol(buf, NULL, 16);\n \t\t\t\tblue /= 64;\n \t\t\t\tbreak;\n \n \t\t\tcase 13:\n \t\t\t\tbuf[4] = '\\0';\n \t\t\t\tbuf[0] = image.colorTable[i].c_color[1];\n \t\t\t\tbuf[1] = image.colorTable[i].c_color[2];\n \t\t\t\tbuf[2] = image.colorTable[i].c_color[3];\n \t\t\t\tbuf[3] = image.colorTable[i].c_color[4];\n \t\t\t\tred = strtol(buf, NULL, 16);\n \t\t\t\tred /= 256;\n \n \t\t\t\tbuf[0] = image.colorTable[i].c_color[5];\n \t\t\t\tbuf[1] = image.colorTable[i].c_color[6];\n \t\t\t\tbuf[2] = image.colorTable[i].c_color[7];\n \t\t\t\tbuf[3] = image.colorTable[i].c_color[8];\n \t\t\t\tgreen = strtol(buf, NULL, 16);\n \t\t\t\tgreen /= 256;\n \n \t\t\t\tbuf[0] = image.colorTable[i].c_color[9];\n \t\t\t\tbuf[1] = image.colorTable[i].c_color[10];\n \t\t\t\tbuf[2] = image.colorTable[i].c_color[11];\n \t\t\t\tbuf[3] = image.colorTable[i].c_color[12];\n \t\t\t\tblue = strtol(buf, NULL, 16);\n \t\t\t\tblue /= 256;\n \t\t\t\tbreak;\n \t\t}\n \n \n \t\tcolors[i] = gdImageColorResolve(im, red, green, blue);\n \t}\n \n \tpointer = (int *) image.data;\n \tfor (i = 0; i < image.height; i++) {\n \t\tfor (j = 0; j < image.width; j++) {\n \t\t\tk = *pointer++;\n \t\t\tgdImageSetPixel(im, j, i, colors[k]);\n \t\t}\n \t}\n \n \tgdFree(colors);\n  done:\n \tXpmFreeXpmImage(&image);\n \tXpmFreeXpmInfo(&info);\n \treturn im;\n }\n \n", "target": "// fix_start\n\tnumber = image.ncolors;\n\tfor(i = 0; i < number; i++) {\n\t\tif (!image.colorTable[i].c_color) {\n\t\t\tgoto done;\n\t\t}\n\t}\n// fix_end\n// fix_start\n// fix_end\n", "cwe": "CWE-476", "cwe_name": "NULL Pointer Dereference", "cve": "CVE-2014-2497", "cve_desc": "The gdImageCreateFromXpm function in gdxpm.c in libgd, as used in PHP 5.4.26 and earlier, allows remote attackers to cause a denial of service (NULL pointer dereference and application crash) via a crafted color table in an XPM file.", "project": "php-src", "idx": 200525}
{"source": " static void ov511_mode_init_regs(struct sd *sd)\n {\n \tstruct gspca_dev *gspca_dev = (struct gspca_dev *)sd;\n \tint hsegs, vsegs, packet_size, fps, needed;\n \tint interlaced = 0;\n \tstruct usb_host_interface *alt;\n \tstruct usb_interface *intf;\n \n \tintf = usb_ifnum_to_if(sd->gspca_dev.dev, sd->gspca_dev.iface);\n \talt = usb_altnum_to_altsetting(intf, sd->gspca_dev.alt);\n \tif (!alt) {\n \t\tgspca_err(gspca_dev, \"Couldn't get altsetting\\n\");\n \t\tsd->gspca_dev.usb_err = -EIO;\n// bug_start\n// bug_end\n \t\treturn;\n \t}\n \n \tpacket_size = le16_to_cpu(alt->endpoint[0].desc.wMaxPacketSize);\n \treg_w(sd, R51x_FIFO_PSIZE, packet_size >> 5);\n \n \treg_w(sd, R511_CAM_UV_EN, 0x01);\n \treg_w(sd, R511_SNAP_UV_EN, 0x01);\n \treg_w(sd, R511_SNAP_OPTS, 0x03);\n \n \thsegs = (sd->gspca_dev.pixfmt.width >> 3) - 1;\n \tvsegs = (sd->gspca_dev.pixfmt.height >> 3) - 1;\n \n \treg_w(sd, R511_CAM_PXCNT, hsegs);\n \treg_w(sd, R511_CAM_LNCNT, vsegs);\n \treg_w(sd, R511_CAM_PXDIV, 0x00);\n \treg_w(sd, R511_CAM_LNDIV, 0x00);\n \n \treg_w(sd, R511_CAM_OPTS, 0x03);\n \n \treg_w(sd, R511_SNAP_PXCNT, hsegs);\n \treg_w(sd, R511_SNAP_LNCNT, vsegs);\n \treg_w(sd, R511_SNAP_PXDIV, 0x00);\n \treg_w(sd, R511_SNAP_LNDIV, 0x00);\n \n \tif (frame_rate > 0)\n \t\tsd->frame_rate = frame_rate;\n \n \tswitch (sd->sensor) {\n \tcase SEN_OV6620:\n \t\tsd->clockdiv = 3;\n \t\tbreak;\n \n \tcase SEN_OV7620:\n \tcase SEN_OV7620AE:\n \tcase SEN_OV7640:\n \tcase SEN_OV7648:\n \tcase SEN_OV76BE:\n \t\tif (sd->gspca_dev.pixfmt.width == 320)\n \t\t\tinterlaced = 1;\n \tcase SEN_OV6630:\n \tcase SEN_OV7610:\n \tcase SEN_OV7670:\n \t\tswitch (sd->frame_rate) {\n \t\tcase 30:\n \t\tcase 25:\n \t\t\tif (sd->gspca_dev.pixfmt.width != 640) {\n \t\t\t\tsd->clockdiv = 0;\n \t\t\t\tbreak;\n \t\t\t}\n \t\tdefault:\n \t\t\tsd->clockdiv = 1;\n \t\t\tbreak;\n \t\tcase 10:\n \t\t\tsd->clockdiv = 2;\n \t\t\tbreak;\n \t\tcase 5:\n \t\t\tsd->clockdiv = 5;\n \t\t\tbreak;\n \t\t}\n \t\tif (interlaced) {\n \t\t\tsd->clockdiv = (sd->clockdiv + 1) * 2 - 1;\n \t\t\tif (sd->clockdiv > 10)\n \t\t\t\tsd->clockdiv = 10;\n \t\t}\n \t\tbreak;\n \n \tcase SEN_OV8610:\n \t\tsd->clockdiv = 0;\n \t\tbreak;\n \t}\n \n \tfps = (interlaced ? 60 : 30) / (sd->clockdiv + 1) + 1;\n \tneeded = fps * sd->gspca_dev.pixfmt.width *\n \t\t\tsd->gspca_dev.pixfmt.height * 3 / 2;\n \tif (needed > 1000 * packet_size) {\n \t\treg_w(sd, R511_COMP_EN, 0x07);\n \t\treg_w(sd, R511_COMP_LUT_EN, 0x03);\n \t} else {\n \t\treg_w(sd, R511_COMP_EN, 0x06);\n \t\treg_w(sd, R511_COMP_LUT_EN, 0x00);\n \t}\n \n \treg_w(sd, R51x_SYS_RESET, OV511_RESET_OMNICE);\n \treg_w(sd, R51x_SYS_RESET, 0);\n }\n \n", "target": "// fix_start\n\t\treturn;\n\t}\n\n\tif (alt->desc.bNumEndpoints < 1) {\n\t\tsd->gspca_dev.usb_err = -ENODEV;\n// fix_end\n", "cwe": "CWE-476", "cwe_name": "NULL Pointer Dereference", "cve": "CVE-2020-11608", "cve_desc": "An issue was discovered in the Linux kernel before 5.6.1. drivers/media/usb/gspca/ov519.c allows NULL pointer dereferences in ov511_mode_init_regs and ov518_mode_init_regs when there are zero endpoints, aka CID-998912346c0d.", "project": "linux", "idx": 200621}
{"source": " static void ov518_mode_init_regs(struct sd *sd)\n {\n \tstruct gspca_dev *gspca_dev = (struct gspca_dev *)sd;\n \tint hsegs, vsegs, packet_size;\n \tstruct usb_host_interface *alt;\n \tstruct usb_interface *intf;\n \n \tintf = usb_ifnum_to_if(sd->gspca_dev.dev, sd->gspca_dev.iface);\n \talt = usb_altnum_to_altsetting(intf, sd->gspca_dev.alt);\n \tif (!alt) {\n \t\tgspca_err(gspca_dev, \"Couldn't get altsetting\\n\");\n \t\tsd->gspca_dev.usb_err = -EIO;\n// bug_start\n// bug_end\n \t\treturn;\n \t}\n \n \tpacket_size = le16_to_cpu(alt->endpoint[0].desc.wMaxPacketSize);\n \tov518_reg_w32(sd, R51x_FIFO_PSIZE, packet_size & ~7, 2);\n \n \treg_w(sd, 0x2b, 0);\n \treg_w(sd, 0x2c, 0);\n \treg_w(sd, 0x2d, 0);\n \treg_w(sd, 0x2e, 0);\n \treg_w(sd, 0x3b, 0);\n \treg_w(sd, 0x3c, 0);\n \treg_w(sd, 0x3d, 0);\n \treg_w(sd, 0x3e, 0);\n \n \tif (sd->bridge == BRIDGE_OV518) {\n \t\treg_w_mask(sd, 0x20, 0x08, 0x08);\n \n \t\treg_w_mask(sd, 0x28, 0x80, 0xf0);\n \t\treg_w_mask(sd, 0x38, 0x80, 0xf0);\n \t} else {\n \t\treg_w(sd, 0x28, 0x80);\n \t\treg_w(sd, 0x38, 0x80);\n \t}\n \n \thsegs = sd->gspca_dev.pixfmt.width / 16;\n \tvsegs = sd->gspca_dev.pixfmt.height / 4;\n \n \treg_w(sd, 0x29, hsegs);\n \treg_w(sd, 0x2a, vsegs);\n \n \treg_w(sd, 0x39, hsegs);\n \treg_w(sd, 0x3a, vsegs);\n \n \treg_w(sd, 0x2f, 0x80);\n \n \tif (sd->bridge == BRIDGE_OV518PLUS && sd->revision == 0 &&\n \t\t\t\t\t      sd->sensor == SEN_OV7620AE)\n \t\tsd->clockdiv = 0;\n \telse\n \t\tsd->clockdiv = 1;\n \n \treg_w(sd, 0x51, 0x04);\n \treg_w(sd, 0x22, 0x18);\n \treg_w(sd, 0x23, 0xff);\n \n \tif (sd->bridge == BRIDGE_OV518PLUS) {\n \t\tswitch (sd->sensor) {\n \t\tcase SEN_OV7620AE:\n \t\t\tif (sd->revision > 0 &&\n \t\t\t\t\tsd->gspca_dev.pixfmt.width == 640) {\n \t\t\t\treg_w(sd, 0x20, 0x60);\n \t\t\t\treg_w(sd, 0x21, 0x1f);\n \t\t\t} else {\n \t\t\t\treg_w(sd, 0x20, 0x00);\n \t\t\t\treg_w(sd, 0x21, 0x19);\n \t\t\t}\n \t\t\tbreak;\n \t\tcase SEN_OV7620:\n \t\t\treg_w(sd, 0x20, 0x00);\n \t\t\treg_w(sd, 0x21, 0x19);\n \t\t\tbreak;\n \t\tdefault:\n \t\t\treg_w(sd, 0x21, 0x19);\n \t\t}\n \t} else\n \t\treg_w(sd, 0x71, 0x17);\n \n \ti2c_w(sd, 0x54, 0x23);\n \n \treg_w(sd, 0x2f, 0x80);\n \n \tif (sd->bridge == BRIDGE_OV518PLUS) {\n \t\treg_w(sd, 0x24, 0x94);\n \t\treg_w(sd, 0x25, 0x90);\n \t\tov518_reg_w32(sd, 0xc4,    400, 2);\n \t\tov518_reg_w32(sd, 0xc6,    540, 2);\n \t\tov518_reg_w32(sd, 0xc7,    540, 2);\n \t\tov518_reg_w32(sd, 0xc8,    108, 2);\n \t\tov518_reg_w32(sd, 0xca, 131098, 3);\n \t\tov518_reg_w32(sd, 0xcb,    532, 2);\n \t\tov518_reg_w32(sd, 0xcc,   2400, 2);\n \t\tov518_reg_w32(sd, 0xcd,     32, 2);\n \t\tov518_reg_w32(sd, 0xce,    608, 2);\n \t} else {\n \t\treg_w(sd, 0x24, 0x9f);\n \t\treg_w(sd, 0x25, 0x90);\n \t\tov518_reg_w32(sd, 0xc4,    400, 2);\n \t\tov518_reg_w32(sd, 0xc6,    381, 2);\n \t\tov518_reg_w32(sd, 0xc7,    381, 2);\n \t\tov518_reg_w32(sd, 0xc8,    128, 2);\n \t\tov518_reg_w32(sd, 0xca, 183331, 3);\n \t\tov518_reg_w32(sd, 0xcb,    746, 2);\n \t\tov518_reg_w32(sd, 0xcc,   1750, 2);\n \t\tov518_reg_w32(sd, 0xcd,     45, 2);\n \t\tov518_reg_w32(sd, 0xce,    851, 2);\n \t}\n \n \treg_w(sd, 0x2f, 0x80);\n }\n \n", "target": "// fix_start\n\t\treturn;\n\t}\n\n\tif (alt->desc.bNumEndpoints < 1) {\n\t\tsd->gspca_dev.usb_err = -ENODEV;\n// fix_end\n", "cwe": "CWE-476", "cwe_name": "NULL Pointer Dereference", "cve": "CVE-2020-11608", "cve_desc": "An issue was discovered in the Linux kernel before 5.6.1. drivers/media/usb/gspca/ov519.c allows NULL pointer dereferences in ov511_mode_init_regs and ov518_mode_init_regs when there are zero endpoints, aka CID-998912346c0d.", "project": "linux", "idx": 200622}
{"source": " urnParseReply(const char *inbuf, const HttpRequestMethod& m)\n {\n     char *buf = xstrdup(inbuf);\n     char *token;\n     url_entry *list;\n     url_entry *old;\n     int n = 32;\n     int i = 0;\n     debugs(52, 3, \"urnParseReply\");\n     list = (url_entry *)xcalloc(n + 1, sizeof(*list));\n \n     for (token = strtok(buf, crlf); token; token = strtok(NULL, crlf)) {\n         debugs(52, 3, \"urnParseReply: got '\" << token << \"'\");\n \n         if (i == n) {\n             old = list;\n             n <<= 2;\n             list = (url_entry *)xcalloc(n + 1, sizeof(*list));\n             memcpy(list, old, i * sizeof(*list));\n             safe_free(old);\n         }\n \n         AnyP::Uri uri;\n         if (!uri.parse(m, SBuf(token)) || !*uri.host())\n             continue;\n \n #if USE_ICMP\n         list[i].rtt = netdbHostRtt(uri.host());\n \n         if (0 == list[i].rtt) {\n             debugs(52, 3, \"Pinging \" << uri.host());\n             netdbPingSite(uri.host());\n         }\n #else\n         list[i].rtt = 0;\n #endif\n \n         list[i].url = xstrdup(uri.absolute().c_str());\n         list[i].host = xstrdup(uri.host());\n         list[i].flags.cached = storeGetPublic(list[i].url, m) ? 1 : 0;\n         ++i;\n     }\n \n     debugs(52, 3, \"urnParseReply: Found \" << i << \" URLs\");\n// bug_start\n// bug_end\n     return list;\n }\n \n", "target": "// fix_start\n    xfree(buf);\n// fix_end\n", "cwe": "CWE-401", "cwe_name": "Missing Release of Memory after Effective Lifetime", "cve": "CVE-2021-28651", "cve_desc": "An issue was discovered in Squid before 4.15 and 5.x before 5.0.6. Due to a buffer-management bug, it allows a denial of service. When resolving a request with the urn: scheme, the parser leaks a small amount of memory. However, there is an unspecified attack methodology that can easily trigger a large amount of memory consumption.", "project": "squid", "idx": 200632}
{"source": " entityValueInitProcessor(XML_Parser parser,\n                          const char *s,\n                          const char *end,\n                          const char **nextPtr)\n {\n   int tok;\n   const char *start = s;\n   const char *next = start;\n   eventPtr = start;\n \n   for (;;) {\n     tok = XmlPrologTok(encoding, start, end, &next);\n     eventEndPtr = next;\n     if (tok <= 0) {\n       if (!ps_finalBuffer && tok != XML_TOK_INVALID) {\n         *nextPtr = s;\n         return XML_ERROR_NONE;\n       }\n       switch (tok) {\n       case XML_TOK_INVALID:\n         return XML_ERROR_INVALID_TOKEN;\n       case XML_TOK_PARTIAL:\n         return XML_ERROR_UNCLOSED_TOKEN;\n       case XML_TOK_PARTIAL_CHAR:\n         return XML_ERROR_PARTIAL_CHAR;\n       case XML_TOK_NONE:\n       default:\n         break;\n       }\n       return storeEntityValue(parser, encoding, s, end);\n     }\n     else if (tok == XML_TOK_XML_DECL) {\n       enum XML_Error result;\n       result = processXmlDecl(parser, 0, start, next);\n       if (result != XML_ERROR_NONE)\n         return result;\n       switch (ps_parsing) {\n       case XML_SUSPENDED:\n         *nextPtr = next;\n         return XML_ERROR_NONE;\n       case XML_FINISHED:\n         return XML_ERROR_ABORTED;\n       default:\n         *nextPtr = next;\n       }\n       processor = entityValueProcessor;\n       return entityValueProcessor(parser, next, end, nextPtr);\n     }\n     else if (tok == XML_TOK_BOM && next == end && !ps_finalBuffer) {\n       *nextPtr = next;\n       return XML_ERROR_NONE;\n     }\n// bug_start\n// bug_end\n     start = next;\n     eventPtr = start;\n   }\n }\n \n", "target": "// fix_start\n    else if (tok == XML_TOK_INSTANCE_START) {\n      *nextPtr = next;\n      return XML_ERROR_SYNTAX;\n    }\n// fix_end\n", "cwe": "CWE-611", "cwe_name": "Improper Restriction of XML External Entity Reference ('XXE')", "cve": "CVE-2017-9233", "cve_desc": "XML External Entity vulnerability in libexpat 2.2.0 and earlier (Expat XML Parser Library) allows attackers to put the parser in an infinite loop using a malformed external entity definition from an external DTD.", "project": "libexpat", "idx": 200711}
{"source": " int h2_make_htx_request(struct http_hdr *list, struct htx *htx, unsigned int *msgf, unsigned long long *body_len)\n {\n \tstruct ist phdr_val[H2_PHDR_NUM_ENTRIES];\n \tuint32_t fields;\n \tuint32_t idx;\n \tint ck, lck;\n \tint phdr;\n \tint ret;\n \tint i;\n \tstruct htx_sl *sl = NULL;\n \tunsigned int sl_flags = 0;\n \tconst char *ctl;\n \n \tlck = ck = -1;\n \tfields = 0;\n \tfor (idx = 0; list[idx].n.len != 0; idx++) {\n \t\tif (!list[idx].n.ptr) {\n \t\t\tphdr = list[idx].n.len;\n \t\t}\n \t\telse {\n \t\t\tphdr = h2_str_to_phdr(list[idx].n);\n \n \t\t\tfor (i = !!phdr; i < list[idx].n.len; i++)\n \t\t\t\tif ((uint8_t)(list[idx].n.ptr[i] - 'A') < 'Z' - 'A' || !HTTP_IS_TOKEN(list[idx].n.ptr[i]))\n \t\t\t\t\tgoto fail;\n \t\t}\n \n \t\tctl = ist_find_ctl(list[idx].v);\n \t\tif (unlikely(ctl) && has_forbidden_char(list[idx].v, ctl))\n \t\t\tgoto fail;\n \n \t\tif (phdr > 0 && phdr < H2_PHDR_NUM_ENTRIES) {\n \t\t\tif (fields & ((1 << phdr) | H2_PHDR_FND_NONE)) {\n \t\t\t\tif (fields & H2_PHDR_FND_NONE) {\n \t\t\t\t\tgoto fail;\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\tgoto fail;\n \t\t\t\t}\n \t\t\t}\n \t\t\tfields |= 1 << phdr;\n \t\t\tphdr_val[phdr] = list[idx].v;\n \t\t\tcontinue;\n \t\t}\n \t\telse if (phdr != 0) {\n \t\t\tgoto fail;\n \t\t}\n \n \t\tif (unlikely(!(fields & H2_PHDR_FND_NONE))) {\n \t\t\tsl = h2_prepare_htx_reqline(fields, phdr_val, htx, msgf);\n \t\t\tif (!sl)\n \t\t\t\tgoto fail;\n \t\t\tfields |= H2_PHDR_FND_NONE;\n// bug_start\n// bug_end\n \t\t}\n \n// bug_start\n\t\tif (isteq(list[idx].n, ist(\"host\")))\n// bug_end\n \t\t\tfields |= H2_PHDR_FND_HOST;\n// bug_start\n// bug_end\n \n \t\tif (isteq(list[idx].n, ist(\"content-length\"))) {\n \t\t\tret = h2_parse_cont_len_header(msgf, &list[idx].v, body_len);\n \t\t\tif (ret < 0)\n \t\t\t\tgoto fail;\n \n \t\t\tsl_flags |= HTX_SL_F_CLEN;\n \t\t\tif (ret == 0)\n \t\t\t\tcontinue;\n \t\t}\n \n \t\tif (isteq(list[idx].n, ist(\"connection\")) ||\n \t\t    isteq(list[idx].n, ist(\"proxy-connection\")) ||\n \t\t    isteq(list[idx].n, ist(\"keep-alive\")) ||\n \t\t    isteq(list[idx].n, ist(\"upgrade\")) ||\n \t\t    isteq(list[idx].n, ist(\"transfer-encoding\")))\n \t\t\tgoto fail;\n \n \t\tif (isteq(list[idx].n, ist(\"te\")) && !isteq(list[idx].v, ist(\"trailers\")))\n \t\t\tgoto fail;\n \n \t\tif (isteq(list[idx].n, ist(\"cookie\"))) {\n \t\t\tlist[idx].n.len = -1;\n \n \t\t\tif (ck < 0)\n \t\t\t\tck = idx;\n \t\t\telse\n \t\t\t\tlist[lck].n.len = idx;\n \n \t\t\tlck = idx;\n \t\t\tcontinue;\n \t\t}\n \n \t\tif (!htx_add_header(htx, list[idx].n, list[idx].v))\n \t\t\tgoto fail;\n \t}\n \n \tif (fields & H2_PHDR_FND_STAT)\n \t\tgoto fail;\n \n \tif (!(fields & H2_PHDR_FND_NONE)) {\n \t\tsl = h2_prepare_htx_reqline(fields, phdr_val, htx, msgf);\n \t\tif (!sl)\n \t\t\tgoto fail;\n \t}\n \n \tif (*msgf & H2_MSGF_BODY_TUNNEL)\n \t\t*msgf &= ~(H2_MSGF_BODY|H2_MSGF_BODY_CL);\n \n \tif (!(*msgf & H2_MSGF_BODY) || ((*msgf & H2_MSGF_BODY_CL) && *body_len == 0) ||\n \t    (*msgf & H2_MSGF_BODY_TUNNEL)) {\n \t\tsl_flags |= HTX_SL_F_BODYLESS;\n \t\thtx->flags |= HTX_FL_EOM;\n \t}\n \n \tif (*msgf & H2_MSGF_EXT_CONNECT) {\n \t\tif (!htx_add_header(htx, ist(\"upgrade\"), phdr_val[H2_PHDR_IDX_PROT]))\n \t\t\tgoto fail;\n \t\tif (!htx_add_header(htx, ist(\"connection\"), ist(\"upgrade\")))\n \t\t\tgoto fail;\n \t\tsl_flags |= HTX_SL_F_CONN_UPG;\n \t}\n \n \tsl->flags |= sl_flags;\n \n \tif ((fields & (H2_PHDR_FND_HOST|H2_PHDR_FND_AUTH)) == H2_PHDR_FND_AUTH) {\n \t\tif (!htx_add_header(htx, ist(\"host\"), phdr_val[H2_PHDR_IDX_AUTH]))\n \t\t\tgoto fail;\n \t}\n \n \tif (ck >= 0) {\n \t\tuint32_t fs;\n \t\tuint32_t bs;\n \t\tuint32_t vl;\n \t\tuint32_t tl;\n \t\tstruct htx_blk *blk;\n \n \t\tblk = htx_add_header(htx, ist(\"cookie\"), list[ck].v);\n \t\tif (!blk)\n \t\t\tgoto fail;\n \n \t\ttl = list[ck].v.len;\n \t\tfs = htx_free_data_space(htx);\n \t\tbs = htx_get_blksz(blk);\n \n \t\tfs += tl;\n \t\twhile ((ck = list[ck].n.len) >= 0) {\n \t\t\tvl = list[ck].v.len;\n \t\t\ttl += vl + 2;\n \t\t\tif (tl > fs)\n \t\t\t\tgoto fail;\n \n \t\t\thtx_change_blk_value_len(htx, blk, tl);\n \t\t\t*(char *)(htx_get_blk_ptr(htx, blk) + bs + 0) = ';';\n \t\t\t*(char *)(htx_get_blk_ptr(htx, blk) + bs + 1) = ' ';\n \t\t\tmemcpy(htx_get_blk_ptr(htx, blk) + bs + 2, list[ck].v.ptr, vl);\n \t\t\tbs += vl + 2;\n \t\t}\n \n \t}\n \n \tif (!htx_add_endof(htx, HTX_BLK_EOH))\n \t\tgoto fail;\n \n \tif (fields & H2_PHDR_FND_SCHM)\n \t\thttp_scheme_based_normalize(htx);\n \n \tret = 1;\n \treturn ret;\n \n  fail:\n \treturn -1;\n }\n \n", "target": "// fix_start\n\n\t\t\tif (fields & H2_PHDR_FND_AUTH) {\n\t\t\t\tif (!htx_add_header(htx, ist(\"host\"), phdr_val[H2_PHDR_IDX_AUTH]))\n\t\t\t\t\tgoto fail;\n\t\t\t\tfields |= H2_PHDR_FND_HOST;\n\t\t\t}\n// fix_end\n// fix_start\n\t\tif (isteq(list[idx].n, ist(\"host\"))) {\n\t\t\tif (fields & H2_PHDR_FND_HOST)\n\t\t\t\tcontinue;\n\n// fix_end\n// fix_start\n\t\t}\n// fix_end\n", "cwe": "CWE-755", "cwe_name": "Improper Handling of Exceptional Conditions", "cve": "CVE-2021-39242", "cve_desc": "An issue was discovered in HAProxy 2.2 before 2.2.16, 2.3 before 2.3.13, and 2.4 before 2.4.3. It can lead to a situation with an attacker-controlled HTTP Host header, because a mismatch between Host and authority is mishandled.", "project": "haproxy", "idx": 200767}
{"source": " unserialize_uep(bufinfo_T *bi, int *error, char_u *file_name)\n {\n     int\t\ti;\n     u_entry_T\t*uep;\n// bug_start\n    char_u\t**array;\n// bug_end\n     char_u\t*line;\n     int\t\tline_len;\n \n     uep = (u_entry_T *)U_ALLOC_LINE(sizeof(u_entry_T));\n     if (uep == NULL)\n \treturn NULL;\n     vim_memset(uep, 0, sizeof(u_entry_T));\n #ifdef U_DEBUG\n     uep->ue_magic = UE_MAGIC;\n #endif\n     uep->ue_top = undo_read_4c(bi);\n     uep->ue_bot = undo_read_4c(bi);\n     uep->ue_lcount = undo_read_4c(bi);\n     uep->ue_size = undo_read_4c(bi);\n     if (uep->ue_size > 0)\n     {\n// bug_start\n\tarray = (char_u **)U_ALLOC_LINE(sizeof(char_u *) * uep->ue_size);\n// bug_end\n \tif (array == NULL)\n \t{\n \t    *error = TRUE;\n \t    return uep;\n \t}\n \tvim_memset(array, 0, sizeof(char_u *) * uep->ue_size);\n     }\n// bug_start\n    else\n\tarray = NULL;\n// bug_end\n     uep->ue_array = array;\n \n     for (i = 0; i < uep->ue_size; ++i)\n     {\n \tline_len = undo_read_4c(bi);\n \tif (line_len >= 0)\n \t    line = read_string_decrypt(bi, line_len);\n \telse\n \t{\n \t    line = NULL;\n \t    corruption_error(\"line length\", file_name);\n \t}\n \tif (line == NULL)\n \t{\n \t    *error = TRUE;\n \t    return uep;\n \t}\n \tarray[i] = line;\n     }\n     return uep;\n }\n \n", "target": "// fix_start\n    char_u\t**array = NULL;\n// fix_end\n// fix_start\n\tif (uep->ue_size < LONG_MAX / (int)sizeof(char_u *))\n\t    array = (char_u **)U_ALLOC_LINE(sizeof(char_u *) * uep->ue_size);\n// fix_end\n// fix_start\n// fix_end\n", "cwe": "CWE-190", "cwe_name": "Integer Overflow or Wraparound", "cve": "CVE-2017-6350", "cve_desc": "An integer overflow at an unserialize_uep memory allocation site would occur for vim before patch 8.0.0378, if it does not properly validate values for tree length when reading a corrupted undo file, which may lead to resultant buffer overflows.", "project": "vim", "idx": 200929}
{"source": " ares_parse_naptr_reply (const unsigned char *abuf, int alen,\n                         struct ares_naptr_reply **naptr_out)\n {\n   unsigned int qdcount, ancount, i;\n   const unsigned char *aptr, *vptr;\n   int status, rr_type, rr_class, rr_len;\n   long len;\n   char *hostname = NULL, *rr_name = NULL;\n   struct ares_naptr_reply *naptr_head = NULL;\n   struct ares_naptr_reply *naptr_last = NULL;\n   struct ares_naptr_reply *naptr_curr;\n \n   *naptr_out = NULL;\n \n   if (alen < HFIXEDSZ)\n     return ARES_EBADRESP;\n \n   qdcount = DNS_HEADER_QDCOUNT (abuf);\n   ancount = DNS_HEADER_ANCOUNT (abuf);\n   if (qdcount != 1)\n     return ARES_EBADRESP;\n   if (ancount == 0)\n     return ARES_ENODATA;\n \n   aptr = abuf + HFIXEDSZ;\n   status = ares_expand_name (aptr, abuf, alen, &hostname, &len);\n   if (status != ARES_SUCCESS)\n     return status;\n \n   if (aptr + len + QFIXEDSZ > abuf + alen)\n     {\n       ares_free (hostname);\n       return ARES_EBADRESP;\n     }\n   aptr += len + QFIXEDSZ;\n \n   for (i = 0; i < ancount; i++)\n     {\n       status = ares_expand_name (aptr, abuf, alen, &rr_name, &len);\n       if (status != ARES_SUCCESS)\n         {\n           break;\n         }\n       aptr += len;\n       if (aptr + RRFIXEDSZ > abuf + alen)\n         {\n           status = ARES_EBADRESP;\n           break;\n         }\n       rr_type = DNS_RR_TYPE (aptr);\n       rr_class = DNS_RR_CLASS (aptr);\n       rr_len = DNS_RR_LEN (aptr);\n       aptr += RRFIXEDSZ;\n       if (aptr + rr_len > abuf + alen)\n         {\n           status = ARES_EBADRESP;\n           break;\n         }\n// bug_start\n      if (rr_len < 7)\n        {\n          status = ARES_EBADRESP;\n          break;\n        }\n// bug_end\n \n       if (rr_class == C_IN && rr_type == T_NAPTR)\n         {\n// bug_start\n// bug_end\n \n           naptr_curr = ares_malloc_data(ARES_DATATYPE_NAPTR_REPLY);\n           if (!naptr_curr)\n             {\n               status = ARES_ENOMEM;\n               break;\n             }\n           if (naptr_last)\n             {\n               naptr_last->next = naptr_curr;\n             }\n           else\n             {\n               naptr_head = naptr_curr;\n             }\n           naptr_last = naptr_curr;\n \n           vptr = aptr;\n           naptr_curr->order = DNS__16BIT(vptr);\n           vptr += sizeof(unsigned short);\n           naptr_curr->preference = DNS__16BIT(vptr);\n           vptr += sizeof(unsigned short);\n \n           status = ares_expand_string(vptr, abuf, alen, &naptr_curr->flags, &len);\n           if (status != ARES_SUCCESS)\n             break;\n           vptr += len;\n \n           status = ares_expand_string(vptr, abuf, alen, &naptr_curr->service, &len);\n           if (status != ARES_SUCCESS)\n             break;\n           vptr += len;\n \n           status = ares_expand_string(vptr, abuf, alen, &naptr_curr->regexp, &len);\n           if (status != ARES_SUCCESS)\n             break;\n           vptr += len;\n \n           status = ares_expand_name(vptr, abuf, alen, &naptr_curr->replacement, &len);\n           if (status != ARES_SUCCESS)\n             break;\n         }\n \n       ares_free (rr_name);\n       rr_name = NULL;\n \n       aptr += rr_len;\n     }\n \n   if (hostname)\n     ares_free (hostname);\n   if (rr_name)\n     ares_free (rr_name);\n \n   if (status != ARES_SUCCESS)\n     {\n       if (naptr_head)\n         ares_free_data (naptr_head);\n       return status;\n     }\n \n   *naptr_out = naptr_head;\n \n   return ARES_SUCCESS;\n }\n \n", "target": "// fix_start\n// fix_end\n// fix_start\n\n          if (rr_len < 7)\n            {\n              status = ARES_EBADRESP;\n              break;\n            }\n// fix_end\n", "cwe": "CWE-200", "cwe_name": "Exposure of Sensitive Information to an Unauthorized Actor", "cve": "CVE-2017-1000381", "cve_desc": "The c-ares function `ares_parse_naptr_reply()`, which is used for parsing NAPTR responses, could be triggered to read memory outside of the given input buffer if the passed in DNS response packet was crafted in a particular way.", "project": "c-ares", "idx": 201328}
{"source": " rpmRC hdrblobInit(const void *uh, size_t uc,\n \t\trpmTagVal regionTag, int exact_size,\n \t\tstruct hdrblob_s *blob, char **emsg)\n {\n     rpmRC rc = RPMRC_FAIL;\n// bug_start\n// bug_end\n \n// bug_start\n    memset(blob, 0, sizeof(*blob));\n// bug_end\n     blob->ei = (int32_t *) uh;\n// bug_start\n    blob->il = ntohl(blob->ei[0]);\n    blob->dl = ntohl(blob->ei[1]);\n// bug_end\n     blob->pe = (entryInfo) &(blob->ei[2]);\n     blob->pvlen = sizeof(blob->il) + sizeof(blob->dl) +\n \t\t  (blob->il * sizeof(*blob->pe)) + blob->dl;\n     blob->dataStart = (uint8_t *) (blob->pe + blob->il);\n     blob->dataEnd = blob->dataStart + blob->dl;\n \n     if (blob->pvlen >= headerMaxbytes || (uc && blob->pvlen != uc)) {\n \trasprintf(emsg, _(\"blob size(%d): BAD, 8 + 16 * il(%d) + dl(%d)\"),\n \t\t\tblob->pvlen, blob->il, blob->dl);\n \tgoto exit;\n     }\n \n     if (hdrblobVerifyRegion(regionTag, exact_size, blob, emsg) == RPMRC_FAIL)\n \tgoto exit;\n \n     if (hdrblobVerifyInfo(blob, emsg))\n \tgoto exit;\n \n     rc = RPMRC_OK;\n \n exit:\n     return rc;\n }\n \n", "target": "// fix_start\n    memset(blob, 0, sizeof(*blob));\n    if (uc && uc < 8) {\n\trasprintf(emsg, _(\"hdr length: BAD\"));\n\tgoto exit;\n    }\n// fix_end\n// fix_start\n// fix_end\n// fix_start\n    blob->il = ntohl((uint32_t)(blob->ei[0]));\n    blob->dl = ntohl((uint32_t)(blob->ei[1]));\n    if (hdrblobVerifyLengths(regionTag, blob->il, blob->dl, emsg) != RPMRC_OK)\n\tgoto exit;\n\n// fix_end\n", "cwe": "CWE-125", "cwe_name": "Out-of-bounds Read", "cve": "CVE-2021-20266", "cve_desc": "A flaw was found in RPM's hdrblobInit() in lib/header.c. This flaw allows an attacker who can modify the rpmdb to cause an out-of-bounds read. The highest threat from this vulnerability is to system availability.", "project": "rpm", "idx": 201363}
{"source": " static x3f_huffnode_t *new_node(x3f_hufftree_t *tree)\n {\n// bug_start\n// bug_end\n   x3f_huffnode_t *t = &tree->nodes[tree->free_node_index];\n \n   t->branch[0] = NULL;\n   t->branch[1] = NULL;\n   t->leaf = UNDEFINED_LEAF;\n \n   tree->free_node_index++;\n \n   return t;\n }\n \n", "target": "// fix_start\n\tif (tree->free_node_index >= tree->total_node_index)\n\t\tthrow LIBRAW_EXCEPTION_IO_CORRUPT;\n// fix_end\n", "cwe": "CWE-125", "cwe_name": "Out-of-bounds Read", "cve": "CVE-2020-35530", "cve_desc": "In LibRaw, there is an out-of-bounds write vulnerability within the \"new_node()\" function (libraw\\src\\x3f\\x3f_utils_patched.cpp) that can be triggered via a crafted X3F file.", "project": "LibRaw", "idx": 201415}
{"source": " static int rawsock_create(struct net *net, struct socket *sock,\n \t\t\t  const struct nfc_protocol *nfc_proto, int kern)\n {\n \tstruct sock *sk;\n \n \tpr_debug(\"sock=%p\\n\", sock);\n \n \tif ((sock->type != SOCK_SEQPACKET) && (sock->type != SOCK_RAW))\n \t\treturn -ESOCKTNOSUPPORT;\n \n// bug_start\n\tif (sock->type == SOCK_RAW)\n// bug_end\n \t\tsock->ops = &rawsock_raw_ops;\n// bug_start\n\telse\n// bug_end\n \t\tsock->ops = &rawsock_ops;\n// bug_start\n// bug_end\n \n \tsk = sk_alloc(net, PF_NFC, GFP_ATOMIC, nfc_proto->proto, kern);\n \tif (!sk)\n \t\treturn -ENOMEM;\n \n \tsock_init_data(sock, sk);\n \tsk->sk_protocol = nfc_proto->id;\n \tsk->sk_destruct = rawsock_destruct;\n \tsock->state = SS_UNCONNECTED;\n \tif (sock->type == SOCK_RAW)\n \t\tnfc_sock_link(&raw_sk_list, sk);\n \telse {\n \t\tINIT_WORK(&nfc_rawsock(sk)->tx_work, rawsock_tx_work);\n \t\tnfc_rawsock(sk)->tx_work_scheduled = false;\n \t}\n \n \treturn 0;\n }\n \n", "target": "// fix_start\n\tif (sock->type == SOCK_RAW) {\n\t\tif (!capable(CAP_NET_RAW))\n\t\t\treturn -EPERM;\n// fix_end\n// fix_start\n\t} else {\n// fix_end\n// fix_start\n\t}\n// fix_end\n", "cwe": "CWE-703", "cwe_name": "Improper Check or Handling of Exceptional Conditions", "cve": "CVE-2020-26088", "cve_desc": "A missing CAP_NET_RAW check in NFC socket creation in net/nfc/rawsock.c in the Linux kernel before 5.8.2 could be used by local attackers to create raw sockets, bypassing security mechanisms, aka CID-26896f01467a.", "project": "linux", "idx": 201423}
{"source": " int LibRaw::ljpeg_start(struct jhead *jh, int info_only)\n {\n   ushort c, tag, len;\n   int cnt = 0;\n   uchar data[0x10000];\n   const uchar *dp;\n \n   memset(jh, 0, sizeof *jh);\n   jh->restart = INT_MAX;\n   if ((fgetc(ifp), fgetc(ifp)) != 0xd8)\n     return 0;\n   do\n   {\n     if (feof(ifp))\n       return 0;\n     if (cnt++ > 1024)\n       return 0;\n     if (!fread(data, 2, 2, ifp))\n       return 0;\n     tag = data[0] << 8 | data[1];\n     len = (data[2] << 8 | data[3]) - 2;\n     if (tag <= 0xff00)\n       return 0;\n     fread(data, 1, len, ifp);\n     switch (tag)\n     {\n     case 0xffc3:\n       jh->sraw = ((data[7] >> 4) * (data[7] & 15) - 1) & 3;\n     case 0xffc1:\n     case 0xffc0:\n       jh->algo = tag & 0xff;\n       jh->bits = data[0];\n       jh->high = data[1] << 8 | data[2];\n       jh->wide = data[3] << 8 | data[4];\n       jh->clrs = data[5] + jh->sraw;\n       if (len == 9 && !dng_version)\n         getc(ifp);\n       break;\n     case 0xffc4:\n       if (info_only)\n         break;\n       for (dp = data; dp < data + len && !((c = *dp++) & -20);)\n         jh->free[c] = jh->huff[c] = make_decoder_ref(&dp);\n       break;\n     case 0xffda:\n       jh->psv = data[1 + data[0] * 2];\n       jh->bits -= data[3 + data[0] * 2] & 15;\n       break;\n     case 0xffdb:\n       FORC(64) jh->quant[c] = data[c * 2 + 1] << 8 | data[c * 2 + 2];\n       break;\n     case 0xffdd:\n       jh->restart = data[0] << 8 | data[1];\n     }\n   } while (tag != 0xffda);\n   if (jh->bits > 16 || jh->clrs > 6 || !jh->bits || !jh->high || !jh->wide ||\n       !jh->clrs)\n     return 0;\n   if (info_only)\n     return 1;\n   if (!jh->huff[0])\n     return 0;\n   FORC(19) if (!jh->huff[c + 1]) jh->huff[c + 1] = jh->huff[c];\n   if (jh->sraw)\n   {\n     FORC(4) jh->huff[2 + c] = jh->huff[1];\n     FORC(jh->sraw) jh->huff[1 + c] = jh->huff[0];\n   }\n// bug_start\n  jh->row = (ushort *)calloc(jh->wide * jh->clrs, 4);\n// bug_end\n   merror(jh->row, \"ljpeg_start()\");\n   return zero_after_ff = 1;\n }\n \n", "target": "// fix_start\n  jh->row = (ushort *)calloc(jh->wide * jh->clrs, 16);\n// fix_end\n", "cwe": "CWE-125", "cwe_name": "Out-of-bounds Read", "cve": "CVE-2020-35533", "cve_desc": "In LibRaw, an out-of-bounds read vulnerability exists within the \"LibRaw::adobe_copy_pixel()\" function (libraw\\src\\decoders\\dng.cpp) when reading data from the image file.", "project": "LibRaw", "idx": 201452}
{"source": " unsigned long move_page_tables(struct vm_area_struct *vma,\n \t\tunsigned long old_addr, struct vm_area_struct *new_vma,\n \t\tunsigned long new_addr, unsigned long len,\n \t\tbool need_rmap_locks)\n {\n \tunsigned long extent, next, old_end;\n \tstruct mmu_notifier_range range;\n \tpmd_t *old_pmd, *new_pmd;\n \n \told_end = old_addr + len;\n \tflush_cache_range(vma, old_addr, old_end);\n \n \tmmu_notifier_range_init(&range, MMU_NOTIFY_UNMAP, 0, vma, vma->vm_mm,\n \t\t\t\told_addr, old_end);\n \tmmu_notifier_invalidate_range_start(&range);\n \n \tfor (; old_addr < old_end; old_addr += extent, new_addr += extent) {\n \t\tcond_resched();\n \t\tnext = (old_addr + PMD_SIZE) & PMD_MASK;\n \t\textent = next - old_addr;\n \t\tif (extent > old_end - old_addr)\n \t\t\textent = old_end - old_addr;\n \t\told_pmd = get_old_pmd(vma->vm_mm, old_addr);\n \t\tif (!old_pmd)\n \t\t\tcontinue;\n \t\tnew_pmd = alloc_new_pmd(vma->vm_mm, vma, new_addr);\n \t\tif (!new_pmd)\n \t\t\tbreak;\n// bug_start\n\t\tif (is_swap_pmd(*old_pmd) || pmd_trans_huge(*old_pmd)) {\n// bug_end\n \t\t\tif (extent == HPAGE_PMD_SIZE) {\n \t\t\t\tbool moved;\n \t\t\t\tif (need_rmap_locks)\n \t\t\t\t\ttake_rmap_locks(vma);\n \t\t\t\tmoved = move_huge_pmd(vma, old_addr, new_addr,\n \t\t\t\t\t\t    old_end, old_pmd, new_pmd);\n \t\t\t\tif (need_rmap_locks)\n \t\t\t\t\tdrop_rmap_locks(vma);\n \t\t\t\tif (moved)\n \t\t\t\t\tcontinue;\n \t\t\t}\n \t\t\tsplit_huge_pmd(vma, old_pmd, old_addr);\n \t\t\tif (pmd_trans_unstable(old_pmd))\n \t\t\t\tcontinue;\n \t\t} else if (extent == PMD_SIZE) {\n #ifdef CONFIG_HAVE_MOVE_PMD\n \t\t\tbool moved;\n \n \t\t\tif (need_rmap_locks)\n \t\t\t\ttake_rmap_locks(vma);\n \t\t\tmoved = move_normal_pmd(vma, old_addr, new_addr,\n \t\t\t\t\told_end, old_pmd, new_pmd);\n \t\t\tif (need_rmap_locks)\n \t\t\t\tdrop_rmap_locks(vma);\n \t\t\tif (moved)\n \t\t\t\tcontinue;\n #endif\n \t\t}\n \n \t\tif (pte_alloc(new_vma->vm_mm, new_pmd))\n \t\t\tbreak;\n \t\tnext = (new_addr + PMD_SIZE) & PMD_MASK;\n \t\tif (extent > next - new_addr)\n \t\t\textent = next - new_addr;\n \t\tmove_ptes(vma, old_pmd, old_addr, old_addr + extent, new_vma,\n \t\t\t  new_pmd, new_addr, need_rmap_locks);\n \t}\n \n \tmmu_notifier_invalidate_range_end(&range);\n \n \treturn len + old_addr - old_end;\n }\n \n", "target": "// fix_start\n\t\tif (is_swap_pmd(*old_pmd) || pmd_trans_huge(*old_pmd) || pmd_devmap(*old_pmd)) {\n// fix_end\n", "cwe": "CWE-119", "cwe_name": "Improper Restriction of Operations within the Bounds of a Memory Buffer", "cve": "CVE-2020-10757", "cve_desc": "A flaw was found in the Linux Kernel in versions after 4.5-rc1 in the way mremap handled DAX Huge Pages. This flaw allows a local attacker with access to a DAX enabled storage to escalate their privileges on the system.", "project": "linux", "idx": 201788}
{"source": " Sfdouble_t sh_strnum(Shell_t *shp, const char *str, char **ptr, int mode) {\n     Sfdouble_t d;\n     char *last;\n \n     if (*str == 0) {\n// bug_start\n        if (ptr) *ptr = (char *)str;\n        return 0;\n    }\n    errno = 0;\n    d = number(str, &last, shp->inarith ? 0 : 10, NULL);\n    if (*last) {\n        if (*last != '.' || last[1] != '.') {\n            d = strval(shp, str, &last, arith, mode);\n            Varsubscript = true;\n// bug_end\n         }\n// bug_start\n        if (!ptr && *last && mode > 0) errormsg(SH_DICT, ERROR_exit(1), e_lexbadchar, *last, str);\n    } else if (!d && *str == '-') {\n        d = -0.0;\n// bug_end\n     }\n     if (ptr) *ptr = last;\n     return d;\n }\n \n", "target": "// fix_start\n        d = 0.0;\n        last = (char *)str;\n    } else {\n        d = number(str, &last, shp->inarith ? 0 : 10, NULL);\n        if (*last && !shp->inarith && sh_isstate(shp, SH_INIT)) {\n            d = number(str, &last, 0, NULL);\n// fix_end\n// fix_start\n        if (*last) {\n            if (sh_isstate(shp, SH_INIT)) {\n                d = 0.0;\n            } else {\n                if (*last != '.' || last[1] != '.') {\n                    d = strval(shp, str, &last, arith, mode);\n                    Varsubscript = true;\n                }\n                if (!ptr && *last && mode > 0) {\n                    errormsg(SH_DICT, ERROR_exit(1), e_lexbadchar, *last, str);\n                }\n            }\n        } else if (d == 0.0 && *str == '-') {\n            d = -0.0;\n        }\n// fix_end\n", "cwe": "CWE-77", "cwe_name": "Improper Neutralization of Special Elements used in a Command ('Command Injection')", "cve": "CVE-2019-14868", "cve_desc": "In ksh version 20120801, a flaw was found in the way it evaluates certain environment variables. An attacker could use this flaw to override or bypass environment restrictions to execute shell commands. Services and applications that allow remote unauthenticated attackers to provide one of those environment variables could allow them to exploit this issue remotely.", "project": "ast", "idx": 201806}
{"source": "// bug_start\nextern int x11_set_xauth(char *xauthority, char *cookie,\n\t\t\t char *host, uint16_t display)\n// bug_end\n {\n \tint i=0, status;\n \tchar *result;\n \tchar **xauth_argv;\n \n \txauth_argv = xmalloc(sizeof(char *) * 10);\n \txauth_argv[i++] = xstrdup(\"xauth\");\n \txauth_argv[i++] = xstrdup(\"-v\");\n \txauth_argv[i++] = xstrdup(\"-f\");\n \txauth_argv[i++] = xstrdup(xauthority);\n// bug_start\n\txauth_argv[i++] = xstrdup(\"add\");\n// bug_end\n \txauth_argv[i++] = xstrdup_printf(\"%s/unix:%u\", host, display);\n// bug_start\n\txauth_argv[i++] = xstrdup(\"MIT-MAGIC-COOKIE-1\");\n\txauth_argv[i++] = xstrdup(cookie);\n// bug_end\n \txauth_argv[i++] = NULL;\n \txassert(i < 10);\n \n \tresult = run_command(\"xauth\", XAUTH_PATH, xauth_argv, 10000, 0,\n \t\t\t     &status);\n \n \tfree_command_argv(xauth_argv);\n \n \tdebug2(\"%s: result from xauth: %s\", __func__, result);\n \txfree(result);\n \n \treturn status;\n }\n \n", "target": "// fix_start\nextern int x11_delete_xauth(char *xauthority, char *host, uint16_t display)\n// fix_end\n// fix_start\n\txauth_argv[i++] = xstrdup(\"remove\");\n// fix_end\n// fix_start\n// fix_end\n", "cwe": "CWE-362", "cwe_name": "Concurrent Execution using Shared Resource with Improper Synchronization ('Race Condition')", "cve": "CVE-2020-27746", "cve_desc": "Slurm before 19.05.8 and 20.x before 20.02.6 exposes Sensitive Information to an Unauthorized Actor because xauth for X11 magic cookies is affected by a race condition in a read operation on the /proc filesystem.", "project": "slurm", "idx": 201848}
{"source": " archive_string_append_from_wcs(struct archive_string *as,\n     const wchar_t *w, size_t len)\n {\n \tint n, ret_val = 0;\n \tchar *p;\n \tchar *end;\n #if HAVE_WCRTOMB\n \tmbstate_t shift_state;\n \n \tmemset(&shift_state, 0, sizeof(shift_state));\n #else\n \twctomb(NULL, L'\\0');\n #endif\n \tif (archive_string_ensure(as, as->length + len + 1) == NULL)\n \t\treturn (-1);\n \n \tp = as->s + as->length;\n \tend = as->s + as->buffer_length - MB_CUR_MAX -1;\n \twhile (*w != L'\\0' && len > 0) {\n \t\tif (p >= end) {\n \t\t\tas->length = p - as->s;\n \t\t\tas->s[as->length] = '\\0';\n \t\t\tif (archive_string_ensure(as,\n// bug_start\n\t\t\t    as->length + len * 2 + 1) == NULL)\n// bug_end\n \t\t\t\treturn (-1);\n \t\t\tp = as->s + as->length;\n \t\t\tend = as->s + as->buffer_length - MB_CUR_MAX -1;\n \t\t}\n #if HAVE_WCRTOMB\n \t\tn = wcrtomb(p, *w++, &shift_state);\n #else\n \t\tn = wctomb(p, *w++);\n #endif\n \t\tif (n == -1) {\n \t\t\tif (errno == EILSEQ) {\n \t\t\t\t*p++ = '?';\n \t\t\t\tret_val = -1;\n \t\t\t} else {\n \t\t\t\tret_val = -1;\n \t\t\t\tbreak;\n \t\t\t}\n \t\t} else\n \t\t\tp += n;\n \t\tlen--;\n \t}\n \tas->length = p - as->s;\n \tas->s[as->length] = '\\0';\n \treturn (ret_val);\n }\n \n", "target": "// fix_start\n\t\t\t    as->length + max(len * 2,\n\t\t\t    (size_t)MB_CUR_MAX) + 1) == NULL)\n// fix_end\n", "cwe": "CWE-787", "cwe_name": "Out-of-bounds Write", "cve": "CVE-2020-21674", "cve_desc": "Heap-based buffer overflow in archive_string_append_from_wcs() (archive_string.c) in libarchive-3.4.1dev allows remote attackers to cause a denial of service (out-of-bounds write in heap memory resulting into a crash) via a crafted archive file. NOTE: this only affects users who downloaded the development code from GitHub. Users of the product's official releases are unaffected.", "project": "libarchive", "idx": 201874}
{"source": " void __do_SAK(struct tty_struct *tty)\n {\n #ifdef TTY_SOFT_SAK\n \ttty_hangup(tty);\n #else\n \tstruct task_struct *g, *p;\n \tstruct pid *session;\n \tint\t\ti;\n// bug_start\n// bug_end\n \n \tif (!tty)\n \t\treturn;\n// bug_start\n\tsession = tty->session;\n// bug_end\n \n \ttty_ldisc_flush(tty);\n \n \ttty_driver_flush_buffer(tty);\n \n \tread_lock(&tasklist_lock);\n \tdo_each_pid_task(session, PIDTYPE_SID, p) {\n \t\ttty_notice(tty, \"SAK: killed process %d (%s): by session\\n\",\n \t\t\t   task_pid_nr(p), p->comm);\n \t\tgroup_send_sig_info(SIGKILL, SEND_SIG_PRIV, p, PIDTYPE_SID);\n \t} while_each_pid_task(session, PIDTYPE_SID, p);\n \n \tdo_each_thread(g, p) {\n \t\tif (p->signal->tty == tty) {\n \t\t\ttty_notice(tty, \"SAK: killed process %d (%s): by controlling tty\\n\",\n \t\t\t\t   task_pid_nr(p), p->comm);\n \t\t\tgroup_send_sig_info(SIGKILL, SEND_SIG_PRIV, p, PIDTYPE_SID);\n \t\t\tcontinue;\n \t\t}\n \t\ttask_lock(p);\n \t\ti = iterate_fd(p->files, 0, this_tty, tty);\n \t\tif (i != 0) {\n \t\t\ttty_notice(tty, \"SAK: killed process %d (%s): by fd#%d\\n\",\n \t\t\t\t   task_pid_nr(p), p->comm, i - 1);\n \t\t\tgroup_send_sig_info(SIGKILL, SEND_SIG_PRIV, p, PIDTYPE_SID);\n \t\t}\n \t\ttask_unlock(p);\n \t} while_each_thread(g, p);\n \tread_unlock(&tasklist_lock);\n// bug_start\n// bug_end\n #endif\n }\n \n", "target": "// fix_start\n\tunsigned long flags;\n// fix_end\n// fix_start\n\n\tspin_lock_irqsave(&tty->ctrl_lock, flags);\n\tsession = get_pid(tty->session);\n\tspin_unlock_irqrestore(&tty->ctrl_lock, flags);\n// fix_end\n// fix_start\n\tput_pid(session);\n// fix_end\n", "cwe": "CWE-416", "cwe_name": "Use After Free", "cve": "CVE-2020-29660", "cve_desc": "A locking inconsistency issue was discovered in the tty subsystem of the Linux kernel through 5.9.13. drivers/tty/tty_io.c and drivers/tty/tty_jobctrl.c may allow a read-after-free attack against TIOCGSID, aka CID-c8bcd9c5be24.", "project": "linux", "idx": 201881}
{"source": " long uv__idna_toascii(const char* s, const char* se, char* d, char* de) {\n   const char* si;\n   const char* st;\n   unsigned c;\n   char* ds;\n   int rc;\n \n   ds = d;\n \n// bug_start\n  for (si = s; si < se; ) {\n// bug_end\n     st = si;\n     c = uv__utf8_decode1(&si, se);\n// bug_start\n// bug_end\n \n     if (c != '.')\n       if (c != 0x3002)\n         if (c != 0xFF0E)\n           if (c != 0xFF61)\n             continue;\n \n     rc = uv__idna_toascii_label(s, st, &d, de);\n \n     if (rc < 0)\n       return rc;\n \n     if (d < de)\n       *d++ = '.';\n \n     s = si;\n   }\n \n   if (s < se) {\n     rc = uv__idna_toascii_label(s, se, &d, de);\n \n     if (rc < 0)\n       return rc;\n   }\n \n   if (d < de)\n     *d++ = '\\0';\n \n   return d - ds;\n }\n \n", "target": "// fix_start\n  si = s;\n  while (si < se) {\n// fix_end\n// fix_start\n\n    if (c == -1u)\n      return UV_EINVAL;\n// fix_end\n", "cwe": "CWE-125", "cwe_name": "Out-of-bounds Read", "cve": "CVE-2021-22918", "cve_desc": "Node.js before 16.4.1, 14.17.2, 12.22.2 is vulnerable to an out-of-bounds read when uv__idna_toascii() is used to convert strings to ASCII. The pointer p is read and increased without checking whether it is beyond pe, with the latter holding a pointer to the end of the buffer. This can lead to information disclosures or crashes. This function can be triggered via uv_getaddrinfo().", "project": "libuv", "idx": 201892}
{"source": " static int nf_tables_newset(struct sk_buff *skb, const struct nfnl_info *info,\n \t\t\t    const struct nlattr * const nla[])\n {\n \tconst struct nfgenmsg *nfmsg = nlmsg_data(info->nlh);\n \tu32 ktype, dtype, flags, policy, gc_int, objtype;\n \tstruct netlink_ext_ack *extack = info->extack;\n \tu8 genmask = nft_genmask_next(info->net);\n \tint family = nfmsg->nfgen_family;\n \tconst struct nft_set_ops *ops;\n \tstruct nft_expr *expr = NULL;\n \tstruct net *net = info->net;\n \tstruct nft_set_desc desc;\n \tstruct nft_table *table;\n \tunsigned char *udata;\n \tstruct nft_set *set;\n \tstruct nft_ctx ctx;\n \tsize_t alloc_size;\n \tu64 timeout;\n \tchar *name;\n \tint err, i;\n \tu16 udlen;\n \tu64 size;\n \n \tif (nla[NFTA_SET_TABLE] == NULL ||\n \t    nla[NFTA_SET_NAME] == NULL ||\n \t    nla[NFTA_SET_KEY_LEN] == NULL ||\n \t    nla[NFTA_SET_ID] == NULL)\n \t\treturn -EINVAL;\n \n \tmemset(&desc, 0, sizeof(desc));\n \n \tktype = NFT_DATA_VALUE;\n \tif (nla[NFTA_SET_KEY_TYPE] != NULL) {\n \t\tktype = ntohl(nla_get_be32(nla[NFTA_SET_KEY_TYPE]));\n \t\tif ((ktype & NFT_DATA_RESERVED_MASK) == NFT_DATA_RESERVED_MASK)\n \t\t\treturn -EINVAL;\n \t}\n \n \tdesc.klen = ntohl(nla_get_be32(nla[NFTA_SET_KEY_LEN]));\n \tif (desc.klen == 0 || desc.klen > NFT_DATA_VALUE_MAXLEN)\n \t\treturn -EINVAL;\n \n \tflags = 0;\n \tif (nla[NFTA_SET_FLAGS] != NULL) {\n \t\tflags = ntohl(nla_get_be32(nla[NFTA_SET_FLAGS]));\n \t\tif (flags & ~(NFT_SET_ANONYMOUS | NFT_SET_CONSTANT |\n \t\t\t      NFT_SET_INTERVAL | NFT_SET_TIMEOUT |\n \t\t\t      NFT_SET_MAP | NFT_SET_EVAL |\n \t\t\t      NFT_SET_OBJECT | NFT_SET_CONCAT | NFT_SET_EXPR))\n \t\t\treturn -EOPNOTSUPP;\n \t\tif ((flags & (NFT_SET_MAP | NFT_SET_OBJECT)) ==\n \t\t\t     (NFT_SET_MAP | NFT_SET_OBJECT))\n \t\t\treturn -EOPNOTSUPP;\n \t\tif ((flags & (NFT_SET_EVAL | NFT_SET_OBJECT)) ==\n \t\t\t     (NFT_SET_EVAL | NFT_SET_OBJECT))\n \t\t\treturn -EOPNOTSUPP;\n \t}\n \n \tdtype = 0;\n \tif (nla[NFTA_SET_DATA_TYPE] != NULL) {\n \t\tif (!(flags & NFT_SET_MAP))\n \t\t\treturn -EINVAL;\n \n \t\tdtype = ntohl(nla_get_be32(nla[NFTA_SET_DATA_TYPE]));\n \t\tif ((dtype & NFT_DATA_RESERVED_MASK) == NFT_DATA_RESERVED_MASK &&\n \t\t    dtype != NFT_DATA_VERDICT)\n \t\t\treturn -EINVAL;\n \n \t\tif (dtype != NFT_DATA_VERDICT) {\n \t\t\tif (nla[NFTA_SET_DATA_LEN] == NULL)\n \t\t\t\treturn -EINVAL;\n \t\t\tdesc.dlen = ntohl(nla_get_be32(nla[NFTA_SET_DATA_LEN]));\n \t\t\tif (desc.dlen == 0 || desc.dlen > NFT_DATA_VALUE_MAXLEN)\n \t\t\t\treturn -EINVAL;\n \t\t} else\n \t\t\tdesc.dlen = sizeof(struct nft_verdict);\n \t} else if (flags & NFT_SET_MAP)\n \t\treturn -EINVAL;\n \n \tif (nla[NFTA_SET_OBJ_TYPE] != NULL) {\n \t\tif (!(flags & NFT_SET_OBJECT))\n \t\t\treturn -EINVAL;\n \n \t\tobjtype = ntohl(nla_get_be32(nla[NFTA_SET_OBJ_TYPE]));\n \t\tif (objtype == NFT_OBJECT_UNSPEC ||\n \t\t    objtype > NFT_OBJECT_MAX)\n \t\t\treturn -EOPNOTSUPP;\n \t} else if (flags & NFT_SET_OBJECT)\n \t\treturn -EINVAL;\n \telse\n \t\tobjtype = NFT_OBJECT_UNSPEC;\n \n \ttimeout = 0;\n \tif (nla[NFTA_SET_TIMEOUT] != NULL) {\n \t\tif (!(flags & NFT_SET_TIMEOUT))\n \t\t\treturn -EINVAL;\n \n \t\terr = nf_msecs_to_jiffies64(nla[NFTA_SET_TIMEOUT], &timeout);\n \t\tif (err)\n \t\t\treturn err;\n \t}\n \tgc_int = 0;\n \tif (nla[NFTA_SET_GC_INTERVAL] != NULL) {\n \t\tif (!(flags & NFT_SET_TIMEOUT))\n \t\t\treturn -EINVAL;\n \t\tgc_int = ntohl(nla_get_be32(nla[NFTA_SET_GC_INTERVAL]));\n \t}\n \n \tpolicy = NFT_SET_POL_PERFORMANCE;\n \tif (nla[NFTA_SET_POLICY] != NULL)\n \t\tpolicy = ntohl(nla_get_be32(nla[NFTA_SET_POLICY]));\n \n \tif (nla[NFTA_SET_DESC] != NULL) {\n \t\terr = nf_tables_set_desc_parse(&desc, nla[NFTA_SET_DESC]);\n \t\tif (err < 0)\n \t\t\treturn err;\n \t}\n \n \tif (nla[NFTA_SET_EXPR] || nla[NFTA_SET_EXPRESSIONS])\n \t\tdesc.expr = true;\n \n \ttable = nft_table_lookup(net, nla[NFTA_SET_TABLE], family, genmask,\n \t\t\t\t NETLINK_CB(skb).portid);\n \tif (IS_ERR(table)) {\n \t\tNL_SET_BAD_ATTR(extack, nla[NFTA_SET_TABLE]);\n \t\treturn PTR_ERR(table);\n \t}\n \n \tnft_ctx_init(&ctx, net, skb, info->nlh, family, table, NULL, nla);\n \n \tset = nft_set_lookup(table, nla[NFTA_SET_NAME], genmask);\n \tif (IS_ERR(set)) {\n \t\tif (PTR_ERR(set) != -ENOENT) {\n \t\t\tNL_SET_BAD_ATTR(extack, nla[NFTA_SET_NAME]);\n \t\t\treturn PTR_ERR(set);\n \t\t}\n \t} else {\n \t\tif (info->nlh->nlmsg_flags & NLM_F_EXCL) {\n \t\t\tNL_SET_BAD_ATTR(extack, nla[NFTA_SET_NAME]);\n \t\t\treturn -EEXIST;\n \t\t}\n \t\tif (info->nlh->nlmsg_flags & NLM_F_REPLACE)\n \t\t\treturn -EOPNOTSUPP;\n \n \t\treturn 0;\n \t}\n \n \tif (!(info->nlh->nlmsg_flags & NLM_F_CREATE))\n \t\treturn -ENOENT;\n \n \tops = nft_select_set_ops(&ctx, nla, &desc, policy);\n \tif (IS_ERR(ops))\n \t\treturn PTR_ERR(ops);\n \n \tudlen = 0;\n \tif (nla[NFTA_SET_USERDATA])\n \t\tudlen = nla_len(nla[NFTA_SET_USERDATA]);\n \n \tsize = 0;\n \tif (ops->privsize != NULL)\n \t\tsize = ops->privsize(nla, &desc);\n \talloc_size = sizeof(*set) + size + udlen;\n \tif (alloc_size < size)\n \t\treturn -ENOMEM;\n \tset = kvzalloc(alloc_size, GFP_KERNEL);\n \tif (!set)\n \t\treturn -ENOMEM;\n \n \tname = nla_strdup(nla[NFTA_SET_NAME], GFP_KERNEL);\n \tif (!name) {\n \t\terr = -ENOMEM;\n \t\tgoto err_set_name;\n \t}\n \n \terr = nf_tables_set_alloc_name(&ctx, set, name);\n \tkfree(name);\n \tif (err < 0)\n// bug_start\n\t\tgoto err_set_alloc_name;\n// bug_end\n \n \tif (nla[NFTA_SET_EXPR]) {\n \t\texpr = nft_set_elem_expr_alloc(&ctx, set, nla[NFTA_SET_EXPR]);\n \t\tif (IS_ERR(expr)) {\n \t\t\terr = PTR_ERR(expr);\n// bug_start\n\t\t\tgoto err_set_alloc_name;\n// bug_end\n \t\t}\n \t\tset->exprs[0] = expr;\n \t\tset->num_exprs++;\n \t} else if (nla[NFTA_SET_EXPRESSIONS]) {\n \t\tstruct nft_expr *expr;\n \t\tstruct nlattr *tmp;\n \t\tint left;\n \n \t\tif (!(flags & NFT_SET_EXPR)) {\n \t\t\terr = -EINVAL;\n// bug_start\n\t\t\tgoto err_set_alloc_name;\n// bug_end\n \t\t}\n \t\ti = 0;\n \t\tnla_for_each_nested(tmp, nla[NFTA_SET_EXPRESSIONS], left) {\n \t\t\tif (i == NFT_SET_EXPR_MAX) {\n \t\t\t\terr = -E2BIG;\n// bug_start\n\t\t\t\tgoto err_set_init;\n// bug_end\n \t\t\t}\n \t\t\tif (nla_type(tmp) != NFTA_LIST_ELEM) {\n \t\t\t\terr = -EINVAL;\n// bug_start\n\t\t\t\tgoto err_set_init;\n// bug_end\n \t\t\t}\n \t\t\texpr = nft_set_elem_expr_alloc(&ctx, set, tmp);\n \t\t\tif (IS_ERR(expr)) {\n \t\t\t\terr = PTR_ERR(expr);\n// bug_start\n\t\t\t\tgoto err_set_init;\n// bug_end\n \t\t\t}\n \t\t\tset->exprs[i++] = expr;\n \t\t\tset->num_exprs++;\n \t\t}\n \t}\n \n// bug_start\n\tudata = NULL;\n\tif (udlen) {\n\t\tudata = set->data + size;\n\t\tnla_memcpy(udata, nla[NFTA_SET_USERDATA], udlen);\n\t}\n\n\tINIT_LIST_HEAD(&set->bindings);\n\tINIT_LIST_HEAD(&set->catchall_list);\n\tset->table = table;\n\twrite_pnet(&set->net, net);\n\tset->ops   = ops;\n\tset->ktype = ktype;\n\tset->klen  = desc.klen;\n\tset->dtype = dtype;\n\tset->objtype = objtype;\n\tset->dlen  = desc.dlen;\n\tset->flags = flags;\n\tset->size  = desc.size;\n\tset->policy = policy;\n\tset->udlen  = udlen;\n\tset->udata  = udata;\n\tset->timeout = timeout;\n\tset->gc_int = gc_int;\n// bug_end\n \tset->handle = nf_tables_alloc_handle(table);\n// bug_start\n\n\tset->field_count = desc.field_count;\n\tfor (i = 0; i < desc.field_count; i++)\n\t\tset->field_len[i] = desc.field_len[i];\n\n\terr = ops->init(set, &desc, nla);\n\tif (err < 0)\n\t\tgoto err_set_init;\n// bug_end\n \n \terr = nft_trans_set_add(&ctx, NFT_MSG_NEWSET, set);\n \tif (err < 0)\n// bug_start\n\t\tgoto err_set_trans;\n// bug_end\n \n \tlist_add_tail_rcu(&set->list, &table->sets);\n \ttable->use++;\n \treturn 0;\n \n// bug_start\nerr_set_trans:\n// bug_end\n \tops->destroy(set);\n err_set_init:\n// bug_start\n\tfor (i = 0; i < set->num_exprs; i++)\n\t\tnft_expr_destroy(&ctx, set->exprs[i]);\nerr_set_alloc_name:\n// bug_end\n \tkfree(set->name);\n err_set_name:\n \tkvfree(set);\n \treturn err;\n }\n \n", "target": "// fix_start\n\t\tgoto err_set_name;\n\n\tudata = NULL;\n\tif (udlen) {\n\t\tudata = set->data + size;\n\t\tnla_memcpy(udata, nla[NFTA_SET_USERDATA], udlen);\n\t}\n\n\tINIT_LIST_HEAD(&set->bindings);\n\tINIT_LIST_HEAD(&set->catchall_list);\n\tset->table = table;\n\twrite_pnet(&set->net, net);\n\tset->ops = ops;\n\tset->ktype = ktype;\n\tset->klen = desc.klen;\n\tset->dtype = dtype;\n\tset->objtype = objtype;\n\tset->dlen = desc.dlen;\n\tset->flags = flags;\n\tset->size = desc.size;\n\tset->policy = policy;\n\tset->udlen = udlen;\n\tset->udata = udata;\n\tset->timeout = timeout;\n\tset->gc_int = gc_int;\n\n\tset->field_count = desc.field_count;\n\tfor (i = 0; i < desc.field_count; i++)\n\t\tset->field_len[i] = desc.field_len[i];\n\n\terr = ops->init(set, &desc, nla);\n\tif (err < 0)\n\t\tgoto err_set_init;\n// fix_end\n// fix_start\n\t\t\tgoto err_set_expr_alloc;\n// fix_end\n// fix_start\n\t\t\tgoto err_set_expr_alloc;\n// fix_end\n// fix_start\n\t\t\t\tgoto err_set_expr_alloc;\n// fix_end\n// fix_start\n\t\t\t\tgoto err_set_expr_alloc;\n// fix_end\n// fix_start\n\t\t\t\tgoto err_set_expr_alloc;\n// fix_end\n// fix_start\n// fix_end\n// fix_start\n// fix_end\n// fix_start\n\t\tgoto err_set_expr_alloc;\n// fix_end\n// fix_start\nerr_set_expr_alloc:\n\tfor (i = 0; i < set->num_exprs; i++)\n\t\tnft_expr_destroy(&ctx, set->exprs[i]);\n\n// fix_end\n// fix_start\n// fix_end\n", "cwe": "CWE-665", "cwe_name": "Improper Initialization", "cve": "CVE-2021-46283", "cve_desc": "nf_tables_newset in net/netfilter/nf_tables_api.c in the Linux kernel before 5.12.13 allows local users to cause a denial of service (NULL pointer dereference and general protection fault) because of the missing initialization for nft_set_elem_expr_alloc. A local user can set a netfilter table expression in their own namespace.", "project": "linux", "idx": 202069}
{"source": "// bug_start\nstatic void scalar32_min_max_or(struct bpf_reg_state *dst_reg,\n\t\t\t\tstruct bpf_reg_state *src_reg)\n// bug_end\n {\n// bug_start\n\tbool src_known = tnum_subreg_is_const(src_reg->var_off);\n\tbool dst_known = tnum_subreg_is_const(dst_reg->var_off);\n\tstruct tnum var32_off = tnum_subreg(dst_reg->var_off);\n\ts32 smin_val = src_reg->smin_value;\n\tu32 umin_val = src_reg->umin_value;\n// bug_end\n \n// bug_start\n\tif (src_known && dst_known)\n// bug_end\n \t\treturn;\n// bug_start\n// bug_end\n \n// bug_start\n\tdst_reg->u32_min_value = max(dst_reg->u32_min_value, umin_val);\n\tdst_reg->u32_max_value = var32_off.value | var32_off.mask;\n\tif (dst_reg->s32_min_value < 0 || smin_val < 0) {\n\t\tdst_reg->s32_min_value = S32_MIN;\n\t\tdst_reg->s32_max_value = S32_MAX;\n// bug_end\n \t} else {\n// bug_start\n\t\tdst_reg->s32_min_value = dst_reg->umin_value;\n\t\tdst_reg->s32_max_value = dst_reg->umax_value;\n// bug_end\n \t}\n// bug_start\n// bug_end\n }\n \n", "target": "// fix_start\nstatic void scalar_min_max_or(struct bpf_reg_state *dst_reg,\n\t\t\t      struct bpf_reg_state *src_reg)\n// fix_end\n// fix_start\n\tbool src_known = tnum_is_const(src_reg->var_off);\n\tbool dst_known = tnum_is_const(dst_reg->var_off);\n\ts64 smin_val = src_reg->smin_value;\n\tu64 umin_val = src_reg->umin_value;\n// fix_end\n// fix_start\n\tif (src_known && dst_known) {\n\t\t__mark_reg_known(dst_reg, dst_reg->var_off.value |\n\t\t\t\t\t  src_reg->var_off.value);\n// fix_end\n// fix_start\n\t}\n// fix_end\n// fix_start\n\tdst_reg->umin_value = max(dst_reg->umin_value, umin_val);\n\tdst_reg->umax_value = dst_reg->var_off.value | dst_reg->var_off.mask;\n\tif (dst_reg->smin_value < 0 || smin_val < 0) {\n\t\tdst_reg->smin_value = S64_MIN;\n\t\tdst_reg->smax_value = S64_MAX;\n// fix_end\n// fix_start\n\t\tdst_reg->smin_value = dst_reg->umin_value;\n\t\tdst_reg->smax_value = dst_reg->umax_value;\n// fix_end\n// fix_start\n\t__update_reg_bounds(dst_reg);\n// fix_end\n", "cwe": "CWE-787", "cwe_name": "Out-of-bounds Write", "cve": "CVE-2020-27194", "cve_desc": "An issue was discovered in the Linux kernel before 5.8.15. scalar32_min_max_or in kernel/bpf/verifier.c mishandles bounds tracking during use of 64-bit values, aka CID-5b9fbeb75b6a.", "project": "linux", "idx": 202076}
{"source": " slap_modrdn2mods(\n \tOperation\t*op,\n \tSlapReply\t*rs )\n {\n \tint\t\ta_cnt, d_cnt;\n \tLDAPRDN\t\told_rdn = NULL;\n \tLDAPRDN\t\tnew_rdn = NULL;\n \n \tassert( !BER_BVISEMPTY( &op->oq_modrdn.rs_newrdn ) );\n \n \tif ( BER_BVISEMPTY( &op->o_req_dn ) ) op->orr_deleteoldrdn = 0;\n \n \tif ( ldap_bv2rdn_x( &op->oq_modrdn.rs_newrdn, &new_rdn,\n \t\t(char **)&rs->sr_text, LDAP_DN_FORMAT_LDAP, op->o_tmpmemctx ) ) {\n \t\tDebug( LDAP_DEBUG_TRACE,\n \t\t\t\"%s slap_modrdn2mods: can't figure out \"\n \t\t\t\"type(s)/value(s) of newrdn\\n\",\n \t\t\top->o_log_prefix, 0, 0 );\n \t\trs->sr_err = LDAP_INVALID_DN_SYNTAX;\n \t\trs->sr_text = \"unknown type(s)/value(s) used in RDN\";\n \t\tgoto done;\n \t}\n \n \tif ( op->oq_modrdn.rs_deleteoldrdn ) {\n \t\tif ( ldap_bv2rdn_x( &op->o_req_dn, &old_rdn,\n \t\t\t(char **)&rs->sr_text, LDAP_DN_FORMAT_LDAP, op->o_tmpmemctx ) ) {\n \t\t\tDebug( LDAP_DEBUG_TRACE,\n \t\t\t\t\"%s slap_modrdn2mods: can't figure out \"\n \t\t\t\t\"type(s)/value(s) of oldrdn\\n\",\n \t\t\t\top->o_log_prefix, 0, 0 );\n \t\t\trs->sr_err = LDAP_OTHER;\n \t\t\trs->sr_text = \"cannot parse RDN from old DN\";\n \t\t\tgoto done;\n \t\t}\n \t}\n \trs->sr_text = NULL;\n \n \tfor ( a_cnt = 0; new_rdn[a_cnt]; a_cnt++ ) {\n \t\tAttributeDescription\t*desc = NULL;\n \t\tModifications \t\t*mod_tmp;\n \n \t\trs->sr_err = slap_bv2ad( &new_rdn[a_cnt]->la_attr, &desc, &rs->sr_text );\n \n \t\tif ( rs->sr_err != LDAP_SUCCESS ) {\n \t\t\tDebug( LDAP_DEBUG_TRACE,\n \t\t\t\t\"%s slap_modrdn2mods: %s: %s (new)\\n\",\n \t\t\t\top->o_log_prefix,\n \t\t\t\trs->sr_text,\n \t\t\t\tnew_rdn[ a_cnt ]->la_attr.bv_val );\n \t\t\tgoto done;\n \t\t}\n \n \t\tif ( !desc->ad_type->sat_equality ) {\n \t\t\tDebug( LDAP_DEBUG_TRACE,\n \t\t\t\t\"%s slap_modrdn2mods: %s: %s (new)\\n\",\n \t\t\t\top->o_log_prefix,\n \t\t\t\trs->sr_text,\n \t\t\t\tnew_rdn[ a_cnt ]->la_attr.bv_val );\n \t\t\trs->sr_text = \"naming attribute has no equality matching rule\";\n \t\t\trs->sr_err = LDAP_NAMING_VIOLATION;\n \t\t\tgoto done;\n \t\t}\n \n \t\tmod_tmp = ( Modifications * )ch_malloc( sizeof( Modifications ) );\n \t\tmod_tmp->sml_desc = desc;\n \t\tBER_BVZERO( &mod_tmp->sml_type );\n \t\tmod_tmp->sml_numvals = 1;\n \t\tmod_tmp->sml_values = ( BerVarray )ch_malloc( 2 * sizeof( struct berval ) );\n \t\tber_dupbv( &mod_tmp->sml_values[0], &new_rdn[a_cnt]->la_value );\n \t\tmod_tmp->sml_values[1].bv_val = NULL;\n \t\tif( desc->ad_type->sat_equality->smr_normalize) {\n \t\t\tmod_tmp->sml_nvalues = ( BerVarray )ch_malloc( 2 * sizeof( struct berval ) );\n \t\t\trs->sr_err = desc->ad_type->sat_equality->smr_normalize(\n \t\t\t\tSLAP_MR_EQUALITY|SLAP_MR_VALUE_OF_ASSERTION_SYNTAX,\n \t\t\t\tdesc->ad_type->sat_syntax,\n \t\t\t\tdesc->ad_type->sat_equality,\n \t\t\t\t&mod_tmp->sml_values[0],\n \t\t\t\t&mod_tmp->sml_nvalues[0], NULL );\n \t\t\tif (rs->sr_err != LDAP_SUCCESS) {\n \t\t\t\tch_free(mod_tmp->sml_nvalues);\n \t\t\t\tch_free(mod_tmp->sml_values[0].bv_val);\n \t\t\t\tch_free(mod_tmp->sml_values);\n \t\t\t\tch_free(mod_tmp);\n \t\t\t\tgoto done;\n \t\t\t}\n \t\t\tmod_tmp->sml_nvalues[1].bv_val = NULL;\n \t\t} else {\n \t\t\tmod_tmp->sml_nvalues = NULL;\n \t\t}\n \t\tmod_tmp->sml_op = SLAP_MOD_SOFTADD;\n \t\tmod_tmp->sml_flags = 0;\n \t\tmod_tmp->sml_next = op->orr_modlist;\n \t\top->orr_modlist = mod_tmp;\n \t}\n \n \tif ( op->orr_deleteoldrdn ) {\n \t\tfor ( d_cnt = 0; old_rdn[d_cnt]; d_cnt++ ) {\n \t\t\tAttributeDescription\t*desc = NULL;\n \t\t\tModifications \t\t*mod_tmp;\n \n \t\t\trs->sr_err = slap_bv2ad( &old_rdn[d_cnt]->la_attr, &desc, &rs->sr_text );\n \t\t\tif ( rs->sr_err != LDAP_SUCCESS ) {\n \t\t\t\tDebug( LDAP_DEBUG_TRACE,\n \t\t\t\t\t\"%s slap_modrdn2mods: %s: %s (old)\\n\",\n \t\t\t\t\top->o_log_prefix,\n \t\t\t\t\trs->sr_text,\n \t\t\t\t\told_rdn[d_cnt]->la_attr.bv_val );\n \t\t\t\tgoto done;\n \t\t\t}\n \n \t\t\tmod_tmp = ( Modifications * )ch_malloc( sizeof( Modifications ) );\n \t\t\tmod_tmp->sml_desc = desc;\n \t\t\tBER_BVZERO( &mod_tmp->sml_type );\n \t\t\tmod_tmp->sml_numvals = 1;\n \t\t\tmod_tmp->sml_values = ( BerVarray )ch_malloc( 2 * sizeof( struct berval ) );\n \t\t\tber_dupbv( &mod_tmp->sml_values[0], &old_rdn[d_cnt]->la_value );\n \t\t\tmod_tmp->sml_values[1].bv_val = NULL;\n// bug_start\n\t\t\tif( desc->ad_type->sat_equality->smr_normalize) {\n// bug_end\n \t\t\t\tmod_tmp->sml_nvalues = ( BerVarray )ch_malloc( 2 * sizeof( struct berval ) );\n \t\t\t\t(void) (*desc->ad_type->sat_equality->smr_normalize)(\n \t\t\t\t\tSLAP_MR_EQUALITY|SLAP_MR_VALUE_OF_ASSERTION_SYNTAX,\n \t\t\t\t\tdesc->ad_type->sat_syntax,\n \t\t\t\t\tdesc->ad_type->sat_equality,\n \t\t\t\t\t&mod_tmp->sml_values[0],\n \t\t\t\t\t&mod_tmp->sml_nvalues[0], NULL );\n \t\t\t\tmod_tmp->sml_nvalues[1].bv_val = NULL;\n \t\t\t} else {\n \t\t\t\tmod_tmp->sml_nvalues = NULL;\n \t\t\t}\n \t\t\tmod_tmp->sml_op = LDAP_MOD_DELETE;\n \t\t\tmod_tmp->sml_flags = 0;\n \t\t\tmod_tmp->sml_next = op->orr_modlist;\n \t\t\top->orr_modlist = mod_tmp;\n \t\t}\n \t}\n \n done:\n \n \tif ( rs->sr_err != LDAP_SUCCESS && op->orr_modlist != NULL ) {\n \t\tModifications *tmp;\n \n \t\tfor ( ; op->orr_modlist != NULL; op->orr_modlist = tmp ) {\n \t\t\ttmp = op->orr_modlist->sml_next;\n \t\t\tch_free( op->orr_modlist );\n \t\t}\n \t}\n \n \tif ( new_rdn != NULL ) {\n \t\tldap_rdnfree_x( new_rdn, op->o_tmpmemctx );\n \t}\n \tif ( old_rdn != NULL ) {\n \t\tldap_rdnfree_x( old_rdn, op->o_tmpmemctx );\n \t}\n \n \treturn rs->sr_err;\n }\n \n", "target": "// fix_start\n\t\t\tif( desc->ad_type->sat_equality && desc->ad_type->sat_equality->smr_normalize) {\n// fix_end\n", "cwe": "CWE-476", "cwe_name": "NULL Pointer Dereference", "cve": "CVE-2020-25692", "cve_desc": "A NULL pointer dereference was found in OpenLDAP server and was fixed in openldap 2.4.55, during a request for renaming RDNs. An unauthenticated attacker could remotely crash the slapd process by sending a specially crafted request, causing a Denial of Service.", "project": "openldap", "idx": 202129}
{"source": " MagickExport Image *WaveImage(const Image *image,const double amplitude,\n   const double wave_length,const PixelInterpolateMethod method,\n   ExceptionInfo *exception)\n {\n #define WaveImageTag  \"Wave/Image\"\n \n   CacheView\n     *canvas_image_view,\n     *wave_view;\n \n   float\n     *sine_map;\n \n   Image\n     *canvas_image,\n     *wave_image;\n \n   MagickBooleanType\n     status;\n \n   MagickOffsetType\n     progress;\n \n   ssize_t\n     i;\n \n   ssize_t\n     y;\n \n   assert(image != (Image *) NULL);\n   assert(image->signature == MagickCoreSignature);\n   if (image->debug != MagickFalse)\n     (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n   assert(exception != (ExceptionInfo *) NULL);\n   assert(exception->signature == MagickCoreSignature);\n   canvas_image=CloneImage(image,0,0,MagickTrue,exception);\n   if (canvas_image == (Image *) NULL)\n     return((Image *) NULL);\n   if ((canvas_image->alpha_trait == UndefinedPixelTrait) &&\n       (canvas_image->background_color.alpha != OpaqueAlpha))\n     (void) SetImageAlpha(canvas_image,OpaqueAlpha,exception);\n   wave_image=CloneImage(canvas_image,canvas_image->columns,(size_t)\n     (canvas_image->rows+2.0*fabs(amplitude)),MagickTrue,exception);\n   if (wave_image == (Image *) NULL)\n     {\n       canvas_image=DestroyImage(canvas_image);\n       return((Image *) NULL);\n     }\n   if (SetImageStorageClass(wave_image,DirectClass,exception) == MagickFalse)\n     {\n       canvas_image=DestroyImage(canvas_image);\n       wave_image=DestroyImage(wave_image);\n       return((Image *) NULL);\n     }\n   sine_map=(float *) AcquireQuantumMemory((size_t) wave_image->columns,\n     sizeof(*sine_map));\n   if (sine_map == (float *) NULL)\n     {\n       canvas_image=DestroyImage(canvas_image);\n       wave_image=DestroyImage(wave_image);\n       ThrowImageException(ResourceLimitError,\"MemoryAllocationFailed\");\n     }\n   for (i=0; i < (ssize_t) wave_image->columns; i++)\n     sine_map[i]=(float) fabs(amplitude)+amplitude*sin((double)\n// bug_start\n      ((2.0*MagickPI*i)/wave_length));\n// bug_end\n   status=MagickTrue;\n   progress=0;\n   canvas_image_view=AcquireVirtualCacheView(canvas_image,exception);\n   wave_view=AcquireAuthenticCacheView(wave_image,exception);\n   (void) SetCacheViewVirtualPixelMethod(canvas_image_view,\n     BackgroundVirtualPixelMethod);\n #if defined(MAGICKCORE_OPENMP_SUPPORT)\n   #pragma omp parallel for schedule(static) shared(progress,status) \\\n     magick_number_threads(canvas_image,wave_image,wave_image->rows,1)\n #endif\n   for (y=0; y < (ssize_t) wave_image->rows; y++)\n   {\n     const Quantum\n       *magick_restrict p;\n \n     Quantum\n       *magick_restrict q;\n \n     ssize_t\n       x;\n \n     if (status == MagickFalse)\n       continue;\n     p=GetCacheViewVirtualPixels(canvas_image_view,0,y,canvas_image->columns,1,\n       exception);\n     q=QueueCacheViewAuthenticPixels(wave_view,0,y,wave_image->columns,1,\n       exception);\n     if ((p == (const Quantum *) NULL) || (q == (Quantum *) NULL))\n       {\n         status=MagickFalse;\n         continue;\n       }\n     for (x=0; x < (ssize_t) wave_image->columns; x++)\n     {\n       status=InterpolatePixelChannels(canvas_image,canvas_image_view,\n         wave_image,method,(double) x,(double) (y-sine_map[x]),q,exception);\n       if (status == MagickFalse)\n         break;\n       p+=GetPixelChannels(canvas_image);\n       q+=GetPixelChannels(wave_image);\n     }\n     if (SyncCacheViewAuthenticPixels(wave_view,exception) == MagickFalse)\n       status=MagickFalse;\n     if (image->progress_monitor != (MagickProgressMonitor) NULL)\n       {\n         MagickBooleanType\n           proceed;\n \n #if defined(MAGICKCORE_OPENMP_SUPPORT)\n         #pragma omp atomic\n #endif\n         progress++;\n         proceed=SetImageProgress(canvas_image,WaveImageTag,progress,\n           canvas_image->rows);\n         if (proceed == MagickFalse)\n           status=MagickFalse;\n       }\n   }\n   wave_view=DestroyCacheView(wave_view);\n   canvas_image_view=DestroyCacheView(canvas_image_view);\n   canvas_image=DestroyImage(canvas_image);\n   sine_map=(float *) RelinquishMagickMemory(sine_map);\n   if (status == MagickFalse)\n     wave_image=DestroyImage(wave_image);\n   return(wave_image);\n }\n \n", "target": "// fix_start\n      ((2.0*MagickPI*i)*PerceptibleReciprocal(wave_length)));\n// fix_end\n", "cwe": "CWE-369", "cwe_name": "Divide By Zero", "cve": "CVE-2021-20309", "cve_desc": "A flaw was found in ImageMagick in versions before 7.0.11 and before 6.9.12, where a division by zero in WaveImage() of MagickCore/visual-effects.c may trigger undefined behavior via a crafted image file submitted to an application using ImageMagick. The highest threat from this vulnerability is to system availability.", "project": "ImageMagick", "idx": 202140}
{"source": " static int tpacket_rcv(struct sk_buff *skb, struct net_device *dev,\n \t\t       struct packet_type *pt, struct net_device *orig_dev)\n {\n \tstruct sock *sk;\n \tstruct packet_sock *po;\n \tstruct sockaddr_ll *sll;\n \tunion tpacket_uhdr h;\n \tu8 *skb_head = skb->data;\n \tint skb_len = skb->len;\n \tunsigned int snaplen, res;\n \tunsigned long status = TP_STATUS_USER;\n// bug_start\n\tunsigned short macoff, netoff, hdrlen;\n// bug_end\n \tstruct sk_buff *copy_skb = NULL;\n \tstruct timespec64 ts;\n \t__u32 ts_status;\n \tbool is_drop_n_account = false;\n \tunsigned int slot_id = 0;\n \tbool do_vnet = false;\n \n \tBUILD_BUG_ON(TPACKET_ALIGN(sizeof(*h.h2)) != 32);\n \tBUILD_BUG_ON(TPACKET_ALIGN(sizeof(*h.h3)) != 48);\n \n \tif (skb->pkt_type == PACKET_LOOPBACK)\n \t\tgoto drop;\n \n \tsk = pt->af_packet_priv;\n \tpo = pkt_sk(sk);\n \n \tif (!net_eq(dev_net(dev), sock_net(sk)))\n \t\tgoto drop;\n \n \tif (dev->header_ops) {\n \t\tif (sk->sk_type != SOCK_DGRAM)\n \t\t\tskb_push(skb, skb->data - skb_mac_header(skb));\n \t\telse if (skb->pkt_type == PACKET_OUTGOING) {\n \t\t\tskb_pull(skb, skb_network_offset(skb));\n \t\t}\n \t}\n \n \tsnaplen = skb->len;\n \n \tres = run_filter(skb, sk, snaplen);\n \tif (!res)\n \t\tgoto drop_n_restore;\n \n \tif (__packet_rcv_has_room(po, skb) == ROOM_NONE) {\n \t\tatomic_inc(&po->tp_drops);\n \t\tgoto drop_n_restore;\n \t}\n \n \tif (skb->ip_summed == CHECKSUM_PARTIAL)\n \t\tstatus |= TP_STATUS_CSUMNOTREADY;\n \telse if (skb->pkt_type != PACKET_OUTGOING &&\n \t\t (skb->ip_summed == CHECKSUM_COMPLETE ||\n \t\t  skb_csum_unnecessary(skb)))\n \t\tstatus |= TP_STATUS_CSUM_VALID;\n \n \tif (snaplen > res)\n \t\tsnaplen = res;\n \n \tif (sk->sk_type == SOCK_DGRAM) {\n \t\tmacoff = netoff = TPACKET_ALIGN(po->tp_hdrlen) + 16 +\n \t\t\t\t  po->tp_reserve;\n \t} else {\n \t\tunsigned int maclen = skb_network_offset(skb);\n \t\tnetoff = TPACKET_ALIGN(po->tp_hdrlen +\n \t\t\t\t       (maclen < 16 ? 16 : maclen)) +\n \t\t\t\t       po->tp_reserve;\n \t\tif (po->has_vnet_hdr) {\n \t\t\tnetoff += sizeof(struct virtio_net_hdr);\n \t\t\tdo_vnet = true;\n \t\t}\n \t\tmacoff = netoff - maclen;\n// bug_start\n// bug_end\n \t}\n \tif (po->tp_version <= TPACKET_V2) {\n \t\tif (macoff + snaplen > po->rx_ring.frame_size) {\n \t\t\tif (po->copy_thresh &&\n \t\t\t    atomic_read(&sk->sk_rmem_alloc) < sk->sk_rcvbuf) {\n \t\t\t\tif (skb_shared(skb)) {\n \t\t\t\t\tcopy_skb = skb_clone(skb, GFP_ATOMIC);\n \t\t\t\t} else {\n \t\t\t\t\tcopy_skb = skb_get(skb);\n \t\t\t\t\tskb_head = skb->data;\n \t\t\t\t}\n \t\t\t\tif (copy_skb)\n \t\t\t\t\tskb_set_owner_r(copy_skb, sk);\n \t\t\t}\n \t\t\tsnaplen = po->rx_ring.frame_size - macoff;\n \t\t\tif ((int)snaplen < 0) {\n \t\t\t\tsnaplen = 0;\n \t\t\t\tdo_vnet = false;\n \t\t\t}\n \t\t}\n \t} else if (unlikely(macoff + snaplen >\n \t\t\t    GET_PBDQC_FROM_RB(&po->rx_ring)->max_frame_len)) {\n \t\tu32 nval;\n \n \t\tnval = GET_PBDQC_FROM_RB(&po->rx_ring)->max_frame_len - macoff;\n \t\tpr_err_once(\"tpacket_rcv: packet too big, clamped from %u to %u. macoff=%u\\n\",\n \t\t\t    snaplen, nval, macoff);\n \t\tsnaplen = nval;\n \t\tif (unlikely((int)snaplen < 0)) {\n \t\t\tsnaplen = 0;\n \t\t\tmacoff = GET_PBDQC_FROM_RB(&po->rx_ring)->max_frame_len;\n \t\t\tdo_vnet = false;\n \t\t}\n \t}\n \tspin_lock(&sk->sk_receive_queue.lock);\n \th.raw = packet_current_rx_frame(po, skb,\n \t\t\t\t\tTP_STATUS_KERNEL, (macoff+snaplen));\n \tif (!h.raw)\n \t\tgoto drop_n_account;\n \n \tif (po->tp_version <= TPACKET_V2) {\n \t\tslot_id = po->rx_ring.head;\n \t\tif (test_bit(slot_id, po->rx_ring.rx_owner_map))\n \t\t\tgoto drop_n_account;\n \t\t__set_bit(slot_id, po->rx_ring.rx_owner_map);\n \t}\n \n \tif (do_vnet &&\n \t    virtio_net_hdr_from_skb(skb, h.raw + macoff -\n \t\t\t\t    sizeof(struct virtio_net_hdr),\n \t\t\t\t    vio_le(), true, 0)) {\n \t\tif (po->tp_version == TPACKET_V3)\n \t\t\tprb_clear_blk_fill_status(&po->rx_ring);\n \t\tgoto drop_n_account;\n \t}\n \n \tif (po->tp_version <= TPACKET_V2) {\n \t\tpacket_increment_rx_head(po, &po->rx_ring);\n \t\tif (atomic_read(&po->tp_drops))\n \t\t\tstatus |= TP_STATUS_LOSING;\n \t}\n \n \tpo->stats.stats1.tp_packets++;\n \tif (copy_skb) {\n \t\tstatus |= TP_STATUS_COPY;\n \t\t__skb_queue_tail(&sk->sk_receive_queue, copy_skb);\n \t}\n \tspin_unlock(&sk->sk_receive_queue.lock);\n \n \tskb_copy_bits(skb, 0, h.raw + macoff, snaplen);\n \n \tif (!(ts_status = tpacket_get_timestamp(skb, &ts, po->tp_tstamp)))\n \t\tktime_get_real_ts64(&ts);\n \n \tstatus |= ts_status;\n \n \tswitch (po->tp_version) {\n \tcase TPACKET_V1:\n \t\th.h1->tp_len = skb->len;\n \t\th.h1->tp_snaplen = snaplen;\n \t\th.h1->tp_mac = macoff;\n \t\th.h1->tp_net = netoff;\n \t\th.h1->tp_sec = ts.tv_sec;\n \t\th.h1->tp_usec = ts.tv_nsec / NSEC_PER_USEC;\n \t\thdrlen = sizeof(*h.h1);\n \t\tbreak;\n \tcase TPACKET_V2:\n \t\th.h2->tp_len = skb->len;\n \t\th.h2->tp_snaplen = snaplen;\n \t\th.h2->tp_mac = macoff;\n \t\th.h2->tp_net = netoff;\n \t\th.h2->tp_sec = ts.tv_sec;\n \t\th.h2->tp_nsec = ts.tv_nsec;\n \t\tif (skb_vlan_tag_present(skb)) {\n \t\t\th.h2->tp_vlan_tci = skb_vlan_tag_get(skb);\n \t\t\th.h2->tp_vlan_tpid = ntohs(skb->vlan_proto);\n \t\t\tstatus |= TP_STATUS_VLAN_VALID | TP_STATUS_VLAN_TPID_VALID;\n \t\t} else {\n \t\t\th.h2->tp_vlan_tci = 0;\n \t\t\th.h2->tp_vlan_tpid = 0;\n \t\t}\n \t\tmemset(h.h2->tp_padding, 0, sizeof(h.h2->tp_padding));\n \t\thdrlen = sizeof(*h.h2);\n \t\tbreak;\n \tcase TPACKET_V3:\n \t\th.h3->tp_status |= status;\n \t\th.h3->tp_len = skb->len;\n \t\th.h3->tp_snaplen = snaplen;\n \t\th.h3->tp_mac = macoff;\n \t\th.h3->tp_net = netoff;\n \t\th.h3->tp_sec  = ts.tv_sec;\n \t\th.h3->tp_nsec = ts.tv_nsec;\n \t\tmemset(h.h3->tp_padding, 0, sizeof(h.h3->tp_padding));\n \t\thdrlen = sizeof(*h.h3);\n \t\tbreak;\n \tdefault:\n \t\tBUG();\n \t}\n \n \tsll = h.raw + TPACKET_ALIGN(hdrlen);\n \tsll->sll_halen = dev_parse_header(skb, sll->sll_addr);\n \tsll->sll_family = AF_PACKET;\n \tsll->sll_hatype = dev->type;\n \tsll->sll_protocol = skb->protocol;\n \tsll->sll_pkttype = skb->pkt_type;\n \tif (unlikely(po->origdev))\n \t\tsll->sll_ifindex = orig_dev->ifindex;\n \telse\n \t\tsll->sll_ifindex = dev->ifindex;\n \n \tsmp_mb();\n \n #if ARCH_IMPLEMENTS_FLUSH_DCACHE_PAGE == 1\n \tif (po->tp_version <= TPACKET_V2) {\n \t\tu8 *start, *end;\n \n \t\tend = (u8 *) PAGE_ALIGN((unsigned long) h.raw +\n \t\t\t\t\tmacoff + snaplen);\n \n \t\tfor (start = h.raw; start < end; start += PAGE_SIZE)\n \t\t\tflush_dcache_page(pgv_to_page(start));\n \t}\n \tsmp_wmb();\n #endif\n \n \tif (po->tp_version <= TPACKET_V2) {\n \t\tspin_lock(&sk->sk_receive_queue.lock);\n \t\t__packet_set_status(po, h.raw, status);\n \t\t__clear_bit(slot_id, po->rx_ring.rx_owner_map);\n \t\tspin_unlock(&sk->sk_receive_queue.lock);\n \t\tsk->sk_data_ready(sk);\n \t} else if (po->tp_version == TPACKET_V3) {\n \t\tprb_clear_blk_fill_status(&po->rx_ring);\n \t}\n \n drop_n_restore:\n \tif (skb_head != skb->data && skb_shared(skb)) {\n \t\tskb->data = skb_head;\n \t\tskb->len = skb_len;\n \t}\n drop:\n \tif (!is_drop_n_account)\n \t\tconsume_skb(skb);\n \telse\n \t\tkfree_skb(skb);\n \treturn 0;\n \n drop_n_account:\n \tspin_unlock(&sk->sk_receive_queue.lock);\n \tatomic_inc(&po->tp_drops);\n \tis_drop_n_account = true;\n \n \tsk->sk_data_ready(sk);\n \tkfree_skb(copy_skb);\n \tgoto drop_n_restore;\n }\n \n", "target": "// fix_start\n\tunsigned short macoff, hdrlen;\n\tunsigned int netoff;\n// fix_end\n// fix_start\n\t}\n\tif (netoff > USHRT_MAX) {\n\t\tatomic_inc(&po->tp_drops);\n\t\tgoto drop_n_restore;\n// fix_end\n", "cwe": "CWE-787", "cwe_name": "Out-of-bounds Write", "cve": "CVE-2020-14386", "cve_desc": "A flaw was found in the Linux kernel before 5.9-rc4. Memory corruption can be exploited to gain root privileges from unprivileged processes. The highest threat from this vulnerability is to data confidentiality and integrity.", "project": "linux", "idx": 202143}
{"source": " repodata_schema2id(Repodata *data, Id *schema, int create)\n {\n   int h, len, i;\n   Id *sp, cid;\n   Id *schematahash;\n \n   if (!*schema)\n     return 0;\n   if ((schematahash = data->schematahash) == 0)\n     {\n       data->schematahash = schematahash = solv_calloc(256, sizeof(Id));\n       for (i = 1; i < data->nschemata; i++)\n \t{\n \t  for (sp = data->schemadata + data->schemata[i], h = 0; *sp;)\n \t    h = h * 7 + *sp++;\n \t  h &= 255;\n \t  schematahash[h] = i;\n \t}\n       data->schemadata = solv_extend_resize(data->schemadata, data->schemadatalen, sizeof(Id), SCHEMATADATA_BLOCK);\n       data->schemata = solv_extend_resize(data->schemata, data->nschemata, sizeof(Id), SCHEMATA_BLOCK);\n     }\n \n   for (sp = schema, len = 0, h = 0; *sp; len++)\n     h = h * 7 + *sp++;\n   h &= 255;\n   len++;\n \n   cid = schematahash[h];\n   if (cid)\n     {\n// bug_start\n      if (!memcmp(data->schemadata + data->schemata[cid], schema, len * sizeof(Id)))\n// bug_end\n         return cid;\n       for (cid = 1; cid < data->nschemata; cid++)\n// bug_start\n        if (!memcmp(data->schemadata + data->schemata[cid], schema, len * sizeof(Id)))\n// bug_end\n           return cid;\n     }\n   if (!create)\n     return 0;\n   data->schemadata = solv_extend(data->schemadata, data->schemadatalen, len, sizeof(Id), SCHEMATADATA_BLOCK);\n   data->schemata = solv_extend(data->schemata, data->nschemata, 1, sizeof(Id), SCHEMATA_BLOCK);\n   memcpy(data->schemadata + data->schemadatalen, schema, len * sizeof(Id));\n   data->schemata[data->nschemata] = data->schemadatalen;\n   data->schemadatalen += len;\n   schematahash[h] = data->nschemata;\n #if 0\n fprintf(stderr, \"schema2id: new schema\\n\");\n #endif\n   return data->nschemata++;\n }\n \n", "target": "// fix_start\n      if ((data->schemata[cid] + len <= data->schemadatalen) &&\n\t\t\t  !memcmp(data->schemadata + data->schemata[cid], schema, len * sizeof(Id)))\n// fix_end\n// fix_start\n        if ((data->schemata[cid] + len <= data->schemadatalen) &&\n\t\t\t\t!memcmp(data->schemadata + data->schemata[cid], schema, len * sizeof(Id)))\n// fix_end\n", "cwe": "CWE-125", "cwe_name": "Out-of-bounds Read", "cve": "CVE-2019-20387", "cve_desc": "repodata_schema2id in repodata.c in libsolv before 0.7.6 has a heap-based buffer over-read via a last schema whose length is less than the length of the input schema.", "project": "libsolv", "idx": 202305}
{"source": " _decodeStripYCbCr(Imaging im, ImagingCodecState state, TIFF *tiff) {\n \n     INT32 strip_row;\n     UINT8 *new_data;\n     UINT32 rows_per_strip, row_byte_size, rows_to_read;\n     int ret;\n     TIFFRGBAImage img;\n     char emsg[1024] = \"\";\n \n     ret = TIFFGetFieldDefaulted(tiff, TIFFTAG_ROWSPERSTRIP, &rows_per_strip);\n     if (ret != 1) {\n         rows_per_strip = state->ysize;\n     }\n     TRACE((\"RowsPerStrip: %u \\n\", rows_per_strip));\n \n     if (!(TIFFRGBAImageOK(tiff, emsg) && TIFFRGBAImageBegin(&img, tiff, 0, emsg))) {\n         TRACE((\"Decode error, msg: %s\", emsg));\n         state->errcode = IMAGING_CODEC_BROKEN;\n         return -1;\n     }\n \n     img.req_orientation = ORIENTATION_TOPLEFT;\n     img.col_offset = 0;\n \n     if (state->xsize != img.width || state->ysize != img.height) {\n         TRACE(\n             (\"Inconsistent Image Error: %d =? %d, %d =? %d\",\n              state->xsize,\n              img.width,\n              state->ysize,\n              img.height));\n         state->errcode = IMAGING_CODEC_BROKEN;\n         goto decodeycbcr_err;\n     }\n \n     if (INT_MAX / 4 < img.width) {\n         state->errcode = IMAGING_CODEC_MEMORY;\n         goto decodeycbcr_err;\n     }\n \n     row_byte_size = img.width * 4;\n \n     if (INT_MAX / row_byte_size < rows_per_strip) {\n         state->errcode = IMAGING_CODEC_MEMORY;\n         goto decodeycbcr_err;\n     }\n \n     state->bytes = rows_per_strip * row_byte_size;\n \n     TRACE((\"StripSize: %d \\n\", state->bytes));\n \n     new_data = realloc(state->buffer, state->bytes);\n     if (!new_data) {\n         state->errcode = IMAGING_CODEC_MEMORY;\n         goto decodeycbcr_err;\n     }\n \n     state->buffer = new_data;\n \n     for (; state->y < state->ysize; state->y += rows_per_strip) {\n         img.row_offset = state->y;\n         rows_to_read = min(rows_per_strip, img.height - state->y);\n \n// bug_start\n        if (TIFFRGBAImageGet(&img, (UINT32 *)state->buffer, img.width, rows_to_read) ==\n            -1) {\n// bug_end\n             TRACE((\"Decode Error, y: %d\\n\", state->y));\n             state->errcode = IMAGING_CODEC_BROKEN;\n             goto decodeycbcr_err;\n         }\n \n         TRACE((\"Decoded strip for row %d \\n\", state->y));\n \n         for (strip_row = 0;\n              strip_row < min((INT32)rows_per_strip, state->ysize - state->y);\n              strip_row++) {\n             TRACE((\"Writing data into line %d ; \\n\", state->y + strip_row));\n \n \n             state->shuffle(\n                 (UINT8 *)im->image[state->y + state->yoff + strip_row] +\n                     state->xoff * im->pixelsize,\n                 state->buffer + strip_row * row_byte_size,\n                 state->xsize);\n         }\n     }\n \n decodeycbcr_err:\n     TIFFRGBAImageEnd(&img);\n     if (state->errcode != 0) {\n         return -1;\n     }\n     return 0;\n }\n \n", "target": "// fix_start\n        if (!TIFFRGBAImageGet(&img, (UINT32 *)state->buffer, img.width, rows_to_read)) {\n// fix_end\n", "cwe": "CWE-787", "cwe_name": "Out-of-bounds Write", "cve": "CVE-2021-25289", "cve_desc": "An issue was discovered in Pillow before 8.1.1. TiffDecode has a heap-based buffer overflow when decoding crafted YCbCr files because of certain interpretation conflicts with LibTIFF in RGBA mode. NOTE: this issue exists because of an incomplete fix for CVE-2020-35654.", "project": "Pillow", "idx": 202401}
{"source": " bool timerqueue_add(struct timerqueue_head *head, struct timerqueue_node *node)\n {\n// bug_start\n\tstruct rb_node **p = &head->head.rb_node;\n// bug_end\n \tstruct rb_node *parent = NULL;\n// bug_start\n\tstruct timerqueue_node  *ptr;\n// bug_end\n \n \tWARN_ON_ONCE(!RB_EMPTY_NODE(&node->node));\n \n \twhile (*p) {\n \t\tparent = *p;\n \t\tptr = rb_entry(parent, struct timerqueue_node, node);\n// bug_start\n\t\tif (node->expires < ptr->expires)\n// bug_end\n \t\t\tp = &(*p)->rb_left;\n// bug_start\n\t\telse\n// bug_end\n \t\t\tp = &(*p)->rb_right;\n// bug_start\n// bug_end\n \t}\n \trb_link_node(&node->node, parent, p);\n// bug_start\n\trb_insert_color(&node->node, &head->head);\n// bug_end\n \n// bug_start\n\tif (!head->next || node->expires < head->next->expires) {\n\t\thead->next = node;\n\t\treturn true;\n\t}\n\treturn false;\n// bug_end\n }\n \n", "target": "// fix_start\n\tstruct rb_node **p = &head->rb_root.rb_root.rb_node;\n// fix_end\n// fix_start\n\tstruct timerqueue_node *ptr;\n\tbool leftmost = true;\n// fix_end\n// fix_start\n\t\tif (node->expires < ptr->expires) {\n// fix_end\n// fix_start\n\t\t} else {\n// fix_end\n// fix_start\n\t\t\tleftmost = false;\n\t\t}\n// fix_end\n// fix_start\n\trb_insert_color_cached(&node->node, &head->rb_root, leftmost);\n// fix_end\n// fix_start\n\treturn leftmost;\n// fix_end\n", "cwe": "CWE-665", "cwe_name": "Improper Initialization", "cve": "CVE-2021-20317", "cve_desc": "A flaw was found in the Linux kernel. A corrupted timer tree caused the task wakeup to be missing in the timerqueue_add function in lib/timerqueue.c. This flaw allows a local attacker with special user privileges to cause a denial of service, slowing and eventually stopping the system while running OSP.", "project": "tip", "idx": 202574}
{"source": " dissect_dnp3_message(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void* data _U_)\n {\n   proto_item  *ti, *tdl, *tc, *hidden_item;\n   proto_tree  *dnp3_tree, *dl_tree, *field_tree;\n   int          offset = 0, temp_offset = 0;\n   gboolean     dl_prm;\n   guint8       dl_len, dl_ctl, dl_func;\n   const gchar *func_code_str;\n   guint16      dl_dst, dl_src, calc_dl_crc;\n \n   col_set_str(pinfo->cinfo, COL_PROTOCOL, \"DNP 3.0\");\n   col_clear(pinfo->cinfo, COL_INFO);\n \n   temp_offset += 2;\n \n   dl_len = tvb_get_guint8(tvb, temp_offset);\n   temp_offset += 1;\n \n   dl_ctl = tvb_get_guint8(tvb, temp_offset);\n   temp_offset += 1;\n \n   dl_dst = tvb_get_letohs(tvb, temp_offset);\n   temp_offset += 2;\n \n   dl_src = tvb_get_letohs(tvb, temp_offset);\n \n   dl_func = dl_ctl & DNP3_CTL_FUNC;\n   dl_prm = dl_ctl & DNP3_CTL_PRM;\n   func_code_str = val_to_str(dl_func, dl_prm ? dnp3_ctl_func_pri_vals : dnp3_ctl_func_sec_vals,\n            \"Unknown function (0x%02x)\");\n \n   col_append_fstr(pinfo->cinfo, COL_INFO, \"from %u to %u\", dl_src, dl_dst);\n   col_append_sep_fstr(pinfo->cinfo, COL_INFO, NULL, \"len=%u, %s\", dl_len, func_code_str);\n \n   ti = proto_tree_add_item(tree, proto_dnp3, tvb, offset, -1, ENC_NA);\n   dnp3_tree = proto_item_add_subtree(ti, ett_dnp3);\n \n   dl_tree = proto_tree_add_subtree_format(dnp3_tree, tvb, offset, DNP_HDR_LEN, ett_dnp3_dl, &tdl,\n         \"Data Link Layer, Len: %u, From: %u, To: %u, \", dl_len, dl_src, dl_dst);\n   if (dl_prm) {\n     if (dl_ctl & DNP3_CTL_DIR) proto_item_append_text(tdl, \"DIR, \");\n     if (dl_ctl & DNP3_CTL_PRM) proto_item_append_text(tdl, \"PRM, \");\n     if (dl_ctl & DNP3_CTL_FCB) proto_item_append_text(tdl, \"FCB, \");\n     if (dl_ctl & DNP3_CTL_FCV) proto_item_append_text(tdl, \"FCV, \");\n   }\n   else {\n     if (dl_ctl & DNP3_CTL_DIR) proto_item_append_text(tdl, \"DIR, \");\n     if (dl_ctl & DNP3_CTL_PRM) proto_item_append_text(tdl, \"PRM, \");\n     if (dl_ctl & DNP3_CTL_RES) proto_item_append_text(tdl, \"RES, \");\n     if (dl_ctl & DNP3_CTL_DFC) proto_item_append_text(tdl, \"DFC, \");\n   }\n   proto_item_append_text(tdl, \"%s\", func_code_str);\n \n   proto_tree_add_item(dl_tree, hf_dnp3_start, tvb, offset, 2, ENC_BIG_ENDIAN);\n   offset += 2;\n \n   proto_tree_add_item(dl_tree, hf_dnp3_len, tvb, offset, 1, ENC_BIG_ENDIAN);\n   offset += 1;\n \n   tc = proto_tree_add_uint_format_value(dl_tree, hf_dnp3_ctl, tvb, offset, 1, dl_ctl,\n           \"0x%02x (\", dl_ctl);\n   if (dl_prm) {\n     if (dl_ctl & DNP3_CTL_DIR) proto_item_append_text(tc, \"DIR, \");\n     if (dl_ctl & DNP3_CTL_PRM) proto_item_append_text(tc, \"PRM, \");\n     if (dl_ctl & DNP3_CTL_FCB) proto_item_append_text(tc, \"FCB, \");\n     if (dl_ctl & DNP3_CTL_FCV) proto_item_append_text(tc, \"FCV, \");\n   }\n   else {\n     if (dl_ctl & DNP3_CTL_DIR) proto_item_append_text(tc, \"DIR, \");\n     if (dl_ctl & DNP3_CTL_PRM) proto_item_append_text(tc, \"PRM, \");\n     if (dl_ctl & DNP3_CTL_RES) proto_item_append_text(tc, \"RES, \");\n     if (dl_ctl & DNP3_CTL_DFC) proto_item_append_text(tc, \"DFC, \");\n   }\n   proto_item_append_text(tc, \"%s)\", func_code_str );\n   field_tree = proto_item_add_subtree(tc, ett_dnp3_dl_ctl);\n \n   if (dl_prm) {\n     proto_tree_add_item(field_tree, hf_dnp3_ctl_dir, tvb, offset, 1, ENC_LITTLE_ENDIAN);\n     proto_tree_add_item(field_tree, hf_dnp3_ctl_prm, tvb, offset, 1, ENC_LITTLE_ENDIAN);\n     proto_tree_add_item(field_tree, hf_dnp3_ctl_fcb, tvb, offset, 1, ENC_LITTLE_ENDIAN);\n     proto_tree_add_item(field_tree, hf_dnp3_ctl_fcv, tvb, offset, 1, ENC_LITTLE_ENDIAN);\n     proto_tree_add_item(field_tree, hf_dnp3_ctl_prifunc, tvb, offset, 1, ENC_BIG_ENDIAN);\n   }\n   else {\n     proto_tree_add_item(field_tree, hf_dnp3_ctl_dir, tvb, offset, 1, ENC_LITTLE_ENDIAN);\n     proto_tree_add_item(field_tree, hf_dnp3_ctl_prm, tvb, offset, 1, ENC_LITTLE_ENDIAN);\n     proto_tree_add_item(field_tree, hf_dnp3_ctl_dfc, tvb, offset, 1, ENC_LITTLE_ENDIAN);\n     proto_tree_add_item(field_tree, hf_dnp3_ctl_secfunc, tvb, offset, 1, ENC_BIG_ENDIAN);\n   }\n     offset += 1;\n \n   proto_tree_add_item(dl_tree, hf_dnp3_dst, tvb, offset, 2, ENC_LITTLE_ENDIAN);\n   hidden_item = proto_tree_add_item(dl_tree, hf_dnp3_addr, tvb, offset, 2, ENC_LITTLE_ENDIAN);\n   proto_item_set_hidden(hidden_item);\n   offset += 2;\n   proto_tree_add_item(dl_tree, hf_dnp3_src, tvb, offset, 2, ENC_LITTLE_ENDIAN);\n   hidden_item = proto_tree_add_item(dl_tree, hf_dnp3_addr, tvb, offset, 2, ENC_LITTLE_ENDIAN);\n   proto_item_set_hidden(hidden_item);\n   offset += 2;\n \n   calc_dl_crc = calculateCRCtvb(tvb, 0, DNP_HDR_LEN - 2);\n   proto_tree_add_checksum(dl_tree, tvb, offset, hf_dnp3_data_hdr_crc,\n                           hf_dnp3_data_hdr_crc_status, &ei_dnp3_data_hdr_crc_incorrect,\n                           pinfo, calc_dl_crc, ENC_LITTLE_ENDIAN, PROTO_CHECKSUM_VERIFY);\n   offset += 2;\n \n   if ((dl_func != DL_FUNC_LINK_STAT) && (dl_func != DL_FUNC_STAT_LINK) &&\n       (dl_func != DL_FUNC_RESET_LINK) && (dl_func != DL_FUNC_ACK))\n   {\n     proto_tree *data_tree;\n     proto_item *data_ti;\n     guint8      tr_ctl, tr_seq;\n     gboolean    tr_fir, tr_fin;\n     guint8     *al_buffer, *al_buffer_ptr;\n     guint8      data_len;\n     int         data_start = offset;\n     int         tl_offset;\n     gboolean    crc_OK = FALSE;\n     tvbuff_t   *next_tvb;\n     guint       i;\n     static int * const transport_flags[] = {\n       &hf_dnp3_tr_fin,\n       &hf_dnp3_tr_fir,\n       &hf_dnp3_tr_seq,\n       NULL\n     };\n \n     tr_ctl = tvb_get_guint8(tvb, offset);\n     tr_seq = tr_ctl & DNP3_TR_SEQ;\n     tr_fir = tr_ctl & DNP3_TR_FIR;\n     tr_fin = tr_ctl & DNP3_TR_FIN;\n \n     tc = proto_tree_add_bitmask(dnp3_tree, tvb, offset, hf_dnp3_tr_ctl, ett_dnp3_tr_ctl, transport_flags, ENC_BIG_ENDIAN);\n     proto_item_append_text(tc, \"(\");\n     if (tr_fir) proto_item_append_text(tc, \"FIR, \");\n     if (tr_fin) proto_item_append_text(tc, \"FIN, \");\n     proto_item_append_text(tc, \"Sequence %u)\", tr_seq);\n \n     data_tree = proto_tree_add_subtree(dnp3_tree, tvb, offset, -1, ett_dnp3_dl_data, &data_ti, \"Data Chunks\");\n \n \n     data_len = dl_len - 5;\n     al_buffer = (guint8 *)wmem_alloc(pinfo->pool, data_len);\n     al_buffer_ptr = al_buffer;\n     i = 0;\n     tl_offset = 1;\n     while (data_len > 0)\n     {\n       guint8        chk_size;\n       const guint8 *chk_ptr;\n       proto_tree   *chk_tree;\n       proto_item   *chk_len_ti;\n       guint16       calc_crc, act_crc;\n \n       chk_size = MIN(data_len, AL_MAX_CHUNK_SIZE);\n       chk_ptr  = tvb_get_ptr(tvb, offset, chk_size);\n       memcpy(al_buffer_ptr, chk_ptr + tl_offset, chk_size - tl_offset);\n       al_buffer_ptr += chk_size - tl_offset;\n \n       chk_tree = proto_tree_add_subtree_format(data_tree, tvb, offset, chk_size + 2, ett_dnp3_dl_chunk, NULL, \"Data Chunk: %u\", i);\n       proto_tree_add_item(chk_tree, hf_dnp3_data_chunk, tvb, offset, chk_size, ENC_NA);\n       chk_len_ti = proto_tree_add_uint(chk_tree, hf_dnp3_data_chunk_len, tvb, offset, 0, chk_size);\n       proto_item_set_generated(chk_len_ti);\n \n       offset  += chk_size;\n \n       calc_crc = calculateCRC(chk_ptr, chk_size);\n       proto_tree_add_checksum(chk_tree, tvb, offset, hf_dnp3_data_chunk_crc,\n                               hf_dnp3_data_chunk_crc_status, &ei_dnp3_data_chunk_crc_incorrect,\n                               pinfo, calc_crc, ENC_LITTLE_ENDIAN, PROTO_CHECKSUM_VERIFY);\n       act_crc  = tvb_get_letohs(tvb, offset);\n       offset  += 2;\n       crc_OK   = calc_crc == act_crc;\n       if (!crc_OK)\n       {\n         break;\n       }\n       data_len -= chk_size;\n       i++;\n       tl_offset = 0;\n     }\n     proto_item_set_len(data_ti, offset - data_start);\n \n     if (crc_OK)\n     {\n       tvbuff_t *al_tvb;\n       gboolean  save_fragmented;\n \n       al_tvb = tvb_new_child_real_data(tvb, al_buffer, (guint) (al_buffer_ptr-al_buffer), (gint) (al_buffer_ptr-al_buffer));\n \n       save_fragmented = pinfo->fragmented;\n \n       static guint al_max_fragments = 60;\n       static guint al_fragment_aging = 64;\n       fragment_head *frag_al = NULL;\n       pinfo->fragmented = TRUE;\n       if (!pinfo->fd->visited)\n       {\n         frag_al = fragment_add_seq_single_aging(&al_reassembly_table,\n             al_tvb, 0, pinfo, tr_seq, NULL,\n             tvb_reported_length(al_tvb),\n             tr_fir, tr_fin,\n             al_max_fragments, al_fragment_aging);\n       }\n       else\n       {\n         frag_al = fragment_get_reassembled_id(&al_reassembly_table, pinfo, tr_seq);\n       }\n       next_tvb = process_reassembled_data(al_tvb, 0, pinfo,\n           \"Reassembled DNP 3.0 Application Layer message\", frag_al, &dnp3_frag_items,\n           NULL, dnp3_tree);\n \n       if (frag_al)\n       {\n         if (pinfo->num == frag_al->reassembled_in && pinfo->curr_layer_num == frag_al->reas_in_layer_num)\n         {\n           dissect_dnp3_al(next_tvb, pinfo, dnp3_tree);\n         }\n         else\n         {\n           col_set_fence(pinfo->cinfo, COL_INFO);\n           col_append_fstr(pinfo->cinfo, COL_INFO,\n               \" (Application Layer fragment %u, reassembled in packet %u)\",\n               tr_seq, frag_al->reassembled_in);\n           proto_tree_add_item(dnp3_tree, hf_al_frag_data, al_tvb, 0, -1, ENC_NA);\n         }\n       }\n       else\n       {\n         col_append_fstr(pinfo->cinfo, COL_INFO,\n             \" (Application Layer Unreassembled fragment %u)\",\n             tr_seq);\n         proto_tree_add_item(dnp3_tree, hf_al_frag_data, al_tvb, 0, -1, ENC_NA);\n       }\n \n       pinfo->fragmented = save_fragmented;\n     }\n     else\n     {\n// bug_start\n// bug_end\n       next_tvb = NULL;\n     }\n   }\n \n   proto_item_set_len(ti, offset);\n   return offset;\n }\n \n", "target": "// fix_start\n      g_free(al_buffer);\n// fix_end\n", "cwe": "CWE-835", "cwe_name": "Loop with Unreachable Exit Condition ('Infinite Loop')", "cve": "CVE-2021-22235", "cve_desc": "Crash in DNP dissector in Wireshark 3.4.0 to 3.4.6 and 3.2.0 to 3.2.14 allows denial of service via packet injection or crafted capture file", "project": "wireshark", "idx": 202609}
{"source": " int do_epoll_ctl(int epfd, int op, int fd, struct epoll_event *epds,\n \t\t bool nonblock)\n {\n \tint error;\n \tint full_check = 0;\n \tstruct fd f, tf;\n \tstruct eventpoll *ep;\n \tstruct epitem *epi;\n \tstruct eventpoll *tep = NULL;\n \n \terror = -EBADF;\n \tf = fdget(epfd);\n \tif (!f.file)\n \t\tgoto error_return;\n \n \ttf = fdget(fd);\n \tif (!tf.file)\n \t\tgoto error_fput;\n \n \terror = -EPERM;\n \tif (!file_can_poll(tf.file))\n \t\tgoto error_tgt_fput;\n \n \tif (ep_op_has_event(op))\n \t\tep_take_care_of_epollwakeup(epds);\n \n \terror = -EINVAL;\n \tif (f.file == tf.file || !is_file_epoll(f.file))\n \t\tgoto error_tgt_fput;\n \n \tif (ep_op_has_event(op) && (epds->events & EPOLLEXCLUSIVE)) {\n \t\tif (op == EPOLL_CTL_MOD)\n \t\t\tgoto error_tgt_fput;\n \t\tif (op == EPOLL_CTL_ADD && (is_file_epoll(tf.file) ||\n \t\t\t\t(epds->events & ~EPOLLEXCLUSIVE_OK_BITS)))\n \t\t\tgoto error_tgt_fput;\n \t}\n \n \tep = f.file->private_data;\n \n \terror = epoll_mutex_lock(&ep->mtx, 0, nonblock);\n \tif (error)\n \t\tgoto error_tgt_fput;\n \tif (op == EPOLL_CTL_ADD) {\n \t\tif (!list_empty(&f.file->f_ep_links) ||\n \t\t\t\t\t\tis_file_epoll(tf.file)) {\n \t\t\tmutex_unlock(&ep->mtx);\n \t\t\terror = epoll_mutex_lock(&epmutex, 0, nonblock);\n \t\t\tif (error)\n \t\t\t\tgoto error_tgt_fput;\n \t\t\tfull_check = 1;\n \t\t\tif (is_file_epoll(tf.file)) {\n \t\t\t\terror = -ELOOP;\n// bug_start\n\t\t\t\tif (ep_loop_check(ep, tf.file) != 0) {\n\t\t\t\t\tclear_tfile_check_list();\n// bug_end\n \t\t\t\t\tgoto error_tgt_fput;\n// bug_start\n\t\t\t\t}\n// bug_end\n \t\t\t} else {\n \t\t\t\tget_file(tf.file);\n \t\t\t\tlist_add(&tf.file->f_tfile_llink,\n \t\t\t\t\t\t\t&tfile_check_list);\n \t\t\t}\n \t\t\terror = epoll_mutex_lock(&ep->mtx, 0, nonblock);\n// bug_start\n\t\t\tif (error) {\nout_del:\n\t\t\t\tlist_del(&tf.file->f_tfile_llink);\n\t\t\t\tif (!is_file_epoll(tf.file))\n\t\t\t\t\tfput(tf.file);\n// bug_end\n \t\t\t\tgoto error_tgt_fput;\n// bug_start\n\t\t\t}\n// bug_end\n \t\t\tif (is_file_epoll(tf.file)) {\n \t\t\t\ttep = tf.file->private_data;\n \t\t\t\terror = epoll_mutex_lock(&tep->mtx, 1, nonblock);\n \t\t\t\tif (error) {\n \t\t\t\t\tmutex_unlock(&ep->mtx);\n// bug_start\n\t\t\t\t\tgoto out_del;\n// bug_end\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \t}\n \n \tepi = ep_find(ep, tf.file, fd);\n \n \terror = -EINVAL;\n \tswitch (op) {\n \tcase EPOLL_CTL_ADD:\n \t\tif (!epi) {\n \t\t\tepds->events |= EPOLLERR | EPOLLHUP;\n \t\t\terror = ep_insert(ep, epds, tf.file, fd, full_check);\n \t\t} else\n \t\t\terror = -EEXIST;\n// bug_start\n\t\tif (full_check)\n\t\t\tclear_tfile_check_list();\n// bug_end\n \t\tbreak;\n \tcase EPOLL_CTL_DEL:\n \t\tif (epi)\n \t\t\terror = ep_remove(ep, epi);\n \t\telse\n \t\t\terror = -ENOENT;\n \t\tbreak;\n \tcase EPOLL_CTL_MOD:\n \t\tif (epi) {\n \t\t\tif (!(epi->event.events & EPOLLEXCLUSIVE)) {\n \t\t\t\tepds->events |= EPOLLERR | EPOLLHUP;\n \t\t\t\terror = ep_modify(ep, epi, epds);\n \t\t\t}\n \t\t} else\n \t\t\terror = -ENOENT;\n \t\tbreak;\n \t}\n \tif (tep != NULL)\n \t\tmutex_unlock(&tep->mtx);\n \tmutex_unlock(&ep->mtx);\n \n error_tgt_fput:\n// bug_start\n\tif (full_check)\n// bug_end\n \t\tmutex_unlock(&epmutex);\n// bug_start\n// bug_end\n \n \tfdput(tf);\n error_fput:\n \tfdput(f);\n error_return:\n \n \treturn error;\n }\n \n", "target": "// fix_start\n\t\t\t\tif (ep_loop_check(ep, tf.file) != 0)\n// fix_end\n// fix_start\n// fix_end\n// fix_start\n\t\t\tif (error)\n// fix_end\n// fix_start\n// fix_end\n// fix_start\n\t\t\t\t\tgoto error_tgt_fput;\n// fix_end\n// fix_start\n// fix_end\n// fix_start\n\tif (full_check) {\n\t\tclear_tfile_check_list();\n// fix_end\n// fix_start\n\t}\n// fix_end\n", "cwe": "CWE-416", "cwe_name": "Use After Free", "cve": "CVE-2020-0466", "cve_desc": "In do_epoll_ctl and ep_loop_check_proc of eventpoll.c, there is a possible use after free due to a logic error. This could lead to local escalation of privilege with no additional execution privileges needed. User interaction is not needed for exploitation.Product: AndroidVersions: Android kernelAndroid ID: A-147802478References: Upstream kernel", "project": "linux", "idx": 202665}
{"source": " rb_str_justify(int argc, VALUE *argv, VALUE str, char jflag)\n {\n     rb_encoding *enc;\n     VALUE w;\n     long width, len, flen = 1, fclen = 1;\n     VALUE res;\n     char *p;\n     const char *f = \" \";\n// bug_start\n    long n, llen, rlen;\n// bug_end\n     volatile VALUE pad;\n     int singlebyte = 1, cr;\n \n     rb_scan_args(argc, argv, \"11\", &w, &pad);\n     enc = STR_ENC_GET(str);\n     width = NUM2LONG(w);\n     if (argc == 2) {\n \tStringValue(pad);\n \tenc = rb_enc_check(str, pad);\n \tf = RSTRING_PTR(pad);\n \tflen = RSTRING_LEN(pad);\n \tfclen = str_strlen(pad, enc);\n \tsinglebyte = single_byte_optimizable(pad);\n \tif (flen == 0 || fclen == 0) {\n \t    rb_raise(rb_eArgError, \"zero width padding\");\n \t}\n     }\n     len = str_strlen(str, enc);\n     if (width < 0 || len >= width) return rb_str_dup(str);\n     n = width - len;\n     llen = (jflag == 'l') ? 0 : ((jflag == 'r') ? n : n/2);\n     rlen = n - llen;\n     cr = ENC_CODERANGE(str);\n// bug_start\n    res = rb_str_new5(str, 0, RSTRING_LEN(str)+n*flen/fclen+2);\n// bug_end\n     p = RSTRING_PTR(res);\n// bug_start\n    while (llen) {\n\tif (flen <= 1) {\n\t    *p++ = *f;\n\t    llen--;\n\t}\n\telse if (llen > fclen) {\n// bug_end\n \t    memcpy(p,f,flen);\n \t    p += flen;\n \t    llen -= fclen;\n \t}\n// bug_start\n\telse {\n\t    char *fp = str_nth(f, f+flen, llen, enc, singlebyte);\n\t    n = fp - f;\n\t    memcpy(p,f,n);\n\t    p+=n;\n\t    break;\n// bug_end\n \t}\n     }\n// bug_start\n    memcpy(p, RSTRING_PTR(str), RSTRING_LEN(str));\n    p+=RSTRING_LEN(str);\n    while (rlen) {\n\tif (flen <= 1) {\n\t    *p++ = *f;\n\t    rlen--;\n\t}\n\telse if (rlen > fclen) {\n// bug_end\n \t    memcpy(p,f,flen);\n \t    p += flen;\n \t    rlen -= fclen;\n \t}\n// bug_start\n\telse {\n\t    char *fp = str_nth(f, f+flen, rlen, enc, singlebyte);\n\t    n = fp - f;\n\t    memcpy(p,f,n);\n\t    p+=n;\n\t    break;\n// bug_end\n \t}\n     }\n     *p = '\\0';\n     STR_SET_LEN(res, p-RSTRING_PTR(res));\n     OBJ_INFECT(res, str);\n     if (!NIL_P(pad)) OBJ_INFECT(res, pad);\n     rb_enc_associate(res, enc);\n     if (argc == 2)\n \tcr = ENC_CODERANGE_AND(cr, ENC_CODERANGE(pad));\n     if (cr != ENC_CODERANGE_BROKEN)\n \tENC_CODERANGE_SET(res, cr);\n     return res;\n }\n \n", "target": "// fix_start\n    long n, size, llen, rlen, llen2 = 0, rlen2 = 0;\n// fix_end\n// fix_start\n    if (flen > 1) {\n       llen2 = str_offset(f, f + flen, llen % fclen, enc, singlebyte);\n       rlen2 = str_offset(f, f + flen, rlen % fclen, enc, singlebyte);\n    }\n    size = RSTRING_LEN(str);\n    if ((len = llen / fclen + rlen / fclen) >= LONG_MAX / flen ||\n       (len *= flen) >= LONG_MAX - llen2 - rlen2 ||\n       (len += llen2 + rlen2) >= LONG_MAX - size) {\n       rb_raise(rb_eArgError, \"argument too big\");\n    }\n    len += size;\n    res = rb_str_new5(str, 0, len);\n// fix_end\n// fix_start\n    if (flen <= 1) {\n       memset(p, *f, llen);\n       p += llen;\n    }\n    else {\n       while (llen > fclen) {\n// fix_end\n// fix_start\n       if (llen > 0) {\n           memcpy(p, f, llen2);\n           p += llen2;\n// fix_end\n// fix_start\n    memcpy(p, RSTRING_PTR(str), size);\n    p += size;\n    if (flen <= 1) {\n       memset(p, *f, rlen);\n       p += rlen;\n    }\n    else {\n       while (rlen > fclen) {\n// fix_end\n// fix_start\n       if (rlen > 0) {\n           memcpy(p, f, rlen2);\n           p += rlen2;\n// fix_end\n", "cwe": "CWE-119", "cwe_name": "Improper Restriction of Operations within the Bounds of a Memory Buffer", "cve": "CVE-2009-4124", "cve_desc": "Heap-based buffer overflow in the rb_str_justify function in string.c in Ruby 1.9.1 before 1.9.1-p376 allows context-dependent attackers to execute arbitrary code via unspecified vectors involving (1) String#ljust, (2) String#center, or (3) String#rjust.  NOTE: some of these details are obtained from third party information.", "project": "ruby", "idx": 202689}
{"source": " static int cmd_handle_untagged (IMAP_DATA* idata)\n {\n   char* s;\n   char* pn;\n   unsigned int count;\n \n   s = imap_next_word (idata->buf);\n   pn = imap_next_word (s);\n \n   if ((idata->state >= IMAP_SELECTED) && isdigit ((unsigned char) *s))\n   {\n     pn = s;\n     s = imap_next_word (s);\n \n     if (ascii_strncasecmp (\"EXISTS\", s, 6) == 0)\n     {\n       dprint (2, (debugfile, \"Handling EXISTS\\n\"));\n \n       mutt_atoui (pn, &count);\n \n       if ( !(idata->reopen & IMAP_EXPUNGE_PENDING) &&\n \t   count < idata->max_msn)\n       {\n \tdprint (1, (debugfile, \"Message count is out of sync\"));\n \treturn 0;\n       }\n       else if (count == idata->max_msn)\n \tdprint (3, (debugfile,\n           \"cmd_handle_untagged: superfluous EXISTS message.\\n\"));\n       else\n       {\n \tif (!(idata->reopen & IMAP_EXPUNGE_PENDING))\n         {\n           dprint (2, (debugfile,\n             \"cmd_handle_untagged: New mail in %s - %d messages total.\\n\",\n             idata->mailbox, count));\n \t  idata->reopen |= IMAP_NEWMAIL_PENDING;\n         }\n \tidata->newMailCount = count;\n       }\n     }\n     else if (ascii_strncasecmp (\"EXPUNGE\", s, 7) == 0)\n       cmd_parse_expunge (idata, pn);\n     else if (ascii_strncasecmp (\"FETCH\", s, 5) == 0)\n       cmd_parse_fetch (idata, pn);\n   }\n   else if (ascii_strncasecmp (\"CAPABILITY\", s, 10) == 0)\n     cmd_parse_capability (idata, s);\n   else if (!ascii_strncasecmp (\"OK [CAPABILITY\", s, 14))\n     cmd_parse_capability (idata, pn);\n   else if (!ascii_strncasecmp (\"OK [CAPABILITY\", pn, 14))\n     cmd_parse_capability (idata, imap_next_word (pn));\n   else if (ascii_strncasecmp (\"LIST\", s, 4) == 0)\n     cmd_parse_list (idata, s);\n   else if (ascii_strncasecmp (\"LSUB\", s, 4) == 0)\n     cmd_parse_lsub (idata, s);\n   else if (ascii_strncasecmp (\"MYRIGHTS\", s, 8) == 0)\n     cmd_parse_myrights (idata, s);\n   else if (ascii_strncasecmp (\"SEARCH\", s, 6) == 0)\n     cmd_parse_search (idata, s);\n   else if (ascii_strncasecmp (\"STATUS\", s, 6) == 0)\n     cmd_parse_status (idata, s);\n   else if (ascii_strncasecmp (\"ENABLED\", s, 7) == 0)\n     cmd_parse_enabled (idata, s);\n   else if (ascii_strncasecmp (\"BYE\", s, 3) == 0)\n   {\n     dprint (2, (debugfile, \"Handling BYE\\n\"));\n \n     if (idata->status == IMAP_BYE)\n       return 0;\n \n     s += 3;\n     SKIPWS (s);\n     mutt_error (\"%s\", s);\n     mutt_sleep (2);\n     cmd_handle_fatal (idata);\n \n     return -1;\n   }\n   else if (option (OPTIMAPSERVERNOISE) && (ascii_strncasecmp (\"NO\", s, 2) == 0))\n   {\n     dprint (2, (debugfile, \"Handling untagged NO\\n\"));\n \n// bug_start\n    mutt_error (\"%s\", s+3);\n// bug_end\n     mutt_sleep (2);\n   }\n \n   return 0;\n }\n \n", "target": "// fix_start\n    mutt_error (\"%s\", s+2);\n// fix_end\n", "cwe": "CWE-20", "cwe_name": "Improper Input Validation", "cve": "CVE-2018-14349", "cve_desc": "An issue was discovered in Mutt before 1.10.1 and NeoMutt before 2018-07-16. imap/command.c mishandles a NO response without a message.", "project": "mutt", "idx": 202733}
{"source": " static Image *OptimizeLayerFrames(const Image *image,const LayerMethod method,\n   ExceptionInfo *exception)\n {\n   ExceptionInfo\n     *sans_exception;\n \n   Image\n     *prev_image,\n     *dup_image,\n     *bgnd_image,\n     *optimized_image;\n \n   RectangleInfo\n     try_bounds,\n     bgnd_bounds,\n     dup_bounds,\n     *bounds;\n \n   MagickBooleanType\n     add_frames,\n     try_cleared,\n     cleared;\n \n   DisposeType\n     *disposals;\n \n   register const Image\n     *curr;\n \n   register ssize_t\n     i;\n \n   assert(image != (const Image *) NULL);\n   assert(image->signature == MagickCoreSignature);\n   if (image->debug != MagickFalse)\n     (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n   assert(exception != (ExceptionInfo *) NULL);\n   assert(exception->signature == MagickCoreSignature);\n   assert(method == OptimizeLayer ||\n          method == OptimizeImageLayer ||\n          method == OptimizePlusLayer);\n   add_frames=method == OptimizePlusLayer ? MagickTrue : MagickFalse;\n   curr=GetFirstImageInList(image);\n   for (; curr != (Image *) NULL; curr=GetNextImageInList(curr))\n   {\n     if ((curr->columns != image->columns) || (curr->rows != image->rows))\n       ThrowImageException(OptionError,\"ImagesAreNotTheSameSize\");\n \n     if ((curr->page.x != 0) || (curr->page.y != 0) ||\n         (curr->page.width != image->page.width) ||\n         (curr->page.height != image->page.height))\n       ThrowImageException(OptionError,\"ImagePagesAreNotCoalesced\");\n   }\n   curr=GetFirstImageInList(image);\n   bounds=(RectangleInfo *) AcquireQuantumMemory((size_t)\n     GetImageListLength(curr),(add_frames != MagickFalse ? 2UL : 1UL)*\n     sizeof(*bounds));\n   if (bounds == (RectangleInfo *) NULL)\n     ThrowImageException(ResourceLimitError,\"MemoryAllocationFailed\");\n   disposals=(DisposeType *) AcquireQuantumMemory((size_t)\n     GetImageListLength(image),(add_frames != MagickFalse ? 2UL : 1UL)*\n     sizeof(*disposals));\n   if (disposals == (DisposeType *) NULL)\n     {\n       bounds=(RectangleInfo *) RelinquishMagickMemory(bounds);\n       ThrowImageException(ResourceLimitError,\"MemoryAllocationFailed\");\n     }\n   prev_image=CloneImage(curr,curr->columns,curr->rows,MagickTrue,exception);\n   if (prev_image == (Image *) NULL)\n     {\n       bounds=(RectangleInfo *) RelinquishMagickMemory(bounds);\n       disposals=(DisposeType *) RelinquishMagickMemory(disposals);\n       return((Image *) NULL);\n     }\n   prev_image->page=curr->page;\n   prev_image->page.x=0;\n   prev_image->page.y=0;\n   prev_image->dispose=NoneDispose;\n   prev_image->background_color.alpha_trait=BlendPixelTrait;\n   prev_image->background_color.alpha=(MagickRealType) TransparentAlpha;\n   (void) SetImageBackgroundColor(prev_image,exception);\n #if DEBUG_OPT_FRAME\n   i=0;\n   (void) FormatLocaleFile(stderr,\"frame %.20g :-\\n\",(double) i);\n #endif\n   disposals[0]=NoneDispose;\n   bounds[0]=CompareImagesBounds(prev_image,curr,CompareAnyLayer,exception);\n #if DEBUG_OPT_FRAME\n   (void) FormatLocaleFile(stderr, \"overlay: %.20gx%.20g%+.20g%+.20g\\n\\n\",\n     (double) bounds[i].width,(double) bounds[i].height,\n     (double) bounds[i].x,(double) bounds[i].y );\n #endif\n   i=1;\n   bgnd_image=(Image *) NULL;\n   dup_image=(Image *) NULL;\n   dup_bounds.width=0;\n   dup_bounds.height=0;\n   dup_bounds.x=0;\n   dup_bounds.y=0;\n   curr=GetNextImageInList(curr);\n   for ( ; curr != (const Image *) NULL; curr=GetNextImageInList(curr))\n   {\n #if DEBUG_OPT_FRAME\n     (void) FormatLocaleFile(stderr,\"frame %.20g :-\\n\",(double) i);\n #endif\n     bounds[i]=CompareImagesBounds(curr->previous,curr,CompareAnyLayer,exception);\n     cleared=IsBoundsCleared(curr->previous,curr,&bounds[i],exception);\n     disposals[i-1]=NoneDispose;\n #if DEBUG_OPT_FRAME\n     (void) FormatLocaleFile(stderr, \"overlay: %.20gx%.20g%+.20g%+.20g%s%s\\n\",\n          (double) bounds[i].width,(double) bounds[i].height,\n          (double) bounds[i].x,(double) bounds[i].y,\n          bounds[i].x < 0?\"  (unchanged)\":\"\",\n          cleared?\"  (pixels cleared)\":\"\");\n #endif\n     if ( bounds[i].x < 0 ) {\n       if ( add_frames && i>=2 ) {\n         disposals[i-1]=DelDispose;\n         disposals[i]=NoneDispose;\n         bounds[i]=bounds[i-1];\n         i++;\n         continue;\n       }\n     }\n     else\n       {\n         try_bounds=CompareImagesBounds(prev_image,curr,CompareAnyLayer,exception);\n         try_cleared=IsBoundsCleared(prev_image,curr,&try_bounds,exception);\n #if DEBUG_OPT_FRAME\n     (void) FormatLocaleFile(stderr, \"test_prev: %.20gx%.20g%+.20g%+.20g%s\\n\",\n          (double) try_bounds.width,(double) try_bounds.height,\n          (double) try_bounds.x,(double) try_bounds.y,\n          try_cleared?\"  (pixels were cleared)\":\"\");\n #endif\n         if ( (!try_cleared && cleared ) ||\n                 try_bounds.width * try_bounds.height\n                     <  bounds[i].width * bounds[i].height )\n           {\n             cleared=try_cleared;\n             bounds[i]=try_bounds;\n             disposals[i-1]=PreviousDispose;\n #if DEBUG_OPT_FRAME\n             (void) FormatLocaleFile(stderr,\"previous: accepted\\n\");\n           } else {\n             (void) FormatLocaleFile(stderr,\"previous: rejected\\n\");\n #endif\n           }\n \n         dup_bounds.width=dup_bounds.height=0;\n         if ( add_frames )\n           {\n             dup_image=CloneImage(curr->previous,0,0,MagickTrue,exception);\n             if (dup_image == (Image *) NULL)\n               {\n                 bounds=(RectangleInfo *) RelinquishMagickMemory(bounds);\n                 disposals=(DisposeType *) RelinquishMagickMemory(disposals);\n                 prev_image=DestroyImage(prev_image);\n                 return((Image *) NULL);\n               }\n             dup_image->background_color.alpha_trait=BlendPixelTrait;\n             dup_bounds=CompareImagesBounds(dup_image,curr,CompareClearLayer,exception);\n             ClearBounds(dup_image,&dup_bounds,exception);\n             try_bounds=CompareImagesBounds(dup_image,curr,CompareAnyLayer,exception);\n             if ( cleared ||\n                    dup_bounds.width*dup_bounds.height\n                       +try_bounds.width*try_bounds.height\n                    < bounds[i].width * bounds[i].height )\n               {\n                 cleared=MagickFalse;\n                 bounds[i]=try_bounds;\n                 disposals[i-1]=DupDispose;\n               }\n             else\n               dup_bounds.width=dup_bounds.height=0;\n           }\n         bgnd_image=CloneImage(curr->previous,0,0,MagickTrue,exception);\n         if (bgnd_image == (Image *) NULL)\n           {\n             bounds=(RectangleInfo *) RelinquishMagickMemory(bounds);\n             disposals=(DisposeType *) RelinquishMagickMemory(disposals);\n             prev_image=DestroyImage(prev_image);\n             if ( dup_image != (Image *) NULL)\n               dup_image=DestroyImage(dup_image);\n             return((Image *) NULL);\n           }\n         bgnd_image->background_color.alpha_trait=BlendPixelTrait;\n         bgnd_bounds=bounds[i-1];\n         ClearBounds(bgnd_image,&bgnd_bounds,exception);\n         try_bounds=CompareImagesBounds(bgnd_image,curr,CompareAnyLayer,exception);\n         try_cleared=IsBoundsCleared(bgnd_image,curr,&try_bounds,exception);\n #if DEBUG_OPT_FRAME\n     (void) FormatLocaleFile(stderr, \"background: %s\\n\",\n          try_cleared?\"(pixels cleared)\":\"\");\n #endif\n         if ( try_cleared )\n           {\n             try_bounds=CompareImagesBounds(curr->previous,curr,CompareClearLayer,exception);\n #if DEBUG_OPT_FRAME\n             (void) FormatLocaleFile(stderr, \"expand_clear: %.20gx%.20g%+.20g%+.20g%s\\n\",\n                 (double) try_bounds.width,(double) try_bounds.height,\n                 (double) try_bounds.x,(double) try_bounds.y,\n                 try_bounds.x<0?\"  (no expand nessary)\":\"\");\n #endif\n             if ( bgnd_bounds.x < 0 )\n               bgnd_bounds = try_bounds;\n             else\n               {\n #if DEBUG_OPT_FRAME\n                 (void) FormatLocaleFile(stderr, \"expand_bgnd: %.20gx%.20g%+.20g%+.20g\\n\",\n                     (double) bgnd_bounds.width,(double) bgnd_bounds.height,\n                     (double) bgnd_bounds.x,(double) bgnd_bounds.y );\n #endif\n                 if ( try_bounds.x < bgnd_bounds.x )\n                   {\n                      bgnd_bounds.width+= bgnd_bounds.x-try_bounds.x;\n                      if ( bgnd_bounds.width < try_bounds.width )\n                        bgnd_bounds.width = try_bounds.width;\n                      bgnd_bounds.x = try_bounds.x;\n                   }\n                 else\n                   {\n                      try_bounds.width += try_bounds.x - bgnd_bounds.x;\n                      if ( bgnd_bounds.width < try_bounds.width )\n                        bgnd_bounds.width = try_bounds.width;\n                   }\n                 if ( try_bounds.y < bgnd_bounds.y )\n                   {\n                      bgnd_bounds.height += bgnd_bounds.y - try_bounds.y;\n                      if ( bgnd_bounds.height < try_bounds.height )\n                        bgnd_bounds.height = try_bounds.height;\n                      bgnd_bounds.y = try_bounds.y;\n                   }\n                 else\n                   {\n                     try_bounds.height += try_bounds.y - bgnd_bounds.y;\n                      if ( bgnd_bounds.height < try_bounds.height )\n                        bgnd_bounds.height = try_bounds.height;\n                   }\n #if DEBUG_OPT_FRAME\n                 (void) FormatLocaleFile(stderr, \"        to : %.20gx%.20g%+.20g%+.20g\\n\",\n                     (double) bgnd_bounds.width,(double) bgnd_bounds.height,\n                     (double) bgnd_bounds.x,(double) bgnd_bounds.y );\n #endif\n               }\n             ClearBounds(bgnd_image,&bgnd_bounds,exception);\n #if DEBUG_OPT_FRAME\n             try_bounds=CompareImagesBounds(bgnd_image,curr,CompareClearLayer,exception);\n             (void) FormatLocaleFile(stderr, \"expand_ctst: %.20gx%.20g%+.20g%+.20g\\n\",\n                 (double) try_bounds.width,(double) try_bounds.height,\n                 (double) try_bounds.x,(double) try_bounds.y );\n             try_bounds=CompareImagesBounds(bgnd_image,curr,CompareAnyLayer,exception);\n             try_cleared=IsBoundsCleared(bgnd_image,curr,&try_bounds,exception);\n             (void) FormatLocaleFile(stderr, \"expand_any : %.20gx%.20g%+.20g%+.20g%s\\n\",\n                 (double) try_bounds.width,(double) try_bounds.height,\n                 (double) try_bounds.x,(double) try_bounds.y,\n                 try_cleared?\"   (pixels cleared)\":\"\");\n #endif\n             try_bounds=CompareImagesBounds(bgnd_image,curr,CompareOverlayLayer,exception);\n #if DEBUG_OPT_FRAME\n             try_cleared=IsBoundsCleared(bgnd_image,curr,&try_bounds,exception);\n             (void) FormatLocaleFile(stderr, \"expand_test: %.20gx%.20g%+.20g%+.20g%s\\n\",\n                 (double) try_bounds.width,(double) try_bounds.height,\n                 (double) try_bounds.x,(double) try_bounds.y,\n                 try_cleared?\"   (pixels cleared)\":\"\");\n #endif\n           }\n         if ( cleared ||\n               bgnd_bounds.width*bgnd_bounds.height\n                 +try_bounds.width*try_bounds.height\n               < bounds[i-1].width*bounds[i-1].height\n                   +dup_bounds.width*dup_bounds.height\n                   +bounds[i].width*bounds[i].height )\n           {\n             cleared=MagickFalse;\n             bounds[i-1]=bgnd_bounds;\n             bounds[i]=try_bounds;\n             if ( disposals[i-1] == DupDispose )\n               dup_image=DestroyImage(dup_image);\n             disposals[i-1]=BackgroundDispose;\n #if DEBUG_OPT_FRAME\n     (void) FormatLocaleFile(stderr,\"expand_bgnd: accepted\\n\");\n           } else {\n     (void) FormatLocaleFile(stderr,\"expand_bgnd: reject\\n\");\n #endif\n           }\n       }\n     if ( disposals[i-1] == DupDispose )\n       {\n          if (bgnd_image != (Image *) NULL)\n            bgnd_image=DestroyImage(bgnd_image);\n          prev_image=DestroyImage(prev_image);\n          prev_image=dup_image, dup_image=(Image *) NULL;\n          bounds[i+1]=bounds[i];\n          bounds[i]=dup_bounds;\n          disposals[i-1]=DupDispose;\n          disposals[i]=BackgroundDispose;\n          i++;\n       }\n     else\n       {\n         if ( dup_image != (Image *) NULL)\n           dup_image=DestroyImage(dup_image);\n         if ( disposals[i-1] != PreviousDispose )\n           prev_image=DestroyImage(prev_image);\n         if ( disposals[i-1] == BackgroundDispose )\n           prev_image=bgnd_image, bgnd_image=(Image *) NULL;\n         if (bgnd_image != (Image *) NULL)\n           bgnd_image=DestroyImage(bgnd_image);\n         if ( disposals[i-1] == NoneDispose )\n           {\n             prev_image=ReferenceImage(curr->previous);\n             if (prev_image == (Image *) NULL)\n               {\n                 bounds=(RectangleInfo *) RelinquishMagickMemory(bounds);\n                 disposals=(DisposeType *) RelinquishMagickMemory(disposals);\n                 return((Image *) NULL);\n               }\n           }\n \n       }\n     assert(prev_image != (Image *) NULL);\n     disposals[i]=disposals[i-1];\n #if DEBUG_OPT_FRAME\n     (void) FormatLocaleFile(stderr, \"final   %.20g : %s  %.20gx%.20g%+.20g%+.20g\\n\",\n          (double) i-1,\n          CommandOptionToMnemonic(MagickDisposeOptions,disposals[i-1]),\n          (double) bounds[i-1].width,(double) bounds[i-1].height,\n          (double) bounds[i-1].x,(double) bounds[i-1].y );\n #endif\n #if DEBUG_OPT_FRAME\n     (void) FormatLocaleFile(stderr, \"interum %.20g : %s  %.20gx%.20g%+.20g%+.20g\\n\",\n          (double) i,\n          CommandOptionToMnemonic(MagickDisposeOptions,disposals[i]),\n          (double) bounds[i].width,(double) bounds[i].height,\n          (double) bounds[i].x,(double) bounds[i].y );\n     (void) FormatLocaleFile(stderr,\"\\n\");\n #endif\n     i++;\n   }\n   prev_image=DestroyImage(prev_image);\n   sans_exception=AcquireExceptionInfo();\n   i=0;\n   curr=GetFirstImageInList(image);\n   optimized_image=NewImageList();\n   while ( curr != (const Image *) NULL )\n   {\n     prev_image=CloneImage(curr,0,0,MagickTrue,exception);\n     if (prev_image == (Image *) NULL)\n       break;\n     prev_image->background_color.alpha_trait=BlendPixelTrait;\n     if ( disposals[i] == DelDispose ) {\n       size_t time = 0;\n       while ( disposals[i] == DelDispose ) {\n// bug_start\n        time += curr->delay*1000/curr->ticks_per_second;\n// bug_end\n         curr=GetNextImageInList(curr);\n         i++;\n       }\n// bug_start\n      time += curr->delay*1000/curr->ticks_per_second;\n// bug_end\n       prev_image->ticks_per_second = 100L;\n       prev_image->delay = time*prev_image->ticks_per_second/1000;\n     }\n     bgnd_image=CropImage(prev_image,&bounds[i],sans_exception);\n     prev_image=DestroyImage(prev_image);\n     if (bgnd_image == (Image *) NULL)\n       break;\n     bgnd_image->dispose=disposals[i];\n     if ( disposals[i] == DupDispose ) {\n       bgnd_image->delay=0;\n       bgnd_image->dispose=NoneDispose;\n     }\n     else\n       curr=GetNextImageInList(curr);\n     AppendImageToList(&optimized_image,bgnd_image);\n     i++;\n   }\n   sans_exception=DestroyExceptionInfo(sans_exception);\n   bounds=(RectangleInfo *) RelinquishMagickMemory(bounds);\n   disposals=(DisposeType *) RelinquishMagickMemory(disposals);\n   if (curr != (Image *) NULL)\n     {\n       optimized_image=DestroyImageList(optimized_image);\n       return((Image *) NULL);\n     }\n   return(GetFirstImageInList(optimized_image));\n }\n \n", "target": "// fix_start\n        time +=(size_t) (curr->delay*1000*\n          PerceptibleReciprocal((double) curr->ticks_per_second));\n// fix_end\n// fix_start\n      time += (size_t)(curr->delay*1000*\n        PerceptibleReciprocal((double) curr->ticks_per_second));\n// fix_end\n", "cwe": "CWE-399", "cwe_name": "Resource Management Errors", "cve": "CVE-2020-27560", "cve_desc": "ImageMagick 7.0.10-34 allows Division by Zero in OptimizeLayerFrames in MagickCore/layer.c, which may cause a denial of service.", "project": "ImageMagick", "idx": 202739}
{"source": " static int io_add_buffers(struct io_provide_buf *pbuf, struct io_buffer **head)\n {\n \tstruct io_buffer *buf;\n \tu64 addr = pbuf->addr;\n \tint i, bid = pbuf->bid;\n \n \tfor (i = 0; i < pbuf->nbufs; i++) {\n \t\tbuf = kmalloc(sizeof(*buf), GFP_KERNEL);\n \t\tif (!buf)\n \t\t\tbreak;\n \n \t\tbuf->addr = addr;\n// bug_start\n\t\tbuf->len = pbuf->len;\n// bug_end\n \t\tbuf->bid = bid;\n \t\taddr += pbuf->len;\n \t\tbid++;\n \t\tif (!*head) {\n \t\t\tINIT_LIST_HEAD(&buf->list);\n \t\t\t*head = buf;\n \t\t} else {\n \t\t\tlist_add_tail(&buf->list, &(*head)->list);\n \t\t}\n \t}\n \n \treturn i ? i : -ENOMEM;\n }\n \n", "target": "// fix_start\n\t\tbuf->len = min_t(__u32, pbuf->len, MAX_RW_COUNT);\n// fix_end\n", "cwe": "CWE-787", "cwe_name": "Out-of-bounds Write", "cve": "CVE-2021-3491", "cve_desc": "The io_uring subsystem in the Linux kernel allowed the MAX_RW_COUNT limit to be bypassed in the PROVIDE_BUFFERS operation, which led to negative values being usedin mem_rw when reading /proc/<PID>/mem. This could be used to create a heap overflow leading to arbitrary code execution in the kernel. It was addressed via commit d1f82808877b (\"io_uring: truncate lengths larger than MAX_RW_COUNT on provide buffers\") (v5.13-rc1) and backported to the stable kernels in v5.12.4, v5.11.21, and v5.10.37. It was introduced in ddf0322db79c (\"io_uring: add IORING_OP_PROVIDE_BUFFERS\") (v5.7-rc1).", "project": "linux", "idx": 202741}
{"source": " static int fuse_do_getattr(struct inode *inode, struct kstat *stat,\n \t\t\t   struct file *file)\n {\n \tint err;\n \tstruct fuse_getattr_in inarg;\n \tstruct fuse_attr_out outarg;\n \tstruct fuse_mount *fm = get_fuse_mount(inode);\n \tFUSE_ARGS(args);\n \tu64 attr_version;\n \n \tattr_version = fuse_get_attr_version(fm->fc);\n \n \tmemset(&inarg, 0, sizeof(inarg));\n \tmemset(&outarg, 0, sizeof(outarg));\n \tif (file && S_ISREG(inode->i_mode)) {\n \t\tstruct fuse_file *ff = file->private_data;\n \n \t\tinarg.getattr_flags |= FUSE_GETATTR_FH;\n \t\tinarg.fh = ff->fh;\n \t}\n \targs.opcode = FUSE_GETATTR;\n \targs.nodeid = get_node_id(inode);\n \targs.in_numargs = 1;\n \targs.in_args[0].size = sizeof(inarg);\n \targs.in_args[0].value = &inarg;\n \targs.out_numargs = 1;\n \targs.out_args[0].size = sizeof(outarg);\n \targs.out_args[0].value = &outarg;\n \terr = fuse_simple_request(fm, &args);\n \tif (!err) {\n \t\tif (fuse_invalid_attr(&outarg.attr) ||\n \t\t    (inode->i_mode ^ outarg.attr.mode) & S_IFMT) {\n// bug_start\n\t\t\tmake_bad_inode(inode);\n// bug_end\n \t\t\terr = -EIO;\n \t\t} else {\n \t\t\tfuse_change_attributes(inode, &outarg.attr,\n \t\t\t\t\t       attr_timeout(&outarg),\n \t\t\t\t\t       attr_version);\n \t\t\tif (stat)\n \t\t\t\tfuse_fillattr(inode, &outarg.attr, stat);\n \t\t}\n \t}\n \treturn err;\n }\n \n", "target": "// fix_start\n\t\t\tfuse_make_bad(inode);\n// fix_end\n", "cwe": "CWE-459", "cwe_name": "Incomplete Cleanup", "cve": "CVE-2020-36322", "cve_desc": "An issue was discovered in the FUSE filesystem implementation in the Linux kernel before 5.10.6, aka CID-5d069dbe8aaf. fuse_do_getattr() calls make_bad_inode() in inappropriate situations, causing a system crash. NOTE: the original fix for this vulnerability was incomplete, and its incompleteness is tracked as CVE-2021-28950.", "project": "linux", "idx": 202842}
{"source": " static struct kvm_vcpu_hv_synic *synic_get(struct kvm *kvm, u32 vpidx)\n {\n \tstruct kvm_vcpu *vcpu;\n \tstruct kvm_vcpu_hv_synic *synic;\n \n \tvcpu = get_vcpu_by_vpidx(kvm, vpidx);\n// bug_start\n\tif (!vcpu)\n// bug_end\n \t\treturn NULL;\n \tsynic = to_hv_synic(vcpu);\n \treturn (synic->active) ? synic : NULL;\n }\n \n", "target": "// fix_start\n\tif (!vcpu || !to_hv_vcpu(vcpu))\n// fix_end\n", "cwe": "CWE-476", "cwe_name": "NULL Pointer Dereference", "cve": "CVE-2021-30178", "cve_desc": "An issue was discovered in the Linux kernel through 5.11.11. synic_get in arch/x86/kvm/hyperv.c has a NULL pointer dereference for certain accesses to the SynIC Hyper-V context, aka CID-919f4ebc5987.", "project": "linux", "idx": 202898}
{"source": "// bug_start\nint ssh_buffer_add_data(struct ssh_buffer_struct *buffer, const void *data, uint32_t len)\n// bug_end\n {\n// bug_start\n  buffer_verify(buffer);\n// bug_end\n \n// bug_start\n  if (data == NULL) {\n      return -1;\n  }\n// bug_end\n \n// bug_start\n  if (buffer->used + len < len) {\n    return -1;\n  }\n// bug_end\n \n// bug_start\n  if (buffer->allocated < (buffer->used + len)) {\n    if(buffer->pos > 0)\n      buffer_shift(buffer);\n    if (realloc_buffer(buffer, buffer->used + len) < 0) {\n      return -1;\n// bug_end\n     }\n// bug_start\n  }\n// bug_end\n \n// bug_start\n  memcpy(buffer->data+buffer->used, data, len);\n  buffer->used+=len;\n  buffer_verify(buffer);\n  return 0;\n// bug_end\n }\n \n", "target": "// fix_start\nvoid *ssh_buffer_allocate(struct ssh_buffer_struct *buffer, uint32_t len)\n// fix_end\n// fix_start\n    void *ptr;\n    buffer_verify(buffer);\n// fix_end\n// fix_start\n    if (buffer->used + len < len) {\n        return NULL;\n    }\n// fix_end\n// fix_start\n    if (buffer->allocated < (buffer->used + len)) {\n        if (buffer->pos > 0) {\n            buffer_shift(buffer);\n        }\n// fix_end\n// fix_start\n        if (realloc_buffer(buffer, buffer->used + len) < 0) {\n            return NULL;\n        }\n// fix_end\n// fix_start\n// fix_end\n// fix_start\n    ptr = buffer->data + buffer->used;\n    buffer->used+=len;\n    buffer_verify(buffer);\n\n    return ptr;\n// fix_end\n", "cwe": "CWE-476", "cwe_name": "NULL Pointer Dereference", "cve": "CVE-2020-16135", "cve_desc": "libssh 0.9.4 has a NULL pointer dereference in tftpserver.c if ssh_buffer_new returns NULL.", "project": "libssh-mirror", "idx": 203616}
{"source": " static int usb_host_handle_control(USBHostDevice *s, USBPacket *p)\n {\n     struct usbdevfs_urb *urb;\n     AsyncURB *aurb;\n     int ret, value, index;\n// bug_start\n// bug_end\n \n     value = le16_to_cpu(s->ctrl.req.wValue);\n     index = le16_to_cpu(s->ctrl.req.wIndex);\n \n     dprintf(\"husb: ctrl type 0x%x req 0x%x val 0x%x index %u len %u\\n\",\n         s->ctrl.req.bRequestType, s->ctrl.req.bRequest, value, index,\n         s->ctrl.len);\n \n     if (s->ctrl.req.bRequestType == 0) {\n         switch (s->ctrl.req.bRequest) {\n         case USB_REQ_SET_ADDRESS:\n             return usb_host_set_address(s, value);\n \n         case USB_REQ_SET_CONFIGURATION:\n             return usb_host_set_config(s, value & 0xff);\n         }\n     }\n \n     if (s->ctrl.req.bRequestType == 1 &&\n                   s->ctrl.req.bRequest == USB_REQ_SET_INTERFACE)\n         return usb_host_set_interface(s, index, value);\n \n \n// bug_start\n// bug_end\n     aurb = async_alloc();\n     aurb->hdev   = s;\n     aurb->packet = p;\n \n     urb = &aurb->urb;\n \n     urb->type     = USBDEVFS_URB_TYPE_CONTROL;\n     urb->endpoint = p->devep;\n \n     urb->buffer        = &s->ctrl.req;\n// bug_start\n    urb->buffer_length = 8 + s->ctrl.len;\n// bug_end\n \n     urb->usercontext = s;\n \n     ret = ioctl(s->fd, USBDEVFS_SUBMITURB, urb);\n \n     dprintf(\"husb: submit ctrl. len %u aurb %p\\n\", urb->buffer_length, aurb);\n \n     if (ret < 0) {\n         dprintf(\"husb: submit failed. errno %d\\n\", errno);\n         async_free(aurb);\n \n         switch(errno) {\n         case ETIMEDOUT:\n             return USB_RET_NAK;\n         case EPIPE:\n         default:\n             return USB_RET_STALL;\n         }\n     }\n \n     usb_defer_packet(p, async_cancel, aurb);\n     return USB_RET_ASYNC;\n }\n \n", "target": "// fix_start\n    int buffer_len;\n// fix_end\n// fix_start\n    buffer_len = 8 + s->ctrl.len;\n    if (buffer_len > sizeof(s->ctrl.buffer)) {\n\t    fprintf(stderr, \"husb: ctrl buffer too small (%u > %lu)\\n\",\n\t\t    buffer_len, sizeof(s->ctrl.buffer));\n\t    return USB_RET_STALL;\n    }\n\n// fix_end\n// fix_start\n    urb->buffer_length = buffer_len;\n// fix_end\n", "cwe": "CWE-119", "cwe_name": "Improper Restriction of Operations within the Bounds of a Memory Buffer", "cve": "CVE-2010-0297", "cve_desc": "Buffer overflow in the usb_host_handle_control function in the USB passthrough handling implementation in usb-linux.c in QEMU before 0.11.1 allows guest OS users to cause a denial of service (guest OS crash or hang) or possibly execute arbitrary code on the host OS via a crafted USB packet.", "project": "qemu", "idx": 203887}
{"source": " evbuffer_add(struct evbuffer *buf, const void *data_in, size_t datlen)\n {\n \tstruct evbuffer_chain *chain, *tmp;\n \tconst unsigned char *data = data_in;\n \tsize_t remain, to_alloc;\n \tint result = -1;\n \n \tEVBUFFER_LOCK(buf);\n \n \tif (buf->freeze_end) {\n// bug_start\n// bug_end\n \t\tgoto done;\n \t}\n \n \tchain = buf->last;\n \n \tif (chain == NULL) {\n \t\tchain = evbuffer_chain_new(datlen);\n \t\tif (!chain)\n \t\t\tgoto done;\n \t\tevbuffer_chain_insert(buf, chain);\n \t}\n \n \tif ((chain->flags & EVBUFFER_IMMUTABLE) == 0) {\n// bug_start\n\t\tremain = (size_t)(chain->buffer_len - chain->misalign - chain->off);\n// bug_end\n \t\tif (remain >= datlen) {\n \t\t\tmemcpy(chain->buffer + chain->misalign + chain->off,\n \t\t\t    data, datlen);\n \t\t\tchain->off += datlen;\n \t\t\tbuf->total_len += datlen;\n \t\t\tbuf->n_add_for_cb += datlen;\n \t\t\tgoto out;\n \t\t} else if (!CHAIN_PINNED(chain) &&\n \t\t    evbuffer_chain_should_realign(chain, datlen)) {\n \t\t\tevbuffer_chain_align(chain);\n \n \t\t\tmemcpy(chain->buffer + chain->off, data, datlen);\n \t\t\tchain->off += datlen;\n \t\t\tbuf->total_len += datlen;\n \t\t\tbuf->n_add_for_cb += datlen;\n \t\t\tgoto out;\n \t\t}\n \t} else {\n \t\tremain = 0;\n \t}\n \n \tto_alloc = chain->buffer_len;\n \tif (to_alloc <= EVBUFFER_CHAIN_MAX_AUTO_SIZE/2)\n \t\tto_alloc <<= 1;\n \tif (datlen > to_alloc)\n \t\tto_alloc = datlen;\n \ttmp = evbuffer_chain_new(to_alloc);\n \tif (tmp == NULL)\n \t\tgoto done;\n \n \tif (remain) {\n \t\tmemcpy(chain->buffer + chain->misalign + chain->off,\n \t\t    data, remain);\n \t\tchain->off += remain;\n \t\tbuf->total_len += remain;\n \t\tbuf->n_add_for_cb += remain;\n \t}\n \n \tdata += remain;\n \tdatlen -= remain;\n \n \tmemcpy(tmp->buffer, data, datlen);\n \ttmp->off = datlen;\n \tevbuffer_chain_insert(buf, tmp);\n \tbuf->n_add_for_cb += datlen;\n \n out:\n \tevbuffer_invoke_callbacks(buf);\n \tresult = 0;\n done:\n \tEVBUFFER_UNLOCK(buf);\n \treturn result;\n }\n \n", "target": "// fix_start\n\t\tgoto done;\n\t}\n\tif (datlen > EV_SIZE_MAX - buf->total_len) {\n// fix_end\n// fix_start\n\t\tEVUTIL_ASSERT(chain->misalign >= 0 &&\n\t\t    (ev_uint64_t)chain->misalign <= EVBUFFER_CHAIN_MAX);\n\t\tremain = chain->buffer_len - (size_t)chain->misalign - chain->off;\n// fix_end\n", "cwe": "CWE-189", "cwe_name": "Numeric Errors", "cve": "CVE-2014-6272", "cve_desc": "Multiple integer overflows in the evbuffer API in Libevent 1.4.x before 1.4.15, 2.0.x before 2.0.22, and 2.1.x before 2.1.5-beta allow context-dependent attackers to cause a denial of service or possibly have other unspecified impact via \"insanely large inputs\" to the (1) evbuffer_add, (2) evbuffer_expand, or (3) bufferevent_write function, which triggers a heap-based buffer overflow or an infinite loop.  NOTE: this identifier has been SPLIT per ADT3 due to different affected versions. See CVE-2015-6525 for the functions that are only affected in 2.0 and later.", "project": "libevent", "idx": 203893}
{"source": " p11_rpc_buffer_get_byte_array (p11_buffer *buf,\n                                size_t *offset,\n                                const unsigned char **data,\n                                size_t *length)\n {\n \tsize_t off = *offset;\n \tuint32_t len;\n \tif (!p11_rpc_buffer_get_uint32 (buf, &off, &len))\n \t\treturn false;\n \tif (len == 0xffffffff) {\n \t\t*offset = off;\n \t\tif (data)\n \t\t\t*data = NULL;\n \t\tif (length)\n \t\t\t*length = 0;\n \t\treturn true;\n \t} else if (len >= 0x7fffffff) {\n \t\tp11_buffer_fail (buf);\n \t\treturn false;\n \t}\n \n// bug_start\n\tif (buf->len < len || *offset > buf->len - len) {\n// bug_end\n \t\tp11_buffer_fail (buf);\n \t\treturn false;\n \t}\n \n \tif (data)\n \t\t*data = (unsigned char *)buf->data + off;\n \tif (length)\n \t\t*length = len;\n \t*offset = off + len;\n \n \treturn true;\n }\n \n", "target": "// fix_start\n\tif (buf->len < len || off > buf->len - len) {\n// fix_end\n", "cwe": "CWE-125", "cwe_name": "Out-of-bounds Read", "cve": "CVE-2020-29362", "cve_desc": "An issue was discovered in p11-kit 0.21.1 through 0.23.21. A heap-based buffer over-read has been discovered in the RPC protocol used by thep11-kit server/remote commands and the client library. When the remote entity supplies a byte array through a serialized PKCS#11 function call, the receiving entity may allow the reading of up to 4 bytes of memory past the heap allocation.", "project": "p11-kit", "idx": 204031}
{"source": " pixReadFromTiffStream(TIFF  *tif)\n {\n char      *text;\n l_uint8   *linebuf, *data, *rowptr;\n l_uint16   spp, bps, photometry, tiffcomp, orientation, sample_fmt;\n l_uint16  *redmap, *greenmap, *bluemap;\n l_int32    d, wpl, bpl, comptype, i, j, k, ncolors, rval, gval, bval, aval;\n l_int32    xres, yres, tiffbpl, packedbpl, halfsize;\n l_uint32   w, h, tiffword, read_oriented;\n l_uint32  *line, *ppixel, *tiffdata, *pixdata;\n PIX       *pix, *pix1;\n PIXCMAP   *cmap;\n \n     PROCNAME(\"pixReadFromTiffStream\");\n \n     if (!tif)\n         return (PIX *)ERROR_PTR(\"tif not defined\", procName, NULL);\n \n     read_oriented = 0;\n \n     TIFFGetFieldDefaulted(tif, TIFFTAG_SAMPLEFORMAT, &sample_fmt);\n     if (sample_fmt != SAMPLEFORMAT_UINT) {\n         L_ERROR(\"sample format = %d is not uint\\n\", procName, sample_fmt);\n         return NULL;\n     }\n \n     if (TIFFIsTiled(tif)) {\n         L_ERROR(\"tiled format is not supported\\n\", procName);\n         return NULL;\n     }\n \n     TIFFGetFieldDefaulted(tif, TIFFTAG_COMPRESSION, &tiffcomp);\n     if (tiffcomp == COMPRESSION_OJPEG) {\n         L_ERROR(\"old style jpeg format is not supported\\n\", procName);\n         return NULL;\n     }\n \n     TIFFGetFieldDefaulted(tif, TIFFTAG_BITSPERSAMPLE, &bps);\n     TIFFGetFieldDefaulted(tif, TIFFTAG_SAMPLESPERPIXEL, &spp);\n     if (bps != 1 && bps != 2 && bps != 4 && bps != 8 && bps != 16) {\n         L_ERROR(\"invalid bps = %d\\n\", procName, bps);\n         return NULL;\n     }\n     if (spp == 2 && bps != 8) {\n         L_WARNING(\"for 2 spp, only handle 8 bps\\n\", procName);\n         return NULL;\n     }\n     if (spp == 1)\n         d = bps;\n     else if (spp == 2)\n         d = 32;\n     else if (spp == 3 || spp == 4)\n         d = 32;\n     else\n         return (PIX *)ERROR_PTR(\"spp not in set {1,2,3,4}\", procName, NULL);\n \n     TIFFGetField(tif, TIFFTAG_IMAGEWIDTH, &w);\n     TIFFGetField(tif, TIFFTAG_IMAGELENGTH, &h);\n     if (w > MaxTiffWidth) {\n         L_ERROR(\"width = %d pixels; too large\\n\", procName, w);\n         return NULL;\n     }\n     if (h > MaxTiffHeight) {\n         L_ERROR(\"height = %d pixels; too large\\n\", procName, h);\n         return NULL;\n     }\n \n     tiffbpl = TIFFScanlineSize(tif);\n     packedbpl = (bps * spp * w + 7) / 8;\n     halfsize = L_ABS(2 * tiffbpl - packedbpl) <= 8;\n #if 0\n     if (halfsize)\n         L_INFO(\"packedbpl = %d is approx. twice tiffbpl = %d\\n\", procName,\n                packedbpl, tiffbpl);\n #endif\n     if (tiffbpl != packedbpl && !halfsize) {\n         L_ERROR(\"invalid tiffbpl: tiffbpl = %d, packedbpl = %d, \"\n                 \"bps = %d, spp = %d, w = %d\\n\",\n                 procName, tiffbpl, packedbpl, bps, spp, w);\n         return NULL;\n     }\n \n     if ((pix = pixCreate(w, h, d)) == NULL)\n         return (PIX *)ERROR_PTR(\"pix not made\", procName, NULL);\n     pixSetInputFormat(pix, IFF_TIFF);\n     data = (l_uint8 *)pixGetData(pix);\n     wpl = pixGetWpl(pix);\n     bpl = 4 * wpl;\n \n     if (spp == 1) {\n         linebuf = (l_uint8 *)LEPT_CALLOC(tiffbpl + 1, sizeof(l_uint8));\n         for (i = 0; i < h; i++) {\n             if (TIFFReadScanline(tif, linebuf, i, 0) < 0) {\n                 LEPT_FREE(linebuf);\n                 pixDestroy(&pix);\n                 return (PIX *)ERROR_PTR(\"line read fail\", procName, NULL);\n             }\n             memcpy(data, linebuf, tiffbpl);\n             data += bpl;\n         }\n         if (bps <= 8)\n             pixEndianByteSwap(pix);\n         else\n             pixEndianTwoByteSwap(pix);\n         LEPT_FREE(linebuf);\n     } else if (spp == 2 && bps == 8) {\n         L_INFO(\"gray+alpha is not supported; converting to RGBA\\n\", procName);\n         pixSetSpp(pix, 4);\n// bug_start\n        linebuf = (l_uint8 *)LEPT_CALLOC(tiffbpl + 1, sizeof(l_uint8));\n// bug_end\n         pixdata = pixGetData(pix);\n         for (i = 0; i < h; i++) {\n             if (TIFFReadScanline(tif, linebuf, i, 0) < 0) {\n                 LEPT_FREE(linebuf);\n                 pixDestroy(&pix);\n                 return (PIX *)ERROR_PTR(\"line read fail\", procName, NULL);\n             }\n             rowptr = linebuf;\n             ppixel = pixdata + i * wpl;\n             for (j = k = 0; j < w; j++) {\n                 SET_DATA_BYTE(ppixel, COLOR_RED, rowptr[k]);\n                 SET_DATA_BYTE(ppixel, COLOR_GREEN, rowptr[k]);\n                 SET_DATA_BYTE(ppixel, COLOR_BLUE, rowptr[k++]);\n                 SET_DATA_BYTE(ppixel, L_ALPHA_CHANNEL, rowptr[k++]);\n                 ppixel++;\n             }\n         }\n         LEPT_FREE(linebuf);\n     } else {\n         if ((tiffdata = (l_uint32 *)LEPT_CALLOC((size_t)w * h,\n                                                  sizeof(l_uint32))) == NULL) {\n             pixDestroy(&pix);\n             return (PIX *)ERROR_PTR(\"calloc fail for tiffdata\", procName, NULL);\n         }\n         if (!TIFFReadRGBAImageOriented(tif, w, h, tiffdata,\n                                        ORIENTATION_TOPLEFT, 0)) {\n             LEPT_FREE(tiffdata);\n             pixDestroy(&pix);\n             return (PIX *)ERROR_PTR(\"failed to read tiffdata\", procName, NULL);\n         } else {\n             read_oriented = 1;\n         }\n \n         if (spp == 4) pixSetSpp(pix, 4);\n         line = pixGetData(pix);\n         for (i = 0; i < h; i++, line += wpl) {\n             for (j = 0, ppixel = line; j < w; j++) {\n                 tiffword = tiffdata[i * w + j];\n                 rval = TIFFGetR(tiffword);\n                 gval = TIFFGetG(tiffword);\n                 bval = TIFFGetB(tiffword);\n                 if (spp == 3) {\n                     composeRGBPixel(rval, gval, bval, ppixel);\n                 } else {\n                     aval = TIFFGetA(tiffword);\n                     composeRGBAPixel(rval, gval, bval, aval, ppixel);\n                 }\n                 ppixel++;\n             }\n         }\n         LEPT_FREE(tiffdata);\n     }\n \n     if (getTiffStreamResolution(tif, &xres, &yres) == 0) {\n         pixSetXRes(pix, xres);\n         pixSetYRes(pix, yres);\n     }\n \n     comptype = getTiffCompressedFormat(tiffcomp);\n     pixSetInputFormat(pix, comptype);\n \n     if (TIFFGetField(tif, TIFFTAG_COLORMAP, &redmap, &greenmap, &bluemap)) {\n         if (bps > 8) {\n             pixDestroy(&pix);\n             return (PIX *)ERROR_PTR(\"colormap size > 256\", procName, NULL);\n         }\n         if ((cmap = pixcmapCreate(bps)) == NULL) {\n             pixDestroy(&pix);\n             return (PIX *)ERROR_PTR(\"colormap not made\", procName, NULL);\n         }\n         ncolors = 1 << bps;\n         for (i = 0; i < ncolors; i++)\n             pixcmapAddColor(cmap, redmap[i] >> 8, greenmap[i] >> 8,\n                             bluemap[i] >> 8);\n         if (pixSetColormap(pix, cmap)) {\n             pixDestroy(&pix);\n             return (PIX *)ERROR_PTR(\"invalid colormap\", procName, NULL);\n         }\n \n         if (bps == 1) {\n             pix1 = pixRemoveColormap(pix, REMOVE_CMAP_BASED_ON_SRC);\n             pixDestroy(&pix);\n             pix = pix1;\n         }\n     } else {\n         if (!TIFFGetField(tif, TIFFTAG_PHOTOMETRIC, &photometry)) {\n             if (tiffcomp == COMPRESSION_CCITTFAX3 ||\n                 tiffcomp == COMPRESSION_CCITTFAX4 ||\n                 tiffcomp == COMPRESSION_CCITTRLE ||\n                 tiffcomp == COMPRESSION_CCITTRLEW) {\n                 photometry = PHOTOMETRIC_MINISWHITE;\n             } else {\n                 photometry = PHOTOMETRIC_MINISBLACK;\n             }\n         }\n         if ((d == 1 && photometry == PHOTOMETRIC_MINISBLACK) ||\n             (d == 8 && photometry == PHOTOMETRIC_MINISWHITE))\n             pixInvert(pix, pix);\n     }\n \n     if (TIFFGetField(tif, TIFFTAG_ORIENTATION, &orientation)) {\n         if (orientation >= 1 && orientation <= 8) {\n             struct tiff_transform *transform = (read_oriented) ?\n                 &tiff_partial_orientation_transforms[orientation - 1] :\n                 &tiff_orientation_transforms[orientation - 1];\n             if (transform->vflip) pixFlipTB(pix, pix);\n             if (transform->hflip) pixFlipLR(pix, pix);\n             if (transform->rotate) {\n                 PIX *oldpix = pix;\n                 pix = pixRotate90(oldpix, transform->rotate);\n                 pixDestroy(&oldpix);\n             }\n         }\n     }\n \n     text = NULL;\n     TIFFGetField(tif, TIFFTAG_IMAGEDESCRIPTION, &text);\n     if (text) pixSetText(pix, text);\n     return pix;\n }\n \n", "target": "// fix_start\n        linebuf = (l_uint8 *)LEPT_CALLOC(2 * tiffbpl + 1, sizeof(l_uint8));\n// fix_end\n", "cwe": "CWE-125", "cwe_name": "Out-of-bounds Read", "cve": "CVE-2020-36280", "cve_desc": "Leptonica before 1.80.0 allows a heap-based buffer over-read in pixReadFromTiffStream, related to tiffio.c.", "project": "leptonica", "idx": 204059}
{"source": " int input_set_keycode(struct input_dev *dev,\n \t\t      const struct input_keymap_entry *ke)\n {\n \tunsigned long flags;\n \tunsigned int old_keycode;\n \tint retval;\n \n \tif (ke->keycode > KEY_MAX)\n \t\treturn -EINVAL;\n \n \tspin_lock_irqsave(&dev->event_lock, flags);\n \n \tretval = dev->setkeycode(dev, ke, &old_keycode);\n \tif (retval)\n \t\tgoto out;\n \n \t__clear_bit(KEY_RESERVED, dev->keybit);\n \n// bug_start\n\tif (test_bit(EV_KEY, dev->evbit) &&\n\t    !is_event_supported(old_keycode, dev->keybit, KEY_MAX) &&\n\t    __test_and_clear_bit(old_keycode, dev->key)) {\n// bug_end\n \t\tstruct input_value vals[] =  {\n \t\t\t{ EV_KEY, old_keycode, 0 },\n \t\t\tinput_value_sync\n \t\t};\n \n \t\tinput_pass_values(dev, vals, ARRAY_SIZE(vals));\n \t}\n \n  out:\n \tspin_unlock_irqrestore(&dev->event_lock, flags);\n \n \treturn retval;\n }\n \n", "target": "// fix_start\n\tif (old_keycode > KEY_MAX) {\n\t\tdev_warn(dev->dev.parent ?: &dev->dev,\n\t\t\t \"%s: got too big old keycode %#x\\n\",\n\t\t\t __func__, old_keycode);\n\t} else if (test_bit(EV_KEY, dev->evbit) &&\n\t\t   !is_event_supported(old_keycode, dev->keybit, KEY_MAX) &&\n\t\t   __test_and_clear_bit(old_keycode, dev->key)) {\n// fix_end\n", "cwe": "CWE-703", "cwe_name": "Improper Check or Handling of Exceptional Conditions", "cve": "CVE-2019-20636", "cve_desc": "In the Linux kernel before 5.4.12, drivers/input/input.c has out-of-bounds writes via a crafted keycode table, as demonstrated by input_set_keycode, aka CID-cb222aed03d7.", "project": "linux", "idx": 204147}
{"source": " static int kvm_s390_get_cmma(struct kvm *kvm, struct kvm_s390_cmma_log *args,\n \t\t\t     u8 *res, unsigned long bufsize)\n {\n \tunsigned long mem_end, cur_gfn, next_gfn, hva, pgstev;\n \tstruct kvm_memslots *slots = kvm_memslots(kvm);\n \tstruct kvm_memory_slot *ms;\n// bug_start\n// bug_end\n \n \tcur_gfn = kvm_s390_next_dirty_cmma(slots, args->start_gfn);\n \tms = gfn_to_memslot(kvm, cur_gfn);\n \targs->count = 0;\n \targs->start_gfn = cur_gfn;\n \tif (!ms)\n \t\treturn 0;\n \tnext_gfn = kvm_s390_next_dirty_cmma(slots, cur_gfn + 1);\n \tmem_end = slots->memslots[0].base_gfn + slots->memslots[0].npages;\n \n \twhile (args->count < bufsize) {\n \t\thva = gfn_to_hva(kvm, cur_gfn);\n \t\tif (kvm_is_error_hva(hva))\n \t\t\treturn 0;\n \t\tif (test_and_clear_bit(cur_gfn - ms->base_gfn, kvm_second_dirty_bitmap(ms)))\n \t\t\tatomic64_dec(&kvm->arch.cmma_dirty_pages);\n \t\tif (get_pgste(kvm->mm, hva, &pgstev) < 0)\n \t\t\tpgstev = 0;\n \t\tres[args->count++] = (pgstev >> 24) & 0x43;\n \t\tif (next_gfn > cur_gfn + KVM_S390_MAX_BIT_DISTANCE)\n \t\t\treturn 0;\n \t\tif (cur_gfn == next_gfn)\n \t\t\tnext_gfn = kvm_s390_next_dirty_cmma(slots, cur_gfn + 1);\n \t\tif ((next_gfn >= mem_end) ||\n \t\t    (next_gfn - args->start_gfn >= bufsize))\n \t\t\treturn 0;\n \t\tcur_gfn++;\n \t\tif (cur_gfn - ms->base_gfn >= ms->npages) {\n \t\t\tms = gfn_to_memslot(kvm, cur_gfn);\n \t\t\tif (!ms)\n \t\t\t\treturn 0;\n \t\t}\n \t}\n \treturn 0;\n }\n \n", "target": "// fix_start\n\n\tif (unlikely(!slots->used_slots))\n\t\treturn 0;\n// fix_end\n", "cwe": "CWE-416", "cwe_name": "Use After Free", "cve": "CVE-2020-36313", "cve_desc": "An issue was discovered in the Linux kernel before 5.7. The KVM subsystem allows out-of-range access to memslots after a deletion, aka CID-0774a964ef56. This affects arch/s390/kvm/kvm-s390.c, include/linux/kvm_host.h, and virt/kvm/kvm_main.c.", "project": "linux", "idx": 204189}
{"source": " static inline void kvm_memslot_delete(struct kvm_memslots *slots,\n \t\t\t\t      struct kvm_memory_slot *memslot)\n {\n \tstruct kvm_memory_slot *mslots = slots->memslots;\n \tint i;\n \n \tif (WARN_ON(slots->id_to_index[memslot->id] == -1))\n \t\treturn;\n \n \tslots->used_slots--;\n \n// bug_start\n// bug_end\n \tfor (i = slots->id_to_index[memslot->id]; i < slots->used_slots; i++) {\n \t\tmslots[i] = mslots[i + 1];\n \t\tslots->id_to_index[mslots[i].id] = i;\n \t}\n \tmslots[i] = *memslot;\n \tslots->id_to_index[memslot->id] = -1;\n }\n \n", "target": "// fix_start\n\tif (atomic_read(&slots->lru_slot) >= slots->used_slots)\n\t\tatomic_set(&slots->lru_slot, 0);\n\n// fix_end\n", "cwe": "CWE-416", "cwe_name": "Use After Free", "cve": "CVE-2020-36313", "cve_desc": "An issue was discovered in the Linux kernel before 5.7. The KVM subsystem allows out-of-range access to memslots after a deletion, aka CID-0774a964ef56. This affects arch/s390/kvm/kvm-s390.c, include/linux/kvm_host.h, and virt/kvm/kvm_main.c.", "project": "linux", "idx": 204190}
{"source": " search_memslots(struct kvm_memslots *slots, gfn_t gfn)\n {\n \tint start = 0, end = slots->used_slots;\n \tint slot = atomic_read(&slots->lru_slot);\n \tstruct kvm_memory_slot *memslots = slots->memslots;\n// bug_start\n// bug_end\n \n \tif (gfn >= memslots[slot].base_gfn &&\n \t    gfn < memslots[slot].base_gfn + memslots[slot].npages)\n \t\treturn &memslots[slot];\n \n \twhile (start < end) {\n \t\tslot = start + (end - start) / 2;\n \n \t\tif (gfn >= memslots[slot].base_gfn)\n \t\t\tend = slot;\n \t\telse\n \t\t\tstart = slot + 1;\n \t}\n \n \tif (gfn >= memslots[start].base_gfn &&\n \t    gfn < memslots[start].base_gfn + memslots[start].npages) {\n \t\tatomic_set(&slots->lru_slot, start);\n \t\treturn &memslots[start];\n \t}\n \n \treturn NULL;\n }\n \n", "target": "// fix_start\n\n\tif (unlikely(!slots->used_slots))\n\t\treturn NULL;\n// fix_end\n", "cwe": "CWE-416", "cwe_name": "Use After Free", "cve": "CVE-2020-36313", "cve_desc": "An issue was discovered in the Linux kernel before 5.7. The KVM subsystem allows out-of-range access to memslots after a deletion, aka CID-0774a964ef56. This affects arch/s390/kvm/kvm-s390.c, include/linux/kvm_host.h, and virt/kvm/kvm_main.c.", "project": "linux", "idx": 204191}
{"source": " static int do_mount(const char *mnt, char **typep, mode_t rootmode,\n \t\t    int fd, const char *opts, const char *dev, char **sourcep,\n \t\t    char **mnt_optsp)\n {\n \tint res;\n \tint flags = MS_NOSUID | MS_NODEV;\n \tchar *optbuf;\n \tchar *mnt_opts = NULL;\n \tconst char *s;\n \tchar *d;\n \tchar *fsname = NULL;\n \tchar *subtype = NULL;\n \tchar *source = NULL;\n \tchar *type = NULL;\n \tint blkdev = 0;\n \n \toptbuf = (char *) malloc(strlen(opts) + 128);\n \tif (!optbuf) {\n \t\tfprintf(stderr, \"%s: failed to allocate memory\\n\", progname);\n \t\treturn -1;\n \t}\n \n \tfor (s = opts, d = optbuf; *s;) {\n \t\tunsigned len;\n \t\tconst char *fsname_str = \"fsname=\";\n \t\tconst char *subtype_str = \"subtype=\";\n \t\tbool escape_ok = begins_with(s, fsname_str) ||\n \t\t\t\t begins_with(s, subtype_str);\n \t\tfor (len = 0; s[len]; len++) {\n \t\t\tif (escape_ok && s[len] == '\\\\' && s[len + 1])\n \t\t\t\tlen++;\n \t\t\telse if (s[len] == ',')\n \t\t\t\tbreak;\n \t\t}\n \t\tif (begins_with(s, fsname_str)) {\n \t\t\tif (!get_string_opt(s, len, fsname_str, &fsname))\n \t\t\t\tgoto err;\n \t\t} else if (begins_with(s, subtype_str)) {\n \t\t\tif (!get_string_opt(s, len, subtype_str, &subtype))\n \t\t\t\tgoto err;\n \t\t} else if (opt_eq(s, len, \"blkdev\")) {\n \t\t\tif (getuid() != 0) {\n \t\t\t\tfprintf(stderr,\n \t\t\t\t\t\"%s: option blkdev is privileged\\n\",\n \t\t\t\t\tprogname);\n \t\t\t\tgoto err;\n \t\t\t}\n \t\t\tblkdev = 1;\n \t\t} else if (opt_eq(s, len, \"auto_unmount\")) {\n \t\t\tauto_unmount = 1;\n \t\t} else if (!begins_with(s, \"fd=\") &&\n \t\t\t   !begins_with(s, \"rootmode=\") &&\n \t\t\t   !begins_with(s, \"user_id=\") &&\n \t\t\t   !begins_with(s, \"group_id=\")) {\n \t\t\tint on;\n \t\t\tint flag;\n \t\t\tint skip_option = 0;\n \t\t\tif (opt_eq(s, len, \"large_read\")) {\n \t\t\t\tstruct utsname utsname;\n \t\t\t\tunsigned kmaj, kmin;\n \t\t\t\tres = uname(&utsname);\n \t\t\t\tif (res == 0 &&\n \t\t\t\t    sscanf(utsname.release, \"%u.%u\",\n \t\t\t\t\t   &kmaj, &kmin) == 2 &&\n \t\t\t\t    (kmaj > 2 || (kmaj == 2 && kmin > 4))) {\n \t\t\t\t\tfprintf(stderr, \"%s: note: 'large_read' mount option is deprecated for %i.%i kernels\\n\", progname, kmaj, kmin);\n \t\t\t\t\tskip_option = 1;\n \t\t\t\t}\n \t\t\t}\n \t\t\tif (getuid() != 0 && !user_allow_other &&\n \t\t\t    (opt_eq(s, len, \"allow_other\") ||\n \t\t\t     opt_eq(s, len, \"allow_root\"))) {\n \t\t\t\tfprintf(stderr, \"%s: option %.*s only allowed if 'user_allow_other' is set in %s\\n\", progname, len, s, FUSE_CONF);\n \t\t\t\tgoto err;\n \t\t\t}\n \t\t\tif (!skip_option) {\n \t\t\t\tif (find_mount_flag(s, len, &on, &flag)) {\n \t\t\t\t\tif (on)\n \t\t\t\t\t\tflags |= flag;\n \t\t\t\t\telse\n \t\t\t\t\t\tflags  &= ~flag;\n// bug_start\n\t\t\t\t} else {\n// bug_end\n \t\t\t\t\tmemcpy(d, s, len);\n \t\t\t\t\td += len;\n \t\t\t\t\t*d++ = ',';\n// bug_start\n// bug_end\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \t\ts += len;\n \t\tif (*s)\n \t\t\ts++;\n \t}\n \t*d = '\\0';\n \tres = get_mnt_opts(flags, optbuf, &mnt_opts);\n \tif (res == -1)\n \t\tgoto err;\n \n \tsprintf(d, \"fd=%i,rootmode=%o,user_id=%u,group_id=%u\",\n \t\tfd, rootmode, getuid(), getgid());\n \n \tsource = malloc((fsname ? strlen(fsname) : 0) +\n \t\t\t(subtype ? strlen(subtype) : 0) + strlen(dev) + 32);\n \n \ttype = malloc((subtype ? strlen(subtype) : 0) + 32);\n \tif (!type || !source) {\n \t\tfprintf(stderr, \"%s: failed to allocate memory\\n\", progname);\n \t\tgoto err;\n \t}\n \n \tif (subtype)\n \t\tsprintf(type, \"%s.%s\", blkdev ? \"fuseblk\" : \"fuse\", subtype);\n \telse\n \t\tstrcpy(type, blkdev ? \"fuseblk\" : \"fuse\");\n \n \tif (fsname)\n \t\tstrcpy(source, fsname);\n \telse\n \t\tstrcpy(source, subtype ? subtype : dev);\n \n \tres = mount_notrunc(source, mnt, type, flags, optbuf);\n \tif (res == -1 && errno == ENODEV && subtype) {\n \t\tstrcpy(type, blkdev ? \"fuseblk\" : \"fuse\");\n \t\tif (fsname) {\n \t\t\tif (!blkdev)\n \t\t\t\tsprintf(source, \"%s#%s\", subtype, fsname);\n \t\t} else {\n \t\t\tstrcpy(source, type);\n \t\t}\n \n \t\tres = mount_notrunc(source, mnt, type, flags, optbuf);\n \t}\n \tif (res == -1 && errno == EINVAL) {\n \t\tsprintf(d, \"fd=%i,rootmode=%o,user_id=%u\",\n \t\t\tfd, rootmode, getuid());\n \t\tres = mount_notrunc(source, mnt, type, flags, optbuf);\n \t}\n \tif (res == -1) {\n \t\tint errno_save = errno;\n \t\tif (blkdev && errno == ENODEV && !fuse_mnt_check_fuseblk())\n \t\t\tfprintf(stderr, \"%s: 'fuseblk' support missing\\n\",\n \t\t\t\tprogname);\n \t\telse\n \t\t\tfprintf(stderr, \"%s: mount failed: %s\\n\", progname,\n \t\t\t\tstrerror(errno_save));\n \t\tgoto err;\n \t}\n \t*sourcep = source;\n \t*typep = type;\n \t*mnt_optsp = mnt_opts;\n \tfree(fsname);\n \tfree(optbuf);\n \n \treturn 0;\n \n err:\n \tfree(fsname);\n \tfree(subtype);\n \tfree(source);\n \tfree(type);\n \tfree(mnt_opts);\n \tfree(optbuf);\n \treturn -1;\n }\n \n", "target": "// fix_start\n\t\t\t\t} else if (opt_eq(s, len, \"default_permissions\") ||\n\t\t\t\t\t   opt_eq(s, len, \"allow_other\") ||\n\t\t\t\t\t   begins_with(s, \"max_read=\") ||\n\t\t\t\t\t   begins_with(s, \"blksize=\")) {\n// fix_end\n// fix_start\n\t\t\t\t} else {\n\t\t\t\t\tfprintf(stderr, \"%s: unknown option '%.*s'\\n\", progname, len, s);\n\t\t\t\t\texit(1);\n// fix_end\n", "cwe": "CWE-269", "cwe_name": "Improper Privilege Management", "cve": "CVE-2018-10906", "cve_desc": "In fuse before versions 2.9.8 and 3.x before 3.2.5, fusermount is vulnerable to a restriction bypass when SELinux is active. This allows non-root users to mount a FUSE file system with the 'allow_other' mount option regardless of whether 'user_allow_other' is set in the fuse configuration. An attacker may use this flaw to mount a FUSE file system, accessible by other users, and trick them into accessing files on that file system, possibly causing Denial of Service or other unspecified effects.", "project": "libfuse", "idx": 204216}
{"source": " xz_decomp(xz_statep state)\n {\n     int ret;\n     unsigned had;\n     unsigned long crc, len;\n     lzma_stream *strm = &(state->strm);\n \n     lzma_action action = LZMA_RUN;\n \n     had = strm->avail_out;\n     do {\n         if (strm->avail_in == 0 && xz_avail(state) == -1)\n             return -1;\n         if (strm->avail_in == 0) {\n             xz_error(state, LZMA_DATA_ERROR, \"unexpected end of file\");\n             return -1;\n         }\n         if (state->eof)\n             action = LZMA_FINISH;\n \n #ifdef HAVE_ZLIB_H\n         if (state->how == GZIP) {\n             state->zstrm.avail_in = (uInt) state->strm.avail_in;\n             state->zstrm.next_in = (Bytef *) state->strm.next_in;\n             state->zstrm.avail_out = (uInt) state->strm.avail_out;\n             state->zstrm.next_out = (Bytef *) state->strm.next_out;\n             ret = inflate(&state->zstrm, Z_NO_FLUSH);\n             if (ret == Z_STREAM_ERROR || ret == Z_NEED_DICT) {\n                 xz_error(state, Z_STREAM_ERROR,\n                          \"internal error: inflate stream corrupt\");\n                 return -1;\n             }\n             if (ret == Z_MEM_ERROR)\n                 ret = LZMA_MEM_ERROR;\n             if (ret == Z_DATA_ERROR)\n                 ret = LZMA_DATA_ERROR;\n             if (ret == Z_STREAM_END)\n                 ret = LZMA_STREAM_END;\n             state->strm.avail_in = state->zstrm.avail_in;\n             state->strm.next_in = state->zstrm.next_in;\n             state->strm.avail_out = state->zstrm.avail_out;\n             state->strm.next_out = state->zstrm.next_out;\n         } else\n #endif\n             ret = lzma_code(strm, action);\n         if (ret == LZMA_MEM_ERROR) {\n             xz_error(state, LZMA_MEM_ERROR, \"out of memory\");\n             return -1;\n         }\n         if (ret == LZMA_DATA_ERROR) {\n             xz_error(state, LZMA_DATA_ERROR, \"compressed data error\");\n             return -1;\n         }\n// bug_start\n// bug_end\n     } while (strm->avail_out && ret != LZMA_STREAM_END);\n \n     state->have = had - strm->avail_out;\n     state->next = strm->next_out - state->have;\n #ifdef HAVE_ZLIB_H\n     state->zstrm.adler =\n         crc32(state->zstrm.adler, state->next, state->have);\n #endif\n \n     if (ret == LZMA_STREAM_END) {\n #ifdef HAVE_ZLIB_H\n         if (state->how == GZIP) {\n             if (gz_next4(state, &crc) == -1 || gz_next4(state, &len) == -1) {\n                 xz_error(state, LZMA_DATA_ERROR, \"unexpected end of file\");\n                 return -1;\n             }\n             if (crc != state->zstrm.adler) {\n                 xz_error(state, LZMA_DATA_ERROR, \"incorrect data check\");\n                 return -1;\n             }\n             if (len != (state->zstrm.total_out & 0xffffffffL)) {\n                 xz_error(state, LZMA_DATA_ERROR, \"incorrect length check\");\n                 return -1;\n             }\n             state->strm.avail_in = 0;\n             state->strm.next_in = NULL;\n             state->strm.avail_out = 0;\n             state->strm.next_out = NULL;\n         } else\n #endif\n         if (strm->avail_in != 0 || !state->eof) {\n             xz_error(state, LZMA_DATA_ERROR, \"trailing garbage\");\n             return -1;\n         }\n         state->how = LOOK;\n     }\n \n     return 0;\n }\n \n", "target": "// fix_start\n        if (ret == LZMA_PROG_ERROR) {\n            xz_error(state, LZMA_PROG_ERROR, \"compression error\");\n            return -1;\n        }\n// fix_end\n", "cwe": "CWE-399", "cwe_name": "Resource Management Errors", "cve": "CVE-2015-8035", "cve_desc": "The xz_decomp function in xzlib.c in libxml2 2.9.1 does not properly detect compression errors, which allows context-dependent attackers to cause a denial of service (process hang) via crafted XML data.", "project": "libxml2", "idx": 204281}
{"source": " static int selectExpander(Walker *pWalker, Select *p){\n   Parse *pParse = pWalker->pParse;\n   int i, j, k;\n   SrcList *pTabList;\n   ExprList *pEList;\n   struct SrcList_item *pFrom;\n   sqlite3 *db = pParse->db;\n   Expr *pE, *pRight, *pExpr;\n   u16 selFlags = p->selFlags;\n   u32 elistFlags = 0;\n \n   p->selFlags |= SF_Expanded;\n   if( db->mallocFailed  ){\n     return WRC_Abort;\n   }\n   assert( p->pSrc!=0 );\n   if( (selFlags & SF_Expanded)!=0 ){\n     return WRC_Prune;\n   }\n   if( pWalker->eCode ){\n     p->selId = ++pParse->nSelect;\n   }\n   pTabList = p->pSrc;\n   pEList = p->pEList;\n   sqlite3WithPush(pParse, p->pWith, 0);\n \n   sqlite3SrcListAssignCursors(pParse, pTabList);\n \n   for(i=0, pFrom=pTabList->a; i<pTabList->nSrc; i++, pFrom++){\n     Table *pTab;\n     assert( pFrom->fg.isRecursive==0 || pFrom->pTab!=0 );\n     if( pFrom->fg.isRecursive ) continue;\n     assert( pFrom->pTab==0 );\n #ifndef SQLITE_OMIT_CTE\n     if( withExpand(pWalker, pFrom) ) return WRC_Abort;\n     if( pFrom->pTab ) {} else\n #endif\n     if( pFrom->zName==0 ){\n #ifndef SQLITE_OMIT_SUBQUERY\n       Select *pSel = pFrom->pSelect;\n       assert( pSel!=0 );\n       assert( pFrom->pTab==0 );\n       if( sqlite3WalkSelect(pWalker, pSel) ) return WRC_Abort;\n       if( sqlite3ExpandSubquery(pParse, pFrom) ) return WRC_Abort;\n #endif\n     }else{\n       assert( pFrom->pTab==0 );\n       pFrom->pTab = pTab = sqlite3LocateTableItem(pParse, 0, pFrom);\n       if( pTab==0 ) return WRC_Abort;\n       if( pTab->nTabRef>=0xffff ){\n         sqlite3ErrorMsg(pParse, \"too many references to \\\"%s\\\": max 65535\",\n            pTab->zName);\n         pFrom->pTab = 0;\n         return WRC_Abort;\n       }\n       pTab->nTabRef++;\n       if( !IsVirtual(pTab) && cannotBeFunction(pParse, pFrom) ){\n         return WRC_Abort;\n       }\n #if !defined(SQLITE_OMIT_VIEW) || !defined (SQLITE_OMIT_VIRTUALTABLE)\n       if( IsVirtual(pTab) || pTab->pSelect ){\n         i16 nCol;\n         u8 eCodeOrig = pWalker->eCode;\n         if( sqlite3ViewGetColumnNames(pParse, pTab) ) return WRC_Abort;\n         assert( pFrom->pSelect==0 );\n         if( pTab->pSelect && (db->flags & SQLITE_EnableView)==0 ){\n           sqlite3ErrorMsg(pParse, \"access to view \\\"%s\\\" prohibited\",\n               pTab->zName);\n         }\n         pFrom->pSelect = sqlite3SelectDup(db, pTab->pSelect, 0);\n         nCol = pTab->nCol;\n         pTab->nCol = -1;\n         pWalker->eCode = 1;\n         sqlite3WalkSelect(pWalker, pFrom->pSelect);\n         pWalker->eCode = eCodeOrig;\n         pTab->nCol = nCol;\n       }\n #endif\n     }\n \n     if( sqlite3IndexedByLookup(pParse, pFrom) ){\n       return WRC_Abort;\n     }\n   }\n \n// bug_start\n  if( db->mallocFailed || sqliteProcessJoin(pParse, p) ){\n// bug_end\n     return WRC_Abort;\n   }\n \n   for(k=0; k<pEList->nExpr; k++){\n     pE = pEList->a[k].pExpr;\n     if( pE->op==TK_ASTERISK ) break;\n     assert( pE->op!=TK_DOT || pE->pRight!=0 );\n     assert( pE->op!=TK_DOT || (pE->pLeft!=0 && pE->pLeft->op==TK_ID) );\n     if( pE->op==TK_DOT && pE->pRight->op==TK_ASTERISK ) break;\n     elistFlags |= pE->flags;\n   }\n   if( k<pEList->nExpr ){\n     struct ExprList_item *a = pEList->a;\n     ExprList *pNew = 0;\n     int flags = pParse->db->flags;\n     int longNames = (flags & SQLITE_FullColNames)!=0\n                       && (flags & SQLITE_ShortColNames)==0;\n \n     for(k=0; k<pEList->nExpr; k++){\n       pE = a[k].pExpr;\n       elistFlags |= pE->flags;\n       pRight = pE->pRight;\n       assert( pE->op!=TK_DOT || pRight!=0 );\n       if( pE->op!=TK_ASTERISK\n        && (pE->op!=TK_DOT || pRight->op!=TK_ASTERISK)\n       ){\n         pNew = sqlite3ExprListAppend(pParse, pNew, a[k].pExpr);\n         if( pNew ){\n           pNew->a[pNew->nExpr-1].zName = a[k].zName;\n           pNew->a[pNew->nExpr-1].zSpan = a[k].zSpan;\n           a[k].zName = 0;\n           a[k].zSpan = 0;\n         }\n         a[k].pExpr = 0;\n       }else{\n         int tableSeen = 0;\n         char *zTName = 0;\n         if( pE->op==TK_DOT ){\n           assert( pE->pLeft!=0 );\n           assert( !ExprHasProperty(pE->pLeft, EP_IntValue) );\n           zTName = pE->pLeft->u.zToken;\n         }\n         for(i=0, pFrom=pTabList->a; i<pTabList->nSrc; i++, pFrom++){\n           Table *pTab = pFrom->pTab;\n           Select *pSub = pFrom->pSelect;\n           char *zTabName = pFrom->zAlias;\n           const char *zSchemaName = 0;\n           int iDb;\n           if( zTabName==0 ){\n             zTabName = pTab->zName;\n           }\n           if( db->mallocFailed ) break;\n           if( pSub==0 || (pSub->selFlags & SF_NestedFrom)==0 ){\n             pSub = 0;\n             if( zTName && sqlite3StrICmp(zTName, zTabName)!=0 ){\n               continue;\n             }\n             iDb = sqlite3SchemaToIndex(db, pTab->pSchema);\n             zSchemaName = iDb>=0 ? db->aDb[iDb].zDbSName : \"*\";\n           }\n           for(j=0; j<pTab->nCol; j++){\n             char *zName = pTab->aCol[j].zName;\n             char *zColname;\n             char *zToFree;\n             Token sColname;\n \n             assert( zName );\n             if( zTName && pSub\n              && sqlite3MatchSpanName(pSub->pEList->a[j].zSpan, 0, zTName, 0)==0\n             ){\n               continue;\n             }\n \n             if( (p->selFlags & SF_IncludeHidden)==0\n              && IsHiddenColumn(&pTab->aCol[j])\n             ){\n               continue;\n             }\n             tableSeen = 1;\n \n             if( i>0 && zTName==0 ){\n               if( (pFrom->fg.jointype & JT_NATURAL)!=0\n                 && tableAndColumnIndex(pTabList, i, zName, 0, 0)\n               ){\n                 continue;\n               }\n               if( sqlite3IdListIndex(pFrom->pUsing, zName)>=0 ){\n                 continue;\n               }\n             }\n             pRight = sqlite3Expr(db, TK_ID, zName);\n             zColname = zName;\n             zToFree = 0;\n             if( longNames || pTabList->nSrc>1 ){\n               Expr *pLeft;\n               pLeft = sqlite3Expr(db, TK_ID, zTabName);\n               pExpr = sqlite3PExpr(pParse, TK_DOT, pLeft, pRight);\n               if( zSchemaName ){\n                 pLeft = sqlite3Expr(db, TK_ID, zSchemaName);\n                 pExpr = sqlite3PExpr(pParse, TK_DOT, pLeft, pExpr);\n               }\n               if( longNames ){\n                 zColname = sqlite3MPrintf(db, \"%s.%s\", zTabName, zName);\n                 zToFree = zColname;\n               }\n             }else{\n               pExpr = pRight;\n             }\n             pNew = sqlite3ExprListAppend(pParse, pNew, pExpr);\n             sqlite3TokenInit(&sColname, zColname);\n             sqlite3ExprListSetName(pParse, pNew, &sColname, 0);\n             if( pNew && (p->selFlags & SF_NestedFrom)!=0 ){\n               struct ExprList_item *pX = &pNew->a[pNew->nExpr-1];\n               if( pSub ){\n                 pX->zSpan = sqlite3DbStrDup(db, pSub->pEList->a[j].zSpan);\n                 testcase( pX->zSpan==0 );\n               }else{\n                 pX->zSpan = sqlite3MPrintf(db, \"%s.%s.%s\",\n                                            zSchemaName, zTabName, zColname);\n                 testcase( pX->zSpan==0 );\n               }\n               pX->bSpanIsTab = 1;\n             }\n             sqlite3DbFree(db, zToFree);\n           }\n         }\n         if( !tableSeen ){\n           if( zTName ){\n             sqlite3ErrorMsg(pParse, \"no such table: %s\", zTName);\n           }else{\n             sqlite3ErrorMsg(pParse, \"no tables specified\");\n           }\n         }\n       }\n     }\n     sqlite3ExprListDelete(db, pEList);\n     p->pEList = pNew;\n   }\n   if( p->pEList ){\n     if( p->pEList->nExpr>db->aLimit[SQLITE_LIMIT_COLUMN] ){\n       sqlite3ErrorMsg(pParse, \"too many columns in result set\");\n       return WRC_Abort;\n     }\n     if( (elistFlags & (EP_HasFunc|EP_Subquery))!=0 ){\n       p->selFlags |= SF_ComplexResult;\n     }\n   }\n   return WRC_Continue;\n }\n \n", "target": "// fix_start\n  if( pParse->nErr || db->mallocFailed || sqliteProcessJoin(pParse, p) ){\n// fix_end\n", "cwe": "CWE-755", "cwe_name": "Improper Handling of Exceptional Conditions", "cve": "CVE-2019-20218", "cve_desc": "selectExpander in select.c in SQLite 3.30.1 proceeds with WITH stack unwinding even after a parsing error.", "project": "sqlite", "idx": 204285}
{"source": " sudoers_policy_deserialize_info(void *v)\n {\n// bug_start\n// bug_end\n     struct sudoers_open_info *info = v;\n// bug_start\n    char * const *cur;\n// bug_end\n     const char *p, *errstr, *groups = NULL;\n     const char *remhost = NULL;\n// bug_start\n// bug_end\n     int flags = 0;\n     debug_decl(sudoers_policy_deserialize_info, SUDOERS_DEBUG_PLUGIN);\n \n #define MATCHES(s, v)\t\\\n     (strncmp((s), (v), sizeof(v) - 1) == 0)\n \n #define INVALID(v) do {\t\\\n     sudo_warn(U_(\"invalid %.*s set by sudo front-end\"), \\\n \t(int)(sizeof(v) - 2), (v)); \\\n } while (0)\n \n #define CHECK(s, v) do {\t\\\n     if ((s)[sizeof(v) - 1] == '\\0') { \\\n \tINVALID(v); \\\n \tgoto bad; \\\n     } \\\n } while (0)\n \n     if (sudo_gettime_real(&sudo_user.submit_time) == -1) {\n \tsudo_warn(\"%s\", U_(\"unable to get time of day\"));\n \tgoto bad;\n     }\n \n     if (info->plugin_args != NULL) {\n \tfor (cur = info->plugin_args; *cur != NULL; cur++) {\n \t    if (MATCHES(*cur, \"error_recovery=\")) {\n \t\tint val = sudo_strtobool(*cur + sizeof(\"error_recovery=\") - 1);\n \t\tif (val == -1) {\n \t\t    INVALID(\"error_recovery=\");\n \t\t} else {\n \t\t    sudoers_recovery = val;\n \t\t}\n \t\tcontinue;\n \t    }\n \t    if (MATCHES(*cur, \"sudoers_file=\")) {\n \t\tCHECK(*cur, \"sudoers_file=\");\n \t\tsudoers_file = *cur + sizeof(\"sudoers_file=\") - 1;\n \t\tcontinue;\n \t    }\n \t    if (MATCHES(*cur, \"sudoers_uid=\")) {\n \t\tp = *cur + sizeof(\"sudoers_uid=\") - 1;\n \t\tsudoers_uid = (uid_t) sudo_strtoid(p, &errstr);\n \t\tif (errstr != NULL) {\n \t\t    sudo_warnx(U_(\"%s: %s\"), *cur, U_(errstr));\n \t\t    goto bad;\n \t\t}\n \t\tcontinue;\n \t    }\n \t    if (MATCHES(*cur, \"sudoers_gid=\")) {\n \t\tp = *cur + sizeof(\"sudoers_gid=\") - 1;\n \t\tsudoers_gid = (gid_t) sudo_strtoid(p, &errstr);\n \t\tif (errstr != NULL) {\n \t\t    sudo_warnx(U_(\"%s: %s\"), *cur, U_(errstr));\n \t\t    goto bad;\n \t\t}\n \t\tcontinue;\n \t    }\n \t    if (MATCHES(*cur, \"sudoers_mode=\")) {\n \t\tp = *cur + sizeof(\"sudoers_mode=\") - 1;\n \t\tsudoers_mode = sudo_strtomode(p, &errstr);\n \t\tif (errstr != NULL) {\n \t\t    sudo_warnx(U_(\"%s: %s\"), *cur, U_(errstr));\n \t\t    goto bad;\n \t\t}\n \t\tcontinue;\n \t    }\n \t    if (MATCHES(*cur, \"ldap_conf=\")) {\n \t\tCHECK(*cur, \"ldap_conf=\");\n \t\tpath_ldap_conf = *cur + sizeof(\"ldap_conf=\") - 1;\n \t\tcontinue;\n \t    }\n \t    if (MATCHES(*cur, \"ldap_secret=\")) {\n \t\tCHECK(*cur, \"ldap_secret=\");\n \t\tpath_ldap_secret = *cur + sizeof(\"ldap_secret=\") - 1;\n \t\tcontinue;\n \t    }\n \t}\n     }\n \n     user_closefrom = -1;\n     for (cur = info->settings; *cur != NULL; cur++) {\n \tif (MATCHES(*cur, \"closefrom=\")) {\n \t    errno = 0;\n \t    p = *cur + sizeof(\"closefrom=\") - 1;\n \t    user_closefrom = sudo_strtonum(p, 3, INT_MAX, &errstr);\n \t    if (user_closefrom == 0) {\n \t\tsudo_warnx(U_(\"%s: %s\"), *cur, U_(errstr));\n \t\tgoto bad;\n \t    }\n \t    continue;\n \t}\n \tif (MATCHES(*cur, \"cmnd_chroot=\")) {\n \t    CHECK(*cur, \"cmnd_chroot=\");\n \t    user_runchroot = *cur + sizeof(\"cmnd_chroot=\") - 1;\n \t    continue;\n \t}\n \tif (MATCHES(*cur, \"cmnd_cwd=\")) {\n \t    CHECK(*cur, \"cmnd_cwd=\");\n \t    user_runcwd = *cur + sizeof(\"cmnd_cwd=\") - 1;\n \t    continue;\n \t}\n \tif (MATCHES(*cur, \"runas_user=\")) {\n \t    CHECK(*cur, \"runas_user=\");\n \t    sudo_user.runas_user = *cur + sizeof(\"runas_user=\") - 1;\n \t    SET(sudo_user.flags, RUNAS_USER_SPECIFIED);\n \t    continue;\n \t}\n \tif (MATCHES(*cur, \"runas_group=\")) {\n \t    CHECK(*cur, \"runas_group=\");\n \t    sudo_user.runas_group = *cur + sizeof(\"runas_group=\") - 1;\n \t    SET(sudo_user.flags, RUNAS_GROUP_SPECIFIED);\n \t    continue;\n \t}\n \tif (MATCHES(*cur, \"prompt=\")) {\n \t    user_prompt = *cur + sizeof(\"prompt=\") - 1;\n \t    def_passprompt_override = true;\n \t    continue;\n \t}\n \tif (MATCHES(*cur, \"set_home=\")) {\n \t    if (parse_bool(*cur, sizeof(\"set_home\") - 1, &flags,\n \t\tMODE_RESET_HOME) == -1)\n \t\tgoto bad;\n \t    continue;\n \t}\n \tif (MATCHES(*cur, \"preserve_environment=\")) {\n \t    if (parse_bool(*cur, sizeof(\"preserve_environment\") - 1, &flags,\n \t\tMODE_PRESERVE_ENV) == -1)\n \t\tgoto bad;\n \t    continue;\n \t}\n \tif (MATCHES(*cur, \"run_shell=\")) {\n \t    if (parse_bool(*cur, sizeof(\"run_shell\") -1, &flags,\n \t\tMODE_SHELL) == -1)\n \t\tgoto bad;\n \t    continue;\n \t}\n \tif (MATCHES(*cur, \"login_shell=\")) {\n \t    if (parse_bool(*cur, sizeof(\"login_shell\") - 1, &flags,\n \t\tMODE_LOGIN_SHELL) == -1)\n \t\tgoto bad;\n \t    continue;\n \t}\n \tif (MATCHES(*cur, \"implied_shell=\")) {\n \t    if (parse_bool(*cur, sizeof(\"implied_shell\") - 1, &flags,\n \t\tMODE_IMPLIED_SHELL) == -1)\n \t\tgoto bad;\n \t    continue;\n \t}\n \tif (MATCHES(*cur, \"preserve_groups=\")) {\n \t    if (parse_bool(*cur, sizeof(\"preserve_groups\") - 1, &flags,\n \t\tMODE_PRESERVE_GROUPS) == -1)\n \t\tgoto bad;\n \t    continue;\n \t}\n \tif (MATCHES(*cur, \"ignore_ticket=\")) {\n \t    if (parse_bool(*cur, sizeof(\"ignore_ticket\") -1, &flags,\n \t\tMODE_IGNORE_TICKET) == -1)\n \t\tgoto bad;\n \t    continue;\n \t}\n \tif (MATCHES(*cur, \"noninteractive=\")) {\n \t    if (parse_bool(*cur, sizeof(\"noninteractive\") - 1, &flags,\n \t\tMODE_NONINTERACTIVE) == -1)\n \t\tgoto bad;\n \t    continue;\n \t}\n \tif (MATCHES(*cur, \"sudoedit=\")) {\n \t    if (parse_bool(*cur, sizeof(\"sudoedit\") - 1, &flags,\n \t\tMODE_EDIT) == -1)\n \t\tgoto bad;\n \t    continue;\n \t}\n \tif (MATCHES(*cur, \"login_class=\")) {\n \t    CHECK(*cur, \"login_class=\");\n \t    login_class = *cur + sizeof(\"login_class=\") - 1;\n \t    def_use_loginclass = true;\n \t    continue;\n \t}\n #ifdef HAVE_PRIV_SET\n \tif (MATCHES(*cur, \"runas_privs=\")) {\n \t    CHECK(*cur, \"runas_privs=\");\n \t    def_privs = *cur + sizeof(\"runas_privs=\") - 1;\n \t    continue;\n \t}\n \tif (MATCHES(*cur, \"runas_limitprivs=\")) {\n \t    CHECK(*cur, \"runas_limitprivs=\");\n \t    def_limitprivs = *cur + sizeof(\"runas_limitprivs=\") - 1;\n \t    continue;\n \t}\n #endif\n #ifdef HAVE_SELINUX\n \tif (MATCHES(*cur, \"selinux_role=\")) {\n \t    CHECK(*cur, \"selinux_role=\");\n \t    user_role = *cur + sizeof(\"selinux_role=\") - 1;\n \t    continue;\n \t}\n \tif (MATCHES(*cur, \"selinux_type=\")) {\n \t    CHECK(*cur, \"selinux_type=\");\n \t    user_type = *cur + sizeof(\"selinux_type=\") - 1;\n \t    continue;\n \t}\n #endif\n #ifdef HAVE_BSD_AUTH_H\n \tif (MATCHES(*cur, \"bsdauth_type=\")) {\n \t    CHECK(*cur, \"login_style=\");\n \t    login_style = *cur + sizeof(\"bsdauth_type=\") - 1;\n \t    continue;\n \t}\n #endif\n \tif (MATCHES(*cur, \"network_addrs=\")) {\n \t    interfaces_string = *cur + sizeof(\"network_addrs=\") - 1;\n \t    if (!set_interfaces(interfaces_string)) {\n \t\tsudo_warn(\"%s\", U_(\"unable to parse network address list\"));\n \t\tgoto bad;\n \t    }\n \t    continue;\n \t}\n \tif (MATCHES(*cur, \"max_groups=\")) {\n \t    errno = 0;\n \t    p = *cur + sizeof(\"max_groups=\") - 1;\n \t    sudo_user.max_groups = sudo_strtonum(p, 1, INT_MAX, &errstr);\n \t    if (sudo_user.max_groups == 0) {\n \t\tsudo_warnx(U_(\"%s: %s\"), *cur, U_(errstr));\n \t\tgoto bad;\n \t    }\n \t    continue;\n \t}\n \tif (MATCHES(*cur, \"remote_host=\")) {\n \t    CHECK(*cur, \"remote_host=\");\n \t    remhost = *cur + sizeof(\"remote_host=\") - 1;\n \t    continue;\n \t}\n \tif (MATCHES(*cur, \"timeout=\")) {\n \t    p = *cur + sizeof(\"timeout=\") - 1;\n \t    user_timeout = parse_timeout(p);\n \t    if (user_timeout == -1) {\n \t\tif (errno == ERANGE)\n \t\t    sudo_warnx(U_(\"%s: %s\"), p, U_(\"timeout value too large\"));\n \t\telse\n \t\t    sudo_warnx(U_(\"%s: %s\"), p, U_(\"invalid timeout value\"));\n \t\tgoto bad;\n \t    }\n \t    continue;\n \t}\n #ifdef ENABLE_SUDO_PLUGIN_API\n \tif (MATCHES(*cur, \"plugin_dir=\")) {\n \t    CHECK(*cur, \"plugin_dir=\");\n \t    path_plugin_dir = *cur + sizeof(\"plugin_dir=\") - 1;\n \t    continue;\n \t}\n #endif\n// bug_start\n// bug_end\n     }\n \n     user_gid = (gid_t)-1;\n     user_sid = (pid_t)-1;\n     user_uid = (gid_t)-1;\n     user_umask = (mode_t)-1;\n     for (cur = info->user_info; *cur != NULL; cur++) {\n \tif (MATCHES(*cur, \"user=\")) {\n \t    CHECK(*cur, \"user=\");\n \t    if ((user_name = strdup(*cur + sizeof(\"user=\") - 1)) == NULL)\n \t\tgoto oom;\n \t    continue;\n \t}\n \tif (MATCHES(*cur, \"uid=\")) {\n \t    p = *cur + sizeof(\"uid=\") - 1;\n \t    user_uid = (uid_t) sudo_strtoid(p, &errstr);\n \t    if (errstr != NULL) {\n \t\tsudo_warnx(U_(\"%s: %s\"), *cur, U_(errstr));\n \t\tgoto bad;\n \t    }\n \t    continue;\n \t}\n \tif (MATCHES(*cur, \"gid=\")) {\n \t    p = *cur + sizeof(\"gid=\") - 1;\n \t    user_gid = (gid_t) sudo_strtoid(p, &errstr);\n \t    if (errstr != NULL) {\n \t\tsudo_warnx(U_(\"%s: %s\"), *cur, U_(errstr));\n \t\tgoto bad;\n \t    }\n \t    continue;\n \t}\n \tif (MATCHES(*cur, \"groups=\")) {\n \t    CHECK(*cur, \"groups=\");\n \t    groups = *cur + sizeof(\"groups=\") - 1;\n \t    continue;\n \t}\n \tif (MATCHES(*cur, \"cwd=\")) {\n \t    CHECK(*cur, \"cwd=\");\n \t    if ((user_cwd = strdup(*cur + sizeof(\"cwd=\") - 1)) == NULL)\n \t\tgoto oom;\n \t    continue;\n \t}\n \tif (MATCHES(*cur, \"tty=\")) {\n \t    CHECK(*cur, \"tty=\");\n \t    if ((user_ttypath = strdup(*cur + sizeof(\"tty=\") - 1)) == NULL)\n \t\tgoto oom;\n \t    user_tty = user_ttypath;\n \t    if (strncmp(user_tty, _PATH_DEV, sizeof(_PATH_DEV) - 1) == 0)\n \t\tuser_tty += sizeof(_PATH_DEV) - 1;\n \t    continue;\n \t}\n \tif (MATCHES(*cur, \"host=\")) {\n \t    CHECK(*cur, \"host=\");\n \t    if ((user_host = strdup(*cur + sizeof(\"host=\") - 1)) == NULL)\n \t\tgoto oom;\n \t    if ((p = strchr(user_host, '.')) != NULL) {\n \t\tuser_shost = strndup(user_host, (size_t)(p - user_host));\n \t\tif (user_shost == NULL)\n \t\t    goto oom;\n \t    } else {\n \t\tuser_shost = user_host;\n \t    }\n \t    continue;\n \t}\n \tif (MATCHES(*cur, \"lines=\")) {\n \t    errno = 0;\n \t    p = *cur + sizeof(\"lines=\") - 1;\n \t    sudo_user.lines = sudo_strtonum(p, 1, INT_MAX, &errstr);\n \t    if (sudo_user.lines == 0) {\n \t\tsudo_warnx(U_(\"%s: %s\"), *cur, U_(errstr));\n \t\tgoto bad;\n \t    }\n \t    continue;\n \t}\n \tif (MATCHES(*cur, \"cols=\")) {\n \t    errno = 0;\n \t    p = *cur + sizeof(\"cols=\") - 1;\n \t    sudo_user.cols = sudo_strtonum(p, 1, INT_MAX, &errstr);\n \t    if (sudo_user.cols == 0) {\n \t\tsudo_warnx(U_(\"%s: %s\"), *cur, U_(errstr));\n \t\tgoto bad;\n \t    }\n \t    continue;\n \t}\n \tif (MATCHES(*cur, \"sid=\")) {\n \t    p = *cur + sizeof(\"sid=\") - 1;\n \t    user_sid = (pid_t) sudo_strtoid(p, &errstr);\n \t    if (errstr != NULL) {\n \t\tsudo_warnx(U_(\"%s: %s\"), *cur, U_(errstr));\n \t\tgoto bad;\n \t    }\n \t    continue;\n \t}\n \tif (MATCHES(*cur, \"umask=\")) {\n \t    p = *cur + sizeof(\"umask=\") - 1;\n \t    sudo_user.umask = sudo_strtomode(p, &errstr);\n \t    if (errstr != NULL) {\n \t\tsudo_warnx(U_(\"%s: %s\"), *cur, U_(errstr));\n \t\tgoto bad;\n \t    }\n \t    continue;\n \t}\n     }\n \n     if (user_name == NULL) {\n \tsudo_warnx(\"%s\", U_(\"user name not set by sudo front-end\"));\n \tgoto bad;\n     }\n     if (user_uid == (uid_t)-1) {\n \tsudo_warnx(\"%s\", U_(\"user-ID not set by sudo front-end\"));\n \tgoto bad;\n     }\n     if (user_gid == (gid_t)-1) {\n \tsudo_warnx(\"%s\", U_(\"group-ID not set by sudo front-end\"));\n \tgoto bad;\n     }\n     if (user_host == NULL) {\n \tsudo_warnx(\"%s\", U_(\"host name not set by sudo front-end\"));\n \tgoto bad;\n     }\n \n     if ((user_runhost = strdup(remhost ? remhost : user_host)) == NULL)\n \tgoto oom;\n     if ((p = strchr(user_runhost, '.')) != NULL) {\n \tuser_srunhost = strndup(user_runhost, (size_t)(p - user_runhost));\n \tif (user_srunhost == NULL)\n \t    goto oom;\n     } else {\n \tuser_srunhost = user_runhost;\n     }\n     if (user_cwd == NULL) {\n \tif ((user_cwd = strdup(\"unknown\")) == NULL)\n \t    goto oom;\n     }\n     if (user_runcwd == NULL) {\n \tif ((user_runcwd = strdup(user_cwd)) == NULL)\n \t    goto oom;\n     }\n     if (user_tty == NULL) {\n \tif ((user_tty = strdup(\"unknown\")) == NULL)\n \t    goto oom;\n     }\n \n     if (groups != NULL) {\n \tuser_ngids = sudo_parse_gids(groups, &user_gid, &user_gids);\n \tif (user_ngids == -1)\n \t    goto bad;\n     }\n \n     if (user_umask == (mode_t)-1) {\n \tuser_umask = umask(0);\n \tumask(user_umask);\n     }\n \n     if (ISSET(flags, MODE_LOGIN_SHELL))\n \tdef_env_reset = true;\n \n     cmnd_fd = -1;\n \n     for (cur = info->settings; *cur != NULL; cur++)\n \tsudo_debug_printf(SUDO_DEBUG_INFO, \"settings: %s\", *cur);\n     for (cur = info->user_info; *cur != NULL; cur++)\n \tsudo_debug_printf(SUDO_DEBUG_INFO, \"user_info: %s\", *cur);\n \n #undef MATCHES\n #undef INVALID\n #undef CHECK\n     debug_return_int(flags);\n \n oom:\n     sudo_warnx(U_(\"%s: %s\"), __func__, U_(\"unable to allocate memory\"));\n bad:\n     debug_return_int(MODE_ERROR);\n }\n \n", "target": "// fix_start\n    const int edit_mask = MODE_EDIT|MODE_IGNORE_TICKET|MODE_NONINTERACTIVE;\n// fix_end\n// fix_start\n// fix_end\n// fix_start\n    char * const *cur;\n// fix_end\n// fix_start\n    }\n\n    if (ISSET(flags, MODE_EDIT) && (flags & edit_mask) != flags) {\n\tsudo_warnx(U_(\"invalid mode flags from sudo front end: 0x%x\"), flags);\n\tgoto bad;\n// fix_end\n", "cwe": "CWE-193", "cwe_name": "Off-by-one Error", "cve": "CVE-2021-3156", "cve_desc": "Sudo before 1.9.5p2 contains an off-by-one error that can result in a heap-based buffer overflow, which allows privilege escalation to root via \"sudoedit -s\" and a command-line argument that ends with a single backslash character.", "project": "sudo", "idx": 204323}
{"source": " int imap_open_connection(struct ImapAccountData *adata)\n {\n   if (mutt_socket_open(adata->conn) < 0)\n     return -1;\n \n   adata->state = IMAP_CONNECTED;\n \n   if (imap_cmd_step(adata) != IMAP_RES_OK)\n   {\n     imap_close_connection(adata);\n     return -1;\n   }\n \n   if (mutt_istr_startswith(adata->buf, \"* OK\"))\n   {\n     if (!mutt_istr_startswith(adata->buf, \"* OK [CAPABILITY\") && check_capabilities(adata))\n     {\n       goto bail;\n     }\n #ifdef USE_SSL\n     if ((adata->conn->ssf == 0) && (C_SslForceTls || (adata->capabilities & IMAP_CAP_STARTTLS)))\n     {\n       enum QuadOption ans;\n \n       if (C_SslForceTls)\n         ans = MUTT_YES;\n       else if ((ans = query_quadoption(C_SslStarttls,\n                                        _(\"Secure connection with TLS?\"))) == MUTT_ABORT)\n       {\n// bug_start\n        goto err_close_conn;\n// bug_end\n       }\n       if (ans == MUTT_YES)\n       {\n         enum ImapExecResult rc = imap_exec(adata, \"STARTTLS\", IMAP_CMD_SINGLE);\n         mutt_socket_empty(adata->conn);\n \n         if (rc == IMAP_EXEC_FATAL)\n           goto bail;\n         if (rc != IMAP_EXEC_ERROR)\n         {\n           if (mutt_ssl_starttls(adata->conn))\n           {\n             mutt_error(_(\"Could not negotiate TLS connection\"));\n// bug_start\n            goto err_close_conn;\n// bug_end\n           }\n           else\n           {\n             if (imap_exec(adata, \"CAPABILITY\", IMAP_CMD_NO_FLAGS))\n               goto bail;\n           }\n         }\n       }\n     }\n \n     if (C_SslForceTls && (adata->conn->ssf == 0))\n     {\n       mutt_error(_(\"Encrypted connection unavailable\"));\n// bug_start\n      goto err_close_conn;\n// bug_end\n     }\n #endif\n   }\n   else if (mutt_istr_startswith(adata->buf, \"* PREAUTH\"))\n   {\n #ifdef USE_SSL\n     if ((adata->conn->ssf == 0) && C_SslForceTls)\n     {\n       mutt_error(_(\"Encrypted connection unavailable\"));\n// bug_start\n      goto err_close_conn;\n// bug_end\n     }\n #endif\n \n     adata->state = IMAP_AUTHENTICATED;\n     if (check_capabilities(adata) != 0)\n       goto bail;\n     FREE(&adata->capstr);\n   }\n   else\n   {\n     imap_error(\"imap_open_connection()\", adata->buf);\n     goto bail;\n   }\n \n   return 0;\n \n// bug_start\n#ifdef USE_SSL\nerr_close_conn:\n// bug_end\n   imap_close_connection(adata);\n// bug_start\n#endif\nbail:\n// bug_end\n   FREE(&adata->capstr);\n   return -1;\n }\n \n", "target": "// fix_start\n        goto bail;\n// fix_end\n// fix_start\n            goto bail;\n// fix_end\n// fix_start\n      goto bail;\n// fix_end\n// fix_start\n      goto bail;\n// fix_end\n// fix_start\nbail:\n// fix_end\n// fix_start\n// fix_end\n", "cwe": "CWE-522", "cwe_name": "Insufficiently Protected Credentials", "cve": "CVE-2020-28896", "cve_desc": "Mutt before 2.0.2 and NeoMutt before 2020-11-20 did not ensure that $ssl_force_tls was processed if an IMAP server's initial server response was invalid. The connection was not properly closed, and the code could continue attempting to authenticate. This could result in authentication credentials being exposed on an unencrypted connection, or to a machine-in-the-middle.", "project": "neomutt", "idx": 204337}
{"source": " static OPJ_BOOL opj_j2k_write_sod(opj_j2k_t *p_j2k,\n                                   opj_tcd_t * p_tile_coder,\n                                   OPJ_BYTE * p_data,\n                                   OPJ_UINT32 * p_data_written,\n                                   OPJ_UINT32 total_data_size,\n                                   const opj_stream_private_t *p_stream,\n                                   opj_event_mgr_t * p_manager\n                                  )\n {\n     opj_codestream_info_t *l_cstr_info = 00;\n     OPJ_UINT32 l_remaining_data;\n     opj_tcd_marker_info_t* marker_info = NULL;\n \n     assert(p_j2k != 00);\n     assert(p_manager != 00);\n     assert(p_stream != 00);\n \n     OPJ_UNUSED(p_stream);\n \n     if (total_data_size < 4) {\n         opj_event_msg(p_manager, EVT_ERROR,\n                       \"Not enough bytes in output buffer to write SOD marker\\n\");\n         return OPJ_FALSE;\n     }\n \n     opj_write_bytes(p_data, J2K_MS_SOD,\n                     2);\n \n     l_remaining_data =  total_data_size - 4;\n \n     p_tile_coder->tp_num =\n         p_j2k->m_specific_param.m_encoder.m_current_poc_tile_part_number ;\n     p_tile_coder->cur_tp_num =\n         p_j2k->m_specific_param.m_encoder.m_current_tile_part_number;\n \n #ifdef USE_JPWL\n     assert(0 && \"TODO\");\n #endif\n \n     if (p_j2k->m_specific_param.m_encoder.m_current_tile_part_number == 0) {\n         p_tile_coder->tcd_image->tiles->packno = 0;\n #ifdef deadcode\n         if (l_cstr_info) {\n             l_cstr_info->packno = 0;\n         }\n #endif\n     }\n \n     *p_data_written = 0;\n \n     if (p_j2k->m_specific_param.m_encoder.m_PLT) {\n         marker_info = opj_tcd_marker_info_create(\n                           p_j2k->m_specific_param.m_encoder.m_PLT);\n         if (marker_info == NULL) {\n             opj_event_msg(p_manager, EVT_ERROR,\n                           \"Cannot encode tile: opj_tcd_marker_info_create() failed\\n\");\n             return OPJ_FALSE;\n         }\n     }\n \n// bug_start\n    assert(l_remaining_data >\n           p_j2k->m_specific_param.m_encoder.m_reserved_bytes_for_PLT);\n// bug_end\n     l_remaining_data -= p_j2k->m_specific_param.m_encoder.m_reserved_bytes_for_PLT;\n \n     if (! opj_tcd_encode_tile(p_tile_coder, p_j2k->m_current_tile_number,\n                               p_data + 2,\n                               p_data_written, l_remaining_data, l_cstr_info,\n                               marker_info,\n                               p_manager)) {\n         opj_event_msg(p_manager, EVT_ERROR, \"Cannot encode tile\\n\");\n         opj_tcd_marker_info_destroy(marker_info);\n         return OPJ_FALSE;\n     }\n \n     *p_data_written += 2;\n \n     if (p_j2k->m_specific_param.m_encoder.m_PLT) {\n         OPJ_UINT32 l_data_written_PLT = 0;\n         OPJ_BYTE* p_PLT_buffer = (OPJ_BYTE*)opj_malloc(\n                                      p_j2k->m_specific_param.m_encoder.m_reserved_bytes_for_PLT);\n         if (!p_PLT_buffer) {\n             opj_event_msg(p_manager, EVT_ERROR, \"Cannot allocate memory\\n\");\n             opj_tcd_marker_info_destroy(marker_info);\n             return OPJ_FALSE;\n         }\n         if (!opj_j2k_write_plt_in_memory(p_j2k,\n                                          marker_info,\n                                          p_PLT_buffer,\n                                          &l_data_written_PLT,\n                                          p_manager)) {\n             opj_tcd_marker_info_destroy(marker_info);\n             opj_free(p_PLT_buffer);\n             return OPJ_FALSE;\n         }\n \n         assert(l_data_written_PLT <=\n                p_j2k->m_specific_param.m_encoder.m_reserved_bytes_for_PLT);\n \n         memmove(p_data + l_data_written_PLT, p_data, *p_data_written);\n         memcpy(p_data, p_PLT_buffer, l_data_written_PLT);\n         opj_free(p_PLT_buffer);\n         *p_data_written += l_data_written_PLT;\n     }\n \n     opj_tcd_marker_info_destroy(marker_info);\n \n     return OPJ_TRUE;\n }\n \n", "target": "// fix_start\n    if (l_remaining_data <\n            p_j2k->m_specific_param.m_encoder.m_reserved_bytes_for_PLT) {\n        opj_event_msg(p_manager, EVT_ERROR,\n                      \"Not enough bytes in output buffer to write SOD marker\\n\");\n        opj_tcd_marker_info_destroy(marker_info);\n        return OPJ_FALSE;\n    }\n// fix_end\n", "cwe": "CWE-20", "cwe_name": "Improper Input Validation", "cve": "CVE-2020-27844", "cve_desc": "A flaw was found in openjpeg's src/lib/openjp2/t2.c in versions prior to 2.4.0. This flaw allows an attacker to provide crafted input to openjpeg during conversion and encoding, causing an out-of-bounds write. The highest threat from this vulnerability is to confidentiality, integrity, as well as system availability.", "project": "openjpeg", "idx": 204345}
{"source": " p11_rpc_buffer_get_attribute (p11_buffer *buffer,\n \t\t\t      size_t *offset,\n \t\t\t      CK_ATTRIBUTE *attr)\n {\n// bug_start\n\tuint32_t type, length;\n// bug_end\n \tunsigned char validity;\n \tp11_rpc_attribute_serializer *serializer;\n \tp11_rpc_value_type value_type;\n \n \tif (!p11_rpc_buffer_get_uint32 (buffer, offset, &type))\n \t\treturn false;\n \n \tif (!p11_rpc_buffer_get_byte (buffer, offset, &validity))\n \t\treturn false;\n \n \tif (!validity) {\n \t\tattr->ulValueLen = ((CK_ULONG)-1);\n \t\tattr->type = type;\n \t\treturn true;\n \t}\n \n \tif (!p11_rpc_buffer_get_uint32 (buffer, offset, &length))\n \t\treturn false;\n \n \tvalue_type = map_attribute_to_value_type (type);\n \tassert (value_type < ELEMS (p11_rpc_attribute_serializers));\n \tserializer = &p11_rpc_attribute_serializers[value_type];\n \tassert (serializer != NULL);\n \tif (!serializer->decode (buffer, offset, attr->pValue, &attr->ulValueLen))\n \t\treturn false;\n// bug_start\n\tif (!attr->pValue)\n// bug_end\n \t\tattr->ulValueLen = length;\n// bug_start\n// bug_end\n \tattr->type = type;\n \treturn true;\n }\n \n", "target": "// fix_start\n\tuint32_t type, length, decode_length;\n// fix_end\n// fix_start\n\tif (!attr->pValue) {\n\t\tdecode_length = attr->ulValueLen;\n// fix_end\n// fix_start\n\t\tif (decode_length > length) {\n\t\t\treturn false;\n\t\t}\n\t}\n// fix_end\n", "cwe": "CWE-787", "cwe_name": "Out-of-bounds Write", "cve": "CVE-2020-29363", "cve_desc": "An issue was discovered in p11-kit 0.23.6 through 0.23.21. A heap-based buffer overflow has been discovered in the RPC protocol used by p11-kit server/remote commands and the client library. When the remote entity supplies a serialized byte array in a CK_ATTRIBUTE, the receiving entity may not allocate sufficient length for the buffer to store the deserialized value.", "project": "p11-kit", "idx": 204380}
{"source": " static OPJ_BOOL opj_tcd_code_block_enc_allocate_data(opj_tcd_cblk_enc_t *\n         p_code_block)\n {\n     OPJ_UINT32 l_data_size;\n \n// bug_start\n    l_data_size = 26 + (OPJ_UINT32)((p_code_block->x1 - p_code_block->x0) *\n// bug_end\n                                    (p_code_block->y1 - p_code_block->y0) * (OPJ_INT32)sizeof(OPJ_UINT32));\n \n     if (l_data_size > p_code_block->data_size) {\n         if (p_code_block->data) {\n             opj_free(p_code_block->data - 1);\n         }\n         p_code_block->data = (OPJ_BYTE*) opj_malloc(l_data_size + 1);\n         if (! p_code_block->data) {\n             p_code_block->data_size = 0U;\n             return OPJ_FALSE;\n         }\n         p_code_block->data_size = l_data_size;\n \n         p_code_block->data[0] = 0;\n         p_code_block->data += 1;\n     }\n     return OPJ_TRUE;\n }\n \n", "target": "// fix_start\n    l_data_size = 28 + (OPJ_UINT32)((p_code_block->x1 - p_code_block->x0) *\n// fix_end\n", "cwe": "CWE-122", "cwe_name": "Heap-based Buffer Overflow", "cve": "CVE-2020-27814", "cve_desc": "A heap-buffer overflow was found in the way openjpeg2 handled certain PNG format files. An attacker could use this flaw to cause an application crash or in some cases execute arbitrary code with the permission of the user running such an application.", "project": "openjpeg", "idx": 204411}
{"source": " static int shm_create(XShmSegmentInfo *shm, XImage **ximg_ptr, int w, int h,\n     char *name) {\n \n \tXImage *xim;\n \tstatic int reported_flip = 0;\n \tint db = 0;\n \n \tshm->shmid = -1;\n \tshm->shmaddr = (char *) -1;\n \t*ximg_ptr = NULL;\n \n \tif (nofb) {\n \t\treturn 1;\n \t}\n \n \tX_LOCK;\n \n \tif (! using_shm || xform24to32 || raw_fb) {\n \t\txim = XCreateImage_wr(dpy, default_visual, depth, ZPixmap,\n \t\t    0, NULL, w, h, raw_fb ? 32 : BitmapPad(dpy), 0);\n \n \t\tX_UNLOCK;\n \n \t\tif (xim == NULL) {\n \t\t\trfbErr(\"XCreateImage(%s) failed.\\n\", name);\n \t\t\tif (quiet) {\n \t\t\t\tfprintf(stderr, \"XCreateImage(%s) failed.\\n\",\n \t\t\t\t    name);\n \t\t\t}\n \t\t\treturn 0;\n \t\t}\n \t\tif (db) fprintf(stderr, \"shm_create simple %d %d\\t%p %s\\n\", w, h, (void *)xim, name);\n \t\txim->data = (char *) malloc(xim->bytes_per_line * xim->height);\n \t\tif (xim->data == NULL) {\n \t\t\trfbErr(\"XCreateImage(%s) data malloc failed.\\n\", name);\n \t\t\tif (quiet) {\n \t\t\t\tfprintf(stderr, \"XCreateImage(%s) data malloc\"\n \t\t\t\t    \" failed.\\n\", name);\n \t\t\t}\n \t\t\treturn 0;\n \t\t}\n \t\tif (flip_byte_order) {\n \t\t\tchar *order = flip_ximage_byte_order(xim);\n \t\t\tif (! reported_flip && ! quiet) {\n \t\t\t\trfbLog(\"Changing XImage byte order\"\n \t\t\t\t    \" to %s\\n\", order);\n \t\t\t\treported_flip = 1;\n \t\t\t}\n \t\t}\n \n \t\t*ximg_ptr = xim;\n \t\treturn 1;\n \t}\n \n \tif (! dpy) {\n \t\tX_UNLOCK;\n \t\treturn 0;\n \t}\n \n \txim = XShmCreateImage_wr(dpy, default_visual, depth, ZPixmap, NULL,\n \t    shm, w, h);\n \n \tif (xim == NULL) {\n \t\trfbErr(\"XShmCreateImage(%s) failed.\\n\", name);\n \t\tif (quiet) {\n \t\t\tfprintf(stderr, \"XShmCreateImage(%s) failed.\\n\", name);\n \t\t}\n \t\tX_UNLOCK;\n \t\treturn 0;\n \t}\n \n \t*ximg_ptr = xim;\n \n #if HAVE_XSHM\n \tshm->shmid = shmget(IPC_PRIVATE,\n// bug_start\n\t    xim->bytes_per_line * xim->height, IPC_CREAT | 0777);\n// bug_end\n \n \tif (shm->shmid == -1) {\n \t\trfbErr(\"shmget(%s) failed.\\n\", name);\n \t\trfbLogPerror(\"shmget\");\n \n \t\tXDestroyImage(xim);\n \t\t*ximg_ptr = NULL;\n \n \t\tX_UNLOCK;\n \t\treturn 0;\n \t}\n \n \tshm->shmaddr = xim->data = (char *) shmat(shm->shmid, 0, 0);\n \n \tif (shm->shmaddr == (char *)-1) {\n \t\trfbErr(\"shmat(%s) failed.\\n\", name);\n \t\trfbLogPerror(\"shmat\");\n \n \t\tXDestroyImage(xim);\n \t\t*ximg_ptr = NULL;\n \n \t\tshmctl(shm->shmid, IPC_RMID, 0);\n \t\tshm->shmid = -1;\n \n \t\tX_UNLOCK;\n \t\treturn 0;\n \t}\n \n \tshm->readOnly = False;\n \n \tif (! XShmAttach_wr(dpy, shm)) {\n \t\trfbErr(\"XShmAttach(%s) failed.\\n\", name);\n \t\tXDestroyImage(xim);\n \t\t*ximg_ptr = NULL;\n \n \t\tshmdt(shm->shmaddr);\n \t\tshm->shmaddr = (char *) -1;\n \n \t\tshmctl(shm->shmid, IPC_RMID, 0);\n \t\tshm->shmid = -1;\n \n \t\tX_UNLOCK;\n \t\treturn 0;\n \t}\n #endif\n \n \tX_UNLOCK;\n \treturn 1;\n }\n \n", "target": "// fix_start\n\t    xim->bytes_per_line * xim->height, IPC_CREAT | 0600);\n// fix_end\n", "cwe": "CWE-284", "cwe_name": "Improper Access Control", "cve": "CVE-2020-29074", "cve_desc": "scan.c in x11vnc 0.9.16 uses IPC_CREAT|0777 in shmget calls, which allows access by actors other than the current user.", "project": "x11vnc", "idx": 204491}
{"source": " void stralgoLCS(client *c) {\n     uint32_t i, j;\n     long long minmatchlen = 0;\n     sds a = NULL, b = NULL;\n     int getlen = 0, getidx = 0, withmatchlen = 0;\n     robj *obja = NULL, *objb = NULL;\n \n     for (j = 2; j < (uint32_t)c->argc; j++) {\n         char *opt = c->argv[j]->ptr;\n         int moreargs = (c->argc-1) - j;\n \n         if (!strcasecmp(opt,\"IDX\")) {\n             getidx = 1;\n         } else if (!strcasecmp(opt,\"LEN\")) {\n             getlen = 1;\n         } else if (!strcasecmp(opt,\"WITHMATCHLEN\")) {\n             withmatchlen = 1;\n         } else if (!strcasecmp(opt,\"MINMATCHLEN\") && moreargs) {\n             if (getLongLongFromObjectOrReply(c,c->argv[j+1],&minmatchlen,NULL)\n                 != C_OK) goto cleanup;\n             if (minmatchlen < 0) minmatchlen = 0;\n             j++;\n         } else if (!strcasecmp(opt,\"STRINGS\") && moreargs > 1) {\n             if (a != NULL) {\n                 addReplyError(c,\"Either use STRINGS or KEYS\");\n                 goto cleanup;\n             }\n             a = c->argv[j+1]->ptr;\n             b = c->argv[j+2]->ptr;\n             j += 2;\n         } else if (!strcasecmp(opt,\"KEYS\") && moreargs > 1) {\n             if (a != NULL) {\n                 addReplyError(c,\"Either use STRINGS or KEYS\");\n                 goto cleanup;\n             }\n             obja = lookupKeyRead(c->db,c->argv[j+1]);\n             objb = lookupKeyRead(c->db,c->argv[j+2]);\n             if ((obja && obja->type != OBJ_STRING) ||\n                 (objb && objb->type != OBJ_STRING))\n             {\n                 addReplyError(c,\n                     \"The specified keys must contain string values\");\n                 obja = NULL;\n                 objb = NULL;\n                 goto cleanup;\n             }\n             obja = obja ? getDecodedObject(obja) : createStringObject(\"\",0);\n             objb = objb ? getDecodedObject(objb) : createStringObject(\"\",0);\n             a = obja->ptr;\n             b = objb->ptr;\n             j += 2;\n         } else {\n             addReply(c,shared.syntaxerr);\n             goto cleanup;\n         }\n     }\n \n     if (a == NULL) {\n         addReplyError(c,\"Please specify two strings: \"\n                         \"STRINGS or KEYS options are mandatory\");\n         goto cleanup;\n     } else if (getlen && getidx) {\n         addReplyError(c,\n             \"If you want both the length and indexes, please \"\n             \"just use IDX.\");\n         goto cleanup;\n     }\n \n     uint32_t alen = sdslen(a);\n     uint32_t blen = sdslen(b);\n \n// bug_start\n    uint32_t *lcs = zmalloc((alen+1)*(blen+1)*sizeof(uint32_t));\n// bug_end\n     #define LCS(A,B) lcs[(B)+((A)*(blen+1))]\n \n     for (uint32_t i = 0; i <= alen; i++) {\n         for (uint32_t j = 0; j <= blen; j++) {\n             if (i == 0 || j == 0) {\n                 LCS(i,j) = 0;\n             } else if (a[i-1] == b[j-1]) {\n                 LCS(i,j) = LCS(i-1,j-1)+1;\n             } else {\n                 uint32_t lcs1 = LCS(i-1,j);\n                 uint32_t lcs2 = LCS(i,j-1);\n                 LCS(i,j) = lcs1 > lcs2 ? lcs1 : lcs2;\n             }\n         }\n     }\n \n     uint32_t idx = LCS(alen,blen);\n     sds result = NULL;\n     void *arraylenptr = NULL;\n     uint32_t arange_start = alen,\n              arange_end = 0,\n              brange_start = 0,\n              brange_end = 0;\n \n     int computelcs = getidx || !getlen;\n     if (computelcs) result = sdsnewlen(SDS_NOINIT,idx);\n \n     uint32_t arraylen = 0;\n     if (getidx) {\n         addReplyMapLen(c,2);\n         addReplyBulkCString(c,\"matches\");\n         arraylenptr = addReplyDeferredLen(c);\n     }\n \n     i = alen, j = blen;\n     while (computelcs && i > 0 && j > 0) {\n         int emit_range = 0;\n         if (a[i-1] == b[j-1]) {\n             result[idx-1] = a[i-1];\n \n             if (arange_start == alen) {\n                 arange_start = i-1;\n                 arange_end = i-1;\n                 brange_start = j-1;\n                 brange_end = j-1;\n             } else {\n                 if (arange_start == i && brange_start == j) {\n                     arange_start--;\n                     brange_start--;\n                 } else {\n                     emit_range = 1;\n                 }\n             }\n             if (arange_start == 0 || brange_start == 0) emit_range = 1;\n             idx--; i--; j--;\n         } else {\n             uint32_t lcs1 = LCS(i-1,j);\n             uint32_t lcs2 = LCS(i,j-1);\n             if (lcs1 > lcs2)\n                 i--;\n             else\n                 j--;\n             if (arange_start != alen) emit_range = 1;\n         }\n \n         uint32_t match_len = arange_end - arange_start + 1;\n         if (emit_range) {\n             if (minmatchlen == 0 || match_len >= minmatchlen) {\n                 if (arraylenptr) {\n                     addReplyArrayLen(c,2+withmatchlen);\n                     addReplyArrayLen(c,2);\n                     addReplyLongLong(c,arange_start);\n                     addReplyLongLong(c,arange_end);\n                     addReplyArrayLen(c,2);\n                     addReplyLongLong(c,brange_start);\n                     addReplyLongLong(c,brange_end);\n                     if (withmatchlen) addReplyLongLong(c,match_len);\n                     arraylen++;\n                 }\n             }\n             arange_start = alen;\n         }\n     }\n \n \n     if (arraylenptr) {\n         addReplyBulkCString(c,\"len\");\n         addReplyLongLong(c,LCS(alen,blen));\n         setDeferredArrayLen(c,arraylenptr,arraylen);\n     } else if (getlen) {\n         addReplyLongLong(c,LCS(alen,blen));\n     } else {\n         addReplyBulkSds(c,result);\n         result = NULL;\n     }\n \n     sdsfree(result);\n     zfree(lcs);\n \n cleanup:\n     if (obja) decrRefCount(obja);\n     if (objb) decrRefCount(objb);\n     return;\n }\n \n", "target": "// fix_start\n    uint32_t *lcs = zmalloc((size_t)(alen+1)*(blen+1)*sizeof(uint32_t));\n// fix_end\n", "cwe": "CWE-190", "cwe_name": "Integer Overflow or Wraparound", "cve": "CVE-2021-29477", "cve_desc": "Redis is an open source (BSD licensed), in-memory data structure store, used as a database, cache, and message broker. An integer overflow bug in Redis version 6.0 or newer could be exploited using the `STRALGO LCS` command to corrupt the heap and potentially result with remote code execution. The problem is fixed in version 6.2.3 and 6.0.13. An additional workaround to mitigate the problem without patching the redis-server executable is to use ACL configuration to prevent clients from using the `STRALGO LCS` command.", "project": "redis", "idx": 204533}
{"source": " rleUncompress (int inLength, int maxLength, const signed char in[], char out[])\n {\n     char *outStart = out;\n \n     while (inLength > 0)\n     {\n \tif (*in < 0)\n \t{\n \t    int count = -((int)*in++);\n \t    inLength -= count + 1;\n \n \t    if (0 > (maxLength -= count))\n \t\treturn 0;\n \n         if (inLength < 0)\n           return 0;\n \n         memcpy(out, in, count);\n         out += count;\n         in  += count;\n \t}\n \telse\n \t{\n \t    int count = *in++;\n \t    inLength -= 2;\n \n \t    if (0 > (maxLength -= count + 1))\n \t\treturn 0;\n \n// bug_start\n// bug_end\n         memset(out, *(char*)in, count+1);\n         out += count+1;\n \n \t    in++;\n \t}\n     }\n \n     return out - outStart;\n }\n \n", "target": "// fix_start\n        if (inLength < 0)\n          return 0;\n\n// fix_end\n", "cwe": "CWE-119", "cwe_name": "Improper Restriction of Operations within the Bounds of a Memory Buffer", "cve": "CVE-2021-3605", "cve_desc": "There's a flaw in OpenEXR's rleUncompress functionality in versions prior to 3.0.5. An attacker who is able to submit a crafted file to an application linked with OpenEXR could cause an out-of-bounds read. The greatest risk from this flaw is to application availability.", "project": "openexr", "idx": 204639}
{"source": " static int xdp_umem_reg(struct xdp_umem *umem, struct xdp_umem_reg *mr)\n {\n \tbool unaligned_chunks = mr->flags & XDP_UMEM_UNALIGNED_CHUNK_FLAG;\n \tu32 chunk_size = mr->chunk_size, headroom = mr->headroom;\n \tunsigned int chunks, chunks_per_page;\n \tu64 addr = mr->addr, size = mr->len;\n// bug_start\n\tint size_chk, err;\n// bug_end\n \n \tif (chunk_size < XDP_UMEM_MIN_CHUNK_SIZE || chunk_size > PAGE_SIZE) {\n \t\treturn -EINVAL;\n \t}\n \n \tif (mr->flags & ~(XDP_UMEM_UNALIGNED_CHUNK_FLAG |\n \t\t\tXDP_UMEM_USES_NEED_WAKEUP))\n \t\treturn -EINVAL;\n \n \tif (!unaligned_chunks && !is_power_of_2(chunk_size))\n \t\treturn -EINVAL;\n \n \tif (!PAGE_ALIGNED(addr)) {\n \t\treturn -EINVAL;\n \t}\n \n \tif ((addr + size) < addr)\n \t\treturn -EINVAL;\n \n \tchunks = (unsigned int)div_u64(size, chunk_size);\n \tif (chunks == 0)\n \t\treturn -EINVAL;\n \n \tif (!unaligned_chunks) {\n \t\tchunks_per_page = PAGE_SIZE / chunk_size;\n \t\tif (chunks < chunks_per_page || chunks % chunks_per_page)\n \t\t\treturn -EINVAL;\n \t}\n \n// bug_start\n\tsize_chk = chunk_size - headroom - XDP_PACKET_HEADROOM;\n\tif (size_chk < 0)\n// bug_end\n \t\treturn -EINVAL;\n \n \tumem->address = (unsigned long)addr;\n \tumem->chunk_mask = unaligned_chunks ? XSK_UNALIGNED_BUF_ADDR_MASK\n \t\t\t\t\t    : ~((u64)chunk_size - 1);\n \tumem->size = size;\n \tumem->headroom = headroom;\n \tumem->chunk_size_nohr = chunk_size - headroom;\n \tumem->npgs = size / PAGE_SIZE;\n \tumem->pgs = NULL;\n \tumem->user = NULL;\n \tumem->flags = mr->flags;\n \tINIT_LIST_HEAD(&umem->xsk_list);\n \tspin_lock_init(&umem->xsk_list_lock);\n \n \trefcount_set(&umem->users, 1);\n \n \terr = xdp_umem_account_pages(umem);\n \tif (err)\n \t\treturn err;\n \n \terr = xdp_umem_pin_pages(umem);\n \tif (err)\n \t\tgoto out_account;\n \n \tumem->pages = kvcalloc(umem->npgs, sizeof(*umem->pages),\n \t\t\t       GFP_KERNEL_ACCOUNT);\n \tif (!umem->pages) {\n \t\terr = -ENOMEM;\n \t\tgoto out_pin;\n \t}\n \n \terr = xdp_umem_map_pages(umem);\n \tif (!err)\n \t\treturn 0;\n \n \tkvfree(umem->pages);\n \n out_pin:\n \txdp_umem_unpin_pages(umem);\n out_account:\n \txdp_umem_unaccount_pages(umem);\n \treturn err;\n }\n \n", "target": "// fix_start\n\tint err;\n// fix_end\n// fix_start\n\tif (headroom >= chunk_size - XDP_PACKET_HEADROOM)\n// fix_end\n", "cwe": "CWE-416", "cwe_name": "Use After Free", "cve": "CVE-2020-12659", "cve_desc": "An issue was discovered in the Linux kernel before 5.6.7. xdp_umem_reg in net/xdp/xdp_umem.c has an out-of-bounds write (by a user with the CAP_NET_ADMIN capability) because of a lack of headroom validation.", "project": "linux", "idx": 204723}
{"source": " void __split_huge_pmd(struct vm_area_struct *vma, pmd_t *pmd,\n \t\tunsigned long address, bool freeze, struct page *page)\n {\n \tspinlock_t *ptl;\n \tstruct mmu_notifier_range range;\n// bug_start\n// bug_end\n \n \tmmu_notifier_range_init(&range, MMU_NOTIFY_CLEAR, 0, vma, vma->vm_mm,\n \t\t\t\taddress & HPAGE_PMD_MASK,\n \t\t\t\t(address & HPAGE_PMD_MASK) + HPAGE_PMD_SIZE);\n \tmmu_notifier_invalidate_range_start(&range);\n \tptl = pmd_lock(vma->vm_mm, pmd);\n \n \tVM_BUG_ON(freeze && !page);\n// bug_start\n\tif (page && page != pmd_page(*pmd))\n\t        goto out;\n// bug_end\n \n// bug_start\n// bug_end\n \tif (pmd_trans_huge(*pmd)) {\n// bug_start\n\t\tpage = pmd_page(*pmd);\n// bug_end\n \t\tif (PageMlocked(page))\n \t\t\tclear_page_mlock(page);\n \t} else if (!(pmd_devmap(*pmd) || is_pmd_migration_entry(*pmd)))\n \t\tgoto out;\n \t__split_huge_pmd_locked(vma, pmd, range.start, freeze);\n out:\n \tspin_unlock(ptl);\n// bug_start\n// bug_end\n \tmmu_notifier_invalidate_range_only_end(&range);\n }\n \n", "target": "// fix_start\n\tbool was_locked = false;\n\tpmd_t _pmd;\n// fix_end\n// fix_start\n\tif (page) {\n\t\tVM_WARN_ON_ONCE(!PageLocked(page));\n\t\twas_locked = true;\n\t\tif (page != pmd_page(*pmd))\n\t\t\tgoto out;\n\t}\n// fix_end\n// fix_start\nrepeat:\n// fix_end\n// fix_start\n\t\tif (!page) {\n\t\t\tpage = pmd_page(*pmd);\n\t\t\tif (unlikely(!trylock_page(page))) {\n\t\t\t\tget_page(page);\n\t\t\t\t_pmd = *pmd;\n\t\t\t\tspin_unlock(ptl);\n\t\t\t\tlock_page(page);\n\t\t\t\tspin_lock(ptl);\n\t\t\t\tif (unlikely(!pmd_same(*pmd, _pmd))) {\n\t\t\t\t\tunlock_page(page);\n\t\t\t\t\tput_page(page);\n\t\t\t\t\tpage = NULL;\n\t\t\t\t\tgoto repeat;\n\t\t\t\t}\n\t\t\t\tput_page(page);\n\t\t\t}\n\t\t}\n// fix_end\n// fix_start\n\tif (!was_locked && page)\n\t\tunlock_page(page);\n// fix_end\n", "cwe": "CWE-362", "cwe_name": "Concurrent Execution using Shared Resource with Improper Synchronization ('Race Condition')", "cve": "CVE-2020-29368", "cve_desc": "An issue was discovered in __split_huge_pmd in mm/huge_memory.c in the Linux kernel before 5.7.5. The copy-on-write implementation can grant unintended write access because of a race condition in a THP mapcount check, aka CID-c444eb564fb1.", "project": "linux", "idx": 204725}
{"source": "// bug_start\nlyxml_parse_elem(struct ly_ctx *ctx, const char *data, unsigned int *len, struct lyxml_elem *parent, int options)\n// bug_end\n {\n     const char *c = data, *start, *e;\n     const char *lws;\n     int uc;\n     char *str;\n     char *prefix = NULL;\n     unsigned int prefix_len = 0;\n     struct lyxml_elem *elem = NULL, *child;\n     struct lyxml_attr *attr;\n     unsigned int size;\n     int nons_flag = 0, closed_flag = 0;\n \n     *len = 0;\n \n// bug_start\n// bug_end\n     if (*c != '<') {\n         return NULL;\n     }\n \n     c++;\n     e = c;\n \n     uc = lyxml_getutf8(ctx, e, &size);\n     if (!is_xmlnamestartchar(uc)) {\n         LOGVAL(ctx, LYE_XML_INVAL, LY_VLOG_NONE, NULL, \"NameStartChar of the element\");\n         return NULL;\n     }\n     e += size;\n     uc = lyxml_getutf8(ctx, e, &size);\n     while (is_xmlnamechar(uc)) {\n         if (*e == ':') {\n             if (prefix_len) {\n                 LOGVAL(ctx, LYE_XML_INVAL, LY_VLOG_NONE, NULL, \"element name, multiple colons found\");\n                 goto error;\n             }\n             start = e + 1;\n \n             prefix_len = e - c;\n             LY_CHECK_ERR_GOTO(prefix, LOGVAL(ctx, LYE_XML_INCHAR, LY_VLOG_NONE, NULL, e), error);\n             prefix = malloc((prefix_len + 1) * sizeof *prefix);\n             LY_CHECK_ERR_GOTO(!prefix, LOGMEM(ctx), error);\n             memcpy(prefix, c, prefix_len);\n             prefix[prefix_len] = '\\0';\n             c = start;\n         }\n         e += size;\n         uc = lyxml_getutf8(ctx, e, &size);\n     }\n     if (!*e) {\n         LOGVAL(ctx, LYE_EOF, LY_VLOG_NONE, NULL);\n         free(prefix);\n         return NULL;\n     }\n \n     elem = calloc(1, sizeof *elem);\n     LY_CHECK_ERR_RETURN(!elem, free(prefix); LOGMEM(ctx), NULL);\n \n     elem->next = NULL;\n     elem->prev = elem;\n     if (parent) {\n         lyxml_add_child(ctx, parent, elem);\n     }\n \n     elem->name = lydict_insert(ctx, c, e - c);\n     c = e;\n \n process:\n     ign_xmlws(c);\n     if (!strncmp(\"/>\", c, 2)) {\n         c += 2;\n         elem->content = lydict_insert(ctx, \"\", 0);\n         closed_flag = 1;\n     } else if (*c == '>') {\n         c++;\n         lws = NULL;\n \n         while (*c) {\n             if (!strncmp(c, \"</\", 2)) {\n                 if (lws && !elem->child) {\n                     goto store_content;\n                 }\n \n                 c += 2;\n                 e = c;\n                 uc = lyxml_getutf8(ctx, e, &size);\n                 if (!is_xmlnamestartchar(uc)) {\n                     LOGVAL(ctx, LYE_XML_INVAL, LY_VLOG_XML, elem, \"NameStartChar of the element\");\n                     goto error;\n                 }\n                 e += size;\n                 uc = lyxml_getutf8(ctx, e, &size);\n                 while (is_xmlnamechar(uc)) {\n                     if (*e == ':') {\n                         start = e + 1;\n \n                         if (!prefix || memcmp(prefix, c, e - c)) {\n                             LOGVAL(ctx, LYE_SPEC, LY_VLOG_XML, elem,\n                                    \"Invalid (different namespaces) opening (%s) and closing element tags.\", elem->name);\n                             goto error;\n                         }\n                         c = start;\n                     }\n                     e += size;\n                     uc = lyxml_getutf8(ctx, e, &size);\n                 }\n                 if (!*e) {\n                     LOGVAL(ctx, LYE_EOF, LY_VLOG_NONE, NULL);\n                     goto error;\n                 }\n \n                 size = e - c;\n                 str = malloc((size + 1) * sizeof *str);\n                 LY_CHECK_ERR_GOTO(!str, LOGMEM(ctx), error);\n                 memcpy(str, c, e - c);\n                 str[e - c] = '\\0';\n                 if (size != strlen(elem->name) || memcmp(str, elem->name, size)) {\n                     LOGVAL(ctx, LYE_SPEC, LY_VLOG_XML, elem,\n                            \"Invalid (mixed names) opening (%s) and closing (%s) element tags.\", elem->name, str);\n                     free(str);\n                     goto error;\n                 }\n                 free(str);\n                 c = e;\n \n                 ign_xmlws(c);\n                 if (*c != '>') {\n                     LOGVAL(ctx, LYE_SPEC, LY_VLOG_XML, elem, \"Data after closing element tag \\\"%s\\\".\", elem->name);\n                     goto error;\n                 }\n                 c++;\n                 if (!(elem->flags & LYXML_ELEM_MIXED) && !elem->content) {\n                     elem->content = lydict_insert(ctx, \"\", 0);\n                 }\n                 closed_flag = 1;\n                 break;\n \n             } else if (!strncmp(c, \"<?\", 2)) {\n                 if (lws) {\n                     lws = NULL;\n                 }\n                 c += 2;\n                 if (parse_ignore(ctx, c, \"?>\", &size)) {\n                     goto error;\n                 }\n                 c += size;\n             } else if (!strncmp(c, \"<!--\", 4)) {\n                 if (lws) {\n                     lws = NULL;\n                 }\n                 c += 4;\n                 if (parse_ignore(ctx, c, \"-->\", &size)) {\n                     goto error;\n                 }\n                 c += size;\n             } else if (!strncmp(c, \"<![CDATA[\", 9)) {\n                 goto store_content;\n             } else if (*c == '<') {\n                 if (lws) {\n                     if (elem->flags & LYXML_ELEM_MIXED) {\n                         goto store_content;\n                     } else {\n                         lws = NULL;\n                     }\n                 }\n                 if (elem->content) {\n                     if (options & LYXML_PARSE_NOMIXEDCONTENT) {\n                         LOGVAL(ctx, LYE_XML_INVAL, LY_VLOG_XML, elem, \"XML element with mixed content\");\n                         goto error;\n                     }\n                     child = calloc(1, sizeof *child);\n                     LY_CHECK_ERR_GOTO(!child, LOGMEM(ctx), error);\n                     child->content = elem->content;\n                     elem->content = NULL;\n                     lyxml_add_child(ctx, elem, child);\n                     elem->flags |= LYXML_ELEM_MIXED;\n                 }\n// bug_start\n                child = lyxml_parse_elem(ctx, c, &size, elem, options);\n// bug_end\n                 if (!child) {\n                     goto error;\n                 }\n                 c += size;\n             } else if (is_xmlws(*c)) {\n                 lws = c;\n                 ign_xmlws(c);\n             } else {\n store_content:\n                 if (lws) {\n                     c = lws;\n                     lws = NULL;\n                 }\n                 str = parse_text(ctx, c, '<', &size);\n                 if (!str && !size) {\n                     goto error;\n                 }\n                 elem->content = lydict_insert_zc(ctx, str);\n                 c += size;\n \n                 if (elem->child) {\n                     if (options & LYXML_PARSE_NOMIXEDCONTENT) {\n                         LOGVAL(ctx, LYE_XML_INVAL, LY_VLOG_XML, elem, \"XML element with mixed content\");\n                         goto error;\n                     }\n                     child = calloc(1, sizeof *child);\n                     LY_CHECK_ERR_GOTO(!child, LOGMEM(ctx), error);\n                     child->content = elem->content;\n                     elem->content = NULL;\n                     lyxml_add_child(ctx, elem, child);\n                     elem->flags |= LYXML_ELEM_MIXED;\n                 }\n             }\n         }\n     } else {\n         attr = parse_attr(ctx, c, &size, elem);\n         if (!attr) {\n             goto error;\n         }\n         c += size;\n \n         if (attr->type == LYXML_ATTR_NS) {\n             if ((!prefix || !prefix[0]) && !attr->name) {\n                 if (attr->value) {\n                     elem->ns = (struct lyxml_ns *)attr;\n                 } else {\n                     nons_flag = 1;\n                 }\n             } else if (prefix && prefix[0] && attr->name && !strncmp(attr->name, prefix, prefix_len + 1)) {\n                 elem->ns = (struct lyxml_ns *)attr;\n             }\n         }\n \n         goto process;\n     }\n \n     *len = c - data;\n \n     if (!closed_flag) {\n         LOGVAL(ctx, LYE_XML_MISS, LY_VLOG_XML, elem, \"closing element tag\", elem->name);\n         goto error;\n     }\n \n     LY_TREE_FOR(elem->attr, attr) {\n         if (attr->type == LYXML_ATTR_STD_UNRES) {\n             str = (char *)attr->ns;\n             attr->ns = lyxml_get_ns(elem, str);\n             free(str);\n             attr->type = LYXML_ATTR_STD;\n         }\n     }\n \n     if (!elem->ns && !nons_flag && parent) {\n         elem->ns = lyxml_get_ns(parent, prefix_len ? prefix : NULL);\n     }\n     free(prefix);\n     return elem;\n \n error:\n     lyxml_free(ctx, elem);\n     free(prefix);\n     return NULL;\n }\n \n", "target": "// fix_start\nlyxml_parse_elem(struct ly_ctx *ctx, const char *data, unsigned int *len, struct lyxml_elem *parent, int options,\n                 int bt_count)\n// fix_end\n// fix_start\n    if (bt_count > LY_RECURSION_LIMIT) {\n        LOGVAL(ctx, LYE_XML_INVAL, LY_VLOG_NONE, NULL, \"Recursion limit %d reached\", LY_RECURSION_LIMIT);\n        return NULL;\n    }\n\n// fix_end\n// fix_start\n                child = lyxml_parse_elem(ctx, c, &size, elem, options, bt_count + 1);\n// fix_end\n", "cwe": "CWE-674", "cwe_name": "Uncontrolled Recursion", "cve": "CVE-2021-28903", "cve_desc": "A stack overflow in libyang <= v1.0.225 can cause a denial of service through function lyxml_parse_mem(). lyxml_parse_elem() function will be called recursively, which will consume stack space and lead to crash.", "project": "libyang", "idx": 204825}
{"source": " lyxml_parse_mem(struct ly_ctx *ctx, const char *data, int options)\n {\n     FUN_IN;\n \n     const char *c = data;\n     unsigned int len;\n     struct lyxml_elem *root, *first = NULL, *next;\n \n     if (!ctx) {\n         LOGARG;\n         return NULL;\n     }\n \n     if (!data) {\n         return NULL;\n     }\n \n repeat:\n     while (1) {\n         if (!*c) {\n             return first;\n         } else if (is_xmlws(*c)) {\n             ign_xmlws(c);\n         } else if (!strncmp(c, \"<?\", 2)) {\n             c += 2;\n             if (parse_ignore(ctx, c, \"?>\", &len)) {\n                 goto error;\n             }\n             c += len;\n         } else if (!strncmp(c, \"<!--\", 4)) {\n             c += 2;\n             if (parse_ignore(ctx, c, \"-->\", &len)) {\n                 goto error;\n             }\n             c += len;\n         } else if (!strncmp(c, \"<!\", 2)) {\n             LOGERR(ctx, LY_EINVAL, \"DOCTYPE not supported in XML documents.\");\n             goto error;\n         } else if (*c == '<') {\n             break;\n         } else {\n             LOGVAL(ctx, LYE_XML_INCHAR, LY_VLOG_NONE, NULL, c);\n             goto error;\n         }\n     }\n \n// bug_start\n    root = lyxml_parse_elem(ctx, c, &len, NULL, options);\n// bug_end\n     if (!root) {\n         goto error;\n     } else if (!first) {\n         first = root;\n     } else {\n         first->prev->next = root;\n         root->prev = first->prev;\n         first->prev = root;\n     }\n     c += len;\n \n     ign_xmlws(c);\n     if (*c) {\n         if (options & LYXML_PARSE_MULTIROOT) {\n             goto repeat;\n         } else {\n             LOGWRN(ctx, \"There are some not parsed data:\\n%s\", c);\n         }\n     }\n \n     return first;\n \n error:\n     LY_TREE_FOR_SAFE(first, next, root) {\n         lyxml_free(ctx, root);\n     }\n     return NULL;\n }\n \n", "target": "// fix_start\n    root = lyxml_parse_elem(ctx, c, &len, NULL, options, 0);\n// fix_end\n", "cwe": "CWE-674", "cwe_name": "Uncontrolled Recursion", "cve": "CVE-2021-28903", "cve_desc": "A stack overflow in libyang <= v1.0.225 can cause a denial of service through function lyxml_parse_mem(). lyxml_parse_elem() function will be called recursively, which will consume stack space and lead to crash.", "project": "libyang", "idx": 204826}
{"source": " int mpol_parse_str(char *str, struct mempolicy **mpol)\n {\n \tstruct mempolicy *new = NULL;\n \tunsigned short mode_flags;\n \tnodemask_t nodes;\n \tchar *nodelist = strchr(str, ':');\n \tchar *flags = strchr(str, '=');\n \tint err = 1, mode;\n \n \tif (flags)\n \t\t*flags++ = '\\0';\n \n \tif (nodelist) {\n \t\t*nodelist++ = '\\0';\n \t\tif (nodelist_parse(nodelist, nodes))\n \t\t\tgoto out;\n \t\tif (!nodes_subset(nodes, node_states[N_MEMORY]))\n \t\t\tgoto out;\n \t} else\n \t\tnodes_clear(nodes);\n \n \tmode = match_string(policy_modes, MPOL_MAX, str);\n \tif (mode < 0)\n \t\tgoto out;\n \n \tswitch (mode) {\n \tcase MPOL_PREFERRED:\n \t\tif (nodelist) {\n \t\t\tchar *rest = nodelist;\n \t\t\twhile (isdigit(*rest))\n \t\t\t\trest++;\n \t\t\tif (*rest)\n// bug_start\n// bug_end\n \t\t\t\tgoto out;\n \t\t}\n \t\tbreak;\n \tcase MPOL_INTERLEAVE:\n \t\tif (!nodelist)\n \t\t\tnodes = node_states[N_MEMORY];\n \t\tbreak;\n \tcase MPOL_LOCAL:\n \t\tif (nodelist)\n \t\t\tgoto out;\n \t\tmode = MPOL_PREFERRED;\n \t\tbreak;\n \tcase MPOL_DEFAULT:\n \t\tif (!nodelist)\n \t\t\terr = 0;\n \t\tgoto out;\n \tcase MPOL_BIND:\n \t\tif (!nodelist)\n \t\t\tgoto out;\n \t}\n \n \tmode_flags = 0;\n \tif (flags) {\n \t\tif (!strcmp(flags, \"static\"))\n \t\t\tmode_flags |= MPOL_F_STATIC_NODES;\n \t\telse if (!strcmp(flags, \"relative\"))\n \t\t\tmode_flags |= MPOL_F_RELATIVE_NODES;\n \t\telse\n \t\t\tgoto out;\n \t}\n \n \tnew = mpol_new(mode, mode_flags, &nodes);\n \tif (IS_ERR(new))\n \t\tgoto out;\n \n \tif (mode != MPOL_PREFERRED)\n \t\tnew->v.nodes = nodes;\n \telse if (nodelist)\n \t\tnew->v.preferred_node = first_node(nodes);\n \telse\n \t\tnew->flags |= MPOL_F_LOCAL;\n \n \tnew->w.user_nodemask = nodes;\n \n \terr = 0;\n \n out:\n \tif (nodelist)\n \t\t*--nodelist = ':';\n \tif (flags)\n \t\t*--flags = '=';\n \tif (!err)\n \t\t*mpol = new;\n \treturn err;\n }\n \n", "target": "// fix_start\n\t\t\t\tgoto out;\n\t\t\tif (nodes_empty(nodes))\n// fix_end\n", "cwe": "CWE-787", "cwe_name": "Out-of-bounds Write", "cve": "CVE-2020-11565", "cve_desc": "An issue was discovered in the Linux kernel through 5.6.2. mpol_parse_str in mm/mempolicy.c has a stack-based out-of-bounds write because an empty nodelist is mishandled during mount option parsing, aka CID-aa9f7d5172fa. NOTE: Someone in the security community disagrees that this is a vulnerability because the issue \u201cis a bug in parsing mount options which can only be specified by a privileged user, so triggering the bug does not grant any powers not already held.\u201d", "project": "linux", "idx": 204856}
{"source": " static void sm501_2d_operation(SM501State *s)\n {\n     int cmd = (s->twoD_control >> 16) & 0x1F;\n     int rtl = s->twoD_control & BIT(27);\n     int format = (s->twoD_stretch >> 20) & 0x3;\n     int rop_mode = (s->twoD_control >> 15) & 0x1;\n     int rop2_source_is_pattern = (s->twoD_control >> 14) & 0x1;\n     int rop = s->twoD_control & 0xFF;\n// bug_start\n    int dst_x = (s->twoD_destination >> 16) & 0x01FFF;\n    int dst_y = s->twoD_destination & 0xFFFF;\n    int width = (s->twoD_dimension >> 16) & 0x1FFF;\n    int height = s->twoD_dimension & 0xFFFF;\n// bug_end\n     uint32_t dst_base = s->twoD_destination_base & 0x03FFFFFF;\n// bug_start\n    uint8_t *dst = s->local_mem + dst_base;\n    int dst_pitch = (s->twoD_pitch >> 16) & 0x1FFF;\n// bug_end\n     int crt = (s->dc_crt_control & SM501_DC_CRT_CONTROL_SEL) ? 1 : 0;\n     int fb_len = get_width(s, crt) * get_height(s, crt) * get_bpp(s, crt);\n \n     if ((s->twoD_stretch >> 16) & 0xF) {\n         qemu_log_mask(LOG_UNIMP, \"sm501: only XY addressing is supported.\\n\");\n         return;\n     }\n \n// bug_start\n    if (rop_mode == 0) {\n        if (rop != 0xcc) {\n            qemu_log_mask(LOG_UNIMP, \"sm501: rop3 mode with rop %x is not \"\n                          \"supported.\\n\", rop);\n        }\n    } else {\n        if (rop2_source_is_pattern && rop != 0x5) {\n            qemu_log_mask(LOG_UNIMP, \"sm501: rop2 source being the pattern and \"\n                          \"rop %x is not supported.\\n\", rop);\n        } else {\n            if (rop != 0x5 && rop != 0xc) {\n                qemu_log_mask(LOG_UNIMP, \"sm501: rop mode %x is not \"\n                              \"supported.\\n\", rop);\n            }\n        }\n    }\n\n// bug_end\n     if (s->twoD_source_base & BIT(27) || s->twoD_destination_base & BIT(27)) {\n         qemu_log_mask(LOG_UNIMP, \"sm501: only local memory is supported.\\n\");\n         return;\n     }\n \n// bug_start\n// bug_end\n     switch (cmd) {\n// bug_start\n    case 0x00:\n// bug_end\n     {\n// bug_start\n        int src_x = (s->twoD_source >> 16) & 0x01FFF;\n        int src_y = s->twoD_source & 0xFFFF;\n// bug_end\n         uint32_t src_base = s->twoD_source_base & 0x03FFFFFF;\n// bug_start\n        uint8_t *src = s->local_mem + src_base;\n        int src_pitch = s->twoD_pitch & 0x1FFF;\n// bug_end\n \n// bug_start\n#define COPY_AREA(_bpp, _pixel_type, rtl) {                                   \\\n        int y, x, index_d, index_s;                                           \\\n        for (y = 0; y < height; y++) {                              \\\n            for (x = 0; x < width; x++) {                           \\\n                _pixel_type val;                                              \\\n                                                                              \\\n                if (rtl) {                                                    \\\n                    index_s = ((src_y - y) * src_pitch + src_x - x) * _bpp;   \\\n                    index_d = ((dst_y - y) * dst_pitch + dst_x - x) * _bpp;   \\\n                } else {                                                      \\\n                    index_s = ((src_y + y) * src_pitch + src_x + x) * _bpp;   \\\n                    index_d = ((dst_y + y) * dst_pitch + dst_x + x) * _bpp;   \\\n                }                                                             \\\n                if (rop_mode == 1 && rop == 5) {                              \\\n                                                             \\\n                    val = ~*(_pixel_type *)&dst[index_d];                     \\\n                } else {                                                      \\\n                    val = *(_pixel_type *)&src[index_s];                      \\\n                }                                                             \\\n                *(_pixel_type *)&dst[index_d] = val;                          \\\n            }                                                                 \\\n        }                                                                     \\\n    }\n        switch (format) {\n        case 0:\n            COPY_AREA(1, uint8_t, rtl);\n            break;\n        case 1:\n            COPY_AREA(2, uint16_t, rtl);\n            break;\n        case 2:\n            COPY_AREA(4, uint32_t, rtl);\n            break;\n// bug_end\n         }\n         break;\n     }\n// bug_start\n    case 0x01:\n// bug_end\n     {\n         uint32_t color = s->twoD_foreground;\n \n// bug_start\n#define FILL_RECT(_bpp, _pixel_type) {                                      \\\n        int y, x;                                                           \\\n        for (y = 0; y < height; y++) {                            \\\n            for (x = 0; x < width; x++) {                         \\\n                int index = ((dst_y + y) * dst_pitch + dst_x + x) * _bpp;   \\\n                *(_pixel_type *)&dst[index] = (_pixel_type)color;           \\\n            }                                                               \\\n        }                                                                   \\\n    }\n// bug_end\n \n// bug_start\n        switch (format) {\n        case 0:\n            FILL_RECT(1, uint8_t);\n            break;\n        case 1:\n            color = cpu_to_le16(color);\n            FILL_RECT(2, uint16_t);\n            break;\n        case 2:\n            color = cpu_to_le32(color);\n            FILL_RECT(4, uint32_t);\n            break;\n        }\n// bug_end\n         break;\n     }\n     default:\n         qemu_log_mask(LOG_UNIMP, \"sm501: not implemented 2D operation: %d\\n\",\n                       cmd);\n         return;\n     }\n \n     if (dst_base >= get_fb_addr(s, crt) &&\n         dst_base <= get_fb_addr(s, crt) + fb_len) {\n         int dst_len = MIN(fb_len, ((dst_y + height - 1) * dst_pitch +\n                           dst_x + width) * (1 << format));\n         if (dst_len) {\n             memory_region_set_dirty(&s->local_mem_region, dst_base, dst_len);\n         }\n     }\n }\n \n", "target": "// fix_start\n    unsigned int dst_x = (s->twoD_destination >> 16) & 0x01FFF;\n    unsigned int dst_y = s->twoD_destination & 0xFFFF;\n    unsigned int width = (s->twoD_dimension >> 16) & 0x1FFF;\n    unsigned int height = s->twoD_dimension & 0xFFFF;\n// fix_end\n// fix_start\n    unsigned int dst_pitch = (s->twoD_pitch >> 16) & 0x1FFF;\n// fix_end\n// fix_start\n// fix_end\n// fix_start\n    if (!dst_pitch) {\n        qemu_log_mask(LOG_GUEST_ERROR, \"sm501: Zero dest pitch.\\n\");\n        return;\n    }\n\n    if (!width || !height) {\n        qemu_log_mask(LOG_GUEST_ERROR, \"sm501: Zero size 2D op.\\n\");\n        return;\n    }\n\n    if (rtl) {\n        dst_x -= width - 1;\n        dst_y -= height - 1;\n    }\n\n    if (dst_base >= get_local_mem_size(s) || dst_base +\n        (dst_x + width + (dst_y + height) * (dst_pitch + width)) *\n        (1 << format) >= get_local_mem_size(s)) {\n        qemu_log_mask(LOG_GUEST_ERROR, \"sm501: 2D op dest is outside vram.\\n\");\n        return;\n    }\n\n// fix_end\n// fix_start\n    case 0:\n// fix_end\n// fix_start\n        unsigned int src_x = (s->twoD_source >> 16) & 0x01FFF;\n        unsigned int src_y = s->twoD_source & 0xFFFF;\n// fix_end\n// fix_start\n        unsigned int src_pitch = s->twoD_pitch & 0x1FFF;\n// fix_end\n// fix_start\n        if (!src_pitch) {\n            qemu_log_mask(LOG_GUEST_ERROR, \"sm501: Zero src pitch.\\n\");\n            return;\n        }\n\n        if (rtl) {\n            src_x -= width - 1;\n            src_y -= height - 1;\n        }\n\n        if (src_base >= get_local_mem_size(s) || src_base +\n            (src_x + width + (src_y + height) * (src_pitch + width)) *\n            (1 << format) >= get_local_mem_size(s)) {\n            qemu_log_mask(LOG_GUEST_ERROR,\n                          \"sm501: 2D op src is outside vram.\\n\");\n            return;\n        }\n\n        if ((rop_mode && rop == 0x5) || (!rop_mode && rop == 0x55)) {\n            unsigned int x, y, i;\n            uint8_t *d = s->local_mem + dst_base;\n\n            for (y = 0; y < height; y++) {\n                i = (dst_x + (dst_y + y) * dst_pitch) * (1 << format);\n                for (x = 0; x < width; x++, i += (1 << format)) {\n                    switch (format) {\n                    case 0:\n                        d[i] = ~d[i];\n                        break;\n                    case 1:\n                        *(uint16_t *)&d[i] = ~*(uint16_t *)&d[i];\n                        break;\n                    case 2:\n                        *(uint32_t *)&d[i] = ~*(uint32_t *)&d[i];\n                        break;\n                    }\n                }\n            }\n        } else {\n            if ((rop_mode && (rop != 0xc || rop2_source_is_pattern)) ||\n                (!rop_mode && rop != 0xcc)) {\n                qemu_log_mask(LOG_UNIMP,\n                              \"sm501: rop%d op %x%s not implemented\\n\",\n                              (rop_mode ? 2 : 3), rop,\n                              (rop2_source_is_pattern ?\n                                  \" with pattern source\" : \"\"));\n            }\n            uint32_t sb, se, db, de;\n            sb = src_base + src_x + src_y * (width + src_pitch);\n            se = sb + width + height * (width + src_pitch);\n            db = dst_base + dst_x + dst_y * (width + dst_pitch);\n            de = db + width + height * (width + dst_pitch);\n            if (rtl && ((db >= sb && db <= se) || (de >= sb && de <= se))) {\n                int llb = width * (1 << format);\n                int tmp_stride = DIV_ROUND_UP(llb, sizeof(uint32_t));\n                uint32_t *tmp = g_malloc(tmp_stride * sizeof(uint32_t) *\n                                         height);\n                pixman_blt((uint32_t *)&s->local_mem[src_base], tmp,\n                           src_pitch * (1 << format) / sizeof(uint32_t),\n                           tmp_stride, 8 * (1 << format), 8 * (1 << format),\n                           src_x, src_y, 0, 0, width, height);\n                pixman_blt(tmp, (uint32_t *)&s->local_mem[dst_base],\n                           tmp_stride,\n                           dst_pitch * (1 << format) / sizeof(uint32_t),\n                           8 * (1 << format), 8 * (1 << format),\n                           0, 0, dst_x, dst_y, width, height);\n                g_free(tmp);\n            } else {\n                pixman_blt((uint32_t *)&s->local_mem[src_base],\n                           (uint32_t *)&s->local_mem[dst_base],\n                           src_pitch * (1 << format) / sizeof(uint32_t),\n                           dst_pitch * (1 << format) / sizeof(uint32_t),\n                           8 * (1 << format), 8 * (1 << format),\n                           src_x, src_y, dst_x, dst_y, width, height);\n            }\n// fix_end\n// fix_start\n    case 1:\n// fix_end\n// fix_start\n        if (format == 2) {\n            color = cpu_to_le32(color);\n        } else if (format == 1) {\n            color = cpu_to_le16(color);\n        }\n// fix_end\n// fix_start\n        pixman_fill((uint32_t *)&s->local_mem[dst_base],\n                    dst_pitch * (1 << format) / sizeof(uint32_t),\n                    8 * (1 << format), dst_x, dst_y, width, height, color);\n// fix_end\n", "cwe": "CWE-190", "cwe_name": "Integer Overflow or Wraparound", "cve": "CVE-2020-12829", "cve_desc": "In QEMU through 5.0.0, an integer overflow was found in the SM501 display driver implementation. This flaw occurs in the COPY_AREA macro while handling MMIO write operations through the sm501_2d_engine_write() callback. A local attacker could abuse this flaw to crash the QEMU process in sm501_2d_operation() in hw/display/sm501.c on the host, resulting in a denial of service.", "project": "qemu", "idx": 204867}
{"source": "     int MemIo::seek(int64 offset, Position pos )\n     {\n         int64 newIdx = 0;\n \n         switch (pos) {\n             case BasicIo::cur:\n                 newIdx = p_->idx_ + offset;\n                 break;\n             case BasicIo::beg:\n                 newIdx = offset;\n                 break;\n             case BasicIo::end:\n                 newIdx = p_->size_ + offset;\n                 break;\n         }\n \n         if (newIdx < 0)\n             return 1;\n \n// bug_start\n        p_->idx_ = static_cast<long>(newIdx);\n// bug_end\n         p_->eof_ = false;\n         return 0;\n     }\n \n", "target": "// fix_start\n        if (static_cast<size_t>(newIdx) > p_->size_) {\n            p_->eof_ = true;\n            return 1;\n        }\n\n        p_->idx_ = static_cast<size_t>(newIdx);\n// fix_end\n", "cwe": "CWE-125", "cwe_name": "Out-of-bounds Read", "cve": "CVE-2019-13504", "cve_desc": "There is an out-of-bounds read in Exiv2::MrwImage::readMetadata in mrwimage.cpp in Exiv2 through 0.27.2.", "project": "exiv2", "idx": 204868}
{"source": " BPMDetect::BPMDetect(int numChannels, int aSampleRate) :\n     beat_lpf(_LPF_coeffs)\n {\n     beats.reserve(250);\n \n     this->sampleRate = aSampleRate;\n     this->channels = numChannels;\n \n     decimateSum = 0;\n     decimateCount = 0;\n \n     decimateBy = sampleRate / TARGET_SRATE;\n// bug_start\n    assert(decimateBy > 0);\n    assert(INPUT_BLOCK_SIZE < decimateBy * DECIMATED_BLOCK_SIZE);\n// bug_end\n \n     windowLen = (60 * sampleRate) / (decimateBy * MIN_BPM);\n     windowStart = (60 * sampleRate) / (decimateBy * MAX_BPM_RANGE);\n \n     assert(windowLen > windowStart);\n \n     xcorr = new float[windowLen];\n     memset(xcorr, 0, windowLen * sizeof(float));\n \n     pos = 0;\n     peakPos = 0;\n     peakVal = 0;\n     init_scaler = 1;\n     beatcorr_ringbuffpos = 0;\n     beatcorr_ringbuff = new float[windowLen];\n     memset(beatcorr_ringbuff, 0, windowLen * sizeof(float));\n \n     buffer = new FIFOSampleBuffer();\n     buffer->setChannels(1);\n     buffer->clear();\n \n     hamw = new float[XCORR_UPDATE_SEQUENCE];\n     hamming(hamw, XCORR_UPDATE_SEQUENCE);\n     hamw2 = new float[XCORR_UPDATE_SEQUENCE / 2];\n     hamming(hamw2, XCORR_UPDATE_SEQUENCE / 2);\n }\n \n", "target": "// fix_start\n    if ((decimateBy <= 0) || (decimateBy * DECIMATED_BLOCK_SIZE < INPUT_BLOCK_SIZE))\n    {\n        ST_THROW_RT_ERROR(\"Too small samplerate\");\n    }\n// fix_end\n", "cwe": "CWE-617", "cwe_name": "Reachable Assertion", "cve": "CVE-2018-17096", "cve_desc": "The BPMDetect class in BPMDetect.cpp in libSoundTouch.a in Olli Parviainen SoundTouch 2.0 allows remote attackers to cause a denial of service (assertion failure and application exit), as demonstrated by SoundStretch.", "project": "soundtouch", "idx": 205562}
{"source": " hivex_open (const char *filename, int flags)\n {\n   hive_h *h = NULL;\n \n   assert (sizeof (struct ntreg_header) == 0x1000);\n   assert (offsetof (struct ntreg_header, csum) == 0x1fc);\n \n   h = calloc (1, sizeof *h);\n   if (h == NULL)\n     goto error;\n \n   h->msglvl = flags & HIVEX_OPEN_MSGLVL_MASK;\n \n   const char *debug = getenv (\"HIVEX_DEBUG\");\n   if (debug && STREQ (debug, \"1\"))\n     h->msglvl = 2;\n \n   DEBUG (2, \"created handle %p\", h);\n \n   h->writable = !!(flags & HIVEX_OPEN_WRITE);\n   h->unsafe = !!(flags & HIVEX_OPEN_UNSAFE);\n   h->filename = strdup (filename);\n   if (h->filename == NULL)\n     goto error;\n \n #ifdef O_CLOEXEC\n   h->fd = open (filename, O_RDONLY | O_CLOEXEC | O_BINARY);\n #else\n   h->fd = open (filename, O_RDONLY | O_BINARY);\n #endif\n   if (h->fd == -1)\n     goto error;\n #ifndef O_CLOEXEC\n   fcntl (h->fd, F_SETFD, FD_CLOEXEC);\n #endif\n \n   struct stat statbuf;\n   if (fstat (h->fd, &statbuf) == -1)\n     goto error;\n \n   h->size = statbuf.st_size;\n \n   if (h->size < 0x2000) {\n     SET_ERRNO (EINVAL,\n                \"%s: file is too small to be a Windows NT Registry hive file\",\n                filename);\n     goto error;\n   }\n \n   if (!h->writable) {\n     h->addr = mmap (NULL, h->size, PROT_READ, MAP_SHARED, h->fd, 0);\n     if (h->addr == MAP_FAILED)\n       goto error;\n \n     DEBUG (2, \"mapped file at %p\", h->addr);\n   } else {\n     h->addr = malloc (h->size);\n     if (h->addr == NULL)\n       goto error;\n \n     if (full_read (h->fd, h->addr, h->size) < h->size)\n       goto error;\n \n     if (close (h->fd) == -1)\n       goto error;\n     h->fd = -1;\n   }\n \n   if (h->hdr->magic[0] != 'r' ||\n       h->hdr->magic[1] != 'e' ||\n       h->hdr->magic[2] != 'g' ||\n       h->hdr->magic[3] != 'f') {\n     SET_ERRNO (ENOTSUP,\n                \"%s: not a Windows NT Registry hive file\", filename);\n     goto error;\n   }\n \n   uint32_t major_ver = le32toh (h->hdr->major_ver);\n   if (major_ver != 1) {\n     SET_ERRNO (ENOTSUP,\n                \"%s: hive file major version %\" PRIu32 \" (expected 1)\",\n                filename, major_ver);\n     goto error;\n   }\n \n   h->bitmap = calloc (1 + h->size / 32, 1);\n   if (h->bitmap == NULL)\n     goto error;\n \n   uint32_t sum = header_checksum (h);\n   if (sum != le32toh (h->hdr->csum)) {\n     SET_ERRNO (EINVAL, \"%s: bad checksum in hive header\", filename);\n     goto error;\n   }\n \n   for (int t=0; t<nr_recode_types; t++) {\n     gl_lock_init (h->iconv_cache[t].mutex);\n     h->iconv_cache[t].handle = NULL;\n   }\n \n   h->last_modified = le64toh ((int64_t) h->hdr->last_modified);\n \n   if (h->msglvl >= 2) {\n     char *name = _hivex_recode (h, utf16le_to_utf8,\n                                 h->hdr->name, 64, NULL);\n \n     fprintf (stderr,\n              \"hivex_open: header fields:\\n\"\n              \"  file version             %\" PRIu32 \".%\" PRIu32 \"\\n\"\n              \"  sequence nos             %\" PRIu32 \" %\" PRIu32 \"\\n\"\n              \"    (sequences nos should match if hive was synched at shutdown)\\n\"\n              \"  last modified            %\" PRIi64 \"\\n\"\n              \"    (Windows filetime, x 100 ns since 1601-01-01)\\n\"\n              \"  original file name       %s\\n\"\n              \"    (only 32 chars are stored, name is probably truncated)\\n\"\n              \"  root offset              0x%x + 0x1000\\n\"\n              \"  end of last page         0x%x + 0x1000 (total file size 0x%zx)\\n\"\n              \"  checksum                 0x%x (calculated 0x%x)\\n\",\n              major_ver, le32toh (h->hdr->minor_ver),\n              le32toh (h->hdr->sequence1), le32toh (h->hdr->sequence2),\n              h->last_modified,\n              name ? name : \"(conversion failed)\",\n              le32toh (h->hdr->offset),\n              le32toh (h->hdr->blocks), h->size,\n              le32toh (h->hdr->csum), sum);\n     free (name);\n   }\n \n   h->rootoffs = le32toh (h->hdr->offset) + 0x1000;\n   h->endpages = le32toh (h->hdr->blocks) + 0x1000;\n \n   DEBUG (2, \"root offset = 0x%zx\", h->rootoffs);\n \n   int seen_root_block = 0, bad_root_block = 0;\n \n   size_t pages = 0;\n   size_t smallest_page = SIZE_MAX, largest_page = 0;\n   size_t blocks = 0;\n   size_t smallest_block = SIZE_MAX, largest_block = 0, blocks_bytes = 0;\n   size_t used_blocks = 0;\n   size_t used_size = 0;\n \n   size_t off;\n   struct ntreg_hbin_page *page;\n   for (off = 0x1000; off < h->size; off += le32toh (page->page_size)) {\n     if (off >= h->endpages)\n       break;\n \n     page = (struct ntreg_hbin_page *) ((char *) h->addr + off);\n     if (page->magic[0] != 'h' ||\n         page->magic[1] != 'b' ||\n         page->magic[2] != 'i' ||\n         page->magic[3] != 'n') {\n \n       if (!h->unsafe) {\n         SET_ERRNO (ENOTSUP,\n                    \"%s: trailing garbage at end of file \"\n                    \"(at 0x%zx, after %zu pages)\",\n                    filename, off, pages);\n         goto error;\n       }\n \n       DEBUG (2,\n              \"page not found at expected offset 0x%zx, \"\n              \"seeking until one is found or EOF is reached\",\n              off);\n \n       int found = 0;\n       while (off < h->size) {\n         off += 0x1000;\n \n         if (off >= h->endpages)\n           break;\n \n         page = (struct ntreg_hbin_page *) ((char *) h->addr + off);\n         if (page->magic[0] == 'h' &&\n             page->magic[1] == 'b' &&\n             page->magic[2] == 'i' &&\n             page->magic[3] == 'n') {\n           DEBUG (2, \"found next page by seeking at 0x%zx\", off);\n           found = 1;\n           break;\n         }\n       }\n \n       if (!found) {\n         DEBUG (2, \"page not found and end of pages section reached\");\n         break;\n       }\n     }\n \n     size_t page_size = le32toh (page->page_size);\n     DEBUG (2, \"page at 0x%zx, size %zu\", off, page_size);\n     pages++;\n     if (page_size < smallest_page) smallest_page = page_size;\n     if (page_size > largest_page) largest_page = page_size;\n \n     if (page_size <= sizeof (struct ntreg_hbin_page) ||\n         (page_size & 0x0fff) != 0) {\n       SET_ERRNO (ENOTSUP,\n                  \"%s: page size %zu at 0x%zx, bad registry\",\n                  filename, page_size, off);\n       goto error;\n     }\n \n     if (off + page_size > h->size) {\n       SET_ERRNO (ENOTSUP,\n                  \"%s: page size %zu at 0x%zx extends beyond end of file, bad registry\",\n                  filename, page_size, off);\n       goto error;\n     }\n \n     size_t page_offset = le32toh(page->offset_first) + 0x1000;\n \n     if (page_offset != off) {\n       SET_ERRNO (ENOTSUP,\n                  \"%s: declared page offset (0x%zx) does not match computed \"\n                  \"offset (0x%zx), bad registry\",\n                  filename, page_offset, off);\n       goto error;\n     }\n \n     size_t blkoff;\n     struct ntreg_hbin_block *block;\n     size_t seg_len;\n     for (blkoff = off + 0x20;\n          blkoff < off + page_size;\n          blkoff += seg_len) {\n       blocks++;\n \n       int is_root = blkoff == h->rootoffs;\n       if (is_root)\n         seen_root_block = 1;\n \n       block = (struct ntreg_hbin_block *) ((char *) h->addr + blkoff);\n       int used;\n       seg_len = block_len (h, blkoff, &used);\n #pragma GCC diagnostic push\n #pragma GCC diagnostic ignored \"-Wstrict-overflow\"\n       if (seg_len <= 4 || (seg_len & 3) != 0) {\n #pragma GCC diagnostic pop\n         if (is_root || !h->unsafe) {\n           SET_ERRNO (ENOTSUP,\n// bug_start\n                     \"%s, the block at 0x%zx has invalid size %\" PRIu32\n                     \", bad registry\",\n// bug_end\n                      filename, blkoff, le32toh (block->seg_len));\n           goto error;\n         } else {\n           DEBUG (2,\n                  \"%s: block at 0x%zx has invalid size %\" PRIu32 \", skipping\",\n                  filename, blkoff, le32toh (block->seg_len));\n           break;\n         }\n// bug_start\n// bug_end\n       }\n \n       if (h->msglvl >= 2) {\n         unsigned char *id = (unsigned char *) block->id;\n         int id0 = id[0], id1 = id[1];\n \n         fprintf (stderr, \"%s: %s: \"\n                  \"%s block id %d,%d (%c%c) at 0x%zx size %zu%s\\n\",\n                  \"hivex\", __func__,\n                  used ? \"used\" : \"free\",\n                  id0, id1,\n                  c_isprint (id0) ? id0 : '.',\n                  c_isprint (id1) ? id1 : '.',\n                  blkoff,\n                  seg_len, is_root ? \" (root)\" : \"\");\n       }\n \n       blocks_bytes += seg_len;\n       if (seg_len < smallest_block) smallest_block = seg_len;\n       if (seg_len > largest_block) largest_block = seg_len;\n \n       if (is_root && !used)\n         bad_root_block = 1;\n \n       if (used) {\n         used_blocks++;\n         used_size += seg_len;\n \n         if (is_root && (block->id[0] != 'n' || block->id[1] != 'k'))\n           bad_root_block = 1;\n \n         BITMAP_SET (h->bitmap, blkoff);\n       }\n     }\n   }\n \n   if (!seen_root_block) {\n     SET_ERRNO (ENOTSUP, \"%s: no root block found\", filename);\n     goto error;\n   }\n \n   if (bad_root_block) {\n     SET_ERRNO (ENOTSUP, \"%s: bad root block (free or not nk)\", filename);\n     goto error;\n   }\n \n   DEBUG (1, \"successfully read Windows Registry hive file:\\n\"\n          \"  pages:          %zu [sml: %zu, lge: %zu]\\n\"\n          \"  blocks:         %zu [sml: %zu, avg: %zu, lge: %zu]\\n\"\n          \"  blocks used:    %zu\\n\"\n          \"  bytes used:     %zu\",\n          pages, smallest_page, largest_page,\n          blocks, smallest_block, blocks_bytes / blocks, largest_block,\n          used_blocks, used_size);\n \n   return h;\n \n  error:;\n   int err = errno;\n   if (h) {\n     free (h->bitmap);\n     if (h->addr && h->size && h->addr != MAP_FAILED) {\n       if (!h->writable)\n         munmap (h->addr, h->size);\n       else\n         free (h->addr);\n     }\n     if (h->fd >= 0)\n       close (h->fd);\n     free (h->filename);\n     free (h);\n   }\n   errno = err;\n   return NULL;\n }\n \n", "target": "// fix_start\n                     \"%s, the block at 0x%zx size %\" PRIu32\n                     \" <= 4 or not a multiple of 4, bad registry\",\n// fix_end\n// fix_start\n      }\n\n      if (blkoff + seg_len > off + page_size) {\n        SET_ERRNO (ENOTSUP,\n                   \"%s, the block at 0x%zx size %\" PRIu32\n                   \" extends beyond the current page, bad registry\",\n                   filename, blkoff, le32toh (block->seg_len));\n        goto error;\n// fix_end\n", "cwe": "CWE-125", "cwe_name": "Out-of-bounds Read", "cve": "CVE-2021-3504", "cve_desc": "A flaw was found in the hivex library in versions before 1.3.20. It is caused due to a lack of bounds check within the hivex_open function. An attacker could input a specially crafted Windows Registry (hive) file which would cause hivex to read memory beyond its normal bounds or cause the program to crash. The highest threat from this vulnerability is to system availability.", "project": "hivex", "idx": 205584}
{"source": " static MSUSB_PIPE_DESCRIPTOR** msusb_mspipes_read(wStream* s, UINT32 NumberOfPipes)\n {\n \tUINT32 pnum;\n \tMSUSB_PIPE_DESCRIPTOR** MsPipes;\n \n// bug_start\n\tif (Stream_GetRemainingCapacity(s) < 12 * NumberOfPipes)\n// bug_end\n \t\treturn NULL;\n \n \tMsPipes = (MSUSB_PIPE_DESCRIPTOR**)calloc(NumberOfPipes, sizeof(MSUSB_PIPE_DESCRIPTOR*));\n \n \tif (!MsPipes)\n \t\treturn NULL;\n \n \tfor (pnum = 0; pnum < NumberOfPipes; pnum++)\n \t{\n \t\tMSUSB_PIPE_DESCRIPTOR* MsPipe = msusb_mspipe_new();\n \n \t\tif (!MsPipe)\n \t\t\tgoto out_error;\n \n \t\tStream_Read_UINT16(s, MsPipe->MaximumPacketSize);\n \t\tStream_Seek(s, 2);\n \t\tStream_Read_UINT32(s, MsPipe->MaximumTransferSize);\n \t\tStream_Read_UINT32(s, MsPipe->PipeFlags);\n \t\tMsPipes[pnum] = MsPipe;\n \t}\n \n \treturn MsPipes;\n out_error:\n \n \tfor (pnum = 0; pnum < NumberOfPipes; pnum++)\n \t\tfree(MsPipes[pnum]);\n \n \tfree(MsPipes);\n \treturn NULL;\n }\n \n", "target": "// fix_start\n\tif (Stream_GetRemainingCapacity(s) / 12 < NumberOfPipes)\n// fix_end\n", "cwe": "CWE-190", "cwe_name": "Integer Overflow or Wraparound", "cve": "CVE-2020-11039", "cve_desc": "In FreeRDP less than or equal to 2.0.0, when using a manipulated server with USB redirection enabled (nearly) arbitrary memory can be read and written due to integer overflows in length checks. This has been patched in 2.1.0.", "project": "FreeRDP", "idx": 205671}
{"source": " static MagickBooleanType WriteAnimatedWEBPImage(const ImageInfo *image_info,\n   Image *image,WebPConfig *configure,WebPMemoryWriter *writer_info,\n   ExceptionInfo *exception)\n {\n   Image\n     *first_image;\n \n   PictureMemory\n     *current,\n     *head;\n \n   size_t\n     effective_delta = 0,\n     frame_timestamp = 0;\n \n   WebPAnimEncoder\n     *enc;\n \n   WebPAnimEncoderOptions\n     enc_options;\n \n   WebPData\n     webp_data;\n \n   WebPPicture\n     picture;\n \n   WebPAnimEncoderOptionsInit(&enc_options);\n   if (image_info->verbose)\n     enc_options.verbose = 1;\n \n   image=CoalesceImages(image, exception);\n   first_image=image;\n   enc=WebPAnimEncoderNew((int) image->page.width,(int) image->page.height,\n     &enc_options);\n \n   head=(PictureMemory *) calloc(sizeof(*head),1);\n   current=head;\n \n   while (image != NULL)\n   {\n     if (WebPPictureInit(&picture) == 0)\n       ThrowWriterException(ResourceLimitError,\"UnableToEncodeImageFile\");\n \n     WriteSingleWEBPImage(image_info, image, &picture, current, exception);\n \n// bug_start\n    effective_delta = image->delay*1000/image->ticks_per_second;\n// bug_end\n     if (effective_delta < 10)\n       effective_delta = 100;\n     frame_timestamp+=effective_delta;\n \n     WebPAnimEncoderAdd(enc,&picture,(int) frame_timestamp,configure);\n \n     image = GetNextImageInList(image);\n     current->next=(PictureMemory *) calloc(sizeof(*head), 1);\n     current = current->next;\n   }\n   webp_data.bytes=writer_info->mem;\n   webp_data.size=writer_info->size;\n   WebPAnimEncoderAssemble(enc, &webp_data);\n   WebPMemoryWriterClear(writer_info);\n   writer_info->size=webp_data.size;\n   writer_info->mem=(unsigned char *) webp_data.bytes;\n   WebPAnimEncoderDelete(enc);\n   DestroyImageList(first_image);\n   FreePictureMemoryList(head);\n   return(MagickTrue);\n }\n \n", "target": "// fix_start\n    effective_delta = image->delay*1000*PerceptibleReciprocal(\n      image->ticks_per_second);\n// fix_end\n", "cwe": "CWE-369", "cwe_name": "Divide By Zero", "cve": "CVE-2021-20245", "cve_desc": "A flaw was found in ImageMagick in coders/webp.c. An attacker who submits a crafted file that is processed by ImageMagick could trigger undefined behavior in the form of math division by zero. The highest threat from this vulnerability is to system availability.", "project": "ImageMagick6", "idx": 205720}
{"source": " MagickExport double GenerateDifferentialNoise(RandomInfo *random_info,\n   const Quantum pixel,const NoiseType noise_type,const MagickRealType attenuate)\n {\n #define SigmaUniform  (attenuate*0.015625)\n #define SigmaGaussian  (attenuate*0.015625)\n #define SigmaImpulse  (attenuate*0.1)\n #define SigmaLaplacian (attenuate*0.0390625)\n #define SigmaMultiplicativeGaussian  (attenuate*0.5)\n #define SigmaPoisson  (attenuate*12.5)\n #define SigmaRandom  (attenuate)\n #define TauGaussian  (attenuate*0.078125)\n \n   double\n     alpha,\n     beta,\n     noise,\n     sigma;\n \n   alpha=GetPseudoRandomValue(random_info);\n   switch (noise_type)\n   {\n     case UniformNoise:\n     default:\n     {\n       noise=(double) (pixel+QuantumRange*SigmaUniform*(alpha-0.5));\n       break;\n     }\n     case GaussianNoise:\n     {\n       double\n         gamma,\n         tau;\n \n       if (fabs(alpha) < MagickEpsilon)\n         alpha=1.0;\n       beta=GetPseudoRandomValue(random_info);\n       gamma=sqrt(-2.0*log(alpha));\n       sigma=gamma*cos((double) (2.0*MagickPI*beta));\n       tau=gamma*sin((double) (2.0*MagickPI*beta));\n       noise=(double) (pixel+sqrt((double) pixel)*SigmaGaussian*sigma+\n         QuantumRange*TauGaussian*tau);\n       break;\n     }\n     case ImpulseNoise:\n     {\n       if (alpha < (SigmaImpulse/2.0))\n         noise=0.0;\n       else\n         if (alpha >= (1.0-(SigmaImpulse/2.0)))\n           noise=(double) QuantumRange;\n         else\n           noise=(double) pixel;\n       break;\n     }\n     case LaplacianNoise:\n     {\n       if (alpha <= 0.5)\n         {\n           if (alpha <= MagickEpsilon)\n             noise=(double) (pixel-QuantumRange);\n           else\n             noise=(double) (pixel+QuantumRange*SigmaLaplacian*log(2.0*alpha)+\n               0.5);\n           break;\n         }\n       beta=1.0-alpha;\n       if (beta <= (0.5*MagickEpsilon))\n         noise=(double) (pixel+QuantumRange);\n       else\n         noise=(double) (pixel-QuantumRange*SigmaLaplacian*log(2.0*beta)+0.5);\n       break;\n     }\n     case MultiplicativeGaussianNoise:\n     {\n       sigma=1.0;\n       if (alpha > MagickEpsilon)\n         sigma=sqrt(-2.0*log(alpha));\n       beta=GetPseudoRandomValue(random_info);\n       noise=(double) (pixel+pixel*SigmaMultiplicativeGaussian*sigma*\n         cos((double) (2.0*MagickPI*beta))/2.0);\n       break;\n     }\n     case PoissonNoise:\n     {\n       double\n         poisson;\n \n       ssize_t\n         i;\n \n       poisson=exp(-SigmaPoisson*QuantumScale*pixel);\n       for (i=0; alpha > poisson; i++)\n       {\n         beta=GetPseudoRandomValue(random_info);\n         alpha*=beta;\n       }\n// bug_start\n      noise=(double) (QuantumRange*i/SigmaPoisson);\n// bug_end\n       break;\n     }\n     case RandomNoise:\n     {\n       noise=(double) (QuantumRange*SigmaRandom*alpha);\n       break;\n     }\n   }\n   return(noise);\n }\n \n", "target": "// fix_start\n      noise=(double) (QuantumRange*i*PerceptibleReciprocal(SigmaPoisson));\n// fix_end\n", "cwe": "CWE-369", "cwe_name": "Divide By Zero", "cve": "CVE-2021-20176", "cve_desc": "A divide-by-zero flaw was found in ImageMagick 6.9.11-57 and 7.0.10-57 in gem.c. This flaw allows an attacker who submits a crafted file that is processed by ImageMagick to trigger undefined behavior through a division by zero. The highest threat from this vulnerability is to system availability.", "project": "ImageMagick6", "idx": 205775}
{"source": " srs_timestamp_check(srs_t *srs, const char *stamp)\n {\n \tconst char\t*sp;\n \tchar\t\t*bp;\n \tint\t\t\t off;\n \ttime_t\t\t now;\n \ttime_t\t\t then;\n \n// bug_start\n// bug_end\n \tthen = 0;\n \tfor (sp = stamp; *sp; sp++) {\n \t\tbp = strchr(SRS_TIME_BASECHARS, toupper(*sp));\n \t\tif (bp == NULL)\n \t\t\treturn SRS_EBADTIMESTAMPCHAR;\n \t\toff = bp - SRS_TIME_BASECHARS;\n \t\tthen = (then << SRS_TIME_BASEBITS) | off;\n \t}\n \n \ttime(&now);\n \tnow = (now / SRS_TIME_PRECISION) % SRS_TIME_SLOTS;\n \twhile (now < then)\n \t\tnow = now + SRS_TIME_SLOTS;\n \n \tif (now <= then + srs->maxage)\n \t\treturn SRS_SUCCESS;\n \treturn SRS_ETIMESTAMPOUTOFDATE;\n }\n \n", "target": "// fix_start\n\tif (strlen(stamp) != 2) return SRS_ETIMESTAMPOUTOFDATE;\n// fix_end\n", "cwe": "CWE-703", "cwe_name": "Improper Check or Handling of Exceptional Conditions", "cve": "CVE-2020-35573", "cve_desc": "srs2.c in PostSRSd before 1.10 allows remote attackers to cause a denial of service (CPU consumption) via a long timestamp tag in an SRS address.", "project": "postsrsd", "idx": 205810}
{"source": " static rsRetVal qAddDirect(qqueue_t *pThis, void* pUsr)\n {\n \tbatch_t singleBatch;\n \tbatch_obj_t batchObj;\n// bug_start\n// bug_end\n \tDEFiRet;\n \n \tASSERT(pThis != NULL);\n \n \tmemset(&batchObj, 0, sizeof(batch_obj_t));\n \tmemset(&singleBatch, 0, sizeof(batch_t));\n \tbatchObj.state = BATCH_STATE_RDY;\n \tbatchObj.pUsrp = (obj_t*) pUsr;\n \tbatchObj.bFilterOK = 1;\n \tsingleBatch.nElem = 1;\n \tsingleBatch.pElem = &batchObj;\n \tiRet = pThis->pConsumer(pThis->pUsr, &singleBatch, &pThis->bShutdownImmediate);\n// bug_start\n// bug_end\n \tobjDestruct(pUsr);\n \n \tRETiRet;\n }\n \n", "target": "// fix_start\n\tint i;\n// fix_end\n// fix_start\n\tfor(i = 0 ; i < CONF_OMOD_NUMSTRINGS_MAXSIZE ; ++i) {\n\t\tfree(batchObj.staticActStrings[i]);\n\t}\n// fix_end\n", "cwe": "CWE-772", "cwe_name": "Missing Release of Resource after Effective Lifetime", "cve": "CVE-2011-1488", "cve_desc": "A memory leak in rsyslog before 5.7.6 was found in the way deamon processed log messages are logged when $RepeatedMsgReduction was enabled. A local attacker could use this flaw to cause a denial of the rsyslogd daemon service by crashing the service via a sequence of repeated log messages sent within short periods of time.", "project": "rsyslog", "idx": 205840}
{"source": " GC_API GC_ATTR_MALLOC void * GC_CALL GC_calloc_explicitly_typed(size_t n,\n                                                         size_t lb, GC_descr d)\n {\n     word *op;\n     size_t lg;\n     GC_descr simple_descr;\n     complex_descriptor *complex_descr;\n     int descr_type;\n     struct LeafDescriptor leaf;\n \n     GC_ASSERT(GC_explicit_typing_initialized);\n     descr_type = GC_make_array_descriptor((word)n, (word)lb, d, &simple_descr,\n                                           &complex_descr, &leaf);\n// bug_start\n// bug_end\n     switch(descr_type) {\n         case NO_MEM: return(0);\n// bug_start\n        case SIMPLE: return(GC_malloc_explicitly_typed(n*lb, simple_descr));\n// bug_end\n         case LEAF:\n// bug_start\n            lb *= n;\n// bug_end\n             lb += sizeof(struct LeafDescriptor) + TYPD_EXTRA_BYTES;\n             break;\n         case COMPLEX:\n// bug_start\n            lb *= n;\n// bug_end\n             lb += TYPD_EXTRA_BYTES;\n             break;\n     }\n     op = GC_malloc_kind(lb, GC_array_kind);\n     if (EXPECT(NULL == op, FALSE))\n         return NULL;\n     lg = SMALL_OBJ(lb) ? GC_size_map[lb] : BYTES_TO_GRANULES(GC_size(op));\n     if (descr_type == LEAF) {\n        volatile struct LeafDescriptor * lp =\n            (struct LeafDescriptor *)\n                (op + GRANULES_TO_WORDS(lg)\n                 - (BYTES_TO_WORDS(sizeof(struct LeafDescriptor)) + 1));\n \n        lp -> ld_tag = LEAF_TAG;\n        lp -> ld_size = leaf.ld_size;\n        lp -> ld_nelements = leaf.ld_nelements;\n        lp -> ld_descriptor = leaf.ld_descriptor;\n        ((volatile word *)op)[GRANULES_TO_WORDS(lg) - 1] = (word)lp;\n    } else {\n #    ifndef GC_NO_FINALIZATION\n        size_t lw = GRANULES_TO_WORDS(lg);\n \n        op[lw - 1] = (word)complex_descr;\n        if (EXPECT(GC_general_register_disappearing_link(\n                                                 (void **)(op + lw - 1), op)\n                   == GC_NO_MEMORY, FALSE))\n #    endif\n        {\n             return GC_malloc(lb);\n        }\n    }\n    return op;\n }\n \n", "target": "// fix_start\n    if ((lb | n) > GC_SQRT_SIZE_MAX\n        && lb > 0 && n > GC_SIZE_MAX / lb)\n      return NULL;\n    lb *= n;\n// fix_end\n// fix_start\n        case SIMPLE:\n            return GC_malloc_explicitly_typed(lb, simple_descr);\n// fix_end\n// fix_start\n// fix_end\n// fix_start\n// fix_end\n", "cwe": "CWE-119", "cwe_name": "Improper Restriction of Operations within the Bounds of a Memory Buffer", "cve": "CVE-2016-9427", "cve_desc": "Integer overflow vulnerability in bdwgc before 2016-09-27 allows attackers to cause client of bdwgc denial of service (heap buffer overflow crash) and possibly execute arbitrary code via huge allocation.", "project": "bdwgc", "idx": 205872}
{"source": " vmod_append(VRT_CTX, VCL_HEADER hdr, VCL_STRANDS s)\n {\n \tstruct http *hp;\n \tstruct strands st[1];\n \tconst char *p[s->n + 2];\n \tconst char *b;\n \n \tCHECK_OBJ_NOTNULL(ctx, VRT_CTX_MAGIC);\n \n \tp[0] = hdr->what + 1;\n \tp[1] = \" \";\n \tAN(memcpy(p + 2, s->p, s->n * sizeof *s->p));\n \tst->n = s->n + 2;\n \tst->p = p;\n \n \tb = VRT_StrandsWS(ctx->ws, NULL, st);\n// bug_start\n// bug_end\n \n \thp = VRT_selecthttp(ctx, hdr->where);\n \thttp_SetHeader(hp, b);\n }\n \n", "target": "// fix_start\n\tif (b == NULL) {\n\t\tVRT_fail(ctx, \"vmod_header: workspace allocation failure\");\n\t\treturn;\n\t}\n// fix_end\n", "cwe": "CWE-476", "cwe_name": "NULL Pointer Dereference", "cve": "CVE-2021-28543", "cve_desc": "Varnish varnish-modules before 0.17.1 allows remote attackers to cause a denial of service (daemon restart) in some configurations. This does not affect organizations that only install the Varnish Cache product; however, it is common to install both Varnish Cache and varnish-modules. Specifically, an assertion failure or NULL pointer dereference can be triggered in Varnish Cache through the varnish-modules header.append() and header.copy() functions. For some Varnish Configuration Language (VCL) files, this gives remote clients an opportunity to cause a Varnish Cache restart. A restart reduces overall availability and performance due to an increased number of cache misses, and may cause higher load on backend servers.", "project": "varnish-modules", "idx": 205887}
{"source": " unsigned long perf_instruction_pointer(struct pt_regs *regs)\n {\n \tbool use_siar = regs_use_siar(regs);\n \tunsigned long siar = mfspr(SPRN_SIAR);\n \n// bug_start\n\tif (ppmu->flags & PPMU_P10_DD1) {\n// bug_end\n \t\tif (siar)\n \t\t\treturn siar;\n \t\telse\n \t\t\treturn regs->nip;\n \t} else if (use_siar && siar_valid(regs))\n \t\treturn mfspr(SPRN_SIAR) + perf_ip_adjust(regs);\n \telse if (use_siar)\n \t\treturn 0;\n \telse\n \t\treturn regs->nip;\n }\n \n", "target": "// fix_start\n\tif (ppmu && (ppmu->flags & PPMU_P10_DD1)) {\n// fix_end\n", "cwe": "CWE-476", "cwe_name": "NULL Pointer Dereference", "cve": "CVE-2021-38200", "cve_desc": "arch/powerpc/perf/core-book3s.c in the Linux kernel before 5.12.13, on systems with perf_event_paranoid=-1 and no specific PMU driver support registered, allows local users to cause a denial of service (perf_instruction_pointer NULL pointer dereference and OOPS) via a \"perf record\" command.", "project": "linux", "idx": 205900}
{"source": " SAPI_API SAPI_TREAT_DATA_FUNC(php_default_treat_data)\n {\n \tchar *res = NULL, *var, *val, *separator = NULL;\n \tconst char *c_var;\n \tzval array;\n \tint free_buffer = 0;\n \tchar *strtok_buf = NULL;\n \tzend_long count = 0;\n \n \tZVAL_UNDEF(&array);\n \tswitch (arg) {\n \t\tcase PARSE_POST:\n \t\tcase PARSE_GET:\n \t\tcase PARSE_COOKIE:\n \t\t\tarray_init(&array);\n \t\t\tswitch (arg) {\n \t\t\t\tcase PARSE_POST:\n \t\t\t\t\tzval_ptr_dtor(&PG(http_globals)[TRACK_VARS_POST]);\n \t\t\t\t\tZVAL_COPY_VALUE(&PG(http_globals)[TRACK_VARS_POST], &array);\n \t\t\t\t\tbreak;\n \t\t\t\tcase PARSE_GET:\n \t\t\t\t\tzval_ptr_dtor(&PG(http_globals)[TRACK_VARS_GET]);\n \t\t\t\t\tZVAL_COPY_VALUE(&PG(http_globals)[TRACK_VARS_GET], &array);\n \t\t\t\t\tbreak;\n \t\t\t\tcase PARSE_COOKIE:\n \t\t\t\t\tzval_ptr_dtor(&PG(http_globals)[TRACK_VARS_COOKIE]);\n \t\t\t\t\tZVAL_COPY_VALUE(&PG(http_globals)[TRACK_VARS_COOKIE], &array);\n \t\t\t\t\tbreak;\n \t\t\t}\n \t\t\tbreak;\n \t\tdefault:\n \t\t\tZVAL_COPY_VALUE(&array, destArray);\n \t\t\tbreak;\n \t}\n \n \tif (arg == PARSE_POST) {\n \t\tsapi_handle_post(&array);\n \t\treturn;\n \t}\n \n \tif (arg == PARSE_GET) {\n \t\tc_var = SG(request_info).query_string;\n \t\tif (c_var && *c_var) {\n \t\t\tres = (char *) estrdup(c_var);\n \t\t\tfree_buffer = 1;\n \t\t} else {\n \t\t\tfree_buffer = 0;\n \t\t}\n \t} else if (arg == PARSE_COOKIE) {\n \t\tc_var = SG(request_info).cookie_data;\n \t\tif (c_var && *c_var) {\n \t\t\tres = (char *) estrdup(c_var);\n \t\t\tfree_buffer = 1;\n \t\t} else {\n \t\t\tfree_buffer = 0;\n \t\t}\n \t} else if (arg == PARSE_STRING) {\n \t\tres = str;\n \t\tfree_buffer = 1;\n \t}\n \n \tif (!res) {\n \t\treturn;\n \t}\n \n \tswitch (arg) {\n \t\tcase PARSE_GET:\n \t\tcase PARSE_STRING:\n \t\t\tseparator = PG(arg_separator).input;\n \t\t\tbreak;\n \t\tcase PARSE_COOKIE:\n \t\t\tseparator = \";\\0\";\n \t\t\tbreak;\n \t}\n \n \tvar = php_strtok_r(res, separator, &strtok_buf);\n \n \twhile (var) {\n \t\tval = strchr(var, '=');\n \n \t\tif (arg == PARSE_COOKIE) {\n \t\t\twhile (isspace(*var)) {\n \t\t\t\tvar++;\n \t\t\t}\n \t\t\tif (var == val || *var == '\\0') {\n \t\t\t\tgoto next_cookie;\n \t\t\t}\n \t\t}\n \n \t\tif (++count > PG(max_input_vars)) {\n \t\t\tphp_error_docref(NULL, E_WARNING, \"Input variables exceeded \" ZEND_LONG_FMT \". To increase the limit change max_input_vars in php.ini.\", PG(max_input_vars));\n \t\t\tbreak;\n \t\t}\n \n \t\tif (val) {\n \t\t\tsize_t val_len;\n \t\t\tsize_t new_val_len;\n \n \t\t\t*val++ = '\\0';\n// bug_start\n\t\t\tphp_url_decode(var, strlen(var));\n// bug_end\n \t\t\tval_len = php_url_decode(val, strlen(val));\n \t\t\tval = estrndup(val, val_len);\n \t\t\tif (sapi_module.input_filter(arg, var, &val, val_len, &new_val_len)) {\n \t\t\t\tphp_register_variable_safe(var, val, new_val_len, &array);\n \t\t\t}\n \t\t\tefree(val);\n \t\t} else {\n \t\t\tsize_t val_len;\n \t\t\tsize_t new_val_len;\n \n// bug_start\n\t\t\tphp_url_decode(var, strlen(var));\n// bug_end\n \t\t\tval_len = 0;\n \t\t\tval = estrndup(\"\", val_len);\n \t\t\tif (sapi_module.input_filter(arg, var, &val, val_len, &new_val_len)) {\n \t\t\t\tphp_register_variable_safe(var, val, new_val_len, &array);\n \t\t\t}\n \t\t\tefree(val);\n \t\t}\n next_cookie:\n \t\tvar = php_strtok_r(NULL, separator, &strtok_buf);\n \t}\n \n \tif (free_buffer) {\n \t\tefree(res);\n \t}\n }\n \n", "target": "// fix_start\n\t\t\tif (arg != PARSE_COOKIE) {\n\t\t\t\tphp_url_decode(var, strlen(var));\n\t\t\t}\n// fix_end\n// fix_start\n\t\t\tif (arg != PARSE_COOKIE) {\n\t\t\t\tphp_url_decode(var, strlen(var));\n\t\t\t}\n// fix_end\n", "cwe": "CWE-565", "cwe_name": "Reliance on Cookies without Validation and Integrity Checking", "cve": "CVE-2020-7070", "cve_desc": "In PHP versions 7.2.x below 7.2.34, 7.3.x below 7.3.23 and 7.4.x below 7.4.11, when PHP is processing incoming HTTP cookie values, the cookie names are url-decoded. This may lead to cookies with prefixes like __Host confused with cookies that decode to such prefix, thus leading to an attacker being able to forge cookie which is supposed to be secure. See also CVE-2020-8184 for more information.", "project": "php-src", "idx": 205909}
{"source": " bool do_notify_parent(struct task_struct *tsk, int sig)\n {\n \tstruct kernel_siginfo info;\n \tunsigned long flags;\n \tstruct sighand_struct *psig;\n \tbool autoreap = false;\n \tu64 utime, stime;\n \n \tBUG_ON(sig == -1);\n \n  \tBUG_ON(task_is_stopped_or_traced(tsk));\n \n \tBUG_ON(!tsk->ptrace &&\n \t       (tsk->group_leader != tsk || !thread_group_empty(tsk)));\n \n \tdo_notify_pidfd(tsk);\n \n \tif (sig != SIGCHLD) {\n// bug_start\n\t\tif (tsk->parent_exec_id != tsk->parent->self_exec_id)\n// bug_end\n \t\t\tsig = SIGCHLD;\n \t}\n \n \tclear_siginfo(&info);\n \tinfo.si_signo = sig;\n \tinfo.si_errno = 0;\n \trcu_read_lock();\n \tinfo.si_pid = task_pid_nr_ns(tsk, task_active_pid_ns(tsk->parent));\n \tinfo.si_uid = from_kuid_munged(task_cred_xxx(tsk->parent, user_ns),\n \t\t\t\t       task_uid(tsk));\n \trcu_read_unlock();\n \n \ttask_cputime(tsk, &utime, &stime);\n \tinfo.si_utime = nsec_to_clock_t(utime + tsk->signal->utime);\n \tinfo.si_stime = nsec_to_clock_t(stime + tsk->signal->stime);\n \n \tinfo.si_status = tsk->exit_code & 0x7f;\n \tif (tsk->exit_code & 0x80)\n \t\tinfo.si_code = CLD_DUMPED;\n \telse if (tsk->exit_code & 0x7f)\n \t\tinfo.si_code = CLD_KILLED;\n \telse {\n \t\tinfo.si_code = CLD_EXITED;\n \t\tinfo.si_status = tsk->exit_code >> 8;\n \t}\n \n \tpsig = tsk->parent->sighand;\n \tspin_lock_irqsave(&psig->siglock, flags);\n \tif (!tsk->ptrace && sig == SIGCHLD &&\n \t    (psig->action[SIGCHLD-1].sa.sa_handler == SIG_IGN ||\n \t     (psig->action[SIGCHLD-1].sa.sa_flags & SA_NOCLDWAIT))) {\n \t\tautoreap = true;\n \t\tif (psig->action[SIGCHLD-1].sa.sa_handler == SIG_IGN)\n \t\t\tsig = 0;\n \t}\n \tif (valid_signal(sig) && sig)\n \t\t__group_send_sig_info(sig, &info, tsk->parent);\n \t__wake_up_parent(tsk, tsk->parent);\n \tspin_unlock_irqrestore(&psig->siglock, flags);\n \n \treturn autoreap;\n }\n \n", "target": "// fix_start\n\t\tif (tsk->parent_exec_id != READ_ONCE(tsk->parent->self_exec_id))\n// fix_end\n", "cwe": "CWE-190", "cwe_name": "Integer Overflow or Wraparound", "cve": "CVE-2020-12826", "cve_desc": "A signal access-control issue was discovered in the Linux kernel before 5.6.5, aka CID-7395ea4e65c2. Because exec_id in include/linux/sched.h is only 32 bits, an integer overflow can interfere with a do_notify_parent protection mechanism. A child process can send an arbitrary signal to a parent process in a different security domain. Exploitation limitations include the amount of elapsed time before an integer overflow occurs, and the lack of scenarios where signals to a parent process present a substantial operational threat.", "project": "linux", "idx": 205956}
{"source": " static struct ip *ip_reass(Slirp *slirp, struct ip *ip, struct ipq *fp)\n {\n     register struct mbuf *m = dtom(slirp, ip);\n     register struct ipasfrag *q;\n     int hlen = ip->ip_hl << 2;\n     int i, next;\n \n     DEBUG_CALL(\"ip_reass\");\n     DEBUG_ARG(\"ip = %p\", ip);\n     DEBUG_ARG(\"fp = %p\", fp);\n     DEBUG_ARG(\"m = %p\", m);\n \n     m->m_data += hlen;\n     m->m_len -= hlen;\n \n     if (fp == NULL) {\n         struct mbuf *t = m_get(slirp);\n \n         if (t == NULL) {\n             goto dropfrag;\n         }\n         fp = mtod(t, struct ipq *);\n         insque(&fp->ip_link, &slirp->ipq.ip_link);\n         fp->ipq_ttl = IPFRAGTTL;\n         fp->ipq_p = ip->ip_p;\n         fp->ipq_id = ip->ip_id;\n         fp->frag_link.next = fp->frag_link.prev = &fp->frag_link;\n         fp->ipq_src = ip->ip_src;\n         fp->ipq_dst = ip->ip_dst;\n         q = (struct ipasfrag *)fp;\n         goto insert;\n     }\n \n     for (q = fp->frag_link.next; q != (struct ipasfrag *)&fp->frag_link;\n          q = q->ipf_next)\n         if (q->ipf_off > ip->ip_off)\n             break;\n \n     if (q->ipf_prev != &fp->frag_link) {\n         struct ipasfrag *pq = q->ipf_prev;\n         i = pq->ipf_off + pq->ipf_len - ip->ip_off;\n         if (i > 0) {\n             if (i >= ip->ip_len)\n                 goto dropfrag;\n             m_adj(dtom(slirp, ip), i);\n             ip->ip_off += i;\n             ip->ip_len -= i;\n         }\n     }\n \n     while (q != (struct ipasfrag *)&fp->frag_link &&\n            ip->ip_off + ip->ip_len > q->ipf_off) {\n         i = (ip->ip_off + ip->ip_len) - q->ipf_off;\n         if (i < q->ipf_len) {\n             q->ipf_len -= i;\n             q->ipf_off += i;\n             m_adj(dtom(slirp, q), i);\n             break;\n         }\n         q = q->ipf_next;\n         m_free(dtom(slirp, q->ipf_prev));\n         ip_deq(q->ipf_prev);\n     }\n \n insert:\n     ip_enq(iptofrag(ip), q->ipf_prev);\n     next = 0;\n     for (q = fp->frag_link.next; q != (struct ipasfrag *)&fp->frag_link;\n          q = q->ipf_next) {\n         if (q->ipf_off != next)\n             return NULL;\n         next += q->ipf_len;\n     }\n     if (((struct ipasfrag *)(q->ipf_prev))->ipf_tos & 1)\n         return NULL;\n \n     q = fp->frag_link.next;\n     m = dtom(slirp, q);\n \n// bug_start\n// bug_end\n     q = (struct ipasfrag *)q->ipf_next;\n     while (q != (struct ipasfrag *)&fp->frag_link) {\n         struct mbuf *t = dtom(slirp, q);\n         q = (struct ipasfrag *)q->ipf_next;\n         m_cat(m, t);\n     }\n \n     q = fp->frag_link.next;\n \n// bug_start\n    if (m->m_flags & M_EXT) {\n// bug_end\n         int delta = (char *)q - m->m_dat;\n         q = (struct ipasfrag *)(m->m_ext + delta);\n     }\n \n     ip = fragtoip(q);\n     ip->ip_len = next;\n     ip->ip_tos &= ~1;\n     ip->ip_src = fp->ipq_src;\n     ip->ip_dst = fp->ipq_dst;\n     remque(&fp->ip_link);\n     (void)m_free(dtom(slirp, fp));\n     m->m_len += (ip->ip_hl << 2);\n     m->m_data -= (ip->ip_hl << 2);\n \n     return ip;\n \n dropfrag:\n     m_free(m);\n     return NULL;\n }\n \n", "target": "// fix_start\n    int was_ext = m->m_flags & M_EXT;\n\n// fix_end\n// fix_start\n    if (!was_ext && m->m_flags & M_EXT) {\n// fix_end\n", "cwe": "CWE-787", "cwe_name": "Out-of-bounds Write", "cve": "CVE-2019-14378", "cve_desc": "ip_reass in ip_input.c in libslirp 4.0.0 has a heap-based buffer overflow via a large packet because it mishandles a case involving the first fragment.", "project": "libslirp", "idx": 205959}
{"source": " int url_is_local_not_ssh(const char *url)\n {\n \tconst char *colon = strchr(url, ':');\n \tconst char *slash = strchr(url, '/');\n \treturn !colon || (slash && slash < colon) ||\n// bug_start\n\t\thas_dos_drive_prefix(url);\n// bug_end\n }\n \n", "target": "// fix_start\n\t\t(has_dos_drive_prefix(url) && is_valid_path(url));\n// fix_end\n", "cwe": "CWE-706", "cwe_name": "Use of Incorrectly-Resolved Name or Reference", "cve": "CVE-2019-1351", "cve_desc": "A tampering vulnerability exists when Git for Visual Studio improperly handles virtual drive paths, aka 'Git for Visual Studio Tampering Vulnerability'.", "project": "git", "idx": 206023}
{"source": " int nested_svm_vmrun(struct vcpu_svm *svm)\n {\n \tint ret;\n \tstruct vmcb *vmcb12;\n \tstruct vmcb *hsave = svm->nested.hsave;\n \tstruct vmcb *vmcb = svm->vmcb;\n \tstruct kvm_host_map map;\n \tu64 vmcb12_gpa;\n \n \tif (is_smm(&svm->vcpu)) {\n \t\tkvm_queue_exception(&svm->vcpu, UD_VECTOR);\n \t\treturn 1;\n \t}\n \n \tvmcb12_gpa = svm->vmcb->save.rax;\n \tret = kvm_vcpu_map(&svm->vcpu, gpa_to_gfn(vmcb12_gpa), &map);\n \tif (ret == -EINVAL) {\n \t\tkvm_inject_gp(&svm->vcpu, 0);\n \t\treturn 1;\n \t} else if (ret) {\n \t\treturn kvm_skip_emulated_instruction(&svm->vcpu);\n \t}\n \n \tret = kvm_skip_emulated_instruction(&svm->vcpu);\n \n \tvmcb12 = map.hva;\n \n \tif (WARN_ON_ONCE(!svm->nested.initialized))\n \t\treturn -EINVAL;\n \n// bug_start\n\tif (!nested_vmcb_checks(svm, vmcb12)) {\n// bug_end\n \t\tvmcb12->control.exit_code    = SVM_EXIT_ERR;\n \t\tvmcb12->control.exit_code_hi = 0;\n \t\tvmcb12->control.exit_info_1  = 0;\n \t\tvmcb12->control.exit_info_2  = 0;\n \t\tgoto out;\n \t}\n \n \ttrace_kvm_nested_vmrun(svm->vmcb->save.rip, vmcb12_gpa,\n \t\t\t       vmcb12->save.rip,\n \t\t\t       vmcb12->control.int_ctl,\n \t\t\t       vmcb12->control.event_inj,\n \t\t\t       vmcb12->control.nested_ctl);\n \n \ttrace_kvm_nested_intercepts(vmcb12->control.intercepts[INTERCEPT_CR] & 0xffff,\n \t\t\t\t    vmcb12->control.intercepts[INTERCEPT_CR] >> 16,\n \t\t\t\t    vmcb12->control.intercepts[INTERCEPT_EXCEPTION],\n \t\t\t\t    vmcb12->control.intercepts[INTERCEPT_WORD3],\n \t\t\t\t    vmcb12->control.intercepts[INTERCEPT_WORD4],\n \t\t\t\t    vmcb12->control.intercepts[INTERCEPT_WORD5]);\n \n \tkvm_clear_exception_queue(&svm->vcpu);\n \tkvm_clear_interrupt_queue(&svm->vcpu);\n \n \thsave->save.es     = vmcb->save.es;\n \thsave->save.cs     = vmcb->save.cs;\n \thsave->save.ss     = vmcb->save.ss;\n \thsave->save.ds     = vmcb->save.ds;\n \thsave->save.gdtr   = vmcb->save.gdtr;\n \thsave->save.idtr   = vmcb->save.idtr;\n \thsave->save.efer   = svm->vcpu.arch.efer;\n \thsave->save.cr0    = kvm_read_cr0(&svm->vcpu);\n \thsave->save.cr4    = svm->vcpu.arch.cr4;\n \thsave->save.rflags = kvm_get_rflags(&svm->vcpu);\n \thsave->save.rip    = kvm_rip_read(&svm->vcpu);\n \thsave->save.rsp    = vmcb->save.rsp;\n \thsave->save.rax    = vmcb->save.rax;\n \tif (npt_enabled)\n \t\thsave->save.cr3    = vmcb->save.cr3;\n \telse\n \t\thsave->save.cr3    = kvm_read_cr3(&svm->vcpu);\n \n \tcopy_vmcb_control_area(&hsave->control, &vmcb->control);\n \n \tsvm->nested.nested_run_pending = 1;\n \n \tif (enter_svm_guest_mode(svm, vmcb12_gpa, vmcb12))\n \t\tgoto out_exit_err;\n \n \tif (nested_svm_vmrun_msrpm(svm))\n \t\tgoto out;\n \n out_exit_err:\n \tsvm->nested.nested_run_pending = 0;\n \n \tsvm->vmcb->control.exit_code    = SVM_EXIT_ERR;\n \tsvm->vmcb->control.exit_code_hi = 0;\n \tsvm->vmcb->control.exit_info_1  = 0;\n \tsvm->vmcb->control.exit_info_2  = 0;\n \n \tnested_svm_vmexit(svm);\n \n out:\n \tkvm_vcpu_unmap(&svm->vcpu, &map, true);\n \n \treturn ret;\n }\n \n", "target": "// fix_start\n\tload_nested_vmcb_control(svm, &vmcb12->control);\n\n\tif (!nested_vmcb_check_save(svm, vmcb12) ||\n\t    !nested_vmcb_check_controls(&svm->nested.ctl)) {\n// fix_end\n", "cwe": "CWE-416", "cwe_name": "Use After Free", "cve": "CVE-2021-29657", "cve_desc": "arch/x86/kvm/svm/nested.c in the Linux kernel before 5.11.12 has a use-after-free in which an AMD KVM guest can bypass access control on host OS MSRs when there are nested guests, aka CID-a58d9166a756. This occurs because of a TOCTOU race condition associated with a VMCB12 double fetch in nested_svm_vmrun.", "project": "linux", "idx": 206039}
{"source": " static avifBool avifParseImageGridBox(avifImageGrid * grid, const uint8_t * raw, size_t rawLen)\n {\n     BEGIN_STREAM(s, raw, rawLen);\n \n     uint8_t version, flags;\n     CHECK(avifROStreamRead(&s, &version, 1));\n     if (version != 0) {\n         return AVIF_FALSE;\n     }\n     CHECK(avifROStreamRead(&s, &flags, 1));\n     CHECK(avifROStreamRead(&s, &grid->rows, 1));\n     CHECK(avifROStreamRead(&s, &grid->columns, 1));\n     ++grid->rows;\n     ++grid->columns;\n \n     uint32_t fieldLength = ((flags & 1) + 1) * 16;\n     if (fieldLength == 16) {\n         uint16_t outputWidth16, outputHeight16;\n         CHECK(avifROStreamReadU16(&s, &outputWidth16));\n         CHECK(avifROStreamReadU16(&s, &outputHeight16));\n         grid->outputWidth = outputWidth16;\n         grid->outputHeight = outputHeight16;\n     } else {\n         if (fieldLength != 32) {\n             return AVIF_FALSE;\n         }\n         CHECK(avifROStreamReadU32(&s, &grid->outputWidth));\n         CHECK(avifROStreamReadU32(&s, &grid->outputHeight));\n     }\n// bug_start\n// bug_end\n     return AVIF_TRUE;\n }\n \n", "target": "// fix_start\n    if (grid->outputWidth > AVIF_MAX_IMAGE_SIZE / grid->outputHeight) {\n        return AVIF_FALSE;\n    }\n// fix_end\n", "cwe": "CWE-703", "cwe_name": "Improper Check or Handling of Exceptional Conditions", "cve": "CVE-2020-36407", "cve_desc": "libavif 0.8.0 and 0.8.1 has an out-of-bounds write in avifDecoderDataFillImageGrid.", "project": "libavif", "idx": 206065}
{"source": " static int codeCompare(\n   Parse *pParse,\n   Expr *pLeft,\n   Expr *pRight,\n   int opcode,\n   int in1, int in2,\n   int dest,\n   int jumpIfNull,\n   int isCommuted\n ){\n   int p5;\n   int addr;\n   CollSeq *p4;\n \n// bug_start\n// bug_end\n   if( isCommuted ){\n     p4 = sqlite3BinaryCompareCollSeq(pParse, pRight, pLeft);\n   }else{\n     p4 = sqlite3BinaryCompareCollSeq(pParse, pLeft, pRight);\n   }\n   p5 = binaryCompareP5(pLeft, pRight, jumpIfNull);\n   addr = sqlite3VdbeAddOp4(pParse->pVdbe, opcode, in2, dest, in1,\n                            (void*)p4, P4_COLLSEQ);\n   sqlite3VdbeChangeP5(pParse->pVdbe, (u8)p5);\n   return addr;\n }\n \n", "target": "// fix_start\n  if( pParse->nErr ) return 0;\n// fix_end\n", "cwe": "CWE-755", "cwe_name": "Improper Handling of Exceptional Conditions", "cve": "CVE-2019-19924", "cve_desc": "SQLite 3.30.1 mishandles certain parser-tree rewriting, related to expr.c, vdbeaux.c, and window.c. This is caused by incorrect sqlite3WindowRewrite() error handling.", "project": "sqlite", "idx": 206235}
{"source": " static void vdbeVComment(Vdbe *p, const char *zFormat, va_list ap){\n   assert( p->nOp>0 || p->aOp==0 );\n// bug_start\n  assert( p->aOp==0 || p->aOp[p->nOp-1].zComment==0 || p->db->mallocFailed );\n// bug_end\n   if( p->nOp ){\n     assert( p->aOp );\n     sqlite3DbFree(p->db, p->aOp[p->nOp-1].zComment);\n     p->aOp[p->nOp-1].zComment = sqlite3VMPrintf(p->db, zFormat, ap);\n   }\n }\n \n", "target": "// fix_start\n  assert( p->aOp==0 || p->aOp[p->nOp-1].zComment==0 || p->db->mallocFailed\n          || p->pParse->nErr>0 );\n// fix_end\n", "cwe": "CWE-755", "cwe_name": "Improper Handling of Exceptional Conditions", "cve": "CVE-2019-19924", "cve_desc": "SQLite 3.30.1 mishandles certain parser-tree rewriting, related to expr.c, vdbeaux.c, and window.c. This is caused by incorrect sqlite3WindowRewrite() error handling.", "project": "sqlite", "idx": 206236}
{"source": " int sqlite3WindowRewrite(Parse *pParse, Select *p){\n   int rc = SQLITE_OK;\n   if( p->pWin && p->pPrior==0 && (p->selFlags & SF_WinRewrite)==0 ){\n     Vdbe *v = sqlite3GetVdbe(pParse);\n     sqlite3 *db = pParse->db;\n     Select *pSub = 0;\n     SrcList *pSrc = p->pSrc;\n     Expr *pWhere = p->pWhere;\n     ExprList *pGroupBy = p->pGroupBy;\n     Expr *pHaving = p->pHaving;\n     ExprList *pSort = 0;\n \n     ExprList *pSublist = 0;\n     Window *pMWin = p->pWin;\n     Window *pWin;\n     Table *pTab;\n \n     pTab = sqlite3DbMallocZero(db, sizeof(Table));\n     if( pTab==0 ){\n// bug_start\n      return SQLITE_NOMEM;\n// bug_end\n     }\n \n     p->pSrc = 0;\n     p->pWhere = 0;\n     p->pGroupBy = 0;\n     p->pHaving = 0;\n     p->selFlags &= ~SF_Aggregate;\n     p->selFlags |= SF_WinRewrite;\n \n     pSort = sqlite3ExprListDup(db, pMWin->pPartition, 0);\n     pSort = exprListAppendList(pParse, pSort, pMWin->pOrderBy, 1);\n     if( pSort && p->pOrderBy && p->pOrderBy->nExpr<=pSort->nExpr ){\n       int nSave = pSort->nExpr;\n       pSort->nExpr = p->pOrderBy->nExpr;\n       if( sqlite3ExprListCompare(pSort, p->pOrderBy, -1)==0 ){\n         sqlite3ExprListDelete(db, p->pOrderBy);\n         p->pOrderBy = 0;\n       }\n       pSort->nExpr = nSave;\n     }\n \n     pMWin->iEphCsr = pParse->nTab++;\n     pParse->nTab += 3;\n \n     selectWindowRewriteEList(pParse, pMWin, pSrc, p->pEList, pTab, &pSublist);\n     selectWindowRewriteEList(pParse, pMWin, pSrc, p->pOrderBy, pTab, &pSublist);\n     pMWin->nBufferCol = (pSublist ? pSublist->nExpr : 0);\n \n     pSublist = exprListAppendList(pParse, pSublist, pMWin->pPartition, 0);\n     pSublist = exprListAppendList(pParse, pSublist, pMWin->pOrderBy, 0);\n \n     for(pWin=pMWin; pWin; pWin=pWin->pNextWin){\n       ExprList *pArgs = pWin->pOwner->x.pList;\n       if( pWin->pFunc->funcFlags & SQLITE_FUNC_SUBTYPE ){\n         selectWindowRewriteEList(pParse, pMWin, pSrc, pArgs, pTab, &pSublist);\n         pWin->iArgCol = (pSublist ? pSublist->nExpr : 0);\n         pWin->bExprArgs = 1;\n       }else{\n         pWin->iArgCol = (pSublist ? pSublist->nExpr : 0);\n         pSublist = exprListAppendList(pParse, pSublist, pArgs, 0);\n       }\n       if( pWin->pFilter ){\n         Expr *pFilter = sqlite3ExprDup(db, pWin->pFilter, 0);\n         pSublist = sqlite3ExprListAppend(pParse, pSublist, pFilter);\n       }\n       pWin->regAccum = ++pParse->nMem;\n       pWin->regResult = ++pParse->nMem;\n       sqlite3VdbeAddOp2(v, OP_Null, 0, pWin->regAccum);\n     }\n \n     if( pSublist==0 ){\n       pSublist = sqlite3ExprListAppend(pParse, 0,\n         sqlite3Expr(db, TK_INTEGER, \"0\")\n       );\n     }\n \n     pSub = sqlite3SelectNew(\n         pParse, pSublist, pSrc, pWhere, pGroupBy, pHaving, pSort, 0, 0\n     );\n     p->pSrc = sqlite3SrcListAppend(pParse, 0, 0, 0);\n     if( p->pSrc ){\n       Table *pTab2;\n       p->pSrc->a[0].pSelect = pSub;\n       sqlite3SrcListAssignCursors(pParse, p->pSrc);\n       pSub->selFlags |= SF_Expanded;\n       pTab2 = sqlite3ResultSetOfSelect(pParse, pSub, SQLITE_AFF_NONE);\n       if( pTab2==0 ){\n         rc = SQLITE_NOMEM;\n       }else{\n         memcpy(pTab, pTab2, sizeof(Table));\n         pTab->tabFlags |= TF_Ephemeral;\n         p->pSrc->a[0].pTab = pTab;\n         pTab = pTab2;\n       }\n       sqlite3VdbeAddOp2(v, OP_OpenEphemeral, pMWin->iEphCsr, pSublist->nExpr);\n       sqlite3VdbeAddOp2(v, OP_OpenDup, pMWin->iEphCsr+1, pMWin->iEphCsr);\n       sqlite3VdbeAddOp2(v, OP_OpenDup, pMWin->iEphCsr+2, pMWin->iEphCsr);\n       sqlite3VdbeAddOp2(v, OP_OpenDup, pMWin->iEphCsr+3, pMWin->iEphCsr);\n     }else{\n       sqlite3SelectDelete(db, pSub);\n     }\n     if( db->mallocFailed ) rc = SQLITE_NOMEM;\n     sqlite3DbFree(db, pTab);\n   }\n \n// bug_start\n// bug_end\n   return rc;\n }\n \n", "target": "// fix_start\n      return sqlite3ErrorToParser(db, SQLITE_NOMEM);\n// fix_end\n// fix_start\n  if( rc && pParse->nErr==0 ){\n    assert( pParse->db->mallocFailed );\n    return sqlite3ErrorToParser(pParse->db, SQLITE_NOMEM);\n  }\n// fix_end\n", "cwe": "CWE-755", "cwe_name": "Improper Handling of Exceptional Conditions", "cve": "CVE-2019-19924", "cve_desc": "SQLite 3.30.1 mishandles certain parser-tree rewriting, related to expr.c, vdbeaux.c, and window.c. This is caused by incorrect sqlite3WindowRewrite() error handling.", "project": "sqlite", "idx": 206237}
{"source": " ansicstr (string, len, flags, sawc, rlen)\n      char *string;\n      int len, flags, *sawc, *rlen;\n {\n   int c, temp;\n   char *ret, *r, *s;\n   unsigned long v;\n \n   if (string == 0 || *string == '\\0')\n     return ((char *)NULL);\n \n #if defined (HANDLE_MULTIBYTE)\n// bug_start\n  if (strstr (string, \"\\\\U\") != 0)\n    ret = (char *)xmalloc (6*len + 1);\n  else\n    ret = (char *)xmalloc (4*len + 1);\n// bug_end\n #else\n   ret = (char *)xmalloc (2*len + 1);\n #endif\n   for (r = ret, s = string; s && *s; )\n     {\n       c = *s++;\n       if (c != '\\\\' || *s == '\\0')\n \t*r++ = c;\n       else\n \t{\n \t  switch (c = *s++)\n \t    {\n #if defined (__STDC__)\n \t    case 'a': c = '\\a'; break;\n \t    case 'v': c = '\\v'; break;\n #else\n \t    case 'a': c = (int) 0x07; break;\n \t    case 'v': c = (int) 0x0B; break;\n #endif\n \t    case 'b': c = '\\b'; break;\n \t    case 'e': case 'E':\n \t      c = ESC; break;\n \t    case 'f': c = '\\f'; break;\n \t    case 'n': c = '\\n'; break;\n \t    case 'r': c = '\\r'; break;\n \t    case 't': c = '\\t'; break;\n \t    case '1': case '2': case '3':\n \t    case '4': case '5': case '6':\n \t    case '7':\n #if 1\n \t      if (flags & 1)\n \t\t{\n \t\t  *r++ = '\\\\';\n \t\t  break;\n \t\t}\n #endif\n \t    case '0':\n \t      temp = 2 + ((flags & 1) && (c == '0'));\n \t      for (c -= '0'; ISOCTAL (*s) && temp--; s++)\n \t\tc = (c * 8) + OCTVALUE (*s);\n \t      c &= 0xFF;\n \t      break;\n \t    case 'x':\n \t      if ((flags & 2) && *s == '{')\n \t\t{\n \t\t  flags |= 16;\n \t\t  s++;\n \t\t}\n \t      for (temp = 2, c = 0; ISXDIGIT ((unsigned char)*s) && temp--; s++)\n \t\tc = (c * 16) + HEXVALUE (*s);\n \t      if (flags & 16)\n \t\t{\n \t\t  for ( ; ISXDIGIT ((unsigned char)*s); s++)\n \t\t    c = (c * 16) + HEXVALUE (*s);\n \t\t  flags &= ~16;\n \t\t  if (*s == '}')\n \t\t    s++;\n \t        }\n \t      else if (temp == 2)\n \t\t{\n \t\t  *r++ = '\\\\';\n \t\t  c = 'x';\n \t\t}\n \t      c &= 0xFF;\n \t      break;\n #if defined (HANDLE_MULTIBYTE)\n \t    case 'u':\n \t    case 'U':\n \t      temp = (c == 'u') ? 4 : 8;\n \t      for (v = 0; ISXDIGIT ((unsigned char)*s) && temp--; s++)\n \t\tv = (v * 16) + HEXVALUE (*s);\n \t      if (temp == ((c == 'u') ? 4 : 8))\n \t\t{\n \t\t  *r++ = '\\\\';\n \t\t  break;\n \t\t}\n \t      else if (v <= 0x7f)\n \t\t{\n \t\t  c = v;\n \t\t  break;\n \t\t}\n \t      else\n \t\t{\n \t\t  temp = u32cconv (v, r);\n \t\t  r += temp;\n \t\t  continue;\n \t\t}\n #endif\n \t    case '\\\\':\n \t      break;\n \t    case '\\'': case '\"': case '?':\n \t      if (flags & 1)\n \t\t*r++ = '\\\\';\n \t      break;\n \t    case 'c':\n \t      if (sawc)\n \t\t{\n \t\t  *sawc = 1;\n \t\t  *r = '\\0';\n \t\t  if (rlen)\n \t\t    *rlen = r - ret;\n \t\t  return ret;\n \t\t}\n \t      else if ((flags & 1) == 0 && *s == 0)\n \t\t;\n \t      else if ((flags & 1) == 0 && (c = *s))\n \t\t{\n \t\t  s++;\n \t\t  if ((flags & 2) && c == '\\\\' && c == *s)\n \t\t    s++;\n \t\t  c = TOCTRL(c);\n \t\t  break;\n \t\t}\n \t    default:\n \t\tif ((flags & 4) == 0)\n \t\t  *r++ = '\\\\';\n \t\tbreak;\n \t    }\n \t  if ((flags & 2) && (c == CTLESC || c == CTLNUL))\n \t    *r++ = CTLESC;\n \t  *r++ = c;\n \t}\n     }\n   *r = '\\0';\n   if (rlen)\n     *rlen = r - ret;\n   return ret;\n }\n \n", "target": "// fix_start\n  ret = (char *)xmalloc (4*len + 1);\n// fix_end\n", "cwe": "CWE-119", "cwe_name": "Improper Restriction of Operations within the Bounds of a Memory Buffer", "cve": "CVE-2012-6711", "cve_desc": "A heap-based buffer overflow exists in GNU Bash before 4.3 when wide characters, not supported by the current locale set in the LC_CTYPE environment variable, are printed through the echo built-in function. A local attacker, who can provide data to print through the \"echo -e\" built-in function, may use this flaw to crash a script or execute code with the privileges of the bash process. This occurs because ansicstr() in lib/sh/strtrans.c mishandles u32cconv().", "project": "bash", "idx": 206271}
{"source": " get_word_rgb_row(j_compress_ptr cinfo, cjpeg_source_ptr sinfo)\n {\n   ppm_source_ptr source = (ppm_source_ptr)sinfo;\n   register JSAMPROW ptr;\n   register U_CHAR *bufferptr;\n   register JSAMPLE *rescale = source->rescale;\n   JDIMENSION col;\n   unsigned int maxval = source->maxval;\n// bug_start\n// bug_end\n \n   if (!ReadOK(source->pub.input_file, source->iobuffer, source->buffer_width))\n     ERREXIT(cinfo, JERR_INPUT_EOF);\n   ptr = source->pub.buffer[0];\n   bufferptr = source->iobuffer;\n   for (col = cinfo->image_width; col > 0; col--) {\n     register unsigned int temp;\n     temp  = UCH(*bufferptr++) << 8;\n     temp |= UCH(*bufferptr++);\n     if (temp > maxval)\n       ERREXIT(cinfo, JERR_PPM_OUTOFRANGE);\n// bug_start\n    *ptr++ = rescale[temp];\n// bug_end\n     temp  = UCH(*bufferptr++) << 8;\n     temp |= UCH(*bufferptr++);\n     if (temp > maxval)\n       ERREXIT(cinfo, JERR_PPM_OUTOFRANGE);\n// bug_start\n    *ptr++ = rescale[temp];\n// bug_end\n     temp  = UCH(*bufferptr++) << 8;\n     temp |= UCH(*bufferptr++);\n     if (temp > maxval)\n       ERREXIT(cinfo, JERR_PPM_OUTOFRANGE);\n// bug_start\n    *ptr++ = rescale[temp];\n// bug_end\n   }\n   return 1;\n }\n \n", "target": "// fix_start\n  register int rindex = rgb_red[cinfo->in_color_space];\n  register int gindex = rgb_green[cinfo->in_color_space];\n  register int bindex = rgb_blue[cinfo->in_color_space];\n  register int aindex = alpha_index[cinfo->in_color_space];\n  register int ps = rgb_pixelsize[cinfo->in_color_space];\n// fix_end\n// fix_start\n    ptr[rindex] = rescale[temp];\n// fix_end\n// fix_start\n    ptr[gindex] = rescale[temp];\n// fix_end\n// fix_start\n    ptr[bindex] = rescale[temp];\n    if (aindex >= 0)\n      ptr[aindex] = 0xFF;\n    ptr += ps;\n// fix_end\n", "cwe": "CWE-200", "cwe_name": "Exposure of Sensitive Information to an Unauthorized Actor", "cve": "CVE-2021-46822", "cve_desc": "The PPM reader in libjpeg-turbo through 2.0.90 mishandles use of tjLoadImage for loading a 16-bit binary PPM file into a grayscale buffer and loading a 16-bit binary PGM file into an RGB buffer. This is related to a heap-based buffer overflow in the get_word_rgb_row function in rdppm.c.", "project": "libjpeg-turbo", "idx": 206275}
{"source": " \n \n static int\n iscsi_if_recv_msg(struct sk_buff *skb, struct nlmsghdr *nlh, uint32_t *group)\n {\n \tint err = 0;\n \tu32 portid;\n// bug_start\n// bug_end\n \tstruct iscsi_uevent *ev = nlmsg_data(nlh);\n \tstruct iscsi_transport *transport = NULL;\n \tstruct iscsi_internal *priv;\n \tstruct iscsi_cls_session *session;\n \tstruct iscsi_cls_conn *conn;\n \tstruct iscsi_endpoint *ep = NULL;\n \n \tif (!netlink_capable(skb, CAP_SYS_ADMIN))\n \t\treturn -EPERM;\n \n \tif (nlh->nlmsg_type == ISCSI_UEVENT_PATH_UPDATE)\n \t\t*group = ISCSI_NL_GRP_UIP;\n \telse\n \t\t*group = ISCSI_NL_GRP_ISCSID;\n \n \tpriv = iscsi_if_transport_lookup(iscsi_ptr(ev->transport_handle));\n \tif (!priv)\n \t\treturn -EINVAL;\n \ttransport = priv->iscsi_transport;\n \n \tif (!try_module_get(transport->owner))\n \t\treturn -EINVAL;\n \n \tportid = NETLINK_CB(skb).portid;\n \n \tswitch (nlh->nlmsg_type) {\n \tcase ISCSI_UEVENT_CREATE_SESSION:\n \t\terr = iscsi_if_create_session(priv, ep, ev,\n \t\t\t\t\t      portid,\n \t\t\t\t\t      ev->u.c_session.initial_cmdsn,\n \t\t\t\t\t      ev->u.c_session.cmds_max,\n \t\t\t\t\t      ev->u.c_session.queue_depth);\n \t\tbreak;\n \tcase ISCSI_UEVENT_CREATE_BOUND_SESSION:\n \t\tep = iscsi_lookup_endpoint(ev->u.c_bound_session.ep_handle);\n \t\tif (!ep) {\n \t\t\terr = -EINVAL;\n \t\t\tbreak;\n \t\t}\n \n \t\terr = iscsi_if_create_session(priv, ep, ev,\n \t\t\t\t\tportid,\n \t\t\t\t\tev->u.c_bound_session.initial_cmdsn,\n \t\t\t\t\tev->u.c_bound_session.cmds_max,\n \t\t\t\t\tev->u.c_bound_session.queue_depth);\n \t\tbreak;\n \tcase ISCSI_UEVENT_DESTROY_SESSION:\n \t\tsession = iscsi_session_lookup(ev->u.d_session.sid);\n \t\tif (!session)\n \t\t\terr = -EINVAL;\n \t\telse if (iscsi_session_has_conns(ev->u.d_session.sid))\n \t\t\terr = -EBUSY;\n \t\telse\n \t\t\ttransport->destroy_session(session);\n \t\tbreak;\n \tcase ISCSI_UEVENT_DESTROY_SESSION_ASYNC:\n \t\tsession = iscsi_session_lookup(ev->u.d_session.sid);\n \t\tif (!session)\n \t\t\terr = -EINVAL;\n \t\telse if (iscsi_session_has_conns(ev->u.d_session.sid))\n \t\t\terr = -EBUSY;\n \t\telse {\n \t\t\tunsigned long flags;\n \n \t\t\tspin_lock_irqsave(&sesslock, flags);\n \t\t\tlist_del_init(&session->sess_list);\n \t\t\tspin_unlock_irqrestore(&sesslock, flags);\n \n \t\t\tqueue_work(iscsi_destroy_workq, &session->destroy_work);\n \t\t}\n \t\tbreak;\n \tcase ISCSI_UEVENT_UNBIND_SESSION:\n \t\tsession = iscsi_session_lookup(ev->u.d_session.sid);\n \t\tif (session)\n \t\t\tscsi_queue_work(iscsi_session_to_shost(session),\n \t\t\t\t\t&session->unbind_work);\n \t\telse\n \t\t\terr = -EINVAL;\n \t\tbreak;\n \tcase ISCSI_UEVENT_CREATE_CONN:\n \t\terr = iscsi_if_create_conn(transport, ev);\n \t\tbreak;\n \tcase ISCSI_UEVENT_DESTROY_CONN:\n \t\terr = iscsi_if_destroy_conn(transport, ev);\n \t\tbreak;\n \tcase ISCSI_UEVENT_BIND_CONN:\n \t\tsession = iscsi_session_lookup(ev->u.b_conn.sid);\n \t\tconn = iscsi_conn_lookup(ev->u.b_conn.sid, ev->u.b_conn.cid);\n \n \t\tif (conn && conn->ep)\n \t\t\tiscsi_if_ep_disconnect(transport, conn->ep->id);\n \n \t\tif (!session || !conn) {\n \t\t\terr = -EINVAL;\n \t\t\tbreak;\n \t\t}\n \n \t\tmutex_lock(&conn_mutex);\n \t\tev->r.retcode =\ttransport->bind_conn(session, conn,\n \t\t\t\t\t\tev->u.b_conn.transport_eph,\n \t\t\t\t\t\tev->u.b_conn.is_leading);\n \t\tmutex_unlock(&conn_mutex);\n \n \t\tif (ev->r.retcode || !transport->ep_connect)\n \t\t\tbreak;\n \n \t\tep = iscsi_lookup_endpoint(ev->u.b_conn.transport_eph);\n \t\tif (ep) {\n \t\t\tep->conn = conn;\n \n \t\t\tmutex_lock(&conn->ep_mutex);\n \t\t\tconn->ep = ep;\n \t\t\tmutex_unlock(&conn->ep_mutex);\n \t\t} else\n \t\t\tiscsi_cls_conn_printk(KERN_ERR, conn,\n \t\t\t\t\t      \"Could not set ep conn \"\n \t\t\t\t\t      \"binding\\n\");\n \t\tbreak;\n \tcase ISCSI_UEVENT_SET_PARAM:\n \t\terr = iscsi_set_param(transport, ev);\n \t\tbreak;\n \tcase ISCSI_UEVENT_START_CONN:\n \t\tconn = iscsi_conn_lookup(ev->u.start_conn.sid, ev->u.start_conn.cid);\n \t\tif (conn) {\n \t\t\tmutex_lock(&conn_mutex);\n \t\t\tev->r.retcode = transport->start_conn(conn);\n \t\t\tif (!ev->r.retcode)\n \t\t\t\tconn->state = ISCSI_CONN_UP;\n \t\t\tmutex_unlock(&conn_mutex);\n \t\t}\n \t\telse\n \t\t\terr = -EINVAL;\n \t\tbreak;\n \tcase ISCSI_UEVENT_STOP_CONN:\n \t\tconn = iscsi_conn_lookup(ev->u.stop_conn.sid, ev->u.stop_conn.cid);\n \t\tif (conn)\n \t\t\tiscsi_if_stop_conn(conn, ev->u.stop_conn.flag);\n \t\telse\n \t\t\terr = -EINVAL;\n \t\tbreak;\n \tcase ISCSI_UEVENT_SEND_PDU:\n// bug_start\n// bug_end\n \t\tconn = iscsi_conn_lookup(ev->u.send_pdu.sid, ev->u.send_pdu.cid);\n \t\tif (conn) {\n \t\t\tmutex_lock(&conn_mutex);\n \t\t\tev->r.retcode =\ttransport->send_pdu(conn,\n \t\t\t\t(struct iscsi_hdr*)((char*)ev + sizeof(*ev)),\n \t\t\t\t(char*)ev + sizeof(*ev) + ev->u.send_pdu.hdr_size,\n \t\t\t\tev->u.send_pdu.data_size);\n \t\t\tmutex_unlock(&conn_mutex);\n \t\t}\n \t\telse\n \t\t\terr = -EINVAL;\n \t\tbreak;\n \tcase ISCSI_UEVENT_GET_STATS:\n \t\terr = iscsi_if_get_stats(transport, nlh);\n \t\tbreak;\n \tcase ISCSI_UEVENT_TRANSPORT_EP_CONNECT:\n \tcase ISCSI_UEVENT_TRANSPORT_EP_POLL:\n \tcase ISCSI_UEVENT_TRANSPORT_EP_DISCONNECT:\n \tcase ISCSI_UEVENT_TRANSPORT_EP_CONNECT_THROUGH_HOST:\n \t\terr = iscsi_if_transport_ep(transport, ev, nlh->nlmsg_type);\n \t\tbreak;\n \tcase ISCSI_UEVENT_TGT_DSCVR:\n \t\terr = iscsi_tgt_dscvr(transport, ev);\n \t\tbreak;\n \tcase ISCSI_UEVENT_SET_HOST_PARAM:\n \t\terr = iscsi_set_host_param(transport, ev);\n \t\tbreak;\n \tcase ISCSI_UEVENT_PATH_UPDATE:\n \t\terr = iscsi_set_path(transport, ev);\n \t\tbreak;\n \tcase ISCSI_UEVENT_SET_IFACE_PARAMS:\n \t\terr = iscsi_set_iface_params(transport, ev,\n \t\t\t\t\t     nlmsg_attrlen(nlh, sizeof(*ev)));\n \t\tbreak;\n \tcase ISCSI_UEVENT_PING:\n \t\terr = iscsi_send_ping(transport, ev);\n \t\tbreak;\n \tcase ISCSI_UEVENT_GET_CHAP:\n \t\terr = iscsi_get_chap(transport, nlh);\n \t\tbreak;\n \tcase ISCSI_UEVENT_DELETE_CHAP:\n \t\terr = iscsi_delete_chap(transport, ev);\n \t\tbreak;\n \tcase ISCSI_UEVENT_SET_FLASHNODE_PARAMS:\n \t\terr = iscsi_set_flashnode_param(transport, ev,\n \t\t\t\t\t\tnlmsg_attrlen(nlh,\n \t\t\t\t\t\t\t      sizeof(*ev)));\n \t\tbreak;\n \tcase ISCSI_UEVENT_NEW_FLASHNODE:\n \t\terr = iscsi_new_flashnode(transport, ev,\n \t\t\t\t\t  nlmsg_attrlen(nlh, sizeof(*ev)));\n \t\tbreak;\n \tcase ISCSI_UEVENT_DEL_FLASHNODE:\n \t\terr = iscsi_del_flashnode(transport, ev);\n \t\tbreak;\n \tcase ISCSI_UEVENT_LOGIN_FLASHNODE:\n \t\terr = iscsi_login_flashnode(transport, ev);\n \t\tbreak;\n \tcase ISCSI_UEVENT_LOGOUT_FLASHNODE:\n \t\terr = iscsi_logout_flashnode(transport, ev);\n \t\tbreak;\n \tcase ISCSI_UEVENT_LOGOUT_FLASHNODE_SID:\n \t\terr = iscsi_logout_flashnode_sid(transport, ev);\n \t\tbreak;\n \tcase ISCSI_UEVENT_SET_CHAP:\n \t\terr = iscsi_set_chap(transport, ev,\n \t\t\t\t     nlmsg_attrlen(nlh, sizeof(*ev)));\n \t\tbreak;\n \tcase ISCSI_UEVENT_GET_HOST_STATS:\n \t\terr = iscsi_get_host_stats(transport, nlh);\n \t\tbreak;\n \tdefault:\n \t\terr = -ENOSYS;\n \t\tbreak;\n \t}\n \n \n", "target": "// fix_start\n\tu32 pdu_len;\n// fix_end\n// fix_start\n\t\tpdu_len = nlh->nlmsg_len - sizeof(*nlh) - sizeof(*ev);\n\n\t\tif ((ev->u.send_pdu.hdr_size > pdu_len) ||\n\t\t    (ev->u.send_pdu.data_size > (pdu_len - ev->u.send_pdu.hdr_size))) {\n\t\t\terr = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n// fix_end\n", "cwe": "CWE-125", "cwe_name": "Out-of-bounds Read", "cve": "CVE-2021-27364", "cve_desc": "An issue was discovered in the Linux kernel through 5.11.3. drivers/scsi/scsi_transport_iscsi.c is adversely affected by the ability of an unprivileged user to craft Netlink messages.", "project": "linux", "idx": 206293}
{"source": " static struct property *dlpar_parse_cc_property(struct cc_workarea *ccwa)\n {\n \tstruct property *prop;\n \tchar *name;\n \tchar *value;\n \n \tprop = kzalloc(sizeof(*prop), GFP_KERNEL);\n \tif (!prop)\n \t\treturn NULL;\n \n \tname = (char *)ccwa + be32_to_cpu(ccwa->name_offset);\n \tprop->name = kstrdup(name, GFP_KERNEL);\n// bug_start\n// bug_end\n \n \tprop->length = be32_to_cpu(ccwa->prop_length);\n \tvalue = (char *)ccwa + be32_to_cpu(ccwa->prop_offset);\n \tprop->value = kmemdup(value, prop->length, GFP_KERNEL);\n \tif (!prop->value) {\n \t\tdlpar_free_cc_property(prop);\n \t\treturn NULL;\n \t}\n \n \treturn prop;\n }\n \n", "target": "// fix_start\n\tif (!prop->name) {\n\t\tdlpar_free_cc_property(prop);\n\t\treturn NULL;\n\t}\n// fix_end\n", "cwe": "CWE-476", "cwe_name": "NULL Pointer Dereference", "cve": "CVE-2019-12614", "cve_desc": "An issue was discovered in dlpar_parse_cc_property in arch/powerpc/platforms/pseries/dlpar.c in the Linux kernel through 5.1.6. There is an unchecked kstrdup of prop->name, which might allow an attacker to cause a denial of service (NULL pointer dereference and system crash).", "project": "linux", "idx": 206300}
{"source": " static Image *ReadHEICImage(const ImageInfo *image_info,\n   ExceptionInfo *exception)\n {\n   const char\n     *option;\n \n   const StringInfo\n     *profile;\n \n   heif_item_id\n     exif_id;\n \n   Image\n     *image;\n \n   int\n     count,\n     stride_y,\n     stride_cb,\n     stride_cr;\n \n   MagickBooleanType\n     status;\n \n   size_t\n     length;\n \n   ssize_t\n     y;\n \n   struct heif_context\n     *heif_context;\n \n   struct heif_decoding_options\n     *decode_options;\n \n   struct heif_error\n     error;\n \n   struct heif_image\n     *heif_image;\n \n   struct heif_image_handle\n     *image_handle;\n \n   const uint8_t\n     *p_y,\n     *p_cb,\n     *p_cr;\n \n   void\n     *file_data;\n \n   assert(image_info != (const ImageInfo *) NULL);\n   assert(image_info->signature == MagickCoreSignature);\n   if (image_info->debug != MagickFalse)\n     (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n       image_info->filename);\n   assert(exception != (ExceptionInfo *) NULL);\n   assert(exception->signature == MagickCoreSignature);\n   image=AcquireImage(image_info);\n   status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n   if (status == MagickFalse)\n     return(DestroyImageList(image));\n   if (GetBlobSize(image) > (MagickSizeType) SSIZE_MAX)\n     ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n   length=(size_t) GetBlobSize(image);\n   file_data=AcquireMagickMemory(length);\n   if (file_data == (void *) NULL)\n     ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n   if (ReadBlob(image,length,(unsigned char *) file_data) != (ssize_t) length)\n     {\n       file_data=RelinquishMagickMemory(file_data);\n       ThrowReaderException(CorruptImageError,\"InsufficientImageDataInFile\");\n     }\n   heif_context=heif_context_alloc();\n   error=heif_context_read_from_memory_without_copy(heif_context,file_data,\n     length,NULL);\n   if (IsHeifSuccess(&error,image) == MagickFalse)\n     {\n       heif_context_free(heif_context);\n       file_data=RelinquishMagickMemory(file_data);\n       return(DestroyImageList(image));\n     }\n   image_handle=(struct heif_image_handle *) NULL;\n   error=heif_context_get_primary_image_handle(heif_context,&image_handle);\n   if (IsHeifSuccess(&error,image) == MagickFalse)\n     {\n       heif_context_free(heif_context);\n       file_data=RelinquishMagickMemory(file_data);\n       return(DestroyImageList(image));\n     }\n #if LIBHEIF_NUMERIC_VERSION >= 0x01040000\n   length=heif_image_handle_get_raw_color_profile_size(image_handle);\n   if (length > 0)\n     {\n       unsigned char\n         *color_buffer;\n \n       if ((MagickSizeType) length > GetBlobSize(image))\n         {\n           heif_image_handle_release(image_handle);\n           heif_context_free(heif_context);\n           file_data=RelinquishMagickMemory(file_data);\n           ThrowReaderException(CorruptImageError,\"InsufficientImageDataInFile\");\n         }\n       color_buffer=(unsigned char *) AcquireMagickMemory(length);\n       if (color_buffer != (unsigned char *) NULL)\n         {\n           error=heif_image_handle_get_raw_color_profile(image_handle,\n             color_buffer);\n           if (error.code == 0)\n             {\n               StringInfo\n                 *profile;\n \n               profile=BlobToStringInfo(color_buffer,length);\n               if (profile != (StringInfo*) NULL)\n                 {\n                   (void) SetImageProfile(image,\"icc\",profile);\n                   profile=DestroyStringInfo(profile);\n                 }\n             }\n         }\n       color_buffer=(unsigned char *) RelinquishMagickMemory(color_buffer);\n     }\n #endif\n   count=heif_image_handle_get_list_of_metadata_block_IDs(image_handle,\"Exif\",\n     &exif_id,1);\n   if (count > 0)\n     {\n       size_t\n         exif_size;\n \n       unsigned char\n         *exif_buffer;\n \n       exif_size=heif_image_handle_get_metadata_size(image_handle,exif_id);\n       if ((MagickSizeType) exif_size > GetBlobSize(image))\n         {\n           heif_image_handle_release(image_handle);\n           heif_context_free(heif_context);\n           file_data=RelinquishMagickMemory(file_data);\n           ThrowReaderException(CorruptImageError,\"InsufficientImageDataInFile\");\n         }\n       exif_buffer=(unsigned char*) AcquireMagickMemory(exif_size);\n       if (exif_buffer != (unsigned char*) NULL)\n         {\n           error=heif_image_handle_get_metadata(image_handle,\n             exif_id,exif_buffer);\n           if (error.code == 0)\n             {\n               StringInfo\n                 *profile;\n \n               profile=(StringInfo*) NULL;\n               if (exif_size > 8)\n                 profile=BlobToStringInfo(exif_buffer+4,(size_t) exif_size-4);\n               if (profile != (StringInfo*) NULL)\n                 {\n                   (void) SetImageProfile(image,\"exif\",profile);\n                   profile=DestroyStringInfo(profile);\n                 }\n             }\n         }\n       exif_buffer=(unsigned char *) RelinquishMagickMemory(exif_buffer);\n   }\n   image->depth=8;\n   image->columns=(size_t) heif_image_handle_get_width(image_handle);\n   image->rows=(size_t) heif_image_handle_get_height(image_handle);\n   if (image_info->ping != MagickFalse)\n     {\n       image->colorspace=YCbCrColorspace;\n       heif_image_handle_release(image_handle);\n       heif_context_free(heif_context);\n       file_data=RelinquishMagickMemory(file_data);\n       return(GetFirstImageInList(image));\n     }\n   status=SetImageExtent(image,image->columns,image->rows);\n   if (status == MagickFalse)\n     {\n       heif_image_handle_release(image_handle);\n       heif_context_free(heif_context);\n       file_data=RelinquishMagickMemory(file_data);\n       return(DestroyImageList(image));\n     }\n   (void) SetImageColorspace(image,YCbCrColorspace);\n   decode_options=(struct heif_decoding_options *) NULL;\n   option=GetImageOption(image_info,\"heic:preserve-orientation\");\n   if (IsStringTrue(option) == MagickTrue)\n     {\n       decode_options=heif_decoding_options_alloc();\n       decode_options->ignore_transformations=1;\n     }\n   else\n     (void) SetImageProperty(image,\"exif:Orientation\",\"1\");\n   error=heif_decode_image(image_handle,&heif_image,heif_colorspace_YCbCr,\n// bug_start\n    heif_chroma_420,NULL);\n// bug_end\n   if (IsHeifSuccess(&error,image) == MagickFalse)\n     {\n       heif_image_handle_release(image_handle);\n       heif_context_free(heif_context);\n       file_data=RelinquishMagickMemory(file_data);\n       return(DestroyImageList(image));\n     }\n// bug_start\n  if (decode_options != (struct heif_decoding_options *) NULL)\n    {\n      image->columns=(size_t) heif_image_get_width(heif_image,heif_channel_Y);\n      image->rows=(size_t) heif_image_get_height(heif_image,heif_channel_Y);\n      status=SetImageExtent(image,image->columns,image->rows);\n      heif_decoding_options_free(decode_options);\n      if (status == MagickFalse)\n        {\n          heif_image_release(heif_image);\n          heif_image_handle_release(image_handle);\n          heif_context_free(heif_context);\n          file_data=RelinquishMagickMemory(file_data);\n          return(DestroyImageList(image));\n        }\n// bug_end\n     }\n   p_y=heif_image_get_plane_readonly(heif_image,heif_channel_Y,&stride_y);\n   p_cb=heif_image_get_plane_readonly(heif_image,heif_channel_Cb,&stride_cb);\n   p_cr=heif_image_get_plane_readonly(heif_image,heif_channel_Cr,&stride_cr);\n   for (y=0; y < (ssize_t) image->rows; y++)\n   {\n     PixelPacket\n       *q;\n \n     register ssize_t\n       x;\n \n     q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n     if (q == (PixelPacket *) NULL)\n       break;\n     for (x=0; x < (ssize_t) image->columns; x++)\n     {\n       SetPixelRed(q,ScaleCharToQuantum((unsigned char) p_y[y*\n         stride_y+x]));\n       SetPixelGreen(q,ScaleCharToQuantum((unsigned char) p_cb[(y/2)*\n         stride_cb+x/2]));\n       SetPixelBlue(q,ScaleCharToQuantum((unsigned char) p_cr[(y/2)*\n         stride_cr+x/2]));\n       q++;\n     }\n     if (SyncAuthenticPixels(image,exception) == MagickFalse)\n       break;\n   }\n   heif_image_release(heif_image);\n   heif_image_handle_release(image_handle);\n   heif_context_free(heif_context);\n   file_data=RelinquishMagickMemory(file_data);\n   profile=GetImageProfile(image,\"icc\");\n   if (profile != (const StringInfo *) NULL)\n     (void) TransformImageColorspace(image,sRGBColorspace);\n   return(GetFirstImageInList(image));\n }\n \n", "target": "// fix_start\n    heif_chroma_420,decode_options);\n  if (decode_options != (struct heif_decoding_options *) NULL)\n    heif_decoding_options_free(decode_options);\n// fix_end\n// fix_start\n  image->columns=(size_t) heif_image_get_width(heif_image,heif_channel_Y);\n  image->rows=(size_t) heif_image_get_height(heif_image,heif_channel_Y);\n  status=SetImageExtent(image,image->columns,image->rows);\n  if (status == MagickFalse)\n    {\n      heif_image_release(heif_image);\n      heif_image_handle_release(image_handle);\n      heif_context_free(heif_context);\n      file_data=RelinquishMagickMemory(file_data);\n      return(DestroyImageList(image));\n// fix_end\n", "cwe": "CWE-125", "cwe_name": "Out-of-bounds Read", "cve": "CVE-2020-10251", "cve_desc": "In ImageMagick 7.0.9, an out-of-bounds read vulnerability exists within the ReadHEICImageByID function in coders\\heic.c. It can be triggered via an image with a width or height value that exceeds the actual size of the image.", "project": "ImageMagick6", "idx": 206422}
{"source": " video_usercopy(struct file *file, unsigned int orig_cmd, unsigned long arg,\n \t       v4l2_kioctl func)\n {\n \tchar\tsbuf[128];\n// bug_start\n\tvoid    *mbuf = NULL;\n// bug_end\n \tvoid\t*parg = (void *)arg;\n \tlong\terr  = -EINVAL;\n \tbool\thas_array_args;\n \tbool\talways_copy = false;\n \tsize_t  array_size = 0;\n \tvoid __user *user_ptr = NULL;\n \tvoid\t**kernel_ptr = NULL;\n \tunsigned int cmd = video_translate_cmd(orig_cmd);\n \tconst size_t ioc_size = _IOC_SIZE(cmd);\n \n \tif (_IOC_DIR(cmd) != _IOC_NONE) {\n \t\tif (ioc_size <= sizeof(sbuf)) {\n \t\t\tparg = sbuf;\n \t\t} else {\n \t\t\tmbuf = kvmalloc(ioc_size, GFP_KERNEL);\n \t\t\tif (NULL == mbuf)\n \t\t\t\treturn -ENOMEM;\n \t\t\tparg = mbuf;\n \t\t}\n \n \t\terr = video_get_user((void __user *)arg, parg, cmd,\n \t\t\t\t     orig_cmd, &always_copy);\n \t\tif (err)\n \t\t\tgoto out;\n \t}\n \n \terr = check_array_args(cmd, parg, &array_size, &user_ptr, &kernel_ptr);\n \tif (err < 0)\n \t\tgoto out;\n \thas_array_args = err;\n \n \tif (has_array_args) {\n// bug_start\n\t\tmbuf = kvmalloc(array_size, GFP_KERNEL);\n// bug_end\n \t\terr = -ENOMEM;\n// bug_start\n\t\tif (NULL == mbuf)\n// bug_end\n \t\t\tgoto out_array_args;\n \t\terr = -EFAULT;\n \t\tif (in_compat_syscall())\n// bug_start\n\t\t\terr = v4l2_compat_get_array_args(file, mbuf, user_ptr,\n\t\t\t\t\t\t\t array_size, orig_cmd,\n\t\t\t\t\t\t\t parg);\n// bug_end\n \t\telse\n// bug_start\n\t\t\terr = copy_from_user(mbuf, user_ptr, array_size) ?\n// bug_end\n \t\t\t\t\t\t\t\t-EFAULT : 0;\n \t\tif (err)\n \t\t\tgoto out_array_args;\n// bug_start\n\t\t*kernel_ptr = mbuf;\n// bug_end\n \t}\n \n \terr = func(file, cmd, parg);\n \tif (err == -ENOTTY || err == -ENOIOCTLCMD) {\n \t\terr = -ENOTTY;\n \t\tgoto out;\n \t}\n \n \tif (err == 0) {\n \t\tif (cmd == VIDIOC_DQBUF)\n \t\t\ttrace_v4l2_dqbuf(video_devdata(file)->minor, parg);\n \t\telse if (cmd == VIDIOC_QBUF)\n \t\t\ttrace_v4l2_qbuf(video_devdata(file)->minor, parg);\n \t}\n \n \tif (has_array_args) {\n \t\t*kernel_ptr = (void __force *)user_ptr;\n \t\tif (in_compat_syscall()) {\n \t\t\tint put_err;\n \n// bug_start\n\t\t\tput_err = v4l2_compat_put_array_args(file, user_ptr, mbuf,\n\t\t\t\t\t\t\t     array_size, orig_cmd,\n\t\t\t\t\t\t\t     parg);\n// bug_end\n \t\t\tif (put_err)\n \t\t\t\terr = put_err;\n// bug_start\n\t\t} else if (copy_to_user(user_ptr, mbuf, array_size)) {\n// bug_end\n \t\t\terr = -EFAULT;\n \t\t}\n \t\tgoto out_array_args;\n \t}\n \tif (err < 0 && !always_copy)\n \t\tgoto out;\n \n out_array_args:\n \tif (video_put_user((void __user *)arg, parg, cmd, orig_cmd))\n \t\terr = -EFAULT;\n out:\n// bug_start\n// bug_end\n \tkvfree(mbuf);\n \treturn err;\n }\n \n", "target": "// fix_start\n\tvoid    *mbuf = NULL, *array_buf = NULL;\n// fix_end\n// fix_start\n\t\tarray_buf = kvmalloc(array_size, GFP_KERNEL);\n// fix_end\n// fix_start\n\t\tif (array_buf == NULL)\n// fix_end\n// fix_start\n\t\t\terr = v4l2_compat_get_array_args(file, array_buf,\n\t\t\t\t\t\t\t user_ptr, array_size,\n\t\t\t\t\t\t\t orig_cmd, parg);\n// fix_end\n// fix_start\n\t\t\terr = copy_from_user(array_buf, user_ptr, array_size) ?\n// fix_end\n// fix_start\n\t\t*kernel_ptr = array_buf;\n// fix_end\n// fix_start\n\t\t\tput_err = v4l2_compat_put_array_args(file, user_ptr,\n\t\t\t\t\t\t\t     array_buf,\n\t\t\t\t\t\t\t     array_size,\n\t\t\t\t\t\t\t     orig_cmd, parg);\n// fix_end\n// fix_start\n\t\t} else if (copy_to_user(user_ptr, array_buf, array_size)) {\n// fix_end\n// fix_start\n\tkvfree(array_buf);\n// fix_end\n", "cwe": "CWE-401", "cwe_name": "Missing Release of Memory after Effective Lifetime", "cve": "CVE-2021-30002", "cve_desc": "An issue was discovered in the Linux kernel before 5.11.3 when a webcam device exists. video_usercopy in drivers/media/v4l2-core/v4l2-ioctl.c has a memory leak for large arguments, aka CID-fb18802a338b.", "project": "linux", "idx": 206468}
{"source": " int CServer::SendMsg(CMsgPacker *pMsg, int Flags, int ClientID)\n {\n \tCNetChunk Packet;\n \tif(!pMsg)\n \t\treturn -1;\n \n// bug_start\n\tif(0 <= ClientID && ClientID < MAX_CLIENTS && GameServer()->IsClientBot(ClientID))\n// bug_end\n \t\treturn 0;\n \n \tmem_zero(&Packet, sizeof(CNetChunk));\n \tPacket.m_ClientID = ClientID;\n \tPacket.m_pData = pMsg->Data();\n \tPacket.m_DataSize = pMsg->Size();\n \n \tif(Flags&MSGFLAG_VITAL)\n \t\tPacket.m_Flags |= NETSENDFLAG_VITAL;\n \tif(Flags&MSGFLAG_FLUSH)\n \t\tPacket.m_Flags |= NETSENDFLAG_FLUSH;\n \n \tif(!(Flags&MSGFLAG_NORECORD))\n \t\tm_DemoRecorder.RecordMessage(pMsg->Data(), pMsg->Size());\n \n \tif(!(Flags&MSGFLAG_NOSEND))\n \t{\n \t\tif(ClientID == -1)\n \t\t{\n \t\t\tint i;\n \t\t\tfor(i = 0; i < MAX_CLIENTS; i++)\n \t\t\t\tif(m_aClients[i].m_State == CClient::STATE_INGAME && !m_aClients[i].m_Quitting)\n \t\t\t\t{\n \t\t\t\t\tPacket.m_ClientID = i;\n \t\t\t\t\tm_NetServer.Send(&Packet);\n \t\t\t\t}\n \t\t}\n \t\telse\n \t\t\tm_NetServer.Send(&Packet);\n \t}\n \treturn 0;\n }\n \n", "target": "// fix_start\n\tif(ClientID != -1 && (ClientID < 0 || ClientID >= MAX_CLIENTS || m_aClients[ClientID].m_State == CClient::STATE_EMPTY || m_aClients[ClientID].m_Quitting))\n// fix_end\n", "cwe": "CWE-703", "cwe_name": "Improper Check or Handling of Exceptional Conditions", "cve": "CVE-2020-12066", "cve_desc": "CServer::SendMsg in engine/server/server.cpp in Teeworlds 0.7.x before 0.7.5 allows remote attackers to shut down the server.", "project": "teeworlds", "idx": 206517}
{"source": " static php_iconv_err_t _php_iconv_mime_decode(smart_str *pretval, const char *str, size_t str_nbytes, const char *enc, const char **next_pos, int mode)\n {\n \tphp_iconv_err_t err = PHP_ICONV_ERR_SUCCESS;\n \n \ticonv_t cd = (iconv_t)(-1), cd_pl = (iconv_t)(-1);\n \n \tconst char *p1;\n \tsize_t str_left;\n \tunsigned int scan_stat = 0;\n \tconst char *csname = NULL;\n \tsize_t csname_len;\n \tconst char *encoded_text = NULL;\n \tsize_t encoded_text_len = 0;\n \tconst char *encoded_word = NULL;\n \tconst char *spaces = NULL;\n \n \tphp_iconv_enc_scheme_t enc_scheme = PHP_ICONV_ENC_SCHEME_BASE64;\n \n \tif (next_pos != NULL) {\n \t\t*next_pos = NULL;\n \t}\n \n \tcd_pl = iconv_open(enc, ICONV_ASCII_ENCODING);\n \n \tif (cd_pl == (iconv_t)(-1)) {\n #if ICONV_SUPPORTS_ERRNO\n \t\tif (errno == EINVAL) {\n \t\t\terr = PHP_ICONV_ERR_WRONG_CHARSET;\n \t\t} else {\n \t\t\terr = PHP_ICONV_ERR_CONVERTER;\n \t\t}\n #else\n \t\terr = PHP_ICONV_ERR_UNKNOWN;\n #endif\n \t\tgoto out;\n \t}\n \n \tp1 = str;\n \tfor (str_left = str_nbytes; str_left > 0; str_left--, p1++) {\n \t\tint eos = 0;\n \n \t\tswitch (scan_stat) {\n \t\t\tcase 0:\n \t\t\t\tswitch (*p1) {\n \t\t\t\t\tcase '\\r':\n \t\t\t\t\t\tscan_stat = 7;\n \t\t\t\t\t\tbreak;\n \n \t\t\t\t\tcase '\\n':\n \t\t\t\t\t\tscan_stat = 8;\n \t\t\t\t\t\tbreak;\n \n \t\t\t\t\tcase '=':\n \t\t\t\t\t\tencoded_word = p1;\n \t\t\t\t\t\tscan_stat = 1;\n \t\t\t\t\t\tbreak;\n \n \t\t\t\t\tcase ' ': case '\\t':\n \t\t\t\t\t\tspaces = p1;\n \t\t\t\t\t\tscan_stat = 11;\n \t\t\t\t\t\tbreak;\n \n \t\t\t\t\tdefault:\n \t\t\t\t\t\terr = _php_iconv_appendc(pretval, *p1, cd_pl);\n \t\t\t\t\t\tif (err != PHP_ICONV_ERR_SUCCESS) {\n \t\t\t\t\t\t\tif (mode & PHP_ICONV_MIME_DECODE_CONTINUE_ON_ERROR) {\n \t\t\t\t\t\t\t\terr = PHP_ICONV_ERR_SUCCESS;\n \t\t\t\t\t\t\t} else {\n \t\t\t\t\t\t\t\tgoto out;\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}\n \t\t\t\t\t\tencoded_word = NULL;\n \t\t\t\t\t\tif ((mode & PHP_ICONV_MIME_DECODE_STRICT)) {\n \t\t\t\t\t\t\tscan_stat = 12;\n \t\t\t\t\t\t}\n \t\t\t\t\t\tbreak;\n \t\t\t\t}\n \t\t\t\tbreak;\n \n \t\t\tcase 1:\n \t\t\t\tif (*p1 != '?') {\n \t\t\t\t\tif (*p1 == '\\r' || *p1 == '\\n') {\n \t\t\t\t\t\t--p1;\n \t\t\t\t\t}\n \t\t\t\t\terr = _php_iconv_appendl(pretval, encoded_word, (size_t)((p1 + 1) - encoded_word), cd_pl);\n \t\t\t\t\tif (err != PHP_ICONV_ERR_SUCCESS) {\n \t\t\t\t\t\tgoto out;\n \t\t\t\t\t}\n \t\t\t\t\tencoded_word = NULL;\n \t\t\t\t\tif ((mode & PHP_ICONV_MIME_DECODE_STRICT)) {\n \t\t\t\t\t\tscan_stat = 12;\n \t\t\t\t\t} else {\n \t\t\t\t\t\tscan_stat = 0;\n \t\t\t\t\t}\n \t\t\t\t\tbreak;\n \t\t\t\t}\n \t\t\t\tcsname = p1 + 1;\n \t\t\t\tscan_stat = 2;\n \t\t\t\tbreak;\n \n \t\t\tcase 2:\n \t\t\t\tswitch (*p1) {\n \t\t\t\t\tcase '?':\n \t\t\t\t\t\tscan_stat = 3;\n \t\t\t\t\t\tbreak;\n \n \t\t\t\t\tcase '*':\n \t\t\t\t\t\tscan_stat = 10;\n \t\t\t\t\t\tbreak;\n \n \t\t\t\t\tcase '\\r': case '\\n':\n \t\t\t\t\t\t--p1;\n \t\t\t\t\t\t_php_iconv_appendc(pretval, '=', cd_pl);\n \t\t\t\t\t\t_php_iconv_appendc(pretval, '?', cd_pl);\n \t\t\t\t\t\terr = _php_iconv_appendl(pretval, csname, (size_t)((p1 + 1) - csname), cd_pl);\n \t\t\t\t\t\tif (err != PHP_ICONV_ERR_SUCCESS) {\n \t\t\t\t\t\t\tgoto out;\n \t\t\t\t\t\t}\n \t\t\t\t\t\tcsname = NULL;\n \t\t\t\t\t\tif ((mode & PHP_ICONV_MIME_DECODE_STRICT)) {\n \t\t\t\t\t\t\tscan_stat = 12;\n \t\t\t\t\t\t}\n \t\t\t\t\t\telse {\n \t\t\t\t\t\t\tscan_stat = 0;\n \t\t\t\t\t\t}\n \t\t\t\t\t\tcontinue;\n \t\t\t\t}\n \t\t\t\tif (scan_stat != 2) {\n \t\t\t\t\tchar tmpbuf[80];\n \n \t\t\t\t\tif (csname == NULL) {\n \t\t\t\t\t\terr = PHP_ICONV_ERR_MALFORMED;\n \t\t\t\t\t\tgoto out;\n \t\t\t\t\t}\n \n \t\t\t\t\tcsname_len = (size_t)(p1 - csname);\n \n \t\t\t\t\tif (csname_len > sizeof(tmpbuf) - 1) {\n \t\t\t\t\t\tif ((mode & PHP_ICONV_MIME_DECODE_CONTINUE_ON_ERROR)) {\n \t\t\t\t\t\t\terr = _php_iconv_appendl(pretval, encoded_word, (size_t)((p1 + 1) - encoded_word), cd_pl);\n \t\t\t\t\t\t\tif (err != PHP_ICONV_ERR_SUCCESS) {\n \t\t\t\t\t\t\t\tgoto out;\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\tencoded_word = NULL;\n \t\t\t\t\t\t\tif ((mode & PHP_ICONV_MIME_DECODE_STRICT)) {\n \t\t\t\t\t\t\t\tscan_stat = 12;\n \t\t\t\t\t\t\t} else {\n \t\t\t\t\t\t\t\tscan_stat = 0;\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\tbreak;\n \t\t\t\t\t\t} else {\n \t\t\t\t\t\t\terr = PHP_ICONV_ERR_MALFORMED;\n \t\t\t\t\t\t\tgoto out;\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \n \t\t\t\t\tmemcpy(tmpbuf, csname, csname_len);\n \t\t\t\t\ttmpbuf[csname_len] = '\\0';\n \n \t\t\t\t\tif (cd != (iconv_t)(-1)) {\n \t\t\t\t\t\ticonv_close(cd);\n \t\t\t\t\t}\n \n \t\t\t\t\tcd = iconv_open(enc, tmpbuf);\n \n \t\t\t\t\tif (cd == (iconv_t)(-1)) {\n \t\t\t\t\t\tif ((mode & PHP_ICONV_MIME_DECODE_CONTINUE_ON_ERROR)) {\n \t\t\t\t\t\t\tint qmarks = 2;\n \t\t\t\t\t\t\twhile (qmarks > 0 && str_left > 1) {\n \t\t\t\t\t\t\t\tif (*(++p1) == '?') {\n \t\t\t\t\t\t\t\t\t--qmarks;\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\t--str_left;\n \t\t\t\t\t\t\t}\n \n \t\t\t\t\t\t\tif (*(p1 + 1) == '=') {\n \t\t\t\t\t\t\t\t++p1;\n// bug_start\n\t\t\t\t\t\t\t\t--str_left;\n// bug_end\n \t\t\t\t\t\t\t}\n \n \t\t\t\t\t\t\terr = _php_iconv_appendl(pretval, encoded_word, (size_t)((p1 + 1) - encoded_word), cd_pl);\n \t\t\t\t\t\t\tif (err != PHP_ICONV_ERR_SUCCESS) {\n \t\t\t\t\t\t\t\tgoto out;\n \t\t\t\t\t\t\t}\n \n \t\t\t\t\t\t\tscan_stat = 12;\n \t\t\t\t\t\t\tbreak;\n \t\t\t\t\t\t} else {\n #if ICONV_SUPPORTS_ERRNO\n \t\t\t\t\t\t\tif (errno == EINVAL) {\n \t\t\t\t\t\t\t\terr = PHP_ICONV_ERR_WRONG_CHARSET;\n \t\t\t\t\t\t\t} else {\n \t\t\t\t\t\t\t\terr = PHP_ICONV_ERR_CONVERTER;\n \t\t\t\t\t\t\t}\n #else\n \t\t\t\t\t\t\terr = PHP_ICONV_ERR_UNKNOWN;\n #endif\n \t\t\t\t\t\t\tgoto out;\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\tbreak;\n \n \t\t\tcase 3:\n \t\t\t\tswitch (*p1) {\n \t\t\t\t\tcase 'b':\n \t\t\t\t\tcase 'B':\n \t\t\t\t\t\tenc_scheme = PHP_ICONV_ENC_SCHEME_BASE64;\n \t\t\t\t\t\tscan_stat = 4;\n \t\t\t\t\t\tbreak;\n \n \t\t\t\t\tcase 'q':\n \t\t\t\t\tcase 'Q':\n \t\t\t\t\t\tenc_scheme = PHP_ICONV_ENC_SCHEME_QPRINT;\n \t\t\t\t\t\tscan_stat = 4;\n \t\t\t\t\t\tbreak;\n \n \t\t\t\t\tdefault:\n \t\t\t\t\t\tif ((mode & PHP_ICONV_MIME_DECODE_CONTINUE_ON_ERROR)) {\n \t\t\t\t\t\t\terr = _php_iconv_appendl(pretval, encoded_word, (size_t)((p1 + 1) - encoded_word), cd_pl);\n \t\t\t\t\t\t\tif (err != PHP_ICONV_ERR_SUCCESS) {\n \t\t\t\t\t\t\t\tgoto out;\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\tencoded_word = NULL;\n \t\t\t\t\t\t\tif ((mode & PHP_ICONV_MIME_DECODE_STRICT)) {\n \t\t\t\t\t\t\t\tscan_stat = 12;\n \t\t\t\t\t\t\t} else {\n \t\t\t\t\t\t\t\tscan_stat = 0;\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\tbreak;\n \t\t\t\t\t\t} else {\n \t\t\t\t\t\t\terr = PHP_ICONV_ERR_MALFORMED;\n \t\t\t\t\t\t\tgoto out;\n \t\t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\tbreak;\n \n \t\t\tcase 4:\n \t\t\t\tif (*p1 != '?') {\n \t\t\t\t\tif ((mode & PHP_ICONV_MIME_DECODE_CONTINUE_ON_ERROR)) {\n \t\t\t\t\t\terr = _php_iconv_appendl(pretval, encoded_word, (size_t)((p1 + 1) - encoded_word), cd_pl);\n \t\t\t\t\t\tif (err != PHP_ICONV_ERR_SUCCESS) {\n \t\t\t\t\t\t\tgoto out;\n \t\t\t\t\t\t}\n \t\t\t\t\t\tencoded_word = NULL;\n \t\t\t\t\t\tif ((mode & PHP_ICONV_MIME_DECODE_STRICT)) {\n \t\t\t\t\t\t\tscan_stat = 12;\n \t\t\t\t\t\t} else {\n \t\t\t\t\t\t\tscan_stat = 0;\n \t\t\t\t\t\t}\n \t\t\t\t\t\tbreak;\n \t\t\t\t\t} else {\n \t\t\t\t\t\terr = PHP_ICONV_ERR_MALFORMED;\n \t\t\t\t\t\tgoto out;\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\tencoded_text = p1 + 1;\n \t\t\t\tscan_stat = 5;\n \t\t\t\tbreak;\n \n \t\t\tcase 5:\n \t\t\t\tif (*p1 == '?') {\n \t\t\t\t\tencoded_text_len = (size_t)(p1 - encoded_text);\n \t\t\t\t\tscan_stat = 6;\n \t\t\t\t}\n \t\t\t\tbreak;\n \n \t\t\tcase 7:\n \t\t\t\tif (*p1 == '\\n') {\n \t\t\t\t\tscan_stat = 8;\n \t\t\t\t} else {\n \t\t\t\t\t_php_iconv_appendc(pretval, '\\r', cd_pl);\n \t\t\t\t\t_php_iconv_appendc(pretval, *p1, cd_pl);\n \t\t\t\t\tscan_stat = 0;\n \t\t\t\t}\n \t\t\t\tbreak;\n \n \t\t\tcase 8:\n \t\t\t\tif (*p1 != ' ' && *p1 != '\\t') {\n \t\t\t\t\t--p1;\n \t\t\t\t\tstr_left = 1;\n \t\t\t\t\tbreak;\n \t\t\t\t}\n \t\t\t\tif (encoded_word == NULL) {\n \t\t\t\t\t_php_iconv_appendc(pretval, ' ', cd_pl);\n \t\t\t\t}\n \t\t\t\tspaces = NULL;\n \t\t\t\tscan_stat = 11;\n \t\t\t\tbreak;\n \n \t\t\tcase 6:\n \t\t\t\tif (*p1 != '=') {\n \t\t\t\t\tif ((mode & PHP_ICONV_MIME_DECODE_CONTINUE_ON_ERROR)) {\n \t\t\t\t\t\terr = _php_iconv_appendl(pretval, encoded_word, (size_t)((p1 + 1) - encoded_word), cd_pl);\n \t\t\t\t\t\tif (err != PHP_ICONV_ERR_SUCCESS) {\n \t\t\t\t\t\t\tgoto out;\n \t\t\t\t\t\t}\n \t\t\t\t\t\tencoded_word = NULL;\n \t\t\t\t\t\tif ((mode & PHP_ICONV_MIME_DECODE_STRICT)) {\n \t\t\t\t\t\t\tscan_stat = 12;\n \t\t\t\t\t\t} else {\n \t\t\t\t\t\t\tscan_stat = 0;\n \t\t\t\t\t\t}\n \t\t\t\t\t\tbreak;\n \t\t\t\t\t} else {\n \t\t\t\t\t\terr = PHP_ICONV_ERR_MALFORMED;\n \t\t\t\t\t\tgoto out;\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\tscan_stat = 9;\n \t\t\t\tif (str_left == 1) {\n \t\t\t\t\teos = 1;\n \t\t\t\t} else {\n \t\t\t\t\tbreak;\n \t\t\t\t}\n \n \t\t\tcase 9:\n \t\t\t\tswitch (*p1) {\n \t\t\t\t\tdefault:\n \t\t\t\t\t\tif (!eos) {\n \t\t\t\t\t\t\tif ((mode & PHP_ICONV_MIME_DECODE_STRICT)) {\n \t\t\t\t\t\t\t\terr = _php_iconv_appendl(pretval, encoded_word, (size_t)((p1 + 1) - encoded_word), cd_pl);\n \t\t\t\t\t\t\t\tif (err != PHP_ICONV_ERR_SUCCESS) {\n \t\t\t\t\t\t\t\t\tgoto out;\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\tscan_stat = 12;\n \t\t\t\t\t\t\t\tbreak;\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}\n \n \t\t\t\t\tcase '\\r': case '\\n': case ' ': case '\\t': {\n \t\t\t\t\t\tzend_string *decoded_text;\n \n \t\t\t\t\t\tswitch (enc_scheme) {\n \t\t\t\t\t\t\tcase PHP_ICONV_ENC_SCHEME_BASE64:\n \t\t\t\t\t\t\t\tdecoded_text = php_base64_decode((unsigned char*)encoded_text, encoded_text_len);\n \t\t\t\t\t\t\t\tbreak;\n \n \t\t\t\t\t\t\tcase PHP_ICONV_ENC_SCHEME_QPRINT:\n \t\t\t\t\t\t\t\tdecoded_text = php_quot_print_decode((unsigned char*)encoded_text, encoded_text_len, 1);\n \t\t\t\t\t\t\t\tbreak;\n \t\t\t\t\t\t\tdefault:\n \t\t\t\t\t\t\t\tdecoded_text = NULL;\n \t\t\t\t\t\t\t\tbreak;\n \t\t\t\t\t\t}\n \n \t\t\t\t\t\tif (decoded_text == NULL) {\n \t\t\t\t\t\t\tif ((mode & PHP_ICONV_MIME_DECODE_CONTINUE_ON_ERROR)) {\n \t\t\t\t\t\t\t\terr = _php_iconv_appendl(pretval, encoded_word, (size_t)((p1 + 1) - encoded_word), cd_pl);\n \t\t\t\t\t\t\t\tif (err != PHP_ICONV_ERR_SUCCESS) {\n \t\t\t\t\t\t\t\t\tgoto out;\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\tencoded_word = NULL;\n \t\t\t\t\t\t\t\tif ((mode & PHP_ICONV_MIME_DECODE_STRICT)) {\n \t\t\t\t\t\t\t\t\tscan_stat = 12;\n \t\t\t\t\t\t\t\t} else {\n \t\t\t\t\t\t\t\t\tscan_stat = 0;\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\tbreak;\n \t\t\t\t\t\t\t} else {\n \t\t\t\t\t\t\t\terr = PHP_ICONV_ERR_UNKNOWN;\n \t\t\t\t\t\t\t\tgoto out;\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}\n \n \t\t\t\t\t\terr = _php_iconv_appendl(pretval, ZSTR_VAL(decoded_text), ZSTR_LEN(decoded_text), cd);\n \t\t\t\t\t\tzend_string_release(decoded_text);\n \n \t\t\t\t\t\tif (err != PHP_ICONV_ERR_SUCCESS) {\n \t\t\t\t\t\t\tif ((mode & PHP_ICONV_MIME_DECODE_CONTINUE_ON_ERROR)) {\n \t\t\t\t\t\t\t\terr = _php_iconv_appendl(pretval, encoded_word, (size_t)(p1 - encoded_word), cd_pl);\n \t\t\t\t\t\t\t\tencoded_word = NULL;\n \t\t\t\t\t\t\t\tif (err != PHP_ICONV_ERR_SUCCESS) {\n \t\t\t\t\t\t\t\t\tbreak;\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t} else {\n \t\t\t\t\t\t\t\tgoto out;\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}\n \n \t\t\t\t\t\tif (eos) {\n \t\t\t\t\t\t\tscan_stat = 0;\n \t\t\t\t\t\t\tbreak;\n \t\t\t\t\t\t}\n \n \t\t\t\t\t\tswitch (*p1) {\n \t\t\t\t\t\t\tcase '\\r':\n \t\t\t\t\t\t\t\tscan_stat = 7;\n \t\t\t\t\t\t\t\tbreak;\n \n \t\t\t\t\t\t\tcase '\\n':\n \t\t\t\t\t\t\t\tscan_stat = 8;\n \t\t\t\t\t\t\t\tbreak;\n \n \t\t\t\t\t\t\tcase '=':\n \t\t\t\t\t\t\t\tscan_stat = 1;\n \t\t\t\t\t\t\t\tbreak;\n \n \t\t\t\t\t\t\tcase ' ': case '\\t':\n \t\t\t\t\t\t\t\tspaces = p1;\n \t\t\t\t\t\t\t\tscan_stat = 11;\n \t\t\t\t\t\t\t\tbreak;\n \n \t\t\t\t\t\t\tdefault:\n \t\t\t\t\t\t\t\t_php_iconv_appendc(pretval, *p1, cd_pl);\n \t\t\t\t\t\t\t\tscan_stat = 12;\n \t\t\t\t\t\t\t\tbreak;\n \t\t\t\t\t\t}\n \t\t\t\t\t} break;\n \t\t\t\t}\n \t\t\t\tbreak;\n \n \t\t\tcase 10:\n \t\t\t\tif (*p1 == '?') {\n \t\t\t\t\tscan_stat = 3;\n \t\t\t\t}\n \t\t\t\tbreak;\n \n \t\t\tcase 11:\n \t\t\t\tswitch (*p1) {\n \t\t\t\t\tcase '\\r':\n \t\t\t\t\t\tscan_stat = 7;\n \t\t\t\t\t\tbreak;\n \n \t\t\t\t\tcase '\\n':\n \t\t\t\t\t\tscan_stat = 8;\n \t\t\t\t\t\tbreak;\n \n \t\t\t\t\tcase '=':\n \t\t\t\t\t\tif (spaces != NULL && encoded_word == NULL) {\n \t\t\t\t\t\t\t_php_iconv_appendl(pretval, spaces, (size_t)(p1 - spaces), cd_pl);\n \t\t\t\t\t\t\tspaces = NULL;\n \t\t\t\t\t\t}\n \t\t\t\t\t\tencoded_word = p1;\n \t\t\t\t\t\tscan_stat = 1;\n \t\t\t\t\t\tbreak;\n \n \t\t\t\t\tcase ' ': case '\\t':\n \t\t\t\t\t\tbreak;\n \n \t\t\t\t\tdefault:\n \t\t\t\t\t\tif (spaces != NULL) {\n \t\t\t\t\t\t\t_php_iconv_appendl(pretval, spaces, (size_t)(p1 - spaces), cd_pl);\n \t\t\t\t\t\t\tspaces = NULL;\n \t\t\t\t\t\t}\n \t\t\t\t\t\t_php_iconv_appendc(pretval, *p1, cd_pl);\n \t\t\t\t\t\tencoded_word = NULL;\n \t\t\t\t\t\tif ((mode & PHP_ICONV_MIME_DECODE_STRICT)) {\n \t\t\t\t\t\t\tscan_stat = 12;\n \t\t\t\t\t\t} else {\n \t\t\t\t\t\t\tscan_stat = 0;\n \t\t\t\t\t\t}\n \t\t\t\t\t\tbreak;\n \t\t\t\t}\n \t\t\t\tbreak;\n \n \t\t\tcase 12:\n \t\t\t\tswitch (*p1) {\n \t\t\t\t\tcase '\\r':\n \t\t\t\t\t\tscan_stat = 7;\n \t\t\t\t\t\tbreak;\n \n \t\t\t\t\tcase '\\n':\n \t\t\t\t\t\tscan_stat = 8;\n \t\t\t\t\t\tbreak;\n \n \t\t\t\t\tcase ' ': case '\\t':\n \t\t\t\t\t\tspaces = p1;\n \t\t\t\t\t\tscan_stat = 11;\n \t\t\t\t\t\tbreak;\n \n \t\t\t\t\tcase '=':\n \t\t\t\t\t\tif (!(mode & PHP_ICONV_MIME_DECODE_STRICT)) {\n \t\t\t\t\t\t\tencoded_word = p1;\n \t\t\t\t\t\t\tscan_stat = 1;\n \t\t\t\t\t\t\tbreak;\n \t\t\t\t\t\t}\n \n \t\t\t\t\tdefault:\n \t\t\t\t\t\t_php_iconv_appendc(pretval, *p1, cd_pl);\n \t\t\t\t\t\tbreak;\n \t\t\t\t}\n \t\t\t\tbreak;\n \t\t}\n \t}\n \tswitch (scan_stat) {\n \t\tcase 0: case 8: case 11: case 12:\n \t\t\tbreak;\n \t\tdefault:\n \t\t\tif ((mode & PHP_ICONV_MIME_DECODE_CONTINUE_ON_ERROR)) {\n \t\t\t\tif (scan_stat == 1) {\n \t\t\t\t\t_php_iconv_appendc(pretval, '=', cd_pl);\n \t\t\t\t}\n \t\t\t\terr = PHP_ICONV_ERR_SUCCESS;\n \t\t\t} else {\n \t\t\t\terr = PHP_ICONV_ERR_MALFORMED;\n \t\t\t\tgoto out;\n \t\t\t}\n \t}\n \n \tif (next_pos != NULL) {\n \t\t*next_pos = p1;\n \t}\n \n \tsmart_str_0(pretval);\n out:\n \tif (cd != (iconv_t)(-1)) {\n \t\ticonv_close(cd);\n \t}\n \tif (cd_pl != (iconv_t)(-1)) {\n \t\ticonv_close(cd_pl);\n \t}\n \treturn err;\n }\n \n", "target": "// fix_start\n\t\t\t\t\t\t\t\tif (str_left > 1) {\n\t\t\t\t\t\t\t\t\t--str_left;\n\t\t\t\t\t\t\t\t}\n// fix_end\n", "cwe": "CWE-125", "cwe_name": "Out-of-bounds Read", "cve": "CVE-2019-11039", "cve_desc": "Function iconv_mime_decode_headers() in PHP versions 7.1.x below 7.1.30, 7.2.x below 7.2.19 and 7.3.x below 7.3.6 may perform out-of-buffer read due to integer overflow when parsing MIME headers. This may lead to information disclosure or crash.", "project": "php-src", "idx": 206554}
{"source": " static void *gp_worker_main(void *pvt)\n {\n     struct gp_thread *t = (struct gp_thread *)pvt;\n     struct gp_query *q = NULL;\n     char dummy = 0;\n     int ret;\n \n     while (!t->pool->shutdown) {\n \n         gp_debug_set_conn_id(0);\n \n         pthread_mutex_lock(&t->cond_mutex);\n         while (t->query == NULL) {\n             pthread_cond_wait(&t->cond_wakeup, &t->cond_mutex);\n             if (t->pool->shutdown) {\n// bug_start\n// bug_end\n                 pthread_exit(NULL);\n             }\n         }\n \n         q = t->query;\n         t->query = NULL;\n \n         pthread_mutex_unlock(&t->cond_mutex);\n \n         gp_debug_set_conn_id(gp_conn_get_cid(q->conn));\n \n         GPDEBUGN(3, \"[status] Handling query input: %p (%zu)\\n\", q->buffer,\n                  q->buflen);\n         gp_handle_query(t->pool, q);\n         GPDEBUGN(3 ,\"[status] Handling query output: %p (%zu)\\n\", q->buffer,\n                  q->buflen);\n \n         pthread_mutex_lock(&t->pool->lock);\n \n         q->next = t->pool->reply_list;\n         t->pool->reply_list = q;\n \n         if (!t->pool->shutdown) {\n             LIST_DEL(t->pool->busy_list, t);\n             LIST_ADD(t->pool->free_list, t);\n         }\n \n         pthread_mutex_unlock(&t->pool->lock);\n \n         ret = write(t->pool->sig_pipe[1], &dummy, 1);\n         if (ret == -1) {\n             GPERROR(\"Failed to signal dispatcher!\");\n         }\n     }\n \n     pthread_exit(NULL);\n }\n \n", "target": "// fix_start\n                pthread_mutex_unlock(&t->cond_mutex);\n// fix_end\n", "cwe": "CWE-667", "cwe_name": "Improper Locking", "cve": "CVE-2020-12658", "cve_desc": "gssproxy (aka gss-proxy) before 0.8.3 does not unlock cond_mutex before pthread exit in gp_worker_main() in gp_workers.c. NOTE: An upstream comment states \"We are already on a shutdown path when running the code in question, so a DoS there doesn't make any sense, and there has been no additional information provided us (as upstream) to indicate why this would be a problem.", "project": "gssproxy", "idx": 206559}
{"source": " static int llcp_sock_bind(struct socket *sock, struct sockaddr *addr, int alen)\n {\n \tstruct sock *sk = sock->sk;\n \tstruct nfc_llcp_sock *llcp_sock = nfc_llcp_sock(sk);\n \tstruct nfc_llcp_local *local;\n \tstruct nfc_dev *dev;\n \tstruct sockaddr_nfc_llcp llcp_addr;\n \tint len, ret = 0;\n \n \tif (!addr || alen < offsetofend(struct sockaddr, sa_family) ||\n \t    addr->sa_family != AF_NFC)\n \t\treturn -EINVAL;\n \n \tpr_debug(\"sk %p addr %p family %d\\n\", sk, addr, addr->sa_family);\n \n \tmemset(&llcp_addr, 0, sizeof(llcp_addr));\n \tlen = min_t(unsigned int, sizeof(llcp_addr), alen);\n \tmemcpy(&llcp_addr, addr, len);\n \n \tif (llcp_addr.dsap != 0)\n \t\treturn -EINVAL;\n \n \tlock_sock(sk);\n \n \tif (sk->sk_state != LLCP_CLOSED) {\n \t\tret = -EBADFD;\n \t\tgoto error;\n \t}\n \n \tdev = nfc_get_device(llcp_addr.dev_idx);\n \tif (dev == NULL) {\n \t\tret = -ENODEV;\n \t\tgoto error;\n \t}\n \n \tlocal = nfc_llcp_find_local(dev);\n \tif (local == NULL) {\n \t\tret = -ENODEV;\n \t\tgoto put_dev;\n \t}\n \n \tllcp_sock->dev = dev;\n \tllcp_sock->local = nfc_llcp_local_get(local);\n \tllcp_sock->nfc_protocol = llcp_addr.nfc_protocol;\n \tllcp_sock->service_name_len = min_t(unsigned int,\n \t\t\t\t\t    llcp_addr.service_name_len,\n \t\t\t\t\t    NFC_LLCP_MAX_SERVICE_NAME);\n \tllcp_sock->service_name = kmemdup(llcp_addr.service_name,\n \t\t\t\t\t  llcp_sock->service_name_len,\n \t\t\t\t\t  GFP_KERNEL);\n \tif (!llcp_sock->service_name) {\n \t\tnfc_llcp_local_put(llcp_sock->local);\n \t\tllcp_sock->local = NULL;\n// bug_start\n// bug_end\n \t\tret = -ENOMEM;\n \t\tgoto put_dev;\n \t}\n \tllcp_sock->ssap = nfc_llcp_get_sdp_ssap(local, llcp_sock);\n \tif (llcp_sock->ssap == LLCP_SAP_MAX) {\n \t\tnfc_llcp_local_put(llcp_sock->local);\n \t\tllcp_sock->local = NULL;\n \t\tkfree(llcp_sock->service_name);\n \t\tllcp_sock->service_name = NULL;\n// bug_start\n// bug_end\n \t\tret = -EADDRINUSE;\n \t\tgoto put_dev;\n \t}\n \n \tllcp_sock->reserved_ssap = llcp_sock->ssap;\n \n \tnfc_llcp_sock_link(&local->sockets, sk);\n \n \tpr_debug(\"Socket bound to SAP %d\\n\", llcp_sock->ssap);\n \n \tsk->sk_state = LLCP_BOUND;\n \n put_dev:\n \tnfc_put_device(dev);\n \n error:\n \trelease_sock(sk);\n \treturn ret;\n }\n \n", "target": "// fix_start\n\t\tllcp_sock->dev = NULL;\n// fix_end\n// fix_start\n\t\tllcp_sock->dev = NULL;\n// fix_end\n", "cwe": "CWE-476", "cwe_name": "NULL Pointer Dereference", "cve": "CVE-2021-38208", "cve_desc": "net/nfc/llcp_sock.c in the Linux kernel before 5.12.10 allows local unprivileged users to cause a denial of service (NULL pointer dereference and BUG) by making a getsockname call after a certain type of failure of a bind call.", "project": "linux", "idx": 206589}
{"source": " start_input_gif(j_compress_ptr cinfo, cjpeg_source_ptr sinfo)\n {\n   gif_source_ptr source = (gif_source_ptr)sinfo;\n   U_CHAR hdrbuf[10];\n   unsigned int width, height;\n   int colormaplen, aspectRatio;\n   int c;\n \n   if (!ReadOK(source->pub.input_file, hdrbuf, 6))\n     ERREXIT(cinfo, JERR_GIF_NOT);\n   if (hdrbuf[0] != 'G' || hdrbuf[1] != 'I' || hdrbuf[2] != 'F')\n     ERREXIT(cinfo, JERR_GIF_NOT);\n   if ((hdrbuf[3] != '8' || hdrbuf[4] != '7' || hdrbuf[5] != 'a') &&\n       (hdrbuf[3] != '8' || hdrbuf[4] != '9' || hdrbuf[5] != 'a'))\n     TRACEMS3(cinfo, 1, JTRC_GIF_BADVERSION, hdrbuf[3], hdrbuf[4], hdrbuf[5]);\n \n   if (!ReadOK(source->pub.input_file, hdrbuf, 7))\n     ERREXIT(cinfo, JERR_INPUT_EOF);\n   width = LM_to_uint(hdrbuf, 0);\n   height = LM_to_uint(hdrbuf, 2);\n// bug_start\n// bug_end\n   aspectRatio = UCH(hdrbuf[6]);\n   if (aspectRatio != 0 && aspectRatio != 49)\n     TRACEMS(cinfo, 1, JTRC_GIF_NONSQUARE);\n \n   source->colormap = (*cinfo->mem->alloc_sarray)\n     ((j_common_ptr)cinfo, JPOOL_IMAGE, (JDIMENSION)MAXCOLORMAPSIZE,\n      (JDIMENSION)NUMCOLORS);\n   colormaplen = 0;\n \n   if (BitSet(hdrbuf[4], COLORMAPFLAG)) {\n     colormaplen = 2 << (hdrbuf[4] & 0x07);\n     ReadColorMap(source, colormaplen, source->colormap);\n   }\n \n   for (;;) {\n     c = ReadByte(source);\n \n     if (c == ';')\n       ERREXIT(cinfo, JERR_GIF_IMAGENOTFOUND);\n \n     if (c == '!') {\n       DoExtension(source);\n       continue;\n     }\n \n     if (c != ',') {\n       WARNMS1(cinfo, JWRN_GIF_CHAR, c);\n       continue;\n     }\n \n     if (!ReadOK(source->pub.input_file, hdrbuf, 9))\n       ERREXIT(cinfo, JERR_INPUT_EOF);\n     width = LM_to_uint(hdrbuf, 4);\n     height = LM_to_uint(hdrbuf, 6);\n// bug_start\n// bug_end\n     source->is_interlaced = (BitSet(hdrbuf[8], INTERLACE) != 0);\n \n     if (BitSet(hdrbuf[8], COLORMAPFLAG)) {\n       colormaplen = 2 << (hdrbuf[8] & 0x07);\n       ReadColorMap(source, colormaplen, source->colormap);\n     }\n \n     source->input_code_size = ReadByte(source);\n     if (source->input_code_size < 2 || source->input_code_size > 8)\n       ERREXIT1(cinfo, JERR_GIF_CODESIZE, source->input_code_size);\n \n     break;\n   }\n \n   source->symbol_head = (UINT16 *)\n     (*cinfo->mem->alloc_large) ((j_common_ptr)cinfo, JPOOL_IMAGE,\n                                 LZW_TABLE_SIZE * sizeof(UINT16));\n   source->symbol_tail = (UINT8 *)\n     (*cinfo->mem->alloc_large) ((j_common_ptr)cinfo, JPOOL_IMAGE,\n                                 LZW_TABLE_SIZE * sizeof(UINT8));\n   source->symbol_stack = (UINT8 *)\n     (*cinfo->mem->alloc_large) ((j_common_ptr)cinfo, JPOOL_IMAGE,\n                                 LZW_TABLE_SIZE * sizeof(UINT8));\n   InitLZWCode(source);\n \n   if (source->is_interlaced) {\n     source->interlaced_image = (*cinfo->mem->request_virt_sarray)\n       ((j_common_ptr)cinfo, JPOOL_IMAGE, FALSE,\n        (JDIMENSION)width, (JDIMENSION)height, (JDIMENSION)1);\n     if (cinfo->progress != NULL) {\n       cd_progress_ptr progress = (cd_progress_ptr)cinfo->progress;\n       progress->total_extra_passes++;\n     }\n     source->pub.get_pixel_rows = load_interlaced_image;\n   } else {\n     source->pub.get_pixel_rows = get_pixel_rows;\n   }\n \n   source->pub.buffer = (*cinfo->mem->alloc_sarray)\n     ((j_common_ptr)cinfo, JPOOL_IMAGE, (JDIMENSION)width * NUMCOLORS,\n      (JDIMENSION)1);\n   source->pub.buffer_height = 1;\n \n   for (c = colormaplen; c < source->clear_code; c++) {\n     source->colormap[CM_RED][c]   =\n     source->colormap[CM_GREEN][c] =\n     source->colormap[CM_BLUE][c]  = CENTERJSAMPLE;\n   }\n \n   cinfo->in_color_space = JCS_RGB;\n   cinfo->input_components = NUMCOLORS;\n   cinfo->data_precision = BITS_IN_JSAMPLE;\n   cinfo->image_width = width;\n   cinfo->image_height = height;\n \n   TRACEMS3(cinfo, 1, JTRC_GIF, width, height, colormaplen);\n }\n \n", "target": "// fix_start\n  if (width == 0 || height == 0)\n    ERREXIT(cinfo, JERR_GIF_EMPTY);\n// fix_end\n// fix_start\n    if (width == 0 || height == 0)\n      ERREXIT(cinfo, JERR_GIF_EMPTY);\n// fix_end\n", "cwe": "CWE-369", "cwe_name": "Divide By Zero", "cve": "CVE-2021-20205", "cve_desc": "Libjpeg-turbo versions 2.0.91 and 2.0.90 is vulnerable to a denial of service vulnerability caused by a divide by zero when processing a crafted GIF image.", "project": "libjpeg-turbo", "idx": 206616}
{"source": " exif_entry_get_value (ExifEntry *e, char *val, unsigned int maxlen)\n {\n \tunsigned int i, j, k;\n \tExifShort v_short, v_short2, v_short3, v_short4;\n \tExifByte v_byte;\n \tExifRational v_rat;\n \tExifSRational v_srat;\n \tchar b[64];\n \tconst char *c;\n \tExifByteOrder o;\n \tdouble d;\n \tExifEntry *entry;\n \tstatic const struct {\n \t\tchar label[5];\n \t\tchar major, minor;\n \t} versions[] = {\n \t\t{\"0110\", 1,  1},\n \t\t{\"0120\", 1,  2},\n \t\t{\"0200\", 2,  0},\n \t\t{\"0210\", 2,  1},\n \t\t{\"0220\", 2,  2},\n \t\t{\"0221\", 2, 21},\n \t\t{\"0230\", 2,  3},\n \t\t{\"\"    , 0,  0}\n \t};\n \n \t(void) bindtextdomain (GETTEXT_PACKAGE, LOCALEDIR);\n \n \tif (!e || !e->parent || !e->parent->parent || !maxlen || !val)\n \t\treturn val;\n \n \tmemset (val, 0, maxlen);\n \n \to = exif_data_get_byte_order (e->parent->parent);\n \n \tif (e->size != e->components * exif_format_get_size (e->format)) {\n \t\tsnprintf (val, maxlen, _(\"Invalid size of entry (%i, \"\n \t\t\t\"expected %li x %i).\"), e->size, e->components,\n \t\t\t\texif_format_get_size (e->format));\n \t\treturn val;\n \t}\n \n \tswitch (e->tag) {\n \tcase EXIF_TAG_USER_COMMENT:\n \n \t\tif ((e->format != EXIF_FORMAT_ASCII) ||\n \t\t    (e->size <= 8) ||\n \t\t    ( memcmp (e->data, \"ASCII\\0\\0\\0\"  , 8) &&\n \t\t      memcmp (e->data, \"UNICODE\\0\"    , 8) &&\n \t\t      memcmp (e->data, \"JIS\\0\\0\\0\\0\\0\", 8) &&\n \t\t      memcmp (e->data, \"\\0\\0\\0\\0\\0\\0\\0\\0\", 8)))\n \t\t\tCF (e, EXIF_FORMAT_UNDEFINED, val, maxlen);\n \n \t\tif ((e->size >= 8) && !memcmp (e->data, \"ASCII\\0\\0\\0\", 8)) {\n \t\t\tstrncpy (val, (char *) e->data + 8, MIN (e->size - 8, maxlen-1));\n \t\t\tbreak;\n \t\t}\n \t\tif ((e->size >= 8) && !memcmp (e->data, \"UNICODE\\0\", 8)) {\n \t\t\tstrncpy (val, _(\"Unsupported UNICODE string\"), maxlen-1);\n \t\t\tbreak;\n \t\t}\n \t\tif ((e->size >= 8) && !memcmp (e->data, \"JIS\\0\\0\\0\\0\\0\", 8)) {\n \t\t\tstrncpy (val, _(\"Unsupported JIS string\"), maxlen-1);\n \t\t\tbreak;\n \t\t}\n \n \t\tfor (i = 0; (i < e->size) &&\n \t\t\t    (!e->data[i] || (e->data[i] == ' ')); i++);\n \t\tif (i == e->size) break;\n \n \t\texif_entry_log (e, EXIF_LOG_CODE_DEBUG,\n \t\t\t_(\"Tag UserComment contains data but is \"\n \t\t\t  \"against specification.\"));\n  \t\tfor (j = 0; (i < e->size) && (j < maxlen-1); i++, j++) {\n \t\t\texif_entry_log (e, EXIF_LOG_CODE_DEBUG,\n \t\t\t\t_(\"Byte at position %i: 0x%02x\"), i, e->data[i]);\n  \t\t\tval[j] = isprint (e->data[i]) ? e->data[i] : '.';\n \t\t}\n \t\tbreak;\n \n \tcase EXIF_TAG_EXIF_VERSION:\n \t\tCF (e, EXIF_FORMAT_UNDEFINED, val, maxlen);\n \t\tCC (e, 4, val, maxlen);\n \t\tstrncpy (val, _(\"Unknown Exif Version\"), maxlen-1);\n \t\tfor (i = 0; *versions[i].label; i++) {\n \t\t\tif (!memcmp (e->data, versions[i].label, 4)) {\n     \t\t\t\tsnprintf (val, maxlen,\n \t\t\t\t\t_(\"Exif Version %d.%d\"),\n \t\t\t\t\tversions[i].major,\n \t\t\t\t\tversions[i].minor);\n     \t\t\t\tbreak;\n \t\t\t}\n \t\t}\n \t\tbreak;\n \tcase EXIF_TAG_FLASH_PIX_VERSION:\n \t\tCF (e, EXIF_FORMAT_UNDEFINED, val, maxlen);\n \t\tCC (e, 4, val, maxlen);\n \t\tif (!memcmp (e->data, \"0100\", 4))\n \t\t\tstrncpy (val, _(\"FlashPix Version 1.0\"), maxlen-1);\n \t\telse if (!memcmp (e->data, \"0101\", 4))\n \t\t\tstrncpy (val, _(\"FlashPix Version 1.01\"), maxlen-1);\n \t\telse\n \t\t\tstrncpy (val, _(\"Unknown FlashPix Version\"), maxlen-1);\n \t\tbreak;\n \tcase EXIF_TAG_COPYRIGHT:\n \t\tCF (e, EXIF_FORMAT_ASCII, val, maxlen);\n \n \t\tif (e->size && e->data && match_repeated_char(e->data, ' ', e->size))\n \t\t\tstrncpy (val, (char *) e->data, MIN (maxlen-1, e->size));\n \t\telse\n \t\t\tstrncpy (val, _(\"[None]\"), maxlen-1);\n \t\tstrncat (val, \" \", maxlen-1 - strlen (val));\n \t\tstrncat (val, _(\"(Photographer)\"), maxlen-1 - strlen (val));\n \n \t\tstrncat (val, \" - \", maxlen-1 - strlen (val));\n \t\tk = 0;\n \t\tif (e->size && e->data) {\n \t\t\tconst unsigned char *tagdata = memchr(e->data, 0, e->size);\n \t\t\tif (tagdata++) {\n \t\t\t\tunsigned int editor_ofs = tagdata - e->data;\n \t\t\t\tunsigned int remaining = e->size - editor_ofs;\n \t\t\t\tif (match_repeated_char(tagdata, ' ', remaining)) {\n \t\t\t\t\tstrncat (val, (const char*)tagdata, MIN (maxlen-1 - strlen (val), remaining));\n \t\t\t\t\t++k;\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \t\tif (!k)\n \t\t\tstrncat (val, _(\"[None]\"), maxlen-1 - strlen (val));\n \t\tstrncat (val, \" \", maxlen-1 - strlen (val));\n \t\tstrncat (val, _(\"(Editor)\"), maxlen-1 - strlen (val));\n \n \t\tbreak;\n \tcase EXIF_TAG_FNUMBER:\n \t\tCF (e, EXIF_FORMAT_RATIONAL, val, maxlen);\n \t\tCC (e, 1, val, maxlen);\n \t\tv_rat = exif_get_rational (e->data, o);\n \t\tif (!v_rat.denominator) {\n \t\t\texif_entry_format_value(e, val, maxlen);\n \t\t\tbreak;\n \t\t}\n \t\td = (double) v_rat.numerator / (double) v_rat.denominator;\n \t\tsnprintf (val, maxlen, \"f/%.01f\", d);\n \t\tbreak;\n \tcase EXIF_TAG_APERTURE_VALUE:\n \tcase EXIF_TAG_MAX_APERTURE_VALUE:\n \t\tCF (e, EXIF_FORMAT_RATIONAL, val, maxlen);\n \t\tCC (e, 1, val, maxlen);\n \t\tv_rat = exif_get_rational (e->data, o);\n \t\tif (!v_rat.denominator || (0x80000000 == v_rat.numerator)) {\n \t\t\texif_entry_format_value(e, val, maxlen);\n \t\t\tbreak;\n \t\t}\n \t\td = (double) v_rat.numerator / (double) v_rat.denominator;\n \t\tsnprintf (val, maxlen, _(\"%.02f EV\"), d);\n \t\tsnprintf (b, sizeof (b), _(\" (f/%.01f)\"), pow (2, d / 2.));\n \t\tstrncat (val, b, maxlen-1 - strlen (val));\n \t\tbreak;\n \tcase EXIF_TAG_FOCAL_LENGTH:\n \t\tCF (e, EXIF_FORMAT_RATIONAL, val, maxlen);\n \t\tCC (e, 1, val, maxlen);\n \t\tv_rat = exif_get_rational (e->data, o);\n \t\tif (!v_rat.denominator) {\n \t\t\texif_entry_format_value(e, val, maxlen);\n \t\t\tbreak;\n \t\t}\n \n \t\td = 0.;\n \t\tentry = exif_content_get_entry (\n \t\t\te->parent->parent->ifd[EXIF_IFD_0], EXIF_TAG_MAKE);\n \t\tif (entry && entry->data && entry->size >= 7 &&\n \t\t    !strncmp ((char *)entry->data, \"Minolta\", 7)) {\n \t\t\tentry = exif_content_get_entry (\n \t\t\t\t\te->parent->parent->ifd[EXIF_IFD_0],\n \t\t\t\t\tEXIF_TAG_MODEL);\n \t\t\tif (entry && entry->data && entry->size >= 8) {\n \t\t\t\tif (!strncmp ((char *)entry->data, \"DiMAGE 7\", 8))\n \t\t\t\t\td = 3.9;\n \t\t\t\telse if (!strncmp ((char *)entry->data, \"DiMAGE 5\", 8))\n \t\t\t\t\td = 4.9;\n \t\t\t}\n \t\t}\n \t\tif (d)\n \t\t\tsnprintf (b, sizeof (b), _(\" (35 equivalent: %.0f mm)\"),\n \t\t\t\t  (d * (double) v_rat.numerator /\n \t\t\t\t       (double) v_rat.denominator));\n \t\telse\n \t\t\tb[0] = 0;\n \n \t\td = (double) v_rat.numerator / (double) v_rat.denominator;\n \t\tsnprintf (val, maxlen, \"%.1f mm\", d);\n \t\tstrncat (val, b, maxlen-1 - strlen (val));\n \t\tbreak;\n \tcase EXIF_TAG_SUBJECT_DISTANCE:\n \t\tCF (e, EXIF_FORMAT_RATIONAL, val, maxlen);\n \t\tCC (e, 1, val, maxlen);\n \t\tv_rat = exif_get_rational (e->data, o);\n \t\tif (!v_rat.denominator) {\n \t\t\texif_entry_format_value(e, val, maxlen);\n \t\t\tbreak;\n \t\t}\n \t\td = (double) v_rat.numerator / (double) v_rat.denominator;\n \t\tsnprintf (val, maxlen, \"%.1f m\", d);\n \t\tbreak;\n \tcase EXIF_TAG_EXPOSURE_TIME:\n \t\tCF (e, EXIF_FORMAT_RATIONAL, val, maxlen);\n \t\tCC (e, 1, val, maxlen);\n \t\tv_rat = exif_get_rational (e->data, o);\n \t\tif (!v_rat.denominator) {\n \t\t\texif_entry_format_value(e, val, maxlen);\n \t\t\tbreak;\n \t\t}\n \t\td = (double) v_rat.numerator / (double) v_rat.denominator;\n \t\tif (d < 1 && d)\n \t\t\tsnprintf (val, maxlen, _(\"1/%.0f\"), 1. / d);\n \t\telse\n \t\t\tsnprintf (val, maxlen, \"%.0f\", d);\n \t\tstrncat (val, _(\" sec.\"), maxlen-1 - strlen (val));\n \t\tbreak;\n \tcase EXIF_TAG_SHUTTER_SPEED_VALUE:\n \t\tCF (e, EXIF_FORMAT_SRATIONAL, val, maxlen);\n \t\tCC (e, 1, val, maxlen);\n \t\tv_srat = exif_get_srational (e->data, o);\n \t\tif (!v_srat.denominator) {\n \t\t\texif_entry_format_value(e, val, maxlen);\n \t\t\tbreak;\n \t\t}\n \t\td = (double) v_srat.numerator / (double) v_srat.denominator;\n \t\tsnprintf (val, maxlen, _(\"%.02f EV\"), d);\n \t\tif (pow (2, d))\n \t\t\td = 1. / pow (2, d);\n \t\tif (d < 1 && d)\n \t\t  snprintf (b, sizeof (b), _(\" (1/%.0f sec.)\"), 1. / d);\n \t\telse\n \t\t  snprintf (b, sizeof (b), _(\" (%.0f sec.)\"), d);\n \t\tstrncat (val, b, maxlen-1 - strlen (val));\n \t\tbreak;\n \tcase EXIF_TAG_BRIGHTNESS_VALUE:\n \t\tCF (e, EXIF_FORMAT_SRATIONAL, val, maxlen);\n \t\tCC (e, 1, val, maxlen);\n \t\tv_srat = exif_get_srational (e->data, o);\n \t\tif (!v_srat.denominator) {\n \t\t\texif_entry_format_value(e, val, maxlen);\n \t\t\tbreak;\n \t\t}\n \t\td = (double) v_srat.numerator / (double) v_srat.denominator;\n \t\tsnprintf (val, maxlen, _(\"%.02f EV\"), d);\n \t\tsnprintf (b, sizeof (b), _(\" (%.02f cd/m^2)\"),\n \t\t\t1. / (M_PI * 0.3048 * 0.3048) * pow (2, d));\n \t\tstrncat (val, b, maxlen-1 - strlen (val));\n \t\tbreak;\n \tcase EXIF_TAG_FILE_SOURCE:\n \t\tCF (e, EXIF_FORMAT_UNDEFINED, val, maxlen);\n \t\tCC (e, 1, val, maxlen);\n \t\tv_byte = e->data[0];\n \t\tif (v_byte == 3)\n \t\t\tstrncpy (val, _(\"DSC\"), maxlen-1);\n \t\telse\n \t\t\tsnprintf (val, maxlen, _(\"Internal error (unknown \"\n \t\t\t\t  \"value %i)\"), v_byte);\n \t\tbreak;\n \tcase EXIF_TAG_COMPONENTS_CONFIGURATION:\n \t\tCF (e, EXIF_FORMAT_UNDEFINED, val, maxlen);\n \t\tCC (e, 4, val, maxlen);\n \t\tfor (i = 0; i < 4; i++) {\n \t\t\tswitch (e->data[i]) {\n \t\t\tcase 0: c = _(\"-\"); break;\n \t\t\tcase 1: c = _(\"Y\"); break;\n \t\t\tcase 2: c = _(\"Cb\"); break;\n \t\t\tcase 3: c = _(\"Cr\"); break;\n \t\t\tcase 4: c = _(\"R\"); break;\n \t\t\tcase 5: c = _(\"G\"); break;\n \t\t\tcase 6: c = _(\"B\"); break;\n \t\t\tdefault: c = _(\"Reserved\"); break;\n \t\t\t}\n \t\t\tstrncat (val, c, maxlen-1 - strlen (val));\n \t\t\tif (i < 3)\n \t\t\t\tstrncat (val, \" \", maxlen-1 - strlen (val));\n \t\t}\n \t\tbreak;\n \tcase EXIF_TAG_EXPOSURE_BIAS_VALUE:\n \t\tCF (e, EXIF_FORMAT_SRATIONAL, val, maxlen);\n \t\tCC (e, 1, val, maxlen);\n \t\tv_srat = exif_get_srational (e->data, o);\n \t\tif (!v_srat.denominator) {\n \t\t\texif_entry_format_value(e, val, maxlen);\n \t\t\tbreak;\n \t\t}\n \t\td = (double) v_srat.numerator / (double) v_srat.denominator;\n \t\tsnprintf (val, maxlen, _(\"%.02f EV\"), d);\n \t\tbreak;\n \tcase EXIF_TAG_SCENE_TYPE:\n \t\tCF (e, EXIF_FORMAT_UNDEFINED, val, maxlen);\n \t\tCC (e, 1, val, maxlen);\n \t\tv_byte = e->data[0];\n \t\tif (v_byte == 1)\n \t\t\tstrncpy (val, _(\"Directly photographed\"), maxlen-1);\n \t\telse\n \t\t\tsnprintf (val, maxlen, _(\"Internal error (unknown \"\n \t\t\t\t  \"value %i)\"), v_byte);\n \t\tbreak;\n \tcase EXIF_TAG_YCBCR_SUB_SAMPLING:\n \t\tCF (e, EXIF_FORMAT_SHORT, val, maxlen);\n \t\tCC (e, 2, val, maxlen);\n \t\tv_short  = exif_get_short (e->data, o);\n \t\tv_short2 = exif_get_short (\n \t\t\te->data + exif_format_get_size (e->format),\n \t\t\to);\n \t\tif ((v_short == 2) && (v_short2 == 1))\n \t\t\tstrncpy (val, _(\"YCbCr4:2:2\"), maxlen-1);\n \t\telse if ((v_short == 2) && (v_short2 == 2))\n \t\t\tstrncpy (val, _(\"YCbCr4:2:0\"), maxlen-1);\n \t\telse\n \t\t\tsnprintf (val, maxlen, \"%u, %u\", v_short, v_short2);\n \t\tbreak;\n \tcase EXIF_TAG_SUBJECT_AREA:\n \t\tCF (e, EXIF_FORMAT_SHORT, val, maxlen);\n \t\tswitch (e->components) {\n \t\tcase 2:\n \t\t\tv_short  = exif_get_short (e->data, o);\n \t\t\tv_short2 = exif_get_short (e->data + 2, o);\n \t\t\tsnprintf (val, maxlen, \"(x,y) = (%i,%i)\",\n \t\t\t\t  v_short, v_short2);\n \t\t\tbreak;\n \t\tcase 3:\n \t\t\tv_short  = exif_get_short (e->data, o);\n \t\t\tv_short2 = exif_get_short (e->data + 2, o);\n \t\t\tv_short3 = exif_get_short (e->data + 4, o);\n \t\t\tsnprintf (val, maxlen, _(\"Within distance %i of \"\n \t\t\t\t\"(x,y) = (%i,%i)\"), v_short3, v_short,\n \t\t\t\tv_short2);\n \t\t\tbreak;\n \t\tcase 4:\n \t\t\tv_short  = exif_get_short (e->data, o);\n \t\t\tv_short2 = exif_get_short (e->data + 2, o);\n \t\t\tv_short3 = exif_get_short (e->data + 4, o);\n \t\t\tv_short4 = exif_get_short (e->data + 6, o);\n \t\t\tsnprintf (val, maxlen, _(\"Within rectangle \"\n \t\t\t\t\"(width %i, height %i) around \"\n \t\t\t\t\"(x,y) = (%i,%i)\"), v_short3, v_short4,\n \t\t\t\tv_short, v_short2);\n \t\t\tbreak;\n \t\tdefault:\n \t\t\tsnprintf (val, maxlen, _(\"Unexpected number \"\n \t\t\t\t\"of components (%li, expected 2, 3, or 4).\"),\n \t\t\t\te->components);\n \t\t}\n \t\tbreak;\n \tcase EXIF_TAG_GPS_VERSION_ID:\n \t\tCF (e, EXIF_FORMAT_BYTE, val, maxlen);\n \t\tCC (e, 4, val, maxlen);\n \t\tv_byte = e->data[0];\n \t\tsnprintf (val, maxlen, \"%u\", v_byte);\n \t\tfor (i = 1; i < e->components; i++) {\n \t\t\tv_byte = e->data[i];\n \t\t\tsnprintf (b, sizeof (b), \".%u\", v_byte);\n \t\t\tstrncat (val, b, maxlen-1 - strlen (val));\n \t\t}\n \t\tbreak;\n \tcase EXIF_TAG_INTEROPERABILITY_VERSION:\n \t\tif (e->format == EXIF_FORMAT_UNDEFINED) {\n \t\t\tstrncpy (val, (char *) e->data, MIN (maxlen-1, e->size));\n \t\t\tbreak;\n \t\t}\n \t\texif_entry_format_value(e, val, maxlen);\n \t\tbreak;\n \tcase EXIF_TAG_GPS_ALTITUDE_REF:\n \t\tCF (e, EXIF_FORMAT_BYTE, val, maxlen);\n \t\tCC (e, 1, val, maxlen);\n \t\tv_byte = e->data[0];\n \t\tif (v_byte == 0)\n \t\t\tstrncpy (val, _(\"Sea level\"), maxlen-1);\n \t\telse if (v_byte == 1)\n \t\t\tstrncpy (val, _(\"Sea level reference\"), maxlen-1);\n \t\telse\n \t\t\tsnprintf (val, maxlen, _(\"Internal error (unknown \"\n \t\t\t\t  \"value %i)\"), v_byte);\n \t\tbreak;\n \tcase EXIF_TAG_GPS_TIME_STAMP:\n \t\tCF (e, EXIF_FORMAT_RATIONAL, val, maxlen);\n \t\tCC (e, 3, val, maxlen);\n \n \t\tv_rat  = exif_get_rational (e->data, o);\n \t\tif (!v_rat.denominator) {\n \t\t\texif_entry_format_value(e, val, maxlen);\n \t\t\tbreak;\n \t\t}\n \t\ti = v_rat.numerator / v_rat.denominator;\n \n \t\tv_rat = exif_get_rational (e->data +\n \t\t\t\t\t     exif_format_get_size (e->format),\n \t\t\t\t\t   o);\n \t\tif (!v_rat.denominator) {\n \t\t\texif_entry_format_value(e, val, maxlen);\n \t\t\tbreak;\n \t\t}\n \t\tj = v_rat.numerator / v_rat.denominator;\n \n \t\tv_rat = exif_get_rational (e->data +\n \t\t\t\t\t     2*exif_format_get_size (e->format),\n \t\t\t\t\t     o);\n \t\tif (!v_rat.denominator) {\n \t\t\texif_entry_format_value(e, val, maxlen);\n \t\t\tbreak;\n \t\t}\n \t\td = (double) v_rat.numerator / (double) v_rat.denominator;\n \t\tsnprintf (val, maxlen, \"%02u:%02u:%05.2f\", i, j, d);\n \t\tbreak;\n \n \tcase EXIF_TAG_METERING_MODE:\n \tcase EXIF_TAG_COMPRESSION:\n \tcase EXIF_TAG_LIGHT_SOURCE:\n \tcase EXIF_TAG_FOCAL_PLANE_RESOLUTION_UNIT:\n \tcase EXIF_TAG_RESOLUTION_UNIT:\n \tcase EXIF_TAG_EXPOSURE_PROGRAM:\n \tcase EXIF_TAG_FLASH:\n \tcase EXIF_TAG_SUBJECT_DISTANCE_RANGE:\n \tcase EXIF_TAG_COLOR_SPACE:\n \t\tCF (e,EXIF_FORMAT_SHORT, val, maxlen);\n \t\tCC (e, 1, val, maxlen);\n \t\tv_short = exif_get_short (e->data, o);\n \n \t\tfor (i = 0; list2[i].tag && (list2[i].tag != e->tag); i++);\n \t\tif (!list2[i].tag) {\n \t\t\tsnprintf (val, maxlen, _(\"Internal error (unknown \"\n \t\t\t\t  \"value %i)\"), v_short);\n \t\t\tbreak;\n \t\t}\n \n \t\tfor (j = 0; list2[i].elem[j].values[0] &&\n \t\t\t    (list2[i].elem[j].index < v_short); j++);\n \t\tif (list2[i].elem[j].index != v_short) {\n \t\t\tsnprintf (val, maxlen, _(\"Internal error (unknown \"\n \t\t\t\t  \"value %i)\"), v_short);\n \t\t\tbreak;\n \t\t}\n \n \t\tmemset (val, 0, maxlen);\n \t\tfor (k = 0; list2[i].elem[j].values[k]; k++) {\n \t\t\tsize_t l = strlen (_(list2[i].elem[j].values[k]));\n \t\t\tif ((maxlen > l) && (strlen (val) < l))\n \t\t\t\tstrncpy (val, _(list2[i].elem[j].values[k]), maxlen-1);\n \t\t}\n \t\tif (!val[0]) snprintf (val, maxlen, \"%i\", v_short);\n \n \t\tbreak;\n \n \tcase EXIF_TAG_PLANAR_CONFIGURATION:\n \tcase EXIF_TAG_SENSING_METHOD:\n \tcase EXIF_TAG_ORIENTATION:\n \tcase EXIF_TAG_YCBCR_POSITIONING:\n \tcase EXIF_TAG_PHOTOMETRIC_INTERPRETATION:\n \tcase EXIF_TAG_CUSTOM_RENDERED:\n \tcase EXIF_TAG_EXPOSURE_MODE:\n \tcase EXIF_TAG_WHITE_BALANCE:\n \tcase EXIF_TAG_SCENE_CAPTURE_TYPE:\n \tcase EXIF_TAG_GAIN_CONTROL:\n \tcase EXIF_TAG_SATURATION:\n \tcase EXIF_TAG_CONTRAST:\n \tcase EXIF_TAG_SHARPNESS:\n \t\tCF (e, EXIF_FORMAT_SHORT, val, maxlen);\n \t\tCC (e, 1, val, maxlen);\n \t\tv_short = exif_get_short (e->data, o);\n \n \t\tfor (i = 0; list[i].tag && (list[i].tag != e->tag); i++);\n \t\tif (!list[i].tag) {\n \t\t\tsnprintf (val, maxlen, _(\"Internal error (unknown \"\n \t\t\t\t  \"value %i)\"), v_short);\n \t\t\tbreak;\n \t\t}\n \n \t\tfor (j = 0; list[i].strings[j] && (j < v_short); j++);\n \t\tif (!list[i].strings[j])\n \t\t\tsnprintf (val, maxlen, \"%i\", v_short);\n \t\telse if (!*list[i].strings[j])\n \t\t\tsnprintf (val, maxlen, _(\"Unknown value %i\"), v_short);\n \t\telse\n \t\t\tstrncpy (val, _(list[i].strings[j]), maxlen-1);\n \t\tbreak;\n \n \tcase EXIF_TAG_XP_TITLE:\n \tcase EXIF_TAG_XP_COMMENT:\n \tcase EXIF_TAG_XP_AUTHOR:\n \tcase EXIF_TAG_XP_KEYWORDS:\n \tcase EXIF_TAG_XP_SUBJECT:\n \t{\n \t\tunsigned char *utf16;\n \n// bug_start\n\t\tif (e->size+sizeof(uint16_t)+1 < e->size) break;\n// bug_end\n \n \t\tutf16 = exif_mem_alloc (e->priv->mem, e->size+sizeof(uint16_t)+1);\n \t\tif (!utf16) break;\n \t\tmemcpy(utf16, e->data, e->size);\n \n \t\tutf16[e->size] = 0;\n \t\tutf16[e->size+1] = 0;\n \t\tutf16[e->size+2] = 0;\n \n \t\texif_convert_utf16_to_utf8(val, utf16, maxlen);\n \t\texif_mem_free(e->priv->mem, utf16);\n \t\tbreak;\n \t}\n \n \tdefault:\n \t\texif_entry_format_value(e, val, maxlen);\n \t}\n \n \treturn val;\n }\n \n", "target": "// fix_start\n\t\tif (e->size >= 65536 - sizeof(uint16_t)*2) break;\n// fix_end\n", "cwe": "CWE-787", "cwe_name": "Out-of-bounds Write", "cve": "CVE-2020-0452", "cve_desc": "In exif_entry_get_value of exif-entry.c, there is a possible out of bounds write due to an integer overflow. This could lead to remote code execution if a third party app used this library to process remote image data with no additional execution privileges needed. User interaction is not needed for exploitation.Product: AndroidVersions: Android-8.1 Android-9 Android-10 Android-11 Android-8.0Android ID: A-159625731", "project": "libexif", "idx": 206645}
{"source": " static struct scatterlist *alloc_sgtable(int size)\n {\n \tint alloc_size, nents, i;\n \tstruct page *new_page;\n \tstruct scatterlist *iter;\n \tstruct scatterlist *table;\n \n \tnents = DIV_ROUND_UP(size, PAGE_SIZE);\n \ttable = kcalloc(nents, sizeof(*table), GFP_KERNEL);\n \tif (!table)\n \t\treturn NULL;\n \tsg_init_table(table, nents);\n \titer = table;\n \tfor_each_sg(table, iter, sg_nents(table), i) {\n \t\tnew_page = alloc_page(GFP_KERNEL);\n \t\tif (!new_page) {\n \t\t\titer = table;\n \t\t\tfor_each_sg(table, iter, sg_nents(table), i) {\n \t\t\t\tnew_page = sg_page(iter);\n \t\t\t\tif (new_page)\n \t\t\t\t\t__free_page(new_page);\n \t\t\t}\n// bug_start\n// bug_end\n \t\t\treturn NULL;\n \t\t}\n \t\talloc_size = min_t(int, size, PAGE_SIZE);\n \t\tsize -= PAGE_SIZE;\n \t\tsg_set_page(iter, new_page, alloc_size, 0);\n \t}\n \treturn table;\n }\n \n", "target": "// fix_start\n\t\t\tkfree(table);\n// fix_end\n", "cwe": "CWE-401", "cwe_name": "Missing Release of Memory after Effective Lifetime", "cve": "CVE-2019-19058", "cve_desc": "A memory leak in the alloc_sgtable() function in drivers/net/wireless/intel/iwlwifi/fw/dbg.c in the Linux kernel through 5.3.11 allows attackers to cause a denial of service (memory consumption) by triggering alloc_page() failures, aka CID-b4b814fec1a5.", "project": "linux", "idx": 206661}
{"source": "   size_t recv_body(char* buf, size_t max) override {\n     auto& message = parser.get();\n     auto& body_remaining = message.body();\n     body_remaining.data = buf;\n     body_remaining.size = max;\n \n     while (body_remaining.size && !parser.is_done()) {\n       boost::system::error_code ec;\n       http::async_read_some(stream, buffer, parser, yield[ec]);\n// bug_start\n      if (ec == http::error::partial_message ||\n          ec == http::error::need_buffer) {\n// bug_end\n         break;\n       }\n       if (ec) {\n         ldout(cct, 4) << \"failed to read body: \" << ec.message() << dendl;\n         throw rgw::io::Exception(ec.value(), std::system_category());\n       }\n     }\n     return max - body_remaining.size;\n   }\n \n", "target": "// fix_start\n      if (ec == http::error::need_buffer) {\n// fix_end\n", "cwe": "CWE-400", "cwe_name": "Uncontrolled Resource Consumption", "cve": "CVE-2020-1700", "cve_desc": "A flaw was found in the way the Ceph RGW Beast front-end handles unexpected disconnects. An authenticated attacker can abuse this flaw by making multiple disconnect attempts resulting in a permanent leak of a socket connection by radosgw. This flaw could lead to a denial of service condition by pile up of CLOSE_WAIT sockets, eventually leading to the exhaustion of available resources, preventing legitimate users from connecting to the system.", "project": "ceph", "idx": 206666}
{"source": " dissect_tcp(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void* data _U_)\n {\n     guint8  th_off_x2;\n     guint16 th_sum;\n     guint32 th_urp;\n     proto_tree *tcp_tree = NULL, *field_tree = NULL;\n     proto_item *ti = NULL, *tf, *hidden_item;\n     proto_item *options_item;\n     proto_tree *options_tree;\n     int        offset = 0;\n     const char *flags_str, *flags_str_first_letter;\n     guint      optlen;\n     guint32    nxtseq = 0;\n     guint      reported_len;\n     vec_t      cksum_vec[4];\n     guint32    phdr[2];\n     guint16    computed_cksum;\n     guint16    real_window;\n     guint      captured_length_remaining;\n     gboolean   desegment_ok;\n     struct tcpinfo tcpinfo;\n     struct tcpheader *tcph;\n     proto_item *tf_syn = NULL, *tf_fin = NULL, *tf_rst = NULL, *scaled_pi;\n     conversation_t *conv=NULL, *other_conv;\n     guint32 save_last_frame = 0;\n     struct tcp_analysis *tcpd=NULL;\n     struct tcp_per_packet_data_t *tcppd=NULL;\n     proto_item *item;\n     proto_tree *checksum_tree;\n     gboolean    icmp_ip = FALSE;\n \n     tcph = wmem_new0(wmem_packet_scope(), struct tcpheader);\n     tcph->th_sport = tvb_get_ntohs(tvb, offset);\n     tcph->th_dport = tvb_get_ntohs(tvb, offset + 2);\n     copy_address_shallow(&tcph->ip_src, &pinfo->src);\n     copy_address_shallow(&tcph->ip_dst, &pinfo->dst);\n \n     col_set_str(pinfo->cinfo, COL_PROTOCOL, \"TCP\");\n     col_clear(pinfo->cinfo, COL_INFO);\n     col_append_ports(pinfo->cinfo, COL_INFO, PT_TCP, tcph->th_sport, tcph->th_dport);\n \n     if (tree) {\n         ti = proto_tree_add_item(tree, proto_tcp, tvb, 0, -1, ENC_NA);\n         if (tcp_summary_in_tree) {\n             proto_item_append_text(ti, \", Src Port: %s, Dst Port: %s\",\n                     port_with_resolution_to_str(wmem_packet_scope(), PT_TCP, tcph->th_sport),\n                     port_with_resolution_to_str(wmem_packet_scope(), PT_TCP, tcph->th_dport));\n         }\n         tcp_tree = proto_item_add_subtree(ti, ett_tcp);\n         p_add_proto_data(pinfo->pool, pinfo, proto_tcp, pinfo->curr_layer_num, tcp_tree);\n \n         proto_tree_add_item(tcp_tree, hf_tcp_srcport, tvb, offset, 2, ENC_BIG_ENDIAN);\n         proto_tree_add_item(tcp_tree, hf_tcp_dstport, tvb, offset + 2, 2, ENC_BIG_ENDIAN);\n         hidden_item = proto_tree_add_item(tcp_tree, hf_tcp_port, tvb, offset, 2, ENC_BIG_ENDIAN);\n         PROTO_ITEM_SET_HIDDEN(hidden_item);\n         hidden_item = proto_tree_add_item(tcp_tree, hf_tcp_port, tvb, offset + 2, 2, ENC_BIG_ENDIAN);\n         PROTO_ITEM_SET_HIDDEN(hidden_item);\n \n         {\n             wmem_list_frame_t *frame;\n             frame = wmem_list_frame_prev(wmem_list_tail(pinfo->layers));\n             if (proto_ip == (gint) GPOINTER_TO_UINT(wmem_list_frame_data(frame))) {\n                 frame = wmem_list_frame_prev(frame);\n                 if (proto_icmp == (gint) GPOINTER_TO_UINT(wmem_list_frame_data(frame))) {\n                     proto_tree_add_item(tcp_tree, hf_tcp_seq, tvb, offset + 4, 4, ENC_BIG_ENDIAN);\n                     icmp_ip = TRUE;\n                 }\n             }\n         }\n     }\n \n     pinfo->ptype = PT_TCP;\n     pinfo->srcport = tcph->th_sport;\n     pinfo->destport = tcph->th_dport;\n \n     p_add_proto_data(pinfo->pool, pinfo, hf_tcp_srcport, pinfo->curr_layer_num, GUINT_TO_POINTER(tcph->th_sport));\n     p_add_proto_data(pinfo->pool, pinfo, hf_tcp_dstport, pinfo->curr_layer_num, GUINT_TO_POINTER(tcph->th_dport));\n \n     tcph->th_rawseq = tvb_get_ntohl(tvb, offset + 4);\n     tcph->th_seq = tcph->th_rawseq;\n     tcph->th_ack = tvb_get_ntohl(tvb, offset + 8);\n     th_off_x2 = tvb_get_guint8(tvb, offset + 12);\n     tcpinfo.flags = tcph->th_flags = tvb_get_ntohs(tvb, offset + 12) & TH_MASK;\n     tcph->th_win = tvb_get_ntohs(tvb, offset + 14);\n     real_window = tcph->th_win;\n     tcph->th_hlen = hi_nibble(th_off_x2) * 4;\n \n     if((conv = find_conversation_pinfo(pinfo, 0)) != NULL) {\n         if (pinfo->num > conv->last_frame) {\n             save_last_frame = conv->last_frame;\n             conv->last_frame = pinfo->num;\n         }\n     }\n     else {\n         conv = conversation_new(pinfo->num, &pinfo->src,\n                      &pinfo->dst, ENDPOINT_TCP,\n                      pinfo->srcport, pinfo->destport, 0);\n     }\n     tcpd=get_tcp_conversation_data(conv,pinfo);\n \n     if(tcpd && ((tcph->th_flags&(TH_SYN|TH_ACK))==TH_SYN) &&\n        (tcpd->fwd->static_flags & TCP_S_BASE_SEQ_SET) &&\n        (tcph->th_seq!=tcpd->fwd->base_seq) ) {\n         if (!(pinfo->fd->visited)) {\n             if (save_last_frame > 0)\n                 conv->last_frame = save_last_frame;\n \n             conv=conversation_new(pinfo->num, &pinfo->src, &pinfo->dst, ENDPOINT_TCP, pinfo->srcport, pinfo->destport, 0);\n             tcpd=get_tcp_conversation_data(conv,pinfo);\n         }\n         if(!tcpd->ta)\n             tcp_analyze_get_acked_struct(pinfo->num, tcph->th_seq, tcph->th_ack, TRUE, tcpd);\n         tcpd->ta->flags|=TCP_A_REUSED_PORTS;\n     }\n     if(tcpd && ((tcph->th_flags&(TH_SYN|TH_ACK))==(TH_SYN|TH_ACK)) &&\n        (tcpd->fwd->static_flags & TCP_S_BASE_SEQ_SET) &&\n        (tcph->th_seq!=tcpd->fwd->base_seq) ) {\n         if (!(pinfo->fd->visited)) {\n             if (save_last_frame > 0)\n                 conv->last_frame = save_last_frame;\n         }\n \n         other_conv = find_conversation(pinfo->num, &pinfo->dst, &pinfo->src, ENDPOINT_TCP, pinfo->destport, pinfo->srcport, 0);\n         if (other_conv != NULL)\n         {\n             conv = other_conv;\n             tcpd=get_tcp_conversation_data(conv,pinfo);\n         }\n \n         if(!tcpd->ta)\n             tcp_analyze_get_acked_struct(pinfo->num, tcph->th_seq, tcph->th_ack, TRUE, tcpd);\n         tcpd->ta->flags|=TCP_A_REUSED_PORTS;\n     }\n \n     if (tcpd) {\n         item = proto_tree_add_uint(tcp_tree, hf_tcp_stream, tvb, offset, 0, tcpd->stream);\n         PROTO_ITEM_SET_GENERATED(item);\n \n         tcph->th_stream = tcpd->stream;\n     }\n \n     if (tcp_calculate_ts) {\n         tcppd = (struct tcp_per_packet_data_t *)p_get_proto_data(wmem_file_scope(), pinfo, proto_tcp, pinfo->curr_layer_num);\n \n         if (!(pinfo->fd->visited))\n             tcp_calculate_timestamps(pinfo, tcpd, tcppd);\n     }\n \n     reported_len = tvb_reported_length(tvb);\n \n     if (!pinfo->fragmented && !pinfo->flags.in_error_pkt) {\n         if (reported_len < tcph->th_hlen) {\n             proto_tree_add_expert_format(tcp_tree, pinfo, &ei_tcp_short_segment, tvb, offset, 0,\n                                      \"Short segment. Segment/fragment does not contain a full TCP header\"\n                                      \" (might be NMAP or someone else deliberately sending unusual packets)\");\n             tcph->th_have_seglen = FALSE;\n         } else {\n             proto_item *pi;\n \n             tcph->th_seglen = reported_len - tcph->th_hlen;\n             tcph->th_have_seglen = TRUE;\n \n             pi = proto_tree_add_uint(ti, hf_tcp_len, tvb, offset+12, 1, tcph->th_seglen);\n             PROTO_ITEM_SET_GENERATED(pi);\n \n             if(tcp_analyze_seq) {\n                 if(!(pinfo->fd->visited)) {\n                     tcp_analyze_sequence_number(pinfo, tcph->th_seq, tcph->th_ack, tcph->th_seglen, tcph->th_flags, tcph->th_win, tcpd);\n                 }\n                 if(tcpd && tcp_relative_seq) {\n                     (tcph->th_seq) -= tcpd->fwd->base_seq;\n                     if (tcph->th_flags & TH_ACK) {\n                         (tcph->th_ack) -= tcpd->rev->base_seq;\n                     }\n                 }\n             }\n \n             if (!(tcph->th_flags&TH_SYN)) {\n                 if (tcpd && (tcpd->fwd->win_scale>=0)) {\n                     (tcph->th_win)<<=tcpd->fwd->win_scale;\n                 }\n                 else {\n                     if (tcp_default_window_scaling>=0) {\n                         (tcph->th_win)<<=tcp_default_window_scaling;\n                     }\n                 }\n             }\n \n             nxtseq = tcph->th_seq + tcph->th_seglen;\n             if ((tcph->th_flags&(TH_SYN|TH_FIN)) && (tcph->th_seglen > 0)) {\n                 nxtseq += 1;\n             }\n         }\n     } else\n         tcph->th_have_seglen = FALSE;\n \n     flags_str = tcp_flags_to_str(wmem_packet_scope(), tcph);\n     flags_str_first_letter = tcp_flags_to_str_first_letter(tcph);\n \n     col_append_lstr(pinfo->cinfo, COL_INFO,\n         \" [\", flags_str, \"]\",\n         COL_ADD_LSTR_TERMINATOR);\n     tcp_info_append_uint(pinfo, \"Seq\", tcph->th_seq);\n     if (tcph->th_flags&TH_ACK)\n         tcp_info_append_uint(pinfo, \"Ack\", tcph->th_ack);\n \n     tcp_info_append_uint(pinfo, \"Win\", tcph->th_win);\n \n     if (tcp_summary_in_tree) {\n         proto_item_append_text(ti, \", Seq: %u\", tcph->th_seq);\n     }\n \n     if (!icmp_ip) {\n         if(tcp_relative_seq && tcp_analyze_seq) {\n             proto_tree_add_uint_format_value(tcp_tree, hf_tcp_seq, tvb, offset + 4, 4, tcph->th_seq, \"%u    (relative sequence number)\", tcph->th_seq);\n         } else {\n             proto_tree_add_uint(tcp_tree, hf_tcp_seq, tvb, offset + 4, 4, tcph->th_seq);\n         }\n     }\n \n     if (tcph->th_hlen < TCPH_MIN_LEN) {\n         col_append_fstr(pinfo->cinfo, COL_INFO, \", bogus TCP header length (%u, must be at least %u)\",\n                         tcph->th_hlen, TCPH_MIN_LEN);\n         if (tree) {\n             tf = proto_tree_add_uint_bits_format_value(tcp_tree, hf_tcp_hdr_len, tvb, (offset + 12) << 3, 4, tcph->th_hlen,\n                                                        \"%u bytes (%u)\", tcph->th_hlen, tcph->th_hlen >> 2);\n             expert_add_info_format(pinfo, tf, &ei_tcp_bogus_header_length,\n                                    \"Bogus TCP header length (%u, must be at least %u)\", tcph->th_hlen, TCPH_MIN_LEN);\n         }\n         return offset+12;\n     }\n \n     if (tcp_summary_in_tree) {\n         if(tcph->th_flags&TH_ACK) {\n             proto_item_append_text(ti, \", Ack: %u\", tcph->th_ack);\n         }\n         if (tcph->th_have_seglen)\n             proto_item_append_text(ti, \", Len: %u\", tcph->th_seglen);\n     }\n     proto_item_set_len(ti, tcph->th_hlen);\n     if (tcph->th_have_seglen) {\n         if(tcp_relative_seq && tcp_analyze_seq) {\n             tf=proto_tree_add_uint_format_value(tcp_tree, hf_tcp_nxtseq, tvb, offset, 0, nxtseq, \"%u    (relative sequence number)\", nxtseq);\n         } else {\n             tf=proto_tree_add_uint(tcp_tree, hf_tcp_nxtseq, tvb, offset, 0, nxtseq);\n         }\n         PROTO_ITEM_SET_GENERATED(tf);\n     }\n \n     tf = proto_tree_add_uint(tcp_tree, hf_tcp_ack, tvb, offset + 8, 4, tcph->th_ack);\n     if (tcph->th_flags & TH_ACK) {\n         if (tcp_relative_seq && tcp_analyze_seq) {\n             proto_item_append_text(tf, \"    (relative ack number)\");\n         }\n     } else {\n         if (tvb_get_ntohl(tvb, offset+8) != 0) {\n             expert_add_info(pinfo, tf, &ei_tcp_ack_nonzero);\n         }\n     }\n \n     if (tree) {\n         proto_tree_add_uint_bits_format_value(tcp_tree, hf_tcp_hdr_len, tvb, (offset + 12) << 3, 4, tcph->th_hlen,\n             \"%u bytes (%u)\", tcph->th_hlen, tcph->th_hlen>>2);\n         tf = proto_tree_add_uint_format(tcp_tree, hf_tcp_flags, tvb, offset + 12, 2,\n                                         tcph->th_flags, \"Flags: 0x%03x (%s)\", tcph->th_flags, flags_str);\n         field_tree = proto_item_add_subtree(tf, ett_tcp_flags);\n         proto_tree_add_boolean(field_tree, hf_tcp_flags_res, tvb, offset + 12, 1, tcph->th_flags);\n         proto_tree_add_boolean(field_tree, hf_tcp_flags_ns, tvb, offset + 12, 1, tcph->th_flags);\n         proto_tree_add_boolean(field_tree, hf_tcp_flags_cwr, tvb, offset + 13, 1, tcph->th_flags);\n         proto_tree_add_boolean(field_tree, hf_tcp_flags_ecn, tvb, offset + 13, 1, tcph->th_flags);\n         proto_tree_add_boolean(field_tree, hf_tcp_flags_urg, tvb, offset + 13, 1, tcph->th_flags);\n         proto_tree_add_boolean(field_tree, hf_tcp_flags_ack, tvb, offset + 13, 1, tcph->th_flags);\n         proto_tree_add_boolean(field_tree, hf_tcp_flags_push, tvb, offset + 13, 1, tcph->th_flags);\n         tf_rst = proto_tree_add_boolean(field_tree, hf_tcp_flags_reset, tvb, offset + 13, 1, tcph->th_flags);\n         tf_syn = proto_tree_add_boolean(field_tree, hf_tcp_flags_syn, tvb, offset + 13, 1, tcph->th_flags);\n         tf_fin = proto_tree_add_boolean(field_tree, hf_tcp_flags_fin, tvb, offset + 13, 1, tcph->th_flags);\n \n         tf = proto_tree_add_string(field_tree, hf_tcp_flags_str, tvb, offset + 12, 2, flags_str_first_letter);\n         PROTO_ITEM_SET_GENERATED(tf);\n         proto_tree_add_uint(tcp_tree, hf_tcp_window_size_value, tvb, offset + 14, 2, real_window);\n         scaled_pi = proto_tree_add_uint(tcp_tree, hf_tcp_window_size, tvb, offset + 14, 2, tcph->th_win);\n         PROTO_ITEM_SET_GENERATED(scaled_pi);\n \n         if( !(tcph->th_flags&TH_SYN) && tcpd ) {\n             switch (tcpd->fwd->win_scale) {\n \n             case -1:\n                 {\n                     gint16 win_scale = tcpd->fwd->win_scale;\n                     gboolean override_with_pref = FALSE;\n \n                     if (tcp_default_window_scaling != WindowScaling_NotKnown) {\n                         win_scale = tcp_default_window_scaling;\n                         override_with_pref = TRUE;\n                     }\n \n                     scaled_pi = proto_tree_add_int_format_value(tcp_tree, hf_tcp_window_size_scalefactor, tvb, offset + 14, 2,\n                                                           win_scale, \"%d (%s)\",\n                                                           win_scale,\n                                                           (override_with_pref) ? \"missing - taken from preference\" : \"unknown\");\n                     PROTO_ITEM_SET_GENERATED(scaled_pi);\n                 }\n                 break;\n \n             case -2:\n                 scaled_pi = proto_tree_add_int_format_value(tcp_tree, hf_tcp_window_size_scalefactor, tvb, offset + 14, 2, tcpd->fwd->win_scale, \"%d (no window scaling used)\", tcpd->fwd->win_scale);\n                 PROTO_ITEM_SET_GENERATED(scaled_pi);\n                 break;\n \n             default:\n                 scaled_pi = proto_tree_add_int_format_value(tcp_tree, hf_tcp_window_size_scalefactor, tvb, offset + 14, 2, 1<<tcpd->fwd->win_scale, \"%d\", 1<<tcpd->fwd->win_scale);\n                 PROTO_ITEM_SET_GENERATED(scaled_pi);\n             }\n         }\n     }\n \n     if(tcph->th_flags & TH_SYN) {\n         if(tcph->th_flags & TH_ACK) {\n            expert_add_info_format(pinfo, tf_syn, &ei_tcp_connection_sack,\n                                   \"Connection establish acknowledge (SYN+ACK): server port %u\", tcph->th_sport);\n            tcpd->server_port = tcph->th_sport;\n         }\n         else {\n            expert_add_info_format(pinfo, tf_syn, &ei_tcp_connection_syn,\n                                   \"Connection establish request (SYN): server port %u\", tcph->th_dport);\n            tcpd->server_port = tcph->th_dport;\n            tcpd->ts_mru_syn = pinfo->abs_ts;\n         }\n         if (tcp_desegment && tcp_reassemble_out_of_order && tcpd && !PINFO_FD_VISITED(pinfo)) {\n             if (tcpd->fwd->maxnextseq == 0) {\n                 tcpd->fwd->maxnextseq = tcph->th_seq + 1;\n             }\n         }\n     }\n     if(tcph->th_flags & TH_FIN) {\n         expert_add_info(pinfo, tf_fin, &ei_tcp_connection_fin);\n     }\n     if(tcph->th_flags & TH_RST)\n         expert_add_info(pinfo, tf_rst, &ei_tcp_connection_rst);\n \n     if(tcp_analyze_seq\n             && (tcph->th_flags & (TH_SYN|TH_ACK)) == TH_ACK\n             && !nstime_is_zero(&tcpd->ts_mru_syn)\n             &&  nstime_is_zero(&tcpd->ts_first_rtt)) {\n         nstime_delta(&(tcpd->ts_first_rtt), &(pinfo->abs_ts), &(tcpd->ts_mru_syn));\n     }\n \n     tcpinfo.seq = tcph->th_seq;\n     tcpinfo.nxtseq = nxtseq;\n     tcpinfo.lastackseq = tcph->th_ack;\n \n     tcpinfo.is_reassembled = FALSE;\n \n     pinfo->can_desegment = 0;\n     th_sum = tvb_get_ntohs(tvb, offset + 16);\n     if (!pinfo->fragmented && tvb_bytes_exist(tvb, 0, reported_len)) {\n \n         if (tcp_check_checksum) {\n \n             SET_CKSUM_VEC_PTR(cksum_vec[0], (const guint8 *)pinfo->src.data, pinfo->src.len);\n             SET_CKSUM_VEC_PTR(cksum_vec[1], (const guint8 *)pinfo->dst.data, pinfo->dst.len);\n             switch (pinfo->src.type) {\n \n             case AT_IPv4:\n                 phdr[0] = g_htonl((IP_PROTO_TCP<<16) + reported_len);\n                 SET_CKSUM_VEC_PTR(cksum_vec[2], (const guint8 *)phdr, 4);\n                 break;\n \n             case AT_IPv6:\n                 phdr[0] = g_htonl(reported_len);\n                 phdr[1] = g_htonl(IP_PROTO_TCP);\n                 SET_CKSUM_VEC_PTR(cksum_vec[2], (const guint8 *)phdr, 8);\n                 break;\n \n             default:\n                 DISSECTOR_ASSERT_NOT_REACHED();\n                 break;\n             }\n             SET_CKSUM_VEC_TVB(cksum_vec[3], tvb, offset, reported_len);\n             computed_cksum = in_cksum(cksum_vec, 4);\n             if (computed_cksum == 0 && th_sum == 0xffff) {\n                 item = proto_tree_add_uint_format_value(tcp_tree, hf_tcp_checksum, tvb,\n                                                   offset + 16, 2, th_sum,\n                                                   \"0x%04x [should be 0x0000 (see RFC 1624)]\", th_sum);\n \n                 checksum_tree = proto_item_add_subtree(item, ett_tcp_checksum);\n                 item = proto_tree_add_uint(checksum_tree, hf_tcp_checksum_calculated, tvb,\n                                               offset + 16, 2, 0x0000);\n                 PROTO_ITEM_SET_GENERATED(item);\n                 item = proto_tree_add_uint(checksum_tree, hf_tcp_checksum_status, tvb,\n// bug_start\n                                              offset + 16, 0, 4);\n// bug_end\n                 PROTO_ITEM_SET_GENERATED(item);\n                 expert_add_info(pinfo, item, &ei_tcp_checksum_ffff);\n \n                 col_append_str(pinfo->cinfo, COL_INFO, \" [TCP CHECKSUM 0xFFFF]\");\n \n                 desegment_ok = TRUE;\n             } else {\n                 proto_item* calc_item;\n                 item = proto_tree_add_checksum(tcp_tree, tvb, offset+16, hf_tcp_checksum, hf_tcp_checksum_status, &ei_tcp_checksum_bad, pinfo, computed_cksum,\n                                                ENC_BIG_ENDIAN, PROTO_CHECKSUM_VERIFY|PROTO_CHECKSUM_IN_CKSUM);\n \n                 calc_item = proto_tree_add_uint(tcp_tree, hf_tcp_checksum_calculated, tvb,\n                                               offset + 16, 2, in_cksum_shouldbe(th_sum, computed_cksum));\n                 PROTO_ITEM_SET_GENERATED(calc_item);\n \n                 if (computed_cksum == 0) {\n                     desegment_ok = TRUE;\n                 } else {\n                     proto_item_append_text(item, \"(maybe caused by \\\"TCP checksum offload\\\"?)\");\n \n                     desegment_ok = FALSE;\n                     pinfo->noreassembly_reason = \" [incorrect TCP checksum]\";\n                     col_append_str(pinfo->cinfo, COL_INFO, \" [TCP CHECKSUM INCORRECT]\");\n                 }\n             }\n         } else {\n             proto_tree_add_checksum(tcp_tree, tvb, offset+16, hf_tcp_checksum, hf_tcp_checksum_status, &ei_tcp_checksum_bad, pinfo, 0,\n                                     ENC_BIG_ENDIAN, PROTO_CHECKSUM_NO_FLAGS);\n \n             desegment_ok = TRUE;\n         }\n     } else {\n         proto_tree_add_checksum(tcp_tree, tvb, offset+16, hf_tcp_checksum, hf_tcp_checksum_status, &ei_tcp_checksum_bad, pinfo, 0,\n                                     ENC_BIG_ENDIAN, PROTO_CHECKSUM_NO_FLAGS);\n \n         desegment_ok = FALSE;\n     }\n \n     if (desegment_ok) {\n         if (tcp_desegment) {\n             if (!pinfo->flags.in_error_pkt) {\n                 pinfo->can_desegment = 2;\n             }\n         }\n     }\n \n     item = proto_tree_add_item_ret_uint(tcp_tree, hf_tcp_urgent_pointer, tvb, offset + 18, 2, ENC_BIG_ENDIAN, &th_urp);\n \n     if (IS_TH_URG(tcph->th_flags)) {\n         tcpinfo.urgent_pointer = (guint16)th_urp;\n         tcp_info_append_uint(pinfo, \"Urg\", th_urp);\n     } else {\n          if (th_urp) {\n             expert_add_info(pinfo, item, &ei_tcp_urgent_pointer_non_zero);\n          }\n     }\n \n     if (tcph->th_have_seglen)\n         tcp_info_append_uint(pinfo, \"Len\", tcph->th_seglen);\n \n     optlen = tcph->th_hlen - TCPH_MIN_LEN;\n     options_item = NULL;\n     options_tree = NULL;\n     if (optlen != 0) {\n         guint bc = (guint)tvb_captured_length_remaining(tvb, offset + 20);\n \n         if (tcp_tree != NULL) {\n             options_item = proto_tree_add_item(tcp_tree, hf_tcp_options, tvb, offset + 20,\n                                                bc < optlen ? bc : optlen, ENC_NA);\n             proto_item_set_text(options_item, \"Options: (%u bytes)\", optlen);\n             options_tree = proto_item_add_subtree(options_item, ett_tcp_options);\n         }\n     }\n \n     tcph->num_sack_ranges = 0;\n \n     if(tcp_analyze_seq) {\n         guint32 use_seq = tcph->th_seq;\n         guint32 use_ack = tcph->th_ack;\n         if (tcp_relative_seq) {\n             use_seq += tcpd->fwd->base_seq;\n             if (tcph->th_flags & TH_ACK) {\n                 use_ack += tcpd->rev->base_seq;\n             }\n         }\n         tcp_print_sequence_number_analysis(pinfo, tvb, tcp_tree, tcpd, use_seq, use_ack);\n     }\n \n     if(tcp_calculate_ts) {\n         tcp_print_timestamps(pinfo, tvb, tcp_tree, tcpd, tcppd);\n     }\n \n     if (optlen) {\n         rvbd_option_data* option_data;\n \n         tcp_dissect_options(tvb, offset + 20, optlen,\n                                TCPOPT_EOL, pinfo, options_tree,\n                                options_item, tcph);\n \n         option_data = (rvbd_option_data*)p_get_proto_data(pinfo->pool, pinfo, proto_tcp_option_rvbd_probe, pinfo->curr_layer_num);\n         if (option_data != NULL)\n         {\n             if (option_data->valid)\n             {\n                 col_prepend_fstr(pinfo->cinfo, COL_INFO, \"S%s, \",\n                                      option_data->type == PROBE_TRACE ? \"#\" :\n                                      (option_data->probe_flags & RVBD_FLAGS_PROBE_NCFE) ? \"+*\" : \"+\");\n             }\n         }\n \n     }\n \n     if(!pinfo->fd->visited) {\n         if((tcph->th_flags & TH_SYN)==TH_SYN) {\n             verify_tcp_window_scaling((tcph->th_flags&TH_ACK)==TH_ACK,tcpd);\n         }\n \n         if((tcph->th_flags & (TH_SYN|TH_ACK))==(TH_SYN|TH_ACK)) {\n             if(tcpd && ((tcpd->rev->scps_capable) || (tcpd->fwd->scps_capable))) {\n                 verify_scps(pinfo, tf_syn, tcpd);\n             }\n \n         }\n     }\n \n     if (tcph->th_mptcp) {\n \n         if (tcp_analyze_mptcp) {\n             mptcp_add_analysis_subtree(pinfo, tvb, tcp_tree, tcpd, tcpd->mptcp_analysis, tcph );\n         }\n     }\n \n     offset += tcph->th_hlen;\n \n     captured_length_remaining = tvb_captured_length_remaining(tvb, offset);\n \n     if (tcph->th_have_seglen) {\n         if(have_tap_listener(tcp_follow_tap)) {\n             tcp_follow_tap_data_t* follow_data = wmem_new0(wmem_packet_scope(), tcp_follow_tap_data_t);\n \n             follow_data->tvb = tvb_new_subset_remaining(tvb, offset);\n             follow_data->tcph = tcph;\n             follow_data->tcpd = tcpd;\n \n             tap_queue_packet(tcp_follow_tap, pinfo, follow_data);\n         }\n     }\n \n     tap_queue_packet(tcp_tap, pinfo, tcph);\n \n     if(tcpd->mptcp_analysis) {\n         tap_queue_packet(mptcp_tap, pinfo, tcpd);\n     }\n \n     if(tcph->th_have_seglen && tcpd && (tcph->th_flags & TH_FIN)\n        && (tcpd->fwd->flags&TCP_FLOW_REASSEMBLE_UNTIL_FIN) ) {\n         struct tcp_multisegment_pdu *msp;\n \n         if (tcpd->fwd->fin == 0 || tcpd->fwd->fin == pinfo->num) {\n             tcpd->fwd->fin = pinfo->num;\n             msp=(struct tcp_multisegment_pdu *)wmem_tree_lookup32_le(tcpd->fwd->multisegment_pdus, tcph->th_seq-1);\n             if(msp) {\n                 fragment_head *ipfd_head;\n \n                 ipfd_head = fragment_add(&tcp_reassembly_table, tvb, offset,\n                                          pinfo, msp->first_frame, NULL,\n                                          tcph->th_seq - msp->seq,\n                                          tcph->th_seglen,\n                                          FALSE );\n                 if(ipfd_head) {\n                     tvbuff_t *next_tvb;\n \n                     next_tvb = tvb_new_chain(tvb, ipfd_head->tvb_data);\n \n                     add_new_data_source(pinfo, next_tvb, \"Reassembled TCP\");\n \n                     print_tcp_fragment_tree(ipfd_head, tree, tcp_tree, pinfo, next_tvb);\n \n                     pinfo->can_desegment = 0;\n \n                     process_tcp_payload(next_tvb, 0, pinfo, tree, tcp_tree, tcph->th_sport, tcph->th_dport, tcph->th_seq,\n                                         nxtseq, FALSE, tcpd, &tcpinfo);\n \n                     return tvb_captured_length(tvb);\n                 }\n             }\n         } else {\n             proto_tree_add_uint(tcp_tree, hf_tcp_fin_retransmission, tvb, 0, 0, tcpd->fwd->fin);\n         }\n     }\n \n     if (tcp_display_process_info && tcpd && ((tcpd->fwd && tcpd->fwd->process_info && tcpd->fwd->process_info->command) ||\n                  (tcpd->rev && tcpd->rev->process_info && tcpd->rev->process_info->command))) {\n         field_tree = proto_tree_add_subtree(tcp_tree, tvb, offset, 0, ett_tcp_process_info, &ti, \"Process Information\");\n         PROTO_ITEM_SET_GENERATED(ti);\n         if (tcpd->fwd && tcpd->fwd->process_info && tcpd->fwd->process_info->command) {\n             proto_tree_add_uint(field_tree, hf_tcp_proc_dst_uid, tvb, 0, 0, tcpd->fwd->process_info->process_uid);\n             proto_tree_add_uint(field_tree, hf_tcp_proc_dst_pid, tvb, 0, 0, tcpd->fwd->process_info->process_pid);\n             proto_tree_add_string(field_tree, hf_tcp_proc_dst_uname, tvb, 0, 0, tcpd->fwd->process_info->username);\n             proto_tree_add_string(field_tree, hf_tcp_proc_dst_cmd, tvb, 0, 0, tcpd->fwd->process_info->command);\n         }\n         if (tcpd->rev && tcpd->rev->process_info && tcpd->rev->process_info->command) {\n             proto_tree_add_uint(field_tree, hf_tcp_proc_src_uid, tvb, 0, 0, tcpd->rev->process_info->process_uid);\n             proto_tree_add_uint(field_tree, hf_tcp_proc_src_pid, tvb, 0, 0, tcpd->rev->process_info->process_pid);\n             proto_tree_add_string(field_tree, hf_tcp_proc_src_uname, tvb, 0, 0, tcpd->rev->process_info->username);\n             proto_tree_add_string(field_tree, hf_tcp_proc_src_cmd, tvb, 0, 0, tcpd->rev->process_info->command);\n         }\n     }\n \n     if (captured_length_remaining != 0) {\n         if (tcph->th_flags & TH_RST) {\n             proto_tree_add_item(tcp_tree, hf_tcp_reset_cause, tvb, offset, captured_length_remaining, ENC_NA|ENC_ASCII);\n         } else {\n             if ((tcph->th_flags&(TH_FIN|TH_SYN)) && (tcph->th_seglen > 0)) {\n                 nxtseq -= 1;\n             }\n             dissect_tcp_payload(tvb, pinfo, offset, tcph->th_seq, nxtseq,\n                                 tcph->th_sport, tcph->th_dport, tree, tcp_tree, tcpd, &tcpinfo);\n         }\n     }\n     return tvb_captured_length(tvb);\n }\n \n", "target": "// fix_start\n                                              offset + 16, 0, PROTO_CHECKSUM_E_BAD);\n// fix_end\n", "cwe": "CWE-354", "cwe_name": "Improper Validation of Integrity Check Value", "cve": "CVE-2020-25862", "cve_desc": "In Wireshark 3.2.0 to 3.2.6, 3.0.0 to 3.0.13, and 2.6.0 to 2.6.20, the TCP dissector could crash. This was addressed in epan/dissectors/packet-tcp.c by changing the handling of the invalid 0xFFFF checksum.", "project": "wireshark", "idx": 206691}
{"source": " static void umd_cleanup(struct subprocess_info *info)\n {\n \tstruct umd_info *umd_info = info->data;\n \n// bug_start\n\tif (info->retval) {\n\t\tfput(umd_info->pipe_to_umh);\n\t\tfput(umd_info->pipe_from_umh);\n\t\tput_pid(umd_info->tgid);\n\t\tumd_info->tgid = NULL;\n\t}\n// bug_end\n }\n \n", "target": "// fix_start\n\tif (info->retval)\n\t\tumd_cleanup_helper(umd_info);\n// fix_end\n", "cwe": "CWE-401", "cwe_name": "Missing Release of Memory after Effective Lifetime", "cve": "CVE-2021-29649", "cve_desc": "An issue was discovered in the Linux kernel before 5.11.11. The user mode driver (UMD) has a copy_process() memory leak, related to a lack of cleanup steps in kernel/usermode_driver.c and kernel/bpf/preload/bpf_preload_kern.c, aka CID-f60a85cad677.", "project": "linux", "idx": 206697}
{"source": " \n static int\n xmlXPathCompOpEvalPositionalPredicate(xmlXPathParserContextPtr ctxt,\n \t\t\t\t      xmlXPathStepOpPtr op,\n \t\t\t\t      xmlNodeSetPtr set,\n \t\t\t\t      int contextSize,\n \t\t\t\t      int minPos,\n \t\t\t\t      int maxPos,\n \t\t\t\t      int hasNsNodes)\n {\n     if (op->ch1 != -1) {\n \txmlXPathCompExprPtr comp = ctxt->comp;\n \tif (comp->steps[op->ch1].op != XPATH_OP_PREDICATE) {\n \t}\n \tcontextSize = xmlXPathCompOpEvalPredicate(ctxt,\n \t    &comp->steps[op->ch1], set, contextSize, hasNsNodes);\n \tCHECK_ERROR0;\n \tif (contextSize <= 0)\n \t    return(0);\n     }\n     if (contextSize < minPos) {\n \txmlXPathNodeSetClear(set, hasNsNodes);\n \treturn(0);\n     }\n     if (op->ch2 == -1) {\n \treturn (contextSize);\n     } else {\n \txmlDocPtr oldContextDoc;\n \tint i, pos = 0, newContextSize = 0, contextPos = 0, res;\n \txmlXPathStepOpPtr exprOp;\n \txmlXPathObjectPtr contextObj = NULL, exprRes = NULL;\n \txmlNodePtr oldContextNode, contextNode = NULL;\n \txmlXPathContextPtr xpctxt = ctxt->context;\n         int frame;\n \n #ifdef LIBXML_XPTR_ENABLED\n #endif\n \n \toldContextNode = xpctxt->node;\n \toldContextDoc = xpctxt->doc;\n \texprOp = &ctxt->comp->steps[op->ch2];\n \tfor (i = 0; i < set->nodeNr; i++) {\n             xmlXPathObjectPtr tmp;\n \n \t    if (set->nodeTab[i] == NULL)\n \t\tcontinue;\n \n \t    contextNode = set->nodeTab[i];\n \t    xpctxt->node = contextNode;\n \t    xpctxt->contextSize = contextSize;\n \t    xpctxt->proximityPosition = ++contextPos;\n \n \t    if ((contextNode->type != XML_NAMESPACE_DECL) &&\n \t\t(contextNode->doc != NULL))\n \t\txpctxt->doc = contextNode->doc;\n \t    if (contextObj == NULL)\n \t\tcontextObj = xmlXPathCacheNewNodeSet(xpctxt, contextNode);\n \t    else {\n \t\tif (xmlXPathNodeSetAddUnique(contextObj->nodesetval,\n \t\t    contextNode) < 0) {\n \t\t    ctxt->error = XPATH_MEMORY_ERROR;\n \t\t    goto evaluation_exit;\n \t\t}\n \t    }\n \n// bug_start\n// bug_end\n             frame = xmlXPathSetFrame(ctxt);\n// bug_start\n\t    valuePush(ctxt, contextObj);\n// bug_end\n \t    res = xmlXPathCompOpEvalToBoolean(ctxt, exprOp, 1);\n// bug_start\n// bug_end\n             tmp = valuePop(ctxt);\n// bug_start\n            xmlXPathPopFrame(ctxt, frame);\n// bug_end\n \n \t    if ((ctxt->error != XPATH_EXPRESSION_OK) || (res == -1)) {\n                 while (tmp != contextObj) {\n                     xmlXPathReleaseObject(xpctxt, tmp);\n                     tmp = valuePop(ctxt);\n                 }\n \t\tgoto evaluation_error;\n \t    }\n             valuePush(ctxt, tmp);\n \n \t    if (res)\n \t\tpos++;\n \n \t    if (res && (pos >= minPos) && (pos <= maxPos)) {\n \t\tnewContextSize++;\n \t\tif (minPos == maxPos) {\n \t\t    if (contextNode->type == XML_NAMESPACE_DECL) {\n \t\t\tset->nodeTab[i] = NULL;\n \t\t    }\n \t\t    xmlXPathNodeSetClear(set, hasNsNodes);\n \t\t    set->nodeNr = 1;\n \t\t    set->nodeTab[0] = contextNode;\n \t\t    goto evaluation_exit;\n \t\t}\n \t\tif (pos == maxPos) {\n \t\t    xmlXPathNodeSetClearFromPos(set, i +1, hasNsNodes);\n \t\t    goto evaluation_exit;\n \t\t}\n \t    } else {\n \t\tset->nodeTab[i] = NULL;\n \t\tif (contextNode->type == XML_NAMESPACE_DECL)\n \t\t    xmlXPathNodeSetFreeNs((xmlNsPtr) contextNode);\n \t    }\n \t    if (exprRes != NULL) {\n \t\txmlXPathReleaseObject(ctxt->context, exprRes);\n \t\texprRes = NULL;\n \t    }\n \t    if (ctxt->value == contextObj) {\n \t\tvaluePop(ctxt);\n \t\txmlXPathNodeSetClear(contextObj->nodesetval, hasNsNodes);\n \t    } else {\n \t\tcontextObj = NULL;\n \t    }\n \t}\n \tgoto evaluation_exit;\n \n evaluation_error:\n \txmlXPathNodeSetClear(set, hasNsNodes);\n \tnewContextSize = 0;\n \n evaluation_exit:\n \tif (contextObj != NULL) {\n \t    if (ctxt->value == contextObj)\n \t\tvaluePop(ctxt);\n \t    xmlXPathReleaseObject(xpctxt, contextObj);\n \t}\n \tif (exprRes != NULL)\n \t    xmlXPathReleaseObject(ctxt->context, exprRes);\n \txpctxt->node = oldContextNode;\n \txpctxt->doc = oldContextDoc;\n \txpctxt->contextSize = -1;\n \txpctxt->proximityPosition = -1;\n \treturn(newContextSize);\n     }\n \n", "target": "// fix_start\n\t    valuePush(ctxt, contextObj);\n// fix_end\n// fix_start\n// fix_end\n// fix_start\n            xmlXPathPopFrame(ctxt, frame);\n// fix_end\n// fix_start\n// fix_end\n", "cwe": "CWE-416", "cwe_name": "Use After Free", "cve": "CVE-2017-15412", "cve_desc": "Use after free in libxml2 before 2.9.5, as used in Google Chrome prior to 63.0.3239.84 and other products, allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.", "project": "libxml2", "idx": 206698}
{"source": " void Utf8DecoderBase::WriteUtf16Slow(const uint8_t* stream,\n// bug_start\n// bug_end\n                                      uint16_t* data,\n                                      unsigned data_length) {\n   while (data_length != 0) {\n     unsigned cursor = 0;\n// bug_start\n    uint32_t character = Utf8::ValueOf(stream, Utf8::kMaxEncodedSize, &cursor);\n// bug_end\n     stream += cursor;\n// bug_start\n// bug_end\n     if (character > unibrow::Utf16::kMaxNonSurrogateCharCode) {\n       *data++ = Utf16::LeadSurrogate(character);\n       *data++ = Utf16::TrailSurrogate(character);\n       DCHECK(data_length > 1);\n       data_length -= 2;\n     } else {\n       *data++ = character;\n       data_length -= 1;\n     }\n   }\n// bug_start\n// bug_end\n }\n \n", "target": "// fix_start\n                                     unsigned stream_length,\n// fix_end\n// fix_start\n\n    uint32_t character = Utf8::ValueOf(stream, stream_length, &cursor);\n// fix_end\n// fix_start\n    stream_length -= cursor;\n// fix_end\n// fix_start\n  DCHECK(stream_length >= 0);\n// fix_end\n", "cwe": "CWE-119", "cwe_name": "Improper Restriction of Operations within the Bounds of a Memory Buffer", "cve": "CVE-2015-5380", "cve_desc": "The Utf8DecoderBase::WriteUtf16Slow function in unicode-decoder.cc in Google V8, as used in Node.js before 0.12.6, io.js before 1.8.3 and 2.x before 2.3.3, and other products, does not verify that there is memory available for a UTF-16 surrogate pair, which allows remote attackers to cause a denial of service (memory corruption) or possibly have unspecified other impact via a crafted byte sequence.", "project": "node", "idx": 206709}
{"source": " MagickExport Image *WaveImage(const Image *image,const double amplitude,\n   const double wave_length,ExceptionInfo *exception)\n {\n #define WaveImageTag  \"Wave/Image\"\n \n   CacheView\n     *image_view,\n     *wave_view;\n \n   float\n     *sine_map;\n \n   Image\n     *wave_image;\n \n   MagickBooleanType\n     status;\n \n   MagickOffsetType\n     progress;\n \n   MagickPixelPacket\n     zero;\n \n   ssize_t\n     i;\n \n   ssize_t\n     y;\n \n   assert(image != (Image *) NULL);\n   assert(image->signature == MagickCoreSignature);\n   if (image->debug != MagickFalse)\n     (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n   assert(exception != (ExceptionInfo *) NULL);\n   assert(exception->signature == MagickCoreSignature);\n   wave_image=CloneImage(image,image->columns,(size_t) (image->rows+2.0*\n     fabs(amplitude)),MagickTrue,exception);\n   if (wave_image == (Image *) NULL)\n     return((Image *) NULL);\n   if (SetImageStorageClass(wave_image,DirectClass) == MagickFalse)\n     {\n       InheritException(exception,&wave_image->exception);\n       wave_image=DestroyImage(wave_image);\n       return((Image *) NULL);\n     }\n   if (wave_image->background_color.opacity != OpaqueOpacity)\n     wave_image->matte=MagickTrue;\n   sine_map=(float *) AcquireQuantumMemory((size_t) wave_image->columns,\n     sizeof(*sine_map));\n   if (sine_map == (float *) NULL)\n     {\n       wave_image=DestroyImage(wave_image);\n       ThrowImageException(ResourceLimitError,\"MemoryAllocationFailed\");\n     }\n   for (i=0; i < (ssize_t) wave_image->columns; i++)\n     sine_map[i]=(float) fabs(amplitude)+amplitude*sin((double)\n// bug_start\n      ((2.0*MagickPI*i)/wave_length));\n// bug_end\n   status=MagickTrue;\n   progress=0;\n   GetMagickPixelPacket(wave_image,&zero);\n   image_view=AcquireVirtualCacheView(image,exception);\n   wave_view=AcquireAuthenticCacheView(wave_image,exception);\n   (void) SetCacheViewVirtualPixelMethod(image_view,\n     BackgroundVirtualPixelMethod);\n #if defined(MAGICKCORE_OPENMP_SUPPORT)\n   #pragma omp parallel for schedule(static) shared(progress,status) \\\n     magick_number_threads(image,wave_image,wave_image->rows,1)\n #endif\n   for (y=0; y < (ssize_t) wave_image->rows; y++)\n   {\n     MagickPixelPacket\n       pixel;\n \n     IndexPacket\n       *magick_restrict indexes;\n \n     PixelPacket\n       *magick_restrict q;\n \n     ssize_t\n       x;\n \n     if (status == MagickFalse)\n       continue;\n     q=QueueCacheViewAuthenticPixels(wave_view,0,y,wave_image->columns,1,\n       exception);\n     if (q == (PixelPacket *) NULL)\n       {\n         status=MagickFalse;\n         continue;\n       }\n     indexes=GetCacheViewAuthenticIndexQueue(wave_view);\n     pixel=zero;\n     for (x=0; x < (ssize_t) wave_image->columns; x++)\n     {\n       status=InterpolateMagickPixelPacket(image,image_view,\n         UndefinedInterpolatePixel,(double) x,(double) (y-sine_map[x]),&pixel,\n         exception);\n       if (status == MagickFalse)\n         break;\n       SetPixelPacket(wave_image,&pixel,q,indexes+x);\n       q++;\n     }\n     if (SyncCacheViewAuthenticPixels(wave_view,exception) == MagickFalse)\n       status=MagickFalse;\n     if (image->progress_monitor != (MagickProgressMonitor) NULL)\n       {\n         MagickBooleanType\n           proceed;\n \n #if defined(MAGICKCORE_OPENMP_SUPPORT)\n         #pragma omp atomic\n #endif\n         progress++;\n         proceed=SetImageProgress(image,WaveImageTag,progress,image->rows);\n         if (proceed == MagickFalse)\n           status=MagickFalse;\n       }\n   }\n   wave_view=DestroyCacheView(wave_view);\n   image_view=DestroyCacheView(image_view);\n   sine_map=(float *) RelinquishMagickMemory(sine_map);\n   if (status == MagickFalse)\n     wave_image=DestroyImage(wave_image);\n   return(wave_image);\n }\n \n", "target": "// fix_start\n      ((2.0*MagickPI*i)*PerceptibleReciprocal(wave_length)));\n// fix_end\n", "cwe": "CWE-369", "cwe_name": "Divide By Zero", "cve": "CVE-2021-20309", "cve_desc": "A flaw was found in ImageMagick in versions before 7.0.11 and before 6.9.12, where a division by zero in WaveImage() of MagickCore/visual-effects.c may trigger undefined behavior via a crafted image file submitted to an application using ImageMagick. The highest threat from this vulnerability is to system availability.", "project": "ImageMagick6", "idx": 206717}
{"source": " static int route4_change(struct net *net, struct sk_buff *in_skb,\n \t\t\t struct tcf_proto *tp, unsigned long base, u32 handle,\n \t\t\t struct nlattr **tca, void **arg, bool ovr,\n \t\t\t bool rtnl_held, struct netlink_ext_ack *extack)\n {\n \tstruct route4_head *head = rtnl_dereference(tp->root);\n \tstruct route4_filter __rcu **fp;\n \tstruct route4_filter *fold, *f1, *pfp, *f = NULL;\n \tstruct route4_bucket *b;\n \tstruct nlattr *opt = tca[TCA_OPTIONS];\n \tstruct nlattr *tb[TCA_ROUTE4_MAX + 1];\n \tunsigned int h, th;\n \tint err;\n \tbool new = true;\n \n \tif (opt == NULL)\n \t\treturn handle ? -EINVAL : 0;\n \n \terr = nla_parse_nested_deprecated(tb, TCA_ROUTE4_MAX, opt,\n \t\t\t\t\t  route4_policy, NULL);\n \tif (err < 0)\n \t\treturn err;\n \n \tfold = *arg;\n \tif (fold && handle && fold->handle != handle)\n \t\t\treturn -EINVAL;\n \n \terr = -ENOBUFS;\n \tf = kzalloc(sizeof(struct route4_filter), GFP_KERNEL);\n \tif (!f)\n \t\tgoto errout;\n \n \terr = tcf_exts_init(&f->exts, net, TCA_ROUTE4_ACT, TCA_ROUTE4_POLICE);\n \tif (err < 0)\n \t\tgoto errout;\n \n \tif (fold) {\n \t\tf->id = fold->id;\n \t\tf->iif = fold->iif;\n \t\tf->res = fold->res;\n \t\tf->handle = fold->handle;\n \n \t\tf->tp = fold->tp;\n \t\tf->bkt = fold->bkt;\n \t\tnew = false;\n \t}\n \n \terr = route4_set_parms(net, tp, base, f, handle, head, tb,\n \t\t\t       tca[TCA_RATE], new, ovr, extack);\n \tif (err < 0)\n \t\tgoto errout;\n \n \th = from_hash(f->handle >> 16);\n \tfp = &f->bkt->ht[h];\n \tfor (pfp = rtnl_dereference(*fp);\n \t     (f1 = rtnl_dereference(*fp)) != NULL;\n \t     fp = &f1->next)\n \t\tif (f->handle < f1->handle)\n \t\t\tbreak;\n \n \ttcf_block_netif_keep_dst(tp->chain->block);\n \trcu_assign_pointer(f->next, f1);\n \trcu_assign_pointer(*fp, f);\n \n \tif (fold && fold->handle && f->handle != fold->handle) {\n \t\tth = to_hash(fold->handle);\n \t\th = from_hash(fold->handle >> 16);\n \t\tb = rtnl_dereference(head->table[th]);\n \t\tif (b) {\n \t\t\tfp = &b->ht[h];\n \t\t\tfor (pfp = rtnl_dereference(*fp); pfp;\n \t\t\t     fp = &pfp->next, pfp = rtnl_dereference(*fp)) {\n// bug_start\n\t\t\t\tif (pfp == f) {\n\t\t\t\t\t*fp = f->next;\n// bug_end\n \t\t\t\t\tbreak;\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \t}\n \n \troute4_reset_fastmap(head);\n \t*arg = f;\n \tif (fold) {\n \t\ttcf_unbind_filter(tp, &fold->res);\n \t\ttcf_exts_get_net(&fold->exts);\n \t\ttcf_queue_work(&fold->rwork, route4_delete_filter_work);\n \t}\n \treturn 0;\n \n errout:\n \tif (f)\n \t\ttcf_exts_destroy(&f->exts);\n \tkfree(f);\n \treturn err;\n }\n \n", "target": "// fix_start\n\t\t\t\tif (pfp == fold) {\n\t\t\t\t\trcu_assign_pointer(*fp, fold->next);\n// fix_end\n", "cwe": "CWE-200", "cwe_name": "Exposure of Sensitive Information to an Unauthorized Actor", "cve": "CVE-2021-3715", "cve_desc": "A flaw was found in the \"Routing decision\" classifier in the Linux kernel's Traffic Control networking subsystem in the way it handled changing of classification filters, leading to a use-after-free condition. This flaw allows unprivileged local users to escalate their privileges on the system. The highest threat from this vulnerability is to confidentiality, integrity, as well as system availability.", "project": "linux", "idx": 206718}
{"source": " static int rtsx_usb_ms_drv_remove(struct platform_device *pdev)\n {\n \tstruct rtsx_usb_ms *host = platform_get_drvdata(pdev);\n \tstruct memstick_host *msh = host->msh;\n \tint err;\n \n \thost->eject = true;\n \tcancel_work_sync(&host->handle_req);\n \n \tmutex_lock(&host->host_mutex);\n \tif (host->req) {\n \t\tdev_dbg(ms_dev(host),\n \t\t\t\"%s: Controller removed during transfer\\n\",\n \t\t\tdev_name(&msh->dev));\n \t\thost->req->error = -ENOMEDIUM;\n \t\tdo {\n \t\t\terr = memstick_next_req(msh, &host->req);\n \t\t\tif (!err)\n \t\t\t\thost->req->error = -ENOMEDIUM;\n \t\t} while (!err);\n \t}\n \tmutex_unlock(&host->host_mutex);\n \n// bug_start\n\tmemstick_remove_host(msh);\n\tmemstick_free_host(msh);\n\n// bug_end\n \tif (pm_runtime_active(ms_dev(host)))\n \t\tpm_runtime_put(ms_dev(host));\n \n \tpm_runtime_disable(ms_dev(host));\n// bug_start\n\tplatform_set_drvdata(pdev, NULL);\n\n// bug_end\n \tdev_dbg(ms_dev(host),\n \t\t\": Realtek USB Memstick controller has been removed\\n\");\n// bug_start\n// bug_end\n \n \treturn 0;\n }\n \n", "target": "// fix_start\n// fix_end\n// fix_start\n\tmemstick_remove_host(msh);\n// fix_end\n// fix_start\n\tmemstick_free_host(msh);\n\tplatform_set_drvdata(pdev, NULL);\n// fix_end\n", "cwe": "CWE-416", "cwe_name": "Use After Free", "cve": "CVE-2022-0487", "cve_desc": "A use-after-free vulnerability was found in rtsx_usb_ms_drv_remove in drivers/memstick/host/rtsx_usb_ms.c in memstick in the Linux kernel. In this flaw, a local attacker with a user privilege may impact system Confidentiality. This flaw affects kernel versions prior to 5.14 rc1.", "project": "linux", "idx": 206735}
{"source": " static ssize_t acpi_table_aml_write(struct config_item *cfg,\n \t\t\t\t    const void *data, size_t size)\n {\n \tconst struct acpi_table_header *header = data;\n \tstruct acpi_table *table;\n// bug_start\n\tint ret;\n// bug_end\n \n \ttable = container_of(cfg, struct acpi_table, cfg);\n \n \tif (table->header) {\n \t\tpr_err(\"table already loaded\\n\");\n \t\treturn -EBUSY;\n \t}\n \n \tif (header->length != size) {\n \t\tpr_err(\"invalid table length\\n\");\n \t\treturn -EINVAL;\n \t}\n \n \tif (memcmp(header->signature, ACPI_SIG_SSDT, 4)) {\n \t\tpr_err(\"invalid table signature\\n\");\n \t\treturn -EINVAL;\n \t}\n \n \ttable = container_of(cfg, struct acpi_table, cfg);\n \n \ttable->header = kmemdup(header, header->length, GFP_KERNEL);\n \tif (!table->header)\n \t\treturn -ENOMEM;\n \n \tret = acpi_load_table(table->header, &table->index);\n \tif (ret) {\n \t\tkfree(table->header);\n \t\ttable->header = NULL;\n \t}\n \n \treturn ret;\n }\n \n", "target": "// fix_start\n\tint ret = security_locked_down(LOCKDOWN_ACPI_TABLES);\n\n\tif (ret)\n\t\treturn ret;\n// fix_end\n", "cwe": "CWE-862", "cwe_name": "Missing Authorization", "cve": "CVE-2020-15780", "cve_desc": "An issue was discovered in drivers/acpi/acpi_configfs.c in the Linux kernel before 5.7.7. Injection of malicious ACPI tables via configfs could be used by attackers to bypass lockdown and secure boot restrictions, aka CID-75b0cea7bf30.", "project": "linux", "idx": 206866}
{"source": " void get_cmdln_options(int argc, char *argv[]) {\n \tint o;\n #if CONFIG_FILE && HAVE_GETPWUID\n     static struct passwd *pwd_entry;\n     char *str;\n #endif\n #ifdef LONG_OPTIONS\n     int option_index = 0;\n     static struct option long_options[] = {\n         {\"timeout\", 1, 0, 't'},\n #ifdef PROC_NET_DEV\n         {\"procfile\",1,0,'f'},\n #endif\n #ifdef PROC_DISKSTATS\n \t\t\t{\"diskstatsfile\",1,0,1000},\n \t\t\t{\"partitionsfile\",1,0,1001},\n #endif\n #if NETSTAT && ALLOW_NETSTATPATH\n         {\"netstat\",1,0,'n'},\n #endif\n #if IOSERVICE_IN\n \t\t  {\"longdisknames\",0,0,1002},\n #endif\n         {\"input\",1,0,'i'},\n         {\"dynamic\",1,0,'d'},\n         {\"help\", 0, 0, 'h'},\n         {\"version\",0,0,'V'},\n         {\"allif\",1,0,'a'},\n         {\"unit\",1,0,'u'},\n \t\t  {\"ansiout\",0,0,'N'},\n #if EXTENDED_STATS\n         {\"type\",1,0,'T'},\n         {\"avglength\",1,0,'A'},\n #endif\n         {\"interfaces\",1,0,'I'},\n         {\"sumhidden\",1,0,'S'},\n         {\"output\",1,0,'o'},\n #ifdef CSV\n         {\"csvchar\",1,0,'C'},\n         {\"csvfile\",1,0,'F'},\n #endif\n         {\"count\",1,0,'c'},\n         {\"daemon\",1,0,'D'},\n #ifdef HTML\n         {\"htmlrefresh\",1,0,'R'},\n         {\"htmlheader\",1,0,'H'},\n #endif\n         {0,0,0,0}\n     };\n #endif\n #ifdef CONFIG_FILE\n     opterr=0;\n     while (1) {\n #ifdef LONG_OPTIONS\n         o=getopt_long (argc,argv,SHORT_OPTIONS,long_options, &option_index);\n #else\n         o=getopt (argc,argv,SHORT_OPTIONS);\n #endif\n         if (o==-1) break;\n     }\n     opterr=1;\n     if (optind < argc) {\n         read_config(argv[optind]);\n     } else {\n         read_config(\"/etc/bwm-ng.conf\");\n #ifdef HAVE_GETPWUID\n         pwd_entry=getpwuid(getuid());\n         if (pwd_entry!=NULL) {\n             str=(char*)malloc(strlen(pwd_entry->pw_dir)+14);\n// bug_start\n// bug_end\n             snprintf(str,strlen(pwd_entry->pw_dir)+14,\"%s/.bwm-ng.conf\",pwd_entry->pw_dir);\n             read_config(str);\n             free(str);\n         }\n #endif\n     }\n     optind=1;\n #endif\n     while (1) {\n #ifdef LONG_OPTIONS\n \t\to=getopt_long (argc,argv,SHORT_OPTIONS,long_options, &option_index);\n #else\n \t\to=getopt (argc,argv,SHORT_OPTIONS);\n #endif\n         if (o==-1) break;\n         switch (o) {\n             case '?': printf(\"unknown option: %s\\n\",argv[optind-1]);\n                       exit(EXIT_FAILURE);\n                       break;\n             case ':': if (!strcmp(argv[optind-1],\"-a\") || !strcasecmp(argv[optind-1],\"--allif\"))\n                             show_all_if=1;\n                       else if (!strcmp(argv[optind-1],\"-d\") || !strcasecmp(argv[optind-1],\"--dynamic\"))\n                             dynamic=1;\n                       else if (!strcmp(argv[optind-1],\"-D\") || !strcasecmp(argv[optind-1],\"--daemon\"))\n                             daemonize=1;\n #ifdef HTML\n                       else if (!strcmp(argv[optind-1],\"-H\") || !strcasecmp(argv[optind-1],\"--htmlheader\"))\n                             html_header=1;\n #endif\n                       else if (!strcmp(argv[optind-1],\"-S\") || !strcasecmp(argv[optind-1],\"--sumhidden\"))\n                             sumhidden=1;\n                           else {\n                               printf(\"%s requires an argument!\\n\",argv[optind-1]);\n                               exit(EXIT_FAILURE);\n                           }\n                       break;\n #ifdef PROC_DISKSTATS\n \t\t\tcase 1000:\n \t\t\t\tif (strlen(optarg)<PATH_MAX)\n \t\t\t\t\tstrcpy(PROC_DISKSTATS_FILE,optarg);\n \t\t\t\tbreak;\n          case 1001:\n             if (strlen(optarg)<PATH_MAX)\n                strcpy(PROC_PARTITIONS_FILE,optarg);\n \t\t\t\tbreak;\n #endif\n #if IOSERVICE_IN\n \t\t\tcase 1002:\n \t\t\t\tlong_darwin_disk_names=!long_darwin_disk_names;\n \t\t\t\tbreak;\n #endif\n \t\t\tcase 'D':\n \t\t\t\tif (optarg) daemonize=atoi(optarg);\n \t\t\t\tbreak;\n #ifdef HTML\n \t\t\tcase 'R':\n \t\t\t\tif ((optarg) && atol(optarg)>0) { html_refresh=atol(optarg); }\n \t\t\t\tbreak;\n \t\t\tcase 'H':\n \t\t\t\tif (optarg) html_header=atoi(optarg);\n \t\t\t\tbreak;\n #endif\n \t\t\tcase 'c':\n \t\t\t\tif (optarg) output_count=atol(optarg);\n \t\t\t\tbreak;\n #if CSV || HTML\n             case 'F':\n                 if (optarg) {\n                     if (out_file) fclose(out_file);\n                     out_file=fopen(optarg,\"a\");\n                     if (!out_file) deinit(1, \"failed to open outfile\\n\");\n                     if (out_file_path) free(out_file_path);\n                     out_file_path=(char *)strdup(optarg);\n                 }\n                 break;\n #endif\n #ifdef CSV\n \t\t\tcase 'C':\n \t\t\t\tif (optarg) csv_char=optarg[0];\n \t\t\t\tbreak;\n #endif\n             case 'h':\n                 cmdln_printhelp();\n                 break;\n #ifdef PROC_NET_DEV\n \t\t\tcase 'f':\n                 if (optarg && (strlen(optarg)<PATH_MAX)) strcpy(PROC_FILE,optarg);\n                 break;\n #endif\n \t\t\tcase 'i':\n                 if (optarg) {\n                     input_method=str2in_method(optarg);\n                 }\n \t\t\t\tbreak;\n             case 'I':\n                 if (optarg) iface_list=(char *)strdup(optarg);\n                 break;\n             case 'S':\n                 if (optarg) sumhidden=atoi(optarg);\n                 break;\n             case 'o':\n                 if (optarg) {\n                     output_method=str2out_method(optarg);\n                 }\n                 break;\n \t\t\t\tcase 'N':\n \t\t\t\t\t ansi_output=!ansi_output;\n             case 'a':\n                 if (optarg) show_all_if=atoi(optarg);\n                 break;\n             case 't':\n                 if ((optarg) && atol(optarg)>0) { delay=atol(optarg); }\n                 break;\n #if EXTENDED_STATS\n             case 'T':\n                 output_type=str2output_type(optarg);\n                 break;\n             case 'A':\n                 if (optarg) avg_length=atoi(optarg)*1000;\n                 break;\n #endif\n             case 'd':\n                 if (optarg) dynamic=atoi(optarg);\n                 break;\n             case 'u':\n                 output_unit=str2output_unit(optarg);\n                 break;\n #if NETSTAT && ALLOW_NETSTATPATH\n             case 'n':\n                 if (optarg && (strlen(optarg)<PATH_MAX)) strcpy(NETSTAT_FILE,optarg);\n                 break;\n #endif\n             case 'V':\n                 print_version;\n                 exit(EXIT_SUCCESS);\n                 break;\n         }\n     }\n     if (iface_list==NULL && show_all_if==1) show_all_if=2;\n #if EXTENDED_STATS\n     if (avg_length==0) {\n         if (delay<AVG_LENGTH/2)\n             avg_length=AVG_LENGTH;\n         else\n             avg_length=(delay*2)+1;\n     } else\n         if (delay*2>=avg_length) deinit(1, \"avglength needs to be a least twice the value of timeout\\n\");\n #endif\n \t if ((output_unit==ERRORS_OUT && !net_input_method(input_method)) ||\n \t\t\t (output_unit==PACKETS_OUT && input_method==LIBSTATDISK_IN))\n \t\toutput_unit=BYTES_OUT;\n     return;\n }\n \n", "target": "// fix_start\n            if(!str) {\n              printf(\"Fatal: failed to allocate %zu bytes.\\n\", strlen(pwd_entry->pw_dir)+14);\n              exit(EXIT_FAILURE);\n            }\n// fix_end\n", "cwe": "CWE-476", "cwe_name": "NULL Pointer Dereference", "cve": "CVE-2022-1341", "cve_desc": "An issue was discovered in in bwm-ng v0.6.2. An arbitrary null write exists in get_cmdln_options() function in src/options.c.", "project": "bwm-ng", "idx": 206867}
{"source": " UINT cliprdr_read_format_list(wStream* s, CLIPRDR_FORMAT_LIST* formatList, BOOL useLongFormatNames)\n {\n \tUINT32 index;\n \tsize_t position;\n \tBOOL asciiNames;\n \tint formatNameLength;\n \tchar* szFormatName;\n \tWCHAR* wszFormatName;\n// bug_start\n\tUINT32 dataLen = formatList->dataLen;\n// bug_end\n \tCLIPRDR_FORMAT* formats = NULL;\n \tUINT error = CHANNEL_RC_OK;\n \n \tasciiNames = (formatList->msgFlags & CB_ASCII_NAMES) ? TRUE : FALSE;\n \n \tindex = 0;\n// bug_start\n// bug_end\n \tformatList->numFormats = 0;\n// bug_start\n\tposition = Stream_GetPosition(s);\n// bug_end\n \n \tif (!formatList->dataLen)\n \t{\n// bug_start\n\t\tformatList->formats = NULL;\n\t\tformatList->numFormats = 0;\n// bug_end\n \t}\n \telse if (!useLongFormatNames)\n \t{\n// bug_start\n\t\tformatList->numFormats = (dataLen / 36);\n// bug_end\n \n// bug_start\n\t\tif ((formatList->numFormats * 36) != dataLen)\n// bug_end\n \t\t{\n// bug_start\n\t\t\tWLog_ERR(TAG, \"Invalid short format list length: %\" PRIu32 \"\", dataLen);\n// bug_end\n \t\t\treturn ERROR_INTERNAL_ERROR;\n \t\t}\n \n \t\tif (formatList->numFormats)\n \t\t\tformats = (CLIPRDR_FORMAT*)calloc(formatList->numFormats, sizeof(CLIPRDR_FORMAT));\n \n \t\tif (!formats)\n \t\t{\n \t\t\tWLog_ERR(TAG, \"calloc failed!\");\n \t\t\treturn CHANNEL_RC_NO_MEMORY;\n \t\t}\n \n \t\tformatList->formats = formats;\n \n// bug_start\n\t\twhile (dataLen)\n// bug_end\n \t\t{\n// bug_start\n\t\t\tStream_Read_UINT32(s, formats[index].formatId);\n\t\t\tdataLen -= 4;\n// bug_end\n \n \t\t\tformats[index].formatName = NULL;\n \n \n// bug_start\n// bug_end\n \t\t\tif (asciiNames)\n \t\t\t{\n// bug_start\n\t\t\t\tszFormatName = (char*)Stream_Pointer(s);\n\n// bug_end\n \t\t\t\tif (szFormatName[0])\n \t\t\t\t{\n \t\t\t\t\tformats[index].formatName = (char*)malloc(32 + 1);\n \t\t\t\t\tif (!formats[index].formatName)\n \t\t\t\t\t{\n \t\t\t\t\t\tWLog_ERR(TAG, \"malloc failed!\");\n \t\t\t\t\t\terror = CHANNEL_RC_NO_MEMORY;\n \t\t\t\t\t\tgoto error_out;\n \t\t\t\t\t}\n \t\t\t\t\tCopyMemory(formats[index].formatName, szFormatName, 32);\n \t\t\t\t\tformats[index].formatName[32] = '\\0';\n \t\t\t\t}\n \t\t\t}\n \t\t\telse\n \t\t\t{\n// bug_start\n\t\t\t\twszFormatName = (WCHAR*)Stream_Pointer(s);\n\n// bug_end\n \t\t\t\tif (wszFormatName[0])\n \t\t\t\t{\n \t\t\t\t\tif (ConvertFromUnicode(CP_UTF8, 0, wszFormatName, 16,\n \t\t\t\t\t                       &(formats[index].formatName), 0, NULL, NULL) < 1)\n \t\t\t\t\t{\n \t\t\t\t\t\tWLog_ERR(TAG, \"failed to convert short clipboard format name\");\n \t\t\t\t\t\terror = ERROR_INTERNAL_ERROR;\n \t\t\t\t\t\tgoto error_out;\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \n// bug_start\n\t\t\tStream_Seek(s, 32);\n\t\t\tdataLen -= 32;\n// bug_end\n \t\t\tindex++;\n \t\t}\n \t}\n \telse\n \t{\n// bug_start\n\t\twhile (dataLen)\n// bug_end\n \t\t{\n// bug_start\n\t\t\tStream_Seek(s, 4);\n\t\t\tdataLen -= 4;\n// bug_end\n \n// bug_start\n\t\t\twszFormatName = (WCHAR*)Stream_Pointer(s);\n// bug_end\n \n// bug_start\n\t\t\tif (!wszFormatName[0])\n\t\t\t\tformatNameLength = 0;\n\t\t\telse\n\t\t\t\tformatNameLength = _wcslen(wszFormatName);\n\n\t\t\tStream_Seek(s, (formatNameLength + 1) * 2);\n\t\t\tdataLen -= ((formatNameLength + 1) * 2);\n\n// bug_end\n \t\t\tformatList->numFormats++;\n \t\t}\n// bug_start\n\n\t\tdataLen = formatList->dataLen;\n\t\tStream_SetPosition(s, position);\n// bug_end\n \n \t\tif (formatList->numFormats)\n \t\t\tformats = (CLIPRDR_FORMAT*)calloc(formatList->numFormats, sizeof(CLIPRDR_FORMAT));\n \n \t\tif (!formats)\n \t\t{\n \t\t\tWLog_ERR(TAG, \"calloc failed!\");\n \t\t\treturn CHANNEL_RC_NO_MEMORY;\n \t\t}\n \n \t\tformatList->formats = formats;\n \n// bug_start\n\t\twhile (dataLen)\n// bug_end\n \t\t{\n// bug_start\n\t\t\tStream_Read_UINT32(s, formats[index].formatId);\n\t\t\tdataLen -= 4;\n// bug_end\n \n \t\t\tformats[index].formatName = NULL;\n \n// bug_start\n\t\t\twszFormatName = (WCHAR*)Stream_Pointer(s);\n\n\t\t\tif (!wszFormatName[0])\n\t\t\t\tformatNameLength = 0;\n\t\t\telse\n\t\t\t\tformatNameLength = _wcslen(wszFormatName);\n// bug_end\n \n \t\t\tif (formatNameLength)\n \t\t\t{\n// bug_start\n\t\t\t\tif (ConvertFromUnicode(CP_UTF8, 0, wszFormatName, -1, &(formats[index].formatName),\n\t\t\t\t                       0, NULL, NULL) < 1)\n// bug_end\n \t\t\t\t{\n \t\t\t\t\tWLog_ERR(TAG, \"failed to convert long clipboard format name\");\n \t\t\t\t\terror = ERROR_INTERNAL_ERROR;\n \t\t\t\t\tgoto error_out;\n \t\t\t\t}\n \t\t\t}\n// bug_start\n\n\t\t\tStream_Seek(s, (formatNameLength + 1) * 2);\n\t\t\tdataLen -= ((formatNameLength + 1) * 2);\n// bug_end\n \n \t\t\tindex++;\n \t\t}\n \t}\n \n \treturn error;\n \n error_out:\n \tcliprdr_free_format_list(formatList);\n \treturn error;\n }\n \n", "target": "// fix_start\n\twStream sub1, sub2;\n// fix_end\n// fix_start\n\tformatList->formats = NULL;\n// fix_end\n// fix_start\n\n\tStream_StaticInit(&sub1, Stream_Pointer(s), formatList->dataLen);\n\tif (!Stream_SafeSeek(s, formatList->dataLen))\n\t\treturn ERROR_INVALID_DATA;\n// fix_end\n// fix_start\n// fix_end\n// fix_start\n\t\tconst size_t cap = Stream_Capacity(&sub1);\n\t\tformatList->numFormats = (cap / 36);\n// fix_end\n// fix_start\n\t\tif ((formatList->numFormats * 36) != cap)\n// fix_end\n// fix_start\n\t\t\tWLog_ERR(TAG, \"Invalid short format list length: %\" PRIuz \"\", cap);\n// fix_end\n// fix_start\n\t\twhile (Stream_GetRemainingLength(&sub1) >= 4)\n// fix_end\n// fix_start\n\t\t\tStream_Read_UINT32(&sub1, formats[index].formatId);\n// fix_end\n// fix_start\n\t\t\tszFormatName = (char*)Stream_Pointer(&sub1);\n\t\t\twszFormatName = (WCHAR*)Stream_Pointer(&sub1);\n\t\t\tif (!Stream_SafeSeek(&sub1, 32))\n\t\t\t\tgoto error_out;\n// fix_end\n// fix_start\n// fix_end\n// fix_start\n// fix_end\n// fix_start\n// fix_end\n// fix_start\n\t\tsub2 = sub1;\n\t\twhile (Stream_GetRemainingLength(&sub1) > 0)\n// fix_end\n// fix_start\n\t\t\tsize_t rest;\n\t\t\tif (!Stream_SafeSeek(&sub1, 4))\n\t\t\t\tgoto error_out;\n// fix_end\n// fix_start\n\t\t\twszFormatName = (WCHAR*)Stream_Pointer(&sub1);\n\t\t\trest = Stream_GetRemainingLength(&sub1);\n\t\t\tformatNameLength = _wcsnlen(wszFormatName, rest / sizeof(WCHAR));\n// fix_end\n// fix_start\n\t\t\tif (!Stream_SafeSeek(&sub1, (formatNameLength + 1) * sizeof(WCHAR)))\n\t\t\t\tgoto error_out;\n// fix_end\n// fix_start\n// fix_end\n// fix_start\n\t\twhile (Stream_GetRemainingLength(&sub2) >= 4)\n// fix_end\n// fix_start\n\t\t\tsize_t rest;\n\t\t\tStream_Read_UINT32(&sub2, formats[index].formatId);\n// fix_end\n// fix_start\n\t\t\twszFormatName = (WCHAR*)Stream_Pointer(&sub2);\n\t\t\trest = Stream_GetRemainingLength(&sub2);\n\t\t\tformatNameLength = _wcsnlen(wszFormatName, rest / sizeof(WCHAR));\n\t\t\tif (!Stream_SafeSeek(&sub2, (formatNameLength + 1) * sizeof(WCHAR)))\n\t\t\t\tgoto error_out;\n// fix_end\n// fix_start\n\t\t\t\tif (ConvertFromUnicode(CP_UTF8, 0, wszFormatName, formatNameLength,\n\t\t\t\t                       &(formats[index].formatName), 0, NULL, NULL) < 1)\n// fix_end\n// fix_start\n// fix_end\n", "cwe": "CWE-125", "cwe_name": "Out-of-bounds Read", "cve": "CVE-2020-11085", "cve_desc": "In FreeRDP before 2.1.0, there is an out-of-bounds read in cliprdr_read_format_list. Clipboard format data read (by client or server) might read data out-of-bounds. This has been fixed in 2.1.0.", "project": "FreeRDP", "idx": 206874}
{"source": " static int identity_count(void *v, const char *key, const char *val)\n {\n     int *count = v;\n// bug_start\n    *count += strlen(key) * 3 + strlen(val) * 3 + 1;\n// bug_end\n     return 1;\n }\n \n", "target": "// fix_start\n    *count += strlen(key) * 3 + strlen(val) * 3 + 2;\n// fix_end\n", "cwe": "CWE-787", "cwe_name": "Out-of-bounds Write", "cve": "CVE-2021-26691", "cve_desc": "In Apache HTTP Server versions 2.4.0 to 2.4.46 a specially crafted SessionHeader sent by an origin server could cause a heap overflow", "project": "httpd", "idx": 206917}
{"source": " static Image *ReadMATImage(const ImageInfo *image_info,ExceptionInfo *exception)\n {\n   Image *image, *image2=NULL,\n    *rotated_image;\n   register Quantum *q;\n \n   unsigned int status;\n   MATHeader MATLAB_HDR;\n   size_t size;\n   size_t CellType;\n   QuantumInfo *quantum_info;\n   ImageInfo *clone_info;\n   int i;\n   ssize_t ldblk;\n   unsigned char *BImgBuff = NULL;\n   double MinVal, MaxVal;\n   unsigned z, z2;\n   unsigned Frames;\n   int logging;\n   int sample_size;\n   MagickOffsetType filepos=0x80;\n   BlobInfo *blob;\n   size_t one;\n \n   unsigned int (*ReadBlobXXXLong)(Image *image);\n   unsigned short (*ReadBlobXXXShort)(Image *image);\n   void (*ReadBlobDoublesXXX)(Image * image, size_t len, double *data);\n   void (*ReadBlobFloatsXXX)(Image * image, size_t len, float *data);\n \n \n   assert(image_info != (const ImageInfo *) NULL);\n   assert(image_info->signature == MagickCoreSignature);\n   assert(exception != (ExceptionInfo *) NULL);\n   assert(exception->signature == MagickCoreSignature);\n   logging = LogMagickEvent(CoderEvent,GetMagickModule(),\"enter\");\n \n   image = AcquireImage(image_info,exception);\n \n   status = OpenBlob(image_info, image, ReadBinaryBlobMode, exception);\n   if (status == MagickFalse)\n     {\n       image=DestroyImageList(image);\n       return((Image *) NULL);\n     }\n   quantum_info=(QuantumInfo *) NULL;\n   clone_info=(ImageInfo *) NULL;\n   if (ReadBlob(image,124,(unsigned char *) &MATLAB_HDR.identific) != 124)\n     ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n   if (strncmp(MATLAB_HDR.identific,\"MATLAB\",6) != 0)\n     {\n       image2=ReadMATImageV4(image_info,image,exception);\n       if (image2  == NULL)\n         goto MATLAB_KO;\n       image=image2;\n       goto END_OF_READING;\n     }\n   MATLAB_HDR.Version = ReadBlobLSBShort(image);\n   if(ReadBlob(image,2,(unsigned char *) &MATLAB_HDR.EndianIndicator) != 2)\n     ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n \n   if (logging)\n     (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"  Endian %c%c\",\n       MATLAB_HDR.EndianIndicator[0],MATLAB_HDR.EndianIndicator[1]);\n   if (!strncmp(MATLAB_HDR.EndianIndicator, \"IM\", 2))\n   {\n     ReadBlobXXXLong = ReadBlobLSBLong;\n     ReadBlobXXXShort = ReadBlobLSBShort;\n     ReadBlobDoublesXXX = ReadBlobDoublesLSB;\n     ReadBlobFloatsXXX = ReadBlobFloatsLSB;\n     image->endian = LSBEndian;\n   }\n   else if (!strncmp(MATLAB_HDR.EndianIndicator, \"MI\", 2))\n   {\n     ReadBlobXXXLong = ReadBlobMSBLong;\n     ReadBlobXXXShort = ReadBlobMSBShort;\n     ReadBlobDoublesXXX = ReadBlobDoublesMSB;\n     ReadBlobFloatsXXX = ReadBlobFloatsMSB;\n     image->endian = MSBEndian;\n   }\n   else\n     goto MATLAB_KO;\n \n   if (strncmp(MATLAB_HDR.identific, \"MATLAB\", 6))\n     {\n MATLAB_KO:\n       clone_info=DestroyImageInfo(clone_info);\n       ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n     }\n \n   filepos = TellBlob(image);\n   while(!EOFBlob(image))\n   {\n     Frames = 1;\n     (void) SeekBlob(image,filepos,SEEK_SET);\n \n     MATLAB_HDR.DataType = ReadBlobXXXLong(image);\n     if(EOFBlob(image)) break;\n     MATLAB_HDR.ObjectSize = ReadBlobXXXLong(image);\n     if(EOFBlob(image)) break;\n     if((MagickSizeType) (MATLAB_HDR.ObjectSize+filepos) > GetBlobSize(image))\n       goto MATLAB_KO;\n     filepos += MATLAB_HDR.ObjectSize + 4 + 4;\n \n     clone_info=CloneImageInfo(image_info);\n     image2 = image;\n #if defined(MAGICKCORE_ZLIB_DELEGATE)\n     if(MATLAB_HDR.DataType == miCOMPRESSED)\n     {\n       image2 = decompress_block(image,&MATLAB_HDR.ObjectSize,clone_info,exception);\n       if(image2==NULL) continue;\n       MATLAB_HDR.DataType = ReadBlobXXXLong(image2);\n     }\n #endif\n \n     if(MATLAB_HDR.DataType!=miMATRIX) continue;\n \n     MATLAB_HDR.unknown1 = ReadBlobXXXLong(image2);\n     MATLAB_HDR.unknown2 = ReadBlobXXXLong(image2);\n \n     MATLAB_HDR.unknown5 = ReadBlobXXXLong(image2);\n     MATLAB_HDR.StructureClass = MATLAB_HDR.unknown5 & 0xFF;\n     MATLAB_HDR.StructureFlag = (MATLAB_HDR.unknown5>>8) & 0xFF;\n \n     MATLAB_HDR.unknown3 = ReadBlobXXXLong(image2);\n     if(image!=image2)\n       MATLAB_HDR.unknown4 = ReadBlobXXXLong(image2);\n     MATLAB_HDR.unknown4 = ReadBlobXXXLong(image2);\n     MATLAB_HDR.DimFlag = ReadBlobXXXLong(image2);\n     MATLAB_HDR.SizeX = ReadBlobXXXLong(image2);\n     MATLAB_HDR.SizeY = ReadBlobXXXLong(image2);\n \n \n     switch(MATLAB_HDR.DimFlag)\n     {\n       case  8: z2=z=1; break;\n       case 12: z2=z = ReadBlobXXXLong(image2);\n            (void) ReadBlobXXXLong(image2);\n          if(z!=3) ThrowReaderException(CoderError, \"MultidimensionalMatricesAreNotSupported\");\n          break;\n       case 16: z2=z = ReadBlobXXXLong(image2);\n          if(z!=3 && z!=1)\n             ThrowReaderException(CoderError, \"MultidimensionalMatricesAreNotSupported\");\n          Frames = ReadBlobXXXLong(image2);\n          if (Frames == 0)\n            ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n          break;\n       default: ThrowReaderException(CoderError, \"MultidimensionalMatricesAreNotSupported\");\n     }\n \n     MATLAB_HDR.Flag1 = ReadBlobXXXShort(image2);\n     MATLAB_HDR.NameFlag = ReadBlobXXXShort(image2);\n \n     if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\n           \"MATLAB_HDR.StructureClass %d\",MATLAB_HDR.StructureClass);\n     if (MATLAB_HDR.StructureClass != mxCHAR_CLASS &&\n         MATLAB_HDR.StructureClass != mxSINGLE_CLASS &&\n         MATLAB_HDR.StructureClass != mxDOUBLE_CLASS &&\n         MATLAB_HDR.StructureClass != mxINT8_CLASS &&\n         MATLAB_HDR.StructureClass != mxUINT8_CLASS &&\n         MATLAB_HDR.StructureClass != mxINT16_CLASS &&\n         MATLAB_HDR.StructureClass != mxUINT16_CLASS &&\n         MATLAB_HDR.StructureClass != mxINT32_CLASS &&\n         MATLAB_HDR.StructureClass != mxUINT32_CLASS &&\n         MATLAB_HDR.StructureClass != mxINT64_CLASS &&\n         MATLAB_HDR.StructureClass != mxUINT64_CLASS)\n       ThrowReaderException(CoderError,\"UnsupportedCellTypeInTheMatrix\");\n \n     switch (MATLAB_HDR.NameFlag)\n     {\n       case 0:\n         size = ReadBlobXXXLong(image2);\n         size = 4 * (ssize_t) ((size + 3 + 1) / 4);\n         (void) SeekBlob(image2, size, SEEK_CUR);\n         break;\n       case 1:\n       case 2:\n       case 3:\n       case 4:\n         (void) ReadBlob(image2, 4, (unsigned char *) &size);\n         break;\n       default:\n         goto MATLAB_KO;\n     }\n \n     CellType = ReadBlobXXXLong(image2);\n     if (logging)\n       (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n         \"MATLAB_HDR.CellType: %.20g\",(double) CellType);\n \n     (void) ReadBlob(image2, 4, (unsigned char *) &size);\n \n     NEXT_FRAME:\n     switch (CellType)\n     {\n       case miINT8:\n       case miUINT8:\n         sample_size = 8;\n         if(MATLAB_HDR.StructureFlag & FLAG_LOGICAL)\n           image->depth = 1;\n         else\n           image->depth = 8;\n         ldblk = (ssize_t) MATLAB_HDR.SizeX;\n         break;\n       case miINT16:\n       case miUINT16:\n         sample_size = 16;\n         image->depth = 16;\n         ldblk = (ssize_t) (2 * MATLAB_HDR.SizeX);\n         break;\n       case miINT32:\n       case miUINT32:\n         sample_size = 32;\n         image->depth = 32;\n         ldblk = (ssize_t) (4 * MATLAB_HDR.SizeX);\n         break;\n       case miINT64:\n       case miUINT64:\n         sample_size = 64;\n         image->depth = 64;\n         ldblk = (ssize_t) (8 * MATLAB_HDR.SizeX);\n         break;\n       case miSINGLE:\n         sample_size = 32;\n         image->depth = 32;\n         (void) SetImageOption(clone_info,\"quantum:format\",\"floating-point\");\n         if (MATLAB_HDR.StructureFlag & FLAG_COMPLEX)\n   {\n   }\n         ldblk = (ssize_t) (4 * MATLAB_HDR.SizeX);\n         break;\n       case miDOUBLE:\n         sample_size = 64;\n         image->depth = 64;\n         (void) SetImageOption(clone_info,\"quantum:format\",\"floating-point\");\n DisableMSCWarning(4127)\n         if (sizeof(double) != 8)\n RestoreMSCWarning\n           ThrowReaderException(CoderError, \"IncompatibleSizeOfDouble\");\n         if (MATLAB_HDR.StructureFlag & FLAG_COMPLEX)\n   {\n   }\n         ldblk = (ssize_t) (8 * MATLAB_HDR.SizeX);\n         break;\n       default:\n         ThrowReaderException(CoderError, \"UnsupportedCellTypeInTheMatrix\");\n     }\n     (void) sample_size;\n     image->columns = MATLAB_HDR.SizeX;\n     image->rows = MATLAB_HDR.SizeY;\n     one=1;\n     image->colors = one << image->depth;\n     if (image->columns == 0 || image->rows == 0)\n       goto MATLAB_KO;\n     if((unsigned long)ldblk*MATLAB_HDR.SizeY > MATLAB_HDR.ObjectSize)\n       goto MATLAB_KO;\n     if ((MATLAB_HDR.DimFlag == 8) &&\n         ((MATLAB_HDR.StructureFlag & FLAG_COMPLEX) == 0))\n       {\n         image->type=GrayscaleType;\n         SetImageColorspace(image,GRAYColorspace,exception);\n       }\n \n \n     if (image_info->ping)\n     {\n       size_t temp = image->columns;\n       image->columns = image->rows;\n       image->rows = temp;\n       goto done_reading;\n     }\n     status=SetImageExtent(image,image->columns,image->rows,exception);\n     if (status == MagickFalse)\n       return(DestroyImageList(image));\n     quantum_info=AcquireQuantumInfo(clone_info,image);\n     if (quantum_info == (QuantumInfo *) NULL)\n       ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n \n     BImgBuff = (unsigned char *) AcquireQuantumMemory((size_t) (ldblk),sizeof(double));\n     if (BImgBuff == NULL)\n       ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n     (void) ResetMagickMemory(BImgBuff,0,ldblk*sizeof(double));\n \n     MinVal = 0;\n     MaxVal = 0;\n     if (CellType==miDOUBLE || CellType==miSINGLE)\n     {\n       CalcMinMax(image2, image_info->endian,  MATLAB_HDR.SizeX, MATLAB_HDR.SizeY, CellType, ldblk, BImgBuff, &quantum_info->minimum, &quantum_info->maximum);\n     }\n \n     if(z==1) z=0;\n     do\n     {\n       for (i = 0; i < (ssize_t) MATLAB_HDR.SizeY; i++)\n       {\n         q=GetAuthenticPixels(image,0,MATLAB_HDR.SizeY-i-1,image->columns,1,exception);\n         if (q == (Quantum *) NULL)\n   {\n     if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\n               \"  MAT set image pixels returns unexpected NULL on a row %u.\", (unsigned)(MATLAB_HDR.SizeY-i-1));\n     goto done_reading;\n   }\n         if(ReadBlob(image2,ldblk,(unsigned char *)BImgBuff) != (ssize_t) ldblk)\n   {\n     if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"  MAT cannot read scanrow %u from a file.\", (unsigned)(MATLAB_HDR.SizeY-i-1));\n     goto ExitLoop;\n   }\n         if((CellType==miINT8 || CellType==miUINT8) && (MATLAB_HDR.StructureFlag & FLAG_LOGICAL))\n         {\n           FixLogical((unsigned char *)BImgBuff,ldblk);\n           if(ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,z2qtype[z],BImgBuff,exception) <= 0)\n     {\n ImportQuantumPixelsFailed:\n       if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\n               \"  MAT failed to ImportQuantumPixels for a row %u\", (unsigned)(MATLAB_HDR.SizeY-i-1));\n       break;\n     }\n         }\n         else\n         {\n           if(ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,z2qtype[z],BImgBuff,exception) <= 0)\n       goto ImportQuantumPixelsFailed;\n \n \n           if (z<=1 &&\n           (CellType==miINT8 || CellType==miINT16 || CellType==miINT32 || CellType==miINT64))\n       FixSignedValues(image,q,MATLAB_HDR.SizeX);\n         }\n \n         if (!SyncAuthenticPixels(image,exception))\n   {\n     if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\n             \"  MAT failed to sync image pixels for a row %u\", (unsigned)(MATLAB_HDR.SizeY-i-1));\n     goto ExitLoop;\n   }\n       }\n     } while(z-- >= 2);\n ExitLoop:\n \n \n     if (MATLAB_HDR.StructureFlag & FLAG_COMPLEX)\n     {\n       CellType = ReadBlobXXXLong(image2);\n       i = ReadBlobXXXLong(image2);\n \n       if (CellType==miDOUBLE || CellType==miSINGLE)\n       {\n         CalcMinMax(image2,  image_info->endian, MATLAB_HDR.SizeX, MATLAB_HDR.SizeY, CellType, ldblk, BImgBuff, &MinVal, &MaxVal);\n       }\n \n       if (CellType==miDOUBLE)\n         for (i = 0; i < (ssize_t) MATLAB_HDR.SizeY; i++)\n   {\n           ReadBlobDoublesXXX(image2, ldblk, (double *)BImgBuff);\n           InsertComplexDoubleRow(image, (double *)BImgBuff, i, MinVal, MaxVal,\n             exception);\n   }\n \n       if (CellType==miSINGLE)\n         for (i = 0; i < (ssize_t) MATLAB_HDR.SizeY; i++)\n   {\n           ReadBlobFloatsXXX(image2, ldblk, (float *)BImgBuff);\n           InsertComplexFloatRow(image,(float *)BImgBuff,i,MinVal,MaxVal,\n             exception);\n   }\n     }\n \n     if ((MATLAB_HDR.DimFlag == 8) &&\n         ((MATLAB_HDR.StructureFlag & FLAG_COMPLEX) == 0))\n       image->type=GrayscaleType;\n     if (image->depth == 1)\n       image->type=BilevelType;\n \n     if(image2==image)\n         image2 = NULL;\n \n     rotated_image = RotateImage(image, 90.0, exception);\n     if (rotated_image != (Image *) NULL)\n     {\n       rotated_image->page.x=0;\n       rotated_image->page.y=0;\n \n       blob = rotated_image->blob;\n       rotated_image->blob = image->blob;\n       rotated_image->colors = image->colors;\n       image->blob = blob;\n       AppendImageToList(&image,rotated_image);\n       DeleteImageFromList(&image);\n     }\n \n done_reading:\n \n     if(image2!=NULL)\n       if(image2!=image)\n       {\n         DeleteImageFromList(&image2);\n   if(clone_info)\n   {\n           if(clone_info->file)\n     {\n             fclose(clone_info->file);\n             clone_info->file = NULL;\n             (void) remove_utf8(clone_info->filename);\n     }\n         }\n       }\n \n     AcquireNextImage(image_info,image,exception);\n     if (image->next == (Image *) NULL) break;\n     image=SyncNextImageInList(image);\n     image->columns=image->rows=0;\n     image->colors=0;\n \n     RelinquishMagickMemory(BImgBuff);\n     BImgBuff = NULL;\n \n     if(--Frames>0)\n     {\n       z = z2;\n       if(image2==NULL) image2 = image;\n       goto NEXT_FRAME;\n     }\n     if ((image2!=NULL) && (image2!=image))\n       {\n         DeleteImageFromList(&image2);\n         if(clone_info)\n         {\n           if(clone_info->file)\n           {\n             fclose(clone_info->file);\n             clone_info->file = NULL;\n             (void) remove_utf8(clone_info->filename);\n           }\n         }\n         }\n   }\n \n   RelinquishMagickMemory(BImgBuff);\n   if (quantum_info != (QuantumInfo *) NULL)\n     quantum_info=DestroyQuantumInfo(quantum_info);\n END_OF_READING:\n   if (clone_info)\n     clone_info=DestroyImageInfo(clone_info);\n   CloseBlob(image);\n \n \n   {\n     Image *p;\n     ssize_t scene=0;\n \n     p=image;\n     image=NULL;\n     while (p != (Image *) NULL)\n       {\n         Image *tmp=p;\n         if ((p->rows == 0) || (p->columns == 0)) {\n           p=p->previous;\n           DeleteImageFromList(&tmp);\n         } else {\n           image=p;\n           p=p->previous;\n         }\n       }\n \n     for (p=image; p != (Image *) NULL; p=p->next)\n       p->scene=scene++;\n   }\n \n   if(clone_info != NULL)\n   {\n     if(clone_info->file)\n     {\n       fclose(clone_info->file);\n       clone_info->file = NULL;\n       (void) remove_utf8(clone_info->filename);\n     }\n     DestroyImageInfo(clone_info);\n     clone_info = NULL;\n   }\n   if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\"return\");\n// bug_start\n// bug_end\n   if(image==NULL)\n     ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n   return (image);\n }\n \n", "target": "// fix_start\n  if ((image != image2) && (image2 != (Image *) NULL))\n    image2=DestroyImage(image2);\n// fix_end\n", "cwe": "CWE-772", "cwe_name": "Missing Release of Resource after Effective Lifetime", "cve": "CVE-2017-11644", "cve_desc": "When ImageMagick 7.0.6-1 processes a crafted file in convert, it can lead to a Memory Leak in the ReadMATImage() function in coders/mat.c.", "project": "ImageMagick", "idx": 206930}
{"source": " static void gprinter_free(struct usb_function *f)\n {\n \tstruct printer_dev *dev = func_to_printer(f);\n \tstruct f_printer_opts *opts;\n \n \topts = container_of(f->fi, struct f_printer_opts, func_inst);\n// bug_start\n\tkfree(dev);\n// bug_end\n \tmutex_lock(&opts->lock);\n \t--opts->refcnt;\n \tmutex_unlock(&opts->lock);\n }\n \n", "target": "// fix_start\n\n\tkref_put(&dev->kref, printer_dev_free);\n// fix_end\n", "cwe": "CWE-416", "cwe_name": "Use After Free", "cve": "CVE-2020-27784", "cve_desc": "A vulnerability was found in the Linux kernel, where accessing a deallocated instance in printer_ioctl() printer_ioctl() tries to access of a printer_dev instance. However, use-after-free arises because it had been freed by gprinter_free().", "project": "linux", "idx": 206932}
{"source": " tiff12_print_page(gx_device_printer * pdev, gp_file * file)\n {\n     gx_device_tiff *const tfdev = (gx_device_tiff *)pdev;\n     int code;\n \n     if (gdev_prn_file_is_new(pdev)) {\n         tfdev->tif = tiff_from_filep(pdev, pdev->dname, file, tfdev->BigEndian, tfdev->UseBigTIFF);\n         if (!tfdev->tif)\n             return_error(gs_error_invalidfileaccess);\n     }\n \n     code = gdev_tiff_begin_page(tfdev, file);\n     if (code < 0)\n         return code;\n \n     TIFFSetField(tfdev->tif, TIFFTAG_BITSPERSAMPLE, 4);\n     tiff_set_rgb_fields(tfdev);\n \n     TIFFCheckpointDirectory(tfdev->tif);\n \n     {\n         int y;\n         int size = gdev_prn_raster(pdev);\n// bug_start\n        byte *data = gs_alloc_bytes(pdev->memory, size, \"tiff12_print_page\");\n// bug_end\n \n         if (data == 0)\n             return_error(gs_error_VMerror);\n \n// bug_start\n        memset(data, 0, size);\n// bug_end\n \n         for (y = 0; y < pdev->height; ++y) {\n             const byte *src;\n             byte *dest;\n             int x;\n \n             code = gdev_prn_copy_scan_lines(pdev, y, data, size);\n             if (code < 0)\n                 break;\n \n             for (src = data, dest = data, x = 0; x < size;\n                  src += 6, dest += 3, x += 6\n                 ) {\n                 dest[0] = (src[0] & 0xf0) | (src[1] >> 4);\n                 dest[1] = (src[2] & 0xf0) | (src[3] >> 4);\n                 dest[2] = (src[4] & 0xf0) | (src[5] >> 4);\n             }\n             TIFFWriteScanline(tfdev->tif, data, y, 0);\n         }\n         gs_free_object(pdev->memory, data, \"tiff12_print_page\");\n \n         TIFFWriteDirectory(tfdev->tif);\n     }\n \n     return code;\n }\n \n", "target": "// fix_start\n\n        int size_alloc = size + 5;\n        byte *data = gs_alloc_bytes(pdev->memory, size_alloc, \"tiff12_print_page\");\n// fix_end\n// fix_start\n        memset(data, 0, size_alloc);\n// fix_end\n", "cwe": "CWE-787", "cwe_name": "Out-of-bounds Write", "cve": "CVE-2020-16300", "cve_desc": "A buffer overflow vulnerability in tiff12_print_page() in devices/gdevtfnx.c of Artifex Software GhostScript v9.50 allows a remote attacker to cause a denial of service via a crafted PDF file. This is fixed in v9.51.", "project": "ghostpdl", "idx": 206948}
{"source": " static int xar_hash_check(int hash, const void * result, const void * expected)\n {\n     int len;\n \n     if (!result || !expected)\n         return 1;\n     switch (hash) {\n     case XAR_CKSUM_SHA1:\n// bug_start\n        len = SHA1_HASH_SIZE;\n// bug_end\n         break;\n     case XAR_CKSUM_MD5:\n// bug_start\n        len = CLI_HASH_MD5;\n// bug_end\n         break;\n     case XAR_CKSUM_OTHER:\n     case XAR_CKSUM_NONE:\n     default:\n         return 1;\n     }\n     return memcmp(result, expected, len);\n }\n \n", "target": "// fix_start\n        len = CLI_HASHLEN_SHA1;\n// fix_end\n// fix_start\n        len = CLI_HASHLEN_MD5;\n// fix_end\n", "cwe": "CWE-125", "cwe_name": "Out-of-bounds Read", "cve": "CVE-2018-1000085", "cve_desc": "ClamAV version version 0.99.3 contains a Out of bounds heap memory read vulnerability in XAR parser, function xar_hash_check() that can result in Leaking of memory, may help in developing exploit chains.. This attack appear to be exploitable via The victim must scan a crafted XAR file. This vulnerability appears to have been fixed in after commit d96a6b8bcc7439fa7e3876207aa0a8e79c8451b6.", "project": "clamav-devel", "idx": 206998}
{"source": " void CLASS kodak_65000_load_raw()\n {\n   short buf[256];\n   int row, col, len, pred[2], ret, i;\n \n   for (row=0; row < height; row++)\n   {\n #ifdef LIBRAW_LIBRARY_BUILD\n     checkCancel();\n #endif\n     for (col=0; col < width; col+=256) {\n       pred[0] = pred[1] = 0;\n       len = MIN (256, width-col);\n       ret = kodak_65000_decode (buf, len);\n       for (i=0; i < len; i++)\n// bug_start\n\tif ((RAW(row,col+i) =\tcurve[ret ? buf[i] :\n\t\t(pred[i & 1] += buf[i])]) >> 12) derror();\n// bug_end\n     }\n   }\n }\n \n", "target": "// fix_start\n      {\n\tint idx = ret ? buf[i] : (pred[i & 1] += buf[i]);\n\tif(idx >=0 && idx <= 0xffff)\n\t {\n\t   if ((RAW(row,col+i) = curve[idx]) >> 12) derror();\n         }\n\t else\n\t   derror();\n      }\n// fix_end\n", "cwe": "CWE-787", "cwe_name": "Out-of-bounds Write", "cve": "CVE-2017-14348", "cve_desc": "LibRaw before 0.18.4 has a heap-based Buffer Overflow in the processCanonCameraInfo function via a crafted file.", "project": "LibRaw", "idx": 207059}
{"source": " static int propagateConstantExprRewrite(Walker *pWalker, Expr *pExpr){\n   int i;\n   WhereConst *pConst;\n   if( pExpr->op!=TK_COLUMN ) return WRC_Continue;\n// bug_start\n  if( ExprHasProperty(pExpr, EP_FixedCol) ) return WRC_Continue;\n// bug_end\n   pConst = pWalker->u.pConst;\n   for(i=0; i<pConst->nConst; i++){\n     Expr *pColumn = pConst->apExpr[i*2];\n     if( pColumn==pExpr ) continue;\n     if( pColumn->iTable!=pExpr->iTable ) continue;\n     if( pColumn->iColumn!=pExpr->iColumn ) continue;\n     pConst->nChng++;\n     ExprClearProperty(pExpr, EP_Leaf);\n     ExprSetProperty(pExpr, EP_FixedCol);\n     assert( pExpr->pLeft==0 );\n     pExpr->pLeft = sqlite3ExprDup(pConst->pParse->db, pConst->apExpr[i*2+1], 0);\n     break;\n   }\n   return WRC_Prune;\n }\n \n", "target": "// fix_start\n  if( ExprHasProperty(pExpr, EP_FixedCol|EP_FromJoin) ) return WRC_Continue;\n// fix_end\n", "cwe": "CWE-125", "cwe_name": "Out-of-bounds Read", "cve": "CVE-2020-6405", "cve_desc": "Out of bounds read in SQLite in Google Chrome prior to 80.0.3987.87 allowed a remote attacker to obtain potentially sensitive information from process memory via a crafted HTML page.", "project": "sqlite", "idx": 207148}
{"source": " prepare_repo_download_targets(LrHandle *handle,\n                               LrYumRepo *repo,\n                               LrYumRepoMd *repomd,\n                               LrMetadataTarget *mdtarget,\n                               GSList **targets,\n                               GSList **cbdata_list,\n                               GError **err)\n {\n     char *destdir;\n \n     destdir = handle->destdir;\n     assert(destdir);\n     assert(strlen(destdir));\n     assert(!err || *err == NULL);\n \n     if(handle->cachedir) {\n         lr_yum_switch_to_zchunk(handle, repomd);\n         repo->use_zchunk = TRUE;\n     } else {\n         g_debug(\"%s: Cache directory not set, disabling zchunk\", __func__);\n         repo->use_zchunk = FALSE;\n     }\n \n     for (GSList *elem = repomd->records; elem; elem = g_slist_next(elem)) {\n         int fd;\n         char *path;\n         LrDownloadTarget *target;\n         LrYumRepoMdRecord *record = elem->data;\n         CbData *cbdata = NULL;\n         void *user_cbdata = NULL;\n         LrEndCb endcb = NULL;\n \n         if (mdtarget != NULL) {\n             user_cbdata = mdtarget->cbdata;\n             endcb = mdtarget->endcb;\n         }\n \n         assert(record);\n \n         if (!lr_yum_repomd_record_enabled(handle, record->type, repomd->records))\n             continue;\n \n         char *location_href = record->location_href;\n// bug_start\n// bug_end\n         gboolean is_zchunk = FALSE;\n         #ifdef WITH_ZCHUNK\n         if (handle->cachedir && record->header_checksum)\n             is_zchunk = TRUE;\n         #endif\n \n         GSList *checksums = NULL;\n         if (is_zchunk) {\n             #ifdef WITH_ZCHUNK\n             if(!prepare_repo_download_zck_target(handle, record, &path, &fd,\n                                                  &checksums, targets, err))\n                 return FALSE;\n             #endif\n         } else {\n             if(!prepare_repo_download_std_target(handle, record, &path, &fd,\n                                                  &checksums, targets, err))\n                 return FALSE;\n         }\n \n         if (handle->user_cb || handle->hmfcb) {\n             cbdata = cbdata_new(handle->user_data,\n                                 user_cbdata,\n                                 handle->user_cb,\n                                 handle->hmfcb,\n                                 record->type);\n             *cbdata_list = g_slist_append(*cbdata_list, cbdata);\n         }\n \n         target = lr_downloadtarget_new(handle,\n                                        location_href,\n                                        record->location_base,\n                                        fd,\n                                        NULL,\n                                        checksums,\n                                        0,\n                                        0,\n                                        NULL,\n                                        cbdata,\n                                        endcb,\n                                        NULL,\n                                        NULL,\n                                        0,\n                                        0,\n                                        NULL,\n                                        FALSE,\n                                        is_zchunk);\n \n         if(is_zchunk) {\n             #ifdef WITH_ZCHUNK\n             target->expectedsize = record->size_header;\n             target->zck_header_size = record->size_header;\n             #endif\n         }\n \n         if (mdtarget != NULL)\n             mdtarget->repomd_records_to_download++;\n         *targets = g_slist_append(*targets, target);\n \n         lr_yum_repo_update(repo, record->type, path);\n         lr_free(path);\n     }\n \n     return TRUE;\n }\n \n", "target": "// fix_start\n\n        char *dest_dir = realpath(handle->destdir, NULL);\n        path = lr_pathconcat(handle->destdir, record->location_href, NULL);\n        char *requested_dir = realpath(dirname(path), NULL);\n        lr_free(path);\n        if (!g_str_has_prefix(requested_dir, dest_dir)) {\n            g_debug(\"%s: Invalid path: %s\", __func__, location_href);\n            g_set_error(err, LR_YUM_ERROR, LRE_IO, \"Invalid path: %s\", location_href);\n            g_slist_free_full(*targets, (GDestroyNotify) lr_downloadtarget_free);\n            free(requested_dir);\n            free(dest_dir);\n            return FALSE;\n        }\n        free(requested_dir);\n        free(dest_dir);\n\n// fix_end\n", "cwe": "CWE-22", "cwe_name": "Path Traversal", "cve": "CVE-2020-14352", "cve_desc": "A flaw was found in librepo in versions before 1.12.1. A directory traversal vulnerability was found where it failed to sanitize paths in remote repository metadata. An attacker controlling a remote repository may be able to copy files outside of the destination directory on the targeted system via path traversal. This flaw could potentially result in system compromise via the overwriting of critical system files. The highest threat from this flaw is to users that make use of untrusted third-party repositories.", "project": "librepo", "idx": 207158}
{"source": " static int jpc_dec_process_siz(jpc_dec_t *dec, jpc_ms_t *ms)\n {\n \tjpc_siz_t *siz = &ms->parms.siz;\n \tint compno;\n \tint tileno;\n \tjpc_dec_tile_t *tile;\n \tjpc_dec_tcomp_t *tcomp;\n \tint htileno;\n \tint vtileno;\n \tjpc_dec_cmpt_t *cmpt;\n \tsize_t size;\n \tsize_t num_samples;\n \tsize_t num_samples_delta;\n// bug_start\n// bug_end\n \n \tsize_t tile_samples;\n \tif (!jas_safe_size_mul(siz->tilewidth, siz->tileheight, &tile_samples) ||\n \t    (dec->max_samples > 0 && tile_samples > dec->max_samples)) {\n \t\tjas_eprintf(\"tile too large\\n\");\n \t\treturn -1;\n \t}\n \n \tdec->xstart = siz->xoff;\n \tdec->ystart = siz->yoff;\n \tdec->xend = siz->width;\n \tdec->yend = siz->height;\n \tdec->tilewidth = siz->tilewidth;\n \tdec->tileheight = siz->tileheight;\n \tdec->tilexoff = siz->tilexoff;\n \tdec->tileyoff = siz->tileyoff;\n \tdec->numcomps = siz->numcomps;\n \n \tif (!(dec->cp = jpc_dec_cp_create(dec->numcomps))) {\n \t\treturn -1;\n \t}\n \n \tif (!(dec->cmpts = jas_alloc2(dec->numcomps, sizeof(jpc_dec_cmpt_t)))) {\n \t\treturn -1;\n \t}\n \n \tnum_samples = 0;\n \tfor (compno = 0, cmpt = dec->cmpts; compno < dec->numcomps; ++compno,\n \t  ++cmpt) {\n \t\tcmpt->prec = siz->comps[compno].prec;\n \t\tcmpt->sgnd = siz->comps[compno].sgnd;\n \t\tcmpt->hstep = siz->comps[compno].hsamp;\n \t\tcmpt->vstep = siz->comps[compno].vsamp;\n \t\tcmpt->width = JPC_CEILDIV(dec->xend, cmpt->hstep) -\n \t\t  JPC_CEILDIV(dec->xstart, cmpt->hstep);\n \t\tcmpt->height = JPC_CEILDIV(dec->yend, cmpt->vstep) -\n \t\t  JPC_CEILDIV(dec->ystart, cmpt->vstep);\n \t\tcmpt->hsubstep = 0;\n \t\tcmpt->vsubstep = 0;\n \n \t\tif (!jas_safe_size_mul(cmpt->width, cmpt->height, &num_samples_delta)) {\n \t\t\tjas_eprintf(\"image too large\\n\");\n \t\t\treturn -1;\n \t\t}\n \t\tif (!jas_safe_size_add(num_samples, num_samples_delta, &num_samples)) {\n \t\t\tjas_eprintf(\"image too large\\n\");\n \t\t\treturn -1;\n \t\t}\n \t}\n \n \tif (dec->max_samples > 0 && num_samples > dec->max_samples) {\n \t\tjas_eprintf(\"maximum number of samples exceeded (%zu > %zu)\\n\",\n \t\t  num_samples, dec->max_samples);\n \t\treturn -1;\n \t}\n \n \tdec->image = 0;\n \n \tdec->numhtiles = JPC_CEILDIV(dec->xend - dec->tilexoff, dec->tilewidth);\n \tdec->numvtiles = JPC_CEILDIV(dec->yend - dec->tileyoff, dec->tileheight);\n \tassert(dec->numhtiles >= 0);\n \tassert(dec->numvtiles >= 0);\n \tif (!jas_safe_size_mul(dec->numhtiles, dec->numvtiles, &size) ||\n \t  size > INT_MAX) {\n \t\treturn -1;\n \t}\n \tif (dec->max_samples > 0 && size > dec->max_samples / 16 / 16) {\n \t\treturn -1;\n \t}\n \tif (dec->max_samples > 0 && size > dec->max_samples / dec->numcomps / 16) {\n \t\treturn -1;\n \t}\n \tdec->numtiles = size;\n \tJAS_DBGLOG(10, (\"numtiles = %d; numhtiles = %d; numvtiles = %d;\\n\",\n \t  dec->numtiles, dec->numhtiles, dec->numvtiles));\n \tif (!(dec->tiles = jas_alloc2(dec->numtiles, sizeof(jpc_dec_tile_t)))) {\n \t\treturn -1;\n \t}\n \n \tfor (tileno = 0, tile = dec->tiles; tileno < dec->numtiles; ++tileno,\n \t  ++tile) {\n \t\ttile->state = JPC_TILE_DONE;\n \t}\n \n \tfor (tileno = 0, tile = dec->tiles; tileno < dec->numtiles; ++tileno,\n \t  ++tile) {\n \t\thtileno = tileno % dec->numhtiles;\n \t\tvtileno = tileno / dec->numhtiles;\n \t\ttile->realmode = 0;\n \t\ttile->state = JPC_TILE_INIT;\n \t\ttile->xstart = JAS_MAX(dec->tilexoff + htileno * dec->tilewidth,\n \t\t  dec->xstart);\n \t\ttile->ystart = JAS_MAX(dec->tileyoff + vtileno * dec->tileheight,\n \t\t  dec->ystart);\n \t\ttile->xend = JAS_MIN(dec->tilexoff + (htileno + 1) *\n \t\t  dec->tilewidth, dec->xend);\n \t\ttile->yend = JAS_MIN(dec->tileyoff + (vtileno + 1) *\n \t\t  dec->tileheight, dec->yend);\n \t\ttile->numparts = 0;\n \t\ttile->partno = 0;\n \t\ttile->pkthdrstream = 0;\n \t\ttile->pkthdrstreampos = 0;\n \t\ttile->pptstab = 0;\n \t\ttile->cp = 0;\n \t\ttile->pi = 0;\n \t\tif (!(tile->tcomps = jas_alloc2(dec->numcomps,\n \t\t  sizeof(jpc_dec_tcomp_t)))) {\n \t\t\treturn -1;\n \t\t}\n \t\tfor (compno = 0, cmpt = dec->cmpts, tcomp = tile->tcomps;\n \t\t  compno < dec->numcomps; ++compno, ++cmpt, ++tcomp) {\n \t\t\ttcomp->rlvls = 0;\n \t\t\ttcomp->numrlvls = 0;\n \t\t\ttcomp->data = 0;\n \t\t\ttcomp->xstart = JPC_CEILDIV(tile->xstart, cmpt->hstep);\n \t\t\ttcomp->ystart = JPC_CEILDIV(tile->ystart, cmpt->vstep);\n \t\t\ttcomp->xend = JPC_CEILDIV(tile->xend, cmpt->hstep);\n \t\t\ttcomp->yend = JPC_CEILDIV(tile->yend, cmpt->vstep);\n \t\t\ttcomp->tsfb = 0;\n \t\t}\n \t}\n \n \tdec->pkthdrstreams = 0;\n \n \tdec->state = JPC_MH;\n \n \treturn 0;\n }\n \n", "target": "// fix_start\n\n\tsize_t total_samples;\n\tif (!jas_safe_size_mul(siz->width, siz->height, &total_samples) ||\n\t    (dec->max_samples > 0 && total_samples > dec->max_samples)) {\n\t\tjas_eprintf(\"image too large\\n\");\n\t\treturn -1;\n\t}\n// fix_end\n", "cwe": "CWE-617", "cwe_name": "Reachable Assertion", "cve": "CVE-2017-13746", "cve_desc": "There is a reachable assertion abort in the function jpc_dec_process_siz() in jpc/jpc_dec.c:1297 in JasPer 2.0.12 that will lead to a remote denial of service attack.", "project": "jasper", "idx": 207163}
{"source": " void LibRaw::parseSonySRF(unsigned len)\n {\n \n   if ((len > 0xfffff) || (len == 0))\n     return;\n \n   INT64 save = ftell(ifp);\n   INT64 offset =\n       0x0310c0 - save;\n   if (len < offset || offset < 0)\n     return;\n   INT64 decrypt_len = offset >> 2;\n \n   unsigned i, nWB;\n   unsigned MasterKey, SRF2Key, RawDataKey;\n   INT64 srf_offset, tag_offset, tag_data, tag_dataoffset;\n   int tag_dataunitlen;\n   uchar *srf_buf;\n// bug_start\n  short entries;\n// bug_end\n   unsigned tag_id, tag_type, tag_datalen;\n \n// bug_start\n  srf_buf = (uchar *)malloc(len);\n// bug_end\n   fread(srf_buf, len, 1, ifp);\n \n   offset += srf_buf[offset] << 2;\n \n #define CHECKBUFFER_SGET4(offset)                                              \\\n   do                                                                           \\\n   {                                                                            \\\n     if ((((offset) + 4) > len) || ((offset) < 0))                              \\\n       goto restore_after_parseSonySRF;                                         \\\n   } while (0)\n \n #define CHECKBUFFER_SGET2(offset)                                              \\\n   do                                                                           \\\n   {                                                                            \\\n     if ( ((offset + 2) > len) || ((offset) < 0))                               \\\n       goto restore_after_parseSonySRF;                                         \\\n   } while (0)\n \n   CHECKBUFFER_SGET4(offset);\n \n   MasterKey = ((unsigned)srf_buf[offset] << 24) |\n               ((unsigned)srf_buf[offset + 1] << 16) |\n               ((unsigned)srf_buf[offset + 2] << 8) |\n               (unsigned)srf_buf[offset + 3];\n \n   srf_offset = 0;\n   CHECKBUFFER_SGET2(srf_offset);\n   entries = sget2(srf_buf + srf_offset);\n   if (entries > 1000)\n     goto restore_after_parseSonySRF;\n   offset = srf_offset + 2;\n   CHECKBUFFER_SGET4(offset);\n   CHECKBUFFER_SGET4(offset + 12 * entries);\n   srf_offset = sget4(srf_buf + offset + 12 * entries) -\n                save;\n \n   if (srf_offset < 0 || decrypt_len < srf_offset / 4)\n     goto restore_after_parseSonySRF;\n   sony_decrypt((unsigned *)(srf_buf + srf_offset), decrypt_len - srf_offset / 4,\n                1, MasterKey);\n   CHECKBUFFER_SGET2(srf_offset);\n   entries = sget2(srf_buf + srf_offset);\n   if (entries > 1000)\n     goto restore_after_parseSonySRF;\n   offset = srf_offset + 2;\n   tag_offset = offset;\n \n   while (entries--) {\n     if (tiff_sget (save, srf_buf, len,\n                    &tag_offset, &tag_id, &tag_type, &tag_dataoffset,\n                    &tag_datalen, &tag_dataunitlen) == 0) {\n       if (tag_id == 0x0000) {\n// bug_start\n        SRF2Key = sget4(srf_buf + tag_dataoffset);\n// bug_end\n       } else if (tag_id == 0x0001) {\n// bug_start\n        RawDataKey = sget4(srf_buf + tag_dataoffset);\n// bug_end\n       }\n     } else goto restore_after_parseSonySRF;\n   }\n   offset = tag_offset;\n \n   CHECKBUFFER_SGET4(offset);\n   srf_offset =\n       sget4(srf_buf + offset) - save;\n   if (srf_offset < 0 || decrypt_len < srf_offset / 4)\n     goto restore_after_parseSonySRF;\n   sony_decrypt((unsigned *)(srf_buf + srf_offset), decrypt_len - srf_offset / 4,\n                1, SRF2Key);\n   CHECKBUFFER_SGET2(srf_offset);\n   entries = sget2(srf_buf + srf_offset);\n   if (entries > 1000)\n     goto restore_after_parseSonySRF;\n   offset = srf_offset + 2;\n   tag_offset = offset;\n \n   while (entries--) {\n// bug_start\n    if (tiff_sget (save, srf_buf, len,\n// bug_end\n                    &tag_offset, &tag_id, &tag_type, &tag_dataoffset,\n                    &tag_datalen, &tag_dataunitlen) == 0) {\n       if ((tag_id >= 0x00c0) && (tag_id <= 0x00ce)) {\n         i = (tag_id - 0x00c0) % 3;\n         nWB = (tag_id - 0x00c0) / 3;\n// bug_start\n        icWBC[Sony_SRF_wb_list[nWB]][i] = sget4(srf_buf + tag_dataoffset);\n// bug_end\n         if (i == 1) {\n           icWBC[Sony_SRF_wb_list[nWB]][3] =\n             icWBC[Sony_SRF_wb_list[nWB]][i];\n         }\n       } else if ((tag_id >= 0x00d0) && (tag_id <= 0x00d2)) {\n         i = (tag_id - 0x00d0) % 3;\n// bug_start\n        cam_mul[i] = sget4(srf_buf + tag_dataoffset);\n// bug_end\n         if (i == 1) {\n           cam_mul[3] = cam_mul[i];\n         }\n       } else switch (tag_id) {\n       case 0x0043:\n// bug_start\n        ilm.MaxAp4MaxFocal = sgetreal(tag_type, srf_buf + tag_dataoffset);\n// bug_end\n         break;\n       case 0x0044:\n// bug_start\n         ilm.MaxAp4MinFocal = sgetreal(tag_type, srf_buf + tag_dataoffset);\n// bug_end\n         break;\n       case 0x0045:\n// bug_start\n        ilm.MinFocal = sgetreal(tag_type, srf_buf + tag_dataoffset);\n// bug_end\n         break;\n       case 0x0046:\n// bug_start\n        ilm.MaxFocal = sgetreal(tag_type, srf_buf + tag_dataoffset);\n// bug_end\n         break;\n       }\n     } else goto restore_after_parseSonySRF;\n   }\n   offset = tag_offset;\n \n restore_after_parseSonySRF:\n   free(srf_buf);\n   fseek(ifp, save, SEEK_SET);\n #undef CHECKBUFFER_SGET4\n #undef CHECKBUFFER_SGET2\n }\n \n", "target": "// fix_start\n  ushort entries;\n// fix_end\n// fix_start\n  srf_buf = (uchar *)malloc(len+64);\n// fix_end\n// fix_start\n\t\t  CHECKBUFFER_SGET4(tag_dataoffset);\n\t\t  SRF2Key = sget4(srf_buf + tag_dataoffset);\n// fix_end\n// fix_start\n\t\t  CHECKBUFFER_SGET4(tag_dataoffset);\n\t\t  RawDataKey = sget4(srf_buf + tag_dataoffset);\n// fix_end\n// fix_start\n\t  if (tiff_sget(save, srf_buf, len,\n// fix_end\n// fix_start\n\t\tCHECKBUFFER_SGET4(tag_dataoffset);\n\t\ticWBC[Sony_SRF_wb_list[nWB]][i] = sget4(srf_buf + tag_dataoffset);\n// fix_end\n// fix_start\n\t\tCHECKBUFFER_SGET4(tag_dataoffset);\n\t\tcam_mul[i] = sget4(srf_buf + tag_dataoffset);\n// fix_end\n// fix_start\n\t\t  CHECKBUFFER_SGET4(tag_dataoffset);\n\t\t  ilm.MaxAp4MaxFocal = sgetreal(tag_type, srf_buf + tag_dataoffset);\n// fix_end\n// fix_start\n\t\t  CHECKBUFFER_SGET4(tag_dataoffset);\n\t\t  ilm.MaxAp4MinFocal = sgetreal(tag_type, srf_buf + tag_dataoffset);\n// fix_end\n// fix_start\n\t\t  CHECKBUFFER_SGET4(tag_dataoffset);\n\t\t  ilm.MinFocal = sgetreal(tag_type, srf_buf + tag_dataoffset);\n// fix_end\n// fix_start\n\t\t  CHECKBUFFER_SGET4(tag_dataoffset);\n\t\t  ilm.MaxFocal = sgetreal(tag_type, srf_buf + tag_dataoffset);\n// fix_end\n", "cwe": "CWE-125", "cwe_name": "Out-of-bounds Read", "cve": "CVE-2020-35535", "cve_desc": "In LibRaw, there is an out-of-bounds read vulnerability within the \"LibRaw::parseSonySRF()\" function (libraw\\src\\metadata\\sony.cpp) when processing srf files.", "project": "LibRaw", "idx": 207218}
{"source": " ctnetlink_parse_tuple_filter(const struct nlattr * const cda[],\n \t\t\t      struct nf_conntrack_tuple *tuple, u32 type,\n \t\t\t      u_int8_t l3num, struct nf_conntrack_zone *zone,\n \t\t\t      u_int32_t flags)\n {\n \tstruct nlattr *tb[CTA_TUPLE_MAX+1];\n \tint err;\n \n \tmemset(tuple, 0, sizeof(*tuple));\n \n \terr = nla_parse_nested_deprecated(tb, CTA_TUPLE_MAX, cda[type],\n \t\t\t\t\t  tuple_nla_policy, NULL);\n \tif (err < 0)\n \t\treturn err;\n \n// bug_start\n\n// bug_end\n \ttuple->src.l3num = l3num;\n \n \tif (flags & CTA_FILTER_FLAG(CTA_IP_DST) ||\n \t    flags & CTA_FILTER_FLAG(CTA_IP_SRC)) {\n \t\tif (!tb[CTA_TUPLE_IP])\n \t\t\treturn -EINVAL;\n \n \t\terr = ctnetlink_parse_tuple_ip(tb[CTA_TUPLE_IP], tuple, flags);\n \t\tif (err < 0)\n \t\t\treturn err;\n \t}\n \n \tif (flags & CTA_FILTER_FLAG(CTA_PROTO_NUM)) {\n \t\tif (!tb[CTA_TUPLE_PROTO])\n \t\t\treturn -EINVAL;\n \n \t\terr = ctnetlink_parse_tuple_proto(tb[CTA_TUPLE_PROTO], tuple, flags);\n \t\tif (err < 0)\n \t\t\treturn err;\n \t} else if (flags & CTA_FILTER_FLAG(ALL_CTA_PROTO)) {\n \t\treturn -EINVAL;\n \t}\n \n \tif ((flags & CTA_FILTER_FLAG(CTA_TUPLE_ZONE)) && tb[CTA_TUPLE_ZONE]) {\n \t\tif (!zone)\n \t\t\treturn -EINVAL;\n \n \t\terr = ctnetlink_parse_tuple_zone(tb[CTA_TUPLE_ZONE],\n \t\t\t\t\t\t type, zone);\n \t\tif (err < 0)\n \t\t\treturn err;\n \t}\n \n \tif (type == CTA_TUPLE_REPLY)\n \t\ttuple->dst.dir = IP_CT_DIR_REPLY;\n \telse\n \t\ttuple->dst.dir = IP_CT_DIR_ORIGINAL;\n \n \treturn 0;\n }\n \n", "target": "// fix_start\n\tif (l3num != NFPROTO_IPV4 && l3num != NFPROTO_IPV6)\n\t\treturn -EOPNOTSUPP;\n// fix_end\n", "cwe": "CWE-120", "cwe_name": "Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')", "cve": "CVE-2020-25211", "cve_desc": "In the Linux kernel through 5.8.7, local attackers able to inject conntrack netlink configuration could overflow a local buffer, causing crashes or triggering use of incorrect protocol numbers in ctnetlink_parse_tuple_filter in net/netfilter/nf_conntrack_netlink.c, aka CID-1cc5ef91d2ff.", "project": "linux", "idx": 207223}
{"source": "// bug_start\nLJ_NOINLINE void lj_err_run(lua_State *L)\n// bug_end\n {\n   ptrdiff_t ef = finderrfunc(L);\n   if (ef) {\n     TValue *errfunc = restorestack(L, ef);\n     TValue *top = L->top;\n     lj_trace_abort(G(L));\n     if (!tvisfunc(errfunc) || L->status == LUA_ERRERR) {\n       setstrV(L, top-1, lj_err_str(L, LJ_ERR_ERRERR));\n       lj_err_throw(L, LUA_ERRERR);\n     }\n     L->status = LUA_ERRERR;\n     copyTV(L, top, top-1);\n     copyTV(L, top-1, errfunc);\n     L->top = top+1;\n     lj_vm_call(L, top, 1+1);\n   }\n   lj_err_throw(L, LUA_ERRRUN);\n }\n \n", "target": "// fix_start\nLJ_NOINLINE void LJ_FASTCALL lj_err_run(lua_State *L)\n// fix_end\n", "cwe": "CWE-125", "cwe_name": "Out-of-bounds Read", "cve": "CVE-2020-24372", "cve_desc": "LuaJIT through 2.1.0-beta3 has an out-of-bounds read in lj_err_run in lj_err.c.", "project": "LuaJIT", "idx": 207262}
{"source": " void LibRaw::parse_exif(int base)\n {\n   unsigned entries, tag, type, len, save, c;\n   double expo, ape;\n \n   unsigned kodak = !strncmp(make, \"EASTMAN\", 7) && tiff_nifds < 3;\n \n   entries = get2();\n   if (!strncmp(make, \"Hasselblad\", 10) && (tiff_nifds > 3) && (entries > 512))\n     return;\n   INT64 fsize = ifp->size();\n   while (entries--)\n   {\n     tiff_get(base, &tag, &type, &len, &save);\n \n     INT64 savepos = ftell(ifp);\n     if (len > 8 && savepos + len > fsize * 2)\n     {\n       fseek(ifp, save, SEEK_SET);\n       continue;\n     }\n     if (callbacks.exif_cb)\n     {\n       callbacks.exif_cb(callbacks.exifparser_data, tag, type, len, order, ifp,\n                         base);\n       fseek(ifp, savepos, SEEK_SET);\n     }\n \n     switch (tag)\n     {\n \tcase 0xA005:\n \t\tfseek(ifp, get4() + base, SEEK_SET);\n \t\tparse_exif_interop(base);\n \t\tbreak;\n \tcase 0xA001:\n \t\tc = get2();\n \t\tif (c == 1 && imgdata.color.ExifColorSpace == LIBRAW_COLORSPACE_Unknown)\n \t\t\timgdata.color.ExifColorSpace = LIBRAW_COLORSPACE_sRGB;\n \t\telse if (c == 2)\n \t\t\timgdata.color.ExifColorSpace = LIBRAW_COLORSPACE_AdobeRGB;\n \t\tbreak;\n     case 0x9400:\n       imCommon.exifAmbientTemperature = getreal(type);\n       if ((imCommon.CameraTemperature > -273.15f) &&\n           ((OlyID == OlyID_TG_5) ||\n            (OlyID == OlyID_TG_6))\n       )\n         imCommon.CameraTemperature += imCommon.exifAmbientTemperature;\n       break;\n     case 0x9401:\n       imCommon.exifHumidity = getreal(type);\n       break;\n     case 0x9402:\n       imCommon.exifPressure = getreal(type);\n       break;\n     case 0x9403:\n       imCommon.exifWaterDepth = getreal(type);\n       break;\n     case 0x9404:\n       imCommon.exifAcceleration = getreal(type);\n       break;\n     case 0x9405:\n       imCommon.exifCameraElevationAngle = getreal(type);\n       break;\n \n     case 0xa405:\n       imgdata.lens.FocalLengthIn35mmFormat = get2();\n       break;\n     case 0xa431:\n       stmread(imgdata.shootinginfo.BodySerial, len, ifp);\n       break;\n     case 0xa432:\n       imgdata.lens.MinFocal = getreal(type);\n       imgdata.lens.MaxFocal = getreal(type);\n       imgdata.lens.MaxAp4MinFocal = getreal(type);\n       imgdata.lens.MaxAp4MaxFocal = getreal(type);\n       break;\n     case 0xa435:\n       stmread(imgdata.lens.LensSerial, len, ifp);\n       if (!strncmp(imgdata.lens.LensSerial, \"----\", 4))\n         imgdata.lens.LensSerial[0] = '\\0';\n       break;\n     case 0xa420:\n       stmread(imgdata.color.ImageUniqueID, len, ifp);\n       break;\n     case 0xc65d:\n       imgdata.color.RawDataUniqueID[16] = 0;\n       fread(imgdata.color.RawDataUniqueID, 1, 16, ifp);\n       break;\n     case 0xc630:\n       imgdata.lens.dng.MinFocal = getreal(type);\n       imgdata.lens.dng.MaxFocal = getreal(type);\n       imgdata.lens.dng.MaxAp4MinFocal = getreal(type);\n       imgdata.lens.dng.MaxAp4MaxFocal = getreal(type);\n       break;\n     case 0xc68b:\n       stmread(imgdata.color.OriginalRawFileName, len, ifp);\n       break;\n     case 0xa433:\n       stmread(imgdata.lens.LensMake, len, ifp);\n       break;\n     case 0xa434:\n       stmread(imgdata.lens.Lens, len, ifp);\n       if (!strncmp(imgdata.lens.Lens, \"----\", 4))\n         imgdata.lens.Lens[0] = '\\0';\n       break;\n     case 0x9205:\n       imgdata.lens.EXIF_MaxAp = libraw_powf64l(2.0f, (getreal(type) / 2.0f));\n       break;\n     case 0x829a:\n// bug_start\n      tiff_ifd[tiff_nifds - 1].t_shutter = shutter = getreal(type);\n// bug_end\n       break;\n     case 0x829d:\n       aperture = getreal(type);\n       break;\n     case 0x8827:\n       iso_speed = get2();\n       break;\n     case 0x8831:\n       if (iso_speed == 0xffff && !strncasecmp(make, \"FUJI\", 4))\n         iso_speed = getreal(type);\n       break;\n     case 0x8832:\n       if (iso_speed == 0xffff &&\n           (!strncasecmp(make, \"SONY\", 4) || !strncasecmp(make, \"CANON\", 5)))\n         iso_speed = getreal(type);\n       break;\n     case 0x9003:\n     case 0x9004:\n       get_timestamp(0);\n       break;\n     case 0x9201:\n// bug_start\n      if ((expo = -getreal(type)) < 128 && shutter == 0.)\n        tiff_ifd[tiff_nifds - 1].t_shutter = shutter =\n            libraw_powf64l(2.0, expo);\n// bug_end\n       break;\n     case 0x9202:\n       if ((fabs(ape = getreal(type)) < 256.0) && (!aperture))\n         aperture = libraw_powf64l(2.0, ape / 2);\n       break;\n     case 0x9209:\n       flash_used = getreal(type);\n       break;\n     case 0x920a:\n       focal_len = getreal(type);\n       break;\n     case 0x927c:\n       if (((make[0] == '\\0') && !strncmp(model, \"ov5647\", 6)) ||\n           (!strncmp(make, \"RaspberryPi\", 11) &&\n            (!strncmp(model, \"RP_OV5647\", 9) ||\n             !strncmp(model, \"RP_imx219\", 9))))\n       {\n         char mn_text[512];\n         char *pos;\n         char ccms[512];\n         ushort l;\n         float num;\n \n         fgets(mn_text, MIN(len, 511), ifp);\n         mn_text[511] = 0;\n \n         pos = strstr(mn_text, \"gain_r=\");\n         if (pos)\n           cam_mul[0] = atof(pos + 7);\n         pos = strstr(mn_text, \"gain_b=\");\n         if (pos)\n           cam_mul[2] = atof(pos + 7);\n         if ((cam_mul[0] > 0.001f) && (cam_mul[2] > 0.001f))\n           cam_mul[1] = cam_mul[3] = 1.0f;\n         else\n           cam_mul[0] = cam_mul[2] = 0.0f;\n \n         pos = strstr(mn_text, \"ccm=\");\n         if (pos)\n         {\n           pos += 4;\n           char *pos2 = strstr(pos, \" \");\n           if (pos2)\n           {\n             l = pos2 - pos;\n             memcpy(ccms, pos, l);\n             ccms[l] = '\\0';\n #ifdef LIBRAW_WIN32_CALLS\n             pos = strtok(ccms, \",\");\n #else\n             char *last = 0;\n             pos = strtok_r(ccms, \",\", &last);\n #endif\n             if (pos)\n             {\n               for (l = 0; l < 4; l++)\n               {\n                 num = 0.0;\n                 for (c = 0; c < 3; c++)\n                 {\n                   imgdata.color.ccm[l][c] = (float)atoi(pos);\n                   num += imgdata.color.ccm[l][c];\n #ifdef LIBRAW_WIN32_CALLS\n                   pos = strtok(NULL, \",\");\n #else\n                   pos = strtok_r(NULL, \",\", &last);\n #endif\n                   if (!pos)\n                     goto end;\n                 }\n                 if (num > 0.01)\n                   FORC3 imgdata.color.ccm[l][c] = imgdata.color.ccm[l][c] / num;\n               }\n             }\n           }\n         }\n       end:;\n       }\n       else if (!strncmp(make, \"SONY\", 4) &&\n                (!strncmp(model, \"DSC-V3\", 6) || !strncmp(model, \"DSC-F828\", 8)))\n       {\n         parseSonySRF(len);\n         break;\n       }\n       else if ((len == 1) && !strncmp(make, \"NIKON\", 5))\n       {\n         c = get4();\n         if (c)\n           fseek(ifp, c, SEEK_SET);\n         is_NikonTransfer = 1;\n       }\n       parse_makernote(base, 0);\n       break;\n     case 0xa002:\n       if (kodak)\n         raw_width = get4();\n       break;\n     case 0xa003:\n       if (kodak)\n         raw_height = get4();\n       break;\n     case 0xa302:\n       if (get4() == 0x20002)\n         for (exif_cfa = c = 0; c < 8; c += 2)\n           exif_cfa |= fgetc(ifp) * 0x01010101U << c;\n     }\n     fseek(ifp, save, SEEK_SET);\n   }\n }\n \n", "target": "// fix_start\n      shutter = getreal(type);\n      if (tiff_nifds > 0 && tiff_nifds <= LIBRAW_IFD_MAXCOUNT)\n          tiff_ifd[tiff_nifds - 1].t_shutter = shutter;\n// fix_end\n// fix_start\n       if ((expo = -getreal(type)) < 128 && shutter == 0.)\n       {\n            shutter = libraw_powf64l(2.0, expo);\n            if (tiff_nifds > 0 && tiff_nifds <= LIBRAW_IFD_MAXCOUNT)\n              tiff_ifd[tiff_nifds - 1].t_shutter = shutter;\n       }\n// fix_end\n", "cwe": "CWE-787", "cwe_name": "Out-of-bounds Write", "cve": "CVE-2020-15365", "cve_desc": "LibRaw before 0.20-Beta3 has an out-of-bounds write in parse_exif() in metadata\\exif_gps.cpp via an unrecognized AtomName and a zero value of tiff_nifds.", "project": "LibRaw", "idx": 207309}
{"source": " static Image *ReadDPSImage(const ImageInfo *image_info,ExceptionInfo *exception)\n {\n   const char\n     *client_name;\n \n   Display\n     *display;\n \n   float\n     pixels_per_point;\n \n   Image\n     *image;\n \n   int\n     sans,\n     status;\n \n   Pixmap\n     pixmap;\n \n   register IndexPacket\n     *indexes;\n \n   register ssize_t\n     i;\n \n   register PixelPacket\n     *q;\n \n   register size_t\n     pixel;\n \n   Screen\n     *screen;\n \n   ssize_t\n     x,\n     y;\n \n   XColor\n     *colors;\n \n   XImage\n     *dps_image;\n \n   XRectangle\n     page,\n     bits_per_pixel;\n \n   XResourceInfo\n     resource_info;\n \n   XrmDatabase\n     resource_database;\n \n   XStandardColormap\n     *map_info;\n \n   XVisualInfo\n     *visual_info;\n \n   assert(image_info != (const ImageInfo *) NULL);\n   assert(image_info->signature == MagickCoreSignature);\n   if (image_info->debug != MagickFalse)\n     (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n       image_info->filename);\n   assert(exception != (ExceptionInfo *) NULL);\n   assert(exception->signature == MagickCoreSignature);\n   display=XOpenDisplay(image_info->server_name);\n   if (display == (Display *) NULL)\n     return((Image *) NULL);\n   (void) XSetErrorHandler(XError);\n   image=AcquireImage(image_info);\n   status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n   if (status == MagickFalse)\n// bug_start\n    return((Image *) NULL);\n// bug_end\n   client_name=GetClientName();\n   resource_database=XGetResourceDatabase(display,client_name);\n   XGetResourceInfo(image_info,resource_database,client_name,&resource_info);\n   map_info=XAllocStandardColormap();\n   visual_info=(XVisualInfo *) NULL;\n   if (map_info == (XStandardColormap *) NULL)\n     ThrowReaderException(ResourceLimitError,\"UnableToCreateStandardColormap\")\n   else\n     {\n       (void) CloneString(&resource_info.visual_type,\"default\");\n       visual_info=XBestVisualInfo(display,map_info,&resource_info);\n       map_info->colormap=(Colormap) NULL;\n     }\n   if ((map_info == (XStandardColormap *) NULL) ||\n       (visual_info == (XVisualInfo *) NULL))\n     {\n       image=DestroyImage(image);\n       XFreeResources(display,visual_info,map_info,(XPixelInfo *) NULL,\n         (XFontStruct *) NULL,&resource_info,(XWindowInfo *) NULL);\n       return((Image *) NULL);\n     }\n   screen=ScreenOfDisplay(display,visual_info->screen);\n   pixels_per_point=XDPSPixelsPerPoint(screen);\n   if ((image->x_resolution != 0.0) && (image->y_resolution != 0.0))\n     pixels_per_point=MagickMin(image->x_resolution,image->y_resolution)/\n       DefaultResolution;\n   status=XDPSCreatePixmapForEPSF((DPSContext) NULL,screen,\n     GetBlobFileHandle(image),visual_info->depth,pixels_per_point,&pixmap,\n     &bits_per_pixel,&page);\n   if ((status == dps_status_failure) || (status == dps_status_no_extension))\n     {\n       image=DestroyImage(image);\n       XFreeResources(display,visual_info,map_info,(XPixelInfo *) NULL,\n         (XFontStruct *) NULL,&resource_info,(XWindowInfo *) NULL);\n       return((Image *) NULL);\n     }\n   status=XDPSImageFileIntoDrawable((DPSContext) NULL,screen,pixmap,\n     GetBlobFileHandle(image),(int) bits_per_pixel.height,visual_info->depth,\n     &page,-page.x,-page.y,pixels_per_point,MagickTrue,MagickFalse,MagickTrue,\n     &sans);\n   if (status != dps_status_success)\n     {\n       image=DestroyImage(image);\n       XFreeResources(display,visual_info,map_info,(XPixelInfo *) NULL,\n         (XFontStruct *) NULL,&resource_info,(XWindowInfo *) NULL);\n       return((Image *) NULL);\n     }\n   dps_image=XGetImage(display,pixmap,0,0,bits_per_pixel.width,\n     bits_per_pixel.height,AllPlanes,ZPixmap);\n   (void) XFreePixmap(display,pixmap);\n   if (dps_image == (XImage *) NULL)\n     {\n       image=DestroyImage(image);\n       XFreeResources(display,visual_info,map_info,(XPixelInfo *) NULL,\n         (XFontStruct *) NULL,&resource_info,(XWindowInfo *) NULL);\n       return((Image *) NULL);\n     }\n   colors=(XColor *) AcquireQuantumMemory(visual_info->colormap_size,\n     sizeof(*colors));\n   if (colors == (XColor *) NULL)\n     {\n       image=DestroyImage(image);\n       XDestroyImage(dps_image);\n       XFreeResources(display,visual_info,map_info,(XPixelInfo *) NULL,\n         (XFontStruct *) NULL,&resource_info,(XWindowInfo *) NULL);\n       return((Image *) NULL);\n     }\n   if ((visual_info->klass != DirectColor) && (visual_info->klass != TrueColor))\n     for (i=0; i < visual_info->colormap_size; i++)\n     {\n       colors[i].pixel=(size_t) i;\n       colors[i].pad=0;\n     }\n   else\n     {\n       size_t\n         blue,\n         blue_bit,\n         green,\n         green_bit,\n         red,\n         red_bit;\n \n       red=0;\n       green=0;\n       blue=0;\n       red_bit=visual_info->red_mask & (~(visual_info->red_mask)+1);\n       green_bit=visual_info->green_mask & (~(visual_info->green_mask)+1);\n       blue_bit=visual_info->blue_mask & (~(visual_info->blue_mask)+1);\n       for (i=0; i < visual_info->colormap_size; i++)\n       {\n         colors[i].pixel=red | green | blue;\n         colors[i].pad=0;\n         red+=red_bit;\n         if (red > visual_info->red_mask)\n           red=0;\n         green+=green_bit;\n         if (green > visual_info->green_mask)\n           green=0;\n         blue+=blue_bit;\n         if (blue > visual_info->blue_mask)\n           blue=0;\n       }\n     }\n   (void) XQueryColors(display,XDefaultColormap(display,visual_info->screen),\n     colors,visual_info->colormap_size);\n   if ((visual_info->klass != TrueColor) && (visual_info->klass != DirectColor))\n     image->storage_class=PseudoClass;\n   image->columns=(size_t) dps_image->width;\n   image->rows=(size_t) dps_image->height;\n   if (image_info->ping != MagickFalse)\n     {\n       (void) CloseBlob(image);\n       colors=(XColor *) RelinquishMagickMemory(colors);\n       XDestroyImage(dps_image);\n       XFreeResources(display,visual_info,map_info,(XPixelInfo *) NULL,\n         (XFontStruct *) NULL,&resource_info,(XWindowInfo *) NULL);\n       return(GetFirstImageInList(image));\n     }\n   status=SetImageExtent(image,image->columns,image->rows);\n   if (status == MagickFalse)\n     {\n       colors=(XColor *) RelinquishMagickMemory(colors);\n       XDestroyImage(dps_image);\n       XFreeResources(display,visual_info,map_info,(XPixelInfo *) NULL,\n         (XFontStruct *) NULL,&resource_info,(XWindowInfo *) NULL);\n       InheritException(exception,&image->exception);\n       return(DestroyImageList(image));\n     }\n   switch (image->storage_class)\n   {\n     case DirectClass:\n     default:\n     {\n       register size_t\n         color,\n         index;\n \n       size_t\n         blue_mask,\n         blue_shift,\n         green_mask,\n         green_shift,\n         red_mask,\n         red_shift;\n \n       red_mask=visual_info->red_mask;\n       red_shift=0;\n       while ((red_mask != 0) && ((red_mask & 0x01) == 0))\n       {\n         red_mask>>=1;\n         red_shift++;\n       }\n       green_mask=visual_info->green_mask;\n       green_shift=0;\n       while ((green_mask != 0) && ((green_mask & 0x01) == 0))\n       {\n         green_mask>>=1;\n         green_shift++;\n       }\n       blue_mask=visual_info->blue_mask;\n       blue_shift=0;\n       while ((blue_mask != 0) && ((blue_mask & 0x01) == 0))\n       {\n         blue_mask>>=1;\n         blue_shift++;\n       }\n       if ((visual_info->colormap_size > 0) &&\n           (visual_info->klass == DirectColor))\n         for (y=0; y < (ssize_t) image->rows; y++)\n         {\n           q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n           if (q == (PixelPacket *) NULL)\n             break;\n           for (x=0; x < (ssize_t) image->columns; x++)\n           {\n             pixel=XGetPixel(dps_image,x,y);\n             index=(pixel >> red_shift) & red_mask;\n             SetPixelRed(q,ScaleShortToQuantum(colors[index].red));\n             index=(pixel >> green_shift) & green_mask;\n             SetPixelGreen(q,ScaleShortToQuantum(colors[index].green));\n             index=(pixel >> blue_shift) & blue_mask;\n             SetPixelBlue(q,ScaleShortToQuantum(colors[index].blue));\n             q++;\n           }\n           if (SyncAuthenticPixels(image,exception) == MagickFalse)\n             break;\n           if (SetImageProgress(image,LoadImageTag,y,image->rows) == MagickFalse)\n             break;\n         }\n       else\n         for (y=0; y < (ssize_t) image->rows; y++)\n         {\n           q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n           if (q == (PixelPacket *) NULL)\n             break;\n           for (x=0; x < (ssize_t) image->columns; x++)\n           {\n             pixel=XGetPixel(dps_image,x,y);\n             color=(pixel >> red_shift) & red_mask;\n             color=(color*65535L)/red_mask;\n             SetPixelRed(q,ScaleShortToQuantum((unsigned short) color));\n             color=(pixel >> green_shift) & green_mask;\n             color=(color*65535L)/green_mask;\n             SetPixelGreen(q,ScaleShortToQuantum((unsigned short)\n               color));\n             color=(pixel >> blue_shift) & blue_mask;\n             color=(color*65535L)/blue_mask;\n             SetPixelBlue(q,ScaleShortToQuantum((unsigned short)\n               color));\n             q++;\n           }\n           if (SyncAuthenticPixels(image,exception) == MagickFalse)\n             break;\n           if (SetImageProgress(image,LoadImageTag,y,image->rows) == MagickFalse)\n             break;\n         }\n       break;\n     }\n     case PseudoClass:\n     {\n       if (AcquireImageColormap(image,(size_t) visual_info->colormap_size) == MagickFalse)\n         {\n           image=DestroyImage(image);\n           colors=(XColor *) RelinquishMagickMemory(colors);\n           XDestroyImage(dps_image);\n           XFreeResources(display,visual_info,map_info,(XPixelInfo *) NULL,\n             (XFontStruct *) NULL,&resource_info,(XWindowInfo *) NULL);\n           return((Image *) NULL);\n         }\n       for (i=0; i < (ssize_t) image->colors; i++)\n       {\n         image->colormap[colors[i].pixel].red=ScaleShortToQuantum(colors[i].red);\n         image->colormap[colors[i].pixel].green=\n           ScaleShortToQuantum(colors[i].green);\n         image->colormap[colors[i].pixel].blue=\n           ScaleShortToQuantum(colors[i].blue);\n       }\n       for (y=0; y < (ssize_t) image->rows; y++)\n       {\n         q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n         if (q == (PixelPacket *) NULL)\n           break;\n         indexes=GetAuthenticIndexQueue(image);\n         for (x=0; x < (ssize_t) image->columns; x++)\n           SetPixelIndex(indexes+x,(unsigned short)\n             XGetPixel(dps_image,x,y));\n         if (SyncAuthenticPixels(image,exception) == MagickFalse)\n           break;\n         if (SetImageProgress(image,LoadImageTag,y,image->rows) == MagickFalse)\n           break;\n       }\n       break;\n     }\n   }\n   colors=(XColor *) RelinquishMagickMemory(colors);\n   XDestroyImage(dps_image);\n   if (image->storage_class == PseudoClass)\n     (void) SyncImage(image);\n   status=XDPSCreatePixmapForEPSF((DPSContext) NULL,screen,\n     GetBlobFileHandle(image),1,pixels_per_point,&pixmap,&bits_per_pixel,&page);\n   if ((status != dps_status_failure) && (status != dps_status_no_extension))\n     {\n       status=XDPSImageFileIntoDrawable((DPSContext) NULL,screen,pixmap,\n         GetBlobFileHandle(image),(int) bits_per_pixel.height,1,&page,-page.x,\n         -page.y,pixels_per_point,MagickTrue,MagickTrue,MagickTrue,&sans);\n       if (status == dps_status_success)\n         {\n           XImage\n             *matte_image;\n \n           matte_image=XGetImage(display,pixmap,0,0,bits_per_pixel.width,\n             bits_per_pixel.height,AllPlanes,ZPixmap);\n           (void) XFreePixmap(display,pixmap);\n           if (matte_image != (XImage *) NULL)\n             {\n               image->storage_class=DirectClass;\n               image->matte=MagickTrue;\n               for (y=0; y < (ssize_t) image->rows; y++)\n               {\n                 q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n                 if (q == (PixelPacket *) NULL)\n                   break;\n                 for (x=0; x < (ssize_t) image->columns; x++)\n                 {\n                   SetPixelOpacity(q,OpaqueOpacity);\n                   if (XGetPixel(matte_image,x,y) == 0)\n                     SetPixelOpacity(q,TransparentOpacity);\n                   q++;\n                 }\n                 if (SyncAuthenticPixels(image,exception) == MagickFalse)\n                   break;\n               }\n               XDestroyImage(matte_image);\n             }\n         }\n     }\n   XFreeResources(display,visual_info,map_info,(XPixelInfo *) NULL,\n     (XFontStruct *) NULL,&resource_info,(XWindowInfo *) NULL);\n   (void) CloseBlob(image);\n   return(GetFirstImageInList(image));\n }\n \n", "target": "// fix_start\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n// fix_end\n", "cwe": "CWE-401", "cwe_name": "Missing Release of Memory after Effective Lifetime", "cve": "CVE-2019-16709", "cve_desc": "ImageMagick 7.0.8-35 has a memory leak in coders/dps.c, as demonstrated by XCreateImage.", "project": "ImageMagick6", "idx": 207312}
{"source": " ipmi_get_session_info(struct ipmi_intf         * intf,\n \t\t\t\t\t  Ipmi_Session_Request_Type  session_request_type,\n \t\t\t\t\t  uint32_t                   id_or_handle)\n {\n \tint i, retval = 0;\n \n \tstruct ipmi_rs * rsp;\n \tstruct ipmi_rq req;\n \tuint8_t rqdata[5];\n \tstruct get_session_info_rsp   session_info;\n \n \tmemset(&req, 0, sizeof(req));\n \tmemset(&session_info, 0, sizeof(session_info));\n \treq.msg.netfn = IPMI_NETFN_APP;\n \treq.msg.cmd   = IPMI_GET_SESSION_INFO;\n \treq.msg.data = rqdata;\n \n \tswitch (session_request_type)\n \t{\n \n \tcase IPMI_SESSION_REQUEST_CURRENT:\n \tcase IPMI_SESSION_REQUEST_BY_ID:\n \tcase IPMI_SESSION_REQUEST_BY_HANDLE:\n \t\tswitch (session_request_type)\n \t\t{\n \t\tcase IPMI_SESSION_REQUEST_CURRENT:\n \t\t\trqdata[0]        = 0x00;\n \t\t\treq.msg.data_len = 1;\n \t\t\tbreak;\n \t\tcase IPMI_SESSION_REQUEST_BY_ID:\n \t\t\trqdata[0]        = 0xFF;\n \t\t\trqdata[1]        = id_or_handle         & 0x000000FF;\n \t\t\trqdata[2]        = (id_or_handle >> 8)  & 0x000000FF;\n \t\t\trqdata[3]        = (id_or_handle >> 16) & 0x000000FF;\n \t\t\trqdata[4]        = (id_or_handle >> 24) & 0x000000FF;\n \t\t\treq.msg.data_len = 5;\n \t\t\tbreak;\n \t\tcase IPMI_SESSION_REQUEST_BY_HANDLE:\n \t\t\trqdata[0]        = 0xFE;\n \t\t\trqdata[1]        = (uint8_t)id_or_handle;\n \t\t\treq.msg.data_len = 2;\n \t\t\tbreak;\n \t\tcase IPMI_SESSION_REQUEST_ALL:\n \t\t\tbreak;\n \t\t}\n \n \t\trsp = intf->sendrecv(intf, &req);\n \t\tif (!rsp)\n \t\t{\n \t\t\tlprintf(LOG_ERR, \"Get Session Info command failed\");\n \t\t\tretval = -1;\n \t\t}\n \t\telse if (rsp->ccode)\n \t\t{\n \t\t\tlprintf(LOG_ERR, \"Get Session Info command failed: %s\",\n \t\t\t\tval2str(rsp->ccode, completion_code_vals));\n \t\t\tretval = -1;\n \t\t}\n \n \t\tif (retval < 0)\n \t\t{\n \t\t\tif ((session_request_type == IPMI_SESSION_REQUEST_CURRENT) &&\n \t\t\t    (strncmp(intf->name, \"lan\", 3) != 0))\n \t\t\t\tlprintf(LOG_ERR, \"It is likely that the channel in use \"\n \t\t\t\t\t\"does not support sessions\");\n \t\t}\n \t\telse\n \t\t{\n// bug_start\n\t\t\tmemcpy(&session_info,  rsp->data, rsp->data_len);\n\t\t\tprint_session_info(&session_info, rsp->data_len);\n// bug_end\n \t\t}\n \t\tbreak;\n \n \tcase IPMI_SESSION_REQUEST_ALL:\n \t\treq.msg.data_len = 1;\n \t\ti = 1;\n \t\tdo\n \t\t{\n \t\t\trqdata[0] = i++;\n \t\t\trsp = intf->sendrecv(intf, &req);\n \n \t\t\tif (!rsp)\n \t\t\t{\n \t\t\t\tlprintf(LOG_ERR, \"Get Session Info command failed\");\n \t\t\t\tretval = -1;\n \t\t\t\tbreak;\n \t\t\t}\n \t\t\telse if (rsp->ccode && rsp->ccode != 0xCC && rsp->ccode != 0xCB)\n \t\t\t{\n \t\t\t\tlprintf(LOG_ERR, \"Get Session Info command failed: %s\",\n \t\t\t\t\tval2str(rsp->ccode, completion_code_vals));\n \t\t\t\tretval = -1;\n \t\t\t\tbreak;\n \t\t\t}\n \t\t\telse if (rsp->data_len < 3)\n \t\t\t{\n \t\t\t\tretval = -1;\n \t\t\t\tbreak;\n \t\t\t}\n \n// bug_start\n\t\t\tmemcpy(&session_info,  rsp->data, rsp->data_len);\n\t\t\tprint_session_info(&session_info, rsp->data_len);\n// bug_end\n \n \t\t} while (i <= session_info.session_slot_count);\n \t\tbreak;\n \t}\n \n \treturn retval;\n }\n \n", "target": "// fix_start\n\t\t\tmemcpy(&session_info,  rsp->data,\n\t\t\t       __min(rsp->data_len, sizeof(session_info)));\n\t\t\tprint_session_info(&session_info,\n\t\t\t                   __min(rsp->data_len, sizeof(session_info)));\n// fix_end\n// fix_start\n\t\t\tmemcpy(&session_info,  rsp->data,\n\t\t\t       __min(rsp->data_len, sizeof(session_info)));\n\t\t\tprint_session_info(&session_info,\n\t\t\t                   __min(rsp->data_len, sizeof(session_info)));\n// fix_end\n", "cwe": "CWE-120", "cwe_name": "Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')", "cve": "CVE-2020-5208", "cve_desc": "It's been found that multiple functions in ipmitool before 1.8.19 neglect proper checking of the data received from a remote LAN party, which may lead to buffer overflows and potentially to remote code execution on the ipmitool side. This is especially dangerous if ipmitool is run as a privileged user. This problem is fixed in version 1.8.19.", "project": "ipmitool", "idx": 207463}
{"source": " static void sctp_destroy_sock(struct sock *sk)\n {\n \tstruct sctp_sock *sp;\n \n \tpr_debug(\"%s: sk:%p\\n\", __func__, sk);\n \n \tsp = sctp_sk(sk);\n \tif (sp->ep == NULL)\n \t\treturn;\n \n \tif (sp->do_auto_asconf) {\n \t\tsp->do_auto_asconf = 0;\n// bug_start\n// bug_end\n \t\tlist_del(&sp->auto_asconf_list);\n// bug_start\n// bug_end\n \t}\n \tsctp_endpoint_free(sp->ep);\n \tlocal_bh_disable();\n \tsk_sockets_allocated_dec(sk);\n \tsock_prot_inuse_add(sock_net(sk), sk->sk_prot, -1);\n \tlocal_bh_enable();\n }\n \n", "target": "// fix_start\n\t\tspin_lock_bh(&sock_net(sk)->sctp.addr_wq_lock);\n// fix_end\n// fix_start\n\t\tspin_unlock_bh(&sock_net(sk)->sctp.addr_wq_lock);\n// fix_end\n", "cwe": "CWE-362", "cwe_name": "Concurrent Execution using Shared Resource with Improper Synchronization ('Race Condition')", "cve": "CVE-2021-23133", "cve_desc": "A race condition in Linux kernel SCTP sockets (net/sctp/socket.c) before 5.12-rc8 can lead to kernel privilege escalation from the context of a network service or an unprivileged process. If sctp_destroy_sock is called without sock_net(sk)->sctp.addr_wq_lock then an element is removed from the auto_asconf_splist list without any proper locking. This can be exploited by an attacker with network service privileges to escalate to root or from the context of an unprivileged user directly if a BPF_CGROUP_INET_SOCK_CREATE is attached which denies creation of some SCTP socket.", "project": "linux", "idx": 207478}
{"source": " static void mcba_usb_disconnect(struct usb_interface *intf)\n {\n \tstruct mcba_priv *priv = usb_get_intfdata(intf);\n \n \tusb_set_intfdata(intf, NULL);\n \n \tnetdev_info(priv->netdev, \"device disconnected\\n\");\n \n \tunregister_candev(priv->netdev);\n// bug_start\n// bug_end\n \tfree_candev(priv->netdev);\n// bug_start\n\n\tmcba_urb_unlink(priv);\n// bug_end\n }\n \n", "target": "// fix_start\n\tmcba_urb_unlink(priv);\n// fix_end\n// fix_start\n// fix_end\n", "cwe": "CWE-416", "cwe_name": "Use After Free", "cve": "CVE-2019-19529", "cve_desc": "In the Linux kernel before 5.3.11, there is a use-after-free bug that can be caused by a malicious USB device in the drivers/net/can/usb/mcba_usb.c driver, aka CID-4d6636498c41.", "project": "linux", "idx": 207488}
{"source": " BOOL license_read_new_or_upgrade_license_packet(rdpLicense* license, wStream* s)\n {\n \tUINT32 os_major;\n \tUINT32 os_minor;\n \tUINT32 cbScope, cbCompanyName, cbProductId, cbLicenseInfo;\n \twStream* licenseStream = NULL;\n \tBOOL ret = FALSE;\n \tBYTE computedMac[16];\n \tLICENSE_BLOB* calBlob;\n \n \tDEBUG_LICENSE(\"Receiving Server New/Upgrade License Packet\");\n \n \tcalBlob = license_new_binary_blob(BB_DATA_BLOB);\n \tif (!calBlob)\n \t\treturn FALSE;\n \n \tif (!license_read_encrypted_blob(license, s, calBlob))\n \t\tgoto out_free_blob;\n \n \tif (Stream_GetRemainingLength(s) < 16)\n \t\tgoto out_free_blob;\n \n \tif (!security_mac_data(license->MacSaltKey, calBlob->data, calBlob->length, computedMac))\n \t\tgoto out_free_blob;\n \n \tif (memcmp(computedMac, Stream_Pointer(s), sizeof(computedMac)) != 0)\n \t{\n \t\tWLog_ERR(TAG, \"new or upgrade license MAC mismatch\");\n \t\tgoto out_free_blob;\n \t}\n \n \tif (!Stream_SafeSeek(s, 16))\n \t\tgoto out_free_blob;\n \n \tlicenseStream = Stream_New(calBlob->data, calBlob->length);\n \tif (!licenseStream)\n \t\tgoto out_free_blob;\n \n// bug_start\n// bug_end\n \tStream_Read_UINT16(licenseStream, os_minor);\n \tStream_Read_UINT16(licenseStream, os_major);\n \n \tStream_Read_UINT32(licenseStream, cbScope);\n \tif (Stream_GetRemainingLength(licenseStream) < cbScope)\n \t\tgoto out_free_stream;\n #ifdef WITH_DEBUG_LICENSE\n \tWLog_DBG(TAG, \"Scope:\");\n \twinpr_HexDump(TAG, WLOG_DEBUG, Stream_Pointer(licenseStream), cbScope);\n #endif\n \tStream_Seek(licenseStream, cbScope);\n \n// bug_start\n// bug_end\n \tStream_Read_UINT32(licenseStream, cbCompanyName);\n \tif (Stream_GetRemainingLength(licenseStream) < cbCompanyName)\n \t\tgoto out_free_stream;\n #ifdef WITH_DEBUG_LICENSE\n \tWLog_DBG(TAG, \"Company name:\");\n \twinpr_HexDump(TAG, WLOG_DEBUG, Stream_Pointer(licenseStream), cbCompanyName);\n #endif\n \tStream_Seek(licenseStream, cbCompanyName);\n \n// bug_start\n// bug_end\n \tStream_Read_UINT32(licenseStream, cbProductId);\n \tif (Stream_GetRemainingLength(licenseStream) < cbProductId)\n \t\tgoto out_free_stream;\n #ifdef WITH_DEBUG_LICENSE\n \tWLog_DBG(TAG, \"Product id:\");\n \twinpr_HexDump(TAG, WLOG_DEBUG, Stream_Pointer(licenseStream), cbProductId);\n #endif\n \tStream_Seek(licenseStream, cbProductId);\n \n// bug_start\n// bug_end\n \tStream_Read_UINT32(licenseStream, cbLicenseInfo);\n \tif (Stream_GetRemainingLength(licenseStream) < cbLicenseInfo)\n \t\tgoto out_free_stream;\n \n \tlicense->state = LICENSE_STATE_COMPLETED;\n \n \tret = TRUE;\n \tif (!license->rdp->settings->OldLicenseBehaviour)\n \t\tret = saveCal(license->rdp->settings, Stream_Pointer(licenseStream), cbLicenseInfo,\n \t\t              license->rdp->settings->ClientHostname);\n \n out_free_stream:\n \tStream_Free(licenseStream, FALSE);\n out_free_blob:\n \tlicense_free_binary_blob(calBlob);\n \treturn ret;\n }\n \n", "target": "// fix_start\n\tif (Stream_GetRemainingLength(licenseStream) < 8)\n\t\tgoto out_free_stream;\n\n// fix_end\n// fix_start\n\tif (Stream_GetRemainingLength(licenseStream) < 4)\n\t\tgoto out_free_stream;\n// fix_end\n// fix_start\n\tif (Stream_GetRemainingLength(licenseStream) < 4)\n\t\tgoto out_free_stream;\n// fix_end\n// fix_start\n\tif (Stream_GetRemainingLength(licenseStream) < 4)\n\t\tgoto out_free_stream;\n// fix_end\n", "cwe": "CWE-125", "cwe_name": "Out-of-bounds Read", "cve": "CVE-2020-11099", "cve_desc": "In FreeRDP before version 2.1.2, there is an out of bounds read in license_read_new_or_upgrade_license_packet. A manipulated license packet can lead to out of bound reads to an internal buffer. This is fixed in version 2.1.2.", "project": "FreeRDP", "idx": 207567}
{"source": " int mutt_seqset_iterator_next(struct SeqsetIterator *iter, unsigned int *next)\n {\n   if (!iter || !next)\n     return -1;\n \n   if (iter->in_range)\n   {\n     if ((iter->down && (iter->range_cur == (iter->range_end - 1))) ||\n         (!iter->down && (iter->range_cur == (iter->range_end + 1))))\n     {\n       iter->in_range = 0;\n     }\n   }\n \n   if (!iter->in_range)\n   {\n     iter->substr_cur = iter->substr_end;\n     if (iter->substr_cur == iter->eostr)\n       return 1;\n \n// bug_start\n    while (!*(iter->substr_cur))\n      iter->substr_cur++;\n// bug_end\n     iter->substr_end = strchr(iter->substr_cur, ',');\n     if (!iter->substr_end)\n       iter->substr_end = iter->eostr;\n     else\n// bug_start\n      *(iter->substr_end) = '\\0';\n// bug_end\n \n     char *range_sep = strchr(iter->substr_cur, ':');\n     if (range_sep)\n       *range_sep++ = '\\0';\n \n     if (mutt_str_atoui(iter->substr_cur, &iter->range_cur) != 0)\n       return -1;\n     if (range_sep)\n     {\n       if (mutt_str_atoui(range_sep, &iter->range_end) != 0)\n         return -1;\n     }\n     else\n       iter->range_end = iter->range_cur;\n \n     iter->down = (iter->range_end < iter->range_cur);\n     iter->in_range = 1;\n   }\n \n   *next = iter->range_cur;\n   if (iter->down)\n     iter->range_cur--;\n   else\n     iter->range_cur++;\n \n   return 0;\n }\n \n", "target": "// fix_start\n// fix_end\n// fix_start\n      *(iter->substr_end++) = '\\0';\n// fix_end\n", "cwe": "CWE-125", "cwe_name": "Out-of-bounds Read", "cve": "CVE-2021-32055", "cve_desc": "Mutt 1.11.0 through 2.0.x before 2.0.7 (and NeoMutt 2019-10-25 through 2021-05-04) has a $imap_qresync issue in which imap/util.c has an out-of-bounds read in situations where an IMAP sequence set ends with a comma. NOTE: the $imap_qresync setting for QRESYNC is not enabled by default.", "project": "neomutt", "idx": 207568}
{"source": " virtio_dev_rx_batch_packed(struct virtio_net *dev,\n \t\t\t   struct vhost_virtqueue *vq,\n \t\t\t   struct rte_mbuf **pkts)\n {\n \tbool wrap_counter = vq->avail_wrap_counter;\n \tstruct vring_packed_desc *descs = vq->desc_packed;\n \tuint16_t avail_idx = vq->last_avail_idx;\n \tuint64_t desc_addrs[PACKED_BATCH_SIZE];\n \tstruct virtio_net_hdr_mrg_rxbuf *hdrs[PACKED_BATCH_SIZE];\n \tuint32_t buf_offset = dev->vhost_hlen;\n \tuint64_t lens[PACKED_BATCH_SIZE];\n \tuint16_t ids[PACKED_BATCH_SIZE];\n \tuint16_t i;\n \n \tif (unlikely(avail_idx & PACKED_BATCH_MASK))\n \t\treturn -1;\n \n \tif (unlikely((avail_idx + PACKED_BATCH_SIZE) > vq->size))\n \t\treturn -1;\n \n \tvhost_for_each_try_unroll(i, 0, PACKED_BATCH_SIZE) {\n \t\tif (unlikely(pkts[i]->next != NULL))\n \t\t\treturn -1;\n \t\tif (unlikely(!desc_is_avail(&descs[avail_idx + i],\n \t\t\t\t\t    wrap_counter)))\n \t\t\treturn -1;\n \t}\n \n \trte_smp_rmb();\n \n \tvhost_for_each_try_unroll(i, 0, PACKED_BATCH_SIZE)\n \t\tlens[i] = descs[avail_idx + i].len;\n \n \tvhost_for_each_try_unroll(i, 0, PACKED_BATCH_SIZE) {\n \t\tif (unlikely(pkts[i]->pkt_len > (lens[i] - buf_offset)))\n \t\t\treturn -1;\n \t}\n \n \tvhost_for_each_try_unroll(i, 0, PACKED_BATCH_SIZE)\n \t\tdesc_addrs[i] = vhost_iova_to_vva(dev, vq,\n \t\t\t\t\t\t  descs[avail_idx + i].addr,\n \t\t\t\t\t\t  &lens[i],\n \t\t\t\t\t\t  VHOST_ACCESS_RW);\n \n \tvhost_for_each_try_unroll(i, 0, PACKED_BATCH_SIZE) {\n// bug_start\n// bug_end\n \t\tif (unlikely(lens[i] != descs[avail_idx + i].len))\n \t\t\treturn -1;\n \t}\n \n \tvhost_for_each_try_unroll(i, 0, PACKED_BATCH_SIZE) {\n \t\trte_prefetch0((void *)(uintptr_t)desc_addrs[i]);\n \t\thdrs[i] = (struct virtio_net_hdr_mrg_rxbuf *)\n \t\t\t\t\t(uintptr_t)desc_addrs[i];\n \t\tlens[i] = pkts[i]->pkt_len + dev->vhost_hlen;\n \t}\n \n \tvhost_for_each_try_unroll(i, 0, PACKED_BATCH_SIZE)\n \t\tvirtio_enqueue_offload(pkts[i], &hdrs[i]->hdr);\n \n \tvq_inc_last_avail_packed(vq, PACKED_BATCH_SIZE);\n \n \tvhost_for_each_try_unroll(i, 0, PACKED_BATCH_SIZE) {\n \t\trte_memcpy((void *)(uintptr_t)(desc_addrs[i] + buf_offset),\n \t\t\t   rte_pktmbuf_mtod_offset(pkts[i], void *, 0),\n \t\t\t   pkts[i]->pkt_len);\n \t}\n \n \tvhost_for_each_try_unroll(i, 0, PACKED_BATCH_SIZE)\n \t\tvhost_log_cache_write_iova(dev, vq, descs[avail_idx + i].addr,\n \t\t\t\t\t   lens[i]);\n \n \tvhost_for_each_try_unroll(i, 0, PACKED_BATCH_SIZE)\n \t\tids[i] = descs[avail_idx + i].id;\n \n \tvhost_flush_enqueue_batch_packed(dev, vq, lens, ids);\n \n \treturn 0;\n }\n \n", "target": "// fix_start\n\t\tif (unlikely(!desc_addrs[i]))\n\t\t\treturn -1;\n// fix_end\n", "cwe": "CWE-665", "cwe_name": "Improper Initialization", "cve": "CVE-2020-10725", "cve_desc": "A flaw was found in DPDK version 19.11 and above that allows a malicious guest to cause a segmentation fault of the vhost-user backend application running on the host, which could result in a loss of connectivity for the other guests running on that host. This is caused by a missing validity check of the descriptor address in the function `virtio_dev_rx_batch_packed()`.", "project": "dpdk", "idx": 207646}
{"source": " parse_key_constraints(struct sshbuf *m, struct sshkey *k, time_t *deathp,\n     u_int *secondsp, int *confirmp, char **sk_providerp)\n {\n \tu_char ctype;\n \tint r;\n \tu_int seconds, maxsign = 0;\n// bug_start\n\tchar *ext_name = NULL;\n\tstruct sshbuf *b = NULL;\n// bug_end\n \n \twhile (sshbuf_len(m)) {\n \t\tif ((r = sshbuf_get_u8(m, &ctype)) != 0) {\n \t\t\terror_fr(r, \"parse constraint type\");\n// bug_start\n\t\t\tgoto err;\n// bug_end\n \t\t}\n \t\tswitch (ctype) {\n \t\tcase SSH_AGENT_CONSTRAIN_LIFETIME:\n \t\t\tif (*deathp != 0) {\n \t\t\t\terror_f(\"lifetime already set\");\n// bug_start\n\t\t\t\tgoto err;\n// bug_end\n \t\t\t}\n \t\t\tif ((r = sshbuf_get_u32(m, &seconds)) != 0) {\n \t\t\t\terror_fr(r, \"parse lifetime constraint\");\n// bug_start\n\t\t\t\tgoto err;\n// bug_end\n \t\t\t}\n \t\t\t*deathp = monotime() + seconds;\n \t\t\t*secondsp = seconds;\n \t\t\tbreak;\n \t\tcase SSH_AGENT_CONSTRAIN_CONFIRM:\n \t\t\tif (*confirmp != 0) {\n \t\t\t\terror_f(\"confirm already set\");\n// bug_start\n\t\t\t\tgoto err;\n// bug_end\n \t\t\t}\n \t\t\t*confirmp = 1;\n \t\t\tbreak;\n \t\tcase SSH_AGENT_CONSTRAIN_MAXSIGN:\n \t\t\tif (k == NULL) {\n \t\t\t\terror_f(\"maxsign not valid here\");\n// bug_start\n\t\t\t\tgoto err;\n// bug_end\n \t\t\t}\n \t\t\tif (maxsign != 0) {\n \t\t\t\terror_f(\"maxsign already set\");\n// bug_start\n\t\t\t\tgoto err;\n// bug_end\n \t\t\t}\n \t\t\tif ((r = sshbuf_get_u32(m, &maxsign)) != 0) {\n \t\t\t\terror_fr(r, \"parse maxsign constraint\");\n// bug_start\n\t\t\t\tgoto err;\n// bug_end\n \t\t\t}\n \t\t\tif ((r = sshkey_enable_maxsign(k, maxsign)) != 0) {\n \t\t\t\terror_fr(r, \"enable maxsign\");\n// bug_start\n\t\t\t\tgoto err;\n// bug_end\n \t\t\t}\n \t\t\tbreak;\n \t\tcase SSH_AGENT_CONSTRAIN_EXTENSION:\n// bug_start\n\t\t\tif ((r = sshbuf_get_cstring(m, &ext_name, NULL)) != 0) {\n\t\t\t\terror_fr(r, \"parse constraint extension\");\n\t\t\t\tgoto err;\n\t\t\t}\n\t\t\tdebug_f(\"constraint ext %s\", ext_name);\n\t\t\tif (strcmp(ext_name, \"sk-provider@openssh.com\") == 0) {\n\t\t\t\tif (sk_providerp == NULL) {\n\t\t\t\t\terror_f(\"%s not valid here\", ext_name);\n\t\t\t\t\tgoto err;\n\t\t\t\t}\n\t\t\t\tif (*sk_providerp != NULL) {\n\t\t\t\t\terror_f(\"%s already set\", ext_name);\n\t\t\t\t\tgoto err;\n\t\t\t\t}\n\t\t\t\tif ((r = sshbuf_get_cstring(m,\n\t\t\t\t    sk_providerp, NULL)) != 0) {\n\t\t\t\t\terror_fr(r, \"parse %s\", ext_name);\n\t\t\t\t\tgoto err;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\terror_f(\"unsupported constraint \\\"%s\\\"\",\n\t\t\t\t    ext_name);\n\t\t\t\tgoto err;\n\t\t\t}\n\t\t\tfree(ext_name);\n// bug_end\n \t\t\tbreak;\n \t\tdefault:\n \t\t\terror_f(\"Unknown constraint %d\", ctype);\n// bug_start\n err:\n\t\t\tfree(ext_name);\n\t\t\tsshbuf_free(b);\n\t\t\treturn -1;\n// bug_end\n \t\t}\n \t}\n// bug_start\n\treturn 0;\n// bug_end\n }\n \n", "target": "// fix_start\n// fix_end\n// fix_start\n\t\t\tgoto out;\n// fix_end\n// fix_start\n\t\t\t\tr = SSH_ERR_INVALID_FORMAT;\n\t\t\t\tgoto out;\n// fix_end\n// fix_start\n\t\t\t\tgoto out;\n// fix_end\n// fix_start\n\t\t\t\tr = SSH_ERR_INVALID_FORMAT;\n\t\t\t\tgoto out;\n// fix_end\n// fix_start\n\t\t\t\tr = SSH_ERR_INVALID_FORMAT;\n\t\t\t\tgoto out;\n// fix_end\n// fix_start\n\t\t\t\tr = SSH_ERR_INVALID_FORMAT;\n\t\t\t\tgoto out;\n// fix_end\n// fix_start\n\t\t\t\tgoto out;\n// fix_end\n// fix_start\n\t\t\t\tgoto out;\n// fix_end\n// fix_start\n\t\t\tif ((r = parse_key_constraint_extension(m,\n\t\t\t    sk_providerp)) != 0)\n\t\t\t\tgoto out;\n// fix_end\n// fix_start\n\t\t\tr = SSH_ERR_FEATURE_UNSUPPORTED;\n\t\t\tgoto out;\n// fix_end\n// fix_start\n\tr = 0;\n out:\n\treturn r;\n// fix_end\n", "cwe": "CWE-399", "cwe_name": "Resource Management Errors", "cve": "CVE-2021-28041", "cve_desc": "ssh-agent in OpenSSH before 8.5 has a double free that may be relevant in a few less-common scenarios, such as unconstrained agent-socket access on a legacy operating system, or the forwarding of an agent to an attacker-controlled host.", "project": "openssh-portable", "idx": 207709}
{"source": " z_jbig2decode(i_ctx_t * i_ctx_p)\n {\n     os_ptr op = osp;\n     ref *sop = NULL;\n     s_jbig2_global_data_t *gref;\n     stream_jbig2decode_state state;\n \n     s_jbig2decode_set_global_data((stream_state*)&state, NULL);\n     if (r_has_type(op, t_dictionary)) {\n         check_dict_read(*op);\n         if ( dict_find_string(op, \".jbig2globalctx\", &sop) > 0) {\n// bug_start\n// bug_end\n             gref = r_ptr(sop, s_jbig2_global_data_t);\n             s_jbig2decode_set_global_data((stream_state*)&state, gref);\n         }\n     }\n \n     return filter_read(i_ctx_p, 0, &s_jbig2decode_template,\n                        (stream_state *) & state, (sop ? r_space(sop) : 0));\n }\n \n", "target": "// fix_start\n            if (!r_is_struct(sop) || !r_has_stype(sop, imemory, st_jbig2_global_data_t))\n                return_error(gs_error_typecheck);\n// fix_end\n", "cwe": "CWE-704", "cwe_name": "Incorrect Type Conversion or Cast", "cve": "CVE-2018-19477", "cve_desc": "psi/zfjbig2.c in Artifex Ghostscript before 9.26 allows remote attackers to bypass intended access restrictions because of a JBIG2Decode type confusion.", "project": "ghostpdl", "idx": 207760}
{"source": " ReadFromRFBServer(rfbClient* client, char *out, unsigned int n)\n {\n// bug_start\n// bug_end\n #undef DEBUG_READ_EXACT\n #ifdef DEBUG_READ_EXACT\n \tchar* oout=out;\n \tunsigned int nn=n;\n \trfbClientLog(\"ReadFromRFBServer %d bytes\\n\",n);\n #endif\n \n   if(!out)\n     return FALSE;\n \n   if (client->serverPort==-1) {\n     rfbVNCRec* rec = client->vncRec;\n     struct timeval tv;\n \n     if (rec->readTimestamp) {\n       rec->readTimestamp = FALSE;\n       if (!fread(&tv,sizeof(struct timeval),1,rec->file))\n         return FALSE;\n \n       tv.tv_sec = rfbClientSwap32IfLE (tv.tv_sec);\n       tv.tv_usec = rfbClientSwap32IfLE (tv.tv_usec);\n \n       if (rec->tv.tv_sec!=0 && !rec->doNotSleep) {\n         struct timeval diff;\n         diff.tv_sec = tv.tv_sec - rec->tv.tv_sec;\n         diff.tv_usec = tv.tv_usec - rec->tv.tv_usec;\n         if(diff.tv_usec<0) {\n \t  diff.tv_sec--;\n \t  diff.tv_usec+=1000000;\n         }\n #ifndef WIN32\n         sleep (diff.tv_sec);\n         usleep (diff.tv_usec);\n #else\n \tSleep (diff.tv_sec * 1000 + diff.tv_usec/1000);\n #endif\n       }\n \n       rec->tv=tv;\n     }\n \n     return (fread(out,1,n,rec->file) != n ? FALSE : TRUE);\n   }\n \n   if (n <= client->buffered) {\n     memcpy(out, client->bufoutptr, n);\n     client->bufoutptr += n;\n     client->buffered -= n;\n #ifdef DEBUG_READ_EXACT\n     goto hexdump;\n #endif\n     return TRUE;\n   }\n \n   memcpy(out, client->bufoutptr, client->buffered);\n \n   out += client->buffered;\n   n -= client->buffered;\n \n   client->bufoutptr = client->buf;\n   client->buffered = 0;\n \n   if (n <= RFB_BUF_SIZE) {\n \n     while (client->buffered < n) {\n       int i;\n       if (client->tlsSession)\n         i = ReadFromTLS(client, client->buf + client->buffered, RFB_BUF_SIZE - client->buffered);\n       else\n #ifdef LIBVNCSERVER_HAVE_SASL\n       if (client->saslconn)\n         i = ReadFromSASL(client, client->buf + client->buffered, RFB_BUF_SIZE - client->buffered);\n       else {\n #endif\n         i = read(client->sock, client->buf + client->buffered, RFB_BUF_SIZE - client->buffered);\n #ifdef WIN32\n \tif (i < 0) errno=WSAGetLastError();\n #endif\n #ifdef LIBVNCSERVER_HAVE_SASL\n       }\n #endif\n \n       if (i <= 0) {\n \tif (i < 0) {\n \t  if (errno == EWOULDBLOCK || errno == EAGAIN) {\n// bug_start\n\t    WaitForMessage(client, 100000);\n// bug_end\n \t    i = 0;\n \t  } else {\n \t    rfbClientErr(\"read (%d: %s)\\n\",errno,strerror(errno));\n \t    return FALSE;\n \t  }\n \t} else {\n \t  if (errorMessageOnReadFailure) {\n \t    rfbClientLog(\"VNC server closed connection\\n\");\n \t  }\n \t  return FALSE;\n \t}\n       }\n       client->buffered += i;\n     }\n \n     memcpy(out, client->bufoutptr, n);\n     client->bufoutptr += n;\n     client->buffered -= n;\n \n   } else {\n \n     while (n > 0) {\n       int i;\n       if (client->tlsSession)\n         i = ReadFromTLS(client, out, n);\n       else\n #ifdef LIBVNCSERVER_HAVE_SASL\n       if (client->saslconn)\n         i = ReadFromSASL(client, out, n);\n       else\n #endif\n         i = read(client->sock, out, n);\n \n       if (i <= 0) {\n \tif (i < 0) {\n #ifdef WIN32\n \t  errno=WSAGetLastError();\n #endif\n \t  if (errno == EWOULDBLOCK || errno == EAGAIN) {\n// bug_start\n\t    WaitForMessage(client, 100000);\n// bug_end\n \t    i = 0;\n \t  } else {\n \t    rfbClientErr(\"read (%s)\\n\",strerror(errno));\n \t    return FALSE;\n \t  }\n \t} else {\n \t  if (errorMessageOnReadFailure) {\n \t    rfbClientLog(\"VNC server closed connection\\n\");\n \t  }\n \t  return FALSE;\n \t}\n       }\n       out += i;\n       n -= i;\n     }\n   }\n \n #ifdef DEBUG_READ_EXACT\n hexdump:\n   { unsigned int ii;\n     for(ii=0;ii<nn;ii++)\n       fprintf(stderr,\"%02x \",(unsigned char)oout[ii]);\n     fprintf(stderr,\"\\n\");\n   }\n #endif\n \n   return TRUE;\n }\n \n", "target": "// fix_start\n  const int USECS_WAIT_PER_RETRY = 100000;\n  int retries = 0;\n// fix_end\n// fix_start\n\t    if (client->readTimeout > 0 &&\n\t\t++retries > (client->readTimeout * 1000 * 1000 / USECS_WAIT_PER_RETRY))\n\t    {\n\t      rfbClientLog(\"Connection timed out\\n\");\n\t      return FALSE;\n\t    }\n\t    WaitForMessage(client, USECS_WAIT_PER_RETRY);\n// fix_end\n// fix_start\n\t    if (client->readTimeout > 0 &&\n\t\t++retries > (client->readTimeout * 1000 * 1000 / USECS_WAIT_PER_RETRY))\n\t    {\n\t\trfbClientLog(\"Connection timed out\\n\");\n\t\treturn FALSE;\n\t    }\n\t    WaitForMessage(client, USECS_WAIT_PER_RETRY);\n// fix_end\n", "cwe": "CWE-703", "cwe_name": "Improper Check or Handling of Exceptional Conditions", "cve": "CVE-2020-14398", "cve_desc": "An issue was discovered in LibVNCServer before 0.9.13. An improperly closed TCP connection causes an infinite loop in libvncclient/sockets.c.", "project": "libvncserver", "idx": 207769}
{"source": " static INLINE BOOL RLEDECOMPRESS(const BYTE* pbSrcBuffer, UINT32 cbSrcBuffer, BYTE* pbDestBuffer,\n                                  UINT32 rowDelta, UINT32 width, UINT32 height)\n {\n \tconst BYTE* pbSrc = pbSrcBuffer;\n \tconst BYTE* pbEnd;\n \tconst BYTE* pbDestEnd;\n \tBYTE* pbDest = pbDestBuffer;\n \tPIXEL temp;\n \tPIXEL fgPel = WHITE_PIXEL;\n \tBOOL fInsertFgPel = FALSE;\n \tBOOL fFirstLine = TRUE;\n \tBYTE bitmask;\n \tPIXEL pixelA, pixelB;\n \tUINT32 runLength;\n \tUINT32 code;\n \tUINT32 advance;\n \tRLEEXTRA\n \n \tif ((rowDelta == 0) || (rowDelta < width))\n \t\treturn FALSE;\n \n \tif (!pbSrcBuffer || !pbDestBuffer)\n \t\treturn FALSE;\n \n \tpbEnd = pbSrcBuffer + cbSrcBuffer;\n \tpbDestEnd = pbDestBuffer + rowDelta * height;\n \n \twhile (pbSrc < pbEnd)\n \t{\n \t\tif (fFirstLine)\n \t\t{\n \t\t\tif ((UINT32)(pbDest - pbDestBuffer) >= rowDelta)\n \t\t\t{\n \t\t\t\tfFirstLine = FALSE;\n \t\t\t\tfInsertFgPel = FALSE;\n \t\t\t}\n \t\t}\n \n \t\tcode = ExtractCodeId(*pbSrc);\n \n \t\tif (code == REGULAR_BG_RUN || code == MEGA_MEGA_BG_RUN)\n \t\t{\n \t\t\trunLength = ExtractRunLength(code, pbSrc, &advance);\n \t\t\tpbSrc = pbSrc + advance;\n \n \t\t\tif (fFirstLine)\n \t\t\t{\n \t\t\t\tif (fInsertFgPel)\n \t\t\t\t{\n \t\t\t\t\tif (!ENSURE_CAPACITY(pbDest, pbDestEnd, 1))\n \t\t\t\t\t\treturn FALSE;\n \n \t\t\t\t\tDESTWRITEPIXEL(pbDest, fgPel);\n \t\t\t\t\tDESTNEXTPIXEL(pbDest);\n \t\t\t\t\trunLength = runLength - 1;\n \t\t\t\t}\n \n \t\t\t\tif (!ENSURE_CAPACITY(pbDest, pbDestEnd, runLength))\n \t\t\t\t\treturn FALSE;\n \n \t\t\t\tUNROLL(runLength, {\n \t\t\t\t\tDESTWRITEPIXEL(pbDest, BLACK_PIXEL);\n \t\t\t\t\tDESTNEXTPIXEL(pbDest);\n \t\t\t\t});\n \t\t\t}\n \t\t\telse\n \t\t\t{\n \t\t\t\tif (fInsertFgPel)\n \t\t\t\t{\n \t\t\t\t\tDESTREADPIXEL(temp, pbDest - rowDelta);\n \n \t\t\t\t\tif (!ENSURE_CAPACITY(pbDest, pbDestEnd, 1))\n \t\t\t\t\t\treturn FALSE;\n \n \t\t\t\t\tDESTWRITEPIXEL(pbDest, temp ^ fgPel);\n \t\t\t\t\tDESTNEXTPIXEL(pbDest);\n \t\t\t\t\trunLength--;\n \t\t\t\t}\n \n \t\t\t\tif (!ENSURE_CAPACITY(pbDest, pbDestEnd, runLength))\n \t\t\t\t\treturn FALSE;\n \n \t\t\t\tUNROLL(runLength, {\n \t\t\t\t\tDESTREADPIXEL(temp, pbDest - rowDelta);\n \t\t\t\t\tDESTWRITEPIXEL(pbDest, temp);\n \t\t\t\t\tDESTNEXTPIXEL(pbDest);\n \t\t\t\t});\n \t\t\t}\n \n \t\t\tfInsertFgPel = TRUE;\n \t\t\tcontinue;\n \t\t}\n \n \t\tfInsertFgPel = FALSE;\n \n \t\tswitch (code)\n \t\t{\n \t\t\tcase REGULAR_FG_RUN:\n \t\t\tcase MEGA_MEGA_FG_RUN:\n \t\t\tcase LITE_SET_FG_FG_RUN:\n \t\t\tcase MEGA_MEGA_SET_FG_RUN:\n \t\t\t\trunLength = ExtractRunLength(code, pbSrc, &advance);\n \t\t\t\tpbSrc = pbSrc + advance;\n \n \t\t\t\tif (code == LITE_SET_FG_FG_RUN || code == MEGA_MEGA_SET_FG_RUN)\n \t\t\t\t{\n// bug_start\n// bug_end\n \t\t\t\t\tSRCREADPIXEL(fgPel, pbSrc);\n \t\t\t\t\tSRCNEXTPIXEL(pbSrc);\n \t\t\t\t}\n \n \t\t\t\tif (!ENSURE_CAPACITY(pbDest, pbDestEnd, runLength))\n \t\t\t\t\treturn FALSE;\n \n \t\t\t\tif (fFirstLine)\n \t\t\t\t{\n \t\t\t\t\tUNROLL(runLength, {\n \t\t\t\t\t\tDESTWRITEPIXEL(pbDest, fgPel);\n \t\t\t\t\t\tDESTNEXTPIXEL(pbDest);\n \t\t\t\t\t});\n \t\t\t\t}\n \t\t\t\telse\n \t\t\t\t{\n \t\t\t\t\tUNROLL(runLength, {\n \t\t\t\t\t\tDESTREADPIXEL(temp, pbDest - rowDelta);\n \t\t\t\t\t\tDESTWRITEPIXEL(pbDest, temp ^ fgPel);\n \t\t\t\t\t\tDESTNEXTPIXEL(pbDest);\n \t\t\t\t\t});\n \t\t\t\t}\n \n \t\t\t\tbreak;\n \n \t\t\tcase LITE_DITHERED_RUN:\n \t\t\tcase MEGA_MEGA_DITHERED_RUN:\n \t\t\t\trunLength = ExtractRunLength(code, pbSrc, &advance);\n \t\t\t\tpbSrc = pbSrc + advance;\n// bug_start\n// bug_end\n \t\t\t\tSRCREADPIXEL(pixelA, pbSrc);\n \t\t\t\tSRCNEXTPIXEL(pbSrc);\n// bug_start\n// bug_end\n \t\t\t\tSRCREADPIXEL(pixelB, pbSrc);\n \t\t\t\tSRCNEXTPIXEL(pbSrc);\n \n \t\t\t\tif (!ENSURE_CAPACITY(pbDest, pbDestEnd, runLength * 2))\n \t\t\t\t\treturn FALSE;\n \n \t\t\t\tUNROLL(runLength, {\n \t\t\t\t\tDESTWRITEPIXEL(pbDest, pixelA);\n \t\t\t\t\tDESTNEXTPIXEL(pbDest);\n \t\t\t\t\tDESTWRITEPIXEL(pbDest, pixelB);\n \t\t\t\t\tDESTNEXTPIXEL(pbDest);\n \t\t\t\t});\n \t\t\t\tbreak;\n \n \t\t\tcase REGULAR_COLOR_RUN:\n \t\t\tcase MEGA_MEGA_COLOR_RUN:\n \t\t\t\trunLength = ExtractRunLength(code, pbSrc, &advance);\n \t\t\t\tpbSrc = pbSrc + advance;\n// bug_start\n// bug_end\n \t\t\t\tSRCREADPIXEL(pixelA, pbSrc);\n \t\t\t\tSRCNEXTPIXEL(pbSrc);\n \n \t\t\t\tif (!ENSURE_CAPACITY(pbDest, pbDestEnd, runLength))\n \t\t\t\t\treturn FALSE;\n \n \t\t\t\tUNROLL(runLength, {\n \t\t\t\t\tDESTWRITEPIXEL(pbDest, pixelA);\n \t\t\t\t\tDESTNEXTPIXEL(pbDest);\n \t\t\t\t});\n \t\t\t\tbreak;\n \n \t\t\tcase REGULAR_FGBG_IMAGE:\n \t\t\tcase MEGA_MEGA_FGBG_IMAGE:\n \t\t\tcase LITE_SET_FG_FGBG_IMAGE:\n \t\t\tcase MEGA_MEGA_SET_FGBG_IMAGE:\n \t\t\t\trunLength = ExtractRunLength(code, pbSrc, &advance);\n \t\t\t\tpbSrc = pbSrc + advance;\n \n// bug_start\n// bug_end\n \t\t\t\tif (code == LITE_SET_FG_FGBG_IMAGE || code == MEGA_MEGA_SET_FGBG_IMAGE)\n \t\t\t\t{\n \t\t\t\t\tSRCREADPIXEL(fgPel, pbSrc);\n \t\t\t\t\tSRCNEXTPIXEL(pbSrc);\n \t\t\t\t}\n \n \t\t\t\tif (fFirstLine)\n \t\t\t\t{\n \t\t\t\t\twhile (runLength > 8)\n \t\t\t\t\t{\n \t\t\t\t\t\tbitmask = *pbSrc;\n \t\t\t\t\t\tpbSrc = pbSrc + 1;\n \t\t\t\t\t\tpbDest = WRITEFIRSTLINEFGBGIMAGE(pbDest, pbDestEnd, bitmask, fgPel, 8);\n \n \t\t\t\t\t\tif (!pbDest)\n \t\t\t\t\t\t\treturn FALSE;\n \n \t\t\t\t\t\trunLength = runLength - 8;\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\telse\n \t\t\t\t{\n \t\t\t\t\twhile (runLength > 8)\n \t\t\t\t\t{\n \t\t\t\t\t\tbitmask = *pbSrc;\n \t\t\t\t\t\tpbSrc = pbSrc + 1;\n \t\t\t\t\t\tpbDest = WRITEFGBGIMAGE(pbDest, pbDestEnd, rowDelta, bitmask, fgPel, 8);\n \n \t\t\t\t\t\tif (!pbDest)\n \t\t\t\t\t\t\treturn FALSE;\n \n \t\t\t\t\t\trunLength = runLength - 8;\n \t\t\t\t\t}\n \t\t\t\t}\n \n \t\t\t\tif (runLength > 0)\n \t\t\t\t{\n \t\t\t\t\tbitmask = *pbSrc;\n \t\t\t\t\tpbSrc = pbSrc + 1;\n \n \t\t\t\t\tif (fFirstLine)\n \t\t\t\t\t{\n \t\t\t\t\t\tpbDest =\n \t\t\t\t\t\t    WRITEFIRSTLINEFGBGIMAGE(pbDest, pbDestEnd, bitmask, fgPel, runLength);\n \t\t\t\t\t}\n \t\t\t\t\telse\n \t\t\t\t\t{\n \t\t\t\t\t\tpbDest =\n \t\t\t\t\t\t    WRITEFGBGIMAGE(pbDest, pbDestEnd, rowDelta, bitmask, fgPel, runLength);\n \t\t\t\t\t}\n \n \t\t\t\t\tif (!pbDest)\n \t\t\t\t\t\treturn FALSE;\n \t\t\t\t}\n \n \t\t\t\tbreak;\n \n \t\t\tcase REGULAR_COLOR_IMAGE:\n \t\t\tcase MEGA_MEGA_COLOR_IMAGE:\n \t\t\t\trunLength = ExtractRunLength(code, pbSrc, &advance);\n \t\t\t\tpbSrc = pbSrc + advance;\n \t\t\t\tif (!ENSURE_CAPACITY(pbDest, pbDestEnd, runLength))\n \t\t\t\t\treturn FALSE;\n \n \t\t\t\tUNROLL(runLength, {\n// bug_start\n// bug_end\n \t\t\t\t\tSRCREADPIXEL(temp, pbSrc);\n \t\t\t\t\tSRCNEXTPIXEL(pbSrc);\n \t\t\t\t\tDESTWRITEPIXEL(pbDest, temp);\n \t\t\t\t\tDESTNEXTPIXEL(pbDest);\n \t\t\t\t});\n \t\t\t\tbreak;\n \n \t\t\tcase SPECIAL_FGBG_1:\n \t\t\t\tpbSrc = pbSrc + 1;\n \n \t\t\t\tif (fFirstLine)\n \t\t\t\t{\n \t\t\t\t\tpbDest =\n \t\t\t\t\t    WRITEFIRSTLINEFGBGIMAGE(pbDest, pbDestEnd, g_MaskSpecialFgBg1, fgPel, 8);\n \t\t\t\t}\n \t\t\t\telse\n \t\t\t\t{\n \t\t\t\t\tpbDest =\n \t\t\t\t\t    WRITEFGBGIMAGE(pbDest, pbDestEnd, rowDelta, g_MaskSpecialFgBg1, fgPel, 8);\n \t\t\t\t}\n \n \t\t\t\tif (!pbDest)\n \t\t\t\t\treturn FALSE;\n \n \t\t\t\tbreak;\n \n \t\t\tcase SPECIAL_FGBG_2:\n \t\t\t\tpbSrc = pbSrc + 1;\n \n \t\t\t\tif (fFirstLine)\n \t\t\t\t{\n \t\t\t\t\tpbDest =\n \t\t\t\t\t    WRITEFIRSTLINEFGBGIMAGE(pbDest, pbDestEnd, g_MaskSpecialFgBg2, fgPel, 8);\n \t\t\t\t}\n \t\t\t\telse\n \t\t\t\t{\n \t\t\t\t\tpbDest =\n \t\t\t\t\t    WRITEFGBGIMAGE(pbDest, pbDestEnd, rowDelta, g_MaskSpecialFgBg2, fgPel, 8);\n \t\t\t\t}\n \n \t\t\t\tif (!pbDest)\n \t\t\t\t\treturn FALSE;\n \n \t\t\t\tbreak;\n \n \t\t\tcase SPECIAL_WHITE:\n \t\t\t\tpbSrc = pbSrc + 1;\n \n \t\t\t\tif (!ENSURE_CAPACITY(pbDest, pbDestEnd, 1))\n \t\t\t\t\treturn FALSE;\n \n \t\t\t\tDESTWRITEPIXEL(pbDest, WHITE_PIXEL);\n \t\t\t\tDESTNEXTPIXEL(pbDest);\n \t\t\t\tbreak;\n \n \t\t\tcase SPECIAL_BLACK:\n \t\t\t\tpbSrc = pbSrc + 1;\n \n \t\t\t\tif (!ENSURE_CAPACITY(pbDest, pbDestEnd, 1))\n \t\t\t\t\treturn FALSE;\n \n \t\t\t\tDESTWRITEPIXEL(pbDest, BLACK_PIXEL);\n \t\t\t\tDESTNEXTPIXEL(pbDest);\n \t\t\t\tbreak;\n \n \t\t\tdefault:\n \t\t\t\treturn FALSE;\n \t\t}\n \t}\n \n \treturn TRUE;\n }\n \n", "target": "// fix_start\n\t\t\t\t\tif (pbSrc >= pbEnd)\n\t\t\t\t\t\treturn FALSE;\n// fix_end\n// fix_start\n\t\t\t\tif (pbSrc >= pbEnd)\n\t\t\t\t\treturn FALSE;\n// fix_end\n// fix_start\n\t\t\t\tif (pbSrc >= pbEnd)\n\t\t\t\t\treturn FALSE;\n// fix_end\n// fix_start\n\t\t\t\tif (pbSrc >= pbEnd)\n\t\t\t\t\treturn FALSE;\n// fix_end\n// fix_start\n\t\t\t\tif (pbSrc >= pbEnd)\n\t\t\t\t\treturn FALSE;\n// fix_end\n// fix_start\n\t\t\t\t\tif (pbSrc >= pbEnd)\n\t\t\t\t\t\treturn FALSE;\n// fix_end\n", "cwe": "CWE-125", "cwe_name": "Out-of-bounds Read", "cve": "CVE-2020-4033", "cve_desc": "In FreeRDP before version 2.1.2, there is an out of bounds read in RLEDECOMPRESS. All FreeRDP based clients with sessions with color depth < 32 are affected. This is fixed in version 2.1.2.", "project": "FreeRDP", "idx": 207836}
{"source": " static int vcf_parse_format(kstring_t *s, const bcf_hdr_t *h, bcf1_t *v, char *p, char *q)\n {\n     if ( !bcf_hdr_nsamples(h) ) return 0;\n \n     static int extreme_val_warned = 0;\n     char *r, *t;\n     int j, l, m, g, overflow = 0;\n     khint_t k;\n     ks_tokaux_t aux1;\n     vdict_t *d = (vdict_t*)h->dict[BCF_DT_ID];\n     kstring_t *mem = (kstring_t*)&h->mem;\n     fmt_aux_t fmt[MAX_N_FMT];\n     mem->l = 0;\n \n     char *end = s->s + s->l;\n     if ( q>=end )\n     {\n         hts_log_error(\"FORMAT column with no sample columns starting at %s:%\"PRIhts_pos\"\", bcf_seqname_safe(h,v), v->pos+1);\n         v->errcode |= BCF_ERR_NCOLS;\n         return -1;\n     }\n \n     v->n_fmt = 0;\n     if ( p[0]=='.' && p[1]==0 )\n     {\n         v->n_sample = bcf_hdr_nsamples(h);\n         return 0;\n     }\n \n     for (j = 0, t = kstrtok(p, \":\", &aux1); t; t = kstrtok(0, 0, &aux1), ++j) {\n         if (j >= MAX_N_FMT) {\n             v->errcode |= BCF_ERR_LIMITS;\n             hts_log_error(\"FORMAT column at %s:%\"PRIhts_pos\" lists more identifiers than htslib can handle\",\n                 bcf_seqname_safe(h,v), v->pos+1);\n             return -1;\n         }\n \n         *(char*)aux1.p = 0;\n         k = kh_get(vdict, d, t);\n         if (k == kh_end(d) || kh_val(d, k).info[BCF_HL_FMT] == 15) {\n             if ( t[0]=='.' && t[1]==0 )\n             {\n                 hts_log_error(\"Invalid FORMAT tag name '.' at %s:%\"PRIhts_pos, bcf_seqname_safe(h,v), v->pos+1);\n                 v->errcode |= BCF_ERR_TAG_INVALID;\n                 return -1;\n             }\n             hts_log_warning(\"FORMAT '%s' at %s:%\"PRIhts_pos\" is not defined in the header, assuming Type=String\", t, bcf_seqname_safe(h,v), v->pos+1);\n             kstring_t tmp = {0,0,0};\n             int l;\n             ksprintf(&tmp, \"##FORMAT=<ID=%s,Number=1,Type=String,Description=\\\"Dummy\\\">\", t);\n             bcf_hrec_t *hrec = bcf_hdr_parse_line(h,tmp.s,&l);\n             free(tmp.s);\n             int res = hrec ? bcf_hdr_add_hrec((bcf_hdr_t*)h, hrec) : -1;\n             if (res < 0) bcf_hrec_destroy(hrec);\n             if (res > 0) res = bcf_hdr_sync((bcf_hdr_t*)h);\n \n             k = kh_get(vdict, d, t);\n             v->errcode = BCF_ERR_TAG_UNDEF;\n             if (res || k == kh_end(d)) {\n                 hts_log_error(\"Could not add dummy header for FORMAT '%s' at %s:%\"PRIhts_pos, t, bcf_seqname_safe(h,v), v->pos+1);\n                 v->errcode |= BCF_ERR_TAG_INVALID;\n                 return -1;\n             }\n         }\n         fmt[j].max_l = fmt[j].max_m = fmt[j].max_g = 0;\n         fmt[j].key = kh_val(d, k).id;\n         fmt[j].is_gt = !strcmp(t, \"GT\");\n         fmt[j].y = h->id[0][fmt[j].key].val->info[BCF_HL_FMT];\n         v->n_fmt++;\n     }\n     int n_sample_ori = -1;\n     r = q + 1;\n     l = 0, m = g = 1, v->n_sample = 0;\n     while ( r<end )\n     {\n         if ( h->keep_samples )\n         {\n             n_sample_ori++;\n             if ( !bit_array_test(h->keep_samples,n_sample_ori) )\n             {\n                 while ( *r!='\\t' && r<end ) r++;\n                 if ( *r=='\\t' ) { *r = 0; r++; }\n                 continue;\n             }\n         }\n \n         j = 0;\n         fmt_aux_t *f = fmt;\n         for (;;) {\n             switch (*r) {\n             case ',':\n                 m++;\n                 break;\n \n             case '|':\n             case '/':\n                 if (f->is_gt) g++;\n                 break;\n \n             case '\\t':\n                 *r = 0;\n \n             case '\\0':\n             case ':':\n                 if (f->max_m < m) f->max_m = m;\n                 if (f->max_l < l) f->max_l = l;\n                 if (f->is_gt && f->max_g < g) f->max_g = g;\n                 l = 0, m = g = 1;\n                 if ( *r==':' ) {\n                     j++; f++;\n                     if ( j>=v->n_fmt ) {\n                         hts_log_error(\"Incorrect number of FORMAT fields at %s:%\"PRIhts_pos\"\",\n                                       h->id[BCF_DT_CTG][v->rid].key, v->pos+1);\n                         v->errcode |= BCF_ERR_NCOLS;\n                         return -1;\n                     }\n                 } else goto end_for;\n                 break;\n             }\n             if ( r>=end ) break;\n             r++; l++;\n         }\n     end_for:\n         v->n_sample++;\n         if ( v->n_sample == bcf_hdr_nsamples(h) ) break;\n         r++;\n     }\n \n     for (j = 0; j < v->n_fmt; ++j) {\n         fmt_aux_t *f = &fmt[j];\n         if ( !f->max_m ) f->max_m = 1;\n         if ((f->y>>4&0xf) == BCF_HT_STR) {\n             f->size = f->is_gt? f->max_g << 2 : f->max_l;\n         } else if ((f->y>>4&0xf) == BCF_HT_REAL || (f->y>>4&0xf) == BCF_HT_INT) {\n             f->size = f->max_m << 2;\n         } else\n         {\n             hts_log_error(\"The format type %d at %s:%\"PRIhts_pos\" is currently not supported\", f->y>>4&0xf, bcf_seqname_safe(h,v), v->pos+1);\n             v->errcode |= BCF_ERR_TAG_INVALID;\n             return -1;\n         }\n         if (align_mem(mem) < 0) {\n             hts_log_error(\"Memory allocation failure at %s:%\"PRIhts_pos, bcf_seqname_safe(h,v), v->pos+1);\n             v->errcode |= BCF_ERR_LIMITS;\n             return -1;\n         }\n// bug_start\n        f->offset = mem->l;\n\n        if (v->n_sample * (uint64_t)f->size > INT_MAX) {\n// bug_end\n             hts_log_error(\"Excessive memory required by FORMAT fields at %s:%\"PRIhts_pos, bcf_seqname_safe(h,v), v->pos+1);\n             v->errcode |= BCF_ERR_LIMITS;\n             return -1;\n         }\n// bug_start\n// bug_end\n         if (ks_resize(mem, mem->l + v->n_sample * (size_t)f->size) < 0) {\n             hts_log_error(\"Memory allocation failure at %s:%\"PRIhts_pos, bcf_seqname_safe(h,v), v->pos+1);\n             v->errcode |= BCF_ERR_LIMITS;\n             return -1;\n         }\n         mem->l += v->n_sample * f->size;\n     }\n     for (j = 0; j < v->n_fmt; ++j)\n         fmt[j].buf = (uint8_t*)mem->s + fmt[j].offset;\n     n_sample_ori = -1;\n     t = q + 1; m = 0;\n     while ( t<end )\n     {\n         if ( h->keep_samples )\n         {\n             n_sample_ori++;\n             if ( !bit_array_test(h->keep_samples,n_sample_ori) )\n             {\n                 while ( *t && t<end ) t++;\n                 t++;\n                 continue;\n             }\n         }\n         if ( m == bcf_hdr_nsamples(h) ) break;\n \n         j = 0;\n         while ( t < end )\n         {\n             fmt_aux_t *z = &fmt[j++];\n             if (!z->buf) {\n                 hts_log_error(\"Memory allocation failure for FORMAT field type %d at %s:%\"PRIhts_pos,\n                               z->y>>4&0xf, bcf_seqname_safe(h,v), v->pos+1);\n                 v->errcode |= BCF_ERR_LIMITS;\n                 return -1;\n             }\n             if ((z->y>>4&0xf) == BCF_HT_STR) {\n                 if (z->is_gt) {\n                     int32_t is_phased = 0;\n                     uint32_t *x = (uint32_t*)(z->buf + z->size * (size_t)m);\n                     uint32_t unreadable = 0;\n                     uint32_t max = 0;\n                     overflow = 0;\n                     for (l = 0;; ++t) {\n                         if (*t == '.') {\n                             ++t, x[l++] = is_phased;\n                         } else {\n                             char *tt = t;\n                             uint32_t val = hts_str2uint(t, &t, sizeof(val) * CHAR_MAX - 2, &overflow);\n                             unreadable |= tt == t;\n                             if (max < val) max = val;\n                             x[l++] = (val + 1) << 1 | is_phased;\n                         }\n                         is_phased = (*t == '|');\n                         if (*t != '|' && *t != '/') break;\n                     }\n                     if (overflow || max > (INT32_MAX >> 1) - 1) {\n                         hts_log_error(\"Couldn't read GT data: value too large at %s:%\"PRIhts_pos, bcf_seqname_safe(h,v), v->pos+1);\n                         return -1;\n                     }\n                     if (unreadable) {\n                         hts_log_error(\"Couldn't read GT data: value not a number or '.' at %s:%\"PRIhts_pos, bcf_seqname_safe(h,v), v->pos+1);\n                         return -1;\n                     }\n                     if ( !l ) x[l++] = 0;\n                     for (; l < z->size>>2; ++l) x[l] = bcf_int32_vector_end;\n                 } else {\n                     char *x = (char*)z->buf + z->size * (size_t)m;\n                     for (r = t, l = 0; *t != ':' && *t; ++t) x[l++] = *t;\n                     for (; l < z->size; ++l) x[l] = 0;\n                 }\n             } else if ((z->y>>4&0xf) == BCF_HT_INT) {\n                 int32_t *x = (int32_t*)(z->buf + z->size * (size_t)m);\n                 for (l = 0;; ++t) {\n                     if (*t == '.') {\n                         x[l++] = bcf_int32_missing, ++t;\n                     } else {\n                         overflow = 0;\n                         char *te;\n                         long int tmp_val = hts_str2int(t, &te, sizeof(tmp_val)*CHAR_BIT, &overflow);\n                         if ( te==t || overflow || tmp_val<BCF_MIN_BT_INT32 || tmp_val>BCF_MAX_BT_INT32 )\n                         {\n                             if ( !extreme_val_warned )\n                             {\n                                 hts_log_warning(\"Extreme FORMAT/%s value encountered and set to missing at %s:%\"PRIhts_pos, h->id[BCF_DT_ID][fmt[j-1].key].key, bcf_seqname_safe(h,v), v->pos+1);\n                                 extreme_val_warned = 1;\n                             }\n                             tmp_val = bcf_int32_missing;\n                         }\n                         x[l++] = tmp_val;\n                         t = te;\n                     }\n                     if (*t != ',') break;\n                 }\n                 if ( !l ) x[l++] = bcf_int32_missing;\n                 for (; l < z->size>>2; ++l) x[l] = bcf_int32_vector_end;\n             } else if ((z->y>>4&0xf) == BCF_HT_REAL) {\n                 float *x = (float*)(z->buf + z->size * (size_t)m);\n                 for (l = 0;; ++t) {\n                     if (*t == '.' && !isdigit_c(t[1])) {\n                         bcf_float_set_missing(x[l++]), ++t;\n                     } else {\n                         overflow = 0;\n                         char *te;\n                         float tmp_val = hts_str2dbl(t, &te, &overflow);\n                         if ( (te==t || overflow) && !extreme_val_warned )\n                         {\n                             hts_log_warning(\"Extreme FORMAT/%s value encountered at %s:%\"PRIhts_pos, h->id[BCF_DT_ID][fmt[j-1].key].key, bcf_seqname(h,v), v->pos+1);\n                             extreme_val_warned = 1;\n                         }\n                         x[l++] = tmp_val;\n                         t = te;\n                     }\n                     if (*t != ',') break;\n                 }\n                 if ( !l ) bcf_float_set_missing(x[l++]);\n                 for (; l < z->size>>2; ++l) bcf_float_set_vector_end(x[l]);\n             } else {\n                 hts_log_error(\"Unknown FORMAT field type %d at %s:%\"PRIhts_pos, z->y>>4&0xf, bcf_seqname_safe(h,v), v->pos+1);\n                 v->errcode |= BCF_ERR_TAG_INVALID;\n                 return -1;\n             }\n \n             if (*t == '\\0') {\n                 break;\n             }\n             else if (*t == ':') {\n                 t++;\n             }\n             else {\n                 char buffer[8];\n                 hts_log_error(\"Invalid character %s in '%s' FORMAT field at %s:%\"PRIhts_pos\"\",\n                     hts_strprint(buffer, sizeof buffer, '\\'', t, 1),\n                     h->id[BCF_DT_ID][z->key].key, bcf_seqname_safe(h,v), v->pos+1);\n                 v->errcode |= BCF_ERR_CHAR;\n                 return -1;\n             }\n         }\n \n         for (; j < v->n_fmt; ++j) {\n             fmt_aux_t *z = &fmt[j];\n             if ((z->y>>4&0xf) == BCF_HT_STR) {\n                 if (z->is_gt) {\n                     int32_t *x = (int32_t*)(z->buf + z->size * (size_t)m);\n                     if (z->size) x[0] = bcf_int32_missing;\n                     for (l = 1; l < z->size>>2; ++l) x[l] = bcf_int32_vector_end;\n                 } else {\n                     char *x = (char*)z->buf + z->size * (size_t)m;\n                     if ( z->size ) x[0] = '.';\n                     for (l = 1; l < z->size; ++l) x[l] = 0;\n                 }\n             } else if ((z->y>>4&0xf) == BCF_HT_INT) {\n                 int32_t *x = (int32_t*)(z->buf + z->size * (size_t)m);\n                 x[0] = bcf_int32_missing;\n                 for (l = 1; l < z->size>>2; ++l) x[l] = bcf_int32_vector_end;\n             } else if ((z->y>>4&0xf) == BCF_HT_REAL) {\n                 float *x = (float*)(z->buf + z->size * (size_t)m);\n                 bcf_float_set_missing(x[0]);\n                 for (l = 1; l < z->size>>2; ++l) bcf_float_set_vector_end(x[l]);\n             }\n         }\n \n         m++; t++;\n     }\n \n     kstring_t *str = &v->indiv;\n     int i;\n     if (v->n_sample > 0) {\n         for (i = 0; i < v->n_fmt; ++i) {\n             fmt_aux_t *z = &fmt[i];\n             bcf_enc_int1(str, z->key);\n             if ((z->y>>4&0xf) == BCF_HT_STR && !z->is_gt) {\n                 bcf_enc_size(str, z->size, BCF_BT_CHAR);\n                 kputsn((char*)z->buf, z->size * (size_t)v->n_sample, str);\n             } else if ((z->y>>4&0xf) == BCF_HT_INT || z->is_gt) {\n                 bcf_enc_vint(str, (z->size>>2) * v->n_sample, (int32_t*)z->buf, z->size>>2);\n             } else {\n                 bcf_enc_size(str, z->size>>2, BCF_BT_FLOAT);\n                 if (serialize_float_array(str, (z->size>>2) * (size_t)v->n_sample,\n                                           (float *) z->buf) != 0) {\n                     v->errcode |= BCF_ERR_LIMITS;\n                     hts_log_error(\"Out of memory at %s:%\"PRIhts_pos, bcf_seqname_safe(h,v), v->pos+1);\n                     return -1;\n                 }\n             }\n         }\n     }\n \n     if ( v->n_sample!=bcf_hdr_nsamples(h) )\n     {\n         hts_log_error(\"Number of columns at %s:%\"PRIhts_pos\" does not match the number of samples (%d vs %d)\",\n             bcf_seqname_safe(h,v), v->pos+1, v->n_sample, bcf_hdr_nsamples(h));\n         v->errcode |= BCF_ERR_NCOLS;\n         return -1;\n     }\n     if ( v->indiv.l > 0xffffffff )\n     {\n         hts_log_error(\"The FORMAT at %s:%\"PRIhts_pos\" is too long\", bcf_seqname_safe(h,v), v->pos+1);\n         v->errcode |= BCF_ERR_LIMITS;\n \n         v->n_fmt = 0;\n         return -1;\n     }\n \n     return 0;\n }\n \n", "target": "// fix_start\n\n        if ((uint64_t) mem->l + v->n_sample * (uint64_t)f->size > INT_MAX) {\n// fix_end\n// fix_start\n\n        f->offset = mem->l;\n// fix_end\n", "cwe": "CWE-787", "cwe_name": "Out-of-bounds Write", "cve": "CVE-2020-36403", "cve_desc": "HTSlib through 1.10.2 allows out-of-bounds write access in vcf_parse_format (called from vcf_parse and vcf_read).", "project": "htslib", "idx": 207837}
{"source": " int hci_req_sync(struct hci_dev *hdev, int (*req)(struct hci_request *req,\n \t\t\t\t\t\t  unsigned long opt),\n \t\t unsigned long opt, u32 timeout, u8 *hci_status)\n {\n \tint ret;\n \n// bug_start\n\tif (!test_bit(HCI_UP, &hdev->flags))\n\t\treturn -ENETDOWN;\n\n// bug_end\n \thci_req_sync_lock(hdev);\n// bug_start\n\tret = __hci_req_sync(hdev, req, opt, timeout, hci_status);\n// bug_end\n \thci_req_sync_unlock(hdev);\n \n \treturn ret;\n }\n \n", "target": "// fix_start\n// fix_end\n// fix_start\n\tif (test_bit(HCI_UP, &hdev->flags))\n\t\tret = __hci_req_sync(hdev, req, opt, timeout, hci_status);\n\telse\n\t\tret = -ENETDOWN;\n// fix_end\n", "cwe": "CWE-362", "cwe_name": "Concurrent Execution using Shared Resource with Improper Synchronization ('Race Condition')", "cve": "CVE-2021-32399", "cve_desc": "net/bluetooth/hci_request.c in the Linux kernel through 5.12.2 has a race condition for removal of the HCI controller.", "project": "linux", "idx": 207859}
{"source": " static UINT parallel_process_irp_create(PARALLEL_DEVICE* parallel, IRP* irp)\n {\n \tchar* path = NULL;\n \tint status;\n// bug_start\n// bug_end\n \tUINT32 PathLength;\n// bug_start\n\tStream_Seek(irp->input, 28);\n// bug_end\n \tStream_Read_UINT32(irp->input, PathLength);\n// bug_start\n\tstatus = ConvertFromUnicode(CP_UTF8, 0, (WCHAR*)Stream_Pointer(irp->input), PathLength / 2,\n\t                            &path, 0, NULL, NULL);\n// bug_end\n \n \tif (status < 1)\n \t\tif (!(path = (char*)calloc(1, 1)))\n \t\t{\n \t\t\tWLog_ERR(TAG, \"calloc failed!\");\n \t\t\treturn CHANNEL_RC_NO_MEMORY;\n \t\t}\n \n \tparallel->id = irp->devman->id_sequence++;\n \tparallel->file = open(parallel->path, O_RDWR);\n \n \tif (parallel->file < 0)\n \t{\n \t\tirp->IoStatus = STATUS_ACCESS_DENIED;\n \t\tparallel->id = 0;\n \t}\n \telse\n \t{\n \t\tif (fcntl(parallel->file, F_SETFL, O_NONBLOCK) == -1)\n \t\t{\n \t\t}\n \t}\n \n \tStream_Write_UINT32(irp->output, parallel->id);\n \tStream_Write_UINT8(irp->output, 0);\n \tfree(path);\n \treturn irp->Complete(irp);\n }\n \n", "target": "// fix_start\n\tWCHAR* ptr;\n// fix_end\n// fix_start\n\tif (!Stream_SafeSeek(irp->input, 28))\n\t\treturn ERROR_INVALID_DATA;\n\tif (Stream_GetRemainingLength(irp->input) < 4)\n\t\treturn ERROR_INVALID_DATA;\n// fix_end\n// fix_start\n\tptr = (WCHAR*)Stream_Pointer(irp->input);\n\tif (!Stream_SafeSeek(irp->input, PathLength))\n\t\treturn ERROR_INVALID_DATA;\n\tstatus = ConvertFromUnicode(CP_UTF8, 0, ptr, PathLength / 2, &path, 0, NULL, NULL);\n// fix_end\n", "cwe": "CWE-415", "cwe_name": "Double Free", "cve": "CVE-2020-11089", "cve_desc": "In FreeRDP before 2.1.0, there is an out-of-bound read in irp functions (parallel_process_irp_create, serial_process_irp_create, drive_process_irp_write, printer_process_irp_write, rdpei_recv_pdu, serial_process_irp_write). This has been fixed in 2.1.0.", "project": "FreeRDP", "idx": 207960}
{"source": " exif_data_load_data_thumbnail (ExifData *data, const unsigned char *d,\n \t\t\t       unsigned int ds, ExifLong o, ExifLong s)\n {\n \tif (o >= ds) {\n \t\texif_log (data->priv->log, EXIF_LOG_CODE_DEBUG, \"ExifData\", \"Bogus thumbnail offset (%u).\", o);\n \t\treturn;\n \t}\n// bug_start\n\tif (s > ds - o) {\n// bug_end\n \t\texif_log (data->priv->log, EXIF_LOG_CODE_DEBUG, \"ExifData\", \"Bogus thumbnail size (%u), max would be %u.\", s, ds-o);\n \t\treturn;\n \t}\n \tif (data->data)\n \t\texif_mem_free (data->priv->mem, data->data);\n \tif (!(data->data = exif_data_alloc (data, s))) {\n \t\tEXIF_LOG_NO_MEMORY (data->priv->log, \"ExifData\", s);\n \t\tdata->size = 0;\n \t\treturn;\n \t}\n \tdata->size = s;\n \tmemcpy (data->data, d + o, s);\n }\n \n", "target": "// fix_start\n\tif (CHECKOVERFLOW(o,ds,s)) {\n// fix_end\n", "cwe": "CWE-190", "cwe_name": "Integer Overflow or Wraparound", "cve": "CVE-2020-0181", "cve_desc": "In exif_data_load_data_thumbnail of exif-data.c, there is a possible denial of service due to an integer overflow. This could lead to remote denial of service with no additional execution privileges needed. User interaction is not needed for exploitation.Product: AndroidVersions: Android-10Android ID: A-145075076", "project": "libexif", "idx": 207982}
{"source": " static int hva_to_pfn_remapped(struct vm_area_struct *vma,\n \t\t\t       unsigned long addr, bool *async,\n \t\t\t       bool write_fault, bool *writable,\n \t\t\t       kvm_pfn_t *p_pfn)\n {\n \tkvm_pfn_t pfn;\n \tpte_t *ptep;\n \tspinlock_t *ptl;\n \tint r;\n \n \tr = follow_pte(vma->vm_mm, addr, &ptep, &ptl);\n \tif (r) {\n \t\tbool unlocked = false;\n \t\tr = fixup_user_fault(current->mm, addr,\n \t\t\t\t     (write_fault ? FAULT_FLAG_WRITE : 0),\n \t\t\t\t     &unlocked);\n \t\tif (unlocked)\n \t\t\treturn -EAGAIN;\n \t\tif (r)\n \t\t\treturn r;\n \n \t\tr = follow_pte(vma->vm_mm, addr, &ptep, &ptl);\n \t\tif (r)\n \t\t\treturn r;\n \t}\n \n \tif (write_fault && !pte_write(*ptep)) {\n \t\tpfn = KVM_PFN_ERR_RO_FAULT;\n \t\tgoto out;\n \t}\n \n \tif (writable)\n \t\t*writable = pte_write(*ptep);\n \tpfn = pte_pfn(*ptep);\n \n// bug_start\n\tkvm_get_pfn(pfn);\n// bug_end\n \n out:\n \tpte_unmap_unlock(ptep, ptl);\n \t*p_pfn = pfn;\n// bug_start\n\treturn 0;\n// bug_end\n }\n \n", "target": "// fix_start\n\tif (!kvm_try_get_pfn(pfn))\n\t\tr = -EFAULT;\n// fix_end\n// fix_start\n\n\treturn r;\n// fix_end\n", "cwe": "CWE-119", "cwe_name": "Improper Restriction of Operations within the Bounds of a Memory Buffer", "cve": "CVE-2021-22543", "cve_desc": "An issue was discovered in Linux: KVM through Improper handling of VM_IO|VM_PFNMAP vmas in KVM can bypass RO checks and can lead to pages being freed while still accessible by the VMM and guest. This allows users with the ability to start and control a VM to read/write random pages of memory and can result in local privilege escalation.", "project": "linux", "idx": 207984}
{"source": " file_rlookup(const char *filename)\n {\n   int\t\ti;\n   cache_t\t*wc;\n \n \n   for (i = web_files, wc = web_cache; i > 0; i --, wc ++)\n// bug_start\n// bug_end\n     if (!strcmp(wc->name, filename))\n// bug_start\n      return (wc->url);\n// bug_end\n \n   return (filename);\n }\n \n", "target": "// fix_start\n  {\n// fix_end\n// fix_start\n    {\n      if (!strncmp(wc->url, \"data:\", 5))\n        return (\"data URL\");\n      else\n        return (wc->url);\n    }\n  }\n// fix_end\n", "cwe": "CWE-415", "cwe_name": "Double Free", "cve": "CVE-2021-23191", "cve_desc": "A security issue was found in htmldoc v1.9.12 and before. A NULL pointer dereference in the function image_load_jpeg() in image.cxx may result in denial of service.", "project": "htmldoc", "idx": 207988}
{"source": " static Image *ReadSVGImage(const ImageInfo *image_info,ExceptionInfo *exception)\n {\n   char\n     filename[MagickPathExtent];\n \n   const char\n     *option;\n \n   FILE\n     *file;\n \n   Image\n     *image,\n     *next;\n \n   int\n     status,\n     unique_file;\n \n   ssize_t\n     n;\n \n   SVGInfo\n     *svg_info;\n \n   unsigned char\n     message[MagickPathExtent];\n \n   xmlSAXHandler\n     sax_modules;\n \n   xmlSAXHandlerPtr\n     sax_handler;\n \n   assert(image_info != (const ImageInfo *) NULL);\n   assert(image_info->signature == MagickCoreSignature);\n   assert(exception != (ExceptionInfo *) NULL);\n   if (image_info->debug != MagickFalse)\n     (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n       image_info->filename);\n   assert(exception->signature == MagickCoreSignature);\n   image=AcquireImage(image_info,exception);\n   status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n   if (status == MagickFalse)\n     {\n       image=DestroyImageList(image);\n       return((Image *) NULL);\n     }\n   if ((fabs(image->resolution.x) < MagickEpsilon) ||\n       (fabs(image->resolution.y) < MagickEpsilon))\n     {\n       GeometryInfo\n         geometry_info;\n \n       int\n         flags;\n \n       flags=ParseGeometry(SVGDensityGeometry,&geometry_info);\n       image->resolution.x=geometry_info.rho;\n       image->resolution.y=geometry_info.sigma;\n       if ((flags & SigmaValue) == 0)\n         image->resolution.y=image->resolution.x;\n     }\n   if (LocaleCompare(image_info->magick,\"MSVG\") != 0)\n     {\n       Image\n         *svg_image;\n \n       svg_image=RenderSVGImage(image_info,image,exception);\n       if (svg_image != (Image *) NULL)\n         {\n           image=DestroyImageList(image);\n           return(svg_image);\n         }\n       {\n #if defined(MAGICKCORE_RSVG_DELEGATE)\n #if defined(MAGICKCORE_CAIRO_DELEGATE)\n         cairo_surface_t\n           *cairo_surface;\n \n         cairo_t\n           *cairo_image;\n \n         MagickBooleanType\n           apply_density;\n \n         MemoryInfo\n           *pixel_info;\n \n         register unsigned char\n           *p;\n \n         RsvgDimensionData\n           dimension_info;\n \n         unsigned char\n           *pixels;\n \n #else\n         GdkPixbuf\n           *pixel_buffer;\n \n         register const guchar\n           *p;\n #endif\n \n         GError\n           *error;\n \n         PixelInfo\n           fill_color;\n \n         register ssize_t\n           x;\n \n         register Quantum\n           *q;\n \n         RsvgHandle\n           *svg_handle;\n \n         ssize_t\n           y;\n \n         unsigned char\n           *buffer;\n \n         buffer=(unsigned char *) AcquireQuantumMemory(MagickMaxBufferExtent,\n           sizeof(*buffer));\n         if (buffer == (unsigned char *) NULL)\n           ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n #if LIBRSVG_CHECK_VERSION(2,40,3)\n         option=GetImageOption(image_info,\"svg:xml-parse-huge\");\n         if ((option != (char *) NULL) && (IsStringTrue(option) != MagickFalse))\n           svg_handle=rsvg_handle_new_with_flags(RSVG_HANDLE_FLAG_UNLIMITED);\n         else\n #endif\n           svg_handle=rsvg_handle_new();\n         if (svg_handle == (RsvgHandle *) NULL)\n           {\n             buffer=(unsigned char *) RelinquishMagickMemory(buffer);\n             ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n           }\n         rsvg_handle_set_base_uri(svg_handle,image_info->filename);\n         if ((fabs(image->resolution.x) > MagickEpsilon) &&\n             (fabs(image->resolution.y) > MagickEpsilon))\n           rsvg_handle_set_dpi_x_y(svg_handle,image->resolution.x,\n             image->resolution.y);\n         while ((n=ReadBlob(image,MagickMaxBufferExtent-1,buffer)) != 0)\n         {\n           buffer[n]='\\0';\n           error=(GError *) NULL;\n           (void) rsvg_handle_write(svg_handle,buffer,n,&error);\n           if (error != (GError *) NULL)\n             g_error_free(error);\n         }\n         buffer=(unsigned char *) RelinquishMagickMemory(buffer);\n         error=(GError *) NULL;\n         rsvg_handle_close(svg_handle,&error);\n         if (error != (GError *) NULL)\n           g_error_free(error);\n #if defined(MAGICKCORE_CAIRO_DELEGATE)\n         apply_density=MagickTrue;\n         rsvg_handle_get_dimensions(svg_handle,&dimension_info);\n         if ((image->resolution.x > 0.0) && (image->resolution.y > 0.0))\n           {\n             RsvgDimensionData\n               dpi_dimension_info;\n \n             rsvg_handle_set_dpi_x_y(svg_handle,image->resolution.x*256,\n               image->resolution.y*256);\n             rsvg_handle_get_dimensions(svg_handle,&dpi_dimension_info);\n             if ((dpi_dimension_info.width != dimension_info.width) ||\n                 (dpi_dimension_info.height != dimension_info.height))\n               apply_density=MagickFalse;\n             rsvg_handle_set_dpi_x_y(svg_handle,image->resolution.x,\n               image->resolution.y);\n           }\n         if (image_info->size != (char *) NULL)\n           {\n             (void) GetGeometry(image_info->size,(ssize_t *) NULL,\n               (ssize_t *) NULL,&image->columns,&image->rows);\n             if ((image->columns != 0) || (image->rows != 0))\n               {\n                 image->resolution.x=DefaultSVGDensity*image->columns/\n                   dimension_info.width;\n                 image->resolution.y=DefaultSVGDensity*image->rows/\n                   dimension_info.height;\n                 if (fabs(image->resolution.x) < MagickEpsilon)\n                   image->resolution.x=image->resolution.y;\n                 else\n                   if (fabs(image->resolution.y) < MagickEpsilon)\n                     image->resolution.y=image->resolution.x;\n                   else\n                     image->resolution.x=image->resolution.y=MagickMin(\n                       image->resolution.x,image->resolution.y);\n                 apply_density=MagickTrue;\n               }\n           }\n         if (apply_density != MagickFalse)\n           {\n             image->columns=image->resolution.x*dimension_info.width/\n               DefaultSVGDensity;\n             image->rows=image->resolution.y*dimension_info.height/\n               DefaultSVGDensity;\n           }\n         else\n           {\n             image->columns=dimension_info.width;\n             image->rows=dimension_info.height;\n           }\n         pixel_info=(MemoryInfo *) NULL;\n #else\n         pixel_buffer=rsvg_handle_get_pixbuf(svg_handle);\n         rsvg_handle_free(svg_handle);\n         image->columns=gdk_pixbuf_get_width(pixel_buffer);\n         image->rows=gdk_pixbuf_get_height(pixel_buffer);\n #endif\n         image->alpha_trait=BlendPixelTrait;\n         if (image_info->ping == MagickFalse)\n           {\n #if defined(MAGICKCORE_CAIRO_DELEGATE)\n             size_t\n               stride;\n #endif\n \n             status=SetImageExtent(image,image->columns,image->rows,exception);\n             if (status == MagickFalse)\n               {\n #if !defined(MAGICKCORE_CAIRO_DELEGATE)\n                 g_object_unref(G_OBJECT(pixel_buffer));\n #endif\n                 g_object_unref(svg_handle);\n                 ThrowReaderException(MissingDelegateError,\n                   \"NoDecodeDelegateForThisImageFormat\");\n               }\n #if defined(MAGICKCORE_CAIRO_DELEGATE)\n             stride=4*image->columns;\n #if defined(MAGICKCORE_PANGOCAIRO_DELEGATE)\n             stride=(size_t) cairo_format_stride_for_width(CAIRO_FORMAT_ARGB32,\n               (int) image->columns);\n #endif\n             pixel_info=AcquireVirtualMemory(stride,image->rows*sizeof(*pixels));\n             if (pixel_info == (MemoryInfo *) NULL)\n               {\n                 g_object_unref(svg_handle);\n                 ThrowReaderException(ResourceLimitError,\n                   \"MemoryAllocationFailed\");\n               }\n             pixels=(unsigned char *) GetVirtualMemoryBlob(pixel_info);\n #endif\n             (void) SetImageBackgroundColor(image,exception);\n #if defined(MAGICKCORE_CAIRO_DELEGATE)\n             cairo_surface=cairo_image_surface_create_for_data(pixels,\n               CAIRO_FORMAT_ARGB32,(int) image->columns,(int) image->rows,(int)\n               stride);\n             if ((cairo_surface == (cairo_surface_t *) NULL) ||\n                 (cairo_surface_status(cairo_surface) != CAIRO_STATUS_SUCCESS))\n               {\n                 if (cairo_surface != (cairo_surface_t *) NULL)\n                   cairo_surface_destroy(cairo_surface);\n                 pixel_info=RelinquishVirtualMemory(pixel_info);\n                 g_object_unref(svg_handle);\n                 ThrowReaderException(ResourceLimitError,\n                   \"MemoryAllocationFailed\");\n               }\n             cairo_image=cairo_create(cairo_surface);\n             cairo_set_operator(cairo_image,CAIRO_OPERATOR_CLEAR);\n             cairo_paint(cairo_image);\n             cairo_set_operator(cairo_image,CAIRO_OPERATOR_OVER);\n             if (apply_density != MagickFalse)\n               cairo_scale(cairo_image,image->resolution.x/DefaultSVGDensity,\n                 image->resolution.y/DefaultSVGDensity);\n             rsvg_handle_render_cairo(svg_handle,cairo_image);\n             cairo_destroy(cairo_image);\n             cairo_surface_destroy(cairo_surface);\n             g_object_unref(svg_handle);\n             p=pixels;\n #else\n             p=gdk_pixbuf_get_pixels(pixel_buffer);\n #endif\n             GetPixelInfo(image,&fill_color);\n             for (y=0; y < (ssize_t) image->rows; y++)\n             {\n               q=GetAuthenticPixels(image,0,y,image->columns,1,exception);\n               if (q == (Quantum *) NULL)\n                 break;\n               for (x=0; x < (ssize_t) image->columns; x++)\n               {\n #if defined(MAGICKCORE_CAIRO_DELEGATE)\n                 fill_color.blue=ScaleCharToQuantum(*p++);\n                 fill_color.green=ScaleCharToQuantum(*p++);\n                 fill_color.red=ScaleCharToQuantum(*p++);\n #else\n                 fill_color.red=ScaleCharToQuantum(*p++);\n                 fill_color.green=ScaleCharToQuantum(*p++);\n                 fill_color.blue=ScaleCharToQuantum(*p++);\n #endif\n                 fill_color.alpha=ScaleCharToQuantum(*p++);\n #if defined(MAGICKCORE_CAIRO_DELEGATE)\n                 {\n                   double\n                     gamma;\n \n                   gamma=QuantumScale*fill_color.alpha;\n                   gamma=PerceptibleReciprocal(gamma);\n                   fill_color.blue*=gamma;\n                   fill_color.green*=gamma;\n                   fill_color.red*=gamma;\n                 }\n #endif\n                 CompositePixelOver(image,&fill_color,fill_color.alpha,q,(double)\n                   GetPixelAlpha(image,q),q);\n                 q+=GetPixelChannels(image);\n               }\n               if (SyncAuthenticPixels(image,exception) == MagickFalse)\n                 break;\n               if (image->previous == (Image *) NULL)\n                 {\n                   status=SetImageProgress(image,LoadImageTag,(MagickOffsetType)\n                     y,image->rows);\n                   if (status == MagickFalse)\n                     break;\n                 }\n             }\n           }\n #if defined(MAGICKCORE_CAIRO_DELEGATE)\n         if (pixel_info != (MemoryInfo *) NULL)\n           pixel_info=RelinquishVirtualMemory(pixel_info);\n #else\n         g_object_unref(G_OBJECT(pixel_buffer));\n #endif\n         (void) CloseBlob(image);\n         for (next=GetFirstImageInList(image); next != (Image *) NULL; )\n         {\n           (void) CopyMagickString(next->filename,image->filename,MaxTextExtent);\n           (void) CopyMagickString(next->magick,image->magick,MaxTextExtent);\n           next=GetNextImageInList(next);\n         }\n         return(GetFirstImageInList(image));\n #endif\n       }\n     }\n   file=(FILE *) NULL;\n   unique_file=AcquireUniqueFileResource(filename);\n   if (unique_file != -1)\n     file=fdopen(unique_file,\"w\");\n   if ((unique_file == -1) || (file == (FILE *) NULL))\n     {\n       (void) CopyMagickString(image->filename,filename,MagickPathExtent);\n       ThrowFileException(exception,FileOpenError,\"UnableToCreateTemporaryFile\",\n         image->filename);\n       image=DestroyImageList(image);\n       return((Image *) NULL);\n     }\n   svg_info=AcquireSVGInfo();\n   if (svg_info == (SVGInfo *) NULL)\n     {\n       (void) fclose(file);\n       ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n     }\n   svg_info->file=file;\n   svg_info->exception=exception;\n   svg_info->image=image;\n   svg_info->image_info=image_info;\n   svg_info->bounds.width=image->columns;\n   svg_info->bounds.height=image->rows;\n   svg_info->svgDepth=0;\n   if (image_info->size != (char *) NULL)\n     (void) CloneString(&svg_info->size,image_info->size);\n   if (image->debug != MagickFalse)\n     (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"begin SAX\");\n   xmlInitParser();\n   (void) xmlSubstituteEntitiesDefault(1);\n   (void) memset(&sax_modules,0,sizeof(sax_modules));\n   sax_modules.internalSubset=SVGInternalSubset;\n   sax_modules.isStandalone=SVGIsStandalone;\n   sax_modules.hasInternalSubset=SVGHasInternalSubset;\n   sax_modules.hasExternalSubset=SVGHasExternalSubset;\n   sax_modules.resolveEntity=SVGResolveEntity;\n   sax_modules.getEntity=SVGGetEntity;\n   sax_modules.entityDecl=SVGEntityDeclaration;\n   sax_modules.notationDecl=SVGNotationDeclaration;\n   sax_modules.attributeDecl=SVGAttributeDeclaration;\n   sax_modules.elementDecl=SVGElementDeclaration;\n   sax_modules.unparsedEntityDecl=SVGUnparsedEntityDeclaration;\n   sax_modules.setDocumentLocator=SVGSetDocumentLocator;\n   sax_modules.startDocument=SVGStartDocument;\n   sax_modules.endDocument=SVGEndDocument;\n   sax_modules.startElement=SVGStartElement;\n   sax_modules.endElement=SVGEndElement;\n   sax_modules.reference=SVGReference;\n   sax_modules.characters=SVGCharacters;\n   sax_modules.ignorableWhitespace=SVGIgnorableWhitespace;\n   sax_modules.processingInstruction=SVGProcessingInstructions;\n   sax_modules.comment=SVGComment;\n   sax_modules.warning=SVGWarning;\n   sax_modules.error=SVGError;\n   sax_modules.fatalError=SVGError;\n   sax_modules.getParameterEntity=SVGGetParameterEntity;\n   sax_modules.cdataBlock=SVGCDataBlock;\n   sax_modules.externalSubset=SVGExternalSubset;\n   sax_handler=(&sax_modules);\n   n=ReadBlob(image,MagickPathExtent-1,message);\n   message[n]='\\0';\n   if (n > 0)\n     {\n       svg_info->parser=xmlCreatePushParserCtxt(sax_handler,svg_info,(char *)\n         message,n,image->filename);\n// bug_start\n      option=GetImageOption(image_info,\"svg:xml-parse-huge\");\n      if ((option != (char *) NULL) && (IsStringTrue(option) != MagickFalse))\n        (void) xmlCtxtUseOptions(svg_info->parser,XML_PARSE_HUGE);\n      while ((n=ReadBlob(image,MagickPathExtent-1,message)) != 0)\n      {\n        message[n]='\\0';\n        status=xmlParseChunk(svg_info->parser,(char *) message,(int) n,0);\n        if (status != 0)\n          break;\n      }\n// bug_end\n     }\n   (void) xmlParseChunk(svg_info->parser,(char *) message,0,1);\n   SVGEndDocument(svg_info);\n   if (svg_info->parser->myDoc != (xmlDocPtr) NULL)\n     xmlFreeDoc(svg_info->parser->myDoc);\n   xmlFreeParserCtxt(svg_info->parser);\n   if (image->debug != MagickFalse)\n     (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"end SAX\");\n   (void) fclose(file);\n   (void) CloseBlob(image);\n   image->columns=svg_info->width;\n   image->rows=svg_info->height;\n   if (exception->severity >= ErrorException)\n     {\n       svg_info=DestroySVGInfo(svg_info);\n       (void) RelinquishUniqueFileResource(filename);\n       image=DestroyImage(image);\n       return((Image *) NULL);\n     }\n   if (image_info->ping == MagickFalse)\n     {\n       ImageInfo\n         *read_info;\n \n       image=DestroyImage(image);\n       image=(Image *) NULL;\n       read_info=CloneImageInfo(image_info);\n       SetImageInfoBlob(read_info,(void *) NULL,0);\n       (void) FormatLocaleString(read_info->filename,MagickPathExtent,\"mvg:%s\",\n         filename);\n       image=ReadImage(read_info,exception);\n       read_info=DestroyImageInfo(read_info);\n       if (image != (Image *) NULL)\n         (void) CopyMagickString(image->filename,image_info->filename,\n           MagickPathExtent);\n     }\n   if (image != (Image *) NULL)\n     {\n       if (svg_info->title != (char *) NULL)\n         (void) SetImageProperty(image,\"svg:title\",svg_info->title,exception);\n       if (svg_info->comment != (char *) NULL)\n         (void) SetImageProperty(image,\"svg:comment\",svg_info->comment,\n           exception);\n     }\n   for (next=GetFirstImageInList(image); next != (Image *) NULL; )\n   {\n     (void) CopyMagickString(next->filename,image->filename,MaxTextExtent);\n     (void) CopyMagickString(next->magick,image->magick,MaxTextExtent);\n     next=GetNextImageInList(next);\n   }\n   svg_info=DestroySVGInfo(svg_info);\n   (void) RelinquishUniqueFileResource(filename);\n   return(GetFirstImageInList(image));\n }\n \n", "target": "// fix_start\n      if (svg_info->parser != (xmlParserCtxtPtr) NULL)\n        {\n          option=GetImageOption(image_info,\"svg:xml-parse-huge\");\n          if ((option != (char *) NULL) && (IsStringTrue(option) != MagickFalse))\n            (void) xmlCtxtUseOptions(svg_info->parser,XML_PARSE_HUGE);\n          while ((n=ReadBlob(image,MagickPathExtent-1,message)) != 0)\n          {\n            message[n]='\\0';\n            status=xmlParseChunk(svg_info->parser,(char *) message,(int) n,0);\n            if (status != 0)\n              break;\n          }\n        }\n    }\n  if (svg_info->parser == (xmlParserCtxtPtr) NULL)\n    {\n      svg_info=DestroySVGInfo(svg_info);\n      (void) RelinquishUniqueFileResource(filename);\n      image=DestroyImage(image);\n      return((Image *) NULL);\n// fix_end\n", "cwe": "CWE-476", "cwe_name": "NULL Pointer Dereference", "cve": "CVE-2021-3596", "cve_desc": "A NULL pointer dereference flaw was found in ImageMagick in versions prior to 7.0.10-31 in ReadSVGImage() in coders/svg.c. This issue is due to not checking the return value from libxml2's xmlCreatePushParserCtxt() and uses the value directly, which leads to a crash and segmentation fault.", "project": "ImageMagick", "idx": 208034}
{"source": " convert(\n     Imaging imOut, Imaging imIn, const char *mode, ImagingPalette palette, int dither) {\n     ImagingSectionCookie cookie;\n     ImagingShuffler convert;\n     int y;\n \n     if (!imIn) {\n         return (Imaging)ImagingError_ModeError();\n     }\n \n     if (!mode) {\n         if (!imIn->palette) {\n             return (Imaging)ImagingError_ModeError();\n         }\n         mode = imIn->palette->mode;\n     } else {\n         if (!strcmp(imIn->mode, mode)) {\n             return ImagingCopy2(imOut, imIn);\n         }\n     }\n \n \n     if (strcmp(imIn->mode, \"P\") == 0 || strcmp(imIn->mode, \"PA\") == 0) {\n         return frompalette(imOut, imIn, mode);\n     }\n \n     if (strcmp(mode, \"P\") == 0 || strcmp(mode, \"PA\") == 0) {\n         return topalette(imOut, imIn, mode, palette, dither);\n     }\n \n     if (dither && strcmp(mode, \"1\") == 0) {\n         return tobilevel(imOut, imIn, dither);\n     }\n \n \n     convert = NULL;\n \n     for (y = 0; converters[y].from; y++) {\n         if (!strcmp(imIn->mode, converters[y].from) &&\n             !strcmp(mode, converters[y].to)) {\n             convert = converters[y].convert;\n             break;\n         }\n     }\n \n     if (!convert) {\n #ifdef notdef\n         return (Imaging)ImagingError_ValueError(\"conversion not supported\");\n #else\n         static char buf[100];\n// bug_start\n        sprintf(buf, \"conversion from %.10s to %.10s not supported\", imIn->mode, mode);\n// bug_end\n         return (Imaging)ImagingError_ValueError(buf);\n #endif\n     }\n \n     imOut = ImagingNew2Dirty(mode, imOut, imIn);\n     if (!imOut) {\n         return NULL;\n     }\n \n     ImagingSectionEnter(&cookie);\n     for (y = 0; y < imIn->ysize; y++) {\n         (*convert)((UINT8 *)imOut->image[y], (UINT8 *)imIn->image[y], imIn->xsize);\n     }\n     ImagingSectionLeave(&cookie);\n \n     return imOut;\n }\n \n", "target": "// fix_start\n        snprintf(buf, 100, \"conversion from %.10s to %.10s not supported\", imIn->mode, mode);\n// fix_end\n", "cwe": "CWE-120", "cwe_name": "Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')", "cve": "CVE-2021-34552", "cve_desc": "Pillow through 8.2.0 and PIL (aka Python Imaging Library) through 1.1.7 allow an attacker to pass controlled parameters directly into a convert function to trigger a buffer overflow in Convert.c.", "project": "Pillow", "idx": 208176}
{"source": " MagickExport void ScaleResampleFilter(ResampleFilter *resample_filter,\n   const double dux,const double duy,const double dvx,const double dvy)\n {\n   double A,B,C,F;\n \n   assert(resample_filter != (ResampleFilter *) NULL);\n   assert(resample_filter->signature == MagickCoreSignature);\n \n   resample_filter->limit_reached = MagickFalse;\n \n   if ( resample_filter->filter == PointFilter )\n     return;\n \n #if DEBUG_ELLIPSE\n   (void) FormatLocaleFile(stderr, \"# -----\\n\" );\n   (void) FormatLocaleFile(stderr, \"dux=%lf; dvx=%lf;   duy=%lf; dvy=%lf;\\n\",\n        dux, dvx, duy, dvy);\n #endif\n \n #if EWA\n #if EWA_CLAMP\n   { double major_mag,\n            minor_mag,\n            major_x,\n            major_y,\n            minor_x,\n            minor_y;\n \n   ClampUpAxes(dux,dvx,duy,dvy, &major_mag, &minor_mag,\n                 &major_x, &major_y, &minor_x, &minor_y);\n   major_x *= major_mag;  major_y *= major_mag;\n   minor_x *= minor_mag;  minor_y *= minor_mag;\n #if DEBUG_ELLIPSE\n   (void) FormatLocaleFile(stderr, \"major_x=%lf; major_y=%lf;  minor_x=%lf; minor_y=%lf;\\n\",\n         major_x, major_y, minor_x, minor_y);\n #endif\n   A = major_y*major_y+minor_y*minor_y;\n   B = -2.0*(major_x*major_y+minor_x*minor_y);\n   C = major_x*major_x+minor_x*minor_x;\n   F = major_mag*minor_mag;\n   F *= F;\n   }\n #else\n   A = dvx*dvx+dvy*dvy;\n   B = -2.0*(dux*dvx+duy*dvy);\n   C = dux*dux+duy*duy;\n   F = dux*dvy-duy*dvx;\n   F *= F;\n #endif\n \n #else\n   A = dvx*dvx+dvy*dvy+1;\n   B = -2.0*(dux*dvx+duy*dvy);\n   C = dux*dux+duy*duy+1;\n   F = A*C - B*B/4;\n #endif\n \n #if DEBUG_ELLIPSE\n   (void) FormatLocaleFile(stderr, \"A=%lf; B=%lf; C=%lf; F=%lf\\n\", A,B,C,F);\n \n   { double alpha, beta, gamma, Major, Minor;\n     double Eccentricity, Ellipse_Area, Ellipse_Angle;\n \n     alpha = A+C;\n     beta  = A-C;\n     gamma = sqrt(beta*beta + B*B );\n \n     if ( alpha - gamma <= MagickEpsilon )\n       Major=MagickMaximumValue;\n     else\n       Major=sqrt(2*F/(alpha - gamma));\n     Minor = sqrt(2*F/(alpha + gamma));\n \n     (void) FormatLocaleFile(stderr, \"# Major=%lf; Minor=%lf\\n\", Major, Minor );\n \n     Eccentricity = Major/Minor;\n     Ellipse_Area = MagickPI*Major*Minor;\n     Ellipse_Angle = atan2(B, A-C);\n \n     (void) FormatLocaleFile(stderr, \"# Angle=%lf   Area=%lf\\n\",\n          (double) RadiansToDegrees(Ellipse_Angle), Ellipse_Area);\n   }\n #endif\n \n   if ( (4*A*C - B*B) > MagickMaximumValue ) {\n     resample_filter->limit_reached = MagickTrue;\n     return;\n   }\n \n   F *= resample_filter->support;\n   F *= resample_filter->support;\n \n   resample_filter->Ulimit = sqrt(C*F/(A*C-0.25*B*B));\n   resample_filter->Vlimit = sqrt(A*F/(A*C-0.25*B*B));\n \n   resample_filter->Uwidth = sqrt(F/A);\n   resample_filter->slope = -B/(2.0*A);\n \n #if DEBUG_ELLIPSE\n   (void) FormatLocaleFile(stderr, \"Ulimit=%lf; Vlimit=%lf; UWidth=%lf; Slope=%lf;\\n\",\n            resample_filter->Ulimit, resample_filter->Vlimit,\n            resample_filter->Uwidth, resample_filter->slope );\n #endif\n \n   if ( (resample_filter->Uwidth * resample_filter->Vlimit)\n          > (4.0*resample_filter->image_area)) {\n     resample_filter->limit_reached = MagickTrue;\n     return;\n   }\n \n   { double scale;\n #if FILTER_LUT\n// bug_start\n    scale = (double)WLUT_WIDTH/F;\n// bug_end\n #else\n// bug_start\n    scale = resample_filter->F/F;\n// bug_end\n #endif\n     resample_filter->A = A*scale;\n     resample_filter->B = B*scale;\n     resample_filter->C = C*scale;\n   }\n }\n \n", "target": "// fix_start\n    scale=(double) WLUT_WIDTH*PerceptibleReciprocal(F);\n// fix_end\n// fix_start\n    scale=resample_filter->F*PerceptibleReciprocal(F);\n// fix_end\n", "cwe": "CWE-369", "cwe_name": "Divide By Zero", "cve": "CVE-2021-20246", "cve_desc": "A flaw was found in ImageMagick in MagickCore/resample.c. An attacker who submits a crafted file that is processed by ImageMagick could trigger undefined behavior in the form of math division by zero. The highest threat from this vulnerability is to system availability.", "project": "ImageMagick", "idx": 208186}
{"source": " handle_spawn (PortalFlatpak         *object,\n               GDBusMethodInvocation *invocation,\n               GUnixFDList           *fd_list,\n               const gchar           *arg_cwd_path,\n               const gchar *const    *arg_argv,\n               GVariant              *arg_fds,\n               GVariant              *arg_envs,\n               guint                  arg_flags,\n               GVariant              *arg_options)\n {\n   g_autoptr(GError) error = NULL;\n   ChildSetupData child_setup_data = { NULL };\n   GPid pid;\n   PidData *pid_data;\n   InstanceIdReadData *instance_id_read_data = NULL;\n   gsize i, j, n_fds, n_envs;\n   const gint *fds = NULL;\n   gint fds_len = 0;\n   g_autofree FdMapEntry *fd_map = NULL;\n   gchar **env;\n   gint32 max_fd;\n   GKeyFile *app_info;\n   g_autoptr(GPtrArray) flatpak_argv = g_ptr_array_new_with_free_func (g_free);\n   g_autofree char *app_id = NULL;\n   g_autofree char *branch = NULL;\n   g_autofree char *arch = NULL;\n   g_autofree char *app_commit = NULL;\n   g_autofree char *runtime_ref = NULL;\n   g_auto(GStrv) runtime_parts = NULL;\n   g_autofree char *runtime_commit = NULL;\n   g_autofree char *instance_path = NULL;\n   g_auto(GStrv) extra_args = NULL;\n   g_auto(GStrv) shares = NULL;\n   g_auto(GStrv) sockets = NULL;\n   g_auto(GStrv) devices = NULL;\n   g_auto(GStrv) sandbox_expose = NULL;\n   g_auto(GStrv) sandbox_expose_ro = NULL;\n   g_autoptr(GVariant) sandbox_expose_fd = NULL;\n   g_autoptr(GVariant) sandbox_expose_fd_ro = NULL;\n   g_autoptr(GOutputStream) instance_id_out_stream = NULL;\n   guint sandbox_flags = 0;\n   gboolean sandboxed;\n   gboolean expose_pids;\n   gboolean share_pids;\n   gboolean notify_start;\n   gboolean devel;\n   g_autoptr(GString) env_string = g_string_new (\"\");\n \n   child_setup_data.instance_id_fd = -1;\n   child_setup_data.env_fd = -1;\n \n   if (fd_list != NULL)\n     fds = g_unix_fd_list_peek_fds (fd_list, &fds_len);\n \n   app_info = g_object_get_data (G_OBJECT (invocation), \"app-info\");\n   g_assert (app_info != NULL);\n \n   app_id = g_key_file_get_string (app_info,\n                                   FLATPAK_METADATA_GROUP_APPLICATION,\n                                   FLATPAK_METADATA_KEY_NAME, NULL);\n   g_assert (app_id != NULL);\n \n   g_debug (\"spawn() called from app: '%s'\", app_id);\n   if (*app_id == 0)\n     {\n       g_dbus_method_invocation_return_error (invocation, G_DBUS_ERROR,\n                                              G_DBUS_ERROR_INVALID_ARGS,\n                                              \"org.freedesktop.portal.Flatpak.Spawn only works in a flatpak\");\n       return G_DBUS_METHOD_INVOCATION_HANDLED;\n     }\n \n   if (*arg_cwd_path == 0)\n     arg_cwd_path = NULL;\n \n   if (arg_argv == NULL || *arg_argv == NULL)\n     {\n       g_dbus_method_invocation_return_error (invocation, G_DBUS_ERROR,\n                                              G_DBUS_ERROR_INVALID_ARGS,\n                                              \"No command given\");\n       return G_DBUS_METHOD_INVOCATION_HANDLED;\n     }\n \n   if ((arg_flags & ~FLATPAK_SPAWN_FLAGS_ALL) != 0)\n     {\n       g_dbus_method_invocation_return_error (invocation, G_DBUS_ERROR, G_DBUS_ERROR_INVALID_ARGS,\n                                              \"Unsupported flags enabled: 0x%x\", arg_flags & ~FLATPAK_SPAWN_FLAGS_ALL);\n       return G_DBUS_METHOD_INVOCATION_HANDLED;\n     }\n \n   runtime_ref = g_key_file_get_string (app_info,\n                                        FLATPAK_METADATA_GROUP_APPLICATION,\n                                        FLATPAK_METADATA_KEY_RUNTIME, NULL);\n   if (runtime_ref == NULL)\n     {\n       g_dbus_method_invocation_return_error (invocation, G_DBUS_ERROR, G_DBUS_ERROR_INVALID_ARGS,\n                                              \"No runtime found\");\n       return G_DBUS_METHOD_INVOCATION_HANDLED;\n     }\n \n   runtime_parts = g_strsplit (runtime_ref, \"/\", -1);\n \n   branch = g_key_file_get_string (app_info,\n                                   FLATPAK_METADATA_GROUP_INSTANCE,\n                                   FLATPAK_METADATA_KEY_BRANCH, NULL);\n   instance_path = g_key_file_get_string (app_info,\n                                          FLATPAK_METADATA_GROUP_INSTANCE,\n                                          FLATPAK_METADATA_KEY_INSTANCE_PATH, NULL);\n   arch = g_key_file_get_string (app_info,\n                                 FLATPAK_METADATA_GROUP_INSTANCE,\n                                 FLATPAK_METADATA_KEY_ARCH, NULL);\n   extra_args = g_key_file_get_string_list (app_info,\n                                            FLATPAK_METADATA_GROUP_INSTANCE,\n                                            FLATPAK_METADATA_KEY_EXTRA_ARGS, NULL, NULL);\n   app_commit = g_key_file_get_string (app_info,\n                                       FLATPAK_METADATA_GROUP_INSTANCE,\n                                       FLATPAK_METADATA_KEY_APP_COMMIT, NULL);\n   runtime_commit = g_key_file_get_string (app_info,\n                                           FLATPAK_METADATA_GROUP_INSTANCE,\n                                           FLATPAK_METADATA_KEY_RUNTIME_COMMIT, NULL);\n   shares = g_key_file_get_string_list (app_info, FLATPAK_METADATA_GROUP_CONTEXT,\n                                        FLATPAK_METADATA_KEY_SHARED, NULL, NULL);\n   sockets = g_key_file_get_string_list (app_info, FLATPAK_METADATA_GROUP_CONTEXT,\n                                        FLATPAK_METADATA_KEY_SOCKETS, NULL, NULL);\n   devices = g_key_file_get_string_list (app_info, FLATPAK_METADATA_GROUP_CONTEXT,\n                                         FLATPAK_METADATA_KEY_DEVICES, NULL, NULL);\n \n   devel = g_key_file_get_boolean (app_info, FLATPAK_METADATA_GROUP_INSTANCE,\n                                   FLATPAK_METADATA_KEY_DEVEL, NULL);\n \n   g_variant_lookup (arg_options, \"sandbox-expose\", \"^as\", &sandbox_expose);\n   g_variant_lookup (arg_options, \"sandbox-expose-ro\", \"^as\", &sandbox_expose_ro);\n   g_variant_lookup (arg_options, \"sandbox-flags\", \"u\", &sandbox_flags);\n   sandbox_expose_fd = g_variant_lookup_value (arg_options, \"sandbox-expose-fd\", G_VARIANT_TYPE (\"ah\"));\n   sandbox_expose_fd_ro = g_variant_lookup_value (arg_options, \"sandbox-expose-fd-ro\", G_VARIANT_TYPE (\"ah\"));\n \n   if ((sandbox_flags & ~FLATPAK_SPAWN_SANDBOX_FLAGS_ALL) != 0)\n     {\n       g_dbus_method_invocation_return_error (invocation, G_DBUS_ERROR, G_DBUS_ERROR_INVALID_ARGS,\n                                              \"Unsupported sandbox flags enabled: 0x%x\", arg_flags & ~FLATPAK_SPAWN_SANDBOX_FLAGS_ALL);\n       return G_DBUS_METHOD_INVOCATION_HANDLED;\n     }\n \n   if (instance_path == NULL &&\n       ((sandbox_expose != NULL && sandbox_expose[0] != NULL) ||\n        (sandbox_expose_ro != NULL && sandbox_expose_ro[0] != NULL)))\n     {\n       g_dbus_method_invocation_return_error (invocation, G_DBUS_ERROR,\n                                              G_DBUS_ERROR_INVALID_ARGS,\n                                              \"Invalid sandbox expose, caller has no instance path\");\n       return G_DBUS_METHOD_INVOCATION_HANDLED;\n     }\n \n   for (i = 0; sandbox_expose != NULL && sandbox_expose[i] != NULL; i++)\n     {\n       const char *expose = sandbox_expose[i];\n \n       g_debug (\"exposing %s\", expose);\n       if (!is_valid_expose (expose, &error))\n         {\n           g_dbus_method_invocation_return_gerror (invocation, error);\n           return G_DBUS_METHOD_INVOCATION_HANDLED;\n         }\n     }\n \n   for (i = 0; sandbox_expose_ro != NULL && sandbox_expose_ro[i] != NULL; i++)\n     {\n       const char *expose = sandbox_expose_ro[i];\n       g_debug (\"exposing %s\", expose);\n       if (!is_valid_expose (expose, &error))\n         {\n           g_dbus_method_invocation_return_gerror (invocation, error);\n           return G_DBUS_METHOD_INVOCATION_HANDLED;\n         }\n     }\n \n   g_debug (\"Running spawn command %s\", arg_argv[0]);\n \n   n_fds = 0;\n   if (fds != NULL)\n     n_fds = g_variant_n_children (arg_fds);\n   fd_map = g_new0 (FdMapEntry, n_fds);\n \n   child_setup_data.fd_map = fd_map;\n   child_setup_data.fd_map_len = n_fds;\n \n   max_fd = -1;\n   for (i = 0; i < n_fds; i++)\n     {\n       gint32 handle, dest_fd;\n       int handle_fd;\n \n       g_variant_get_child (arg_fds, i, \"{uh}\", &dest_fd, &handle);\n \n       if (handle >= fds_len || handle < 0)\n         {\n           g_dbus_method_invocation_return_error (invocation, G_DBUS_ERROR,\n                                                  G_DBUS_ERROR_INVALID_ARGS,\n                                                  \"No file descriptor for handle %d\",\n                                                  handle);\n           return G_DBUS_METHOD_INVOCATION_HANDLED;\n         }\n \n       handle_fd = fds[handle];\n \n       fd_map[i].to = dest_fd;\n       fd_map[i].from = handle_fd;\n       fd_map[i].final = fd_map[i].to;\n \n       if ((dest_fd == 0 || dest_fd == 1 || dest_fd == 2) &&\n           !child_setup_data.set_tty &&\n           isatty (handle_fd))\n         {\n           child_setup_data.set_tty = TRUE;\n           child_setup_data.tty = handle_fd;\n         }\n \n       max_fd = MAX (max_fd, fd_map[i].to);\n       max_fd = MAX (max_fd, fd_map[i].from);\n     }\n \n   for (i = 0; i < n_fds; i++)\n     {\n       int to_fd = fd_map[i].to;\n       gboolean conflict = FALSE;\n \n       for (j = i + 1; j < n_fds; j++)\n         {\n           int from_fd = fd_map[j].from;\n           if (from_fd == to_fd)\n             {\n               conflict = TRUE;\n               break;\n             }\n         }\n \n       if (conflict)\n         fd_map[i].to = ++max_fd;\n     }\n \n   if (arg_flags & FLATPAK_SPAWN_FLAGS_CLEAR_ENV)\n     {\n       char *empty[] = { NULL };\n       env = g_strdupv (empty);\n     }\n   else\n     env = g_get_environ ();\n \n   n_envs = g_variant_n_children (arg_envs);\n   for (i = 0; i < n_envs; i++)\n     {\n       const char *var = NULL;\n       const char *val = NULL;\n       g_variant_get_child (arg_envs, i, \"{&s&s}\", &var, &val);\n \n// bug_start\n      env = g_environ_setenv (env, var, val, TRUE);\n// bug_end\n     }\n \n   g_ptr_array_add (flatpak_argv, g_strdup (\"flatpak\"));\n   g_ptr_array_add (flatpak_argv, g_strdup (\"run\"));\n \n   sandboxed = (arg_flags & FLATPAK_SPAWN_FLAGS_SANDBOX) != 0;\n \n   if (sandboxed)\n     {\n       g_ptr_array_add (flatpak_argv, g_strdup (\"--sandbox\"));\n \n       if (sandbox_flags & FLATPAK_SPAWN_SANDBOX_FLAGS_SHARE_DISPLAY)\n         {\n           if (sockets != NULL && g_strv_contains ((const char * const *) sockets, \"wayland\"))\n             g_ptr_array_add (flatpak_argv, g_strdup (\"--socket=wayland\"));\n           if (sockets != NULL && g_strv_contains ((const char * const *) sockets, \"fallback-x11\"))\n             g_ptr_array_add (flatpak_argv, g_strdup (\"--socket=fallback-x11\"));\n           if (sockets != NULL && g_strv_contains ((const char * const *) sockets, \"x11\"))\n             g_ptr_array_add (flatpak_argv, g_strdup (\"--socket=x11\"));\n           if (shares != NULL && g_strv_contains ((const char * const *) shares, \"ipc\") &&\n               sockets != NULL && (g_strv_contains ((const char * const *) sockets, \"fallback-x11\") ||\n                                   g_strv_contains ((const char * const *) sockets, \"x11\")))\n             g_ptr_array_add (flatpak_argv, g_strdup (\"--share=ipc\"));\n         }\n       if (sandbox_flags & FLATPAK_SPAWN_SANDBOX_FLAGS_SHARE_SOUND)\n         {\n           if (sockets != NULL && g_strv_contains ((const char * const *) sockets, \"pulseaudio\"))\n             g_ptr_array_add (flatpak_argv, g_strdup (\"--socket=pulseaudio\"));\n         }\n       if (sandbox_flags & FLATPAK_SPAWN_SANDBOX_FLAGS_SHARE_GPU)\n         {\n           if (devices != NULL &&\n               (g_strv_contains ((const char * const *) devices, \"dri\") ||\n                g_strv_contains ((const char * const *) devices, \"all\")))\n             g_ptr_array_add (flatpak_argv, g_strdup (\"--device=dri\"));\n         }\n       if (sandbox_flags & FLATPAK_SPAWN_SANDBOX_FLAGS_ALLOW_DBUS)\n         g_ptr_array_add (flatpak_argv, g_strdup (\"--session-bus\"));\n       if (sandbox_flags & FLATPAK_SPAWN_SANDBOX_FLAGS_ALLOW_A11Y)\n         g_ptr_array_add (flatpak_argv, g_strdup (\"--a11y-bus\"));\n     }\n   else\n     {\n       for (i = 0; extra_args != NULL && extra_args[i] != NULL; i++)\n         {\n           if (g_str_has_prefix (extra_args[i], \"--env=\"))\n             {\n               const char *var_val = extra_args[i] + strlen (\"--env=\");\n \n               if (var_val[0] == '\\0' || var_val[0] == '=')\n                 {\n                   g_warning (\"Environment variable in extra-args has empty name\");\n                   continue;\n                 }\n \n               if (strchr (var_val, '=') == NULL)\n                 {\n                   g_warning (\"Environment variable in extra-args has no value\");\n                   continue;\n                 }\n \n               g_string_append (env_string, var_val);\n               g_string_append_c (env_string, '\\0');\n             }\n           else\n             {\n               g_ptr_array_add (flatpak_argv, g_strdup (extra_args[i]));\n             }\n         }\n     }\n \n   if (env_string->len > 0)\n     {\n       g_auto(GLnxTmpfile) env_tmpf  = { 0, };\n \n       if (!flatpak_buffer_to_sealed_memfd_or_tmpfile (&env_tmpf, \"environ\",\n                                                       env_string->str,\n                                                       env_string->len, &error))\n         {\n           g_dbus_method_invocation_return_gerror (invocation, error);\n           return G_DBUS_METHOD_INVOCATION_HANDLED;\n         }\n \n       child_setup_data.env_fd = glnx_steal_fd (&env_tmpf.fd);\n       g_ptr_array_add (flatpak_argv,\n                        g_strdup_printf (\"--env-fd=%d\",\n                                         child_setup_data.env_fd));\n     }\n \n   expose_pids = (arg_flags & FLATPAK_SPAWN_FLAGS_EXPOSE_PIDS) != 0;\n   share_pids = (arg_flags & FLATPAK_SPAWN_FLAGS_SHARE_PIDS) != 0;\n \n   if (expose_pids || share_pids)\n     {\n       g_autofree char *instance_id = NULL;\n       int sender_pid1 = 0;\n \n       if (!(supports & FLATPAK_SPAWN_SUPPORT_FLAGS_EXPOSE_PIDS))\n         {\n           g_dbus_method_invocation_return_error (invocation, G_DBUS_ERROR,\n                                                  G_DBUS_ERROR_NOT_SUPPORTED,\n                                                  \"Expose pids not supported with setuid bwrap\");\n           return G_DBUS_METHOD_INVOCATION_HANDLED;\n         }\n \n       instance_id = g_key_file_get_string (app_info,\n                                            FLATPAK_METADATA_GROUP_INSTANCE,\n                                            FLATPAK_METADATA_KEY_INSTANCE_ID, NULL);\n \n       if (instance_id)\n         {\n           g_autoptr(FlatpakInstance) instance = flatpak_instance_new_for_id (instance_id);\n           sender_pid1 = flatpak_instance_get_child_pid (instance);\n         }\n \n       if (sender_pid1 == 0)\n         {\n           g_dbus_method_invocation_return_error (invocation, G_DBUS_ERROR,\n                                                  G_DBUS_ERROR_INVALID_ARGS,\n                                                  \"Could not find requesting pid\");\n           return G_DBUS_METHOD_INVOCATION_HANDLED;\n         }\n \n       g_ptr_array_add (flatpak_argv, g_strdup_printf (\"--parent-pid=%d\", sender_pid1));\n \n       if (share_pids)\n         g_ptr_array_add (flatpak_argv, g_strdup (\"--parent-share-pids\"));\n       else\n         g_ptr_array_add (flatpak_argv, g_strdup (\"--parent-expose-pids\"));\n     }\n \n   notify_start = (arg_flags & FLATPAK_SPAWN_FLAGS_NOTIFY_START) != 0;\n   if (notify_start)\n     {\n       int pipe_fds[2];\n       if (pipe (pipe_fds) == -1)\n         {\n           int errsv = errno;\n           g_dbus_method_invocation_return_error (invocation, G_IO_ERROR,\n                                                  g_io_error_from_errno (errsv),\n                                                  \"Failed to create instance ID pipe: %s\",\n                                                  g_strerror (errsv));\n           return G_DBUS_METHOD_INVOCATION_HANDLED;\n         }\n \n       GInputStream *in_stream = G_INPUT_STREAM (g_unix_input_stream_new (pipe_fds[0], TRUE));\n       instance_id_out_stream = G_OUTPUT_STREAM (g_unix_output_stream_new (pipe_fds[1], TRUE));\n \n       instance_id_read_data = g_new0 (InstanceIdReadData, 1);\n \n       g_input_stream_read_async (in_stream, instance_id_read_data->buffer,\n                                  INSTANCE_ID_BUFFER_SIZE - 1, G_PRIORITY_DEFAULT, NULL,\n                                  instance_id_read_finish, instance_id_read_data);\n \n       g_ptr_array_add (flatpak_argv, g_strdup_printf (\"--instance-id-fd=%d\", pipe_fds[1]));\n       child_setup_data.instance_id_fd = pipe_fds[1];\n     }\n \n   if (devel)\n     g_ptr_array_add (flatpak_argv, g_strdup (\"--devel\"));\n \n   if (shares != NULL && g_strv_contains ((const char * const *) shares, \"network\") &&\n       !(arg_flags & FLATPAK_SPAWN_FLAGS_NO_NETWORK))\n     g_ptr_array_add (flatpak_argv, g_strdup (\"--share=network\"));\n   else\n     g_ptr_array_add (flatpak_argv, g_strdup (\"--unshare=network\"));\n \n \n   if (instance_path)\n     {\n       for (i = 0; sandbox_expose != NULL && sandbox_expose[i] != NULL; i++)\n         g_ptr_array_add (flatpak_argv,\n                          filesystem_sandbox_arg (instance_path, sandbox_expose[i], FALSE));\n       for (i = 0; sandbox_expose_ro != NULL && sandbox_expose_ro[i] != NULL; i++)\n         g_ptr_array_add (flatpak_argv,\n                          filesystem_sandbox_arg (instance_path, sandbox_expose_ro[i], TRUE));\n     }\n \n   for (i = 0; sandbox_expose_ro != NULL && sandbox_expose_ro[i] != NULL; i++)\n     {\n       const char *expose = sandbox_expose_ro[i];\n       g_debug (\"exposing %s\", expose);\n     }\n \n   if (sandbox_expose_fd != NULL)\n     {\n       gsize len = g_variant_n_children (sandbox_expose_fd);\n       for (i = 0; i < len; i++)\n         {\n           gint32 handle;\n           g_variant_get_child (sandbox_expose_fd, i, \"h\", &handle);\n           if (handle >= 0 && handle < fds_len)\n             {\n               int handle_fd = fds[handle];\n               g_autofree char *path = NULL;\n               gboolean writable = FALSE;\n \n               path = get_path_for_fd (handle_fd, &writable, &error);\n \n               if (path)\n                 {\n                   g_ptr_array_add (flatpak_argv, filesystem_arg (path, !writable));\n                 }\n               else\n                 {\n                   g_debug (\"unable to get path for sandbox-exposed fd %d, ignoring: %s\",\n                            handle_fd, error->message);\n                   g_clear_error (&error);\n                 }\n             }\n           else\n             {\n               g_dbus_method_invocation_return_error (invocation, G_DBUS_ERROR,\n                                                      G_DBUS_ERROR_INVALID_ARGS,\n                                                      \"No file descriptor for handle %d\",\n                                                      handle);\n               return G_DBUS_METHOD_INVOCATION_HANDLED;\n             }\n         }\n     }\n \n   if (sandbox_expose_fd_ro != NULL)\n     {\n       gsize len = g_variant_n_children (sandbox_expose_fd_ro);\n       for (i = 0; i < len; i++)\n         {\n           gint32 handle;\n           g_variant_get_child (sandbox_expose_fd_ro, i, \"h\", &handle);\n           if (handle >= 0 && handle < fds_len)\n             {\n               int handle_fd = fds[handle];\n               g_autofree char *path = NULL;\n               gboolean writable = FALSE;\n \n               path = get_path_for_fd (handle_fd, &writable, &error);\n \n               if (path)\n                 {\n                   g_ptr_array_add (flatpak_argv, filesystem_arg (path, TRUE));\n                 }\n               else\n                 {\n                   g_debug (\"unable to get path for sandbox-exposed fd %d, ignoring: %s\",\n                            handle_fd, error->message);\n                   g_clear_error (&error);\n                 }\n             }\n           else\n             {\n               g_dbus_method_invocation_return_error (invocation, G_DBUS_ERROR,\n                                                      G_DBUS_ERROR_INVALID_ARGS,\n                                                      \"No file descriptor for handle %d\",\n                                                      handle);\n               return G_DBUS_METHOD_INVOCATION_HANDLED;\n             }\n         }\n     }\n \n   g_ptr_array_add (flatpak_argv, g_strdup_printf (\"--runtime=%s\", runtime_parts[1]));\n   g_ptr_array_add (flatpak_argv, g_strdup_printf (\"--runtime-version=%s\", runtime_parts[3]));\n \n   if ((arg_flags & FLATPAK_SPAWN_FLAGS_LATEST_VERSION) == 0)\n     {\n       if (app_commit)\n         g_ptr_array_add (flatpak_argv, g_strdup_printf (\"--commit=%s\", app_commit));\n       if (runtime_commit)\n         g_ptr_array_add (flatpak_argv, g_strdup_printf (\"--runtime-commit=%s\", runtime_commit));\n     }\n \n   if (arg_cwd_path != NULL)\n     g_ptr_array_add (flatpak_argv, g_strdup_printf (\"--cwd=%s\", arg_cwd_path));\n \n   if (arg_argv[0][0] != 0)\n     g_ptr_array_add (flatpak_argv, g_strdup_printf (\"--command=%s\", arg_argv[0]));\n \n   g_ptr_array_add (flatpak_argv, g_strdup_printf (\"%s/%s/%s\", app_id, arch ? arch : \"\", branch ? branch : \"\"));\n   for (i = 1; arg_argv[i] != NULL; i++)\n     g_ptr_array_add (flatpak_argv, g_strdup (arg_argv[i]));\n   g_ptr_array_add (flatpak_argv, NULL);\n \n   if (opt_verbose)\n     {\n       g_autoptr(GString) cmd = g_string_new (\"\");\n \n       for (i = 0; flatpak_argv->pdata[i] != NULL; i++)\n         {\n           if (i > 0)\n             g_string_append (cmd, \" \");\n           g_string_append (cmd, flatpak_argv->pdata[i]);\n         }\n \n       g_debug (\"Starting: %s\\n\", cmd->str);\n     }\n \n   if (!g_spawn_async_with_pipes (NULL,\n                                  (char **) flatpak_argv->pdata,\n                                  env,\n                                  G_SPAWN_SEARCH_PATH | G_SPAWN_DO_NOT_REAP_CHILD | G_SPAWN_LEAVE_DESCRIPTORS_OPEN,\n                                  child_setup_func, &child_setup_data,\n                                  &pid,\n                                  NULL,\n                                  NULL,\n                                  NULL,\n                                  &error))\n     {\n       gint code = G_DBUS_ERROR_FAILED;\n       if (g_error_matches (error, G_SPAWN_ERROR, G_SPAWN_ERROR_ACCES))\n         code = G_DBUS_ERROR_ACCESS_DENIED;\n       else if (g_error_matches (error, G_SPAWN_ERROR, G_SPAWN_ERROR_NOENT))\n         code = G_DBUS_ERROR_FILE_NOT_FOUND;\n       g_dbus_method_invocation_return_error (invocation, G_DBUS_ERROR, code,\n                                              \"Failed to start command: %s\",\n                                              error->message);\n       return G_DBUS_METHOD_INVOCATION_HANDLED;\n     }\n \n   if (instance_id_read_data)\n     instance_id_read_data->pid = pid;\n \n   pid_data = g_new0 (PidData, 1);\n   pid_data->pid = pid;\n   pid_data->client = g_strdup (g_dbus_method_invocation_get_sender (invocation));\n   pid_data->watch_bus = (arg_flags & FLATPAK_SPAWN_FLAGS_WATCH_BUS) != 0;\n   pid_data->expose_or_share_pids = (expose_pids || share_pids);\n   pid_data->child_watch = g_child_watch_add_full (G_PRIORITY_DEFAULT,\n                                                   pid,\n                                                   child_watch_died,\n                                                   pid_data,\n                                                   NULL);\n \n   g_debug (\"Client Pid is %d\", pid_data->pid);\n \n   g_hash_table_replace (client_pid_data_hash, GUINT_TO_POINTER (pid_data->pid),\n                         pid_data);\n \n   portal_flatpak_complete_spawn (object, invocation, NULL, pid);\n   return G_DBUS_METHOD_INVOCATION_HANDLED;\n }\n \n", "target": "// fix_start\n      if (var[0] == '\\0')\n        {\n          g_dbus_method_invocation_return_error (invocation, G_DBUS_ERROR,\n                                                 G_DBUS_ERROR_INVALID_ARGS,\n                                                 \"Environment variable cannot have empty name\");\n          return G_DBUS_METHOD_INVOCATION_HANDLED;\n        }\n\n      if (strchr (var, '=') != NULL)\n        {\n          g_dbus_method_invocation_return_error (invocation, G_DBUS_ERROR,\n                                                 G_DBUS_ERROR_INVALID_ARGS,\n                                                 \"Environment variable name cannot contain '='\");\n          return G_DBUS_METHOD_INVOCATION_HANDLED;\n        }\n\n      g_string_append (env_string, var);\n      g_string_append_c (env_string, '=');\n      g_string_append (env_string, val);\n      g_string_append_c (env_string, '\\0');\n// fix_end\n", "cwe": "CWE-74", "cwe_name": "Improper Neutralization of Special Elements in Output Used by a Downstream Component ('Injection')", "cve": "CVE-2021-21261", "cve_desc": "Flatpak is a system for building, distributing, and running sandboxed desktop applications on Linux. A bug was discovered in the `flatpak-portal` service that can allow sandboxed applications to execute arbitrary code on the host system (a sandbox escape). This sandbox-escape bug is present in versions from 0.11.4 and before fixed versions 1.8.5 and 1.10.0. The Flatpak portal D-Bus service (`flatpak-portal`, also known by its D-Bus service name `org.freedesktop.portal.Flatpak`) allows apps in a Flatpak sandbox to launch their own subprocesses in a new sandbox instance, either with the same security settings as the caller or with more restrictive security settings. For example, this is used in Flatpak-packaged web browsers such as Chromium to launch subprocesses that will process untrusted web content, and give those subprocesses a more restrictive sandbox than the browser itself. In vulnerable versions, the Flatpak portal service passes caller-specified environment variables to non-sandboxed processes on the host system, and in particular to the `flatpak run` command that is used to launch the new sandbox instance. A malicious or compromised Flatpak app could set environment variables that are trusted by the `flatpak run` command, and use them to execute arbitrary code that is not in a sandbox. As a workaround, this vulnerability can be mitigated by preventing the `flatpak-portal` service from starting, but that mitigation will prevent many Flatpak apps from working correctly. This is fixed in versions 1.8.5 and 1.10.0.", "project": "flatpak", "idx": 208226}
{"source": " static void msf2_dma_tx(MSF2EmacState *s)\n {\n     NetClientState *nc = qemu_get_queue(s->nic);\n     hwaddr desc = s->regs[R_DMA_TX_DESC];\n     uint8_t buf[MAX_PKT_SIZE];\n     EmacDesc d;\n     int size;\n     uint8_t pktcnt;\n     uint32_t status;\n \n     if (!(s->regs[R_CFG1] & R_CFG1_TX_EN_MASK)) {\n         return;\n     }\n \n     while (1) {\n         emac_load_desc(s, &d, desc);\n         if (d.pktsize & EMPTY_MASK) {\n             break;\n         }\n         size = d.pktsize & PKT_SIZE;\n         address_space_read(&s->dma_as, d.pktaddr, MEMTXATTRS_UNSPECIFIED,\n                            buf, size);\n         if (s->regs[R_CFG1] & R_CFG1_LB_EN_MASK) {\n// bug_start\n            nc->info->receive(nc, buf, size);\n// bug_end\n         } else {\n             qemu_send_packet(nc, buf, size);\n         }\n         d.pktsize |= EMPTY_MASK;\n         emac_store_desc(s, &d, desc);\n         status = s->regs[R_DMA_TX_STATUS];\n         pktcnt = FIELD_EX32(status, DMA_TX_STATUS, PKTCNT);\n         pktcnt++;\n         s->regs[R_DMA_TX_STATUS] = FIELD_DP32(status, DMA_TX_STATUS,\n                                               PKTCNT, pktcnt);\n         s->regs[R_DMA_TX_STATUS] |= R_DMA_TX_STATUS_PKT_SENT_MASK;\n         desc = d.next;\n     }\n     s->regs[R_DMA_TX_STATUS] |= R_DMA_TX_STATUS_UNDERRUN_MASK;\n     s->regs[R_DMA_TX_CTL] &= ~R_DMA_TX_CTL_EN_MASK;\n }\n \n", "target": "// fix_start\n            qemu_receive_packet(nc, buf, size);\n// fix_end\n", "cwe": "CWE-835", "cwe_name": "Loop with Unreachable Exit Condition ('Infinite Loop')", "cve": "CVE-2021-3416", "cve_desc": "A potential stack overflow via infinite loop issue was found in various NIC emulators of QEMU in versions up to and including 5.2.0. The issue occurs in loopback mode of a NIC wherein reentrant DMA checks get bypassed. A guest user/process may use this flaw to consume CPU cycles or crash the QEMU process on the host resulting in DoS scenario.", "project": "qemu", "idx": 208328}
{"source": " static int ca8210_probe(struct spi_device *spi_device)\n {\n \tstruct ca8210_priv *priv;\n \tstruct ieee802154_hw *hw;\n \tstruct ca8210_platform_data *pdata;\n \tint ret;\n \n \tdev_info(&spi_device->dev, \"Inserting ca8210\\n\");\n \n \thw = ieee802154_alloc_hw(sizeof(struct ca8210_priv), &ca8210_phy_ops);\n \tif (!hw) {\n \t\tdev_crit(&spi_device->dev, \"ieee802154_alloc_hw failed\\n\");\n \t\tret = -ENOMEM;\n \t\tgoto error;\n \t}\n \n \tpriv = hw->priv;\n \tpriv->hw = hw;\n \tpriv->spi = spi_device;\n \thw->parent = &spi_device->dev;\n \tspin_lock_init(&priv->lock);\n \tpriv->async_tx_pending = false;\n \tpriv->hw_registered = false;\n \tpriv->sync_up = 0;\n \tpriv->sync_down = 0;\n \tpriv->promiscuous = false;\n \tpriv->retries = 0;\n \tinit_completion(&priv->ca8210_is_awake);\n \tinit_completion(&priv->spi_transfer_complete);\n \tinit_completion(&priv->sync_exchange_complete);\n \tspi_set_drvdata(priv->spi, priv);\n \tif (IS_ENABLED(CONFIG_IEEE802154_CA8210_DEBUGFS)) {\n \t\tcascoda_api_upstream = ca8210_test_int_driver_write;\n \t\tca8210_test_interface_init(priv);\n \t} else {\n \t\tcascoda_api_upstream = NULL;\n \t}\n \tca8210_hw_setup(hw);\n \tieee802154_random_extended_addr(&hw->phy->perm_extended_addr);\n \n \tpdata = kmalloc(sizeof(*pdata), GFP_KERNEL);\n \tif (!pdata) {\n \t\tret = -ENOMEM;\n \t\tgoto error;\n \t}\n \n// bug_start\n// bug_end\n \tret = ca8210_get_platform_data(priv->spi, pdata);\n \tif (ret) {\n \t\tdev_crit(&spi_device->dev, \"ca8210_get_platform_data failed\\n\");\n \t\tgoto error;\n \t}\n// bug_start\n\tpriv->spi->dev.platform_data = pdata;\n// bug_end\n \n \tret = ca8210_dev_com_init(priv);\n \tif (ret) {\n \t\tdev_crit(&spi_device->dev, \"ca8210_dev_com_init failed\\n\");\n \t\tgoto error;\n \t}\n \tret = ca8210_reset_init(priv->spi);\n \tif (ret) {\n \t\tdev_crit(&spi_device->dev, \"ca8210_reset_init failed\\n\");\n \t\tgoto error;\n \t}\n \n \tret = ca8210_interrupt_init(priv->spi);\n \tif (ret) {\n \t\tdev_crit(&spi_device->dev, \"ca8210_interrupt_init failed\\n\");\n \t\tgoto error;\n \t}\n \n \tmsleep(100);\n \n \tca8210_reset_send(priv->spi, 1);\n \n \tret = tdme_chipinit(priv->spi);\n \tif (ret) {\n \t\tdev_crit(&spi_device->dev, \"tdme_chipinit failed\\n\");\n \t\tgoto error;\n \t}\n \n \tif (pdata->extclockenable) {\n \t\tret = ca8210_config_extern_clk(pdata, priv->spi, 1);\n \t\tif (ret) {\n \t\t\tdev_crit(\n \t\t\t\t&spi_device->dev,\n \t\t\t\t\"ca8210_config_extern_clk failed\\n\"\n \t\t\t);\n \t\t\tgoto error;\n \t\t}\n \t\tret = ca8210_register_ext_clock(priv->spi);\n \t\tif (ret) {\n \t\t\tdev_crit(\n \t\t\t\t&spi_device->dev,\n \t\t\t\t\"ca8210_register_ext_clock failed\\n\"\n \t\t\t);\n \t\t\tgoto error;\n \t\t}\n \t}\n \n \tret = ieee802154_register_hw(hw);\n \tif (ret) {\n \t\tdev_crit(&spi_device->dev, \"ieee802154_register_hw failed\\n\");\n \t\tgoto error;\n \t}\n \tpriv->hw_registered = true;\n \n \treturn 0;\n error:\n \tmsleep(100);\n \tca8210_remove(spi_device);\n \treturn link_to_linux_err(ret);\n }\n \n", "target": "// fix_start\n\tpriv->spi->dev.platform_data = pdata;\n// fix_end\n// fix_start\n// fix_end\n", "cwe": "CWE-401", "cwe_name": "Missing Release of Memory after Effective Lifetime", "cve": "CVE-2019-19075", "cve_desc": "A memory leak in the ca8210_probe() function in drivers/net/ieee802154/ca8210.c in the Linux kernel before 5.3.8 allows attackers to cause a denial of service (memory consumption) by triggering ca8210_get_platform_data() failures, aka CID-6402939ec86e.", "project": "linux", "idx": 208360}
{"source": "     void Jp2Image::encodeJp2Header(const DataBuf& boxBuf,DataBuf& outBuf)\n     {\n         DataBuf output(boxBuf.size_ + iccProfile_.size_ + 100);\n// bug_start\n        int     outlen = sizeof(Jp2BoxHeader) ;\n        int      inlen = sizeof(Jp2BoxHeader) ;\n// bug_end\n         Jp2BoxHeader* pBox   = (Jp2BoxHeader*) boxBuf.pData_;\n// bug_start\n        int32_t       length = getLong((byte*)&pBox->length, bigEndian);\n        int32_t       count  = sizeof (Jp2BoxHeader);\n// bug_end\n         char*         p      = (char*) boxBuf.pData_;\n         bool          bWroteColor = false ;\n \n         while ( count < length || !bWroteColor ) {\n             Jp2BoxHeader* pSubBox = (Jp2BoxHeader*) (p+count) ;\n \n             Jp2BoxHeader   subBox ; memcpy(&subBox,pSubBox,sizeof(subBox));\n             Jp2BoxHeader   newBox =  subBox;\n \n             if ( count < length ) {\n                 subBox.length = getLong((byte*)&subBox.length, bigEndian);\n                 subBox.type   = getLong((byte*)&subBox.type  , bigEndian);\n #ifdef EXIV2_DEBUG_MESSAGES\n                 std::cout << \"Jp2Image::encodeJp2Header subbox: \"<< toAscii(subBox.type) << \" length = \" << subBox.length << std::endl;\n #endif\n// bug_start\n// bug_end\n                 count        += subBox.length;\n                 newBox.type   = subBox.type;\n             } else {\n                 subBox.length=0;\n                 newBox.type = kJp2BoxTypeColorHeader;\n                 count = length;\n             }\n \n// bug_start\n            int32_t newlen = subBox.length;\n// bug_end\n             if ( newBox.type == kJp2BoxTypeColorHeader ) {\n                 bWroteColor = true ;\n                 if ( ! iccProfileDefined() ) {\n                     const char* pad   = \"\\x01\\x00\\x00\\x00\\x00\\x00\\x10\\x00\\x00\\x05\\x1cuuid\";\n                     uint32_t    psize = 15;\n                     newlen            = sizeof(newBox) + psize ;\n// bug_start\n// bug_end\n                     ul2Data((byte*)&newBox.length,psize      ,bigEndian);\n                     ul2Data((byte*)&newBox.type  ,newBox.type,bigEndian);\n                     ::memcpy(output.pData_+outlen                     ,&newBox            ,sizeof(newBox));\n                     ::memcpy(output.pData_+outlen+sizeof(newBox)      ,pad                ,psize         );\n                 } else {\n                     const char* pad   = \"\\x02\\x00\\x00\";\n                     uint32_t    psize = 3;\n                     newlen            = sizeof(newBox) + psize + iccProfile_.size_;\n// bug_start\n// bug_end\n                     ul2Data((byte*)&newBox.length,newlen,bigEndian);\n                     ul2Data((byte*)&newBox.type,newBox.type,bigEndian);\n                     ::memcpy(output.pData_+outlen                     ,&newBox            ,sizeof(newBox)  );\n                     ::memcpy(output.pData_+outlen+sizeof(newBox)      , pad               ,psize           );\n                     ::memcpy(output.pData_+outlen+sizeof(newBox)+psize,iccProfile_.pData_,iccProfile_.size_);\n                 }\n             } else {\n// bug_start\n// bug_end\n                 ::memcpy(output.pData_+outlen,boxBuf.pData_+inlen,subBox.length);\n             }\n \n             outlen += newlen;\n             inlen  += subBox.length;\n         }\n \n         outBuf.alloc(outlen);\n         ::memcpy(outBuf.pData_,output.pData_,outlen);\n         pBox   = (Jp2BoxHeader*) outBuf.pData_;\n         ul2Data((byte*)&pBox->type,kJp2BoxTypeJp2Header,bigEndian);\n         ul2Data((byte*)&pBox->length,outlen,bigEndian);\n     }\n \n", "target": "// fix_start\n        long    outlen = sizeof(Jp2BoxHeader) ;\n        long    inlen = sizeof(Jp2BoxHeader) ;\n// fix_end\n// fix_start\n        uint32_t      length = getLong((byte*)&pBox->length, bigEndian);\n        uint32_t      count  = sizeof (Jp2BoxHeader);\n// fix_end\n// fix_start\n                enforce(subBox.length <= length - count, Exiv2::kerCorruptedMetadata);\n// fix_end\n// fix_start\n            uint32_t newlen = subBox.length;\n// fix_end\n// fix_start\n                    enforce(newlen <= output.size_ - outlen, Exiv2::kerCorruptedMetadata);\n// fix_end\n// fix_start\n                    enforce(newlen <= output.size_ - outlen, Exiv2::kerCorruptedMetadata);\n// fix_end\n// fix_start\n                enforce(newlen <= output.size_ - outlen, Exiv2::kerCorruptedMetadata);\n// fix_end\n", "cwe": "CWE-703", "cwe_name": "Improper Check or Handling of Exceptional Conditions", "cve": "CVE-2021-29464", "cve_desc": "Exiv2 is a command-line utility and C++ library for reading, writing, deleting, and modifying the metadata of image files. A heap buffer overflow was found in Exiv2 versions v0.27.3 and earlier. The heap overflow is triggered when Exiv2 is used to write metadata into a crafted image file. An attacker could potentially exploit the vulnerability to gain code execution, if they can trick the victim into running Exiv2 on a crafted image file. Note that this bug is only triggered when writing the metadata, which is a less frequently used Exiv2 operation than reading the metadata. For example, to trigger the bug in the Exiv2 command-line application, you need to add an extra command-line argument such as `insert`. The bug is fixed in version v0.27.4.", "project": "exiv2", "idx": 208379}
{"source": " exif_mnote_data_canon_load (ExifMnoteData *ne,\n \tconst unsigned char *buf, unsigned int buf_size)\n {\n \tExifMnoteDataCanon *n = (ExifMnoteDataCanon *) ne;\n \tExifShort c;\n \tsize_t i, tcount, o, datao;\n// bug_start\n// bug_end\n \n \tif (!n || !buf || !buf_size) {\n \t\texif_log (ne->log, EXIF_LOG_CODE_CORRUPT_DATA,\n \t\t\t  \"ExifMnoteCanon\", \"Short MakerNote\");\n \t\treturn;\n \t}\n \tdatao = 6 + n->offset;\n \tif (CHECKOVERFLOW(datao, buf_size, 2)) {\n \t\texif_log (ne->log, EXIF_LOG_CODE_CORRUPT_DATA,\n \t\t\t  \"ExifMnoteCanon\", \"Short MakerNote\");\n \t\treturn;\n \t}\n \n \tc = exif_get_short (buf + datao, n->order);\n \tdatao += 2;\n \n \texif_mnote_data_canon_clear (n);\n \n \tn->entries = exif_mem_alloc (ne->mem, sizeof (MnoteCanonEntry) * c);\n \tif (!n->entries) {\n \t\tEXIF_LOG_NO_MEMORY(ne->log, \"ExifMnoteCanon\", sizeof (MnoteCanonEntry) * c);\n \t\treturn;\n \t}\n \n \ttcount = 0;\n \tfor (i = c, o = datao; i; --i, o += 12) {\n \t\tsize_t s;\n \n \t\tmemset(&n->entries[tcount], 0, sizeof(MnoteCanonEntry));\n \t\tif (CHECKOVERFLOW(o,buf_size,12)) {\n \t\t\texif_log (ne->log, EXIF_LOG_CODE_CORRUPT_DATA,\n \t\t\t\t\"ExifMnoteCanon\", \"Short MakerNote\");\n \t\t\tbreak;\n \t\t}\n \n \t\tn->entries[tcount].tag        = exif_get_short (buf + o, n->order);\n \t\tn->entries[tcount].format     = exif_get_short (buf + o + 2, n->order);\n \t\tn->entries[tcount].components = exif_get_long (buf + o + 4, n->order);\n \t\tn->entries[tcount].order      = n->order;\n \n \t\texif_log (ne->log, EXIF_LOG_CODE_DEBUG, \"ExifMnoteCanon\",\n \t\t\t\"Loading entry 0x%x ('%s')...\", n->entries[tcount].tag,\n \t\t\t mnote_canon_tag_get_name (n->entries[tcount].tag));\n \n \t\tif (\texif_format_get_size (n->entries[tcount].format) &&\n \t\t\tbuf_size / exif_format_get_size (n->entries[tcount].format) < n->entries[tcount].components\n \t\t) {\n \t\t\texif_log (ne->log, EXIF_LOG_CODE_CORRUPT_DATA,\n \t\t\t\t  \"ExifMnoteCanon\", \"Tag size overflow detected (%u * %lu)\", exif_format_get_size (n->entries[tcount].format), n->entries[tcount].components);\n \t\t\tcontinue;\n \t\t}\n \n \t\ts = exif_format_get_size (n->entries[tcount].format) *\n \t\t\t\t\t\t\t\t  n->entries[tcount].components;\n \t\tn->entries[tcount].size = s;\n \t\tif (!s) {\n \t\t\texif_log (ne->log, EXIF_LOG_CODE_CORRUPT_DATA,\n \t\t\t\t  \"ExifMnoteCanon\",\n \t\t\t\t  \"Invalid zero-length tag size\");\n \t\t\tcontinue;\n \n \t\t} else {\n \t\t\tsize_t dataofs = o + 8;\n \t\t\tif (s > 4) dataofs = exif_get_long (buf + dataofs, n->order) + 6;\n \n \t\t\tif (CHECKOVERFLOW(dataofs, buf_size, s)) {\n \t\t\t\texif_log (ne->log, EXIF_LOG_CODE_DEBUG,\n \t\t\t\t\t\"ExifMnoteCanon\",\n \t\t\t\t\t\"Tag data past end of buffer (%u > %u)\",\n \t\t\t\t\t(unsigned)(dataofs + s), buf_size);\n \t\t\t\tcontinue;\n \t\t\t}\n \n \t\t\tn->entries[tcount].data = exif_mem_alloc (ne->mem, s);\n \t\t\tif (!n->entries[tcount].data) {\n \t\t\t\tEXIF_LOG_NO_MEMORY(ne->log, \"ExifMnoteCanon\", s);\n \t\t\t\tcontinue;\n \t\t\t}\n \t\t\tmemcpy (n->entries[tcount].data, buf + dataofs, s);\n \t\t}\n \n// bug_start\n// bug_end\n \t\t++tcount;\n \t}\n \tn->count = tcount;\n }\n \n", "target": "// fix_start\n\tlong failsafe_size = 0;\n// fix_end\n// fix_start\n\t\tfailsafe_size += mnote_canon_entry_count_values(&n->entries[tcount]);\n\n\t\tif (failsafe_size > FAILSAFE_SIZE_MAX) {\n\t\t\texif_mem_free (ne->mem, n->entries[tcount].data);\n\t\t\texif_log (ne->log, EXIF_LOG_CODE_CORRUPT_DATA,\n\t\t\t\t\t  \"ExifMnoteCanon\", \"Failsafe tag size overflow (%lu > %ld)\",\n\t\t\t\t\t  failsafe_size, FAILSAFE_SIZE_MAX);\n\t\t\tbreak;\n\t\t}\n\n// fix_end\n", "cwe": "CWE-703", "cwe_name": "Improper Check or Handling of Exceptional Conditions", "cve": "CVE-2020-13114", "cve_desc": "An issue was discovered in libexif before 0.6.22. An unrestricted size in handling Canon EXIF MakerNote data could lead to consumption of large amounts of compute time for decoding EXIF data.", "project": "libexif", "idx": 208385}
{"source": " Int32 BZ2_decompress ( DState* s )\n {\n    UChar      uc;\n    Int32      retVal;\n    Int32      minLen, maxLen;\n    bz_stream* strm = s->strm;\n \n    Int32  i;\n    Int32  j;\n    Int32  t;\n    Int32  alphaSize;\n    Int32  nGroups;\n    Int32  nSelectors;\n    Int32  EOB;\n    Int32  groupNo;\n    Int32  groupPos;\n    Int32  nextSym;\n    Int32  nblockMAX;\n    Int32  nblock;\n    Int32  es;\n    Int32  N;\n    Int32  curr;\n    Int32  zt;\n    Int32  zn;\n    Int32  zvec;\n    Int32  zj;\n    Int32  gSel;\n    Int32  gMinlen;\n    Int32* gLimit;\n    Int32* gBase;\n    Int32* gPerm;\n \n    if (s->state == BZ_X_MAGIC_1) {\n       s->save_i           = 0;\n       s->save_j           = 0;\n       s->save_t           = 0;\n       s->save_alphaSize   = 0;\n       s->save_nGroups     = 0;\n       s->save_nSelectors  = 0;\n       s->save_EOB         = 0;\n       s->save_groupNo     = 0;\n       s->save_groupPos    = 0;\n       s->save_nextSym     = 0;\n       s->save_nblockMAX   = 0;\n       s->save_nblock      = 0;\n       s->save_es          = 0;\n       s->save_N           = 0;\n       s->save_curr        = 0;\n       s->save_zt          = 0;\n       s->save_zn          = 0;\n       s->save_zvec        = 0;\n       s->save_zj          = 0;\n       s->save_gSel        = 0;\n       s->save_gMinlen     = 0;\n       s->save_gLimit      = NULL;\n       s->save_gBase       = NULL;\n       s->save_gPerm       = NULL;\n    }\n \n    i           = s->save_i;\n    j           = s->save_j;\n    t           = s->save_t;\n    alphaSize   = s->save_alphaSize;\n    nGroups     = s->save_nGroups;\n    nSelectors  = s->save_nSelectors;\n    EOB         = s->save_EOB;\n    groupNo     = s->save_groupNo;\n    groupPos    = s->save_groupPos;\n    nextSym     = s->save_nextSym;\n    nblockMAX   = s->save_nblockMAX;\n    nblock      = s->save_nblock;\n    es          = s->save_es;\n    N           = s->save_N;\n    curr        = s->save_curr;\n    zt          = s->save_zt;\n    zn          = s->save_zn;\n    zvec        = s->save_zvec;\n    zj          = s->save_zj;\n    gSel        = s->save_gSel;\n    gMinlen     = s->save_gMinlen;\n    gLimit      = s->save_gLimit;\n    gBase       = s->save_gBase;\n    gPerm       = s->save_gPerm;\n \n    retVal = BZ_OK;\n \n    switch (s->state) {\n \n       GET_UCHAR(BZ_X_MAGIC_1, uc);\n       if (uc != BZ_HDR_B) RETURN(BZ_DATA_ERROR_MAGIC);\n \n       GET_UCHAR(BZ_X_MAGIC_2, uc);\n       if (uc != BZ_HDR_Z) RETURN(BZ_DATA_ERROR_MAGIC);\n \n       GET_UCHAR(BZ_X_MAGIC_3, uc)\n       if (uc != BZ_HDR_h) RETURN(BZ_DATA_ERROR_MAGIC);\n \n       GET_BITS(BZ_X_MAGIC_4, s->blockSize100k, 8)\n       if (s->blockSize100k < (BZ_HDR_0 + 1) ||\n           s->blockSize100k > (BZ_HDR_0 + 9)) RETURN(BZ_DATA_ERROR_MAGIC);\n       s->blockSize100k -= BZ_HDR_0;\n \n       if (s->smallDecompress) {\n          s->ll16 = BZALLOC( s->blockSize100k * 100000 * sizeof(UInt16) );\n          s->ll4  = BZALLOC(\n                       ((1 + s->blockSize100k * 100000) >> 1) * sizeof(UChar)\n                    );\n          if (s->ll16 == NULL || s->ll4 == NULL) RETURN(BZ_MEM_ERROR);\n       } else {\n          s->tt  = BZALLOC( s->blockSize100k * 100000 * sizeof(Int32) );\n          if (s->tt == NULL) RETURN(BZ_MEM_ERROR);\n       }\n \n       GET_UCHAR(BZ_X_BLKHDR_1, uc);\n \n       if (uc == 0x17) goto endhdr_2;\n       if (uc != 0x31) RETURN(BZ_DATA_ERROR);\n       GET_UCHAR(BZ_X_BLKHDR_2, uc);\n       if (uc != 0x41) RETURN(BZ_DATA_ERROR);\n       GET_UCHAR(BZ_X_BLKHDR_3, uc);\n       if (uc != 0x59) RETURN(BZ_DATA_ERROR);\n       GET_UCHAR(BZ_X_BLKHDR_4, uc);\n       if (uc != 0x26) RETURN(BZ_DATA_ERROR);\n       GET_UCHAR(BZ_X_BLKHDR_5, uc);\n       if (uc != 0x53) RETURN(BZ_DATA_ERROR);\n       GET_UCHAR(BZ_X_BLKHDR_6, uc);\n       if (uc != 0x59) RETURN(BZ_DATA_ERROR);\n \n       s->currBlockNo++;\n       if (s->verbosity >= 2)\n          VPrintf1 ( \"\\n    [%d: huff+mtf \", s->currBlockNo );\n \n       s->storedBlockCRC = 0;\n       GET_UCHAR(BZ_X_BCRC_1, uc);\n       s->storedBlockCRC = (s->storedBlockCRC << 8) | ((UInt32)uc);\n       GET_UCHAR(BZ_X_BCRC_2, uc);\n       s->storedBlockCRC = (s->storedBlockCRC << 8) | ((UInt32)uc);\n       GET_UCHAR(BZ_X_BCRC_3, uc);\n       s->storedBlockCRC = (s->storedBlockCRC << 8) | ((UInt32)uc);\n       GET_UCHAR(BZ_X_BCRC_4, uc);\n       s->storedBlockCRC = (s->storedBlockCRC << 8) | ((UInt32)uc);\n \n       GET_BITS(BZ_X_RANDBIT, s->blockRandomised, 1);\n \n       s->origPtr = 0;\n       GET_UCHAR(BZ_X_ORIGPTR_1, uc);\n       s->origPtr = (s->origPtr << 8) | ((Int32)uc);\n       GET_UCHAR(BZ_X_ORIGPTR_2, uc);\n       s->origPtr = (s->origPtr << 8) | ((Int32)uc);\n       GET_UCHAR(BZ_X_ORIGPTR_3, uc);\n       s->origPtr = (s->origPtr << 8) | ((Int32)uc);\n \n       if (s->origPtr < 0)\n          RETURN(BZ_DATA_ERROR);\n       if (s->origPtr > 10 + 100000*s->blockSize100k)\n          RETURN(BZ_DATA_ERROR);\n \n       for (i = 0; i < 16; i++) {\n          GET_BIT(BZ_X_MAPPING_1, uc);\n          if (uc == 1)\n             s->inUse16[i] = True; else\n             s->inUse16[i] = False;\n       }\n \n       for (i = 0; i < 256; i++) s->inUse[i] = False;\n \n       for (i = 0; i < 16; i++)\n          if (s->inUse16[i])\n             for (j = 0; j < 16; j++) {\n                GET_BIT(BZ_X_MAPPING_2, uc);\n                if (uc == 1) s->inUse[i * 16 + j] = True;\n             }\n       makeMaps_d ( s );\n       if (s->nInUse == 0) RETURN(BZ_DATA_ERROR);\n       alphaSize = s->nInUse+2;\n \n       GET_BITS(BZ_X_SELECTOR_1, nGroups, 3);\n       if (nGroups < 2 || nGroups > 6) RETURN(BZ_DATA_ERROR);\n       GET_BITS(BZ_X_SELECTOR_2, nSelectors, 15);\n// bug_start\n      if (nSelectors < 1) RETURN(BZ_DATA_ERROR);\n// bug_end\n       for (i = 0; i < nSelectors; i++) {\n          j = 0;\n          while (True) {\n             GET_BIT(BZ_X_SELECTOR_3, uc);\n             if (uc == 0) break;\n             j++;\n             if (j >= nGroups) RETURN(BZ_DATA_ERROR);\n          }\n          s->selectorMtf[i] = j;\n       }\n \n       {\n          UChar pos[BZ_N_GROUPS], tmp, v;\n          for (v = 0; v < nGroups; v++) pos[v] = v;\n \n          for (i = 0; i < nSelectors; i++) {\n             v = s->selectorMtf[i];\n             tmp = pos[v];\n             while (v > 0) { pos[v] = pos[v-1]; v--; }\n             pos[0] = tmp;\n             s->selector[i] = tmp;\n          }\n       }\n \n       for (t = 0; t < nGroups; t++) {\n          GET_BITS(BZ_X_CODING_1, curr, 5);\n          for (i = 0; i < alphaSize; i++) {\n             while (True) {\n                if (curr < 1 || curr > 20) RETURN(BZ_DATA_ERROR);\n                GET_BIT(BZ_X_CODING_2, uc);\n                if (uc == 0) break;\n                GET_BIT(BZ_X_CODING_3, uc);\n                if (uc == 0) curr++; else curr--;\n             }\n             s->len[t][i] = curr;\n          }\n       }\n \n       for (t = 0; t < nGroups; t++) {\n          minLen = 32;\n          maxLen = 0;\n          for (i = 0; i < alphaSize; i++) {\n             if (s->len[t][i] > maxLen) maxLen = s->len[t][i];\n             if (s->len[t][i] < minLen) minLen = s->len[t][i];\n          }\n          BZ2_hbCreateDecodeTables (\n             &(s->limit[t][0]),\n             &(s->base[t][0]),\n             &(s->perm[t][0]),\n             &(s->len[t][0]),\n             minLen, maxLen, alphaSize\n          );\n          s->minLens[t] = minLen;\n       }\n \n \n       EOB      = s->nInUse+1;\n       nblockMAX = 100000 * s->blockSize100k;\n       groupNo  = -1;\n       groupPos = 0;\n \n       for (i = 0; i <= 255; i++) s->unzftab[i] = 0;\n \n       {\n          Int32 ii, jj, kk;\n          kk = MTFA_SIZE-1;\n          for (ii = 256 / MTFL_SIZE - 1; ii >= 0; ii--) {\n             for (jj = MTFL_SIZE-1; jj >= 0; jj--) {\n                s->mtfa[kk] = (UChar)(ii * MTFL_SIZE + jj);\n                kk--;\n             }\n             s->mtfbase[ii] = kk + 1;\n          }\n       }\n \n       nblock = 0;\n       GET_MTF_VAL(BZ_X_MTF_1, BZ_X_MTF_2, nextSym);\n \n       while (True) {\n \n          if (nextSym == EOB) break;\n \n          if (nextSym == BZ_RUNA || nextSym == BZ_RUNB) {\n \n             es = -1;\n             N = 1;\n             do {\n                if (N >= 2*1024*1024) RETURN(BZ_DATA_ERROR);\n                if (nextSym == BZ_RUNA) es = es + (0+1) * N; else\n                if (nextSym == BZ_RUNB) es = es + (1+1) * N;\n                N = N * 2;\n                GET_MTF_VAL(BZ_X_MTF_3, BZ_X_MTF_4, nextSym);\n             }\n                while (nextSym == BZ_RUNA || nextSym == BZ_RUNB);\n \n             es++;\n             uc = s->seqToUnseq[ s->mtfa[s->mtfbase[0]] ];\n             s->unzftab[uc] += es;\n \n             if (s->smallDecompress)\n                while (es > 0) {\n                   if (nblock >= nblockMAX) RETURN(BZ_DATA_ERROR);\n                   s->ll16[nblock] = (UInt16)uc;\n                   nblock++;\n                   es--;\n                }\n             else\n                while (es > 0) {\n                   if (nblock >= nblockMAX) RETURN(BZ_DATA_ERROR);\n                   s->tt[nblock] = (UInt32)uc;\n                   nblock++;\n                   es--;\n                };\n \n             continue;\n \n          } else {\n \n             if (nblock >= nblockMAX) RETURN(BZ_DATA_ERROR);\n \n             {\n                Int32 ii, jj, kk, pp, lno, off;\n                UInt32 nn;\n                nn = (UInt32)(nextSym - 1);\n \n                if (nn < MTFL_SIZE) {\n                   pp = s->mtfbase[0];\n                   uc = s->mtfa[pp+nn];\n                   while (nn > 3) {\n                      Int32 z = pp+nn;\n                      s->mtfa[(z)  ] = s->mtfa[(z)-1];\n                      s->mtfa[(z)-1] = s->mtfa[(z)-2];\n                      s->mtfa[(z)-2] = s->mtfa[(z)-3];\n                      s->mtfa[(z)-3] = s->mtfa[(z)-4];\n                      nn -= 4;\n                   }\n                   while (nn > 0) {\n                      s->mtfa[(pp+nn)] = s->mtfa[(pp+nn)-1]; nn--;\n                   };\n                   s->mtfa[pp] = uc;\n                } else {\n                   lno = nn / MTFL_SIZE;\n                   off = nn % MTFL_SIZE;\n                   pp = s->mtfbase[lno] + off;\n                   uc = s->mtfa[pp];\n                   while (pp > s->mtfbase[lno]) {\n                      s->mtfa[pp] = s->mtfa[pp-1]; pp--;\n                   };\n                   s->mtfbase[lno]++;\n                   while (lno > 0) {\n                      s->mtfbase[lno]--;\n                      s->mtfa[s->mtfbase[lno]]\n                         = s->mtfa[s->mtfbase[lno-1] + MTFL_SIZE - 1];\n                      lno--;\n                   }\n                   s->mtfbase[0]--;\n                   s->mtfa[s->mtfbase[0]] = uc;\n                   if (s->mtfbase[0] == 0) {\n                      kk = MTFA_SIZE-1;\n                      for (ii = 256 / MTFL_SIZE-1; ii >= 0; ii--) {\n                         for (jj = MTFL_SIZE-1; jj >= 0; jj--) {\n                            s->mtfa[kk] = s->mtfa[s->mtfbase[ii] + jj];\n                            kk--;\n                         }\n                         s->mtfbase[ii] = kk + 1;\n                      }\n                   }\n                }\n             }\n \n             s->unzftab[s->seqToUnseq[uc]]++;\n             if (s->smallDecompress)\n                s->ll16[nblock] = (UInt16)(s->seqToUnseq[uc]); else\n                s->tt[nblock]   = (UInt32)(s->seqToUnseq[uc]);\n             nblock++;\n \n             GET_MTF_VAL(BZ_X_MTF_5, BZ_X_MTF_6, nextSym);\n             continue;\n          }\n       }\n \n       if (s->origPtr < 0 || s->origPtr >= nblock)\n          RETURN(BZ_DATA_ERROR);\n \n       for (i = 0; i <= 255; i++) {\n          if (s->unzftab[i] < 0 || s->unzftab[i] > nblock)\n             RETURN(BZ_DATA_ERROR);\n       }\n       s->cftab[0] = 0;\n       for (i = 1; i <= 256; i++) s->cftab[i] = s->unzftab[i-1];\n       for (i = 1; i <= 256; i++) s->cftab[i] += s->cftab[i-1];\n       for (i = 0; i <= 256; i++) {\n          if (s->cftab[i] < 0 || s->cftab[i] > nblock) {\n             RETURN(BZ_DATA_ERROR);\n          }\n       }\n       for (i = 1; i <= 256; i++) {\n          if (s->cftab[i-1] > s->cftab[i]) {\n             RETURN(BZ_DATA_ERROR);\n          }\n       }\n \n       s->state_out_len = 0;\n       s->state_out_ch  = 0;\n       BZ_INITIALISE_CRC ( s->calculatedBlockCRC );\n       s->state = BZ_X_OUTPUT;\n       if (s->verbosity >= 2) VPrintf0 ( \"rt+rld\" );\n \n       if (s->smallDecompress) {\n \n          for (i = 0; i <= 256; i++) s->cftabCopy[i] = s->cftab[i];\n \n          for (i = 0; i < nblock; i++) {\n             uc = (UChar)(s->ll16[i]);\n             SET_LL(i, s->cftabCopy[uc]);\n             s->cftabCopy[uc]++;\n          }\n \n          i = s->origPtr;\n          j = GET_LL(i);\n          do {\n             Int32 tmp = GET_LL(j);\n             SET_LL(j, i);\n             i = j;\n             j = tmp;\n          }\n             while (i != s->origPtr);\n \n          s->tPos = s->origPtr;\n          s->nblock_used = 0;\n          if (s->blockRandomised) {\n             BZ_RAND_INIT_MASK;\n             BZ_GET_SMALL(s->k0); s->nblock_used++;\n             BZ_RAND_UPD_MASK; s->k0 ^= BZ_RAND_MASK;\n          } else {\n             BZ_GET_SMALL(s->k0); s->nblock_used++;\n          }\n \n       } else {\n \n          for (i = 0; i < nblock; i++) {\n             uc = (UChar)(s->tt[i] & 0xff);\n             s->tt[s->cftab[uc]] |= (i << 8);\n             s->cftab[uc]++;\n          }\n \n          s->tPos = s->tt[s->origPtr] >> 8;\n          s->nblock_used = 0;\n          if (s->blockRandomised) {\n             BZ_RAND_INIT_MASK;\n             BZ_GET_FAST(s->k0); s->nblock_used++;\n             BZ_RAND_UPD_MASK; s->k0 ^= BZ_RAND_MASK;\n          } else {\n             BZ_GET_FAST(s->k0); s->nblock_used++;\n          }\n \n       }\n \n       RETURN(BZ_OK);\n \n \n \n     endhdr_2:\n \n       GET_UCHAR(BZ_X_ENDHDR_2, uc);\n       if (uc != 0x72) RETURN(BZ_DATA_ERROR);\n       GET_UCHAR(BZ_X_ENDHDR_3, uc);\n       if (uc != 0x45) RETURN(BZ_DATA_ERROR);\n       GET_UCHAR(BZ_X_ENDHDR_4, uc);\n       if (uc != 0x38) RETURN(BZ_DATA_ERROR);\n       GET_UCHAR(BZ_X_ENDHDR_5, uc);\n       if (uc != 0x50) RETURN(BZ_DATA_ERROR);\n       GET_UCHAR(BZ_X_ENDHDR_6, uc);\n       if (uc != 0x90) RETURN(BZ_DATA_ERROR);\n \n       s->storedCombinedCRC = 0;\n       GET_UCHAR(BZ_X_CCRC_1, uc);\n       s->storedCombinedCRC = (s->storedCombinedCRC << 8) | ((UInt32)uc);\n       GET_UCHAR(BZ_X_CCRC_2, uc);\n       s->storedCombinedCRC = (s->storedCombinedCRC << 8) | ((UInt32)uc);\n       GET_UCHAR(BZ_X_CCRC_3, uc);\n       s->storedCombinedCRC = (s->storedCombinedCRC << 8) | ((UInt32)uc);\n       GET_UCHAR(BZ_X_CCRC_4, uc);\n       s->storedCombinedCRC = (s->storedCombinedCRC << 8) | ((UInt32)uc);\n \n       s->state = BZ_X_IDLE;\n       RETURN(BZ_STREAM_END);\n \n       default: AssertH ( False, 4001 );\n    }\n \n    AssertH ( False, 4002 );\n \n    save_state_and_return:\n \n    s->save_i           = i;\n    s->save_j           = j;\n    s->save_t           = t;\n    s->save_alphaSize   = alphaSize;\n    s->save_nGroups     = nGroups;\n    s->save_nSelectors  = nSelectors;\n    s->save_EOB         = EOB;\n    s->save_groupNo     = groupNo;\n    s->save_groupPos    = groupPos;\n    s->save_nextSym     = nextSym;\n    s->save_nblockMAX   = nblockMAX;\n    s->save_nblock      = nblock;\n    s->save_es          = es;\n    s->save_N           = N;\n    s->save_curr        = curr;\n    s->save_zt          = zt;\n    s->save_zn          = zn;\n    s->save_zvec        = zvec;\n    s->save_zj          = zj;\n    s->save_gSel        = gSel;\n    s->save_gMinlen     = gMinlen;\n    s->save_gLimit      = gLimit;\n    s->save_gBase       = gBase;\n    s->save_gPerm       = gPerm;\n \n    return retVal;\n }\n \n", "target": "// fix_start\n      if (nSelectors < 1 || nSelectors > BZ_MAX_SELECTORS) RETURN(BZ_DATA_ERROR);\n// fix_end\n", "cwe": "CWE-787", "cwe_name": "Out-of-bounds Write", "cve": "CVE-2019-12900", "cve_desc": "BZ2_decompress in decompress.c in bzip2 through 1.0.6 has an out-of-bounds write when there are many selectors.", "project": "bzip2", "idx": 208386}
{"source": " static int uvc_scan_chain_forward(struct uvc_video_chain *chain,\n \tstruct uvc_entity *entity, struct uvc_entity *prev)\n {\n \tstruct uvc_entity *forward;\n \tint found;\n \n \tforward = NULL;\n \tfound = 0;\n \n \twhile (1) {\n \t\tforward = uvc_entity_by_reference(chain->dev, entity->id,\n \t\t\tforward);\n \t\tif (forward == NULL)\n \t\t\tbreak;\n \t\tif (forward == prev)\n \t\t\tcontinue;\n// bug_start\n// bug_end\n \n \t\tswitch (UVC_ENTITY_TYPE(forward)) {\n \t\tcase UVC_VC_EXTENSION_UNIT:\n \t\t\tif (forward->bNrInPins != 1) {\n \t\t\t\tuvc_trace(UVC_TRACE_DESCR, \"Extension unit %d \"\n \t\t\t\t\t  \"has more than 1 input pin.\\n\",\n \t\t\t\t\t  entity->id);\n \t\t\t\treturn -EINVAL;\n \t\t\t}\n \n \t\t\tlist_add_tail(&forward->chain, &chain->entities);\n \t\t\tif (uvc_trace_param & UVC_TRACE_PROBE) {\n \t\t\t\tif (!found)\n \t\t\t\t\tprintk(KERN_CONT \" (->\");\n \n \t\t\t\tprintk(KERN_CONT \" XU %d\", forward->id);\n \t\t\t\tfound = 1;\n \t\t\t}\n \t\t\tbreak;\n \n \t\tcase UVC_OTT_VENDOR_SPECIFIC:\n \t\tcase UVC_OTT_DISPLAY:\n \t\tcase UVC_OTT_MEDIA_TRANSPORT_OUTPUT:\n \t\tcase UVC_TT_STREAMING:\n \t\t\tif (UVC_ENTITY_IS_ITERM(forward)) {\n \t\t\t\tuvc_trace(UVC_TRACE_DESCR, \"Unsupported input \"\n \t\t\t\t\t\"terminal %u.\\n\", forward->id);\n \t\t\t\treturn -EINVAL;\n \t\t\t}\n \n \t\t\tlist_add_tail(&forward->chain, &chain->entities);\n \t\t\tif (uvc_trace_param & UVC_TRACE_PROBE) {\n \t\t\t\tif (!found)\n \t\t\t\t\tprintk(KERN_CONT \" (->\");\n \n \t\t\t\tprintk(KERN_CONT \" OT %d\", forward->id);\n \t\t\t\tfound = 1;\n \t\t\t}\n \t\t\tbreak;\n \t\t}\n \t}\n \tif (found)\n \t\tprintk(KERN_CONT \")\");\n \n \treturn 0;\n }\n \n", "target": "// fix_start\n\t\tif (forward->chain.next || forward->chain.prev) {\n\t\t\tuvc_trace(UVC_TRACE_DESCR, \"Found reference to \"\n\t\t\t\t\"entity %d already in chain.\\n\", forward->id);\n\t\t\treturn -EINVAL;\n\t\t}\n// fix_end\n", "cwe": "CWE-269", "cwe_name": "Improper Privilege Management", "cve": "CVE-2020-0404", "cve_desc": "In uvc_scan_chain_forward of uvc_driver.c, there is a possible linked list corruption due to an unusual root cause. This could lead to local escalation of privilege in the kernel with no additional execution privileges needed. User interaction is not needed for exploitation.Product: AndroidVersions: Android kernelAndroid ID: A-111893654References: Upstream kernel", "project": "linux", "idx": 208387}
{"source": " static BOOL rdp_read_font_capability_set(wStream* s, UINT16 length, rdpSettings* settings)\n {\n \tWINPR_UNUSED(settings);\n// bug_start\n\tif (length > 4)\n// bug_end\n \t\tStream_Seek_UINT16(s);\n \n// bug_start\n\tif (length > 6)\n// bug_end\n \t\tStream_Seek_UINT16(s);\n \n \treturn TRUE;\n }\n \n", "target": "// fix_start\n\tif (length > 5)\n// fix_end\n// fix_start\n\tif (length > 7)\n// fix_end\n", "cwe": "CWE-125", "cwe_name": "Out-of-bounds Read", "cve": "CVE-2020-11058", "cve_desc": "In FreeRDP after 1.1 and before 2.0.0, a stream out-of-bounds seek in rdp_read_font_capability_set could lead to a later out-of-bounds read. As a result, a manipulated client or server might force a disconnect due to an invalid data read. This has been fixed in 2.0.0.", "project": "FreeRDP", "idx": 208417}
{"source": " delete_buff_tail(buffheader_T *buf, int slen)\n {\n// bug_start\n    int len = (int)STRLEN(buf->bh_curr->b_str);\n// bug_end\n \n// bug_start\n// bug_end\n     if (len >= slen)\n     {\n \tbuf->bh_curr->b_str[len - slen] = NUL;\n \tbuf->bh_space += slen;\n     }\n }\n \n", "target": "// fix_start\n    int len;\n// fix_end\n// fix_start\n    if (buf->bh_curr == NULL || buf->bh_curr->b_str == NULL)\n\treturn;\n    len = (int)STRLEN(buf->bh_curr->b_str);\n// fix_end\n", "cwe": "CWE-125", "cwe_name": "Out-of-bounds Read", "cve": "CVE-2022-0393", "cve_desc": "Out-of-bounds Read in GitHub repository vim/vim prior to 8.2.", "project": "vim", "idx": 208442}
{"source": " static int is_fuse_usermount(struct libmnt_context *cxt, int *errsv)\n {\n \tstruct libmnt_ns *ns_old;\n \tconst char *type = mnt_fs_get_fstype(cxt->fs);\n \tconst char *optstr;\n// bug_start\n\tchar *user_id = NULL;\n\tsize_t sz;\n\tuid_t uid;\n\tchar uidstr[sizeof(stringify_value(ULONG_MAX))];\n// bug_end\n \n \t*errsv = 0;\n \n \tif (!type)\n \t\treturn 0;\n \n \tif (strcmp(type, \"fuse\") != 0 &&\n \t    strcmp(type, \"fuseblk\") != 0 &&\n \t    strncmp(type, \"fuse.\", 5) != 0 &&\n \t    strncmp(type, \"fuseblk.\", 8) != 0)\n \t\treturn 0;\n \n \toptstr = mnt_fs_get_fs_options(cxt->fs);\n \tif (!optstr)\n \t\treturn 0;\n// bug_start\n\n\tif (mnt_optstr_get_option(optstr, \"user_id\", &user_id, &sz) != 0)\n\t\treturn 0;\n\n\tif (sz == 0 || user_id == NULL)\n// bug_end\n \t\treturn 0;\n \n \tns_old = mnt_context_switch_origin_ns(cxt);\n \tif (!ns_old) {\n \t\t*errsv = -MNT_ERR_NAMESPACE;\n \t\treturn 0;\n \t}\n \n \tuid = getuid();\n \n \tif (!mnt_context_switch_ns(cxt, ns_old)) {\n \t\t*errsv = -MNT_ERR_NAMESPACE;\n \t\treturn 0;\n \t}\n \n// bug_start\n\tsnprintf(uidstr, sizeof(uidstr), \"%lu\", (unsigned long) uid);\n\treturn strncmp(user_id, uidstr, sz) == 0;\n// bug_end\n }\n \n", "target": "// fix_start\n\tuid_t uid, entry_uid;\n// fix_end\n// fix_start\n\tif (mnt_optstr_get_uid(optstr, \"user_id\", &entry_uid) != 0)\n// fix_end\n// fix_start\n\treturn uid == entry_uid;\n// fix_end\n", "cwe": "CWE-703", "cwe_name": "Improper Check or Handling of Exceptional Conditions", "cve": "CVE-2021-3995", "cve_desc": "A logic error was found in the libmount library of util-linux in the function that allows an unprivileged user to unmount a FUSE filesystem. This flaw allows an unprivileged local attacker to unmount FUSE filesystems that belong to certain other users who have a UID that is a prefix of the UID of the attacker in its string form. An attacker may use this flaw to cause a denial of service to applications that use the affected filesystems.", "project": "util-linux", "idx": 208443}
{"source": " static inline void tcp_check_send_head(struct sock *sk, struct sk_buff *skb_unlinked)\n {\n \tif (sk->sk_send_head == skb_unlinked)\n \t\tsk->sk_send_head = NULL;\n// bug_start\n// bug_end\n }\n \n", "target": "// fix_start\n\tif (tcp_sk(sk)->highest_sack == skb_unlinked)\n\t\ttcp_sk(sk)->highest_sack = NULL;\n// fix_end\n", "cwe": "CWE-269", "cwe_name": "Improper Privilege Management", "cve": "CVE-2016-6828", "cve_desc": "The tcp_check_send_head function in include/net/tcp.h in the Linux kernel before 4.7.5 does not properly maintain certain SACK state after a failed data copy, which allows local users to cause a denial of service (tcp_xmit_retransmit_queue use-after-free and system crash) via a crafted SACK option.", "project": "linux", "idx": 208465}
{"source": " static INLINE BOOL ensure_capacity(const BYTE* start, const BYTE* end, size_t size, size_t base)\n {\n \tconst size_t available = (uintptr_t)end - (uintptr_t)start;\n \tconst BOOL rc = available >= size * base;\n// bug_start\n\treturn rc;\n// bug_end\n }\n \n", "target": "// fix_start\n\treturn rc && (start <= end);\n// fix_end\n", "cwe": "CWE-787", "cwe_name": "Out-of-bounds Write", "cve": "CVE-2020-11524", "cve_desc": "libfreerdp/codec/interleaved.c in FreeRDP versions > 1.0 through 2.0.0-rc4 has an Out-of-bounds Write.", "project": "FreeRDP", "idx": 208486}
{"source": " parserule(struct scanner *s, struct environment *env)\n {\n \tstruct rule *r;\n \tchar *var;\n \tstruct evalstring *val;\n \tbool hascommand = false, hasrspfile = false, hasrspcontent = false;\n \n \tr = mkrule(scanname(s));\n \tscannewline(s);\n \twhile (scanindent(s)) {\n \t\tvar = scanname(s);\n \t\tparselet(s, &val);\n \t\truleaddvar(r, var, val);\n// bug_start\n// bug_end\n \t\tif (strcmp(var, \"command\") == 0)\n \t\t\thascommand = true;\n \t\telse if (strcmp(var, \"rspfile\") == 0)\n \t\t\thasrspfile = true;\n \t\telse if (strcmp(var, \"rspfile_content\") == 0)\n \t\t\thasrspcontent = true;\n \t}\n \tif (!hascommand)\n \t\tfatal(\"rule '%s' has no command\", r->name);\n \tif (hasrspfile != hasrspcontent)\n \t\tfatal(\"rule '%s' has rspfile and no rspfile_content or vice versa\", r->name);\n \tenvaddrule(env, r);\n }\n \n", "target": "// fix_start\n\t\tif (!val)\n\t\t\tcontinue;\n// fix_end\n", "cwe": "CWE-284", "cwe_name": "Improper Access Control", "cve": "CVE-2021-30219", "cve_desc": "samurai 1.2 has a NULL pointer dereference in printstatus() function in build.c via a crafted build file.", "project": "samurai", "idx": 208509}
{"source": " handle_add_command(GraphicsManager *self, const GraphicsCommand *g, const uint8_t *payload, bool *is_dirty, uint32_t iid) {\n #define ABRT(code, ...) { set_add_response(#code, __VA_ARGS__); self->loading_image = 0; if (img) img->data_loaded = false; return NULL; }\n #define MAX_DATA_SZ (4u * 100000000u)\n     has_add_respose = false;\n     bool existing, init_img = true;\n     Image *img = NULL;\n     unsigned char tt = g->transmission_type ? g->transmission_type : 'd';\n     enum FORMATS { RGB=24, RGBA=32, PNG=100 };\n     uint32_t fmt = g->format ? g->format : RGBA;\n     if (tt == 'd' && self->loading_image) init_img = false;\n     if (init_img) {\n         self->last_init_graphics_command = *g;\n         self->last_init_graphics_command.id = iid;\n         self->loading_image = 0;\n         if (g->data_width > 10000 || g->data_height > 10000) ABRT(EINVAL, \"Image too large\");\n         remove_images(self, add_trim_predicate, 0);\n         img = find_or_create_image(self, iid, &existing);\n         if (existing) {\n             free_load_data(&img->load_data);\n             img->data_loaded = false;\n             free_refs_data(img);\n             *is_dirty = true;\n             self->layers_dirty = true;\n         } else {\n             img->internal_id = internal_id_counter++;\n             img->client_id = iid;\n         }\n         img->atime = monotonic(); img->used_storage = 0;\n         img->width = g->data_width; img->height = g->data_height;\n         switch(fmt) {\n             case PNG:\n                 if (g->data_sz > MAX_DATA_SZ) ABRT(EINVAL, \"PNG data size too large\");\n                 img->load_data.is_4byte_aligned = true;\n                 img->load_data.is_opaque = false;\n                 img->load_data.data_sz = g->data_sz ? g->data_sz : 1024 * 100;\n                 break;\n             case RGB:\n             case RGBA:\n                 img->load_data.data_sz = (size_t)g->data_width * g->data_height * (fmt / 8);\n                 if (!img->load_data.data_sz) ABRT(EINVAL, \"Zero width/height not allowed\");\n                 img->load_data.is_4byte_aligned = fmt == RGBA || (img->width % 4 == 0);\n                 img->load_data.is_opaque = fmt == RGB;\n                 break;\n             default:\n                 ABRT(EINVAL, \"Unknown image format: %u\", fmt);\n         }\n         if (tt == 'd') {\n             if (g->more) self->loading_image = img->internal_id;\n             img->load_data.buf_capacity = img->load_data.data_sz + (g->compressed ? 1024 : 10);\n             img->load_data.buf = malloc(img->load_data.buf_capacity);\n             img->load_data.buf_used = 0;\n             if (img->load_data.buf == NULL) {\n                 ABRT(ENOMEM, \"Out of memory\");\n                 img->load_data.buf_capacity = 0; img->load_data.buf_used = 0;\n             }\n         }\n     } else {\n         self->last_init_graphics_command.more = g->more;\n         self->last_init_graphics_command.payload_sz = g->payload_sz;\n         g = &self->last_init_graphics_command;\n         tt = g->transmission_type ? g->transmission_type : 'd';\n         fmt = g->format ? g->format : RGBA;\n         img = img_by_internal_id(self, self->loading_image);\n         if (img == NULL) {\n             self->loading_image = 0;\n             ABRT(EILSEQ, \"More payload loading refers to non-existent image\");\n         }\n     }\n     int fd;\n     static char fname[2056] = {0};\n     switch(tt) {\n         case 'd':\n             if (img->load_data.buf_capacity - img->load_data.buf_used < g->payload_sz) {\n                 if (img->load_data.buf_used + g->payload_sz > MAX_DATA_SZ || fmt != PNG) ABRT(EFBIG, \"Too much data\");\n                 img->load_data.buf_capacity = MIN(2 * img->load_data.buf_capacity, MAX_DATA_SZ);\n                 img->load_data.buf = realloc(img->load_data.buf, img->load_data.buf_capacity);\n                 if (img->load_data.buf == NULL) {\n                     ABRT(ENOMEM, \"Out of memory\");\n                     img->load_data.buf_capacity = 0; img->load_data.buf_used = 0;\n                 }\n             }\n             memcpy(img->load_data.buf + img->load_data.buf_used, payload, g->payload_sz);\n             img->load_data.buf_used += g->payload_sz;\n             if (!g->more) { img->data_loaded = true; self->loading_image = 0; }\n             break;\n         case 'f':\n         case 't':\n         case 's':\n             if (g->payload_sz > 2048) ABRT(EINVAL, \"Filename too long\");\n             snprintf(fname, sizeof(fname)/sizeof(fname[0]), \"%.*s\", (int)g->payload_sz, payload);\n             if (tt == 's') fd = shm_open(fname, O_RDONLY, 0);\n             else fd = open(fname, O_CLOEXEC | O_RDONLY);\n// bug_start\n            if (fd == -1) ABRT(EBADF, \"Failed to open file %s for graphics transmission with error: [%d] %s\", fname, errno, strerror(errno));\n// bug_end\n             img->data_loaded = mmap_img_file(self, img, fd, g->data_sz, g->data_offset);\n             safe_close(fd, __FILE__, __LINE__);\n             if (tt == 't') {\n                 if (global_state.boss) { call_boss(safe_delete_temp_file, \"s\", fname); }\n                 else unlink(fname);\n             }\n             else if (tt == 's') shm_unlink(fname);\n             break;\n         default:\n             ABRT(EINVAL, \"Unknown transmission type: %c\", g->transmission_type);\n     }\n     if (!img->data_loaded) return NULL;\n     self->loading_image = 0;\n     bool needs_processing = g->compressed || fmt == PNG;\n     if (needs_processing) {\n         uint8_t *buf; size_t bufsz;\n #define IB { if (img->load_data.buf) { buf = img->load_data.buf; bufsz = img->load_data.buf_used; } else { buf = img->load_data.mapped_file; bufsz = img->load_data.mapped_file_sz; } }\n         switch(g->compressed) {\n             case 'z':\n                 IB;\n                 if (!inflate_zlib(self, img, buf, bufsz)) {\n                     img->data_loaded = false; return NULL;\n                 }\n                 break;\n             case 0:\n                 break;\n             default:\n                 ABRT(EINVAL, \"Unknown image compression: %c\", g->compressed);\n         }\n         switch(fmt) {\n             case PNG:\n                 IB;\n                 if (!inflate_png(self, img, buf, bufsz)) {\n                     img->data_loaded = false; return NULL;\n                 }\n                 break;\n             default: break;\n         }\n #undef IB\n         img->load_data.data = img->load_data.buf;\n         if (img->load_data.buf_used < img->load_data.data_sz) {\n             ABRT(ENODATA, \"Insufficient image data: %zu < %zu\", img->load_data.buf_used, img->load_data.data_sz);\n         }\n         if (img->load_data.mapped_file) {\n             munmap(img->load_data.mapped_file, img->load_data.mapped_file_sz);\n             img->load_data.mapped_file = NULL; img->load_data.mapped_file_sz = 0;\n         }\n     } else {\n         if (tt == 'd') {\n             if (img->load_data.buf_used < img->load_data.data_sz) {\n                 ABRT(ENODATA, \"Insufficient image data: %zu < %zu\",  img->load_data.buf_used, img->load_data.data_sz);\n             } else img->load_data.data = img->load_data.buf;\n         } else {\n             if (img->load_data.mapped_file_sz < img->load_data.data_sz) {\n                 ABRT(ENODATA, \"Insufficient image data: %zu < %zu\",  img->load_data.mapped_file_sz, img->load_data.data_sz);\n             } else img->load_data.data = img->load_data.mapped_file;\n         }\n     }\n     size_t required_sz = (size_t)(img->load_data.is_opaque ? 3 : 4) * img->width * img->height;\n     if (img->load_data.data_sz != required_sz) ABRT(EINVAL, \"Image dimensions: %ux%u do not match data size: %zu, expected size: %zu\", img->width, img->height, img->load_data.data_sz, required_sz);\n     if (LIKELY(img->data_loaded && send_to_gpu)) {\n         send_image_to_gpu(&img->texture_id, img->load_data.data, img->width, img->height, img->load_data.is_opaque, img->load_data.is_4byte_aligned, false, REPEAT_CLAMP);\n         free_load_data(&img->load_data);\n         self->used_storage += required_sz;\n         img->used_storage = required_sz;\n     }\n     return img;\n #undef MAX_DATA_SZ\n #undef ABRT\n }\n \n", "target": "// fix_start\n            if (fd == -1) ABRT(EBADF, \"Failed to open file for graphics transmission with error: [%d] %s\", errno, strerror(errno));\n// fix_end\n", "cwe": "CWE-787", "cwe_name": "Out-of-bounds Write", "cve": "CVE-2020-35605", "cve_desc": "The Graphics Protocol feature in graphics.c in kitty before 0.19.3 allows remote attackers to execute arbitrary code because a filename containing special characters can be included in an error message.", "project": "kitty", "idx": 208514}
{"source": " HRESULT Http::HrReadHeaders()\n {\n \tHRESULT hr;\n \tstd::string strBuffer;\n \tULONG n = 0;\n \tstd::map<std::string, std::string>::iterator iHeader = mapHeaders.end();\n// bug_start\n// bug_end\n \n \tec_log_debug(\"Receiving headers:\");\n \tdo\n \t{\n \t\thr = m_lpChannel->HrReadLine(strBuffer);\n \t\tif (hr != hrSuccess)\n \t\t\treturn hr;\n \t\tif (strBuffer.empty())\n \t\t\tbreak;\n// bug_start\n// bug_end\n \n \t\tif (n == 0) {\n \t\t\tm_strAction = strBuffer;\n \t\t} else {\n \t\t\tauto pos = strBuffer.find(':');\n \t\t\tsize_t start = 0;\n \n \t\t\tif (strBuffer[0] == ' ' || strBuffer[0] == '\\t') {\n \t\t\t\tif (iHeader == mapHeaders.end())\n \t\t\t\t\tcontinue;\n \t\t\t\twhile (strBuffer[start] == ' ' || strBuffer[start] == '\\t')\n \t\t\t\t\t++start;\n \t\t\t\tiHeader->second += strBuffer.substr(start);\n \t\t\t} else {\n \t\t\t\tauto r = mapHeaders.emplace(strBuffer.substr(0, pos), strBuffer.substr(pos + 2));\n \t\t\t\tiHeader = r.first;\n \t\t\t}\n \t\t}\n \n \t\tif (strBuffer.find(\"Authorization\") != std::string::npos)\n \t\t\tec_log_debug(\"< Authorization: <value hidden>\");\n \t\telse\n \t\t\tec_log_debug(\"< \"+strBuffer);\n \t\t++n;\n \t} while(hr == hrSuccess);\n \n \thr = HrParseHeaders();\n \tif (hr != hrSuccess)\n \t\thr_ldebug(hr, \"parsing headers failed\");\n \treturn hr;\n }\n \n", "target": "// fix_start\n\tstatic constexpr std::size_t MAX_HEADER_LENGTH = 65536;\n\tstd::size_t numOfBytesRead = 0;\n// fix_end\n// fix_start\n\n\t\tnumOfBytesRead += strBuffer.size();\n\t\tif(numOfBytesRead > MAX_HEADER_LENGTH) {\n\t\t\treturn MAPI_E_TOO_BIG;\n\t\t}\n// fix_end\n", "cwe": "CWE-770", "cwe_name": "Allocation of Resources Without Limits or Throttling", "cve": "CVE-2021-28994", "cve_desc": "kopano-ical (formerly zarafa-ical) in Kopano Groupware Core through 8.7.16, 9.x through 9.1.0, 10.x through 10.0.7, and 11.x through 11.0.1 and Zarafa 6.30.x through 7.2.x allows memory exhaustion via long HTTP headers.", "project": "kopano-core", "idx": 208547}
{"source": " ImagingLibTiffDecode(\n     Imaging im, ImagingCodecState state, UINT8 *buffer, Py_ssize_t bytes) {\n     TIFFSTATE *clientstate = (TIFFSTATE *)state->context;\n     char *filename = \"tempfile.tif\";\n     char *mode = \"r\";\n     TIFF *tiff;\n     uint16 photometric = 0;\n     int isYCbCr = 0;\n \n \n     TRACE((\"in decoder: bytes %d\\n\", bytes));\n     TRACE(\n         (\"State: count %d, state %d, x %d, y %d, ystep %d\\n\",\n          state->count,\n          state->state,\n          state->x,\n          state->y,\n          state->ystep));\n     TRACE(\n         (\"State: xsize %d, ysize %d, xoff %d, yoff %d \\n\",\n          state->xsize,\n          state->ysize,\n          state->xoff,\n          state->yoff));\n     TRACE((\"State: bits %d, bytes %d \\n\", state->bits, state->bytes));\n     TRACE(\n         (\"Buffer: %p: %c%c%c%c\\n\",\n          buffer,\n          (char)buffer[0],\n          (char)buffer[1],\n          (char)buffer[2],\n          (char)buffer[3]));\n     TRACE(\n         (\"State->Buffer: %c%c%c%c\\n\",\n          (char)state->buffer[0],\n          (char)state->buffer[1],\n          (char)state->buffer[2],\n          (char)state->buffer[3]));\n     TRACE(\n         (\"Image: mode %s, type %d, bands: %d, xsize %d, ysize %d \\n\",\n          im->mode,\n          im->type,\n          im->bands,\n          im->xsize,\n          im->ysize));\n     TRACE(\n         (\"Image: image8 %p, image32 %p, image %p, block %p \\n\",\n          im->image8,\n          im->image32,\n          im->image,\n          im->block));\n     TRACE((\"Image: pixelsize: %d, linesize %d \\n\", im->pixelsize, im->linesize));\n \n     dump_state(clientstate);\n     clientstate->size = bytes;\n     clientstate->eof = clientstate->size;\n     clientstate->loc = 0;\n     clientstate->data = (tdata_t)buffer;\n     clientstate->flrealloc = 0;\n     dump_state(clientstate);\n \n     TIFFSetWarningHandler(NULL);\n     TIFFSetWarningHandlerExt(NULL);\n \n     if (clientstate->fp) {\n         TRACE((\"Opening using fd: %d\\n\", clientstate->fp));\n         lseek(clientstate->fp, 0, SEEK_SET);\n         tiff = TIFFFdOpen(fd_to_tiff_fd(clientstate->fp), filename, mode);\n     } else {\n         TRACE((\"Opening from string\\n\"));\n         tiff = TIFFClientOpen(\n             filename,\n             mode,\n             (thandle_t)clientstate,\n             _tiffReadProc,\n             _tiffWriteProc,\n             _tiffSeekProc,\n             _tiffCloseProc,\n             _tiffSizeProc,\n             _tiffMapProc,\n             _tiffUnmapProc);\n     }\n \n     if (!tiff) {\n         TRACE((\"Error, didn't get the tiff\\n\"));\n         state->errcode = IMAGING_CODEC_BROKEN;\n         return -1;\n     }\n \n     if (clientstate->ifd) {\n         int rv;\n         uint32 ifdoffset = clientstate->ifd;\n         TRACE((\"reading tiff ifd %u\\n\", ifdoffset));\n         rv = TIFFSetSubDirectory(tiff, ifdoffset);\n         if (!rv) {\n             TRACE((\"error in TIFFSetSubDirectory\"));\n             goto decode_err;\n         }\n     }\n \n     TIFFGetField(tiff, TIFFTAG_PHOTOMETRIC, &photometric);\n     isYCbCr = photometric == PHOTOMETRIC_YCBCR;\n \n     if (TIFFIsTiled(tiff)) {\n         INT32 x, y, tile_y;\n         UINT32 tile_width, tile_length, current_tile_length, current_line,\n             current_tile_width, row_byte_size;\n         UINT8 *new_data;\n \n         TIFFGetField(tiff, TIFFTAG_TILEWIDTH, &tile_width);\n         TIFFGetField(tiff, TIFFTAG_TILELENGTH, &tile_length);\n \n         if ((UINT32)INT_MAX / state->bits < tile_width) {\n             state->errcode = IMAGING_CODEC_MEMORY;\n             goto decode_err;\n         }\n \n         if (isYCbCr) {\n             row_byte_size = tile_width * 4;\n             if (im->pixelsize != 4) {\n                 state->errcode = IMAGING_CODEC_BROKEN;\n                 goto decode_err;\n             }\n         } else {\n             row_byte_size = (tile_width * state->bits + 7) / 8;\n         }\n \n         if (INT_MAX / row_byte_size < tile_length) {\n             state->errcode = IMAGING_CODEC_MEMORY;\n             goto decode_err;\n         }\n \n         state->bytes = row_byte_size * tile_length;\n \n         if (TIFFTileSize(tiff) > state->bytes) {\n             state->errcode = IMAGING_CODEC_MEMORY;\n             goto decode_err;\n         }\n \n         new_data = realloc(state->buffer, state->bytes);\n         if (!new_data) {\n             state->errcode = IMAGING_CODEC_MEMORY;\n             goto decode_err;\n         }\n \n         state->buffer = new_data;\n \n         TRACE((\"TIFFTileSize: %d\\n\", state->bytes));\n \n         for (y = state->yoff; y < state->ysize; y += tile_length) {\n             for (x = state->xoff; x < state->xsize; x += tile_width) {\n// bug_start\n// bug_end\n                 if (isYCbCr) {\n                     if (!TIFFReadRGBATile(tiff, x, y, (UINT32 *)state->buffer)) {\n                         TRACE((\"Decode Error, Tile at %dx%d\\n\", x, y));\n                         state->errcode = IMAGING_CODEC_BROKEN;\n                         goto decode_err;\n                     }\n                 } else {\n                     if (TIFFReadTile(tiff, (tdata_t)state->buffer, x, y, 0, 0) == -1) {\n                         TRACE((\"Decode Error, Tile at %dx%d\\n\", x, y));\n                         state->errcode = IMAGING_CODEC_BROKEN;\n                         goto decode_err;\n                     }\n                 }\n \n                 TRACE((\"Read tile at %dx%d; \\n\\n\", x, y));\n \n                 current_tile_width = min((INT32)tile_width, state->xsize - x);\n                 current_tile_length = min((INT32)tile_length, state->ysize - y);\n                 for (tile_y = 0; tile_y < current_tile_length; tile_y++) {\n                     TRACE(\n                         (\"Writing tile data at %dx%d using tile_width: %d; \\n\",\n                          tile_y + y,\n                          x,\n                          current_tile_width));\n \n \n                     if (isYCbCr) {\n                         current_line = tile_length - tile_y - 1;\n                     } else {\n                         current_line = tile_y;\n                     }\n \n                     state->shuffle(\n                         (UINT8 *)im->image[tile_y + y] + x * im->pixelsize,\n                         state->buffer + current_line * row_byte_size,\n                         current_tile_width);\n                 }\n             }\n         }\n     } else {\n         if (!isYCbCr) {\n             _decodeStrip(im, state, tiff);\n         } else {\n             _decodeStripYCbCr(im, state, tiff);\n         }\n     }\n \n decode_err:\n     TIFFClose(tiff);\n     TRACE((\"Done Decoding, Returning \\n\"));\n     return -1;\n }\n \n", "target": "// fix_start\n                if (!TIFFCheckTile(tiff, x, y, 0, 0)) {\n                    TRACE((\"Check Tile Error, Tile at %dx%d\\n\", x, y));\n                    state->errcode = IMAGING_CODEC_BROKEN;\n                    goto decode_err;\n                }\n// fix_end\n", "cwe": "CWE-125", "cwe_name": "Out-of-bounds Read", "cve": "CVE-2021-25291", "cve_desc": "An issue was discovered in Pillow before 8.1.1. In TiffDecode.c, there is an out-of-bounds read in TiffreadRGBATile via invalid tile boundaries.", "project": "Pillow", "idx": 208556}
{"source": " mt76_add_fragment(struct mt76_dev *dev, struct mt76_queue *q, void *data,\n \t\t  int len, bool more)\n {\n \tstruct page *page = virt_to_head_page(data);\n \tint offset = data - page_address(page);\n \tstruct sk_buff *skb = q->rx_head;\n// bug_start\n// bug_end\n \n// bug_start\n\toffset += q->buf_offset;\n\tskb_add_rx_frag(skb, skb_shinfo(skb)->nr_frags, page, offset, len,\n\t\t\tq->buf_size);\n// bug_end\n \n \tif (more)\n \t\treturn;\n \n \tq->rx_head = NULL;\n \tdev->drv->rx_skb(dev, q - dev->q_rx, skb);\n }\n \n", "target": "// fix_start\n\tstruct skb_shared_info *shinfo = skb_shinfo(skb);\n// fix_end\n// fix_start\n\tif (shinfo->nr_frags < ARRAY_SIZE(shinfo->frags)) {\n\t\toffset += q->buf_offset;\n\t\tskb_add_rx_frag(skb, shinfo->nr_frags, page, offset, len,\n\t\t\t\tq->buf_size);\n\t}\n// fix_end\n", "cwe": "CWE-787", "cwe_name": "Out-of-bounds Write", "cve": "CVE-2020-12465", "cve_desc": "An array overflow was discovered in mt76_add_fragment in drivers/net/wireless/mediatek/mt76/dma.c in the Linux kernel before 5.5.10, aka CID-b102f0c522cf. An oversized packet with too many rx fragments can corrupt memory of adjacent pages.", "project": "linux", "idx": 208640}
{"source": " ext_get_plugin(const char *name, const char *module, const char *revision)\n {\n     uint16_t u;\n \n     assert(name);\n     assert(module);\n \n     for (u = 0; u < ext_plugins_count; u++) {\n// bug_start\n        if (!strcmp(name, ext_plugins[u].name) &&\n                !strcmp(module, ext_plugins[u].module) &&\n                (!ext_plugins[u].revision || !strcmp(revision, ext_plugins[u].revision))) {\n// bug_end\n             return ext_plugins[u].plugin;\n         }\n     }\n \n     return NULL;\n }\n \n", "target": "// fix_start\n        if (!strcmp(name, ext_plugins[u].name) && !strcmp(module, ext_plugins[u].module) &&\n                ((!revision && !ext_plugins[u].revision) || (revision && !strcmp(revision, ext_plugins[u].revision)))) {\n// fix_end\n", "cwe": "CWE-252", "cwe_name": "Unchecked Return Value", "cve": "CVE-2021-28904", "cve_desc": "In function ext_get_plugin() in libyang <= v1.0.225, it doesn't check whether the value of revision is NULL. If revision is NULL, the operation of strcmp(revision, ext_plugins[u].revision) will lead to a crash.", "project": "libyang", "idx": 208672}
{"source": " FastHufDecoder::FastHufDecoder\n     (const char *&table,\n      int numBytes,\n      int minSymbol,\n      int maxSymbol,\n      int rleSymbol)\n :\n     _rleSymbol (rleSymbol),\n     _numSymbols (0),\n     _minCodeLength (255),\n     _maxCodeLength (0),\n     _idToSymbol (0)\n {\n \n     std::vector<Int64> symbols;\n \n \n     Int64 base[MAX_CODE_LEN + 1];\n \n \n     Int64 offset[MAX_CODE_LEN + 1];\n \n \n     size_t codeCount[MAX_CODE_LEN + 1];\n \n     for (int i = 0; i <= MAX_CODE_LEN; ++i)\n     {\n         codeCount[i] = 0;\n         base[i]      = 0xffffffffffffffffULL;\n         offset[i]    = 0;\n     }\n \n \n     const char *currByte     = table;\n     Int64       currBits     = 0;\n     int         currBitCount = 0;\n \n     const int SHORT_ZEROCODE_RUN = 59;\n     const int LONG_ZEROCODE_RUN  = 63;\n     const int SHORTEST_LONG_RUN  = 2 + LONG_ZEROCODE_RUN - SHORT_ZEROCODE_RUN;\n \n     for (Int64 symbol = static_cast<Int64>(minSymbol); symbol <= static_cast<Int64>(maxSymbol); symbol++)\n     {\n         if (currByte - table > numBytes)\n         {\n             throw IEX_NAMESPACE::InputExc (\"Error decoding Huffman table \"\n                                            \"(Truncated table data).\");\n         }\n \n \n         Int64 codeLen = readBits (6, currBits, currBitCount, currByte);\n \n         if (codeLen == (Int64) LONG_ZEROCODE_RUN)\n         {\n             if (currByte - table > numBytes)\n             {\n                 throw IEX_NAMESPACE::InputExc (\"Error decoding Huffman table \"\n                                                \"(Truncated table data).\");\n             }\n \n             int runLen = readBits (8, currBits, currBitCount, currByte) +\n                          SHORTEST_LONG_RUN;\n \n             if (symbol + runLen > static_cast<Int64>(maxSymbol + 1))\n             {\n                 throw IEX_NAMESPACE::InputExc (\"Error decoding Huffman table \"\n                                                \"(Run beyond end of table).\");\n             }\n \n             symbol += runLen - 1;\n \n         }\n         else if (codeLen >= static_cast<Int64>(SHORT_ZEROCODE_RUN))\n         {\n             int runLen = codeLen - SHORT_ZEROCODE_RUN + 2;\n \n             if (symbol + runLen > static_cast<Int64>(maxSymbol + 1))\n             {\n                 throw IEX_NAMESPACE::InputExc (\"Error decoding Huffman table \"\n                                                \"(Run beyond end of table).\");\n             }\n \n             symbol += runLen - 1;\n \n         }\n         else if (codeLen != 0)\n         {\n             symbols.push_back ((symbol << 6) | (codeLen & 63));\n \n             if (codeLen < _minCodeLength)\n                 _minCodeLength = codeLen;\n \n             if (codeLen > _maxCodeLength)\n                 _maxCodeLength = codeLen;\n \n             codeCount[codeLen]++;\n         }\n     }\n \n     for (int i = 0; i < MAX_CODE_LEN; ++i)\n         _numSymbols += codeCount[i];\n \n     table = currByte;\n \n \n     {\n         double* countTmp = new double[_maxCodeLength+1];\n \n         for (int l = _minCodeLength; l <= _maxCodeLength; ++l)\n         {\n             countTmp[l] = (double)codeCount[l] *\n// bug_start\n                          (double)(2 << (_maxCodeLength-l));\n// bug_end\n         }\n \n         for (int l = _minCodeLength; l <= _maxCodeLength; ++l)\n         {\n             double tmp = 0;\n \n             for (int k =l + 1; k <= _maxCodeLength; ++k)\n                 tmp += countTmp[k];\n \n// bug_start\n            tmp /= (double)(2 << (_maxCodeLength - l));\n// bug_end\n \n             base[l] = (Int64)ceil (tmp);\n         }\n \n         delete [] countTmp;\n     }\n \n \n     offset[_maxCodeLength] = 0;\n \n     for (int i= _maxCodeLength - 1; i >= _minCodeLength; i--)\n         offset[i] = offset[i + 1] + codeCount[i + 1];\n \n \n     _idToSymbol = new int[_numSymbols];\n \n     Int64 mapping[MAX_CODE_LEN + 1];\n     for (int i = 0; i < MAX_CODE_LEN + 1; ++i)\n         mapping[i] = -1;\n     for (int i = _minCodeLength; i <= _maxCodeLength; ++i)\n         mapping[i] = offset[i];\n \n     for (std::vector<Int64>::const_iterator i = symbols.begin();\n          i != symbols.end();\n          ++i)\n     {\n         int codeLen = *i & 63;\n         int symbol  = *i >> 6;\n \n         if (mapping[codeLen] >= static_cast<Int64>(_numSymbols))\n         {\n             delete[] _idToSymbol;\n             _idToSymbol = NULL;\n             throw IEX_NAMESPACE::InputExc (\"Huffman decode error \"\n                                            \"(Invalid symbol in header).\");\n         }\n         _idToSymbol[mapping[codeLen]] = symbol;\n         mapping[codeLen]++;\n     }\n \n     try\n     {\n       buildTables(base, offset);\n     }catch(...)\n     {\n             delete[] _idToSymbol;\n             _idToSymbol = NULL;\n             throw;\n     }\n }\n \n", "target": "// fix_start\n                          (double)(2ll << (_maxCodeLength-l));\n// fix_end\n// fix_start\n            tmp /= (double)(2ll << (_maxCodeLength - l));\n// fix_end\n", "cwe": "CWE-190", "cwe_name": "Integer Overflow or Wraparound", "cve": "CVE-2021-3474", "cve_desc": "There's a flaw in OpenEXR in versions before 3.0.0-beta. A crafted input file that is processed by OpenEXR could cause a shift overflow in the FastHufDecoder, potentially leading to problems with application availability.", "project": "openexr", "idx": 208675}
{"source": " static zval *phar_rename_archive(phar_archive_data *phar, char *ext, zend_bool compress TSRMLS_DC)\n {\n \tconst char *oldname = NULL;\n \tchar *oldpath = NULL;\n \tchar *basename = NULL, *basepath = NULL;\n \tchar *newname = NULL, *newpath = NULL;\n \tzval *ret, arg1;\n \tzend_class_entry *ce;\n \tchar *error;\n \tconst char *pcr_error;\n \tint ext_len = ext ? strlen(ext) : 0;\n \tint oldname_len;\n \tphar_archive_data **pphar = NULL;\n \tphp_stream_statbuf ssb;\n \n \tif (!ext) {\n \t\tif (phar->is_zip) {\n \n \t\t\tif (phar->is_data) {\n \t\t\t\text = \"zip\";\n \t\t\t} else {\n \t\t\t\text = \"phar.zip\";\n \t\t\t}\n \n \t\t} else if (phar->is_tar) {\n \n \t\t\tswitch (phar->flags) {\n \t\t\t\tcase PHAR_FILE_COMPRESSED_GZ:\n \t\t\t\t\tif (phar->is_data) {\n \t\t\t\t\t\text = \"tar.gz\";\n \t\t\t\t\t} else {\n \t\t\t\t\t\text = \"phar.tar.gz\";\n \t\t\t\t\t}\n \t\t\t\t\tbreak;\n \t\t\t\tcase PHAR_FILE_COMPRESSED_BZ2:\n \t\t\t\t\tif (phar->is_data) {\n \t\t\t\t\t\text = \"tar.bz2\";\n \t\t\t\t\t} else {\n \t\t\t\t\t\text = \"phar.tar.bz2\";\n \t\t\t\t\t}\n \t\t\t\t\tbreak;\n \t\t\t\tdefault:\n \t\t\t\t\tif (phar->is_data) {\n \t\t\t\t\t\text = \"tar\";\n \t\t\t\t\t} else {\n \t\t\t\t\t\text = \"phar.tar\";\n \t\t\t\t\t}\n \t\t\t}\n \t\t} else {\n \n \t\t\tswitch (phar->flags) {\n \t\t\t\tcase PHAR_FILE_COMPRESSED_GZ:\n \t\t\t\t\text = \"phar.gz\";\n \t\t\t\t\tbreak;\n \t\t\t\tcase PHAR_FILE_COMPRESSED_BZ2:\n \t\t\t\t\text = \"phar.bz2\";\n \t\t\t\t\tbreak;\n \t\t\t\tdefault:\n \t\t\t\t\text = \"phar\";\n \t\t\t}\n \t\t}\n \t} else if (phar_path_check(&ext, &ext_len, &pcr_error) > pcr_is_ok) {\n \n \t\tif (phar->is_data) {\n \t\t\tzend_throw_exception_ex(spl_ce_BadMethodCallException, 0 TSRMLS_CC, \"data phar converted from \\\"%s\\\" has invalid extension %s\", phar->fname, ext);\n \t\t} else {\n \t\t\tzend_throw_exception_ex(spl_ce_BadMethodCallException, 0 TSRMLS_CC, \"phar converted from \\\"%s\\\" has invalid extension %s\", phar->fname, ext);\n \t\t}\n \t\treturn NULL;\n \t}\n \n \tif (ext[0] == '.') {\n \t\t++ext;\n \t}\n \n \toldpath = estrndup(phar->fname, phar->fname_len);\n \toldname = zend_memrchr(phar->fname, '/', phar->fname_len);\n \t++oldname;\n \toldname_len = strlen(oldname);\n \n \tbasename = estrndup(oldname, oldname_len);\n \tspprintf(&newname, 0, \"%s.%s\", strtok(basename, \".\"), ext);\n \tefree(basename);\n \n \n \n \tbasepath = estrndup(oldpath, (strlen(oldpath) - oldname_len));\n \tphar->fname_len = spprintf(&newpath, 0, \"%s%s\", basepath, newname);\n \tphar->fname = newpath;\n \tphar->ext = newpath + phar->fname_len - strlen(ext) - 1;\n \tefree(basepath);\n \tefree(newname);\n \n \tif (PHAR_G(manifest_cached) && SUCCESS == zend_hash_find(&cached_phars, newpath, phar->fname_len, (void **) &pphar)) {\n \t\tefree(oldpath);\n \t\tzend_throw_exception_ex(spl_ce_BadMethodCallException, 0 TSRMLS_CC, \"Unable to add newly converted phar \\\"%s\\\" to the list of phars, new phar name is in phar.cache_list\", phar->fname);\n \t\treturn NULL;\n \t}\n \n \tif (SUCCESS == zend_hash_find(&(PHAR_GLOBALS->phar_fname_map), newpath, phar->fname_len, (void **) &pphar)) {\n \t\tif ((*pphar)->fname_len == phar->fname_len && !memcmp((*pphar)->fname, phar->fname, phar->fname_len)) {\n \t\t\tif (!zend_hash_num_elements(&phar->manifest)) {\n \t\t\t\t(*pphar)->is_tar = phar->is_tar;\n \t\t\t\t(*pphar)->is_zip = phar->is_zip;\n \t\t\t\t(*pphar)->is_data = phar->is_data;\n \t\t\t\t(*pphar)->flags = phar->flags;\n \t\t\t\t(*pphar)->fp = phar->fp;\n \t\t\t\tphar->fp = NULL;\n \t\t\t\tphar_destroy_phar_data(phar TSRMLS_CC);\n \t\t\t\tphar = *pphar;\n \t\t\t\tphar->refcount++;\n \t\t\t\tnewpath = oldpath;\n \t\t\t\tgoto its_ok;\n \t\t\t}\n \t\t}\n \n \t\tefree(oldpath);\n \t\tzend_throw_exception_ex(spl_ce_BadMethodCallException, 0 TSRMLS_CC, \"Unable to add newly converted phar \\\"%s\\\" to the list of phars, a phar with that name already exists\", phar->fname);\n \t\treturn NULL;\n \t}\n its_ok:\n \tif (SUCCESS == php_stream_stat_path(newpath, &ssb)) {\n// bug_start\n// bug_end\n \t\tefree(oldpath);\n// bug_start\n\t\tzend_throw_exception_ex(spl_ce_BadMethodCallException, 0 TSRMLS_CC, \"phar \\\"%s\\\" exists and must be unlinked prior to conversion\", newpath);\n// bug_end\n \t\treturn NULL;\n \t}\n \tif (!phar->is_data) {\n \t\tif (SUCCESS != phar_detect_phar_fname_ext(newpath, phar->fname_len, (const char **) &(phar->ext), &(phar->ext_len), 1, 1, 1 TSRMLS_CC)) {\n \t\t\tefree(oldpath);\n \t\t\tzend_throw_exception_ex(spl_ce_BadMethodCallException, 0 TSRMLS_CC, \"phar \\\"%s\\\" has invalid extension %s\", phar->fname, ext);\n \t\t\treturn NULL;\n \t\t}\n \n \t\tif (phar->alias) {\n \t\t\tif (phar->is_temporary_alias) {\n \t\t\t\tphar->alias = NULL;\n \t\t\t\tphar->alias_len = 0;\n \t\t\t} else {\n \t\t\t\tphar->alias = estrndup(newpath, strlen(newpath));\n \t\t\t\tphar->alias_len = strlen(newpath);\n \t\t\t\tphar->is_temporary_alias = 1;\n \t\t\t\tzend_hash_update(&(PHAR_GLOBALS->phar_alias_map), newpath, phar->fname_len, (void*)&phar, sizeof(phar_archive_data*), NULL);\n \t\t\t}\n \t\t}\n \n \t} else {\n \n \t\tif (SUCCESS != phar_detect_phar_fname_ext(newpath, phar->fname_len, (const char **) &(phar->ext), &(phar->ext_len), 0, 1, 1 TSRMLS_CC)) {\n \t\t\tefree(oldpath);\n \t\t\tzend_throw_exception_ex(spl_ce_BadMethodCallException, 0 TSRMLS_CC, \"data phar \\\"%s\\\" has invalid extension %s\", phar->fname, ext);\n \t\t\treturn NULL;\n \t\t}\n \n \t\tphar->alias = NULL;\n \t\tphar->alias_len = 0;\n \t}\n \n \tif ((!pphar || phar == *pphar) && SUCCESS != zend_hash_update(&(PHAR_GLOBALS->phar_fname_map), newpath, phar->fname_len, (void*)&phar, sizeof(phar_archive_data*), NULL)) {\n \t\tefree(oldpath);\n \t\tzend_throw_exception_ex(spl_ce_BadMethodCallException, 0 TSRMLS_CC, \"Unable to add newly converted phar \\\"%s\\\" to the list of phars\", phar->fname);\n \t\treturn NULL;\n \t}\n \n \tphar_flush(phar, 0, 0, 1, &error TSRMLS_CC);\n \n \tif (error) {\n \t\tzend_throw_exception_ex(spl_ce_BadMethodCallException, 0 TSRMLS_CC, \"%s\", error);\n \t\tefree(error);\n \t\tefree(oldpath);\n \t\treturn NULL;\n \t}\n \n \tefree(oldpath);\n \n \tif (phar->is_data) {\n \t\tce = phar_ce_data;\n \t} else {\n \t\tce = phar_ce_archive;\n \t}\n \n \tMAKE_STD_ZVAL(ret);\n \n \tif (SUCCESS != object_init_ex(ret, ce)) {\n \t\tzval_dtor(ret);\n \t\tzend_throw_exception_ex(spl_ce_BadMethodCallException, 0 TSRMLS_CC, \"Unable to instantiate phar object when converting archive \\\"%s\\\"\", phar->fname);\n \t\treturn NULL;\n \t}\n \n \tINIT_PZVAL(&arg1);\n \tZVAL_STRINGL(&arg1, phar->fname, phar->fname_len, 0);\n \n \tzend_call_method_with_1_params(&ret, ce, &ce->constructor, \"__construct\", NULL, &arg1);\n \treturn ret;\n }\n \n", "target": "// fix_start\n\t\tzend_throw_exception_ex(spl_ce_BadMethodCallException, 0 TSRMLS_CC, \"phar \\\"%s\\\" exists and must be unlinked prior to conversion\", newpath);\n// fix_end\n// fix_start\n// fix_end\n", "cwe": "CWE-416", "cwe_name": "Use After Free", "cve": "CVE-2015-2301", "cve_desc": "Use-after-free vulnerability in the phar_rename_archive function in phar_object.c in PHP before 5.5.22 and 5.6.x before 5.6.6 allows remote attackers to cause a denial of service or possibly have unspecified other impact via vectors that trigger an attempted renaming of a Phar archive to the name of an existing file.", "project": "php-src", "idx": 208677}
{"source": "// bug_start\nrndr_quote(struct buf *ob, const struct buf *text, void *opaque)\n// bug_end\n {\n \tif (!text || !text->size)\n \t\treturn 0;\n \n// bug_start\n\tBUFPUTSL(ob, \"<q>\");\n// bug_end\n \tbufput(ob, text->data, text->size);\n// bug_start\n\tBUFPUTSL(ob, \"</q>\");\n// bug_end\n \n \treturn 1;\n }\n \n", "target": "// fix_start\nrndr_underline(struct buf *ob, const struct buf *text, void *opaque)\n// fix_end\n// fix_start\n\tBUFPUTSL(ob, \"<u>\");\n// fix_end\n// fix_start\n\tBUFPUTSL(ob, \"</u>\");\n// fix_end\n", "cwe": "CWE-79", "cwe_name": "Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')", "cve": "CVE-2020-26298", "cve_desc": "Redcarpet is a Ruby library for Markdown processing. In Redcarpet before version 3.5.1, there is an injection vulnerability which can enable a cross-site scripting attack. In affected versions no HTML escaping was being performed when processing quotes. This applies even when the `:escape_html` option was being used. This is fixed in version 3.5.1 by the referenced commit.", "project": "redcarpet", "idx": 208718}
{"source": " ppm_load_read_header(FILE       *fp,\n                      pnm_struct *img)\n {\n     gchar *ptr;\n     gchar  header[MAX_CHARS_IN_ROW];\n     gint   maxval;\n \n     fgets (header,MAX_CHARS_IN_ROW,fp);\n \n     if (header[0] != ASCII_P ||\n         (header[1] != PIXMAP_ASCII &&\n          header[1] != PIXMAP_RAW))\n       {\n         g_warning (\"Image is not a portable pixmap\");\n         return FALSE;\n       }\n \n     img->type = header[1];\n \n     fgets (header,MAX_CHARS_IN_ROW,fp);\n     while(header[0] == '#')\n       {\n         fgets (header,MAX_CHARS_IN_ROW,fp);\n       }\n \n// bug_start\n    img->width  = strtol (header,&ptr,0);\n    img->height = atoi (ptr);\n// bug_end\n \n     fgets (header,MAX_CHARS_IN_ROW,fp);\n// bug_start\n    maxval = strtol (header,&ptr,0);\n// bug_end\n \n     if ((maxval != 255) && (maxval != 65535))\n       {\n         g_warning (\"Image is not an 8-bit or 16-bit portable pixmap\");\n         return FALSE;\n       }\n \n   switch (maxval)\n     {\n     case 255:\n       img->bpc = sizeof (guchar);\n       break;\n \n     case 65535:\n       img->bpc = sizeof (gushort);\n       break;\n \n     default:\n       g_warning (\"%s: Programmer stupidity error\", G_STRLOC);\n     }\n \n     if (!img->width || !img->height ||\n         G_MAXSIZE / img->width / img->height / CHANNEL_COUNT < img->bpc)\n       {\n         g_warning (\"Illegal width/height: %ld/%ld\", img->width, img->height);\n         return FALSE;\n       }\n     img->numsamples = img->width * img->height * CHANNEL_COUNT;\n \n     return TRUE;\n }\n \n", "target": "// fix_start\n    errno = 0;\n    img->width  = strtol (header,&ptr,10);\n    if (errno)\n      {\n        g_warning (\"Error reading width: %s\", strerror(errno));\n        return FALSE;\n      }\n    else if (img->width < 0)\n      {\n        g_warning (\"Error: width is negative\");\n        return FALSE;\n      }\n\n    img->height = strtol (ptr,&ptr,10);\n    if (errno)\n      {\n        g_warning (\"Error reading height: %s\", strerror(errno));\n        return FALSE;\n      }\n    else if (img->width < 0)\n      {\n        g_warning (\"Error: height is negative\");\n        return FALSE;\n      }\n// fix_end\n// fix_start\n    maxval = strtol (header,&ptr,10);\n// fix_end\n", "cwe": "CWE-189", "cwe_name": "Numeric Errors", "cve": "CVE-2012-4433", "cve_desc": "Multiple integer overflows in operations/external/ppm-load.c in GEGL (Generic Graphics Library) 0.2.0 allow remote attackers to cause a denial of service (application crash) or possibly execute arbitrary code via a large (1) width or (2) height value in a Portable Pixel Map (ppm) image, which triggers a heap-based buffer overflow.", "project": "gegl", "idx": 208743}
{"source": " enum_func_status\n php_mysqlnd_rowp_read_text_protocol_aux(MYSQLND_MEMORY_POOL_CHUNK * row_buffer, zval ** fields,\n \t\t\t\t\t\t\t\t\tunsigned int field_count, const MYSQLND_FIELD * fields_metadata,\n \t\t\t\t\t\t\t\t\tzend_bool as_int_or_float, zend_bool copy_data, MYSQLND_STATS * stats TSRMLS_DC)\n {\n \n \tunsigned int i;\n \tzend_bool last_field_was_string = FALSE;\n \tzval **current_field, **end_field, **start_field;\n \tzend_uchar * p = row_buffer->ptr;\n \tsize_t data_size = row_buffer->app;\n \tzend_uchar * bit_area = (zend_uchar*) row_buffer->ptr + data_size + 1;\n// bug_start\n// bug_end\n \n \tDBG_ENTER(\"php_mysqlnd_rowp_read_text_protocol_aux\");\n \n \tif (!fields) {\n \t\tDBG_RETURN(FAIL);\n \t}\n \n \tend_field = (start_field = fields) + field_count;\n \n \tfor (i = 0, current_field = start_field; current_field < end_field; current_field++, i++) {\n \t\tDBG_INF(\"Directly creating zval\");\n \t\tMAKE_STD_ZVAL(*current_field);\n \t\tif (!*current_field) {\n \t\t\tDBG_RETURN(FAIL);\n \t\t}\n \t}\n \n \tfor (i = 0, current_field = start_field; current_field < end_field; current_field++, i++) {\n \t\tzend_uchar *this_field_len_pos = p;\n// bug_start\n\t\tunsigned long len = php_mysqlnd_net_field_length(&p);\n// bug_end\n \n// bug_start\n// bug_end\n \t\tif (copy_data == FALSE && current_field > start_field && last_field_was_string) {\n \n \t\t\t*this_field_len_pos = '\\0';\n \t\t}\n \n \t\tif (len == MYSQLND_NULL_LENGTH) {\n \t\t\tZVAL_NULL(*current_field);\n \t\t\tlast_field_was_string = FALSE;\n \t\t} else {\n #if defined(MYSQLND_STRING_TO_INT_CONVERSION)\n \t\t\tstruct st_mysqlnd_perm_bind perm_bind =\n \t\t\t\t\tmysqlnd_ps_fetch_functions[fields_metadata[i].type];\n #endif\n \t\t\tif (MYSQLND_G(collect_statistics)) {\n \t\t\t\tenum_mysqlnd_collected_stats statistic;\n \t\t\t\tswitch (fields_metadata[i].type) {\n \t\t\t\t\tcase MYSQL_TYPE_DECIMAL:\tstatistic = STAT_TEXT_TYPE_FETCHED_DECIMAL; break;\n \t\t\t\t\tcase MYSQL_TYPE_TINY:\t\tstatistic = STAT_TEXT_TYPE_FETCHED_INT8; break;\n \t\t\t\t\tcase MYSQL_TYPE_SHORT:\t\tstatistic = STAT_TEXT_TYPE_FETCHED_INT16; break;\n \t\t\t\t\tcase MYSQL_TYPE_LONG:\t\tstatistic = STAT_TEXT_TYPE_FETCHED_INT32; break;\n \t\t\t\t\tcase MYSQL_TYPE_FLOAT:\t\tstatistic = STAT_TEXT_TYPE_FETCHED_FLOAT; break;\n \t\t\t\t\tcase MYSQL_TYPE_DOUBLE:\t\tstatistic = STAT_TEXT_TYPE_FETCHED_DOUBLE; break;\n \t\t\t\t\tcase MYSQL_TYPE_NULL:\t\tstatistic = STAT_TEXT_TYPE_FETCHED_NULL; break;\n \t\t\t\t\tcase MYSQL_TYPE_TIMESTAMP:\tstatistic = STAT_TEXT_TYPE_FETCHED_TIMESTAMP; break;\n \t\t\t\t\tcase MYSQL_TYPE_LONGLONG:\tstatistic = STAT_TEXT_TYPE_FETCHED_INT64; break;\n \t\t\t\t\tcase MYSQL_TYPE_INT24:\t\tstatistic = STAT_TEXT_TYPE_FETCHED_INT24; break;\n \t\t\t\t\tcase MYSQL_TYPE_DATE:\t\tstatistic = STAT_TEXT_TYPE_FETCHED_DATE; break;\n \t\t\t\t\tcase MYSQL_TYPE_TIME:\t\tstatistic = STAT_TEXT_TYPE_FETCHED_TIME; break;\n \t\t\t\t\tcase MYSQL_TYPE_DATETIME:\tstatistic = STAT_TEXT_TYPE_FETCHED_DATETIME; break;\n \t\t\t\t\tcase MYSQL_TYPE_YEAR:\t\tstatistic = STAT_TEXT_TYPE_FETCHED_YEAR; break;\n \t\t\t\t\tcase MYSQL_TYPE_NEWDATE:\tstatistic = STAT_TEXT_TYPE_FETCHED_DATE; break;\n \t\t\t\t\tcase MYSQL_TYPE_VARCHAR:\tstatistic = STAT_TEXT_TYPE_FETCHED_STRING; break;\n \t\t\t\t\tcase MYSQL_TYPE_BIT:\t\tstatistic = STAT_TEXT_TYPE_FETCHED_BIT; break;\n \t\t\t\t\tcase MYSQL_TYPE_NEWDECIMAL:\tstatistic = STAT_TEXT_TYPE_FETCHED_DECIMAL; break;\n \t\t\t\t\tcase MYSQL_TYPE_ENUM:\t\tstatistic = STAT_TEXT_TYPE_FETCHED_ENUM; break;\n \t\t\t\t\tcase MYSQL_TYPE_SET:\t\tstatistic = STAT_TEXT_TYPE_FETCHED_SET; break;\n \t\t\t\t\tcase MYSQL_TYPE_JSON:\t\tstatistic = STAT_TEXT_TYPE_FETCHED_JSON; break;\n \t\t\t\t\tcase MYSQL_TYPE_TINY_BLOB:\tstatistic = STAT_TEXT_TYPE_FETCHED_BLOB; break;\n \t\t\t\t\tcase MYSQL_TYPE_MEDIUM_BLOB:statistic = STAT_TEXT_TYPE_FETCHED_BLOB; break;\n \t\t\t\t\tcase MYSQL_TYPE_LONG_BLOB:\tstatistic = STAT_TEXT_TYPE_FETCHED_BLOB; break;\n \t\t\t\t\tcase MYSQL_TYPE_BLOB:\t\tstatistic = STAT_TEXT_TYPE_FETCHED_BLOB; break;\n \t\t\t\t\tcase MYSQL_TYPE_VAR_STRING:\tstatistic = STAT_TEXT_TYPE_FETCHED_STRING; break;\n \t\t\t\t\tcase MYSQL_TYPE_STRING:\t\tstatistic = STAT_TEXT_TYPE_FETCHED_STRING; break;\n \t\t\t\t\tcase MYSQL_TYPE_GEOMETRY:\tstatistic = STAT_TEXT_TYPE_FETCHED_GEOMETRY; break;\n \t\t\t\t\tdefault: statistic = STAT_TEXT_TYPE_FETCHED_OTHER; break;\n \t\t\t\t}\n \t\t\t\tMYSQLND_INC_CONN_STATISTIC_W_VALUE2(stats, statistic, 1, STAT_BYTES_RECEIVED_PURE_DATA_TEXT, len);\n \t\t\t}\n #ifdef MYSQLND_STRING_TO_INT_CONVERSION\n \t\t\tif (as_int_or_float && perm_bind.php_type == IS_LONG) {\n \t\t\t\tzend_uchar save = *(p + len);\n \t\t\t\t*(p + len) = '\\0';\n \t\t\t\tif (perm_bind.pack_len < SIZEOF_LONG) {\n \t\t\t\t\tint64_t v =\n #ifndef PHP_WIN32\n \t\t\t\t\t\tatoll((char *) p);\n #else\n \t\t\t\t\t\t_atoi64((char *) p);\n #endif\n \t\t\t\t\tZVAL_LONG(*current_field, (long) v);\n \t\t\t\t} else {\n \t\t\t\t\tuint64_t v =\n #ifndef PHP_WIN32\n \t\t\t\t\t\t(uint64_t) atoll((char *) p);\n #else\n \t\t\t\t\t\t(uint64_t) _atoi64((char *) p);\n #endif\n \t\t\t\t\tzend_bool uns = fields_metadata[i].flags & UNSIGNED_FLAG? TRUE:FALSE;\n #if SIZEOF_LONG==8\n \t\t\t\t\tif (uns == TRUE && v > 9223372036854775807L)\n #elif SIZEOF_LONG==4\n \t\t\t\t\tif ((uns == TRUE && v > L64(2147483647)) ||\n \t\t\t\t\t\t(uns == FALSE && (( L64(2147483647) < (int64_t) v) ||\n \t\t\t\t\t\t(L64(-2147483648) > (int64_t) v))))\n #else\n #error Need fix for this architecture\n #endif\n \t\t\t\t\t{\n \t\t\t\t\t\tZVAL_STRINGL(*current_field, (char *)p, len, 0);\n \t\t\t\t\t} else {\n \t\t\t\t\t\tZVAL_LONG(*current_field, (long) v);\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\t*(p + len) = save;\n \t\t\t} else if (as_int_or_float && perm_bind.php_type == IS_DOUBLE) {\n \t\t\t\tzend_uchar save = *(p + len);\n \t\t\t\t*(p + len) = '\\0';\n \t\t\t\tZVAL_DOUBLE(*current_field, atof((char *) p));\n \t\t\t\t*(p + len) = save;\n \t\t\t} else\n #endif\n \t\t\tif (fields_metadata[i].type == MYSQL_TYPE_BIT) {\n \t\t\t\tzend_uchar *start = bit_area;\n \t\t\t\tps_fetch_from_1_to_8_bytes(*current_field, &(fields_metadata[i]), 0, &p, len TSRMLS_CC);\n \t\t\t\tp -= len;\n \t\t\t\tif (Z_TYPE_PP(current_field) == IS_LONG) {\n \t\t\t\t\tbit_area += 1 + sprintf((char *)start, \"%ld\", Z_LVAL_PP(current_field));\n \t\t\t\t\tZVAL_STRINGL(*current_field, (char *) start, bit_area - start - 1, copy_data);\n \t\t\t\t} else if (Z_TYPE_PP(current_field) == IS_STRING){\n \t\t\t\t\tmemcpy(bit_area, Z_STRVAL_PP(current_field), Z_STRLEN_PP(current_field));\n \t\t\t\t\tbit_area += Z_STRLEN_PP(current_field);\n \t\t\t\t\t*bit_area++ = '\\0';\n \t\t\t\t\tzval_dtor(*current_field);\n \t\t\t\t\tZVAL_STRINGL(*current_field, (char *) start, bit_area - start - 1, copy_data);\n \t\t\t\t}\n \t\t\t} else {\n \t\t\t\tZVAL_STRINGL(*current_field, (char *)p, len, copy_data);\n \t\t\t}\n \t\t\tp += len;\n \t\t\tlast_field_was_string = TRUE;\n \t\t}\n \t}\n \tif (copy_data == FALSE && last_field_was_string) {\n \t\trow_buffer->ptr[data_size] = '\\0';\n \t}\n \n \tDBG_RETURN(PASS);\n \n", "target": "// fix_start\n\tconst zend_uchar * const packet_end = (zend_uchar*) row_buffer->ptr + data_size;\n// fix_end\n// fix_start\n\t\tconst unsigned long len = php_mysqlnd_net_field_length(&p);\n// fix_end\n// fix_start\n\t\tif (len != MYSQLND_NULL_LENGTH && ((p + len) > packet_end)) {\n\t\t\tphp_error_docref(NULL, E_WARNING, \"Malformed server packet. Field length pointing \"MYSQLND_SZ_T_SPEC\n\t\t\t\t\t\t\t\t\t\t\t  \" bytes after end of packet\", (p + len) - packet_end - 1);\n\t\t\tDBG_RETURN(FAIL);\n\t\t}\n// fix_end\n", "cwe": "CWE-119", "cwe_name": "Improper Restriction of Operations within the Bounds of a Memory Buffer", "cve": "CVE-2016-7412", "cve_desc": "ext/mysqlnd/mysqlnd_wireprotocol.c in PHP before 5.6.26 and 7.x before 7.0.11 does not verify that a BIT field has the UNSIGNED_FLAG flag, which allows remote MySQL servers to cause a denial of service (heap-based buffer overflow) or possibly have unspecified other impact via crafted field metadata.", "project": "php-src", "idx": 208933}
{"source": "// bug_start\nstatic void cil_reset_classperms_set(struct cil_classperms_set *cp_set)\n// bug_end\n {\n// bug_start\n\tcil_reset_classpermission(cp_set->set);\n// bug_end\n }\n \n", "target": "// fix_start\nstatic void cil_reset_classpermissionset(struct cil_classpermissionset *cps)\n// fix_end\n// fix_start\n\tcil_reset_classperms_list(cps->classperms);\n// fix_end\n", "cwe": "CWE-416", "cwe_name": "Use After Free", "cve": "CVE-2021-36086", "cve_desc": "The CIL compiler in SELinux 3.2 has a use-after-free in cil_reset_classpermission (called from cil_reset_classperms_set and cil_reset_classperms_list).", "project": "selinux", "idx": 208940}
{"source": " void APar_ExtractDetails(FILE *isofile, uint8_t optional_output) {\n// bug_start\n  char uint32_buffer[5];\n// bug_end\n   Trackage track = {0};\n \n   AtomicInfo *mvhdAtom = APar_FindAtom(\"moov.mvhd\", false, VERSIONED_ATOM, 0);\n   if (mvhdAtom != NULL) {\n     APar_ExtractMovieDetails(uint32_buffer, isofile, mvhdAtom);\n     fprintf(stdout,\n             \"Movie duration: %.3lf seconds (%s) - %.2lf* kbp/sec bitrate \"\n             \"(*=approximate)\\n\",\n             movie_info.seconds,\n             secsTOtime(movie_info.seconds),\n             movie_info.simple_bitrate_calc);\n     if (optional_output & SHOW_DATE_INFO) {\n       fprintf(stdout,\n               \"  Presentation Creation Date (UTC):     %s\\n\",\n               APar_extract_UTC(movie_info.creation_time));\n       fprintf(stdout,\n               \"  Presentation Modification Date (UTC): %s\\n\",\n               APar_extract_UTC(movie_info.modified_time));\n     }\n   }\n \n   AtomicInfo *iodsAtom = APar_FindAtom(\"moov.iods\", false, VERSIONED_ATOM, 0);\n   if (iodsAtom != NULL) {\n     movie_info.contains_iods = true;\n     APar_Extract_iods_Info(isofile, iodsAtom);\n   }\n \n   if (optional_output & SHOW_TRACK_INFO) {\n     APar_TrackLevelInfo(&track,\n                         NULL);\n \n     fprintf(\n         stdout, \"Low-level details. Total tracks: %u\\n\", track.total_tracks);\n     fprintf(stdout,\n             \"Trk  Type  Handler                    Kind  Lang  Bytes\\n\");\n \n     if (track.total_tracks > 0) {\n       while (track.total_tracks > track.track_num) {\n         track.track_num += 1;\n         TrackInfo track_info = {0};\n \n         APar_ExtractTrackDetails(uint32_buffer, isofile, &track, &track_info);\n         uint16_t more_whitespace =\n             purge_extraneous_characters(track_info.track_hdlr_name);\n \n         if (strlen(track_info.track_hdlr_name) == 0) {\n           memcpy(track_info.track_hdlr_name, \"[none listed]\", 13);\n         }\n         fprintf(stdout,\n                 \"%u    %s  %s\",\n                 track.track_num,\n                 uint32tochar4(track_info.track_type, uint32_buffer),\n                 track_info.track_hdlr_name);\n \n         uint16_t handler_len = strlen(track_info.track_hdlr_name);\n         if (handler_len < 25 + more_whitespace) {\n           for (uint16_t i = handler_len; i < 25 + more_whitespace; i++) {\n             fprintf(stdout, \" \");\n           }\n         }\n \n         fprintf(stdout,\n                 \"  %s  %s   %\" PRIu64,\n                 uint32tochar4(track_info.track_codec, uint32_buffer),\n                 track_info.unpacked_lang,\n                 track_info.sample_aggregate);\n \n         if (track_info.encoder_name[0] != 0 && track_info.contains_esds) {\n           purge_extraneous_characters(track_info.encoder_name);\n           fprintf(stdout, \"   Encoder: %s\", track_info.encoder_name);\n         }\n         if (track_info.type_of_track & DRM_PROTECTED_TRACK) {\n           fprintf(stdout,\n                   \" (protected %s)\",\n                   uint32tochar4(track_info.protected_codec, uint32_buffer));\n         }\n \n         fprintf(stdout, \"\\n\");\n \n         if (track_info.type_of_track & VIDEO_TRACK ||\n             track_info.type_of_track & AUDIO_TRACK) {\n           APar_Print_TrackDetails(&track_info);\n         }\n \n         if (optional_output & SHOW_DATE_INFO) {\n           fprintf(stdout,\n                   \"       Creation Date (UTC):     %s\\n\",\n                   APar_extract_UTC(track_info.creation_time));\n           fprintf(stdout,\n                   \"       Modification Date (UTC): %s\\n\",\n                   APar_extract_UTC(track_info.modified_time));\n         }\n       }\n     }\n   }\n }\n \n", "target": "// fix_start\n  char uint32_buffer[8];\n// fix_end\n", "cwe": "CWE-787", "cwe_name": "Out-of-bounds Write", "cve": "CVE-2021-37232", "cve_desc": "A stack overflow vulnerability occurs in Atomicparsley 20210124.204813.840499f through APar_read64() in src/util.cpp due to the lack of buffer size of uint32_buffer while reading more bytes in APar_read64.", "project": "atomicparsley", "idx": 208981}
{"source": " _gnutls_ciphertext2compressed (gnutls_session_t session,\n \t\t\t       opaque * compress_data,\n \t\t\t       int compress_size,\n \t\t\t       gnutls_datum_t ciphertext, uint8_t type)\n {\n   uint8_t MAC[MAX_HASH_SIZE];\n   uint16_t c_length;\n   uint8_t pad;\n   int length;\n   digest_hd_st td;\n   uint16_t blocksize;\n   int ret, i, pad_failed = 0;\n   uint8_t major, minor;\n   gnutls_protocol_t ver;\n   int hash_size =\n     _gnutls_hash_get_algo_len (session->security_parameters.\n \t\t\t       read_mac_algorithm);\n \n   ver = gnutls_protocol_get_version (session);\n   minor = _gnutls_version_get_minor (ver);\n   major = _gnutls_version_get_major (ver);\n \n   blocksize = _gnutls_cipher_get_block_size (session->security_parameters.\n \t\t\t\t\t     read_bulk_cipher_algorithm);\n \n   ret = mac_init (&td, session->security_parameters.read_mac_algorithm,\n \t\t session->connection_state.read_mac_secret.data,\n \t\t session->connection_state.read_mac_secret.size, ver);\n \n   if (ret < 0\n       && session->security_parameters.read_mac_algorithm != GNUTLS_MAC_NULL)\n     {\n       gnutls_assert ();\n       return GNUTLS_E_INTERNAL_ERROR;\n// bug_start\n    }\n\n  if (ciphertext.size < (unsigned) blocksize + hash_size)\n    {\n      _gnutls_record_log\n\t(\"REC[%x]: Short record length %d < %d + %d (under attack?)\\n\",\n\t session, ciphertext.size, blocksize, hash_size);\n      gnutls_assert ();\n      return GNUTLS_E_DECRYPTION_FAILED;\n// bug_end\n     }\n \n   switch (_gnutls_cipher_is_block\n \t  (session->security_parameters.read_bulk_cipher_algorithm))\n     {\n     case CIPHER_STREAM:\n       if ((ret = _gnutls_cipher_decrypt (&session->connection_state.\n \t\t\t\t\t read_cipher_state,\n \t\t\t\t\t ciphertext.data,\n \t\t\t\t\t ciphertext.size)) < 0)\n \t{\n \t  gnutls_assert ();\n \t  return ret;\n \t}\n \n       length = ciphertext.size - hash_size;\n \n       break;\n     case CIPHER_BLOCK:\n       if ((ciphertext.size < blocksize) || (ciphertext.size % blocksize != 0))\n \t{\n \t  gnutls_assert ();\n \t  return GNUTLS_E_DECRYPTION_FAILED;\n \t}\n \n       if ((ret = _gnutls_cipher_decrypt (&session->connection_state.\n \t\t\t\t\t read_cipher_state,\n \t\t\t\t\t ciphertext.data,\n \t\t\t\t\t ciphertext.size)) < 0)\n \t{\n \t  gnutls_assert ();\n \t  return ret;\n \t}\n \n       if (session->security_parameters.version >= GNUTLS_TLS1_1)\n \t{\n \t  ciphertext.size -= blocksize;\n \t  ciphertext.data += blocksize;\n \n \t  if (ciphertext.size == 0)\n \t    {\n \t      gnutls_assert ();\n \t      return GNUTLS_E_DECRYPTION_FAILED;\n \t    }\n \t}\n \n       pad = ciphertext.data[ciphertext.size - 1] + 1;\n \n       if ((int)pad > (int)ciphertext.size - hash_size)\n \t{\n \t  gnutls_assert ();\n// bug_start\n// bug_end\n \t  pad_failed = GNUTLS_E_DECRYPTION_FAILED;\n \t}\n \n       length = ciphertext.size - hash_size - pad;\n \n       if (ver >= GNUTLS_TLS1 && pad_failed == 0)\n \tfor (i = 2; i < pad; i++)\n \t  {\n \t    if (ciphertext.data[ciphertext.size - i] !=\n \t\tciphertext.data[ciphertext.size - 1])\n \t      pad_failed = GNUTLS_E_DECRYPTION_FAILED;\n \t  }\n       break;\n     default:\n       gnutls_assert ();\n       return GNUTLS_E_INTERNAL_ERROR;\n     }\n \n   if (length < 0)\n     length = 0;\n   c_length = _gnutls_conv_uint16 ((uint16_t) length);\n \n   if (session->security_parameters.read_mac_algorithm != GNUTLS_MAC_NULL)\n     {\n       _gnutls_hmac (&td,\n \t\t    UINT64DATA (session->connection_state.\n \t\t\t\tread_sequence_number), 8);\n \n       _gnutls_hmac (&td, &type, 1);\n       if (ver >= GNUTLS_TLS1)\n \t{\n \t  _gnutls_hmac (&td, &major, 1);\n \t  _gnutls_hmac (&td, &minor, 1);\n \t}\n       _gnutls_hmac (&td, &c_length, 2);\n \n       if (length > 0)\n \t_gnutls_hmac (&td, ciphertext.data, length);\n \n       mac_deinit (&td, MAC, ver);\n     }\n \n   if (pad_failed != 0)\n     return pad_failed;\n \n   if (memcmp (MAC, &ciphertext.data[length], hash_size) != 0)\n     {\n       gnutls_assert ();\n       return GNUTLS_E_DECRYPTION_FAILED;\n     }\n \n   if (compress_size < length)\n     {\n       gnutls_assert ();\n       return GNUTLS_E_DECOMPRESSION_FAILED;\n     }\n   memcpy (compress_data, ciphertext.data, length);\n \n   return length;\n }\n \n", "target": "// fix_start\n// fix_end\n// fix_start\n\t  _gnutls_record_log\n\t    (\"REC[%x]: Short record length %d > %d - %d (under attack?)\\n\",\n\t     session, pad, ciphertext.size, hash_size);\n// fix_end\n", "cwe": "CWE-189", "cwe_name": "Numeric Errors", "cve": "CVE-2008-1948", "cve_desc": "The _gnutls_server_name_recv_params function in lib/ext_server_name.c in libgnutls in gnutls-serv in GnuTLS before 2.2.4 does not properly calculate the number of Server Names in a TLS 1.0 Client Hello message during extension handling, which allows remote attackers to cause a denial of service (crash) or possibly execute arbitrary code via a zero value for the length of Server Names, which leads to a buffer overflow in session resumption data in the pack_security_parameters function, aka GNUTLS-SA-2008-1-1.", "project": "gnutls", "idx": 209003}
{"source": " bool SFD_GetFontMetaData( FILE *sfd,\n \t\t\t  char *tok,\n \t\t\t  SplineFont *sf,\n \t\t\t  SFD_GetFontMetaDataData* d )\n {\n     int ch;\n     int i;\n     KernClass* kc = 0;\n     int old;\n     char val[2000];\n \n     static SFD_GetFontMetaDataData my_static_d;\n     static int my_static_d_is_virgin = 1;\n     if( !d )\n     {\n \tif( my_static_d_is_virgin )\n \t{\n \t    my_static_d_is_virgin = 0;\n \t    SFD_GetFontMetaDataData_Init( &my_static_d );\n \t}\n \td = &my_static_d;\n     }\n \n     if ( strmatch(tok,\"FontName:\")==0 )\n     {\n \tgeteol(sfd,val);\n \tsf->fontname = copy(val);\n     }\n     else if ( strmatch(tok,\"FullName:\")==0 )\n     {\n \tgeteol(sfd,val);\n \tsf->fullname = copy(val);\n     }\n     else if ( strmatch(tok,\"FamilyName:\")==0 )\n     {\n \tgeteol(sfd,val);\n \tsf->familyname = copy(val);\n     }\n     else if ( strmatch(tok,\"DefaultBaseFilename:\")==0 )\n     {\n \tgeteol(sfd,val);\n \tsf->defbasefilename = copy(val);\n     }\n     else if ( strmatch(tok,\"Weight:\")==0 )\n     {\n \tgetprotectedname(sfd,val);\n \tsf->weight = copy(val);\n     }\n     else if ( strmatch(tok,\"Copyright:\")==0 )\n     {\n \tsf->copyright = getquotedeol(sfd);\n     }\n     else if ( strmatch(tok,\"Comments:\")==0 )\n     {\n \tchar *temp = getquotedeol(sfd);\n \tsf->comments = latin1_2_utf8_copy(temp);\n \tfree(temp);\n     }\n     else if ( strmatch(tok,\"UComments:\")==0 )\n     {\n \tsf->comments = SFDReadUTF7Str(sfd);\n     }\n     else if ( strmatch(tok,\"FontLog:\")==0 )\n     {\n \tsf->fontlog = SFDReadUTF7Str(sfd);\n     }\n     else if ( strmatch(tok,\"Version:\")==0 )\n     {\n \tgeteol(sfd,val);\n \tsf->version = copy(val);\n     }\n     else if ( strmatch(tok,\"StyleMapFamilyName:\")==0 )\n     {\n     sf->styleMapFamilyName = SFDReadUTF7Str(sfd);\n     }\n     else if ( strmatch(tok,\"OS2FamilyName:\")==0 )\n     {\n     if (sf->styleMapFamilyName == NULL)\n         sf->styleMapFamilyName = SFDReadUTF7Str(sfd);\n     }\n     else if ( strmatch(tok,\"FONDName:\")==0 )\n     {\n \tgeteol(sfd,val);\n \tsf->fondname = copy(val);\n     }\n     else if ( strmatch(tok,\"ItalicAngle:\")==0 )\n     {\n \tgetreal(sfd,&sf->italicangle);\n     }\n     else if ( strmatch(tok,\"StrokeWidth:\")==0 )\n     {\n \tgetreal(sfd,&sf->strokewidth);\n     }\n     else if ( strmatch(tok,\"UnderlinePosition:\")==0 )\n     {\n \tgetreal(sfd,&sf->upos);\n     }\n     else if ( strmatch(tok,\"UnderlineWidth:\")==0 )\n     {\n \tgetreal(sfd,&sf->uwidth);\n     }\n     else if ( strmatch(tok,\"ModificationTime:\")==0 )\n     {\n \tgetlonglong(sfd,&sf->modificationtime);\n     }\n     else if ( strmatch(tok,\"CreationTime:\")==0 )\n     {\n \tgetlonglong(sfd,&sf->creationtime);\n \td->hadtimes = true;\n     }\n     else if ( strmatch(tok,\"PfmFamily:\")==0 )\n     {\n \tint temp;\n \tgetint(sfd,&temp);\n \tsf->pfminfo.pfmfamily = temp;\n \tsf->pfminfo.pfmset = true;\n     }\n     else if ( strmatch(tok,\"LangName:\")==0 )\n     {\n \tsf->names = SFDGetLangName(sfd,sf->names);\n     }\n     else if ( strmatch(tok,\"GaspTable:\")==0 )\n     {\n \tSFDGetGasp(sfd,sf);\n     }\n     else if ( strmatch(tok,\"DesignSize:\")==0 )\n     {\n \tSFDGetDesignSize(sfd,sf);\n     }\n     else if ( strmatch(tok,\"OtfFeatName:\")==0 )\n     {\n \tSFDGetOtfFeatName(sfd,sf);\n     }\n     else if ( strmatch(tok,\"PfmWeight:\")==0 || strmatch(tok,\"TTFWeight:\")==0 )\n     {\n \tgetsint(sfd,&sf->pfminfo.weight);\n \tsf->pfminfo.pfmset = true;\n     }\n     else if ( strmatch(tok,\"TTFWidth:\")==0 )\n     {\n \tgetsint(sfd,&sf->pfminfo.width);\n \tsf->pfminfo.pfmset = true;\n     }\n     else if ( strmatch(tok,\"Panose:\")==0 )\n     {\n \tint temp,i;\n \tfor ( i=0; i<10; ++i )\n \t{\n \t    getint(sfd,&temp);\n \t    sf->pfminfo.panose[i] = temp;\n \t}\n \tsf->pfminfo.panose_set = true;\n     }\n     else if ( strmatch(tok,\"LineGap:\")==0 )\n     {\n \tgetsint(sfd,&sf->pfminfo.linegap);\n \tsf->pfminfo.pfmset = true;\n     }\n     else if ( strmatch(tok,\"VLineGap:\")==0 )\n     {\n \tgetsint(sfd,&sf->pfminfo.vlinegap);\n \tsf->pfminfo.pfmset = true;\n     }\n     else if ( strmatch(tok,\"HheadAscent:\")==0 )\n     {\n \tgetsint(sfd,&sf->pfminfo.hhead_ascent);\n     }\n     else if ( strmatch(tok,\"HheadAOffset:\")==0 )\n     {\n \tint temp;\n \tgetint(sfd,&temp); sf->pfminfo.hheadascent_add = temp;\n     }\n     else if ( strmatch(tok,\"HheadDescent:\")==0 )\n     {\n \tgetsint(sfd,&sf->pfminfo.hhead_descent);\n     }\n     else if ( strmatch(tok,\"HheadDOffset:\")==0 )\n     {\n \tint temp;\n \tgetint(sfd,&temp); sf->pfminfo.hheaddescent_add = temp;\n     }\n     else if ( strmatch(tok,\"OS2TypoLinegap:\")==0 )\n     {\n \tgetsint(sfd,&sf->pfminfo.os2_typolinegap);\n     }\n     else if ( strmatch(tok,\"OS2TypoAscent:\")==0 )\n     {\n \tgetsint(sfd,&sf->pfminfo.os2_typoascent);\n     }\n     else if ( strmatch(tok,\"OS2TypoAOffset:\")==0 )\n     {\n \tint temp;\n \tgetint(sfd,&temp); sf->pfminfo.typoascent_add = temp;\n     }\n     else if ( strmatch(tok,\"OS2TypoDescent:\")==0 )\n     {\n \tgetsint(sfd,&sf->pfminfo.os2_typodescent);\n     }\n     else if ( strmatch(tok,\"OS2TypoDOffset:\")==0 )\n     {\n \tint temp;\n \tgetint(sfd,&temp); sf->pfminfo.typodescent_add = temp;\n     }\n     else if ( strmatch(tok,\"OS2WinAscent:\")==0 )\n     {\n \tgetsint(sfd,&sf->pfminfo.os2_winascent);\n     }\n     else if ( strmatch(tok,\"OS2WinDescent:\")==0 )\n     {\n \tgetsint(sfd,&sf->pfminfo.os2_windescent);\n     }\n     else if ( strmatch(tok,\"OS2WinAOffset:\")==0 )\n     {\n \tint temp;\n \tgetint(sfd,&temp); sf->pfminfo.winascent_add = temp;\n     }\n     else if ( strmatch(tok,\"OS2WinDOffset:\")==0 )\n     {\n \tint temp;\n \tgetint(sfd,&temp); sf->pfminfo.windescent_add = temp;\n     }\n     else if ( strmatch(tok,\"HHeadAscent:\")==0 )\n     {\n \tgetsint(sfd,&sf->pfminfo.hhead_ascent);\n     }\n     else if ( strmatch(tok,\"HHeadDescent:\")==0 )\n     {\n \tgetsint(sfd,&sf->pfminfo.hhead_descent);\n     }\n \n     else if ( strmatch(tok,\"HHeadAOffset:\")==0 )\n     {\n \tint temp;\n \tgetint(sfd,&temp); sf->pfminfo.hheadascent_add = temp;\n     }\n     else if ( strmatch(tok,\"HHeadDOffset:\")==0 )\n     {\n \tint temp;\n \tgetint(sfd,&temp); sf->pfminfo.hheaddescent_add = temp;\n     }\n     else if ( strmatch(tok,\"MacStyle:\")==0 )\n     {\n \tgetsint(sfd,&sf->macstyle);\n     }\n     else if ( strmatch(tok,\"OS2SubXSize:\")==0 )\n     {\n \tgetsint(sfd,&sf->pfminfo.os2_subxsize);\n \tsf->pfminfo.subsuper_set = true;\n     }\n     else if ( strmatch(tok,\"OS2SubYSize:\")==0 )\n     {\n \tgetsint(sfd,&sf->pfminfo.os2_subysize);\n     }\n     else if ( strmatch(tok,\"OS2SubXOff:\")==0 )\n     {\n \tgetsint(sfd,&sf->pfminfo.os2_subxoff);\n     }\n     else if ( strmatch(tok,\"OS2SubYOff:\")==0 )\n     {\n \tgetsint(sfd,&sf->pfminfo.os2_subyoff);\n     }\n     else if ( strmatch(tok,\"OS2SupXSize:\")==0 )\n     {\n \tgetsint(sfd,&sf->pfminfo.os2_supxsize);\n     }\n     else if ( strmatch(tok,\"OS2SupYSize:\")==0 )\n     {\n \tgetsint(sfd,&sf->pfminfo.os2_supysize);\n     }\n     else if ( strmatch(tok,\"OS2SupXOff:\")==0 )\n     {\n \tgetsint(sfd,&sf->pfminfo.os2_supxoff);\n     }\n     else if ( strmatch(tok,\"OS2SupYOff:\")==0 )\n     {\n \tgetsint(sfd,&sf->pfminfo.os2_supyoff);\n     }\n     else if ( strmatch(tok,\"OS2StrikeYSize:\")==0 )\n     {\n \tgetsint(sfd,&sf->pfminfo.os2_strikeysize);\n     }\n     else if ( strmatch(tok,\"OS2StrikeYPos:\")==0 )\n     {\n \tgetsint(sfd,&sf->pfminfo.os2_strikeypos);\n     }\n     else if ( strmatch(tok,\"OS2CapHeight:\")==0 )\n     {\n \tgetsint(sfd,&sf->pfminfo.os2_capheight);\n     }\n     else if ( strmatch(tok,\"OS2XHeight:\")==0 )\n     {\n \tgetsint(sfd,&sf->pfminfo.os2_xheight);\n     }\n     else if ( strmatch(tok,\"OS2FamilyClass:\")==0 )\n     {\n \tgetsint(sfd,&sf->pfminfo.os2_family_class);\n     }\n     else if ( strmatch(tok,\"OS2Vendor:\")==0 )\n     {\n \twhile ( isspace(nlgetc(sfd)));\n \tsf->pfminfo.os2_vendor[0] = nlgetc(sfd);\n \tsf->pfminfo.os2_vendor[1] = nlgetc(sfd);\n \tsf->pfminfo.os2_vendor[2] = nlgetc(sfd);\n \tsf->pfminfo.os2_vendor[3] = nlgetc(sfd);\n \t(void) nlgetc(sfd);\n     }\n     else if ( strmatch(tok,\"OS2CodePages:\")==0 )\n     {\n \tgethexints(sfd,sf->pfminfo.codepages,2);\n \tsf->pfminfo.hascodepages = true;\n     }\n     else if ( strmatch(tok,\"OS2UnicodeRanges:\")==0 )\n     {\n \tgethexints(sfd,sf->pfminfo.unicoderanges,4);\n \tsf->pfminfo.hasunicoderanges = true;\n     }\n     else if ( strmatch(tok,\"TopEncoding:\")==0 )\n     {\n \tgetint(sfd,&sf->top_enc);\n     }\n     else if ( strmatch(tok,\"Ascent:\")==0 )\n     {\n \tgetint(sfd,&sf->ascent);\n     }\n     else if ( strmatch(tok,\"Descent:\")==0 )\n     {\n \tgetint(sfd,&sf->descent);\n     }\n     else if ( strmatch(tok,\"InvalidEm:\")==0 )\n     {\n \tgetint(sfd,&sf->invalidem);\n     }\n     else if ( strmatch(tok,\"woffMajor:\")==0 )\n     {\n \tgetint(sfd,&sf->woffMajor);\n     }\n     else if ( strmatch(tok,\"woffMinor:\")==0 )\n     {\n \tgetint(sfd,&sf->woffMinor);\n     }\n     else if ( strmatch(tok,\"woffMetadata:\")==0 )\n     {\n \tsf->woffMetadata = SFDReadUTF7Str(sfd);\n     }\n     else if ( strmatch(tok,\"UFOAscent:\")==0 )\n     {\n \t    getreal(sfd,&sf->ufo_ascent);\n     }\n     else if ( strmatch(tok,\"UFODescent:\")==0 )\n     {\n \tgetreal(sfd,&sf->ufo_descent);\n     }\n     else if ( strmatch(tok,\"sfntRevision:\")==0 )\n     {\n \tgethex(sfd,(uint32 *)&sf->sfntRevision);\n     }\n     else if ( strmatch(tok,\"LayerCount:\")==0 )\n     {\n \td->had_layer_cnt = true;\n// bug_start\n\tgetint(sfd,&sf->layer_cnt);\n\tif ( sf->layer_cnt>2 ) {\n// bug_end\n \t    sf->layers = realloc(sf->layers,sf->layer_cnt*sizeof(LayerInfo));\n \t    memset(sf->layers+2,0,(sf->layer_cnt-2)*sizeof(LayerInfo));\n// bug_start\n// bug_end\n \t}\n     }\n     else if ( strmatch(tok,\"Layer:\")==0 )\n     {\n \tint layer, o2, bk;\n \tgetint(sfd,&layer);\n \tif ( layer>=sf->layer_cnt ) {\n \t    sf->layers = realloc(sf->layers,(layer+1)*sizeof(LayerInfo));\n \t    memset(sf->layers+sf->layer_cnt,0,((layer+1)-sf->layer_cnt)*sizeof(LayerInfo));\n \t    sf->layer_cnt = layer+1;\n \t}\n \tgetint(sfd,&o2);\n \tsf->layers[layer].order2 = o2;\n \tsf->layers[layer].background = layer==ly_back;\n \twhile ( (ch=nlgetc(sfd))==' ' );\n \tungetc(ch,sfd);\n \tif ( ch!='\"' ) {\n \t    getint(sfd,&bk);\n \t    sf->layers[layer].background = bk;\n \t}\n \tsf->layers[layer].name = SFDReadUTF7Str(sfd);\n \twhile ( (ch=nlgetc(sfd))==' ' );\n \tungetc(ch,sfd);\n \tif ( ch!='\\n' ) {\n \t    getint(sfd,&bk);\n \t    sf->layers[layer].background = bk;\n \t}\n \twhile ( (ch=nlgetc(sfd))==' ' );\n \tungetc(ch,sfd);\n \tif ( ch!='\\n' ) { sf->layers[layer].ufo_path = SFDReadUTF7Str(sfd); }\n     }\n     else if ( strmatch(tok,\"PreferredKerning:\")==0 )\n     {\n \tint temp;\n \tgetint(sfd,&temp);\n \tsf->preferred_kerning = temp;\n     }\n     else if ( strmatch(tok,\"StrokedFont:\")==0 )\n     {\n \tint temp;\n \tgetint(sfd,&temp);\n \tsf->strokedfont = temp;\n     }\n     else if ( strmatch(tok,\"MultiLayer:\")==0 )\n     {\n \tint temp;\n \tgetint(sfd,&temp);\n \tsf->multilayer = temp;\n     }\n     else if ( strmatch(tok,\"NeedsXUIDChange:\")==0 )\n     {\n \tint temp;\n \tgetint(sfd,&temp);\n \tsf->changed_since_xuidchanged = temp;\n     }\n     else if ( strmatch(tok,\"VerticalOrigin:\")==0 )\n     {\n \tint temp;\n \tgetint(sfd,&temp);\n \tsf->hasvmetrics = true;\n     }\n     else if ( strmatch(tok,\"HasVMetrics:\")==0 )\n     {\n \tint temp;\n \tgetint(sfd,&temp);\n \tsf->hasvmetrics = temp;\n     }\n     else if ( strmatch(tok,\"Justify:\")==0 )\n     {\n \tSFDParseJustify(sfd,sf,tok);\n     }\n     else if ( strmatch(tok,\"BaseHoriz:\")==0 )\n     {\n \tsf->horiz_base = SFDParseBase(sfd);\n \td->last_base = sf->horiz_base;\n \td->last_base_script = NULL;\n     }\n     else if ( strmatch(tok,\"BaseVert:\")==0 )\n     {\n \tsf->vert_base = SFDParseBase(sfd);\n \td->last_base = sf->vert_base;\n \td->last_base_script = NULL;\n     }\n     else if ( strmatch(tok,\"BaseScript:\")==0 )\n     {\n \tstruct basescript *bs = SFDParseBaseScript(sfd,d->last_base);\n \tif ( d->last_base==NULL )\n \t{\n \t    BaseScriptFree(bs);\n \t    bs = NULL;\n \t}\n \telse if ( d->last_base_script!=NULL )\n \t    d->last_base_script->next = bs;\n \telse\n \t    d->last_base->scripts = bs;\n \td->last_base_script = bs;\n     }\n     else if ( strmatch(tok,\"StyleMap:\")==0 )\n     {\n     gethex(sfd,(uint32 *)&sf->pfminfo.stylemap);\n     }\n     else if ( strmatch(tok,\"OS2StyleName:\")==0 )\n     {\n     char* sname = SFDReadUTF7Str(sfd);\n     if (sf->pfminfo.stylemap == -1) {\n         if (strcmp(sname,\"bold italic\")==0) sf->pfminfo.stylemap = 0x21;\n         else if (strcmp(sname,\"bold\")==0) sf->pfminfo.stylemap = 0x20;\n         else if (strcmp(sname,\"italic\")==0) sf->pfminfo.stylemap = 0x01;\n         else if (strcmp(sname,\"regular\")==0) sf->pfminfo.stylemap = 0x40;\n     }\n     free(sname);\n     }\n     else if ( strmatch(tok,\"FSType:\")==0 )\n     {\n \tgetsint(sfd,&sf->pfminfo.fstype);\n     }\n     else if ( strmatch(tok,\"OS2Version:\")==0 )\n     {\n \tgetsint(sfd,&sf->os2_version);\n     }\n     else if ( strmatch(tok,\"OS2_WeightWidthSlopeOnly:\")==0 )\n     {\n \tint temp;\n \tgetint(sfd,&temp);\n \tsf->weight_width_slope_only = temp;\n     }\n     else if ( strmatch(tok,\"OS2_UseTypoMetrics:\")==0 )\n     {\n \tint temp;\n \tgetint(sfd,&temp);\n \tsf->use_typo_metrics = temp;\n     }\n     else if ( strmatch(tok,\"UseUniqueID:\")==0 )\n     {\n \tint temp;\n \tgetint(sfd,&temp);\n \tsf->use_uniqueid = temp;\n     }\n     else if ( strmatch(tok,\"UseXUID:\")==0 )\n     {\n \tint temp;\n \tgetint(sfd,&temp);\n \tsf->use_xuid = temp;\n     }\n     else if ( strmatch(tok,\"UniqueID:\")==0 )\n     {\n \tgetint(sfd,&sf->uniqueid);\n     }\n     else if ( strmatch(tok,\"XUID:\")==0 )\n     {\n \tgeteol(sfd,tok);\n \tsf->xuid = copy(tok);\n     }\n     else if ( strmatch(tok,\"Lookup:\")==0 )\n     {\n \tOTLookup *otl;\n \tint temp;\n \tif ( sf->sfd_version<2 ) {\n \t    IError( \"Lookups should not happen in version 1 sfd files.\" );\n \t    exit(1);\n \t}\n \totl = chunkalloc(sizeof(OTLookup));\n \tgetint(sfd,&temp); otl->lookup_type = temp;\n \tgetint(sfd,&temp); otl->lookup_flags = temp;\n \tgetint(sfd,&temp); otl->store_in_afm = temp;\n \totl->lookup_name = SFDReadUTF7Str(sfd);\n \tif ( otl->lookup_type<gpos_single ) {\n \t    if ( d->lastsotl==NULL )\n \t\tsf->gsub_lookups = otl;\n \t    else\n \t\td->lastsotl->next = otl;\n \t    d->lastsotl = otl;\n \t} else {\n \t    if ( d->lastpotl==NULL )\n \t\tsf->gpos_lookups = otl;\n \t    else\n \t\td->lastpotl->next = otl;\n \t    d->lastpotl = otl;\n \t}\n \tSFDParseLookup(sfd,otl);\n     }\n     else if ( strmatch(tok,\"MarkAttachClasses:\")==0 )\n     {\n \tgetint(sfd,&sf->mark_class_cnt);\n \tsf->mark_classes = malloc(sf->mark_class_cnt*sizeof(char *));\n \tsf->mark_class_names = malloc(sf->mark_class_cnt*sizeof(char *));\n \tsf->mark_classes[0] = NULL; sf->mark_class_names[0] = NULL;\n \tfor ( i=1; i<sf->mark_class_cnt; ++i )\n \t{\n \t    int temp;\n \t    while ( (temp=nlgetc(sfd))=='\\n' || temp=='\\r' ); ungetc(temp,sfd);\n \t    sf->mark_class_names[i] = SFDReadUTF7Str(sfd);\n \t    getint(sfd,&temp);\n \t    sf->mark_classes[i] = malloc(temp+1); sf->mark_classes[i][temp] = '\\0';\n \t    nlgetc(sfd);\n \t    fread(sf->mark_classes[i],1,temp,sfd);\n \t}\n     }\n     else if ( strmatch(tok,\"MarkAttachSets:\")==0 )\n     {\n \tgetint(sfd,&sf->mark_set_cnt);\n \tsf->mark_sets = malloc(sf->mark_set_cnt*sizeof(char *));\n \tsf->mark_set_names = malloc(sf->mark_set_cnt*sizeof(char *));\n \tfor ( i=0; i<sf->mark_set_cnt; ++i )\n \t{\n \t    int temp;\n \t    while ( (temp=nlgetc(sfd))=='\\n' || temp=='\\r' ); ungetc(temp,sfd);\n \t    sf->mark_set_names[i] = SFDReadUTF7Str(sfd);\n \t    getint(sfd,&temp);\n \t    sf->mark_sets[i] = malloc(temp+1); sf->mark_sets[i][temp] = '\\0';\n \t    nlgetc(sfd);\n \t    fread(sf->mark_sets[i],1,temp,sfd);\n \t}\n     }\n     else if ( strmatch(tok,\"KernClass2:\")==0 || strmatch(tok,\"VKernClass2:\")==0 ||\n \t      strmatch(tok,\"KernClass:\")==0 || strmatch(tok,\"VKernClass:\")==0 ||\n \t      strmatch(tok,\"KernClass3:\")==0 || strmatch(tok,\"VKernClass3:\")==0 )\n     {\n \tint kernclassversion = 0;\n \tint isv = tok[0]=='V';\n \tint kcvoffset = (isv ? 10 : 9);\n \tif (isdigit(tok[kcvoffset])) kernclassversion = tok[kcvoffset] - '0';\n \tint temp, classstart=1;\n \tint old = (kernclassversion == 0);\n \n \tif ( (sf->sfd_version<2)!=old ) {\n \t    IError( \"Version mixup in Kerning Classes of sfd file.\" );\n \t    exit(1);\n \t}\n \tkc = chunkalloc(old ? sizeof(KernClass1) : sizeof(KernClass));\n \tgetint(sfd,&kc->first_cnt);\n \tch=nlgetc(sfd);\n \tif ( ch=='+' )\n \t    classstart = 0;\n \telse\n \t    ungetc(ch,sfd);\n \tgetint(sfd,&kc->second_cnt);\n \tif ( old ) {\n \t    getint(sfd,&temp); ((KernClass1 *) kc)->sli = temp;\n \t    getint(sfd,&temp); ((KernClass1 *) kc)->flags = temp;\n \t} else {\n \t    kc->subtable = SFFindLookupSubtableAndFreeName(sf,SFDReadUTF7Str(sfd));\n \t    if ( kc->subtable!=NULL && kc->subtable->kc==NULL )\n \t\tkc->subtable->kc = kc;\n \t    else {\n \t\tif ( kc->subtable==NULL )\n \t\t    LogError(_(\"Bad SFD file, missing subtable in kernclass defn.\\n\") );\n \t\telse\n \t\t    LogError(_(\"Bad SFD file, two kerning classes assigned to the same subtable: %s\\n\"), kc->subtable->subtable_name );\n \t\tkc->subtable = NULL;\n \t    }\n \t}\n \tkc->firsts = calloc(kc->first_cnt,sizeof(char *));\n \tkc->seconds = calloc(kc->second_cnt,sizeof(char *));\n \tkc->offsets = calloc(kc->first_cnt*kc->second_cnt,sizeof(int16));\n \tkc->adjusts = calloc(kc->first_cnt*kc->second_cnt,sizeof(DeviceTable));\n \tif (kernclassversion >= 3) {\n \t  kc->firsts_flags = calloc(kc->first_cnt, sizeof(int));\n \t  kc->seconds_flags = calloc(kc->second_cnt, sizeof(int));\n \t  kc->offsets_flags = calloc(kc->first_cnt*kc->second_cnt, sizeof(int));\n \t  kc->firsts_names = calloc(kc->first_cnt, sizeof(char*));\n \t  kc->seconds_names = calloc(kc->second_cnt, sizeof(char*));\n \t}\n \tkc->firsts[0] = NULL;\n \tfor ( i=classstart; i<kc->first_cnt; ++i ) {\n \t  if (kernclassversion < 3) {\n \t    getint(sfd,&temp);\n \t    kc->firsts[i] = malloc(temp+1); kc->firsts[i][temp] = '\\0';\n \t    nlgetc(sfd);\n \t    fread(kc->firsts[i],1,temp,sfd);\n \t  } else {\n \t    getint(sfd,&kc->firsts_flags[i]);\n \t    while ((ch=nlgetc(sfd)) == ' '); ungetc(ch, sfd); if (ch == '\\n' || ch == EOF) continue;\n \t    kc->firsts_names[i] = SFDReadUTF7Str(sfd);\n \t    while ((ch=nlgetc(sfd)) == ' '); ungetc(ch, sfd); if (ch == '\\n' || ch == EOF) continue;\n \t    kc->firsts[i] = SFDReadUTF7Str(sfd);\n             if (kc->firsts[i] == NULL) kc->firsts[i] = copy(\"\");\n \t    while ((ch=nlgetc(sfd)) == ' ' || ch == '\\n'); ungetc(ch, sfd);\n \t  }\n \t}\n \tkc->seconds[0] = NULL;\n \tfor ( i=1; i<kc->second_cnt; ++i ) {\n \t  if (kernclassversion < 3) {\n \t    getint(sfd,&temp);\n \t    kc->seconds[i] = malloc(temp+1); kc->seconds[i][temp] = '\\0';\n \t    nlgetc(sfd);\n \t    fread(kc->seconds[i],1,temp,sfd);\n \t  } else {\n \t    getint(sfd,&temp);\n \t    kc->seconds_flags[i] = temp;\n \t    while ((ch=nlgetc(sfd)) == ' '); ungetc(ch, sfd); if (ch == '\\n' || ch == EOF) continue;\n \t    kc->seconds_names[i] = SFDReadUTF7Str(sfd);\n \t    while ((ch=nlgetc(sfd)) == ' '); ungetc(ch, sfd); if (ch == '\\n' || ch == EOF) continue;\n \t    kc->seconds[i] = SFDReadUTF7Str(sfd);\n             if (kc->seconds[i] == NULL) kc->seconds[i] = copy(\"\");\n \t    while ((ch=nlgetc(sfd)) == ' ' || ch == '\\n'); ungetc(ch, sfd);\n \t  }\n \t}\n \tfor ( i=0; i<kc->first_cnt*kc->second_cnt; ++i ) {\n \t  if (kernclassversion >= 3) {\n \t    getint(sfd,&temp);\n \t    kc->offsets_flags[i] = temp;\n \t  }\n \t    getint(sfd,&temp);\n \t    kc->offsets[i] = temp;\n \t    SFDReadDeviceTable(sfd,&kc->adjusts[i]);\n \t}\n \tif ( !old && kc->subtable == NULL ) {\n \t    ;\n \t} else if ( !isv ) {\n \t    if ( d->lastkc==NULL )\n \t\tsf->kerns = kc;\n \t    else\n \t\td->lastkc->next = kc;\n \t    d->lastkc = kc;\n \t} else {\n \t    if ( d->lastvkc==NULL )\n \t\tsf->vkerns = kc;\n \t    else\n \t\td->lastvkc->next = kc;\n \t    d->lastvkc = kc;\n \t}\n     }\n     else if ( strmatch(tok,\"ContextPos2:\")==0 || strmatch(tok,\"ContextSub2:\")==0 ||\n \t      strmatch(tok,\"ChainPos2:\")==0 || strmatch(tok,\"ChainSub2:\")==0 ||\n \t      strmatch(tok,\"ReverseChain2:\")==0 ||\n \t      strmatch(tok,\"ContextPos:\")==0 || strmatch(tok,\"ContextSub:\")==0 ||\n \t      strmatch(tok,\"ChainPos:\")==0 || strmatch(tok,\"ChainSub:\")==0 ||\n \t      strmatch(tok,\"ReverseChain:\")==0 )\n     {\n \tFPST *fpst;\n \tint old;\n \tif ( strchr(tok,'2')!=NULL ) {\n \t    old = false;\n \t    fpst = chunkalloc(sizeof(FPST));\n \t} else {\n \t    old = true;\n \t    fpst = chunkalloc(sizeof(FPST1));\n \t}\n \tif ( (sf->sfd_version<2)!=old ) {\n \t    IError( \"Version mixup in FPST of sfd file.\" );\n \t    exit(1);\n \t}\n \tif ( d->lastfp==NULL )\n \t    sf->possub = fpst;\n \telse\n \t    d->lastfp->next = fpst;\n \td->lastfp = fpst;\n \tSFDParseChainContext(sfd,sf,fpst,tok,old);\n     }\n     else if ( strmatch(tok,\"Group:\")==0 ) {\n         struct ff_glyphclasses *grouptmp = calloc(1, sizeof(struct ff_glyphclasses));\n         while ((ch=nlgetc(sfd)) == ' '); ungetc(ch, sfd);\n         grouptmp->classname = SFDReadUTF7Str(sfd);\n         while ((ch=nlgetc(sfd)) == ' '); ungetc(ch, sfd);\n         grouptmp->glyphs = SFDReadUTF7Str(sfd);\n         while ((ch=nlgetc(sfd)) == ' ' || ch == '\\n'); ungetc(ch, sfd);\n         if (d->lastgroup != NULL) d->lastgroup->next = grouptmp; else sf->groups = grouptmp;\n         d->lastgroup = grouptmp;\n     }\n     else if ( strmatch(tok,\"GroupKern:\")==0 ) {\n         int temp = 0;\n         struct ff_rawoffsets *kerntmp = calloc(1, sizeof(struct ff_rawoffsets));\n         while ((ch=nlgetc(sfd)) == ' '); ungetc(ch, sfd);\n         kerntmp->left = SFDReadUTF7Str(sfd);\n         while ((ch=nlgetc(sfd)) == ' '); ungetc(ch, sfd);\n         kerntmp->right = SFDReadUTF7Str(sfd);\n         while ((ch=nlgetc(sfd)) == ' '); ungetc(ch, sfd);\n         getint(sfd,&temp);\n         kerntmp->offset = temp;\n         while ((ch=nlgetc(sfd)) == ' ' || ch == '\\n'); ungetc(ch, sfd);\n         if (d->lastgroupkern != NULL) d->lastgroupkern->next = kerntmp; else sf->groupkerns = kerntmp;\n         d->lastgroupkern = kerntmp;\n     }\n     else if ( strmatch(tok,\"GroupVKern:\")==0 ) {\n         int temp = 0;\n         struct ff_rawoffsets *kerntmp = calloc(1, sizeof(struct ff_rawoffsets));\n         while ((ch=nlgetc(sfd)) == ' '); ungetc(ch, sfd);\n         kerntmp->left = SFDReadUTF7Str(sfd);\n         while ((ch=nlgetc(sfd)) == ' '); ungetc(ch, sfd);\n         kerntmp->right = SFDReadUTF7Str(sfd);\n         while ((ch=nlgetc(sfd)) == ' '); ungetc(ch, sfd);\n         getint(sfd,&temp);\n         kerntmp->offset = temp;\n         while ((ch=nlgetc(sfd)) == ' ' || ch == '\\n'); ungetc(ch, sfd);\n         if (d->lastgroupvkern != NULL) d->lastgroupvkern->next = kerntmp; else sf->groupvkerns = kerntmp;\n         d->lastgroupvkern = kerntmp;\n     }\n     else if ( strmatch(tok,\"MacIndic2:\")==0 || strmatch(tok,\"MacContext2:\")==0 ||\n \t      strmatch(tok,\"MacLigature2:\")==0 || strmatch(tok,\"MacSimple2:\")==0 ||\n \t      strmatch(tok,\"MacKern2:\")==0 || strmatch(tok,\"MacInsert2:\")==0 ||\n \t      strmatch(tok,\"MacIndic:\")==0 || strmatch(tok,\"MacContext:\")==0 ||\n \t      strmatch(tok,\"MacLigature:\")==0 || strmatch(tok,\"MacSimple:\")==0 ||\n \t      strmatch(tok,\"MacKern:\")==0 || strmatch(tok,\"MacInsert:\")==0 )\n     {\n \tASM *sm;\n \tif ( strchr(tok,'2')!=NULL ) {\n \t    old = false;\n \t    sm = chunkalloc(sizeof(ASM));\n \t} else {\n \t    old = true;\n \t    sm = chunkalloc(sizeof(ASM1));\n \t}\n \tif ( (sf->sfd_version<2)!=old ) {\n \t    IError( \"Version mixup in state machine of sfd file.\" );\n \t    exit(1);\n \t}\n \tif ( d->lastsm==NULL )\n \t    sf->sm = sm;\n \telse\n \t    d->lastsm->next = sm;\n \td->lastsm = sm;\n \tSFDParseStateMachine(sfd,sf,sm,tok,old);\n     }\n     else if ( strmatch(tok,\"MacFeat:\")==0 )\n     {\n \tsf->features = SFDParseMacFeatures(sfd,tok);\n     }\n     else if ( strmatch(tok,\"TtfTable:\")==0 )\n     {\n \tSFDGetTtfTable(sfd,sf,d->lastttf);\n     }\n     else if ( strmatch(tok,\"TtTable:\")==0 )\n     {\n \tSFDGetTtTable(sfd,sf,d->lastttf);\n     }\n \n \n \n     else if ( strmatch(tok,\"ShortTable:\")==0 )\n     {\n \tSFDGetShortTable(sfd,sf,d->lastttf);\n     }\n     else\n     {\n         return false;\n     }\n     return true;\n }\n \n", "target": "// fix_start\n\tint layer_cnt_tmp;\n\tgetint(sfd,&layer_cnt_tmp);\n\tif ( layer_cnt_tmp>2 ) {\n// fix_end\n// fix_start\n\t    sf->layer_cnt = layer_cnt_tmp;\n// fix_end\n", "cwe": "CWE-416", "cwe_name": "Use After Free", "cve": "CVE-2020-5395", "cve_desc": "FontForge 20190801 has a use-after-free in SFD_GetFontMetaData in sfd.c.", "project": "fontforge", "idx": 209042}
{"source": " int flb_gzip_compress(void *in_data, size_t in_len,\n                       void **out_data, size_t *out_len)\n {\n     int flush;\n     int status;\n     int footer_start;\n     uint8_t *pb;\n     size_t out_size;\n     void *out_buf;\n     z_stream strm;\n     mz_ulong crc;\n \n// bug_start\n    out_size = in_len + 32;\n// bug_end\n     out_buf = flb_malloc(out_size);\n// bug_start\n// bug_end\n     if (!out_buf) {\n         flb_errno();\n         flb_error(\"[gzip] could not allocate outgoing buffer\");\n         return -1;\n     }\n \n     memset(&strm, '\\0', sizeof(strm));\n     strm.zalloc    = Z_NULL;\n     strm.zfree     = Z_NULL;\n     strm.opaque    = Z_NULL;\n     strm.next_in   = in_data;\n     strm.avail_in  = in_len;\n     strm.total_out = 0;\n \n     deflateInit2(&strm, Z_DEFAULT_COMPRESSION,\n                  Z_DEFLATED, -Z_DEFAULT_WINDOW_BITS, 9, Z_DEFAULT_STRATEGY);\n \n     gzip_header(out_buf);\n \n     pb = (uint8_t *) out_buf + FLB_GZIP_HEADER_OFFSET;\n \n     flush = Z_NO_FLUSH;\n     while (1) {\n         strm.next_out  = pb + strm.total_out;\n         strm.avail_out = out_size - (pb - (uint8_t *) out_buf);\n \n         if (strm.avail_in == 0) {\n             flush = Z_FINISH;\n         }\n \n         status = deflate(&strm, flush);\n         if (status == Z_STREAM_END) {\n             break;\n         }\n         else if (status != Z_OK) {\n             deflateEnd(&strm);\n             return -1;\n         }\n     }\n \n     if (deflateEnd(&strm) != Z_OK) {\n         flb_free(out_buf);\n         return -1;\n     }\n     *out_len = strm.total_out;\n \n     footer_start = FLB_GZIP_HEADER_OFFSET + *out_len;\n     pb = (uint8_t *) out_buf + footer_start;\n \n     crc = mz_crc32(MZ_CRC32_INIT, in_data, in_len);\n     *pb++ = crc & 0xFF;\n     *pb++ = (crc >> 8) & 0xFF;\n     *pb++ = (crc >> 16) & 0xFF;\n     *pb++ = (crc >> 24) & 0xFF;\n     *pb++ = in_len & 0xFF;\n     *pb++ = (in_len >> 8) & 0xFF;\n     *pb++ = (in_len >> 16) & 0xFF;\n     *pb++ = (in_len >> 24) & 0xFF;\n \n     *out_len += FLB_GZIP_HEADER_OFFSET + 8;\n     *out_data = out_buf;\n \n     return 0;\n }\n \n", "target": "// fix_start\n\n    int max_input_expansion = ((int)(in_len / 32000) + 1) * 5;\n\n    out_size = 10 + 8 + max_input_expansion + in_len;\n// fix_end\n// fix_start\n\n// fix_end\n", "cwe": "CWE-787", "cwe_name": "Out-of-bounds Write", "cve": "CVE-2020-35963", "cve_desc": "flb_gzip_compress in flb_gzip.c in Fluent Bit before 1.6.4 has an out-of-bounds write because it does not use the correct calculation of the maximum gzip data-size expansion.", "project": "fluent-bit", "idx": 209045}
{"source": " filter_session_io(struct io *io, int evt, void *arg)\n {\n \tstruct filter_session *fs = arg;\n \tchar *line = NULL;\n \tssize_t len;\n \n \tlog_trace(TRACE_IO, \"filter session: %p: %s %s\", fs, io_strevent(evt),\n \t    io_strio(io));\n \n \tswitch (evt) {\n \tcase IO_DATAIN:\n \tnextline:\n \t\tline = io_getline(fs->io, &len);\n \t\tif (line == NULL)\n \t\t\treturn;\n \n \t\tfilter_data(fs->id, line);\n \n \t\tgoto nextline;\n// bug_start\n\n\tcase IO_DISCONNECTED:\n\t\tio_free(fs->io);\n\t\tfs->io = NULL;\n\t\tbreak;\n// bug_end\n \t}\n }\n \n", "target": "// fix_start\n// fix_end\n", "cwe": "CWE-476", "cwe_name": "NULL Pointer Dereference", "cve": "CVE-2020-35680", "cve_desc": "smtpd/lka_filter.c in OpenSMTPD before 6.8.0p1, in certain configurations, allows remote attackers to cause a denial of service (NULL pointer dereference and daemon crash) via a crafted pattern of client activity, because the filter state machine does not properly maintain the I/O channel between the SMTP engine and the filters layer.", "project": "src", "idx": 209807}
{"source": " ipmi_lan_alert_set(struct ipmi_intf * intf, uint8_t chan, uint8_t alert,\n \t\t   int argc, char ** argv)\n {\n \tstruct lan_param * p;\n \tuint8_t data[32], temp[32];\n \tint rc = 0;\n \n \tif (argc < 2) {\n \t\tprint_lan_alert_set_usage();\n \t\treturn (-1);\n \t}\n \n \tif (strncmp(argv[0], \"help\", 4) == 0 ||\n \t    strncmp(argv[1], \"help\", 4) == 0) {\n \t\tprint_lan_alert_set_usage();\n \t\treturn 0;\n \t}\n \n \tmemset(data, 0, sizeof(data));\n \tmemset(temp, 0, sizeof(temp));\n \n \tif (strncasecmp(argv[0], \"ipaddr\", 6) == 0 &&\n \t    (get_cmdline_ipaddr(argv[1], temp) == 0)) {\n \t\tp = get_lan_param_select(intf, chan, IPMI_LANP_DEST_ADDR, alert);\n \t\tif (!p) {\n \t\t\treturn (-1);\n \t\t}\n// bug_start\n\t\tmemcpy(data, p->data, p->data_len);\n// bug_end\n \t\tmemcpy(data+3, temp, 4);\n \t\tprintf(\"Setting LAN Alert %d IP Address to %d.%d.%d.%d\\n\", alert,\n \t\t       data[3], data[4], data[5], data[6]);\n \t\trc = set_lan_param_nowait(intf, chan, IPMI_LANP_DEST_ADDR, data, p->data_len);\n \t}\n \telse if (strncasecmp(argv[0], \"macaddr\", 7) == 0 &&\n \t\t (str2mac(argv[1], temp) == 0)) {\n \t\tp = get_lan_param_select(intf, chan, IPMI_LANP_DEST_ADDR, alert);\n \t\tif (!p) {\n \t\t\treturn (-1);\n \t\t}\n// bug_start\n\t\tmemcpy(data, p->data, p->data_len);\n// bug_end\n \t\tmemcpy(data+7, temp, 6);\n \t\tprintf(\"Setting LAN Alert %d MAC Address to \"\n \t\t       \"%s\\n\", alert, mac2str(&data[7]));\n \t\trc = set_lan_param_nowait(intf, chan, IPMI_LANP_DEST_ADDR, data, p->data_len);\n \t}\n \telse if (strncasecmp(argv[0], \"gateway\", 7) == 0) {\n \t\tp = get_lan_param_select(intf, chan, IPMI_LANP_DEST_ADDR, alert);\n \t\tif (!p) {\n \t\t\treturn (-1);\n \t\t}\n// bug_start\n\t\tmemcpy(data, p->data, p->data_len);\n// bug_end\n \n \t\tif (strncasecmp(argv[1], \"def\", 3) == 0 ||\n \t\t    strncasecmp(argv[1], \"default\", 7) == 0) {\n \t\t\tprintf(\"Setting LAN Alert %d to use Default Gateway\\n\", alert);\n \t\t\tdata[2] = 0;\n \t\t}\n \t\telse if (strncasecmp(argv[1], \"bak\", 3) == 0 ||\n \t\t\t strncasecmp(argv[1], \"backup\", 6) == 0) {\n \t\t\tprintf(\"Setting LAN Alert %d to use Backup Gateway\\n\", alert);\n \t\t\tdata[2] = 1;\n \t\t}\n \t\telse {\n \t\t\tprint_lan_alert_set_usage();\n \t\t\treturn -1;\n \t\t}\n \n \t\trc = set_lan_param_nowait(intf, chan, IPMI_LANP_DEST_ADDR, data, p->data_len);\n \t}\n \telse if (strncasecmp(argv[0], \"ack\", 3) == 0) {\n \t\tp = get_lan_param_select(intf, chan, IPMI_LANP_DEST_TYPE, alert);\n \t\tif (!p) {\n \t\t\treturn (-1);\n \t\t}\n// bug_start\n\t\tmemcpy(data, p->data, p->data_len);\n// bug_end\n \n \t\tif (strncasecmp(argv[1], \"on\", 2) == 0 ||\n \t\t    strncasecmp(argv[1], \"yes\", 3) == 0) {\n \t\t\tprintf(\"Setting LAN Alert %d to Acknowledged\\n\", alert);\n \t\t\tdata[1] |= 0x80;\n \t\t}\n \t\telse if (strncasecmp(argv[1], \"off\", 3) == 0 ||\n \t\t\t strncasecmp(argv[1], \"no\", 2) == 0) {\n \t\t\tprintf(\"Setting LAN Alert %d to Unacknowledged\\n\", alert);\n \t\t\tdata[1] &= ~0x80;\n \t\t}\n \t\telse {\n \t\t\tprint_lan_alert_set_usage();\n \t\t\treturn -1;\n \t\t}\n \t\trc = set_lan_param_nowait(intf, chan, IPMI_LANP_DEST_TYPE, data, p->data_len);\n \t}\n \telse if (strncasecmp(argv[0], \"type\", 4) == 0) {\n \t\tp = get_lan_param_select(intf, chan, IPMI_LANP_DEST_TYPE, alert);\n \t\tif (!p) {\n \t\t\treturn (-1);\n \t\t}\n// bug_start\n\t\tmemcpy(data, p->data, p->data_len);\n// bug_end\n \n \t\tif (strncasecmp(argv[1], \"pet\", 3) == 0) {\n \t\t\tprintf(\"Setting LAN Alert %d destination to PET Trap\\n\", alert);\n \t\t\tdata[1] &= ~0x07;\n \t\t}\n \t\telse if (strncasecmp(argv[1], \"oem1\", 4) == 0) {\n \t\t\tprintf(\"Setting LAN Alert %d destination to OEM 1\\n\", alert);\n \t\t\tdata[1] &= ~0x07;\n \t\t\tdata[1] |= 0x06;\n \t\t}\n \t\telse if (strncasecmp(argv[1], \"oem2\", 4) == 0) {\n \t\t\tprintf(\"Setting LAN Alert %d destination to OEM 2\\n\", alert);\n \t\t\tdata[1] |= 0x07;\n \t\t}\n \t\telse {\n \t\t\tprint_lan_alert_set_usage();\n \t\t\treturn -1;\n \t\t}\n \t\trc = set_lan_param_nowait(intf, chan, IPMI_LANP_DEST_TYPE, data, p->data_len);\n \t}\n \telse if (strncasecmp(argv[0], \"time\", 4) == 0) {\n \t\tp = get_lan_param_select(intf, chan, IPMI_LANP_DEST_TYPE, alert);\n \t\tif (!p) {\n \t\t\treturn (-1);\n \t\t}\n// bug_start\n\t\tmemcpy(data, p->data, p->data_len);\n// bug_end\n \n \t\tif (str2uchar(argv[1], &data[2]) != 0) {\n \t\t\tlprintf(LOG_ERR, \"Invalid time: %s\", argv[1]);\n \t\t\treturn (-1);\n \t\t}\n \t\tprintf(\"Setting LAN Alert %d timeout/retry to %d seconds\\n\", alert, data[2]);\n \t\trc = set_lan_param_nowait(intf, chan, IPMI_LANP_DEST_TYPE, data, p->data_len);\n \t}\n \telse if (strncasecmp(argv[0], \"retry\", 5) == 0) {\n \t\tp = get_lan_param_select(intf, chan, IPMI_LANP_DEST_TYPE, alert);\n \t\tif (!p) {\n \t\t\treturn (-1);\n \t\t}\n// bug_start\n\t\tmemcpy(data, p->data, p->data_len);\n// bug_end\n \n \t\tif (str2uchar(argv[1], &data[3]) != 0) {\n \t\t\tlprintf(LOG_ERR, \"Invalid retry: %s\", argv[1]);\n \t\t\treturn (-1);\n \t\t}\n \t\tdata[3] = data[3] & 0x7;\n \t\tprintf(\"Setting LAN Alert %d number of retries to %d\\n\", alert, data[3]);\n \t\trc = set_lan_param_nowait(intf, chan, IPMI_LANP_DEST_TYPE, data, p->data_len);\n \t}\n \telse {\n \t\tprint_lan_alert_set_usage();\n \t\treturn -1;\n \t}\n \n \treturn rc;\n }\n \n", "target": "// fix_start\n\t\tmemcpy(data, p->data, __min(p->data_len, sizeof(data)));\n// fix_end\n// fix_start\n\t\tmemcpy(data, p->data, __min(p->data_len, sizeof(data)));\n// fix_end\n// fix_start\n\t\tmemcpy(data, p->data, __min(p->data_len, sizeof(data)));\n// fix_end\n// fix_start\n\t\tmemcpy(data, p->data, __min(p->data_len, sizeof(data)));\n// fix_end\n// fix_start\n\t\tmemcpy(data, p->data, __min(p->data_len, sizeof(data)));\n// fix_end\n// fix_start\n\t\tmemcpy(data, p->data, __min(p->data_len, sizeof(data)));\n// fix_end\n// fix_start\n\t\tmemcpy(data, p->data, __min(p->data_len, sizeof(data)));\n// fix_end\n", "cwe": "CWE-120", "cwe_name": "Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')", "cve": "CVE-2020-5208", "cve_desc": "It's been found that multiple functions in ipmitool before 1.8.19 neglect proper checking of the data received from a remote LAN party, which may lead to buffer overflows and potentially to remote code execution on the ipmitool side. This is especially dangerous if ipmitool is run as a privileged user. This problem is fixed in version 1.8.19.", "project": "ipmitool", "idx": 209813}
{"source": " CairoFont *CairoFont::create(GfxFont *gfxFont, XRef *xref, FT_Library lib, GBool useCIDs) {\n   Ref embRef;\n   Object refObj, strObj;\n   GooString *tmpFileName, *fileName,*tmpFileName2;\n   DisplayFontParam *dfp;\n   FILE *tmpFile;\n   int c, i, n;\n   GfxFontType fontType;\n   char **enc;\n   char *name;\n   FoFiTrueType *ff;\n   FoFiType1C *ff1c;\n   Ref ref;\n   static cairo_user_data_key_t cairo_font_face_key;\n   cairo_font_face_t *cairo_font_face;\n   FT_Face face;\n \n   Gushort *codeToGID;\n   int codeToGIDLen;\n \n   dfp = NULL;\n   codeToGID = NULL;\n   codeToGIDLen = 0;\n   cairo_font_face = NULL;\n \n   ref = *gfxFont->getID();\n   fontType = gfxFont->getType();\n \n   tmpFileName = NULL;\n \n   if (gfxFont->getEmbeddedFontID(&embRef)) {\n     if (!openTempFile(&tmpFileName, &tmpFile, \"wb\", NULL)) {\n       error(-1, \"Couldn't create temporary font file\");\n       goto err2;\n     }\n \n     refObj.initRef(embRef.num, embRef.gen);\n     refObj.fetch(xref, &strObj);\n     refObj.free();\n// bug_start\n// bug_end\n     strObj.streamReset();\n     while ((c = strObj.streamGetChar()) != EOF) {\n       fputc(c, tmpFile);\n     }\n     strObj.streamClose();\n     strObj.free();\n     fclose(tmpFile);\n     fileName = tmpFileName;\n \n   } else if (!(fileName = gfxFont->getExtFontFile())) {\n     dfp = NULL;\n     if (gfxFont->getName()) {\n       dfp = globalParams->getDisplayFont(gfxFont);\n     }\n     if (!dfp) {\n       error(-1, \"Couldn't find a font for '%s'\",\n \t    gfxFont->getName() ? gfxFont->getName()->getCString()\n \t    : \"(unnamed)\");\n       goto err2;\n     }\n     switch (dfp->kind) {\n     case displayFontT1:\n       fileName = dfp->t1.fileName;\n       fontType = gfxFont->isCIDFont() ? fontCIDType0 : fontType1;\n       break;\n     case displayFontTT:\n       fileName = dfp->tt.fileName;\n       fontType = gfxFont->isCIDFont() ? fontCIDType2 : fontTrueType;\n       break;\n     }\n   }\n \n   switch (fontType) {\n   case fontType1:\n   case fontType1C:\n     if (FT_New_Face(lib, fileName->getCString(), 0, &face)) {\n       error(-1, \"could not create type1 face\");\n       goto err2;\n     }\n \n     enc = ((Gfx8BitFont *)gfxFont)->getEncoding();\n \n     codeToGID = (Gushort *)gmallocn(256, sizeof(int));\n     codeToGIDLen = 256;\n     for (i = 0; i < 256; ++i) {\n       codeToGID[i] = 0;\n       if ((name = enc[i])) {\n \tcodeToGID[i] = (Gushort)FT_Get_Name_Index(face, name);\n       }\n     }\n     break;\n \n   case fontCIDType2:\n     codeToGID = NULL;\n     n = 0;\n     if (((GfxCIDFont *)gfxFont)->getCIDToGID()) {\n       n = ((GfxCIDFont *)gfxFont)->getCIDToGIDLen();\n       if (n) {\n \tcodeToGID = (Gushort *)gmallocn(n, sizeof(Gushort));\n \tmemcpy(codeToGID, ((GfxCIDFont *)gfxFont)->getCIDToGID(),\n \t\tn * sizeof(Gushort));\n       }\n     } else {\n       ff = FoFiTrueType::load(fileName->getCString());\n       if (! ff)\n \tgoto err2;\n       codeToGID = ((GfxCIDFont *)gfxFont)->getCodeToGIDMap(ff, &n);\n       delete ff;\n     }\n     codeToGIDLen = n;\n   case fontTrueType:\n     if (!(ff = FoFiTrueType::load(fileName->getCString()))) {\n       error(-1, \"failed to load truetype font\\n\");\n       goto err2;\n     }\n     if (fontType == fontTrueType) {\n       codeToGID = ((Gfx8BitFont *)gfxFont)->getCodeToGIDMap(ff);\n       codeToGIDLen = 256;\n     }\n     if (!openTempFile(&tmpFileName2, &tmpFile, \"wb\", NULL)) {\n       delete ff;\n       error(-1, \"failed to open truetype tempfile\\n\");\n       goto err2;\n     }\n     ff->writeTTF(&fileWrite, tmpFile);\n     fclose(tmpFile);\n     delete ff;\n \n     if (FT_New_Face(lib, tmpFileName2->getCString(), 0, &face)) {\n       error(-1, \"could not create truetype face\\n\");\n       goto err2;\n     }\n     unlink (tmpFileName2->getCString());\n     delete tmpFileName2;\n     break;\n \n   case fontCIDType0:\n   case fontCIDType0C:\n \n     codeToGID = NULL;\n     codeToGIDLen = 0;\n \n     if (!useCIDs)\n     {\n       if ((ff1c = FoFiType1C::load(fileName->getCString()))) {\n         codeToGID = ff1c->getCIDToGIDMap(&codeToGIDLen);\n         delete ff1c;\n       }\n     }\n \n     if (FT_New_Face(lib, fileName->getCString(), 0, &face)) {\n       gfree(codeToGID);\n       codeToGID = NULL;\n       error(-1, \"could not create cid face\\n\");\n       goto err2;\n     }\n     break;\n \n   default:\n     printf (\"font type not handled\\n\");\n     goto err2;\n     break;\n   }\n \n   if (fileName == tmpFileName) {\n     unlink (fileName->getCString());\n     delete tmpFileName;\n   }\n \n   cairo_font_face = cairo_ft_font_face_create_for_ft_face (face,\n \t\t\t\t\t\t\t   FT_LOAD_NO_HINTING |\n \t\t\t\t\t\t\t   FT_LOAD_NO_BITMAP);\n   if (cairo_font_face == NULL) {\n     error(-1, \"could not create cairo font\\n\");\n     goto err2;\n   } {\n   CairoFont *ret = new CairoFont(ref, cairo_font_face, face, codeToGID, codeToGIDLen);\n   cairo_font_face_set_user_data (cairo_font_face,\n \t\t\t\t &cairo_font_face_key,\n \t\t\t\t ret,\n \t\t\t\t cairo_font_face_destroy);\n \n   return ret;\n   }\n  err2:\n   printf (\"some font thing failed\\n\");\n   return NULL;\n }\n \n", "target": "// fix_start\n    if (!strObj.isStream()) {\n      error(-1, \"Embedded font object is wrong type\");\n      strObj.free();\n      fclose(tmpFile);\n      goto err2;\n    }\n// fix_end\n", "cwe": "CWE-20", "cwe_name": "Improper Input Validation", "cve": "CVE-2008-1693", "cve_desc": "The CairoFont::create function in CairoFontEngine.cc in Poppler, possibly before 0.8.0, as used in Xpdf, Evince, ePDFview, KWord, and other applications, does not properly handle embedded fonts in PDF files, which allows remote attackers to execute arbitrary code via a crafted font object, related to dereferencing a function pointer associated with the type of this font object.", "project": "poppler", "idx": 209818}
{"source": " ExecAlterObjectDependsStmt(AlterObjectDependsStmt *stmt, ObjectAddress *refAddress)\n {\n \tObjectAddress address;\n \tObjectAddress refAddr;\n \tRelation\trel;\n \n \taddress =\n \t\tget_object_address_rv(stmt->objectType, stmt->relation, (List *) stmt->object,\n \t\t\t\t\t\t\t  &rel, AccessExclusiveLock, false);\n// bug_start\n// bug_end\n \n \tif (rel)\n \t\ttable_close(rel, NoLock);\n \n \trefAddr = get_object_address(OBJECT_EXTENSION, (Node *) stmt->extname,\n \t\t\t\t\t\t\t\t &rel, AccessExclusiveLock, false);\n \tAssert(rel == NULL);\n \tif (refAddress)\n \t\t*refAddress = refAddr;\n \n \trecordDependencyOn(&address, &refAddr, DEPENDENCY_AUTO_EXTENSION);\n \n \treturn address;\n }\n \n", "target": "// fix_start\n\n\tcheck_object_ownership(GetUserId(),\n\t\t\t\t\t\t   stmt->objectType, address, stmt->object, rel);\n// fix_end\n", "cwe": "CWE-862", "cwe_name": "Missing Authorization", "cve": "CVE-2020-1720", "cve_desc": "A flaw was found in PostgreSQL's \"ALTER ... DEPENDS ON EXTENSION\", where sub-commands did not perform authorization checks. An authenticated attacker could use this flaw in certain configurations to perform drop objects such as function, triggers, et al., leading to database corruption. This issue affects PostgreSQL versions before 12.2, before 11.7, before 10.12 and before 9.6.17.", "project": "postgres", "idx": 209909}
{"source": " static Image *ReadXPMImage(const ImageInfo *image_info,ExceptionInfo *exception)\n {\n   char\n     *grey,\n     key[MaxTextExtent],\n     target[MaxTextExtent],\n     *xpm_buffer;\n \n   Image\n     *image;\n \n   MagickBooleanType\n     active,\n     status;\n \n   register char\n     *next,\n     *p,\n     *q;\n \n   register IndexPacket\n     *indexes;\n \n   register PixelPacket\n     *r;\n \n   register ssize_t\n     x;\n \n   size_t\n     length;\n \n   SplayTreeInfo\n     *xpm_colors;\n \n   ssize_t\n     count,\n     j,\n     y;\n \n   unsigned long\n     colors,\n     columns,\n     rows,\n     width;\n \n   assert(image_info != (const ImageInfo *) NULL);\n   assert(image_info->signature == MagickCoreSignature);\n   if (image_info->debug != MagickFalse)\n     (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n       image_info->filename);\n   assert(exception != (ExceptionInfo *) NULL);\n   assert(exception->signature == MagickCoreSignature);\n   image=AcquireImage(image_info);\n   status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n   if (status == MagickFalse)\n     {\n       image=DestroyImageList(image);\n       return((Image *) NULL);\n     }\n   length=MaxTextExtent;\n   xpm_buffer=(char *) AcquireQuantumMemory((size_t) length,sizeof(*xpm_buffer));\n   if (xpm_buffer == (char *) NULL)\n     ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n   *xpm_buffer='\\0';\n   p=xpm_buffer;\n   while (ReadBlobString(image,p) != (char *) NULL)\n   {\n     if ((*p == '#') && ((p == xpm_buffer) || (*(p-1) == '\\n')))\n       continue;\n     if ((*p == '}') && (*(p+1) == ';'))\n       break;\n     p+=strlen(p);\n     if ((size_t) (p-xpm_buffer+MaxTextExtent) < length)\n       continue;\n     length<<=1;\n     xpm_buffer=(char *) ResizeQuantumMemory(xpm_buffer,length+MaxTextExtent,\n       sizeof(*xpm_buffer));\n     if (xpm_buffer == (char *) NULL)\n       break;\n     p=xpm_buffer+strlen(xpm_buffer);\n   }\n   if (xpm_buffer == (char *) NULL)\n     ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n   count=0;\n   width=0;\n   for (p=xpm_buffer; *p != '\\0'; p++)\n   {\n     if (*p != '\"')\n       continue;\n     count=(ssize_t) sscanf(p+1,\"%lu %lu %lu %lu\",&columns,&rows,&colors,&width);\n     image->columns=columns;\n     image->rows=rows;\n     image->colors=colors;\n     if (count == 4)\n       break;\n   }\n   if ((count != 4) || (width == 0) || (width > 3) ||\n       (image->columns == 0) || (image->rows == 0) ||\n       (image->colors == 0) || (image->colors > MaxColormapSize))\n     {\n       xpm_buffer=DestroyString(xpm_buffer);\n       ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n     }\n   active=MagickFalse;\n   for (q=xpm_buffer; *p != '\\0'; )\n   {\n     if (*p++ == '\"')\n       {\n         if (active != MagickFalse)\n           *q++='\\n';\n         active=active != MagickFalse ? MagickFalse : MagickTrue;\n       }\n     if (active != MagickFalse)\n       *q++=(*p);\n   }\n   *q='\\0';\n   if (active != MagickFalse)\n     {\n       xpm_buffer=DestroyString(xpm_buffer);\n       ThrowReaderException(CorruptImageError,\"UnexpectedEndOfFile\");\n     }\n   xpm_colors=NewSplayTree(CompareXPMColor,RelinquishMagickMemory,\n     (void *(*)(void *)) NULL);\n   if (AcquireImageColormap(image,image->colors) == MagickFalse)\n     {\n       xpm_colors=DestroySplayTree(xpm_colors);\n       xpm_buffer=DestroyString(xpm_buffer);\n       ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n     }\n   image->depth=1;\n   next=NextXPMLine(xpm_buffer);\n   for (j=0; (j < (ssize_t) image->colors) && (next != (char *) NULL); j++)\n   {\n     char\n       symbolic[MagickPathExtent];\n \n     MagickPixelPacket\n       pixel;\n \n     p=next;\n     next=NextXPMLine(p);\n     if (next == (char *) NULL)\n       break;\n     length=MagickMin((size_t) width,MagickPathExtent-1);\n     if (CopyXPMColor(key,p,length) != (ssize_t) length)\n       break;\n     status=AddValueToSplayTree(xpm_colors,ConstantString(key),(void *) j);\n// bug_start\n// bug_end\n     (void) CopyMagickString(target,\"gray\",MaxTextExtent);\n     q=(char *) NULL;\n     if (strlen(p) > width)\n       q=ParseXPMColor(p+width,MagickTrue);\n// bug_start\n// bug_end\n     *symbolic='\\0';\n     if (q != (char *) NULL)\n       {\n         while ((isspace((int) ((unsigned char) *q)) == 0) && (*q != '\\0'))\n           q++;\n         if ((next-q) < 0)\n           break;\n         if (next != (char *) NULL)\n           (void) CopyXPMColor(target,q,MagickMin((size_t) (next-q),\n             MaxTextExtent-1));\n         else\n           (void) CopyMagickString(target,q,MaxTextExtent);\n         q=ParseXPMColor(target,MagickFalse);\n         (void) CopyXPMColor(symbolic,q,MagickMin((size_t) (next-q),\n           MagickPathExtent-1));\n         if (q != (char *) NULL)\n           *q='\\0';\n       }\n     StripString(target);\n     if (*symbolic != '\\0')\n       (void) AddValueToSplayTree(xpm_symbolic,ConstantString(target),\n         ConstantString(symbolic));\n     grey=strstr(target,\"grey\");\n     if (grey != (char *) NULL)\n       grey[2]='a';\n     if (LocaleCompare(target,\"none\") == 0)\n       {\n         image->storage_class=DirectClass;\n         image->matte=MagickTrue;\n       }\n     status=QueryColorCompliance(target,XPMCompliance,&image->colormap[j],\n       exception);\n     if (status == MagickFalse)\n       break;\n     (void) QueryMagickColorCompliance(target,XPMCompliance,&pixel,exception);\n     if (image->depth < pixel.depth)\n       image->depth=pixel.depth;\n   }\n   if (j < (ssize_t) image->colors)\n     {\n       xpm_colors=DestroySplayTree(xpm_colors);\n       xpm_buffer=DestroyString(xpm_buffer);\n       ThrowReaderException(CorruptImageError,\"CorruptImage\");\n     }\n   j=0;\n   if (image_info->ping == MagickFalse)\n     {\n       status=SetImageExtent(image,image->columns,image->rows);\n       if (status == MagickFalse)\n         {\n           InheritException(exception,&image->exception);\n           xpm_colors=DestroySplayTree(xpm_colors);\n           xpm_buffer=DestroyString(xpm_buffer);\n           return(DestroyImageList(image));\n         }\n       for (y=0; y < (ssize_t) image->rows; y++)\n       {\n         p=NextXPMLine(p);\n         if (p == (char *) NULL)\n           break;\n         r=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n         if (r == (PixelPacket *) NULL)\n           break;\n         indexes=GetAuthenticIndexQueue(image);\n         for (x=0; x < (ssize_t) image->columns; x++)\n         {\n           ssize_t\n             count;\n \n           count=CopyXPMColor(key,p,MagickMin(width,MaxTextExtent-1));\n           if (count != (ssize_t) width)\n             break;\n           j=(ssize_t) GetValueFromSplayTree(xpm_colors,key);\n           if (image->storage_class == PseudoClass)\n             SetPixelIndex(indexes+x,j);\n           *r=image->colormap[j];\n           p+=count;\n           r++;\n         }\n         if (x < (ssize_t) image->columns)\n           break;\n         if (SyncAuthenticPixels(image,exception) == MagickFalse)\n           break;\n       }\n       if (y < (ssize_t) image->rows)\n         {\n           xpm_colors=DestroySplayTree(xpm_colors);\n           xpm_buffer=DestroyString(xpm_buffer);\n           ThrowReaderException(CorruptImageError,\"NotEnoughPixelData\");\n         }\n     }\n   xpm_colors=DestroySplayTree(xpm_colors);\n   xpm_buffer=DestroyString(xpm_buffer);\n   (void) CloseBlob(image);\n   return(GetFirstImageInList(image));\n }\n \n", "target": "// fix_start\n    (void) memset(target,0,sizeof(target));\n// fix_end\n// fix_start\n    (void) memset(symbolic,0,sizeof(symbolic));\n// fix_end\n", "cwe": "CWE-787", "cwe_name": "Out-of-bounds Write", "cve": "CVE-2020-19667", "cve_desc": "Stack-based buffer overflow and unconditional jump in ReadXPMImage in coders/xpm.c in ImageMagick 7.0.10-7.", "project": "ImageMagick6", "idx": 209922}
{"source": " static int ntlm_read_ntlm_v2_client_challenge(wStream* s, NTLMv2_CLIENT_CHALLENGE* challenge)\n {\n \tsize_t size;\n// bug_start\n// bug_end\n \tStream_Read_UINT8(s, challenge->RespType);\n \tStream_Read_UINT8(s, challenge->HiRespType);\n \tStream_Read_UINT16(s, challenge->Reserved1);\n \tStream_Read_UINT32(s, challenge->Reserved2);\n \tStream_Read(s, challenge->Timestamp, 8);\n \tStream_Read(s, challenge->ClientChallenge, 8);\n \tStream_Read_UINT32(s, challenge->Reserved3);\n \tsize = Stream_Length(s) - Stream_GetPosition(s);\n \n \tif (size > UINT32_MAX)\n \t\treturn -1;\n \n \tchallenge->cbAvPairs = size;\n \tchallenge->AvPairs = (NTLM_AV_PAIR*)malloc(challenge->cbAvPairs);\n \n \tif (!challenge->AvPairs)\n \t\treturn -1;\n \n \tStream_Read(s, challenge->AvPairs, size);\n \treturn 1;\n }\n \n", "target": "// fix_start\n\tif (Stream_GetRemainingLength(s) < 28)\n\t\treturn -1;\n\n// fix_end\n", "cwe": "CWE-125", "cwe_name": "Out-of-bounds Read", "cve": "CVE-2020-11086", "cve_desc": "In FreeRDP less than or equal to 2.0.0, there is an out-of-bound read in ntlm_read_ntlm_v2_client_challenge that reads up to 28 bytes out-of-bound to an internal structure. This has been fixed in 2.1.0.", "project": "FreeRDP", "idx": 209951}
{"source": " sftp_client_message sftp_get_client_message(sftp_session sftp) {\n   ssh_session session = sftp->session;\n   sftp_packet packet;\n   sftp_client_message msg;\n   ssh_buffer payload;\n   int rc;\n \n   msg = malloc(sizeof (struct sftp_client_message_struct));\n   if (msg == NULL) {\n     ssh_set_error_oom(session);\n     return NULL;\n   }\n   ZERO_STRUCTP(msg);\n \n   packet = sftp_packet_read(sftp);\n   if (packet == NULL) {\n     ssh_set_error_oom(session);\n     sftp_client_message_free(msg);\n     return NULL;\n   }\n \n   payload = packet->payload;\n   msg->type = packet->type;\n   msg->sftp = sftp;\n \n   msg->complete_message = ssh_buffer_new();\n   if (msg->complete_message == NULL) {\n       ssh_set_error_oom(session);\n       sftp_client_message_free(msg);\n       return NULL;\n   }\n \n// bug_start\n  ssh_buffer_add_data(msg->complete_message,\n                      ssh_buffer_get(payload),\n                      ssh_buffer_get_len(payload));\n// bug_end\n \n   ssh_buffer_get_u32(payload, &msg->id);\n \n   switch(msg->type) {\n     case SSH_FXP_CLOSE:\n     case SSH_FXP_READDIR:\n       msg->handle = ssh_buffer_get_ssh_string(payload);\n       if (msg->handle == NULL) {\n         ssh_set_error_oom(session);\n         sftp_client_message_free(msg);\n         return NULL;\n       }\n       break;\n     case SSH_FXP_READ:\n       rc = ssh_buffer_unpack(payload,\n                              \"Sqd\",\n                              &msg->handle,\n                              &msg->offset,\n                              &msg->len);\n       if (rc != SSH_OK) {\n         ssh_set_error_oom(session);\n         sftp_client_message_free(msg);\n         return NULL;\n       }\n       break;\n     case SSH_FXP_WRITE:\n       rc = ssh_buffer_unpack(payload,\n                              \"SqS\",\n                              &msg->handle,\n                              &msg->offset,\n                              &msg->data);\n       if (rc != SSH_OK) {\n         ssh_set_error_oom(session);\n         sftp_client_message_free(msg);\n         return NULL;\n       }\n       break;\n     case SSH_FXP_REMOVE:\n     case SSH_FXP_RMDIR:\n     case SSH_FXP_OPENDIR:\n     case SSH_FXP_READLINK:\n     case SSH_FXP_REALPATH:\n       rc = ssh_buffer_unpack(payload,\n                              \"s\",\n                              &msg->filename);\n       if (rc != SSH_OK) {\n         ssh_set_error_oom(session);\n         sftp_client_message_free(msg);\n         return NULL;\n       }\n       break;\n     case SSH_FXP_RENAME:\n     case SSH_FXP_SYMLINK:\n       rc = ssh_buffer_unpack(payload,\n                              \"sS\",\n                              &msg->filename,\n                              &msg->data);\n       if (rc != SSH_OK) {\n         ssh_set_error_oom(session);\n         sftp_client_message_free(msg);\n         return NULL;\n       }\n       break;\n     case SSH_FXP_MKDIR:\n     case SSH_FXP_SETSTAT:\n       rc = ssh_buffer_unpack(payload,\n                              \"s\",\n                              &msg->filename);\n       if (rc != SSH_OK) {\n         ssh_set_error_oom(session);\n         sftp_client_message_free(msg);\n         return NULL;\n       }\n       msg->attr = sftp_parse_attr(sftp, payload, 0);\n       if (msg->attr == NULL) {\n         ssh_set_error_oom(session);\n         sftp_client_message_free(msg);\n         return NULL;\n       }\n       break;\n     case SSH_FXP_FSETSTAT:\n       msg->handle = ssh_buffer_get_ssh_string(payload);\n       if (msg->handle == NULL) {\n         ssh_set_error_oom(session);\n         sftp_client_message_free(msg);\n         return NULL;\n       }\n       msg->attr = sftp_parse_attr(sftp, payload, 0);\n       if (msg->attr == NULL) {\n         ssh_set_error_oom(session);\n         sftp_client_message_free(msg);\n         return NULL;\n       }\n       break;\n     case SSH_FXP_LSTAT:\n     case SSH_FXP_STAT:\n       rc = ssh_buffer_unpack(payload,\n                              \"s\",\n                              &msg->filename);\n       if (rc != SSH_OK) {\n         ssh_set_error_oom(session);\n         sftp_client_message_free(msg);\n         return NULL;\n       }\n       if(sftp->version > 3) {\n         ssh_buffer_unpack(payload, \"d\", &msg->flags);\n       }\n       break;\n     case SSH_FXP_OPEN:\n       rc = ssh_buffer_unpack(payload,\n                              \"sd\",\n                              &msg->filename,\n                              &msg->flags);\n       if (rc != SSH_OK) {\n         ssh_set_error_oom(session);\n         sftp_client_message_free(msg);\n         return NULL;\n       }\n       msg->attr = sftp_parse_attr(sftp, payload, 0);\n       if (msg->attr == NULL) {\n         ssh_set_error_oom(session);\n         sftp_client_message_free(msg);\n         return NULL;\n       }\n       break;\n     case SSH_FXP_FSTAT:\n       rc = ssh_buffer_unpack(payload,\n                              \"S\",\n                              &msg->handle);\n       if (rc != SSH_OK) {\n         ssh_set_error_oom(session);\n         sftp_client_message_free(msg);\n         return NULL;\n       }\n       break;\n     case SSH_FXP_EXTENDED:\n       rc = ssh_buffer_unpack(payload,\n                              \"s\",\n                              &msg->submessage);\n       if (rc != SSH_OK) {\n         ssh_set_error_oom(session);\n         sftp_client_message_free(msg);\n         return NULL;\n       }\n \n       if (strcmp(msg->submessage, \"hardlink@openssh.com\") == 0 ||\n           strcmp(msg->submessage, \"posix-rename@openssh.com\") == 0) {\n         rc = ssh_buffer_unpack(payload,\n                                \"sS\",\n                                &msg->filename,\n                                &msg->data);\n         if (rc != SSH_OK) {\n           ssh_set_error_oom(session);\n           sftp_client_message_free(msg);\n           return NULL;\n         }\n       }\n       break;\n     default:\n       ssh_set_error(sftp->session, SSH_FATAL,\n                     \"Received unhandled sftp message %d\", msg->type);\n       sftp_client_message_free(msg);\n       return NULL;\n   }\n \n   return msg;\n }\n \n", "target": "// fix_start\n  rc = ssh_buffer_add_data(msg->complete_message,\n                           ssh_buffer_get(payload),\n                           ssh_buffer_get_len(payload));\n  if (rc < 0) {\n      ssh_set_error_oom(session);\n      sftp_client_message_free(msg);\n      return NULL;\n  }\n// fix_end\n", "cwe": "CWE-476", "cwe_name": "NULL Pointer Dereference", "cve": "CVE-2020-16135", "cve_desc": "libssh 0.9.4 has a NULL pointer dereference in tftpserver.c if ssh_buffer_new returns NULL.", "project": "libssh-mirror", "idx": 209954}
{"source": " static int changedline (const Proto *p, int oldpc, int newpc) {\n// bug_start\n// bug_end\n   while (oldpc++ < newpc) {\n     if (p->lineinfo[oldpc] != 0)\n       return (luaG_getfuncline(p, oldpc - 1) != luaG_getfuncline(p, newpc));\n   }\n   return 0;\n }\n \n", "target": "// fix_start\n  if (p->lineinfo == NULL)\n    return 0;\n// fix_end\n", "cwe": "CWE-787", "cwe_name": "Out-of-bounds Write", "cve": "CVE-2020-24369", "cve_desc": "ldebug.c in Lua 5.4.0 attempts to access debug information via the line hook of a stripped function, leading to a NULL pointer dereference.", "project": "lua", "idx": 210098}
{"source": " int init_aliases(void)\n {\n     FILE *fp;\n     char alias[MAXALIASLEN + 1U];\n     char dir[PATH_MAX + 1U];\n \n     if ((fp = fopen(ALIASES_FILE, \"r\")) == NULL) {\n         return 0;\n     }\n     while (fgets(alias, sizeof alias, fp) != NULL) {\n         if (*alias == '#' || *alias == '\\n' || *alias == 0) {\n             continue;\n         }\n         {\n             char * const z = alias + strlen(alias) - 1U;\n \n             if (*z != '\\n') {\n                 goto bad;\n             }\n             *z = 0;\n         }\n         do {\n             if (fgets(dir, sizeof dir, fp) == NULL || *dir == 0) {\n                 goto bad;\n             }\n             {\n                 char * const z = dir + strlen(dir) - 1U;\n \n                 if (*z == '\\n') {\n                     *z = 0;\n                 }\n             }\n         } while (*dir == '#' || *dir == 0);\n         if (head == NULL) {\n             if ((head = tail = malloc(sizeof *head)) == NULL ||\n                 (tail->alias = strdup(alias)) == NULL ||\n                 (tail->dir = strdup(dir)) == NULL) {\n                 die_mem();\n             }\n// bug_start\n            tail->next = NULL;\n// bug_end\n         } else {\n             DirAlias *curr;\n \n             if ((curr = malloc(sizeof *curr)) == NULL ||\n                 (curr->alias = strdup(alias)) == NULL ||\n                 (curr->dir = strdup(dir)) == NULL) {\n                 die_mem();\n             }\n             tail->next = curr;\n             tail = curr;\n         }\n// bug_start\n// bug_end\n     }\n     fclose(fp);\n     aliases_up++;\n \n     return 0;\n \n     bad:\n     fclose(fp);\n     logfile(LOG_ERR, MSG_ALIASES_BROKEN_FILE \" [\" ALIASES_FILE \"]\");\n \n     return -1;\n }\n \n", "target": "// fix_start\n// fix_end\n// fix_start\n        tail->next = NULL;\n// fix_end\n", "cwe": "CWE-824", "cwe_name": "Access of Uninitialized Pointer", "cve": "CVE-2020-9274", "cve_desc": "An issue was discovered in Pure-FTPd 1.0.49. An uninitialized pointer vulnerability has been detected in the diraliases linked list. When the *lookup_alias(const char alias) or print_aliases(void) function is called, they fail to correctly detect the end of the linked list and try to access a non-existent list member. This is related to init_aliases in diraliases.c.", "project": "pure-ftpd", "idx": 210109}
{"source": " PHP_FUNCTION(enchant_broker_request_dict)\n {\n \tzval *broker;\n \tenchant_broker *pbroker;\n \tenchant_dict *dict;\n \tEnchantDict *d;\n \tchar *tag;\n \tint taglen;\n \tint pos;\n \n \tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"rs\", &broker, &tag, &taglen) == FAILURE) {\n \t\tRETURN_FALSE;\n \t}\n \n \tPHP_ENCHANT_GET_BROKER;\n \n \tif (taglen == 0) {\n \t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Tag cannot be empty\");\n \t\tRETURN_FALSE;\n \t}\n \n \td = enchant_broker_request_dict(pbroker->pbroker, (const char *)tag);\n \tif (d) {\n// bug_start\n// bug_end\n \t\tif (pbroker->dictcnt) {\n \t\t\tpbroker->dict = (enchant_dict **)erealloc(pbroker->dict, sizeof(enchant_dict *) * pbroker->dictcnt);\n// bug_start\n\t\t\tpos = pbroker->dictcnt++;\n// bug_end\n \t\t} else {\n \t\t\tpbroker->dict = (enchant_dict **)emalloc(sizeof(enchant_dict *));\n \t\t\tpos = 0;\n// bug_start\n\t\t\tpbroker->dictcnt++;\n// bug_end\n \t\t}\n \n \t\tdict = pbroker->dict[pos] = (enchant_dict *)emalloc(sizeof(enchant_dict));\n \t\tdict->id = pos;\n \t\tdict->pbroker = pbroker;\n \t\tdict->pdict = d;\n \t\tdict->prev = pos ? pbroker->dict[pos-1] : NULL;\n \t\tdict->next = NULL;\n \t\tpbroker->dict[pos] = dict;\n \n \t\tif (pos) {\n \t\t\tpbroker->dict[pos-1]->next = dict;\n \t\t}\n \n \t\tdict->rsrc_id = ZEND_REGISTER_RESOURCE(return_value, dict, le_enchant_dict);\n \t\tzend_list_addref(pbroker->rsrc_id);\n \t} else {\n \t\tRETURN_FALSE;\n \t}\n }\n \n", "target": "// fix_start\n\t\tpos = pbroker->dictcnt++;\n// fix_end\n// fix_start\n// fix_end\n// fix_start\n// fix_end\n", "cwe": "CWE-119", "cwe_name": "Improper Restriction of Operations within the Bounds of a Memory Buffer", "cve": "CVE-2014-9705", "cve_desc": "Heap-based buffer overflow in the enchant_broker_request_dict function in ext/enchant/enchant.c in PHP before 5.4.38, 5.5.x before 5.5.22, and 5.6.x before 5.6.6 allows remote attackers to execute arbitrary code via vectors that trigger creation of multiple dictionaries.", "project": "php-src", "idx": 210165}
{"source": " check_tty(const char *tty)\n {\n \tif ((tty == NULL) || (strlen(tty) == 0)) {\n \t\treturn NULL;\n \t}\n \tif (strchr(tty, '/') != NULL) {\n \t\tif (strncmp(tty, \"/dev/\", 5) != 0) {\n \t\t\treturn NULL;\n \t\t}\n \t\ttty = strrchr(tty, '/') + 1;\n \t}\n// bug_start\n\tif (strlen(tty) == 0) {\n// bug_end\n \t\treturn NULL;\n \t}\n \treturn tty;\n }\n \n", "target": "// fix_start\n\tif (!strlen(tty) || !strcmp(tty, \".\") || !strcmp(tty, \"..\")) {\n// fix_end\n", "cwe": "CWE-22", "cwe_name": "Path Traversal", "cve": "CVE-2014-2583", "cve_desc": "Multiple directory traversal vulnerabilities in pam_timestamp.c in the pam_timestamp module for Linux-PAM (aka pam) 1.1.8 allow local users to create arbitrary files or possibly bypass authentication via a .. (dot dot) in the (1) PAM_RUSER value to the get_ruser function or (2) PAM_TTY value to the check_tty function, which is used by the format_timestamp_name function.", "project": "linux-pam", "idx": 210171}
{"source": " get_ruser(pam_handle_t *pamh, char *ruserbuf, size_t ruserbuflen)\n {\n \tconst void *ruser;\n \tstruct passwd *pwd;\n \n \tif (ruserbuf == NULL || ruserbuflen < 1)\n \t\treturn -2;\n \tif (pam_get_item(pamh, PAM_RUSER, &ruser) != PAM_SUCCESS) {\n \t\truser = NULL;\n \t}\n \tif ((ruser == NULL) || (strlen(ruser) == 0)) {\n \t\tpwd = pam_modutil_getpwuid(pamh, getuid());\n \t\tif (pwd != NULL) {\n \t\t\truser = pwd->pw_name;\n \t\t}\n// bug_start\n// bug_end\n \t}\n \tif (ruser == NULL || strlen(ruser) >= ruserbuflen) {\n \t\t*ruserbuf = '\\0';\n \t\treturn -1;\n \t}\n \tstrcpy(ruserbuf, ruser);\n \treturn 0;\n }\n \n", "target": "// fix_start\n\t} else {\n\t\tif (!strcmp(ruser, \".\") ||\n\t\t    !strcmp(ruser, \"..\") ||\n\t\t    strchr(ruser, '/')) {\n\t\t\truser = NULL;\n\t\t}\n// fix_end\n", "cwe": "CWE-22", "cwe_name": "Path Traversal", "cve": "CVE-2014-2583", "cve_desc": "Multiple directory traversal vulnerabilities in pam_timestamp.c in the pam_timestamp module for Linux-PAM (aka pam) 1.1.8 allow local users to create arbitrary files or possibly bypass authentication via a .. (dot dot) in the (1) PAM_RUSER value to the get_ruser function or (2) PAM_TTY value to the check_tty function, which is used by the format_timestamp_name function.", "project": "linux-pam", "idx": 210172}
{"source": " int ma_read_ok_packet(MYSQL *mysql, uchar *pos, ulong length)\n {\n// bug_start\n// bug_end\n   size_t item_len;\n   mysql->affected_rows= net_field_length_ll(&pos);\n   mysql->insert_id=\t  net_field_length_ll(&pos);\n   mysql->server_status=uint2korr(pos);\n   pos+=2;\n   mysql->warning_count=uint2korr(pos);\n   pos+=2;\n// bug_start\n  if (pos < mysql->net.read_pos+length)\n// bug_end\n   {\n     if ((item_len= net_field_length(&pos)))\n       mysql->info=(char*) pos;\n// bug_start\n// bug_end\n \n     if (mysql->server_capabilities & CLIENT_SESSION_TRACKING)\n     {\n       ma_clear_session_state(mysql);\n       pos+= item_len;\n \n       if (mysql->server_status & SERVER_SESSION_STATE_CHANGED)\n       {\n         int i;\n// bug_start\n        if (pos < mysql->net.read_pos + length)\n// bug_end\n         {\n           LIST *session_item;\n           MYSQL_LEX_STRING *str= NULL;\n           enum enum_session_state_type si_type;\n           uchar *old_pos= pos;\n// bug_start\n          size_t item_len= net_field_length(&pos);\n// bug_end\n \n           if (mysql->info)\n             *old_pos= 0;\n \n// bug_start\n          while (item_len > 0)\n// bug_end\n           {\n             size_t plen;\n             char *data;\n// bug_start\n            old_pos= pos;\n// bug_end\n             si_type= (enum enum_session_state_type)net_field_length(&pos);\n             switch(si_type) {\n             case SESSION_TRACK_SCHEMA:\n             case SESSION_TRACK_STATE_CHANGE:\n             case SESSION_TRACK_TRANSACTION_CHARACTERISTICS:\n             case SESSION_TRACK_SYSTEM_VARIABLES:\n               if (si_type != SESSION_TRACK_STATE_CHANGE)\n                 net_field_length(&pos);\n               plen= net_field_length(&pos);\n// bug_start\n// bug_end\n               if (!(session_item= ma_multi_malloc(0,\n                                   &session_item, sizeof(LIST),\n                                   &str, sizeof(MYSQL_LEX_STRING),\n                                   &data, plen,\n                                   NULL)))\n// bug_start\n              {\n                ma_clear_session_state(mysql);\n                SET_CLIENT_ERROR(mysql, CR_OUT_OF_MEMORY, SQLSTATE_UNKNOWN, 0);\n                return -1;\n              }\n// bug_end\n               str->length= plen;\n               str->str= data;\n               memcpy(str->str, (char *)pos, plen);\n               pos+= plen;\n               session_item->data= str;\n               mysql->extension->session_state[si_type].list= list_add(mysql->extension->session_state[si_type].list, session_item);\n \n               if (si_type == SESSION_TRACK_SCHEMA)\n               {\n                 free(mysql->db);\n                 mysql->db= malloc(plen + 1);\n                 memcpy(mysql->db, str->str, plen);\n                 mysql->db[plen]= 0;\n               }\n               else if (si_type == SESSION_TRACK_SYSTEM_VARIABLES)\n               {\n                 my_bool set_charset= 0;\n                 if (!strncmp(str->str, \"character_set_client\", str->length))\n                   set_charset= 1;\n                 plen= net_field_length(&pos);\n// bug_start\n// bug_end\n                 if (!(session_item= ma_multi_malloc(0,\n                                     &session_item, sizeof(LIST),\n                                     &str, sizeof(MYSQL_LEX_STRING),\n                                     &data, plen,\n                                     NULL)))\n// bug_start\n                {\n                  ma_clear_session_state(mysql);\n                  SET_CLIENT_ERROR(mysql, CR_OUT_OF_MEMORY, SQLSTATE_UNKNOWN, 0);\n                  return -1;\n                }\n// bug_end\n                 str->length= plen;\n                 str->str= data;\n                 memcpy(str->str, (char *)pos, plen);\n                 pos+= plen;\n                 session_item->data= str;\n                 mysql->extension->session_state[si_type].list= list_add(mysql->extension->session_state[si_type].list, session_item);\n// bug_start\n                if (set_charset &&\n// bug_end\n                     strncmp(mysql->charset->csname, str->str, str->length) != 0)\n                 {\n// bug_start\n                  char cs_name[64];\n                  MARIADB_CHARSET_INFO *cs_info;\n// bug_end\n                   memcpy(cs_name, str->str, str->length);\n                   cs_name[str->length]= 0;\n// bug_start\n                  if ((cs_info = (MARIADB_CHARSET_INFO *)mysql_find_charset_name(cs_name)))\n// bug_end\n                     mysql->charset= cs_info;\n                 }\n               }\n               break;\n             default:\n               plen= net_field_length(&pos);\n// bug_start\n// bug_end\n               pos+= plen;\n               break;\n             }\n// bug_start\n            item_len-= (pos - old_pos);\n// bug_end\n           }\n         }\n         for (i= SESSION_TRACK_BEGIN; i <= SESSION_TRACK_END; i++)\n         {\n           mysql->extension->session_state[i].list= list_reverse(mysql->extension->session_state[i].list);\n           mysql->extension->session_state[i].current= mysql->extension->session_state[i].list;\n         }\n       }\n     }\n   }\n   else if (mysql->server_capabilities & CLIENT_SESSION_TRACKING)\n     ma_clear_session_state(mysql);\n   return(0);\n// bug_start\n// bug_end\n }\n \n", "target": "// fix_start\n  uchar *end= mysql->net.read_pos+length;\n// fix_end\n// fix_start\n  if (pos > end)\n    goto corrupted;\n  if (pos < end)\n// fix_end\n// fix_start\n    if (pos + item_len > end)\n      goto corrupted;\n// fix_end\n// fix_start\n        if (pos < end)\n// fix_end\n// fix_start\n\n          item_len= net_field_length(&pos);\n          if (pos + item_len > end)\n            goto corrupted;\n          end= pos + item_len;\n// fix_end\n// fix_start\n          while (pos < end)\n// fix_end\n// fix_start\n// fix_end\n// fix_start\n              if (pos + plen > end)\n                goto corrupted;\n// fix_end\n// fix_start\n                  goto oom;\n// fix_end\n// fix_start\n                if (pos + plen > end)\n                  goto corrupted;\n// fix_end\n// fix_start\n                  goto oom;\n// fix_end\n// fix_start\n                if (set_charset && str->length < CHARSET_NAME_LEN &&\n// fix_end\n// fix_start\n                  char cs_name[CHARSET_NAME_LEN];\n                  const MARIADB_CHARSET_INFO *cs_info;\n// fix_end\n// fix_start\n                  if ((cs_info = mysql_find_charset_name(cs_name)))\n// fix_end\n// fix_start\n              if (pos + plen > end)\n                goto corrupted;\n// fix_end\n// fix_start\n// fix_end\n// fix_start\n\noom:\n  ma_clear_session_state(mysql);\n  SET_CLIENT_ERROR(mysql, CR_OUT_OF_MEMORY, SQLSTATE_UNKNOWN, 0);\n  return -1;\n\ncorrupted:\n  ma_clear_session_state(mysql);\n  SET_CLIENT_ERROR(mysql, CR_MALFORMED_PACKET, SQLSTATE_UNKNOWN, 0);\n  return -1;\n// fix_end\n", "cwe": "CWE-20", "cwe_name": "Improper Input Validation", "cve": "CVE-2020-13249", "cve_desc": "libmariadb/mariadb_lib.c in MariaDB Connector/C before 3.1.8 does not properly validate the content of an OK packet received from a server. NOTE: although mariadb_lib.c was originally based on code shipped for MySQL, this issue does not affect any MySQL components supported by Oracle.", "project": "mariadb-connector-c", "idx": 210193}
{"source": " UnicodeString::doAppend(const UChar *srcChars, int32_t srcStart, int32_t srcLength) {\n   if(!isWritable() || srcLength == 0 || srcChars == NULL) {\n     return *this;\n   }\n \n   srcChars += srcStart;\n \n   if(srcLength < 0) {\n     if((srcLength = u_strlen(srcChars)) == 0) {\n       return *this;\n     }\n   }\n \n   int32_t oldLength = length();\n// bug_start\n  int32_t newLength = oldLength + srcLength;\n// bug_end\n \n   const UChar* oldArray = getArrayStart();\n   if (isBufferWritable() &&\n       oldArray < srcChars + srcLength &&\n       srcChars < oldArray + oldLength) {\n     UnicodeString copy(srcChars, srcLength);\n     if (copy.isBogus()) {\n       setToBogus();\n       return *this;\n     }\n     return doAppend(copy.getArrayStart(), 0, srcLength);\n   }\n \n   if((newLength <= getCapacity() && isBufferWritable()) ||\n       cloneArrayIfNeeded(newLength, getGrowCapacity(newLength))) {\n     UChar *newArray = getArrayStart();\n     if(srcChars != newArray + oldLength) {\n       us_arrayCopy(srcChars, 0, newArray, oldLength, srcLength);\n     }\n     setLength(newLength);\n   }\n   return *this;\n }\n \n", "target": "// fix_start\n  int32_t newLength;\n  if (uprv_add32_overflow(oldLength, srcLength, &newLength)) {\n    setToBogus();\n    return *this;\n  }\n// fix_end\n", "cwe": "CWE-190", "cwe_name": "Integer Overflow or Wraparound", "cve": "CVE-2020-10531", "cve_desc": "An issue was discovered in International Components for Unicode (ICU) for C/C++ through 66.1. An integer overflow, leading to a heap-based buffer overflow, exists in the UnicodeString::doAppend() function in common/unistr.cpp.", "project": "icu", "idx": 210237}
{"source": " static int decode_attr_security_label(struct xdr_stream *xdr, uint32_t *bitmap,\n \t\t\t\t\tstruct nfs4_label *label)\n {\n \tuint32_t pi = 0;\n \tuint32_t lfs = 0;\n \t__u32 len;\n \t__be32 *p;\n \tint status = 0;\n \n \tif (unlikely(bitmap[2] & (FATTR4_WORD2_SECURITY_LABEL - 1U)))\n \t\treturn -EIO;\n \tif (likely(bitmap[2] & FATTR4_WORD2_SECURITY_LABEL)) {\n \t\tp = xdr_inline_decode(xdr, 4);\n \t\tif (unlikely(!p))\n \t\t\treturn -EIO;\n \t\tlfs = be32_to_cpup(p++);\n \t\tp = xdr_inline_decode(xdr, 4);\n \t\tif (unlikely(!p))\n \t\t\treturn -EIO;\n \t\tpi = be32_to_cpup(p++);\n \t\tp = xdr_inline_decode(xdr, 4);\n \t\tif (unlikely(!p))\n \t\t\treturn -EIO;\n \t\tlen = be32_to_cpup(p++);\n \t\tp = xdr_inline_decode(xdr, len);\n \t\tif (unlikely(!p))\n \t\t\treturn -EIO;\n \t\tif (len < NFS4_MAXLABELLEN) {\n \t\t\tif (label) {\n// bug_start\n\t\t\t\tmemcpy(label->label, p, len);\n// bug_end\n \t\t\t\tlabel->len = len;\n \t\t\t\tlabel->pi = pi;\n \t\t\t\tlabel->lfs = lfs;\n \t\t\t\tstatus = NFS_ATTR_FATTR_V4_SECURITY_LABEL;\n \t\t\t}\n \t\t\tbitmap[2] &= ~FATTR4_WORD2_SECURITY_LABEL;\n \t\t} else\n \t\t\tprintk(KERN_WARNING \"%s: label too long (%u)!\\n\",\n \t\t\t\t\t__func__, len);\n \t}\n \tif (label && label->label)\n \t\tdprintk(\"%s: label=%s, len=%d, PI=%d, LFS=%d\\n\", __func__,\n \t\t\t(char *)label->label, label->len, label->pi, label->lfs);\n \treturn status;\n }\n \n", "target": "// fix_start\n\t\t\t\tif (label->len) {\n\t\t\t\t\tif (label->len < len)\n\t\t\t\t\t\treturn -ERANGE;\n\t\t\t\t\tmemcpy(label->label, p, len);\n\t\t\t\t}\n// fix_end\n", "cwe": "CWE-787", "cwe_name": "Out-of-bounds Write", "cve": "CVE-2020-25212", "cve_desc": "A TOCTOU mismatch in the NFS client code in the Linux kernel before 5.8.3 could be used by local attackers to corrupt memory or possibly have unspecified other impact because a size check is in fs/nfs/nfs4proc.c instead of fs/nfs/nfs4xdr.c, aka CID-b4487b935452.", "project": "linux", "idx": 210250}
{"source": " static void hci_extended_inquiry_result_evt(struct hci_dev *hdev,\n \t\t\t\t\t    struct sk_buff *skb)\n {\n \tstruct inquiry_data data;\n \tstruct extended_inquiry_info *info = (void *) (skb->data + 1);\n \tint num_rsp = *((__u8 *) skb->data);\n \tsize_t eir_len;\n \n \tBT_DBG(\"%s num_rsp %d\", hdev->name, num_rsp);\n \n// bug_start\n\tif (!num_rsp)\n// bug_end\n \t\treturn;\n \n \tif (hci_dev_test_flag(hdev, HCI_PERIODIC_INQ))\n \t\treturn;\n \n \thci_dev_lock(hdev);\n \n \tfor (; num_rsp; num_rsp--, info++) {\n \t\tu32 flags;\n \t\tbool name_known;\n \n \t\tbacpy(&data.bdaddr, &info->bdaddr);\n \t\tdata.pscan_rep_mode\t= info->pscan_rep_mode;\n \t\tdata.pscan_period_mode\t= info->pscan_period_mode;\n \t\tdata.pscan_mode\t\t= 0x00;\n \t\tmemcpy(data.dev_class, info->dev_class, 3);\n \t\tdata.clock_offset\t= info->clock_offset;\n \t\tdata.rssi\t\t= info->rssi;\n \t\tdata.ssp_mode\t\t= 0x01;\n \n \t\tif (hci_dev_test_flag(hdev, HCI_MGMT))\n \t\t\tname_known = eir_get_data(info->data,\n \t\t\t\t\t\t  sizeof(info->data),\n \t\t\t\t\t\t  EIR_NAME_COMPLETE, NULL);\n \t\telse\n \t\t\tname_known = true;\n \n \t\tflags = hci_inquiry_cache_update(hdev, &data, name_known);\n \n \t\teir_len = eir_get_length(info->data, sizeof(info->data));\n \n \t\tmgmt_device_found(hdev, &info->bdaddr, ACL_LINK, 0x00,\n \t\t\t\t  info->dev_class, info->rssi,\n \t\t\t\t  flags, info->data, eir_len, NULL, 0);\n \t}\n \n \thci_dev_unlock(hdev);\n }\n \n", "target": "// fix_start\n\tif (!num_rsp || skb->len < num_rsp * sizeof(*info) + 1)\n// fix_end\n", "cwe": "CWE-125", "cwe_name": "Out-of-bounds Read", "cve": "CVE-2020-36386", "cve_desc": "An issue was discovered in the Linux kernel before 5.8.1. net/bluetooth/hci_event.c has a slab out-of-bounds read in hci_extended_inquiry_result_evt, aka CID-51c19bf3d5cf.", "project": "linux", "idx": 210268}
{"source": " static int svm_cpu_init(int cpu)\n {\n \tstruct svm_cpu_data *sd;\n// bug_start\n\tint r;\n// bug_end\n \n \tsd = kzalloc(sizeof(struct svm_cpu_data), GFP_KERNEL);\n \tif (!sd)\n \t\treturn -ENOMEM;\n \tsd->cpu = cpu;\n// bug_start\n\tr = -ENOMEM;\n// bug_end\n \tsd->save_area = alloc_page(GFP_KERNEL);\n \tif (!sd->save_area)\n// bug_start\n\t\tgoto err_1;\n// bug_end\n \n \tif (svm_sev_enabled()) {\n// bug_start\n\t\tr = -ENOMEM;\n// bug_end\n \t\tsd->sev_vmcbs = kmalloc_array(max_sev_asid + 1,\n \t\t\t\t\t      sizeof(void *),\n \t\t\t\t\t      GFP_KERNEL);\n \t\tif (!sd->sev_vmcbs)\n// bug_start\n\t\t\tgoto err_1;\n// bug_end\n \t}\n \n \tper_cpu(svm_data, cpu) = sd;\n \n \treturn 0;\n \n// bug_start\nerr_1:\n// bug_end\n \tkfree(sd);\n// bug_start\n\treturn r;\n// bug_end\n \n }\n \n", "target": "// fix_start\n// fix_end\n// fix_start\n// fix_end\n// fix_start\n\t\tgoto free_cpu_data;\n// fix_end\n// fix_start\n// fix_end\n// fix_start\n\t\t\tgoto free_save_area;\n// fix_end\n// fix_start\nfree_save_area:\n\t__free_page(sd->save_area);\nfree_cpu_data:\n// fix_end\n// fix_start\n\treturn -ENOMEM;\n// fix_end\n", "cwe": "CWE-401", "cwe_name": "Missing Release of Memory after Effective Lifetime", "cve": "CVE-2020-12768", "cve_desc": "An issue was discovered in the Linux kernel before 5.6. svm_cpu_uninit in arch/x86/kvm/svm.c has a memory leak, aka CID-d80b64ff297e. NOTE: third parties dispute this issue because it's a one-time leak at the boot, the size is negligible, and it can't be triggered at will", "project": "linux", "idx": 210296}
{"source": " BOOL glyph_cache_put(rdpGlyphCache* glyphCache, UINT32 id, UINT32 index, rdpGlyph* glyph)\n {\n \trdpGlyph* prevGlyph;\n \n \tif (id > 9)\n \t{\n \t\tWLog_ERR(TAG, \"invalid glyph cache id: %\" PRIu32 \"\", id);\n \t\treturn FALSE;\n \t}\n \n// bug_start\n\tif (index > glyphCache->glyphCache[id].number)\n// bug_end\n \t{\n \t\tWLog_ERR(TAG, \"invalid glyph cache index: %\" PRIu32 \" in cache id: %\" PRIu32 \"\", index, id);\n \t\treturn FALSE;\n \t}\n \n \tWLog_Print(glyphCache->log, WLOG_DEBUG, \"GlyphCachePut: id: %\" PRIu32 \" index: %\" PRIu32 \"\", id,\n \t           index);\n \tprevGlyph = glyphCache->glyphCache[id].entries[index];\n \n \tif (prevGlyph)\n \t\tprevGlyph->Free(glyphCache->context, prevGlyph);\n \n \tglyphCache->glyphCache[id].entries[index] = glyph;\n \treturn TRUE;\n }\n \n", "target": "// fix_start\n\tif (index >= glyphCache->glyphCache[id].number)\n// fix_end\n", "cwe": "CWE-703", "cwe_name": "Improper Check or Handling of Exceptional Conditions", "cve": "CVE-2020-11098", "cve_desc": "In FreeRDP before version 2.1.2, there is an out-of-bound read in glyph_cache_put. This affects all FreeRDP clients with `+glyph-cache` option enabled This is fixed in version 2.1.2.", "project": "FreeRDP", "idx": 210325}
{"source": " static BOOL autodetect_recv_bandwidth_measure_results(rdpRdp* rdp, wStream* s,\n                                                       AUTODETECT_RSP_PDU* autodetectRspPdu)\n {\n \tBOOL success = TRUE;\n \n \tif (autodetectRspPdu->headerLength != 0x0E)\n \t\treturn FALSE;\n \n \tWLog_VRB(AUTODETECT_TAG, \"received Bandwidth Measure Results PDU\");\n// bug_start\n// bug_end\n \tStream_Read_UINT32(s, rdp->autodetect->bandwidthMeasureTimeDelta);\n \tStream_Read_UINT32(s, rdp->autodetect->bandwidthMeasureByteCount);\n \n \tif (rdp->autodetect->bandwidthMeasureTimeDelta > 0)\n \t\trdp->autodetect->netCharBandwidth = rdp->autodetect->bandwidthMeasureByteCount * 8 /\n \t\t                                    rdp->autodetect->bandwidthMeasureTimeDelta;\n \telse\n \t\trdp->autodetect->netCharBandwidth = 0;\n \n \tIFCALLRET(rdp->autodetect->BandwidthMeasureResults, success, rdp->context,\n \t          autodetectRspPdu->sequenceNumber);\n \treturn success;\n }\n \n", "target": "// fix_start\n\tif (Stream_GetRemainingLength(s) < 8)\n\t\treturn -1;\n// fix_end\n", "cwe": "CWE-125", "cwe_name": "Out-of-bounds Read", "cve": "CVE-2020-11047", "cve_desc": "In FreeRDP after 1.1 and before 2.0.0, there is an out-of-bounds read in autodetect_recv_bandwidth_measure_results. A malicious server can extract up to 8 bytes of client memory with a manipulated message by providing a short input and reading the measurement result data. This has been patched in 2.0.0.", "project": "FreeRDP", "idx": 210399}
{"source": " static PCRE2_SPTR SLJIT_FUNC do_extuni_no_utf(jit_arguments *args, PCRE2_SPTR cc)\n {\n PCRE2_SPTR start_subject = args->begin;\n PCRE2_SPTR end_subject = args->end;\n int lgb, rgb, ricount;\n PCRE2_SPTR bptr;\n uint32_t c;\n \n// bug_start\nGETCHARINC(c, cc);\n// bug_end\n lgb = UCD_GRAPHBREAK(c);\n \n while (cc < end_subject)\n   {\n   c = *cc;\n   rgb = UCD_GRAPHBREAK(c);\n \n   if ((PRIV(ucp_gbtable)[lgb] & (1 << rgb)) == 0) break;\n \n \n   if (lgb == ucp_gbRegionalIndicator && rgb == ucp_gbRegionalIndicator)\n     {\n     ricount = 0;\n     bptr = cc - 1;\n \n     while (bptr > start_subject)\n       {\n       bptr--;\n       c = *bptr;\n \n       if (UCD_GRAPHBREAK(c) != ucp_gbRegionalIndicator) break;\n \n       ricount++;\n       }\n \n     if ((ricount & 1) != 0) break;\n     }\n \n \n   if ((rgb != ucp_gbExtend && rgb != ucp_gbZWJ) ||\n        lgb != ucp_gbExtended_Pictographic)\n     lgb = rgb;\n \n   cc++;\n   }\n \n return cc;\n }\n \n", "target": "// fix_start\nc = *cc++;\n// fix_end\n", "cwe": "CWE-125", "cwe_name": "Out-of-bounds Read", "cve": "CVE-2019-20454", "cve_desc": "An out-of-bounds read was discovered in PCRE before 10.34 when the pattern \\X is JIT compiled and used to match specially crafted subjects in non-UTF mode. Applications that use PCRE to parse untrusted input may be vulnerable to this flaw, which would allow an attacker to crash the application. The flaw occurs in do_extuni_no_utf in pcre2_jit_compile.c.", "project": "php-src", "idx": 210402}
{"source": " static Image *ReadVIFFImage(const ImageInfo *image_info,\n   ExceptionInfo *exception)\n {\n #define VFF_CM_genericRGB  15\n #define VFF_CM_ntscRGB  1\n #define VFF_CM_NONE  0\n #define VFF_DEP_DECORDER  0x4\n #define VFF_DEP_NSORDER  0x8\n #define VFF_DES_RAW  0\n #define VFF_LOC_IMPLICIT  1\n #define VFF_MAPTYP_NONE  0\n #define VFF_MAPTYP_1_BYTE  1\n #define VFF_MAPTYP_2_BYTE  2\n #define VFF_MAPTYP_4_BYTE  4\n #define VFF_MAPTYP_FLOAT  5\n #define VFF_MAPTYP_DOUBLE  7\n #define VFF_MS_NONE  0\n #define VFF_MS_ONEPERBAND  1\n #define VFF_MS_SHARED  3\n #define VFF_TYP_BIT  0\n #define VFF_TYP_1_BYTE  1\n #define VFF_TYP_2_BYTE  2\n #define VFF_TYP_4_BYTE  4\n #define VFF_TYP_FLOAT  5\n #define VFF_TYP_DOUBLE  9\n \n   typedef struct _ViffInfo\n   {\n     unsigned char\n       identifier,\n       file_type,\n       release,\n       version,\n       machine_dependency,\n       reserve[3];\n \n     char\n       comment[512];\n \n     unsigned int\n       rows,\n       columns,\n       subrows;\n \n     int\n       x_offset,\n       y_offset;\n \n     float\n       x_bits_per_pixel,\n       y_bits_per_pixel;\n \n     unsigned int\n       location_type,\n       location_dimension,\n       number_of_images,\n       number_data_bands,\n       data_storage_type,\n       data_encode_scheme,\n       map_scheme,\n       map_storage_type,\n       map_rows,\n       map_columns,\n       map_subrows,\n       map_enable,\n       maps_per_cycle,\n       color_space_model;\n   } ViffInfo;\n \n   double\n     min_value,\n     scale_factor,\n     value;\n \n   Image\n     *image;\n \n   int\n     bit;\n \n   MagickBooleanType\n     status;\n \n   MagickSizeType\n     number_pixels;\n \n   register IndexPacket\n     *indexes;\n \n   register ssize_t\n     x;\n \n   register PixelPacket\n     *q;\n \n   register ssize_t\n     i;\n \n   register unsigned char\n     *p;\n \n   size_t\n     bytes_per_pixel,\n     max_packets,\n     quantum;\n \n   ssize_t\n     count,\n     y;\n \n   unsigned char\n     *pixels;\n \n   unsigned long\n     lsb_first;\n \n   ViffInfo\n     viff_info;\n \n   assert(image_info != (const ImageInfo *) NULL);\n   assert(image_info->signature == MagickCoreSignature);\n   if (image_info->debug != MagickFalse)\n     (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n       image_info->filename);\n   assert(exception != (ExceptionInfo *) NULL);\n   assert(exception->signature == MagickCoreSignature);\n   image=AcquireImage(image_info);\n   status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n   if (status == MagickFalse)\n     {\n       image=DestroyImageList(image);\n       return((Image *) NULL);\n     }\n   count=ReadBlob(image,1,&viff_info.identifier);\n   do\n   {\n     if ((count != 1) || ((unsigned char) viff_info.identifier != 0xab))\n       ThrowReaderException(CorruptImageError,\"NotAVIFFImage\");\n     (void) ReadBlob(image,sizeof(viff_info.file_type),&viff_info.file_type);\n     (void) ReadBlob(image,sizeof(viff_info.release),&viff_info.release);\n     (void) ReadBlob(image,sizeof(viff_info.version),&viff_info.version);\n     (void) ReadBlob(image,sizeof(viff_info.machine_dependency),\n       &viff_info.machine_dependency);\n     (void) ReadBlob(image,sizeof(viff_info.reserve),viff_info.reserve);\n     count=ReadBlob(image,512,(unsigned char *) viff_info.comment);\n     if (count != 512)\n       ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n     viff_info.comment[511]='\\0';\n     if (strlen(viff_info.comment) > 4)\n       (void) SetImageProperty(image,\"comment\",viff_info.comment);\n     if ((viff_info.machine_dependency == VFF_DEP_DECORDER) ||\n         (viff_info.machine_dependency == VFF_DEP_NSORDER))\n       image->endian=LSBEndian;\n     else\n       image->endian=MSBEndian;\n     viff_info.rows=ReadBlobLong(image);\n     viff_info.columns=ReadBlobLong(image);\n     viff_info.subrows=ReadBlobLong(image);\n     viff_info.x_offset=ReadBlobSignedLong(image);\n     viff_info.y_offset=ReadBlobSignedLong(image);\n     viff_info.x_bits_per_pixel=(float) ReadBlobLong(image);\n     viff_info.y_bits_per_pixel=(float) ReadBlobLong(image);\n     viff_info.location_type=ReadBlobLong(image);\n     viff_info.location_dimension=ReadBlobLong(image);\n     viff_info.number_of_images=ReadBlobLong(image);\n     viff_info.number_data_bands=ReadBlobLong(image);\n     viff_info.data_storage_type=ReadBlobLong(image);\n     viff_info.data_encode_scheme=ReadBlobLong(image);\n     viff_info.map_scheme=ReadBlobLong(image);\n     viff_info.map_storage_type=ReadBlobLong(image);\n     viff_info.map_rows=ReadBlobLong(image);\n     viff_info.map_columns=ReadBlobLong(image);\n     viff_info.map_subrows=ReadBlobLong(image);\n     viff_info.map_enable=ReadBlobLong(image);\n     viff_info.maps_per_cycle=ReadBlobLong(image);\n     viff_info.color_space_model=ReadBlobLong(image);\n     for (i=0; i < 420; i++)\n       (void) ReadBlobByte(image);\n     if (EOFBlob(image) != MagickFalse)\n       ThrowReaderException(CorruptImageError,\"UnexpectedEndOfFile\");\n// bug_start\n// bug_end\n     image->columns=viff_info.rows;\n     image->rows=viff_info.columns;\n     image->depth=viff_info.x_bits_per_pixel <= 8 ? 8UL :\n       MAGICKCORE_QUANTUM_DEPTH;\n     image->matte=viff_info.number_data_bands == 4 ? MagickTrue : MagickFalse;\n     status=SetImageExtent(image,image->columns,image->rows);\n     if (status == MagickFalse)\n       {\n         InheritException(exception,&image->exception);\n         return(DestroyImageList(image));\n       }\n     (void) SetImageBackgroundColor(image);\n// bug_start\n    number_pixels=(MagickSizeType) viff_info.columns*viff_info.rows;\n    if (number_pixels != (size_t) number_pixels)\n      ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n    if (number_pixels == 0)\n      ThrowReaderException(CoderError,\"ImageColumnOrRowSizeIsNotSupported\");\n// bug_end\n     if ((viff_info.number_data_bands < 1) || (viff_info.number_data_bands > 4))\n       ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n     if ((viff_info.data_storage_type != VFF_TYP_BIT) &&\n         (viff_info.data_storage_type != VFF_TYP_1_BYTE) &&\n         (viff_info.data_storage_type != VFF_TYP_2_BYTE) &&\n         (viff_info.data_storage_type != VFF_TYP_4_BYTE) &&\n         (viff_info.data_storage_type != VFF_TYP_FLOAT) &&\n         (viff_info.data_storage_type != VFF_TYP_DOUBLE))\n       ThrowReaderException(CoderError,\"DataStorageTypeIsNotSupported\");\n     if (viff_info.data_encode_scheme != VFF_DES_RAW)\n       ThrowReaderException(CoderError,\"DataEncodingSchemeIsNotSupported\");\n     if ((viff_info.map_storage_type != VFF_MAPTYP_NONE) &&\n         (viff_info.map_storage_type != VFF_MAPTYP_1_BYTE) &&\n         (viff_info.map_storage_type != VFF_MAPTYP_2_BYTE) &&\n         (viff_info.map_storage_type != VFF_MAPTYP_4_BYTE) &&\n         (viff_info.map_storage_type != VFF_MAPTYP_FLOAT) &&\n         (viff_info.map_storage_type != VFF_MAPTYP_DOUBLE))\n       ThrowReaderException(CoderError,\"MapStorageTypeIsNotSupported\");\n     if ((viff_info.color_space_model != VFF_CM_NONE) &&\n         (viff_info.color_space_model != VFF_CM_ntscRGB) &&\n         (viff_info.color_space_model != VFF_CM_genericRGB))\n       ThrowReaderException(CoderError,\"ColorspaceModelIsNotSupported\");\n     if (viff_info.location_type != VFF_LOC_IMPLICIT)\n       ThrowReaderException(CoderError,\"LocationTypeIsNotSupported\");\n     if (viff_info.number_of_images != 1)\n       ThrowReaderException(CoderError,\"NumberOfImagesIsNotSupported\");\n     if (viff_info.map_rows == 0)\n       viff_info.map_scheme=VFF_MS_NONE;\n     switch ((int) viff_info.map_scheme)\n     {\n       case VFF_MS_NONE:\n       {\n         if (viff_info.number_data_bands < 3)\n           {\n             if (viff_info.data_storage_type == VFF_TYP_BIT)\n               image->colors=2;\n             else\n               if (viff_info.data_storage_type == VFF_MAPTYP_1_BYTE)\n                 image->colors=256UL;\n               else\n                 image->colors=image->depth <= 8 ? 256UL : 65536UL;\n             if (AcquireImageColormap(image,image->colors) == MagickFalse)\n               ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n           }\n         break;\n       }\n       case VFF_MS_ONEPERBAND:\n       case VFF_MS_SHARED:\n       {\n         unsigned char\n           *viff_colormap;\n \n         switch ((int) viff_info.map_storage_type)\n         {\n           case VFF_MAPTYP_1_BYTE: bytes_per_pixel=1; break;\n           case VFF_MAPTYP_2_BYTE: bytes_per_pixel=2; break;\n           case VFF_MAPTYP_4_BYTE: bytes_per_pixel=4; break;\n           case VFF_MAPTYP_FLOAT: bytes_per_pixel=4; break;\n           case VFF_MAPTYP_DOUBLE: bytes_per_pixel=8; break;\n           default: bytes_per_pixel=1; break;\n         }\n         image->colors=viff_info.map_columns;\n         if ((MagickSizeType) (viff_info.map_rows*image->colors) > GetBlobSize(image))\n           ThrowReaderException(CorruptImageError,\"InsufficientImageDataInFile\");\n         if (AcquireImageColormap(image,image->colors) == MagickFalse)\n           ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n         if ((MagickSizeType) viff_info.map_rows > GetBlobSize(image))\n           ThrowReaderException(CorruptImageError,\"InsufficientImageDataInFile\");\n         if ((MagickSizeType) viff_info.map_rows >\n             (viff_info.map_rows*bytes_per_pixel*sizeof(*viff_colormap)))\n           ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n         viff_colormap=(unsigned char *) AcquireQuantumMemory(image->colors,\n           viff_info.map_rows*bytes_per_pixel*sizeof(*viff_colormap));\n         if (viff_colormap == (unsigned char *) NULL)\n           ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n         (void) ReadBlob(image,bytes_per_pixel*image->colors*viff_info.map_rows,\n           viff_colormap);\n         lsb_first=1;\n         if (*(char *) &lsb_first &&\n             ((viff_info.machine_dependency != VFF_DEP_DECORDER) &&\n              (viff_info.machine_dependency != VFF_DEP_NSORDER)))\n           switch ((int) viff_info.map_storage_type)\n           {\n             case VFF_MAPTYP_2_BYTE:\n             {\n               MSBOrderShort(viff_colormap,(bytes_per_pixel*image->colors*\n                 viff_info.map_rows));\n               break;\n             }\n             case VFF_MAPTYP_4_BYTE:\n             case VFF_MAPTYP_FLOAT:\n             {\n               MSBOrderLong(viff_colormap,(bytes_per_pixel*image->colors*\n                 viff_info.map_rows));\n               break;\n             }\n             default: break;\n           }\n         for (i=0; i < (ssize_t) (viff_info.map_rows*image->colors); i++)\n         {\n           switch ((int) viff_info.map_storage_type)\n           {\n             case VFF_MAPTYP_2_BYTE: value=1.0*((short *) viff_colormap)[i]; break;\n             case VFF_MAPTYP_4_BYTE: value=1.0*((int *) viff_colormap)[i]; break;\n             case VFF_MAPTYP_FLOAT: value=((float *) viff_colormap)[i]; break;\n             case VFF_MAPTYP_DOUBLE: value=((double *) viff_colormap)[i]; break;\n             default: value=1.0*viff_colormap[i]; break;\n           }\n           if (i < (ssize_t) image->colors)\n             {\n               image->colormap[i].red=ScaleCharToQuantum((unsigned char) value);\n               image->colormap[i].green=ScaleCharToQuantum((unsigned char)\n                 value);\n               image->colormap[i].blue=ScaleCharToQuantum((unsigned char) value);\n             }\n           else\n             if (i < (ssize_t) (2*image->colors))\n               image->colormap[i % image->colors].green=ScaleCharToQuantum(\n                 (unsigned char) value);\n             else\n               if (i < (ssize_t) (3*image->colors))\n                 image->colormap[i % image->colors].blue=ScaleCharToQuantum(\n                   (unsigned char) value);\n         }\n         viff_colormap=(unsigned char *) RelinquishMagickMemory(viff_colormap);\n         break;\n       }\n       default:\n         ThrowReaderException(CoderError,\"ColormapTypeNotSupported\");\n     }\n     if ((image_info->ping != MagickFalse) && (image_info->number_scenes != 0))\n       if (image->scene >= (image_info->scene+image_info->number_scenes-1))\n         break;\n     if (viff_info.data_storage_type == VFF_TYP_BIT)\n       {\n         image->colors=2;\n         if (AcquireImageColormap(image,image->colors) == MagickFalse)\n           ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n         image->colorspace=GRAYColorspace;\n       }\n     switch ((int) viff_info.data_storage_type)\n     {\n       case VFF_TYP_2_BYTE: bytes_per_pixel=2; break;\n       case VFF_TYP_4_BYTE: bytes_per_pixel=4; break;\n       case VFF_TYP_FLOAT: bytes_per_pixel=4; break;\n       case VFF_TYP_DOUBLE: bytes_per_pixel=8; break;\n       default: bytes_per_pixel=1; break;\n     }\n     if (viff_info.data_storage_type == VFF_TYP_BIT)\n       {\n         if (HeapOverflowSanityCheck((image->columns+7UL) >> 3UL,image->rows) != MagickFalse)\n           ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n         max_packets=((image->columns+7UL) >> 3UL)*image->rows;\n       }\n     else\n       {\n         if (HeapOverflowSanityCheck((size_t) number_pixels,viff_info.number_data_bands) != MagickFalse)\n           ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n         max_packets=(size_t) (number_pixels*viff_info.number_data_bands);\n       }\n     if ((MagickSizeType) (bytes_per_pixel*max_packets) > GetBlobSize(image))\n       ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n     pixels=(unsigned char *) AcquireQuantumMemory((size_t) MagickMax(\n       number_pixels,max_packets),bytes_per_pixel*sizeof(*pixels));\n     if (pixels == (unsigned char *) NULL)\n       ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n     (void) memset(pixels,0,MagickMax(number_pixels,max_packets)*\n       bytes_per_pixel*sizeof(*pixels));\n     (void) ReadBlob(image,bytes_per_pixel*max_packets,pixels);\n     lsb_first=1;\n     if (*(char *) &lsb_first &&\n         ((viff_info.machine_dependency != VFF_DEP_DECORDER) &&\n          (viff_info.machine_dependency != VFF_DEP_NSORDER)))\n       switch ((int) viff_info.data_storage_type)\n       {\n         case VFF_TYP_2_BYTE:\n         {\n           MSBOrderShort(pixels,bytes_per_pixel*max_packets);\n           break;\n         }\n         case VFF_TYP_4_BYTE:\n         case VFF_TYP_FLOAT:\n         {\n           MSBOrderLong(pixels,bytes_per_pixel*max_packets);\n           break;\n         }\n         default: break;\n       }\n     min_value=0.0;\n     scale_factor=1.0;\n     if ((viff_info.data_storage_type != VFF_TYP_1_BYTE) &&\n         (viff_info.map_scheme == VFF_MS_NONE))\n       {\n         double\n           max_value;\n \n         switch ((int) viff_info.data_storage_type)\n         {\n           case VFF_TYP_2_BYTE: value=1.0*((short *) pixels)[0]; break;\n           case VFF_TYP_4_BYTE: value=1.0*((int *) pixels)[0]; break;\n           case VFF_TYP_FLOAT: value=((float *) pixels)[0]; break;\n           case VFF_TYP_DOUBLE: value=((double *) pixels)[0]; break;\n           default: value=1.0*pixels[0]; break;\n         }\n         max_value=value;\n         min_value=value;\n         for (i=0; i < (ssize_t) max_packets; i++)\n         {\n           switch ((int) viff_info.data_storage_type)\n           {\n             case VFF_TYP_2_BYTE: value=1.0*((short *) pixels)[i]; break;\n             case VFF_TYP_4_BYTE: value=1.0*((int *) pixels)[i]; break;\n             case VFF_TYP_FLOAT: value=((float *) pixels)[i]; break;\n             case VFF_TYP_DOUBLE: value=((double *) pixels)[i]; break;\n             default: value=1.0*pixels[i]; break;\n           }\n           if (value > max_value)\n             max_value=value;\n           else\n             if (value < min_value)\n               min_value=value;\n         }\n         if ((min_value == 0) && (max_value == 0))\n           scale_factor=0;\n         else\n           if (min_value == max_value)\n             {\n               scale_factor=(MagickRealType) QuantumRange/min_value;\n               min_value=0;\n             }\n           else\n             scale_factor=(MagickRealType) QuantumRange/(max_value-min_value);\n       }\n     p=(unsigned char *) pixels;\n     for (i=0; i < (ssize_t) max_packets; i++)\n     {\n       switch ((int) viff_info.data_storage_type)\n       {\n         case VFF_TYP_2_BYTE: value=1.0*((short *) pixels)[i]; break;\n         case VFF_TYP_4_BYTE: value=1.0*((int *) pixels)[i]; break;\n         case VFF_TYP_FLOAT: value=((float *) pixels)[i]; break;\n         case VFF_TYP_DOUBLE: value=((double *) pixels)[i]; break;\n         default: value=1.0*pixels[i]; break;\n       }\n       if (viff_info.map_scheme == VFF_MS_NONE)\n         {\n           value=(value-min_value)*scale_factor;\n           if (value > QuantumRange)\n             value=QuantumRange;\n           else\n             if (value < 0)\n               value=0;\n         }\n       *p=(unsigned char) ((Quantum) value);\n       p++;\n     }\n     p=(unsigned char *) pixels;\n     if (viff_info.data_storage_type == VFF_TYP_BIT)\n       {\n         if (image->storage_class != PseudoClass)\n           ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n         for (y=0; y < (ssize_t) image->rows; y++)\n         {\n           q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n           if (q == (PixelPacket *) NULL)\n             break;\n           indexes=GetAuthenticIndexQueue(image);\n           for (x=0; x < (ssize_t) (image->columns-7); x+=8)\n           {\n             for (bit=0; bit < 8; bit++)\n             {\n               quantum=(size_t) ((*p) & (0x01 << bit) ? 0 : 1);\n               SetPixelRed(q,quantum == 0 ? 0 : QuantumRange);\n               SetPixelGreen(q,quantum == 0 ? 0 : QuantumRange);\n               SetPixelBlue(q,quantum == 0 ? 0 : QuantumRange);\n               if (image->storage_class == PseudoClass)\n                 SetPixelIndex(indexes+x+bit,quantum);\n              }\n             p++;\n           }\n           if ((image->columns % 8) != 0)\n             {\n               for (bit=0; bit < (int) (image->columns % 8); bit++)\n               {\n                 quantum=(size_t) ((*p) & (0x01 << bit) ? 0 : 1);\n                 SetPixelRed(q,quantum == 0 ? 0 : QuantumRange);\n                 SetPixelGreen(q,quantum == 0 ? 0 : QuantumRange);\n                 SetPixelBlue(q,quantum == 0 ? 0 : QuantumRange);\n                 if (image->storage_class == PseudoClass)\n                   SetPixelIndex(indexes+x+bit,quantum);\n               }\n               p++;\n             }\n           if (SyncAuthenticPixels(image,exception) == MagickFalse)\n             break;\n           if (image->previous == (Image *) NULL)\n             {\n               status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n                 image->rows);\n               if (status == MagickFalse)\n                 break;\n             }\n         }\n       }\n     else\n       if (image->storage_class == PseudoClass)\n         for (y=0; y < (ssize_t) image->rows; y++)\n         {\n           q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n           if (q == (PixelPacket *) NULL)\n             break;\n           indexes=GetAuthenticIndexQueue(image);\n           for (x=0; x < (ssize_t) image->columns; x++)\n             SetPixelIndex(indexes+x,*p++);\n           if (SyncAuthenticPixels(image,exception) == MagickFalse)\n             break;\n           if (image->previous == (Image *) NULL)\n             {\n               status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n                 image->rows);\n               if (status == MagickFalse)\n                 break;\n             }\n         }\n       else\n         {\n           number_pixels=(MagickSizeType) image->columns*image->rows;\n           for (y=0; y < (ssize_t) image->rows; y++)\n           {\n             q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n             if (q == (PixelPacket *) NULL)\n               break;\n             for (x=0; x < (ssize_t) image->columns; x++)\n             {\n               SetPixelRed(q,ScaleCharToQuantum(*p));\n               SetPixelGreen(q,ScaleCharToQuantum(*(p+number_pixels)));\n               SetPixelBlue(q,ScaleCharToQuantum(*(p+2*number_pixels)));\n               if (image->colors != 0)\n                 {\n                   ssize_t\n                     index;\n \n                   index=(ssize_t) GetPixelRed(q);\n                   SetPixelRed(q,image->colormap[(ssize_t)\n                     ConstrainColormapIndex(image,(ssize_t) index)].red);\n                   index=(ssize_t) GetPixelGreen(q);\n                   SetPixelGreen(q,image->colormap[(ssize_t)\n                     ConstrainColormapIndex(image,(ssize_t) index)].green);\n                   index=(ssize_t) GetPixelRed(q);\n                   SetPixelBlue(q,image->colormap[(ssize_t)\n                     ConstrainColormapIndex(image,(ssize_t) index)].blue);\n                 }\n               SetPixelOpacity(q,image->matte != MagickFalse ? QuantumRange-\n                 ScaleCharToQuantum(*(p+number_pixels*3)) : OpaqueOpacity);\n               p++;\n               q++;\n             }\n             if (SyncAuthenticPixels(image,exception) == MagickFalse)\n               break;\n             if (image->previous == (Image *) NULL)\n               {\n                 status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n                 image->rows);\n                 if (status == MagickFalse)\n                   break;\n               }\n           }\n         }\n     pixels=(unsigned char *) RelinquishMagickMemory(pixels);\n     if (image->storage_class == PseudoClass)\n       (void) SyncImage(image);\n     if (EOFBlob(image) != MagickFalse)\n       {\n         ThrowFileException(exception,CorruptImageError,\"UnexpectedEndOfFile\",\n           image->filename);\n         break;\n       }\n     if (image_info->number_scenes != 0)\n       if (image->scene >= (image_info->scene+image_info->number_scenes-1))\n         break;\n     count=ReadBlob(image,1,&viff_info.identifier);\n     if ((count == 1) && (viff_info.identifier == 0xab))\n       {\n         AcquireNextImage(image_info,image);\n         if (GetNextImageInList(image) == (Image *) NULL)\n           {\n             status=MagickFalse;\n             break;\n           }\n         image=SyncNextImageInList(image);\n         status=SetImageProgress(image,LoadImagesTag,TellBlob(image),\n           GetBlobSize(image));\n         if (status == MagickFalse)\n           break;\n       }\n   } while ((count != 0) && (viff_info.identifier == 0xab));\n   (void) CloseBlob(image);\n   if (status == MagickFalse)\n     return(DestroyImageList(image));\n   return(GetFirstImageInList(image));\n }\n \n", "target": "// fix_start\n    number_pixels=(MagickSizeType) viff_info.columns*viff_info.rows;\n    if (number_pixels != (size_t) number_pixels)\n      ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n    if (number_pixels > GetBlobSize(image))\n      ThrowReaderException(CorruptImageError,\"InsufficientImageDataInFile\");\n    if (number_pixels == 0)\n      ThrowReaderException(CoderError,\"ImageColumnOrRowSizeIsNotSupported\");\n// fix_end\n// fix_start\n// fix_end\n", "cwe": "CWE-400", "cwe_name": "Uncontrolled Resource Consumption", "cve": "CVE-2018-15607", "cve_desc": "In ImageMagick 7.0.8-11 Q16, a tiny input file 0x50 0x36 0x36 0x36 0x36 0x4c 0x36 0x38 0x36 0x36 0x36 0x36 0x36 0x36 0x1f 0x35 0x50 0x00 can result in a hang of several minutes during which CPU and memory resources are consumed until ultimately an attempted large memory allocation fails. Remote attackers could leverage this vulnerability to cause a denial of service via a crafted file.", "project": "ImageMagick6", "idx": 210554}
{"source": " MagickExport Image *AcquireImage(const ImageInfo *image_info)\n {\n   const char\n     *option;\n \n   Image\n     *image;\n \n   MagickStatusType\n     flags;\n \n   (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"...\");\n   image=(Image *) AcquireCriticalMemory(sizeof(*image));\n   (void) memset(image,0,sizeof(*image));\n   (void) CopyMagickString(image->magick,\"MIFF\",MaxTextExtent);\n   image->storage_class=DirectClass;\n   image->depth=MAGICKCORE_QUANTUM_DEPTH;\n   image->colorspace=sRGBColorspace;\n   image->rendering_intent=PerceptualIntent;\n   image->gamma=1.000f/2.200f;\n   image->chromaticity.red_primary.x=0.6400f;\n   image->chromaticity.red_primary.y=0.3300f;\n   image->chromaticity.red_primary.z=0.0300f;\n   image->chromaticity.green_primary.x=0.3000f;\n   image->chromaticity.green_primary.y=0.6000f;\n   image->chromaticity.green_primary.z=0.1000f;\n   image->chromaticity.blue_primary.x=0.1500f;\n   image->chromaticity.blue_primary.y=0.0600f;\n   image->chromaticity.blue_primary.z=0.7900f;\n   image->chromaticity.white_point.x=0.3127f;\n   image->chromaticity.white_point.y=0.3290f;\n   image->chromaticity.white_point.z=0.3583f;\n   image->interlace=NoInterlace;\n   image->ticks_per_second=UndefinedTicksPerSecond;\n   image->compose=OverCompositeOp;\n   image->blur=1.0;\n   InitializeExceptionInfo(&image->exception);\n   (void) QueryColorDatabase(BackgroundColor,&image->background_color,\n     &image->exception);\n   (void) QueryColorDatabase(BorderColor,&image->border_color,&image->exception);\n   (void) QueryColorDatabase(MatteColor,&image->matte_color,&image->exception);\n   (void) QueryColorDatabase(TransparentColor,&image->transparent_color,\n     &image->exception);\n   GetTimerInfo(&image->timer);\n   image->ping=MagickFalse;\n   image->cache=AcquirePixelCache(0);\n   image->blob=CloneBlobInfo((BlobInfo *) NULL);\n   image->timestamp=time((time_t *) NULL);\n   image->debug=IsEventLogging();\n   image->reference_count=1;\n   image->semaphore=AllocateSemaphoreInfo();\n   image->signature=MagickCoreSignature;\n   if (image_info == (ImageInfo *) NULL)\n     return(image);\n   SetBlobExempt(image,image_info->file != (FILE *) NULL ? MagickTrue :\n     MagickFalse);\n   (void) CopyMagickString(image->filename,image_info->filename,MaxTextExtent);\n   (void) CopyMagickString(image->magick_filename,image_info->filename,\n     MaxTextExtent);\n   (void) CopyMagickString(image->magick,image_info->magick,MaxTextExtent);\n   if (image_info->size != (char *) NULL)\n     {\n       (void) ParseAbsoluteGeometry(image_info->size,&image->extract_info);\n       image->columns=image->extract_info.width;\n       image->rows=image->extract_info.height;\n       image->offset=image->extract_info.x;\n       image->extract_info.x=0;\n       image->extract_info.y=0;\n     }\n   if (image_info->extract != (char *) NULL)\n     {\n       RectangleInfo\n         geometry;\n \n       (void) memset(&geometry,0,sizeof(geometry));\n       flags=ParseAbsoluteGeometry(image_info->extract,&geometry);\n       if (((flags & XValue) != 0) || ((flags & YValue) != 0))\n         {\n           image->extract_info=geometry;\n           Swap(image->columns,image->extract_info.width);\n           Swap(image->rows,image->extract_info.height);\n         }\n     }\n   image->compression=image_info->compression;\n   image->quality=image_info->quality;\n   image->endian=image_info->endian;\n   image->interlace=image_info->interlace;\n   image->units=image_info->units;\n   if (image_info->density != (char *) NULL)\n     {\n       GeometryInfo\n         geometry_info;\n \n       flags=ParseGeometry(image_info->density,&geometry_info);\n// bug_start\n      image->x_resolution=geometry_info.rho;\n      image->y_resolution=geometry_info.sigma;\n      if ((flags & SigmaValue) == 0)\n        image->y_resolution=image->x_resolution;\n// bug_end\n     }\n   if (image_info->page != (char *) NULL)\n     {\n       char\n         *geometry;\n \n       image->page=image->extract_info;\n       geometry=GetPageGeometry(image_info->page);\n       (void) ParseAbsoluteGeometry(geometry,&image->page);\n       geometry=DestroyString(geometry);\n     }\n   if (image_info->depth != 0)\n     image->depth=image_info->depth;\n   image->dither=image_info->dither;\n   image->background_color=image_info->background_color;\n   image->border_color=image_info->border_color;\n   image->matte_color=image_info->matte_color;\n   image->transparent_color=image_info->transparent_color;\n   image->ping=image_info->ping;\n   image->progress_monitor=image_info->progress_monitor;\n   image->client_data=image_info->client_data;\n   if (image_info->cache != (void *) NULL)\n     ClonePixelCacheMethods(image->cache,image_info->cache);\n   (void) SyncImageSettings(image_info,image);\n   option=GetImageOption(image_info,\"delay\");\n   if (option != (const char *) NULL)\n     {\n       GeometryInfo\n         geometry_info;\n \n       flags=ParseGeometry(option,&geometry_info);\n       if ((flags & GreaterValue) != 0)\n         {\n           if (image->delay > (size_t) floor(geometry_info.rho+0.5))\n             image->delay=(size_t) floor(geometry_info.rho+0.5);\n         }\n       else\n         if ((flags & LessValue) != 0)\n           {\n             if (image->delay < (size_t) floor(geometry_info.rho+0.5))\n               image->ticks_per_second=(ssize_t) floor(geometry_info.sigma+0.5);\n           }\n         else\n           image->delay=(size_t) floor(geometry_info.rho+0.5);\n       if ((flags & SigmaValue) != 0)\n         image->ticks_per_second=(ssize_t) floor(geometry_info.sigma+0.5);\n     }\n   option=GetImageOption(image_info,\"dispose\");\n   if (option != (const char *) NULL)\n     image->dispose=(DisposeType) ParseCommandOption(MagickDisposeOptions,\n       MagickFalse,option);\n   return(image);\n }\n \n", "target": "// fix_start\n      if ((flags & RhoValue) != 0)\n        image->x_resolution=geometry_info.rho;\n      image->y_resolution=image->x_resolution;\n      if ((flags & SigmaValue) != 0)\n        image->y_resolution=geometry_info.sigma;\n// fix_end\n", "cwe": "CWE-665", "cwe_name": "Improper Initialization", "cve": "CVE-2019-12979", "cve_desc": "ImageMagick 7.0.8-34 has a \"use of uninitialized value\" vulnerability in the SyncImageSettings function in MagickCore/image.c. This is related to AcquireImage in magick/image.c.", "project": "ImageMagick6", "idx": 210612}
{"source": " bfad_im_get_stats(struct Scsi_Host *shost)\n {\n \tstruct bfad_im_port_s *im_port =\n \t\t\t(struct bfad_im_port_s *) shost->hostdata[0];\n \tstruct bfad_s         *bfad = im_port->bfad;\n \tstruct bfad_hal_comp fcomp;\n \tunion bfa_port_stats_u *fcstats;\n \tstruct fc_host_statistics *hstats;\n \tbfa_status_t    rc;\n \tunsigned long   flags;\n \n \tfcstats = kzalloc(sizeof(union bfa_port_stats_u), GFP_KERNEL);\n \tif (fcstats == NULL)\n \t\treturn NULL;\n \n \thstats = &bfad->link_stats;\n \tinit_completion(&fcomp.comp);\n \tspin_lock_irqsave(&bfad->bfad_lock, flags);\n \tmemset(hstats, 0, sizeof(struct fc_host_statistics));\n \trc = bfa_port_get_stats(BFA_FCPORT(&bfad->bfa),\n \t\t\t\tfcstats, bfad_hcb_comp, &fcomp);\n \tspin_unlock_irqrestore(&bfad->bfad_lock, flags);\n// bug_start\n\tif (rc != BFA_STATUS_OK)\n// bug_end\n \t\treturn NULL;\n// bug_start\n// bug_end\n \n \twait_for_completion(&fcomp.comp);\n \n \thstats->seconds_since_last_reset = fcstats->fc.secs_reset;\n \thstats->tx_frames = fcstats->fc.tx_frames;\n \thstats->tx_words  = fcstats->fc.tx_words;\n \thstats->rx_frames = fcstats->fc.rx_frames;\n \thstats->rx_words  = fcstats->fc.rx_words;\n \thstats->lip_count = fcstats->fc.lip_count;\n \thstats->nos_count = fcstats->fc.nos_count;\n \thstats->error_frames = fcstats->fc.error_frames;\n \thstats->dumped_frames = fcstats->fc.dropped_frames;\n \thstats->link_failure_count = fcstats->fc.link_failures;\n \thstats->loss_of_sync_count = fcstats->fc.loss_of_syncs;\n \thstats->loss_of_signal_count = fcstats->fc.loss_of_signals;\n \thstats->prim_seq_protocol_err_count = fcstats->fc.primseq_errs;\n \thstats->invalid_crc_count = fcstats->fc.invalid_crcs;\n \n \tkfree(fcstats);\n \treturn hstats;\n }\n \n", "target": "// fix_start\n\tif (rc != BFA_STATUS_OK) {\n\t\tkfree(fcstats);\n// fix_end\n// fix_start\n\t}\n// fix_end\n", "cwe": "CWE-401", "cwe_name": "Missing Release of Memory after Effective Lifetime", "cve": "CVE-2019-19066", "cve_desc": "A memory leak in the bfad_im_get_stats() function in drivers/scsi/bfa/bfad_attr.c in the Linux kernel through 5.3.11 allows attackers to cause a denial of service (memory consumption) by triggering bfa_port_get_stats() failures, aka CID-0e62395da2bd.", "project": "linux", "idx": 210708}
{"source": " ldns_rr_new_frm_str_internal(ldns_rr **newrr, const char *str,\n \t\t\t\t\t\t\t uint32_t default_ttl, const ldns_rdf *origin,\n \t\t\t\t\t\t\t ldns_rdf **prev, bool question)\n {\n \tldns_rr *new;\n \tconst ldns_rr_descriptor *desc;\n \tldns_rr_type rr_type;\n \tldns_buffer *rr_buf = NULL;\n \tldns_buffer *rd_buf = NULL;\n \tuint32_t ttl_val;\n \tchar  *owner = NULL;\n \tchar  *ttl = NULL;\n \tldns_rr_class clas_val;\n \tchar  *clas = NULL;\n \tchar  *type = NULL;\n \tsize_t type_sz;\n \tchar  *rdata = NULL;\n \tchar  *rd = NULL;\n \tchar  *xtok = NULL;\n \tsize_t rd_strlen;\n \tconst char *delimiters;\n \tssize_t c;\n \tldns_rdf *owner_dname;\n         const char* endptr;\n         int was_unknown_rr_format = 0;\n \tldns_status status = LDNS_STATUS_OK;\n \n \tbool done;\n \tbool quoted;\n \n \tldns_rdf *r = NULL;\n \tuint16_t r_cnt;\n \tuint16_t r_min;\n \tuint16_t r_max;\n         size_t pre_data_pos;\n \n \tuint16_t hex_data_size;\n \tchar *hex_data_str = NULL;\n \tuint16_t cur_hex_data_size;\n \tsize_t hex_pos = 0;\n \tuint8_t *hex_data = NULL;\n \n \tnew = ldns_rr_new();\n \n \towner = LDNS_XMALLOC(char, LDNS_MAX_DOMAINLEN + 1);\n \tttl = LDNS_XMALLOC(char, LDNS_TTL_DATALEN);\n \tclas = LDNS_XMALLOC(char, LDNS_SYNTAX_DATALEN);\n \trdata = LDNS_XMALLOC(char, LDNS_MAX_PACKETLEN + 1);\n \trr_buf = LDNS_MALLOC(ldns_buffer);\n \trd_buf = LDNS_MALLOC(ldns_buffer);\n \trd = LDNS_XMALLOC(char, LDNS_MAX_RDFLEN);\n \txtok = LDNS_XMALLOC(char, LDNS_MAX_RDFLEN);\n \tif (rr_buf) {\n \t\trr_buf->_data = NULL;\n \t}\n \tif (rd_buf) {\n \t\trd_buf->_data = NULL;\n \t}\n \tif (!new || !owner || !ttl || !clas || !rdata ||\n \t\t\t!rr_buf || !rd_buf || !rd || !xtok) {\n \n \t\tgoto memerror;\n \t}\n \n \tldns_buffer_new_frm_data(rr_buf, (char*)str, strlen(str));\n \n \tif (ldns_bget_token(rr_buf, owner, \"\\t\\n \", LDNS_MAX_DOMAINLEN) == -1){\n \n \t\tstatus = LDNS_STATUS_SYNTAX_ERR;\n \t\tgoto error;\n \t}\n \n \tif (ldns_bget_token(rr_buf, ttl, \"\\t\\n \", LDNS_TTL_DATALEN) == -1) {\n \n \t\tstatus = LDNS_STATUS_SYNTAX_TTL_ERR;\n \t\tgoto error;\n \t}\n \tttl_val = (uint32_t) ldns_str2period(ttl, &endptr);\n \n \tif (strlen(ttl) > 0 && !isdigit((int) ttl[0])) {\n \t\tif (default_ttl == 0) {\n \t\t\tttl_val = LDNS_DEFAULT_TTL;\n \t\t} else {\n \t\t\tttl_val = default_ttl;\n \t\t}\n \t\tclas_val = ldns_get_rr_class_by_name(ttl);\n \t\tif (clas_val == 0) {\n \t\t\tclas_val = LDNS_RR_CLASS_IN;\n \t\t\ttype_sz = strlen(ttl) + 1;\n \t\t\ttype = LDNS_XMALLOC(char, type_sz);\n \t\t\tif (!type) {\n \t\t\t\tgoto memerror;\n \t\t\t}\n \t\t\tstrlcpy(type, ttl, type_sz);\n \t\t}\n \t} else {\n \t\tif (-1 == ldns_bget_token(\n \t\t\t\trr_buf, clas, \"\\t\\n \", LDNS_SYNTAX_DATALEN)) {\n \n \t\t\tstatus = LDNS_STATUS_SYNTAX_CLASS_ERR;\n \t\t\tgoto error;\n \t\t}\n \t\tclas_val = ldns_get_rr_class_by_name(clas);\n \t\tif (clas_val == 0) {\n \t\t\tclas_val = LDNS_RR_CLASS_IN;\n \t\t\ttype_sz = strlen(clas) + 1;\n \t\t\ttype = LDNS_XMALLOC(char, type_sz);\n \t\t\tif (!type) {\n \t\t\t\tgoto memerror;\n \t\t\t}\n \t\t\tstrlcpy(type, clas, type_sz);\n \t\t}\n \t}\n \n \tif (!type) {\n \t\ttype = LDNS_XMALLOC(char, LDNS_SYNTAX_DATALEN);\n \t\tif (!type) {\n \t\t\tgoto memerror;\n \t\t}\n \t\tif (-1 == ldns_bget_token(\n \t\t\t\trr_buf, type, \"\\t\\n \", LDNS_SYNTAX_DATALEN)) {\n \n \t\t\tstatus = LDNS_STATUS_SYNTAX_TYPE_ERR;\n \t\t\tgoto error;\n \t\t}\n \t}\n \n \tif (ldns_bget_token(rr_buf, rdata, \"\\0\", LDNS_MAX_PACKETLEN) == -1) {\n \t}\n \tldns_buffer_new_frm_data(rd_buf, rdata, strlen(rdata));\n \n \tif (strlen(owner) <= 1 && strncmp(owner, \"@\", 1) == 0) {\n \t\tif (origin) {\n \t\t\tldns_rr_set_owner(new, ldns_rdf_clone(origin));\n \t\t} else if (prev && *prev) {\n \t\t\tldns_rr_set_owner(new, ldns_rdf_clone(*prev));\n \t\t} else {\n \t\t\tldns_rr_set_owner(new, ldns_dname_new_frm_str(\".\"));\n \t\t}\n \n \t\tif (prev) {\n \t\t\tldns_rdf_deep_free(*prev);\n \t\t\t*prev = ldns_rdf_clone(ldns_rr_owner(new));\n \t\t\tif (!*prev) {\n \t\t\t\tgoto memerror;\n \t\t\t}\n \t\t}\n \t} else {\n \t\tif (strlen(owner) == 0) {\n \t\t\tif (prev && *prev) {\n \t\t\t\tldns_rr_set_owner(new, ldns_rdf_clone(*prev));\n \t\t\t} else if (origin) {\n \t\t\t\tldns_rr_set_owner(new, ldns_rdf_clone(origin));\n \t\t\t} else {\n \t\t\t\tldns_rr_set_owner(new,\n \t\t\t\t\t\tldns_dname_new_frm_str(\".\"));\n \t\t\t}\n \t\t\tif(!ldns_rr_owner(new)) {\n \t\t\t\tgoto memerror;\n \t\t\t}\n \t\t} else {\n \t\t\towner_dname = ldns_dname_new_frm_str(owner);\n \t\t\tif (!owner_dname) {\n \t\t\t\tstatus = LDNS_STATUS_SYNTAX_ERR;\n \t\t\t\tgoto error;\n \t\t\t}\n \n \t\t\tldns_rr_set_owner(new, owner_dname);\n \t\t\tif (!ldns_dname_str_absolute(owner) && origin) {\n \t\t\t\tif(ldns_dname_cat(ldns_rr_owner(new), origin)\n \t\t\t\t\t\t!= LDNS_STATUS_OK) {\n \n \t\t\t\t\tstatus = LDNS_STATUS_SYNTAX_ERR;\n \t\t\t\t\tgoto error;\n \t\t\t\t}\n \t\t\t}\n \t\t\tif (prev) {\n \t\t\t\tldns_rdf_deep_free(*prev);\n \t\t\t\t*prev = ldns_rdf_clone(ldns_rr_owner(new));\n \t\t\t\tif (!*prev) {\n \t\t\t\t\tgoto error;\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \t}\n \tLDNS_FREE(owner);\n \n \tldns_rr_set_question(new, question);\n \n \tldns_rr_set_ttl(new, ttl_val);\n \tLDNS_FREE(ttl);\n \n \tldns_rr_set_class(new, clas_val);\n \tLDNS_FREE(clas);\n \n \trr_type = ldns_get_rr_type_by_name(type);\n \tLDNS_FREE(type);\n \n \tdesc = ldns_rr_descript((uint16_t)rr_type);\n \tldns_rr_set_type(new, rr_type);\n \tif (desc) {\n \t\tr_max = ldns_rr_descriptor_maximum(desc);\n \t\tr_min = ldns_rr_descriptor_minimum(desc);\n \t} else {\n \t\tr_min = 0;\n \t\tr_max = 1;\n \t}\n \n \tfor (done = false, r_cnt = 0; !done && r_cnt < r_max; r_cnt++) {\n \t\tquoted = false;\n \n \t\tswitch (ldns_rr_descriptor_field_type(desc, r_cnt)) {\n \t\tcase LDNS_RDF_TYPE_B64        :\n \t\tcase LDNS_RDF_TYPE_HEX        :\n \t\tcase LDNS_RDF_TYPE_LOC        :\n \t\tcase LDNS_RDF_TYPE_WKS        :\n \t\tcase LDNS_RDF_TYPE_IPSECKEY   :\n \t\tcase LDNS_RDF_TYPE_AMTRELAY   :\n \t\tcase LDNS_RDF_TYPE_NSEC       :\tif (r_cnt == r_max - 1) {\n \t\t\t\t\t\t\tdelimiters = \"\\n\";\n \t\t\t\t\t\t\tbreak;\n \t\t\t\t\t\t}\n \t\tdefault                       :\tdelimiters = \"\\n\\t \";\n \t\t}\n \n \t\tif (ldns_rdf_type_maybe_quoted(\n \t\t\t\tldns_rr_descriptor_field_type(\n \t\t\t\tdesc, r_cnt)) &&\n \t\t\t\tldns_buffer_remaining(rd_buf) > 0){\n \n// bug_start\n\t\t\twhile (*(ldns_buffer_current(rd_buf)) == ' ') {\n// bug_end\n \t\t\t\tldns_buffer_skip(rd_buf, 1);\n \t\t\t}\n \n// bug_start\n\t\t\tif (*(ldns_buffer_current(rd_buf)) == '\\\"') {\n// bug_end\n \t\t\t\tdelimiters = \"\\\"\\0\";\n \t\t\t\tldns_buffer_skip(rd_buf, 1);\n \t\t\t\tquoted = true;\n// bug_start\n\t\t\t} else if (ldns_rr_descriptor_field_type(desc, r_cnt)\n// bug_end\n \t\t\t\t\t== LDNS_RDF_TYPE_LONG_STR) {\n \n \t\t\t\tstatus = LDNS_STATUS_SYNTAX_RDATA_ERR;\n \t\t\t\tgoto error;\n \t\t\t}\n \t\t}\n \n \n \t\twhile (ldns_buffer_position(rd_buf) < ldns_buffer_limit(rd_buf)\n \t\t\t\t&& *(ldns_buffer_current(rd_buf)) == ' '\n \t\t\t\t&& !quoted) {\n \n \t\t\tldns_buffer_skip(rd_buf, 1);\n \t\t}\n \n \t\tpre_data_pos = ldns_buffer_position(rd_buf);\n \t\tif (-1 == (c = ldns_bget_token(\n \t\t\t\trd_buf, rd, delimiters, LDNS_MAX_RDFLEN))) {\n \n \t\t\tdone = true;\n \t\t\t(void)done;\n \t\t\tbreak;\n \t\t}\n \t\trd_strlen = strlen(rd);\n \n \t\tif (strncmp(rd, \"\\\\#\", 2) == 0 && !quoted &&\n \t\t\t\t(rd_strlen == 2 || rd[2]==' ')) {\n \n \t\t\twas_unknown_rr_format = 1;\n \t\t\tldns_buffer_set_position(rd_buf, pre_data_pos);\n \t\t\tdelimiters = \"\\n\\t \";\n \t\t\t(void)ldns_bget_token(rd_buf, rd,\n \t\t\t\t\tdelimiters, LDNS_MAX_RDFLEN);\n \t\t\tc = ldns_bget_token(rd_buf, rd,\n \t\t\t\t\tdelimiters, LDNS_MAX_RDFLEN);\n \t\t\tif (c == -1) {\n \t\t\t\tstatus = LDNS_STATUS_SYNTAX_RDATA_ERR;\n \t\t\t\tgoto error;\n \t\t\t}\n \t\t\thex_data_size = (uint16_t) atoi(rd);\n \t\t\thex_data_str = LDNS_XMALLOC(char, 2*hex_data_size + 1);\n \t\t\tif (!hex_data_str) {\n \t\t\t\tgoto memerror;\n \t\t\t}\n \t\t\tcur_hex_data_size = 0;\n \t\t\twhile(cur_hex_data_size < 2 * hex_data_size) {\n \t\t\t\tc = ldns_bget_token(rd_buf, rd,\n \t\t\t\t\t\tdelimiters, LDNS_MAX_RDFLEN);\n \t\t\t\tif (c == -1) {\n \t\t\t\t\tstatus = LDNS_STATUS_SYNTAX_RDATA_ERR;\n \t\t\t\t\tgoto error;\n \t\t\t\t}\n \t\t\t\trd_strlen = strlen(rd);\n \t\t\t\tif ((size_t)cur_hex_data_size + rd_strlen >\n \t\t\t\t    2 * (size_t)hex_data_size) {\n \t\t\t\t\tstatus = LDNS_STATUS_SYNTAX_RDATA_ERR;\n \t\t\t\t\tgoto error;\n \t\t\t\t}\n \t\t\t\tstrlcpy(hex_data_str + cur_hex_data_size, rd,\n \t\t\t\t\t\trd_strlen + 1);\n \n \t\t\t\tcur_hex_data_size += rd_strlen;\n \t\t\t}\n \t\t\thex_data_str[cur_hex_data_size] = '\\0';\n \n \t\t\tif (desc) {\n \t\t\t\thex_pos = 0;\n \t\t\t\thex_data =\n \t\t\t\t\tLDNS_XMALLOC(uint8_t, hex_data_size+2);\n \n \t\t\t\tif (!hex_data) {\n \t\t\t\t\tgoto memerror;\n \t\t\t\t}\n \t\t\t\tldns_write_uint16(hex_data, hex_data_size);\n \t\t\t\tldns_hexstring_to_data(\n \t\t\t\t\t\thex_data + 2, hex_data_str);\n \t\t\t\tstatus = ldns_wire2rdf(new, hex_data,\n \t\t\t\t\t\thex_data_size + 2, &hex_pos);\n \t\t\t\tif (status != LDNS_STATUS_OK) {\n \t\t\t\t\tgoto error;\n \t\t\t\t}\n \t\t\t\tLDNS_FREE(hex_data);\n \t\t\t} else {\n \t\t\t\tr = ldns_rdf_new_frm_str(LDNS_RDF_TYPE_HEX,\n \t\t\t\t\t\thex_data_str);\n \t\t\t\tif (!r) {\n \t\t\t\t\tgoto memerror;\n \t\t\t\t}\n \t\t\t\tldns_rdf_set_type(r, LDNS_RDF_TYPE_UNKNOWN);\n \t\t\t\tif (!ldns_rr_push_rdf(new, r)) {\n \t\t\t\t\tgoto memerror;\n \t\t\t\t}\n \t\t\t}\n \t\t\tLDNS_FREE(hex_data_str);\n \n \t\t} else if(rd_strlen > 0 || quoted) {\n \t\t\tswitch(ldns_rr_descriptor_field_type(desc, r_cnt)) {\n \n \t\t\tcase LDNS_RDF_TYPE_HEX:\n \t\t\tcase LDNS_RDF_TYPE_B64:\n \t\t\t\tif (r_cnt == r_max - 1) {\n \t\t\t\t\tc = ldns_bget_token(rd_buf, xtok,\n \t\t\t\t\t\t\t\"\\n\", LDNS_MAX_RDFLEN);\n \t\t\t\t\tif (c != -1) {\n \t\t\t\t\t\t(void) strncat(rd, xtok,\n \t\t\t\t\t\t\tLDNS_MAX_RDFLEN -\n \t\t\t\t\t\t\tstrlen(rd) - 1);\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\tr = ldns_rdf_new_frm_str(\n \t\t\t\t\t\tldns_rr_descriptor_field_type(\n \t\t\t\t\t\t\tdesc, r_cnt), rd);\n \t\t\t\tbreak;\n \n \t\t\tcase LDNS_RDF_TYPE_HIP:\n \t\t\t\tdo {\n \t\t\t\t\tif (ldns_bget_token(rd_buf,\n \t\t\t\t\t\t\txtok, delimiters,\n \t\t\t\t\t\t\tLDNS_MAX_RDFLEN) == -1)\n \t\t\t\t\t\tbreak;\n \n \t\t\t\t\t(void) strncat(rd, \" \",\n \t\t\t\t\t\t\tLDNS_MAX_RDFLEN -\n \t\t\t\t\t\t\tstrlen(rd) - 1);\n \t\t\t\t\t(void) strncat(rd, xtok,\n \t\t\t\t\t\t\tLDNS_MAX_RDFLEN -\n \t\t\t\t\t\t\tstrlen(rd) - 1);\n \n \t\t\t\t\tif (ldns_bget_token(rd_buf,\n \t\t\t\t\t\t\txtok, delimiters,\n \t\t\t\t\t\t\tLDNS_MAX_RDFLEN) == -1)\n \t\t\t\t\t\tbreak;\n \n \t\t\t\t\t(void) strncat(rd, \" \",\n \t\t\t\t\t\t\tLDNS_MAX_RDFLEN -\n \t\t\t\t\t\t\tstrlen(rd) - 1);\n \t\t\t\t\t(void) strncat(rd, xtok,\n \t\t\t\t\t\t\tLDNS_MAX_RDFLEN -\n \t\t\t\t\t\t\tstrlen(rd) - 1);\n \t\t\t\t} while (false);\n \n \t\t\t\tr = ldns_rdf_new_frm_str(\n \t\t\t\t\t\tldns_rr_descriptor_field_type(\n \t\t\t\t\t\t\tdesc, r_cnt), rd);\n \t\t\t\tbreak;\n \n \t\t\tcase LDNS_RDF_TYPE_DNAME:\n \t\t\t\tr = ldns_rdf_new_frm_str(\n \t\t\t\t\t\tldns_rr_descriptor_field_type(\n \t\t\t\t\t\t\tdesc, r_cnt), rd);\n \n \t\t\t\tif (r && ldns_rdf_size(r) > 1 &&\n \t\t\t\t\t\tldns_rdf_data(r)[0] == 1 &&\n \t\t\t\t\t\tldns_rdf_data(r)[1] == '@') {\n \n \t\t\t\t\tldns_rdf_deep_free(r);\n \n \t\t\t\t\tr = origin ? ldns_rdf_clone(origin)\n \n \t\t\t\t\t  : ( rr_type == LDNS_RR_TYPE_SOA ?\n \n \t\t\t\t\t      ldns_rdf_clone(\n \t\t\t\t\t\t      ldns_rr_owner(new))\n \n \t\t\t\t\t    : ldns_rdf_new_frm_str(\n \t\t\t\t\t\t    LDNS_RDF_TYPE_DNAME, \".\")\n \t\t\t\t\t    );\n \n \t\t\t\t} else if (r && rd_strlen >= 1 && origin &&\n \t\t\t\t\t\t!ldns_dname_str_absolute(rd)) {\n \n \t\t\t\t\tstatus = ldns_dname_cat(r, origin);\n \t\t\t\t\tif (status != LDNS_STATUS_OK) {\n \t\t\t\t\t\tgoto error;\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\tbreak;\n \t\t\tdefault:\n \t\t\t\tr = ldns_rdf_new_frm_str(\n \t\t\t\t\t\tldns_rr_descriptor_field_type(\n \t\t\t\t\t\t\tdesc, r_cnt), rd);\n \t\t\t\tbreak;\n \t\t\t}\n \t\t\tif (!r) {\n \t\t\t\tstatus = LDNS_STATUS_SYNTAX_RDATA_ERR;\n \t\t\t\tgoto error;\n \t\t\t}\n \t\t\tldns_rr_push_rdf(new, r);\n \t\t}\n \t\tif (quoted) {\n \t\t\tif (ldns_buffer_available(rd_buf, 1)) {\n \t\t\t\tldns_buffer_skip(rd_buf, 1);\n \t\t\t} else {\n \t\t\t\tdone = true;\n \t\t\t}\n \t\t}\n \n \t}\n \tLDNS_FREE(rd);\n \tLDNS_FREE(xtok);\n \tldns_buffer_free(rr_buf);\n \tLDNS_FREE(rdata);\n \tif (ldns_buffer_remaining(rd_buf) > 0) {\n \t\tldns_buffer_free(rd_buf);\n \t\tldns_rr_free(new);\n \t\treturn LDNS_STATUS_SYNTAX_SUPERFLUOUS_TEXT_ERR;\n \t}\n \tldns_buffer_free(rd_buf);\n \n \tif (!question && desc && !was_unknown_rr_format &&\n \t\t\tldns_rr_rd_count(new) < r_min) {\n \n \t\tldns_rr_free(new);\n \t\treturn LDNS_STATUS_SYNTAX_MISSING_VALUE_ERR;\n \t}\n \n \tif (newrr) {\n \t\t*newrr = new;\n \t} else {\n \t\tldns_rr_free(new);\n \t}\n \treturn LDNS_STATUS_OK;\n \n memerror:\n \tstatus = LDNS_STATUS_MEM_ERR;\n error:\n \tif (rd_buf && rd_buf->_data) {\n \t\tldns_buffer_free(rd_buf);\n \t} else {\n \t\tLDNS_FREE(rd_buf);\n \t}\n \tif (rr_buf && rr_buf->_data) {\n \t\tldns_buffer_free(rr_buf);\n \t} else {\n \t\tLDNS_FREE(rr_buf);\n \t}\n \tLDNS_FREE(type);\n \tLDNS_FREE(owner);\n \tLDNS_FREE(ttl);\n \tLDNS_FREE(clas);\n \tLDNS_FREE(hex_data);\n \tLDNS_FREE(hex_data_str);\n \tLDNS_FREE(xtok);\n \tLDNS_FREE(rd);\n \tLDNS_FREE(rdata);\n \tldns_rr_free(new);\n \treturn status;\n }\n \n", "target": "// fix_start\n\t\t\twhile (sldns_buffer_remaining(strbuf) > 0 &&\n\t\t\t\t*(ldns_buffer_current(rd_buf)) == ' ') {\n// fix_end\n// fix_start\n\t\t\tif (sldns_buffer_remaining(strbuf) > 0 &&\n\t\t\t\t*(ldns_buffer_current(rd_buf)) == '\\\"') {\n// fix_end\n// fix_start\n\t\t\t}\n\t\t\tif (!quoted && ldns_rr_descriptor_field_type(desc, r_cnt)\n// fix_end\n", "cwe": "CWE-125", "cwe_name": "Out-of-bounds Read", "cve": "CVE-2020-19860", "cve_desc": "When ldns version 1.7.1 verifies a zone file, the ldns_rr_new_frm_str_internal function has a heap out of bounds read vulnerability. An attacker can leak information on the heap by constructing a zone file payload.", "project": "ldns", "idx": 210738}
{"source": " static int multiSelect(\n   Parse *pParse,\n   Select *p,\n   SelectDest *pDest\n ){\n   int rc = SQLITE_OK;\n   Select *pPrior;\n   Vdbe *v;\n   SelectDest dest;\n   Select *pDelete = 0;\n   sqlite3 *db;\n \n   assert( p && p->pPrior );\n   assert( (p->selFlags & SF_Recursive)==0 || p->op==TK_ALL || p->op==TK_UNION );\n   assert( p->selFlags & SF_Compound );\n   db = pParse->db;\n   pPrior = p->pPrior;\n   dest = *pDest;\n   if( pPrior->pOrderBy || pPrior->pLimit ){\n     sqlite3ErrorMsg(pParse,\"%s clause should come after %s not before\",\n       pPrior->pOrderBy!=0 ? \"ORDER BY\" : \"LIMIT\", selectOpName(p->op));\n     rc = 1;\n     goto multi_select_end;\n   }\n \n   v = sqlite3GetVdbe(pParse);\n   assert( v!=0 );\n \n   if( dest.eDest==SRT_EphemTab ){\n     assert( p->pEList );\n     sqlite3VdbeAddOp2(v, OP_OpenEphemeral, dest.iSDParm, p->pEList->nExpr);\n     dest.eDest = SRT_Table;\n   }\n \n   if( p->selFlags & SF_MultiValue ){\n     rc = multiSelectValues(pParse, p, &dest);\n     if( rc>=0 ) goto multi_select_end;\n     rc = SQLITE_OK;\n   }\n \n   assert( p->pEList && pPrior->pEList );\n   assert( p->pEList->nExpr==pPrior->pEList->nExpr );\n \n #ifndef SQLITE_OMIT_CTE\n   if( p->selFlags & SF_Recursive ){\n     generateWithRecursiveQuery(pParse, p, &dest);\n   }else\n #endif\n \n   if( p->pOrderBy ){\n     return multiSelectOrderBy(pParse, p, pDest);\n   }else{\n \n #ifndef SQLITE_OMIT_EXPLAIN\n     if( pPrior->pPrior==0 ){\n       ExplainQueryPlan((pParse, 1, \"COMPOUND QUERY\"));\n       ExplainQueryPlan((pParse, 1, \"LEFT-MOST SUBQUERY\"));\n     }\n #endif\n \n     switch( p->op ){\n       case TK_ALL: {\n         int addr = 0;\n         int nLimit;\n         assert( !pPrior->pLimit );\n         pPrior->iLimit = p->iLimit;\n         pPrior->iOffset = p->iOffset;\n         pPrior->pLimit = p->pLimit;\n         rc = sqlite3Select(pParse, pPrior, &dest);\n         p->pLimit = 0;\n         if( rc ){\n           goto multi_select_end;\n         }\n         p->pPrior = 0;\n         p->iLimit = pPrior->iLimit;\n         p->iOffset = pPrior->iOffset;\n         if( p->iLimit ){\n           addr = sqlite3VdbeAddOp1(v, OP_IfNot, p->iLimit); VdbeCoverage(v);\n           VdbeComment((v, \"Jump ahead if LIMIT reached\"));\n           if( p->iOffset ){\n             sqlite3VdbeAddOp3(v, OP_OffsetLimit,\n                               p->iLimit, p->iOffset+1, p->iOffset);\n           }\n         }\n         ExplainQueryPlan((pParse, 1, \"UNION ALL\"));\n         rc = sqlite3Select(pParse, p, &dest);\n         testcase( rc!=SQLITE_OK );\n         pDelete = p->pPrior;\n         p->pPrior = pPrior;\n         p->nSelectRow = sqlite3LogEstAdd(p->nSelectRow, pPrior->nSelectRow);\n         if( pPrior->pLimit\n          && sqlite3ExprIsInteger(pPrior->pLimit->pLeft, &nLimit)\n          && nLimit>0 && p->nSelectRow > sqlite3LogEst((u64)nLimit)\n         ){\n           p->nSelectRow = sqlite3LogEst((u64)nLimit);\n         }\n         if( addr ){\n           sqlite3VdbeJumpHere(v, addr);\n         }\n         break;\n       }\n       case TK_EXCEPT:\n       case TK_UNION: {\n         int unionTab;\n         u8 op = 0;\n         int priorOp;\n         Expr *pLimit;\n         int addr;\n         SelectDest uniondest;\n \n         testcase( p->op==TK_EXCEPT );\n         testcase( p->op==TK_UNION );\n         priorOp = SRT_Union;\n         if( dest.eDest==priorOp ){\n           assert( p->pLimit==0 );\n           unionTab = dest.iSDParm;\n         }else{\n           unionTab = pParse->nTab++;\n           assert( p->pOrderBy==0 );\n           addr = sqlite3VdbeAddOp2(v, OP_OpenEphemeral, unionTab, 0);\n           assert( p->addrOpenEphm[0] == -1 );\n           p->addrOpenEphm[0] = addr;\n           findRightmost(p)->selFlags |= SF_UsesEphemeral;\n           assert( p->pEList );\n         }\n \n         assert( !pPrior->pOrderBy );\n         sqlite3SelectDestInit(&uniondest, priorOp, unionTab);\n         rc = sqlite3Select(pParse, pPrior, &uniondest);\n         if( rc ){\n           goto multi_select_end;\n         }\n \n         if( p->op==TK_EXCEPT ){\n           op = SRT_Except;\n         }else{\n           assert( p->op==TK_UNION );\n           op = SRT_Union;\n         }\n         p->pPrior = 0;\n         pLimit = p->pLimit;\n         p->pLimit = 0;\n         uniondest.eDest = op;\n         ExplainQueryPlan((pParse, 1, \"%s USING TEMP B-TREE\",\n                           selectOpName(p->op)));\n         rc = sqlite3Select(pParse, p, &uniondest);\n         testcase( rc!=SQLITE_OK );\n         sqlite3ExprListDelete(db, p->pOrderBy);\n         pDelete = p->pPrior;\n         p->pPrior = pPrior;\n         p->pOrderBy = 0;\n         if( p->op==TK_UNION ){\n           p->nSelectRow = sqlite3LogEstAdd(p->nSelectRow, pPrior->nSelectRow);\n         }\n         sqlite3ExprDelete(db, p->pLimit);\n         p->pLimit = pLimit;\n         p->iLimit = 0;\n         p->iOffset = 0;\n \n         assert( unionTab==dest.iSDParm || dest.eDest!=priorOp );\n         if( dest.eDest!=priorOp ){\n           int iCont, iBreak, iStart;\n           assert( p->pEList );\n           iBreak = sqlite3VdbeMakeLabel(pParse);\n           iCont = sqlite3VdbeMakeLabel(pParse);\n           computeLimitRegisters(pParse, p, iBreak);\n           sqlite3VdbeAddOp2(v, OP_Rewind, unionTab, iBreak); VdbeCoverage(v);\n           iStart = sqlite3VdbeCurrentAddr(v);\n           selectInnerLoop(pParse, p, unionTab,\n                           0, 0, &dest, iCont, iBreak);\n           sqlite3VdbeResolveLabel(v, iCont);\n           sqlite3VdbeAddOp2(v, OP_Next, unionTab, iStart); VdbeCoverage(v);\n           sqlite3VdbeResolveLabel(v, iBreak);\n           sqlite3VdbeAddOp2(v, OP_Close, unionTab, 0);\n         }\n         break;\n       }\n       default: assert( p->op==TK_INTERSECT ); {\n         int tab1, tab2;\n         int iCont, iBreak, iStart;\n         Expr *pLimit;\n         int addr;\n         SelectDest intersectdest;\n         int r1;\n \n         tab1 = pParse->nTab++;\n         tab2 = pParse->nTab++;\n         assert( p->pOrderBy==0 );\n \n         addr = sqlite3VdbeAddOp2(v, OP_OpenEphemeral, tab1, 0);\n         assert( p->addrOpenEphm[0] == -1 );\n         p->addrOpenEphm[0] = addr;\n         findRightmost(p)->selFlags |= SF_UsesEphemeral;\n         assert( p->pEList );\n \n         sqlite3SelectDestInit(&intersectdest, SRT_Union, tab1);\n         rc = sqlite3Select(pParse, pPrior, &intersectdest);\n         if( rc ){\n           goto multi_select_end;\n         }\n \n         addr = sqlite3VdbeAddOp2(v, OP_OpenEphemeral, tab2, 0);\n         assert( p->addrOpenEphm[1] == -1 );\n         p->addrOpenEphm[1] = addr;\n         p->pPrior = 0;\n         pLimit = p->pLimit;\n         p->pLimit = 0;\n         intersectdest.iSDParm = tab2;\n         ExplainQueryPlan((pParse, 1, \"%s USING TEMP B-TREE\",\n                           selectOpName(p->op)));\n         rc = sqlite3Select(pParse, p, &intersectdest);\n         testcase( rc!=SQLITE_OK );\n         pDelete = p->pPrior;\n         p->pPrior = pPrior;\n         if( p->nSelectRow>pPrior->nSelectRow ){\n           p->nSelectRow = pPrior->nSelectRow;\n         }\n         sqlite3ExprDelete(db, p->pLimit);\n         p->pLimit = pLimit;\n \n         assert( p->pEList );\n         iBreak = sqlite3VdbeMakeLabel(pParse);\n         iCont = sqlite3VdbeMakeLabel(pParse);\n         computeLimitRegisters(pParse, p, iBreak);\n         sqlite3VdbeAddOp2(v, OP_Rewind, tab1, iBreak); VdbeCoverage(v);\n         r1 = sqlite3GetTempReg(pParse);\n         iStart = sqlite3VdbeAddOp2(v, OP_RowData, tab1, r1);\n         sqlite3VdbeAddOp4Int(v, OP_NotFound, tab2, iCont, r1, 0);\n         VdbeCoverage(v);\n         sqlite3ReleaseTempReg(pParse, r1);\n         selectInnerLoop(pParse, p, tab1,\n                         0, 0, &dest, iCont, iBreak);\n         sqlite3VdbeResolveLabel(v, iCont);\n         sqlite3VdbeAddOp2(v, OP_Next, tab1, iStart); VdbeCoverage(v);\n         sqlite3VdbeResolveLabel(v, iBreak);\n         sqlite3VdbeAddOp2(v, OP_Close, tab2, 0);\n         sqlite3VdbeAddOp2(v, OP_Close, tab1, 0);\n         break;\n       }\n     }\n \n   #ifndef SQLITE_OMIT_EXPLAIN\n     if( p->pNext==0 ){\n       ExplainQueryPlanPop(pParse);\n     }\n   #endif\n   }\n// bug_start\n// bug_end\n \n   if( p->selFlags & SF_UsesEphemeral ){\n     int i;\n     KeyInfo *pKeyInfo;\n     Select *pLoop;\n     CollSeq **apColl;\n     int nCol;\n \n     assert( p->pNext==0 );\n     nCol = p->pEList->nExpr;\n     pKeyInfo = sqlite3KeyInfoAlloc(db, nCol, 1);\n     if( !pKeyInfo ){\n       rc = SQLITE_NOMEM_BKPT;\n       goto multi_select_end;\n     }\n     for(i=0, apColl=pKeyInfo->aColl; i<nCol; i++, apColl++){\n       *apColl = multiSelectCollSeq(pParse, p, i);\n       if( 0==*apColl ){\n         *apColl = db->pDfltColl;\n       }\n     }\n \n     for(pLoop=p; pLoop; pLoop=pLoop->pPrior){\n       for(i=0; i<2; i++){\n         int addr = pLoop->addrOpenEphm[i];\n         if( addr<0 ){\n           assert( pLoop->addrOpenEphm[1]<0 );\n           break;\n         }\n         sqlite3VdbeChangeP2(v, addr, nCol);\n         sqlite3VdbeChangeP4(v, addr, (char*)sqlite3KeyInfoRef(pKeyInfo),\n                             P4_KEYINFO);\n         pLoop->addrOpenEphm[i] = -1;\n       }\n     }\n     sqlite3KeyInfoUnref(pKeyInfo);\n   }\n \n multi_select_end:\n   pDest->iSdst = dest.iSdst;\n   pDest->nSdst = dest.nSdst;\n   sqlite3SelectDelete(db, pDelete);\n   return rc;\n }\n \n", "target": "// fix_start\n  if( pParse->nErr ) goto multi_select_end;\n// fix_end\n", "cwe": "CWE-476", "cwe_name": "NULL Pointer Dereference", "cve": "CVE-2019-19926", "cve_desc": "multiSelect in select.c in SQLite 3.30.1 mishandles certain errors during parsing, as demonstrated by errors from sqlite3WindowRewrite() calls. NOTE: this vulnerability exists because of an incomplete fix for CVE-2019-19880.", "project": "sqlite", "idx": 210816}
{"source": " static ssize_t usbip_sockfd_store(struct device *dev, struct device_attribute *attr,\n \t\t\t    const char *buf, size_t count)\n {\n \tstruct stub_device *sdev = dev_get_drvdata(dev);\n \tint sockfd = 0;\n \tstruct socket *socket;\n \tint rv;\n// bug_start\n// bug_end\n \n \tif (!sdev) {\n \t\tdev_err(dev, \"sdev is null\\n\");\n \t\treturn -ENODEV;\n \t}\n \n \trv = sscanf(buf, \"%d\", &sockfd);\n \tif (rv != 1)\n \t\treturn -EINVAL;\n \n \tif (sockfd != -1) {\n \t\tint err;\n \n \t\tdev_info(dev, \"stub up\\n\");\n \n \t\tspin_lock_irq(&sdev->ud.lock);\n \n \t\tif (sdev->ud.status != SDEV_ST_AVAILABLE) {\n \t\t\tdev_err(dev, \"not ready\\n\");\n \t\t\tgoto err;\n \t\t}\n \n \t\tsocket = sockfd_lookup(sockfd, &err);\n \t\tif (!socket) {\n \t\t\tdev_err(dev, \"failed to lookup sock\");\n \t\t\tgoto err;\n \t\t}\n \n \t\tif (socket->type != SOCK_STREAM) {\n \t\t\tdev_err(dev, \"Expecting SOCK_STREAM - found %d\",\n \t\t\t\tsocket->type);\n \t\t\tgoto sock_err;\n \t\t}\n \n// bug_start\n// bug_end\n \t\tsdev->ud.tcp_socket = socket;\n \t\tsdev->ud.sockfd = sockfd;\n// bug_start\n\n// bug_end\n \t\tspin_unlock_irq(&sdev->ud.lock);\n \n// bug_start\n\t\tsdev->ud.tcp_rx = kthread_get_run(stub_rx_loop, &sdev->ud,\n\t\t\t\t\t\t  \"stub_rx\");\n\t\tsdev->ud.tcp_tx = kthread_get_run(stub_tx_loop, &sdev->ud,\n\t\t\t\t\t\t  \"stub_tx\");\n\n\t\tspin_lock_irq(&sdev->ud.lock);\n\t\tsdev->ud.status = SDEV_ST_USED;\n\t\tspin_unlock_irq(&sdev->ud.lock);\n// bug_end\n \n \t} else {\n \t\tdev_info(dev, \"stub down\\n\");\n \n \t\tspin_lock_irq(&sdev->ud.lock);\n \t\tif (sdev->ud.status != SDEV_ST_USED)\n \t\t\tgoto err;\n \n \t\tspin_unlock_irq(&sdev->ud.lock);\n \n \t\tusbip_event_add(&sdev->ud, SDEV_EVENT_DOWN);\n \t}\n \n \treturn count;\n \n sock_err:\n \tsockfd_put(socket);\n err:\n \tspin_unlock_irq(&sdev->ud.lock);\n \treturn -EINVAL;\n }\n \n", "target": "// fix_start\n\tstruct task_struct *tcp_rx = NULL;\n\tstruct task_struct *tcp_tx = NULL;\n// fix_end\n// fix_start\n\t\tspin_unlock_irq(&sdev->ud.lock);\n\t\ttcp_rx = kthread_create(stub_rx_loop, &sdev->ud, \"stub_rx\");\n\t\tif (IS_ERR(tcp_rx)) {\n\t\t\tsockfd_put(socket);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\ttcp_tx = kthread_create(stub_tx_loop, &sdev->ud, \"stub_tx\");\n\t\tif (IS_ERR(tcp_tx)) {\n\t\t\tkthread_stop(tcp_rx);\n\t\t\tsockfd_put(socket);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tget_task_struct(tcp_rx);\n\t\tget_task_struct(tcp_tx);\n\n\t\tspin_lock_irq(&sdev->ud.lock);\n// fix_end\n// fix_start\n\t\tsdev->ud.tcp_rx = tcp_rx;\n\t\tsdev->ud.tcp_tx = tcp_tx;\n\t\tsdev->ud.status = SDEV_ST_USED;\n// fix_end\n// fix_start\n\t\twake_up_process(sdev->ud.tcp_rx);\n\t\twake_up_process(sdev->ud.tcp_tx);\n// fix_end\n", "cwe": "CWE-362", "cwe_name": "Concurrent Execution using Shared Resource with Improper Synchronization ('Race Condition')", "cve": "CVE-2021-29265", "cve_desc": "An issue was discovered in the Linux kernel before 5.11.7. usbip_sockfd_store in drivers/usb/usbip/stub_dev.c allows attackers to cause a denial of service (GPF) because the stub-up sequence has race conditions during an update of the local and shared status, aka CID-9380afd6df70.", "project": "linux", "idx": 210838}
{"source": " static struct socket *get_raw_socket(int fd)\n {\n// bug_start\n\tstruct {\n\t\tstruct sockaddr_ll sa;\n\t\tchar  buf[MAX_ADDR_LEN];\n\t} uaddr;\n// bug_end\n \tint r;\n \tstruct socket *sock = sockfd_lookup(fd, &r);\n \n \tif (!sock)\n \t\treturn ERR_PTR(-ENOTSOCK);\n \n \tif (sock->sk->sk_type != SOCK_RAW) {\n \t\tr = -ESOCKTNOSUPPORT;\n \t\tgoto err;\n \t}\n \n// bug_start\n\tr = sock->ops->getname(sock, (struct sockaddr *)&uaddr.sa, 0);\n\tif (r < 0)\n\t\tgoto err;\n\n\tif (uaddr.sa.sll_family != AF_PACKET) {\n// bug_end\n \t\tr = -EPFNOSUPPORT;\n \t\tgoto err;\n \t}\n \treturn sock;\n err:\n \tsockfd_put(sock);\n \treturn ERR_PTR(r);\n }\n \n", "target": "// fix_start\n// fix_end\n// fix_start\n\tif (sock->sk->sk_family != AF_PACKET) {\n// fix_end\n", "cwe": "CWE-787", "cwe_name": "Out-of-bounds Write", "cve": "CVE-2020-10942", "cve_desc": "In the Linux kernel before 5.5.8, get_raw_socket in drivers/vhost/net.c lacks validation of an sk_family field, which might allow attackers to trigger kernel stack corruption via crafted system calls.", "project": "linux", "idx": 210873}
{"source": " mwifiex_cmd_802_11_ad_hoc_start(struct mwifiex_private *priv,\n \t\t\t\tstruct host_cmd_ds_command *cmd,\n \t\t\t\tstruct cfg80211_ssid *req_ssid)\n {\n \tint rsn_ie_len = 0;\n \tstruct mwifiex_adapter *adapter = priv->adapter;\n \tstruct host_cmd_ds_802_11_ad_hoc_start *adhoc_start =\n \t\t&cmd->params.adhoc_start;\n \tstruct mwifiex_bssdescriptor *bss_desc;\n \tu32 cmd_append_size = 0;\n \tu32 i;\n \tu16 tmp_cap;\n \tstruct mwifiex_ie_types_chan_list_param_set *chan_tlv;\n \tu8 radio_type;\n \n \tstruct mwifiex_ie_types_htcap *ht_cap;\n \tstruct mwifiex_ie_types_htinfo *ht_info;\n \tu8 *pos = (u8 *) adhoc_start +\n \t\t\tsizeof(struct host_cmd_ds_802_11_ad_hoc_start);\n \n \tif (!adapter)\n \t\treturn -1;\n \n \tcmd->command = cpu_to_le16(HostCmd_CMD_802_11_AD_HOC_START);\n \n \tbss_desc = &priv->curr_bss_params.bss_descriptor;\n \tpriv->attempted_bss_desc = bss_desc;\n \n \n \tmemset(adhoc_start->ssid, 0, IEEE80211_MAX_SSID_LEN);\n \n// bug_start\n// bug_end\n \tmemcpy(adhoc_start->ssid, req_ssid->ssid, req_ssid->ssid_len);\n \n \tmwifiex_dbg(adapter, INFO, \"info: ADHOC_S_CMD: SSID = %s\\n\",\n \t\t    adhoc_start->ssid);\n \n \tmemset(bss_desc->ssid.ssid, 0, IEEE80211_MAX_SSID_LEN);\n \tmemcpy(bss_desc->ssid.ssid, req_ssid->ssid, req_ssid->ssid_len);\n \n \tbss_desc->ssid.ssid_len = req_ssid->ssid_len;\n \n \tadhoc_start->bss_mode = HostCmd_BSS_MODE_IBSS;\n \tbss_desc->bss_mode = NL80211_IFTYPE_ADHOC;\n \tadhoc_start->beacon_period = cpu_to_le16(priv->beacon_period);\n \tbss_desc->beacon_period = priv->beacon_period;\n \n #define DS_PARA_IE_ID   3\n #define DS_PARA_IE_LEN  1\n \n \tadhoc_start->phy_param_set.ds_param_set.element_id = DS_PARA_IE_ID;\n \tadhoc_start->phy_param_set.ds_param_set.len = DS_PARA_IE_LEN;\n \n \tif (!mwifiex_get_cfp(priv, adapter->adhoc_start_band,\n \t\t\t     (u16) priv->adhoc_channel, 0)) {\n \t\tstruct mwifiex_chan_freq_power *cfp;\n \t\tcfp = mwifiex_get_cfp(priv, adapter->adhoc_start_band,\n \t\t\t\t      FIRST_VALID_CHANNEL, 0);\n \t\tif (cfp)\n \t\t\tpriv->adhoc_channel = (u8) cfp->channel;\n \t}\n \n \tif (!priv->adhoc_channel) {\n \t\tmwifiex_dbg(adapter, ERROR,\n \t\t\t    \"ADHOC_S_CMD: adhoc_channel cannot be 0\\n\");\n \t\treturn -1;\n \t}\n \n \tmwifiex_dbg(adapter, INFO,\n \t\t    \"info: ADHOC_S_CMD: creating ADHOC on channel %d\\n\",\n \t\t    priv->adhoc_channel);\n \n \tpriv->curr_bss_params.bss_descriptor.channel = priv->adhoc_channel;\n \tpriv->curr_bss_params.band = adapter->adhoc_start_band;\n \n \tbss_desc->channel = priv->adhoc_channel;\n \tadhoc_start->phy_param_set.ds_param_set.current_chan =\n \t\tpriv->adhoc_channel;\n \n \tmemcpy(&bss_desc->phy_param_set, &adhoc_start->phy_param_set,\n \t       sizeof(union ieee_types_phy_param_set));\n \n #define IBSS_PARA_IE_ID   6\n #define IBSS_PARA_IE_LEN  2\n \n \tadhoc_start->ss_param_set.ibss_param_set.element_id = IBSS_PARA_IE_ID;\n \tadhoc_start->ss_param_set.ibss_param_set.len = IBSS_PARA_IE_LEN;\n \tadhoc_start->ss_param_set.ibss_param_set.atim_window\n \t\t\t\t\t= cpu_to_le16(priv->atim_window);\n \tmemcpy(&bss_desc->ss_param_set, &adhoc_start->ss_param_set,\n \t       sizeof(union ieee_types_ss_param_set));\n \n \tbss_desc->cap_info_bitmap |= WLAN_CAPABILITY_IBSS;\n \ttmp_cap = WLAN_CAPABILITY_IBSS;\n \n \tif (priv->sec_info.encryption_mode) {\n \t\tmwifiex_dbg(adapter, INFO,\n \t\t\t    \"info: ADHOC_S_CMD: wep_status set privacy to WEP\\n\");\n \t\tbss_desc->privacy = MWIFIEX_802_11_PRIV_FILTER_8021X_WEP;\n \t\ttmp_cap |= WLAN_CAPABILITY_PRIVACY;\n \t} else {\n \t\tmwifiex_dbg(adapter, INFO,\n \t\t\t    \"info: ADHOC_S_CMD: wep_status NOT set,\\t\"\n \t\t\t    \"setting privacy to ACCEPT ALL\\n\");\n \t\tbss_desc->privacy = MWIFIEX_802_11_PRIV_FILTER_ACCEPT_ALL;\n \t}\n \n \tmemset(adhoc_start->data_rate, 0, sizeof(adhoc_start->data_rate));\n \tmwifiex_get_active_data_rates(priv, adhoc_start->data_rate);\n \tif ((adapter->adhoc_start_band & BAND_G) &&\n \t    (priv->curr_pkt_filter & HostCmd_ACT_MAC_ADHOC_G_PROTECTION_ON)) {\n \t\tif (mwifiex_send_cmd(priv, HostCmd_CMD_MAC_CONTROL,\n \t\t\t\t     HostCmd_ACT_GEN_SET, 0,\n \t\t\t\t     &priv->curr_pkt_filter, false)) {\n \t\t\tmwifiex_dbg(adapter, ERROR,\n \t\t\t\t    \"ADHOC_S_CMD: G Protection config failed\\n\");\n \t\t\treturn -1;\n \t\t}\n \t}\n \tfor (i = 0; i < sizeof(adhoc_start->data_rate); i++)\n \t\tif (!adhoc_start->data_rate[i])\n \t\t\tbreak;\n \n \tpriv->curr_bss_params.num_of_rates = i;\n \n \tmemcpy(&priv->curr_bss_params.data_rates,\n \t       &adhoc_start->data_rate, priv->curr_bss_params.num_of_rates);\n \n \tmwifiex_dbg(adapter, INFO, \"info: ADHOC_S_CMD: rates=%4ph\\n\",\n \t\t    adhoc_start->data_rate);\n \n \tmwifiex_dbg(adapter, INFO, \"info: ADHOC_S_CMD: AD-HOC Start command is ready\\n\");\n \n \tif (IS_SUPPORT_MULTI_BANDS(adapter)) {\n \t\tchan_tlv = (struct mwifiex_ie_types_chan_list_param_set *) pos;\n \t\tchan_tlv->header.type = cpu_to_le16(TLV_TYPE_CHANLIST);\n \t\tchan_tlv->header.len =\n \t\t\tcpu_to_le16(sizeof(struct mwifiex_chan_scan_param_set));\n \n \t\tmemset(chan_tlv->chan_scan_param, 0x00,\n \t\t       sizeof(struct mwifiex_chan_scan_param_set));\n \t\tchan_tlv->chan_scan_param[0].chan_number =\n \t\t\t(u8) priv->curr_bss_params.bss_descriptor.channel;\n \n \t\tmwifiex_dbg(adapter, INFO, \"info: ADHOC_S_CMD: TLV Chan = %d\\n\",\n \t\t\t    chan_tlv->chan_scan_param[0].chan_number);\n \n \t\tchan_tlv->chan_scan_param[0].radio_type\n \t\t       = mwifiex_band_to_radio_type(priv->curr_bss_params.band);\n \t\tif (adapter->adhoc_start_band & BAND_GN ||\n \t\t    adapter->adhoc_start_band & BAND_AN) {\n \t\t\tif (adapter->sec_chan_offset ==\n \t\t\t\t\t    IEEE80211_HT_PARAM_CHA_SEC_ABOVE)\n \t\t\t\tchan_tlv->chan_scan_param[0].radio_type |=\n \t\t\t\t\t(IEEE80211_HT_PARAM_CHA_SEC_ABOVE << 4);\n \t\t\telse if (adapter->sec_chan_offset ==\n \t\t\t\t\t    IEEE80211_HT_PARAM_CHA_SEC_BELOW)\n \t\t\t\tchan_tlv->chan_scan_param[0].radio_type |=\n \t\t\t\t\t(IEEE80211_HT_PARAM_CHA_SEC_BELOW << 4);\n \t\t}\n \t\tmwifiex_dbg(adapter, INFO, \"info: ADHOC_S_CMD: TLV Band = %d\\n\",\n \t\t\t    chan_tlv->chan_scan_param[0].radio_type);\n \t\tpos += sizeof(chan_tlv->header) +\n \t\t\tsizeof(struct mwifiex_chan_scan_param_set);\n \t\tcmd_append_size +=\n \t\t\tsizeof(chan_tlv->header) +\n \t\t\tsizeof(struct mwifiex_chan_scan_param_set);\n \t}\n \n \tcmd_append_size += mwifiex_cmd_append_vsie_tlv(priv,\n \t\t\t\tMWIFIEX_VSIE_MASK_ADHOC, &pos);\n \n \tif (priv->sec_info.wpa_enabled) {\n \t\trsn_ie_len = mwifiex_append_rsn_ie_wpa_wpa2(priv, &pos);\n \t\tif (rsn_ie_len == -1)\n \t\t\treturn -1;\n \t\tcmd_append_size += rsn_ie_len;\n \t}\n \n \tif (adapter->adhoc_11n_enabled) {\n \t\tht_cap = (struct mwifiex_ie_types_htcap *) pos;\n \t\tmemset(ht_cap, 0, sizeof(struct mwifiex_ie_types_htcap));\n \t\tht_cap->header.type = cpu_to_le16(WLAN_EID_HT_CAPABILITY);\n \t\tht_cap->header.len =\n \t\t       cpu_to_le16(sizeof(struct ieee80211_ht_cap));\n \t\tradio_type = mwifiex_band_to_radio_type(\n \t\t\t\t\tpriv->adapter->config_bands);\n \t\tmwifiex_fill_cap_info(priv, radio_type, &ht_cap->ht_cap);\n \n \t\tif (adapter->sec_chan_offset ==\n \t\t\t\t\tIEEE80211_HT_PARAM_CHA_SEC_NONE) {\n \t\t\tu16 tmp_ht_cap;\n \n \t\t\ttmp_ht_cap = le16_to_cpu(ht_cap->ht_cap.cap_info);\n \t\t\ttmp_ht_cap &= ~IEEE80211_HT_CAP_SUP_WIDTH_20_40;\n \t\t\ttmp_ht_cap &= ~IEEE80211_HT_CAP_SGI_40;\n \t\t\tht_cap->ht_cap.cap_info = cpu_to_le16(tmp_ht_cap);\n \t\t}\n \n \t\tpos += sizeof(struct mwifiex_ie_types_htcap);\n \t\tcmd_append_size += sizeof(struct mwifiex_ie_types_htcap);\n \n \t\tht_info = (struct mwifiex_ie_types_htinfo *) pos;\n \t\tmemset(ht_info, 0, sizeof(struct mwifiex_ie_types_htinfo));\n \t\tht_info->header.type = cpu_to_le16(WLAN_EID_HT_OPERATION);\n \t\tht_info->header.len =\n \t\t\tcpu_to_le16(sizeof(struct ieee80211_ht_operation));\n \n \t\tht_info->ht_oper.primary_chan =\n \t\t\t(u8) priv->curr_bss_params.bss_descriptor.channel;\n \t\tif (adapter->sec_chan_offset) {\n \t\t\tht_info->ht_oper.ht_param = adapter->sec_chan_offset;\n \t\t\tht_info->ht_oper.ht_param |=\n \t\t\t\t\tIEEE80211_HT_PARAM_CHAN_WIDTH_ANY;\n \t\t}\n \t\tht_info->ht_oper.operation_mode =\n \t\t     cpu_to_le16(IEEE80211_HT_OP_MODE_NON_GF_STA_PRSNT);\n \t\tht_info->ht_oper.basic_set[0] = 0xff;\n \t\tpos += sizeof(struct mwifiex_ie_types_htinfo);\n \t\tcmd_append_size +=\n \t\t\t\tsizeof(struct mwifiex_ie_types_htinfo);\n \t}\n \n \tcmd->size =\n \t\tcpu_to_le16((u16)(sizeof(struct host_cmd_ds_802_11_ad_hoc_start)\n \t\t\t\t  + S_DS_GEN + cmd_append_size));\n \n \tif (adapter->adhoc_start_band == BAND_B)\n \t\ttmp_cap &= ~WLAN_CAPABILITY_SHORT_SLOT_TIME;\n \telse\n \t\ttmp_cap |= WLAN_CAPABILITY_SHORT_SLOT_TIME;\n \n \tadhoc_start->cap_info_bitmap = cpu_to_le16(tmp_cap);\n \n \treturn 0;\n }\n \n", "target": "// fix_start\n\tif (req_ssid->ssid_len > IEEE80211_MAX_SSID_LEN)\n\t\treq_ssid->ssid_len = IEEE80211_MAX_SSID_LEN;\n// fix_end\n", "cwe": "CWE-787", "cwe_name": "Out-of-bounds Write", "cve": "CVE-2020-36158", "cve_desc": "mwifiex_cmd_802_11_ad_hoc_start in drivers/net/wireless/marvell/mwifiex/join.c in the Linux kernel through 5.10.4 might allow remote attackers to execute arbitrary code via a long SSID value, aka CID-5c455c5ab332.", "project": "linux", "idx": 211030}
{"source": " gst_matroska_demux_add_wvpk_header (GstElement * element,\n     GstMatroskaTrackContext * stream, GstBuffer ** buf)\n {\n   GstMatroskaTrackAudioContext *audiocontext =\n       (GstMatroskaTrackAudioContext *) stream;\n   GstBuffer *newbuf = NULL;\n   GstMapInfo map, outmap;\n   guint8 *buf_data, *data;\n   Wavpack4Header wvh;\n \n   wvh.ck_id[0] = 'w';\n   wvh.ck_id[1] = 'v';\n   wvh.ck_id[2] = 'p';\n   wvh.ck_id[3] = 'k';\n \n   wvh.version = GST_READ_UINT16_LE (stream->codec_priv);\n   wvh.track_no = 0;\n   wvh.index_no = 0;\n   wvh.total_samples = -1;\n   wvh.block_index = audiocontext->wvpk_block_index;\n \n   if (audiocontext->channels <= 2) {\n     guint32 block_samples, tmp;\n     gsize size = gst_buffer_get_size (*buf);\n \n// bug_start\n// bug_end\n     gst_buffer_extract (*buf, 0, &tmp, sizeof (guint32));\n     block_samples = GUINT32_FROM_LE (tmp);\n \n// bug_start\n    wvh.ck_size = size + sizeof (Wavpack4Header) - 20;\n// bug_end\n \n// bug_start\n    newbuf = gst_buffer_new_allocate (NULL, sizeof (Wavpack4Header) - 12, NULL);\n// bug_end\n \n     gst_buffer_map (newbuf, &outmap, GST_MAP_WRITE);\n     data = outmap.data;\n     data[0] = 'w';\n     data[1] = 'v';\n     data[2] = 'p';\n     data[3] = 'k';\n     GST_WRITE_UINT32_LE (data + 4, wvh.ck_size);\n     GST_WRITE_UINT16_LE (data + 8, wvh.version);\n     GST_WRITE_UINT8 (data + 10, wvh.track_no);\n     GST_WRITE_UINT8 (data + 11, wvh.index_no);\n     GST_WRITE_UINT32_LE (data + 12, wvh.total_samples);\n     GST_WRITE_UINT32_LE (data + 16, wvh.block_index);\n     gst_buffer_unmap (newbuf, &outmap);\n \n     gst_buffer_copy_into (newbuf, *buf, GST_BUFFER_COPY_TIMESTAMPS |\n         GST_BUFFER_COPY_FLAGS | GST_BUFFER_COPY_MEMORY, 0, size);\n \n     gst_buffer_unref (*buf);\n     *buf = newbuf;\n     audiocontext->wvpk_block_index += block_samples;\n   } else {\n     guint8 *outdata = NULL;\n// bug_start\n    guint outpos = 0;\n    gsize buf_size, size, out_size = 0;\n// bug_end\n     guint32 block_samples, flags, crc, blocksize;\n// bug_start\n// bug_end\n \n     gst_buffer_map (*buf, &map, GST_MAP_READ);\n     buf_data = map.data;\n     buf_size = map.size;\n \n     if (buf_size < 4) {\n       GST_ERROR_OBJECT (element, \"Too small wavpack buffer\");\n       gst_buffer_unmap (*buf, &map);\n// bug_start\n// bug_end\n       return GST_FLOW_ERROR;\n     }\n \n     data = buf_data;\n     size = buf_size;\n \n     block_samples = GST_READ_UINT32_LE (data);\n     data += 4;\n     size -= 4;\n \n     while (size > 12) {\n       flags = GST_READ_UINT32_LE (data);\n       data += 4;\n       size -= 4;\n       crc = GST_READ_UINT32_LE (data);\n       data += 4;\n       size -= 4;\n       blocksize = GST_READ_UINT32_LE (data);\n       data += 4;\n       size -= 4;\n \n// bug_start\n      if (blocksize == 0 || size < blocksize)\n        break;\n\n      g_assert ((newbuf == NULL) == (outdata == NULL));\n\n      if (newbuf == NULL) {\n        out_size = sizeof (Wavpack4Header) + blocksize;\n        newbuf = gst_buffer_new_allocate (NULL, out_size, NULL);\n\n        gst_buffer_copy_into (newbuf, *buf,\n            GST_BUFFER_COPY_TIMESTAMPS | GST_BUFFER_COPY_FLAGS, 0, -1);\n\n        outpos = 0;\n        gst_buffer_map (newbuf, &outmap, GST_MAP_WRITE);\n        outdata = outmap.data;\n      } else {\n        gst_buffer_unmap (newbuf, &outmap);\n        out_size += sizeof (Wavpack4Header) + blocksize;\n        gst_buffer_set_size (newbuf, out_size);\n        gst_buffer_map (newbuf, &outmap, GST_MAP_WRITE);\n        outdata = outmap.data;\n// bug_end\n       }\n \n// bug_start\n      outdata[outpos] = 'w';\n      outdata[outpos + 1] = 'v';\n      outdata[outpos + 2] = 'p';\n      outdata[outpos + 3] = 'k';\n      outpos += 4;\n// bug_end\n \n// bug_start\n      GST_WRITE_UINT32_LE (outdata + outpos,\n          blocksize + sizeof (Wavpack4Header) - 8);\n      GST_WRITE_UINT16_LE (outdata + outpos + 4, wvh.version);\n      GST_WRITE_UINT8 (outdata + outpos + 6, wvh.track_no);\n      GST_WRITE_UINT8 (outdata + outpos + 7, wvh.index_no);\n      GST_WRITE_UINT32_LE (outdata + outpos + 8, wvh.total_samples);\n      GST_WRITE_UINT32_LE (outdata + outpos + 12, wvh.block_index);\n      GST_WRITE_UINT32_LE (outdata + outpos + 16, block_samples);\n      GST_WRITE_UINT32_LE (outdata + outpos + 20, flags);\n      GST_WRITE_UINT32_LE (outdata + outpos + 24, crc);\n      outpos += 28;\n// bug_end\n \n// bug_start\n      memmove (outdata + outpos, data, blocksize);\n      outpos += blocksize;\n// bug_end\n       data += blocksize;\n       size -= blocksize;\n     }\n     gst_buffer_unmap (*buf, &map);\n// bug_start\n// bug_end\n     gst_buffer_unref (*buf);\n// bug_start\n// bug_end\n \n// bug_start\n    if (newbuf)\n      gst_buffer_unmap (newbuf, &outmap);\n\n    *buf = newbuf;\n// bug_end\n     audiocontext->wvpk_block_index += block_samples;\n   }\n \n   return GST_FLOW_OK;\n }\n \n", "target": "// fix_start\n    if (size < 4) {\n      GST_ERROR_OBJECT (element, \"Too small wavpack buffer\");\n      gst_buffer_unmap (*buf, &map);\n      return GST_FLOW_ERROR;\n    }\n\n// fix_end\n// fix_start\n    wvh.ck_size = size + WAVPACK4_HEADER_SIZE - 20;\n// fix_end\n// fix_start\n    newbuf = gst_buffer_new_allocate (NULL, WAVPACK4_HEADER_SIZE - 12, NULL);\n// fix_end\n// fix_start\n    gsize buf_size, size;\n// fix_end\n// fix_start\n    GstAdapter *adapter;\n\n    adapter = gst_adapter_new ();\n// fix_end\n// fix_start\n      g_object_unref (adapter);\n// fix_end\n// fix_start\n      if (blocksize == 0 || size < blocksize) {\n        GST_ERROR_OBJECT (element, \"Too small wavpack buffer\");\n        gst_buffer_unmap (*buf, &map);\n        g_object_unref (adapter);\n        return GST_FLOW_ERROR;\n// fix_end\n// fix_start\n      g_assert (newbuf == NULL);\n// fix_end\n// fix_start\n      newbuf =\n          gst_buffer_new_allocate (NULL, WAVPACK4_HEADER_SIZE + blocksize,\n          NULL);\n      gst_buffer_map (newbuf, &outmap, GST_MAP_WRITE);\n      outdata = outmap.data;\n// fix_end\n// fix_start\n      outdata[0] = 'w';\n      outdata[1] = 'v';\n      outdata[2] = 'p';\n      outdata[3] = 'k';\n      outdata += 4;\n\n      GST_WRITE_UINT32_LE (outdata, blocksize + WAVPACK4_HEADER_SIZE - 8);\n      GST_WRITE_UINT16_LE (outdata + 4, wvh.version);\n      GST_WRITE_UINT8 (outdata + 6, wvh.track_no);\n      GST_WRITE_UINT8 (outdata + 7, wvh.index_no);\n      GST_WRITE_UINT32_LE (outdata + 8, wvh.total_samples);\n      GST_WRITE_UINT32_LE (outdata + 12, wvh.block_index);\n      GST_WRITE_UINT32_LE (outdata + 16, block_samples);\n      GST_WRITE_UINT32_LE (outdata + 20, flags);\n      GST_WRITE_UINT32_LE (outdata + 24, crc);\n      outdata += 28;\n\n      memcpy (outdata, data, blocksize);\n\n      gst_buffer_unmap (newbuf, &outmap);\n      gst_adapter_push (adapter, newbuf);\n      newbuf = NULL;\n\n// fix_end\n// fix_start\n\n    newbuf = gst_adapter_take_buffer (adapter, gst_adapter_available (adapter));\n    g_object_unref (adapter);\n\n    gst_buffer_copy_into (newbuf, *buf,\n        GST_BUFFER_COPY_TIMESTAMPS | GST_BUFFER_COPY_FLAGS, 0, -1);\n// fix_end\n// fix_start\n    *buf = newbuf;\n// fix_end\n// fix_start\n// fix_end\n", "cwe": "CWE-416", "cwe_name": "Use After Free", "cve": "CVE-2021-3497", "cve_desc": "GStreamer before 1.18.4 might access already-freed memory in error code paths when demuxing certain malformed Matroska files.", "project": "gst-plugins-good", "idx": 211032}
{"source": " allocate_trace_buffer(struct trace_array *tr, struct trace_buffer *buf, int size)\n {\n \tenum ring_buffer_flags rb_flags;\n \n \trb_flags = tr->trace_flags & TRACE_ITER_OVERWRITE ? RB_FL_OVERWRITE : 0;\n \n \tbuf->tr = tr;\n \n \tbuf->buffer = ring_buffer_alloc(size, rb_flags);\n \tif (!buf->buffer)\n \t\treturn -ENOMEM;\n \n \tbuf->data = alloc_percpu(struct trace_array_cpu);\n \tif (!buf->data) {\n \t\tring_buffer_free(buf->buffer);\n// bug_start\n// bug_end\n \t\treturn -ENOMEM;\n \t}\n \n \tset_buffer_entries(&tr->trace_buffer,\n \t\t\t   ring_buffer_size(tr->trace_buffer.buffer, 0));\n \n \treturn 0;\n }\n \n", "target": "// fix_start\n\t\tbuf->buffer = NULL;\n// fix_end\n", "cwe": "CWE-415", "cwe_name": "Double Free", "cve": "CVE-2017-18595", "cve_desc": "An issue was discovered in the Linux kernel before 4.14.11. A double free may be caused by the function allocate_trace_buffer in the file kernel/trace/trace.c.", "project": "linux", "idx": 211099}
{"source": " void ScanLineInputFile::initialize(const Header& header)\n {\n         _data->header = header;\n \n         _data->lineOrder = _data->header.lineOrder();\n \n         const Box2i &dataWindow = _data->header.dataWindow();\n \n         _data->minX = dataWindow.min.x;\n         _data->maxX = dataWindow.max.x;\n         _data->minY = dataWindow.min.y;\n         _data->maxY = dataWindow.max.y;\n \n         Compression comp = _data->header.compression();\n \n         _data->linesInBuffer =\n             numLinesInBuffer (comp);\n \n         int lineOffsetSize = (dataWindow.max.y - dataWindow.min.y +\n                               _data->linesInBuffer) / _data->linesInBuffer;\n \n// bug_start\n        if (lineOffsetSize > gLargeChunkTableSize)\n// bug_end\n         {\n             Int64 pos = _streamData->is->tellg();\n             _streamData->is->seekg(pos + (lineOffsetSize-1)*sizeof(Int64));\n             Int64 temp;\n             OPENEXR_IMF_INTERNAL_NAMESPACE::Xdr::read <OPENEXR_IMF_INTERNAL_NAMESPACE::StreamIO> (*_streamData->is, temp);\n             _streamData->is->seekg(pos);\n \n         }\n \n \n         size_t maxBytesPerLine = bytesPerLineTable (_data->header,\n                                                     _data->bytesPerLine);\n \n         if (maxBytesPerLine*numLinesInBuffer(comp) > INT_MAX)\n         {\n             throw IEX_NAMESPACE::InputExc(\"maximum bytes per scanline exceeds maximum permissible size\");\n         }\n \n \n         for (size_t i = 0; i < _data->lineBuffers.size(); i++)\n         {\n             _data->lineBuffers[i] = new LineBuffer (newCompressor(comp,\n                                                  maxBytesPerLine,\n                                                  _data->header));\n         }\n \n \n \n         _data->lineBufferSize = maxBytesPerLine * _data->linesInBuffer;\n \n         if (!_streamData->is->isMemoryMapped())\n         {\n             for (size_t i = 0; i < _data->lineBuffers.size(); i++)\n             {\n                 _data->lineBuffers[i]->buffer = (char *) EXRAllocAligned(_data->lineBufferSize*sizeof(char),16);\n                 if (!_data->lineBuffers[i]->buffer)\n                 {\n                     throw IEX_NAMESPACE::LogicExc(\"Failed to allocate memory for scanline buffers\");\n                 }\n             }\n         }\n         _data->nextLineBufferMinY = _data->minY - 1;\n \n         offsetInLineBufferTable (_data->bytesPerLine,\n                                  _data->linesInBuffer,\n                                  _data->offsetInLineBuffer);\n \n \n         _data->lineOffsets.resize (lineOffsetSize);\n }\n \n", "target": "// fix_start\n        if (lineOffsetSize * _data->linesInBuffer > gLargeChunkTableSize)\n// fix_end\n", "cwe": "CWE-770", "cwe_name": "Allocation of Resources Without Limits or Throttling", "cve": "CVE-2021-3478", "cve_desc": "There's a flaw in OpenEXR's scanline input file functionality in versions before 3.0.0-beta. An attacker able to submit a crafted file to be processed by OpenEXR could consume excessive system memory. The greatest impact of this flaw is to system availability.", "project": "openexr", "idx": 211127}
{"source": " static struct kobject *cdev_get(struct cdev *p)\n {\n \tstruct module *owner = p->owner;\n \tstruct kobject *kobj;\n \n \tif (owner && !try_module_get(owner))\n \t\treturn NULL;\n// bug_start\n\tkobj = kobject_get(&p->kobj);\n// bug_end\n \tif (!kobj)\n \t\tmodule_put(owner);\n \treturn kobj;\n }\n \n", "target": "// fix_start\n\tkobj = kobject_get_unless_zero(&p->kobj);\n// fix_end\n", "cwe": "CWE-362", "cwe_name": "Concurrent Execution using Shared Resource with Improper Synchronization ('Race Condition')", "cve": "CVE-2020-0305", "cve_desc": "In cdev_get of char_dev.c, there is a possible use-after-free due to a race condition. This could lead to local escalation of privilege with System execution privileges needed. User interaction is not needed for exploitation.Product: AndroidVersions: Android-10Android ID: A-153467744", "project": "linux", "idx": 211135}
{"source": " static Image *ReadTIFFImage(const ImageInfo *image_info,\n   ExceptionInfo *exception)\n {\n #define ThrowTIFFException(severity,message) \\\n { \\\n   if (pixel_info != (MemoryInfo *) NULL) \\\n     pixel_info=RelinquishVirtualMemory(pixel_info); \\\n   if (quantum_info != (QuantumInfo *) NULL) \\\n     quantum_info=DestroyQuantumInfo(quantum_info); \\\n   TIFFClose(tiff); \\\n   ThrowReaderException(severity,message); \\\n }\n \n   const char\n     *option;\n \n   float\n     *chromaticity,\n     x_position,\n     y_position,\n     x_resolution,\n     y_resolution;\n \n   Image\n     *image;\n \n   int\n     tiff_status;\n \n   MagickBooleanType\n     more_frames,\n     status;\n \n   MagickSizeType\n     number_pixels;\n \n   MemoryInfo\n     *pixel_info = (MemoryInfo *) NULL;\n \n   QuantumInfo\n     *quantum_info;\n \n   QuantumType\n     quantum_type;\n \n   register ssize_t\n     i;\n \n   size_t\n     pad;\n \n   ssize_t\n     y;\n \n   TIFF\n     *tiff;\n \n   TIFFMethodType\n     method;\n \n   uint16\n     compress_tag,\n     bits_per_sample,\n     endian,\n     extra_samples,\n     interlace,\n     max_sample_value,\n     min_sample_value,\n     orientation,\n     pages,\n     photometric,\n     *sample_info,\n     sample_format,\n     samples_per_pixel,\n     units,\n     value;\n \n   uint32\n     height,\n     rows_per_strip,\n     width;\n \n   unsigned char\n     *pixels;\n \n   void\n     *sans[2] = { NULL, NULL };\n \n   assert(image_info != (const ImageInfo *) NULL);\n   assert(image_info->signature == MagickCoreSignature);\n   if (image_info->debug != MagickFalse)\n     (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n       image_info->filename);\n   assert(exception != (ExceptionInfo *) NULL);\n   assert(exception->signature == MagickCoreSignature);\n   image=AcquireImage(image_info,exception);\n   status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n   if (status == MagickFalse)\n     {\n       image=DestroyImageList(image);\n       return((Image *) NULL);\n     }\n   (void) SetMagickThreadValue(tiff_exception,exception);\n   tiff=TIFFClientOpen(image->filename,\"rb\",(thandle_t) image,TIFFReadBlob,\n     TIFFWriteBlob,TIFFSeekBlob,TIFFCloseBlob,TIFFGetBlobSize,TIFFMapBlob,\n     TIFFUnmapBlob);\n   if (tiff == (TIFF *) NULL)\n     {\n       image=DestroyImageList(image);\n       return((Image *) NULL);\n     }\n   if (exception->severity > ErrorException)\n     {\n       TIFFClose(tiff);\n       image=DestroyImageList(image);\n       return((Image *) NULL);\n     }\n   if (image_info->number_scenes != 0)\n     {\n       if (image_info->scene < (size_t) TIFFNumberOfDirectories(tiff))\n         {\n           for (i=0; i < (ssize_t) image_info->scene; i++)\n           {\n             status=TIFFReadDirectory(tiff) != 0 ? MagickTrue : MagickFalse;\n             if (status == MagickFalse)\n               {\n                 TIFFClose(tiff);\n                 image=DestroyImageList(image);\n                 return((Image *) NULL);\n               }\n             AcquireNextImage(image_info,image,exception);\n             if (GetNextImageInList(image) == (Image *) NULL)\n               {\n                 TIFFClose(tiff);\n                 image=DestroyImageList(image);\n                 return((Image *) NULL);\n               }\n             image=SyncNextImageInList(image);\n           }\n       }\n   }\n   more_frames=MagickTrue;\n   do\n   {\n     photometric=PHOTOMETRIC_RGB;\n     if ((TIFFGetField(tiff,TIFFTAG_IMAGEWIDTH,&width) != 1) ||\n         (TIFFGetField(tiff,TIFFTAG_IMAGELENGTH,&height) != 1) ||\n         (TIFFGetFieldDefaulted(tiff,TIFFTAG_PHOTOMETRIC,&photometric,sans) != 1) ||\n         (TIFFGetFieldDefaulted(tiff,TIFFTAG_COMPRESSION,&compress_tag,sans) != 1) ||\n         (TIFFGetFieldDefaulted(tiff,TIFFTAG_FILLORDER,&endian,sans) != 1) ||\n         (TIFFGetFieldDefaulted(tiff,TIFFTAG_PLANARCONFIG,&interlace,sans) != 1) ||\n         (TIFFGetFieldDefaulted(tiff,TIFFTAG_SAMPLESPERPIXEL,&samples_per_pixel,sans) != 1) ||\n         (TIFFGetFieldDefaulted(tiff,TIFFTAG_BITSPERSAMPLE,&bits_per_sample,sans) != 1) ||\n         (TIFFGetFieldDefaulted(tiff,TIFFTAG_SAMPLEFORMAT,&sample_format,sans) != 1) ||\n         (TIFFGetFieldDefaulted(tiff,TIFFTAG_MINSAMPLEVALUE,&min_sample_value,sans) != 1) ||\n         (TIFFGetFieldDefaulted(tiff,TIFFTAG_MAXSAMPLEVALUE,&max_sample_value,sans) != 1))\n       {\n         TIFFClose(tiff);\n         ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n       }\n     if (((sample_format != SAMPLEFORMAT_IEEEFP) || (bits_per_sample != 64)) &&\n         ((bits_per_sample <= 0) || (bits_per_sample > 32)))\n       {\n         TIFFClose(tiff);\n         ThrowReaderException(CorruptImageError,\"UnsupportedBitsPerPixel\");\n       }\n     if (sample_format == SAMPLEFORMAT_IEEEFP)\n       (void) SetImageProperty(image,\"quantum:format\",\"floating-point\",\n         exception);\n     switch (photometric)\n     {\n       case PHOTOMETRIC_MINISBLACK:\n       {\n         (void) SetImageProperty(image,\"tiff:photometric\",\"min-is-black\",\n           exception);\n         break;\n       }\n       case PHOTOMETRIC_MINISWHITE:\n       {\n         (void) SetImageProperty(image,\"tiff:photometric\",\"min-is-white\",\n           exception);\n         break;\n       }\n       case PHOTOMETRIC_PALETTE:\n       {\n         (void) SetImageProperty(image,\"tiff:photometric\",\"palette\",exception);\n         break;\n       }\n       case PHOTOMETRIC_RGB:\n       {\n         (void) SetImageProperty(image,\"tiff:photometric\",\"RGB\",exception);\n         break;\n       }\n       case PHOTOMETRIC_CIELAB:\n       {\n         (void) SetImageProperty(image,\"tiff:photometric\",\"CIELAB\",exception);\n         break;\n       }\n       case PHOTOMETRIC_LOGL:\n       {\n         (void) SetImageProperty(image,\"tiff:photometric\",\"CIE Log2(L)\",\n           exception);\n         break;\n       }\n       case PHOTOMETRIC_LOGLUV:\n       {\n         (void) SetImageProperty(image,\"tiff:photometric\",\"LOGLUV\",exception);\n         break;\n       }\n #if defined(PHOTOMETRIC_MASK)\n       case PHOTOMETRIC_MASK:\n       {\n         (void) SetImageProperty(image,\"tiff:photometric\",\"MASK\",exception);\n         break;\n       }\n #endif\n       case PHOTOMETRIC_SEPARATED:\n       {\n         (void) SetImageProperty(image,\"tiff:photometric\",\"separated\",exception);\n         break;\n       }\n       case PHOTOMETRIC_YCBCR:\n       {\n         (void) SetImageProperty(image,\"tiff:photometric\",\"YCBCR\",exception);\n         break;\n       }\n       default:\n       {\n         (void) SetImageProperty(image,\"tiff:photometric\",\"unknown\",exception);\n         break;\n       }\n     }\n     if (image->debug != MagickFalse)\n       {\n         (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"Geometry: %ux%u\",\n           (unsigned int) width,(unsigned int) height);\n         (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"Interlace: %u\",\n           interlace);\n         (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n           \"Bits per sample: %u\",bits_per_sample);\n         (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n           \"Min sample value: %u\",min_sample_value);\n         (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n           \"Max sample value: %u\",max_sample_value);\n         (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"Photometric \"\n           \"interpretation: %s\",GetImageProperty(image,\"tiff:photometric\",\n           exception));\n       }\n     image->columns=(size_t) width;\n     image->rows=(size_t) height;\n     image->depth=(size_t) bits_per_sample;\n     if (image->debug != MagickFalse)\n       (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"Image depth: %.20g\",\n         (double) image->depth);\n     image->endian=MSBEndian;\n     if (endian == FILLORDER_LSB2MSB)\n       image->endian=LSBEndian;\n #if defined(MAGICKCORE_HAVE_TIFFISBIGENDIAN)\n     if (TIFFIsBigEndian(tiff) == 0)\n       {\n         (void) SetImageProperty(image,\"tiff:endian\",\"lsb\",exception);\n         image->endian=LSBEndian;\n       }\n     else\n       {\n         (void) SetImageProperty(image,\"tiff:endian\",\"msb\",exception);\n         image->endian=MSBEndian;\n       }\n #endif\n     if ((photometric == PHOTOMETRIC_MINISBLACK) ||\n         (photometric == PHOTOMETRIC_MINISWHITE))\n       image->colorspace=GRAYColorspace;\n     if (photometric == PHOTOMETRIC_SEPARATED)\n       image->colorspace=CMYKColorspace;\n     if (photometric == PHOTOMETRIC_CIELAB)\n       image->colorspace=LabColorspace;\n     if ((photometric == PHOTOMETRIC_YCBCR) && (compress_tag != COMPRESSION_JPEG))\n       image->colorspace=YCbCrColorspace;\n     status=TIFFGetProfiles(tiff,image,exception);\n     if (status == MagickFalse)\n       {\n         TIFFClose(tiff);\n         return(DestroyImageList(image));\n       }\n     status=TIFFGetProperties(tiff,image,exception);\n     if (status == MagickFalse)\n       {\n         TIFFClose(tiff);\n         return(DestroyImageList(image));\n       }\n     option=GetImageOption(image_info,\"tiff:exif-properties\");\n     if (IsStringFalse(option) == MagickFalse)\n       TIFFGetEXIFProperties(tiff,image,exception);\n     if ((TIFFGetFieldDefaulted(tiff,TIFFTAG_XRESOLUTION,&x_resolution,sans) == 1) &&\n         (TIFFGetFieldDefaulted(tiff,TIFFTAG_YRESOLUTION,&y_resolution,sans) == 1))\n       {\n         image->resolution.x=x_resolution;\n         image->resolution.y=y_resolution;\n       }\n     if (TIFFGetFieldDefaulted(tiff,TIFFTAG_RESOLUTIONUNIT,&units,sans,sans) == 1)\n       {\n         if (units == RESUNIT_INCH)\n           image->units=PixelsPerInchResolution;\n         if (units == RESUNIT_CENTIMETER)\n           image->units=PixelsPerCentimeterResolution;\n       }\n     if ((TIFFGetFieldDefaulted(tiff,TIFFTAG_XPOSITION,&x_position,sans) == 1) &&\n         (TIFFGetFieldDefaulted(tiff,TIFFTAG_YPOSITION,&y_position,sans) == 1))\n       {\n         image->page.x=(ssize_t) ceil(x_position*image->resolution.x-0.5);\n         image->page.y=(ssize_t) ceil(y_position*image->resolution.y-0.5);\n       }\n     if (TIFFGetFieldDefaulted(tiff,TIFFTAG_ORIENTATION,&orientation,sans) == 1)\n       image->orientation=(OrientationType) orientation;\n     if (TIFFGetField(tiff,TIFFTAG_WHITEPOINT,&chromaticity) == 1)\n       {\n         if ((chromaticity != (float *) NULL) && (*chromaticity != 0.0))\n           {\n             image->chromaticity.white_point.x=chromaticity[0];\n             image->chromaticity.white_point.y=chromaticity[1];\n           }\n       }\n     if (TIFFGetField(tiff,TIFFTAG_PRIMARYCHROMATICITIES,&chromaticity) == 1)\n       {\n         if ((chromaticity != (float *) NULL) && (*chromaticity != 0.0))\n           {\n             image->chromaticity.red_primary.x=chromaticity[0];\n             image->chromaticity.red_primary.y=chromaticity[1];\n             image->chromaticity.green_primary.x=chromaticity[2];\n             image->chromaticity.green_primary.y=chromaticity[3];\n             image->chromaticity.blue_primary.x=chromaticity[4];\n             image->chromaticity.blue_primary.y=chromaticity[5];\n           }\n       }\n #if defined(MAGICKCORE_HAVE_TIFFISCODECCONFIGURED) || (TIFFLIB_VERSION > 20040919)\n     if ((compress_tag != COMPRESSION_NONE) &&\n         (TIFFIsCODECConfigured(compress_tag) == 0))\n       {\n         TIFFClose(tiff);\n         ThrowReaderException(CoderError,\"CompressNotSupported\");\n       }\n #endif\n     switch (compress_tag)\n     {\n       case COMPRESSION_NONE: image->compression=NoCompression; break;\n       case COMPRESSION_CCITTFAX3: image->compression=FaxCompression; break;\n       case COMPRESSION_CCITTFAX4: image->compression=Group4Compression; break;\n       case COMPRESSION_JPEG:\n       {\n          image->compression=JPEGCompression;\n #if defined(JPEG_SUPPORT)\n          {\n            char\n              sampling_factor[MagickPathExtent];\n \n            uint16\n              horizontal,\n              vertical;\n \n            tiff_status=TIFFGetField(tiff,TIFFTAG_YCBCRSUBSAMPLING,&horizontal,\n              &vertical);\n            if (tiff_status == 1)\n              {\n                (void) FormatLocaleString(sampling_factor,MagickPathExtent,\n                  \"%dx%d\",horizontal,vertical);\n                (void) SetImageProperty(image,\"jpeg:sampling-factor\",\n                  sampling_factor,exception);\n                (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                  \"Sampling Factors: %s\",sampling_factor);\n              }\n          }\n #endif\n         break;\n       }\n       case COMPRESSION_OJPEG: image->compression=JPEGCompression; break;\n #if defined(COMPRESSION_LZMA)\n       case COMPRESSION_LZMA: image->compression=LZMACompression; break;\n #endif\n       case COMPRESSION_LZW: image->compression=LZWCompression; break;\n       case COMPRESSION_DEFLATE: image->compression=ZipCompression; break;\n       case COMPRESSION_ADOBE_DEFLATE: image->compression=ZipCompression; break;\n #if defined(COMPRESSION_WEBP)\n       case COMPRESSION_WEBP: image->compression=WebPCompression; break;\n #endif\n #if defined(COMPRESSION_ZSTD)\n       case COMPRESSION_ZSTD: image->compression=ZstdCompression; break;\n #endif\n       default: image->compression=RLECompression; break;\n     }\n     quantum_info=(QuantumInfo *) NULL;\n     if ((photometric == PHOTOMETRIC_PALETTE) &&\n         (pow(2.0,1.0*bits_per_sample) <= MaxColormapSize))\n       {\n         size_t\n           colors;\n \n         colors=(size_t) GetQuantumRange(bits_per_sample)+1;\n         if (AcquireImageColormap(image,colors,exception) == MagickFalse)\n           {\n             TIFFClose(tiff);\n             ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n           }\n       }\n     value=(unsigned short) image->scene;\n     if (TIFFGetFieldDefaulted(tiff,TIFFTAG_PAGENUMBER,&value,&pages,sans) == 1)\n       image->scene=value;\n     if (image->storage_class == PseudoClass)\n       {\n         size_t\n           range;\n \n         uint16\n           *blue_colormap,\n           *green_colormap,\n           *red_colormap;\n \n         tiff_status=TIFFGetField(tiff,TIFFTAG_COLORMAP,&red_colormap,\n           &green_colormap,&blue_colormap);\n         if (tiff_status == 1)\n           {\n             if ((red_colormap != (uint16 *) NULL) &&\n                 (green_colormap != (uint16 *) NULL) &&\n                 (blue_colormap != (uint16 *) NULL))\n               {\n                 range=255;\n                 for (i=0; i < (ssize_t) image->colors; i++)\n                   if ((red_colormap[i] >= 256) || (green_colormap[i] >= 256) ||\n                       (blue_colormap[i] >= 256))\n                     {\n                       range=65535;\n                       break;\n                     }\n                 for (i=0; i < (ssize_t) image->colors; i++)\n                 {\n                   image->colormap[i].red=ClampToQuantum(((double)\n                     QuantumRange*red_colormap[i])/range);\n                   image->colormap[i].green=ClampToQuantum(((double)\n                     QuantumRange*green_colormap[i])/range);\n                   image->colormap[i].blue=ClampToQuantum(((double)\n                     QuantumRange*blue_colormap[i])/range);\n                 }\n               }\n           }\n       }\n     if (image_info->ping != MagickFalse)\n       {\n         if (image_info->number_scenes != 0)\n           if (image->scene >= (image_info->scene+image_info->number_scenes-1))\n             break;\n         goto next_tiff_frame;\n       }\n     status=SetImageExtent(image,image->columns,image->rows,exception);\n     if (status == MagickFalse)\n       {\n         TIFFClose(tiff);\n         return(DestroyImageList(image));\n       }\n     status=SetImageColorspace(image,image->colorspace,exception);\n     status&=ResetImagePixels(image,exception);\n     if (status == MagickFalse)\n       {\n         TIFFClose(tiff);\n         return(DestroyImageList(image));\n       }\n     quantum_info=AcquireQuantumInfo(image_info,image);\n     if (quantum_info == (QuantumInfo *) NULL)\n       ThrowTIFFException(ResourceLimitError,\"MemoryAllocationFailed\");\n     if (sample_format == SAMPLEFORMAT_UINT)\n       status=SetQuantumFormat(image,quantum_info,UnsignedQuantumFormat);\n     if (sample_format == SAMPLEFORMAT_INT)\n       status=SetQuantumFormat(image,quantum_info,SignedQuantumFormat);\n     if (sample_format == SAMPLEFORMAT_IEEEFP)\n       status=SetQuantumFormat(image,quantum_info,FloatingPointQuantumFormat);\n     if (status == MagickFalse)\n       ThrowTIFFException(ResourceLimitError,\"MemoryAllocationFailed\");\n     status=MagickTrue;\n     switch (photometric)\n     {\n       case PHOTOMETRIC_MINISBLACK:\n       {\n         quantum_info->min_is_white=MagickFalse;\n         break;\n       }\n       case PHOTOMETRIC_MINISWHITE:\n       {\n         quantum_info->min_is_white=MagickTrue;\n         break;\n       }\n       default:\n         break;\n     }\n     extra_samples=0;\n     tiff_status=TIFFGetFieldDefaulted(tiff,TIFFTAG_EXTRASAMPLES,&extra_samples,\n       &sample_info,sans);\n     if (tiff_status == 1)\n       {\n         (void) SetImageProperty(image,\"tiff:alpha\",\"unspecified\",exception);\n         if (extra_samples == 0)\n           {\n             if ((samples_per_pixel == 4) && (photometric == PHOTOMETRIC_RGB))\n               image->alpha_trait=BlendPixelTrait;\n           }\n         else\n           for (i=0; i < extra_samples; i++)\n           {\n             image->alpha_trait=BlendPixelTrait;\n             if (sample_info[i] == EXTRASAMPLE_ASSOCALPHA)\n               {\n                 SetQuantumAlphaType(quantum_info,AssociatedQuantumAlpha);\n                 (void) SetImageProperty(image,\"tiff:alpha\",\"associated\",\n                   exception);\n               }\n             else\n               if (sample_info[i] == EXTRASAMPLE_UNASSALPHA)\n                 {\n                   SetQuantumAlphaType(quantum_info,DisassociatedQuantumAlpha);\n                   (void) SetImageProperty(image,\"tiff:alpha\",\"unassociated\",\n                     exception);\n                 }\n           }\n       }\n     if (image->alpha_trait != UndefinedPixelTrait)\n       (void) SetImageAlphaChannel(image,OpaqueAlphaChannel,exception);\n     if (samples_per_pixel > MaxPixelChannels)\n       {\n         TIFFClose(tiff);\n         ThrowReaderException(CorruptImageError,\"MaximumChannelsExceeded\");\n       }\n     method=ReadGenericMethod;\n     rows_per_strip=(uint32) image->rows;\n     if (TIFFGetField(tiff,TIFFTAG_ROWSPERSTRIP,&rows_per_strip) == 1)\n       {\n         char\n           buffer[MagickPathExtent];\n \n         (void) FormatLocaleString(buffer,MagickPathExtent,\"%u\",\n           (unsigned int) rows_per_strip);\n         (void) SetImageProperty(image,\"tiff:rows-per-strip\",buffer,exception);\n         method=ReadStripMethod;\n         if (rows_per_strip > (uint32) image->rows)\n           rows_per_strip=(uint32) image->rows;\n       }\n     if (TIFFIsTiled(tiff) != MagickFalse)\n       {\n         uint32\n           columns,\n           rows;\n \n         if ((TIFFGetField(tiff,TIFFTAG_TILEWIDTH,&columns) != 1) ||\n             (TIFFGetField(tiff,TIFFTAG_TILELENGTH,&rows) != 1))\n           ThrowTIFFException(CoderError,\"ImageIsNotTiled\");\n         if ((AcquireMagickResource(WidthResource,columns) == MagickFalse) ||\n             (AcquireMagickResource(HeightResource,rows) == MagickFalse))\n           ThrowTIFFException(ImageError,\"WidthOrHeightExceedsLimit\");\n         method=ReadTileMethod;\n       }\n     if (image->compression == JPEGCompression)\n       method=GetJPEGMethod(image,tiff,photometric,bits_per_sample,\n         samples_per_pixel);\n     if (photometric == PHOTOMETRIC_LOGLUV)\n       method=ReadGenericMethod;\n     quantum_info->endian=LSBEndian;\n     quantum_type=RGBQuantum;\n     if (TIFFScanlineSize(tiff) <= 0)\n       ThrowTIFFException(ResourceLimitError,\"MemoryAllocationFailed\");\n     if ((1.0*TIFFScanlineSize(tiff)) > (2.53*GetBlobSize(image)))\n       ThrowTIFFException(CorruptImageError,\"InsufficientImageDataInFile\");\n     number_pixels=MagickMax(TIFFScanlineSize(tiff),MagickMax((ssize_t)\n       image->columns*samples_per_pixel*pow(2.0,ceil(log(bits_per_sample)/\n       log(2.0))),image->columns*rows_per_strip));\n     pixel_info=AcquireVirtualMemory(number_pixels,sizeof(uint32));\n     if (pixel_info == (MemoryInfo *) NULL)\n       ThrowTIFFException(ResourceLimitError,\"MemoryAllocationFailed\");\n     pixels=(unsigned char *) GetVirtualMemoryBlob(pixel_info);\n     (void) memset(pixels,0,number_pixels*sizeof(uint32));\n     quantum_type=IndexQuantum;\n     pad=(size_t) MagickMax((ssize_t) samples_per_pixel-1,0);\n     if (image->alpha_trait != UndefinedPixelTrait)\n       {\n         if (image->storage_class == PseudoClass)\n           quantum_type=IndexAlphaQuantum;\n         else\n           quantum_type=samples_per_pixel == 1 ? AlphaQuantum : GrayAlphaQuantum;\n       }\n     else\n       if (image->storage_class != PseudoClass)\n         quantum_type=GrayQuantum;\n     if ((samples_per_pixel > 2) && (interlace != PLANARCONFIG_SEPARATE))\n       {\n         pad=(size_t) MagickMax((size_t) samples_per_pixel-3,0);\n         quantum_type=RGBQuantum;\n         if (image->alpha_trait != UndefinedPixelTrait)\n           {\n             quantum_type=RGBAQuantum;\n             pad=(size_t) MagickMax((size_t) samples_per_pixel-4,0);\n           }\n         if (image->colorspace == CMYKColorspace)\n           {\n             pad=(size_t) MagickMax((size_t) samples_per_pixel-4,0);\n             quantum_type=CMYKQuantum;\n             if (image->alpha_trait != UndefinedPixelTrait)\n               {\n                 quantum_type=CMYKAQuantum;\n                 pad=(size_t) MagickMax((size_t) samples_per_pixel-5,0);\n               }\n           }\n         status=SetQuantumPad(image,quantum_info,pad*((bits_per_sample+7) >> 3));\n         if (status == MagickFalse)\n           ThrowTIFFException(ResourceLimitError,\"MemoryAllocationFailed\");\n       }\n     switch (method)\n     {\n       case ReadYCCKMethod:\n       {\n         for (y=0; y < (ssize_t) image->rows; y++)\n         {\n           register Quantum\n             *magick_restrict q;\n \n           register ssize_t\n             x;\n \n           unsigned char\n             *p;\n \n           tiff_status=TIFFReadPixels(tiff,0,y,(char *) pixels);\n           if (tiff_status == -1)\n             break;\n           q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n           if (q == (Quantum *) NULL)\n             break;\n           p=pixels;\n           for (x=0; x < (ssize_t) image->columns; x++)\n           {\n             SetPixelCyan(image,ScaleCharToQuantum(ClampYCC((double) *p+\n               (1.402*(double) *(p+2))-179.456)),q);\n             SetPixelMagenta(image,ScaleCharToQuantum(ClampYCC((double) *p-\n               (0.34414*(double) *(p+1))-(0.71414*(double ) *(p+2))+\n               135.45984)),q);\n             SetPixelYellow(image,ScaleCharToQuantum(ClampYCC((double) *p+\n               (1.772*(double) *(p+1))-226.816)),q);\n             SetPixelBlack(image,ScaleCharToQuantum((unsigned char) *(p+3)),q);\n             q+=GetPixelChannels(image);\n             p+=4;\n           }\n           if (SyncAuthenticPixels(image,exception) == MagickFalse)\n             break;\n           if (image->previous == (Image *) NULL)\n             {\n               status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n                 image->rows);\n               if (status == MagickFalse)\n                 break;\n             }\n         }\n         break;\n       }\n       case ReadStripMethod:\n       {\n         register unsigned char\n           *p;\n \n         size_t\n           extent;\n \n         ssize_t\n           stride,\n           strip_id;\n \n         tsize_t\n           strip_size;\n \n         unsigned char\n           *strip_pixels;\n \n         extent=TIFFStripSize(tiff);\n #if defined(TIFF_VERSION_BIG)\n         extent+=image->columns*sizeof(uint64);\n #else\n         extent+=image->columns*sizeof(uint32);\n #endif\n         strip_pixels=(unsigned char *) AcquireQuantumMemory(extent,\n// bug_start\n          sizeof(*strip_pixels));\n// bug_end\n         if (strip_pixels == (unsigned char *) NULL)\n           ThrowTIFFException(ResourceLimitError,\"MemoryAllocationFailed\");\n         (void) memset(strip_pixels,0,extent*sizeof(*strip_pixels));\n         stride=TIFFVStripSize(tiff,1);\n         strip_id=0;\n         p=strip_pixels;\n         for (i=0; i < (ssize_t) samples_per_pixel; i++)\n         {\n           size_t\n             rows_remaining;\n \n           switch (i)\n           {\n             case 0: break;\n             case 1: quantum_type=GreenQuantum; break;\n             case 2: quantum_type=BlueQuantum; break;\n             case 3:\n             {\n               if (image->colorspace == CMYKColorspace)\n                 quantum_type=BlackQuantum;\n               break;\n             }\n             case 4: quantum_type=AlphaQuantum; break;\n           }\n           rows_remaining=0;\n           for (y=0; y < (ssize_t) image->rows; y++)\n           {\n             register Quantum\n               *magick_restrict q;\n \n             q=GetAuthenticPixels(image,0,y,image->columns,1,exception);\n             if (q == (Quantum *) NULL)\n               break;\n             if (rows_remaining == 0)\n               {\n                 strip_size=TIFFReadEncodedStrip(tiff,strip_id,strip_pixels,\n                   TIFFStripSize(tiff));\n                 if (strip_size == -1)\n                   break;\n                 rows_remaining=rows_per_strip;\n                 if ((y+rows_per_strip) > image->rows)\n                   rows_remaining=(rows_per_strip-(y+rows_per_strip-\n                     image->rows));\n                 p=strip_pixels;\n                 strip_id++;\n               }\n             (void) ImportQuantumPixels(image,(CacheView *) NULL,\n               quantum_info,quantum_type,p,exception);\n             p+=stride;\n             rows_remaining--;\n             if (SyncAuthenticPixels(image,exception) == MagickFalse)\n               break;\n             if (image->previous == (Image *) NULL)\n               {\n                 status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n                   image->rows);\n                 if (status == MagickFalse)\n                   break;\n               }\n           }\n           if ((samples_per_pixel > 1) && (interlace != PLANARCONFIG_SEPARATE))\n             break;\n         }\n         strip_pixels=(unsigned char *) RelinquishMagickMemory(strip_pixels);\n         break;\n       }\n       case ReadTileMethod:\n       {\n         register unsigned char\n           *p;\n \n         size_t\n           extent;\n \n         uint32\n           columns,\n           rows;\n \n         unsigned char\n           *tile_pixels;\n \n         if ((TIFFGetField(tiff,TIFFTAG_TILEWIDTH,&columns) != 1) ||\n             (TIFFGetField(tiff,TIFFTAG_TILELENGTH,&rows) != 1))\n           ThrowTIFFException(CoderError,\"ImageIsNotTiled\");\n         number_pixels=(MagickSizeType) columns*rows;\n         if (HeapOverflowSanityCheck(rows,sizeof(*tile_pixels)) != MagickFalse)\n           ThrowTIFFException(ResourceLimitError,\"MemoryAllocationFailed\");\n         extent=TIFFTileSize(tiff);\n #if defined(TIFF_VERSION_BIG)\n         extent+=columns*sizeof(uint64);\n #else\n         extent+=columns*sizeof(uint32);\n #endif\n         tile_pixels=(unsigned char *) AcquireQuantumMemory(extent,\n           sizeof(*tile_pixels));\n         if (tile_pixels == (unsigned char *) NULL)\n           ThrowTIFFException(ResourceLimitError,\"MemoryAllocationFailed\");\n         (void) memset(tile_pixels,0,extent*sizeof(*tile_pixels));\n         for (i=0; i < (ssize_t) samples_per_pixel; i++)\n         {\n           switch (i)\n           {\n             case 0: break;\n             case 1: quantum_type=GreenQuantum; break;\n             case 2: quantum_type=BlueQuantum; break;\n             case 3:\n             {\n               if (image->colorspace == CMYKColorspace)\n                 quantum_type=BlackQuantum;\n               break;\n             }\n             case 4: quantum_type=AlphaQuantum; break;\n           }\n           for (y=0; y < (ssize_t) image->rows; y+=rows)\n           {\n             register ssize_t\n               x;\n \n             size_t\n               rows_remaining;\n \n             rows_remaining=image->rows-y;\n             if ((ssize_t) (y+rows) < (ssize_t) image->rows)\n               rows_remaining=rows;\n             for (x=0; x < (ssize_t) image->columns; x+=columns)\n             {\n               size_t\n                 columns_remaining,\n                 row;\n \n               columns_remaining=image->columns-x;\n               if ((ssize_t) (x+columns) < (ssize_t) image->columns)\n                 columns_remaining=columns;\n               if (TIFFReadTile(tiff,tile_pixels,(uint32) x,(uint32) y,0,i) == 0)\n                 break;\n               p=tile_pixels;\n               for (row=0; row < rows_remaining; row++)\n               {\n                 register Quantum\n                   *magick_restrict q;\n \n                 q=GetAuthenticPixels(image,x,y+row,columns_remaining,1,\n                   exception);\n                 if (q == (Quantum *) NULL)\n                   break;\n                 (void) ImportQuantumPixels(image,(CacheView *) NULL,\n                   quantum_info,quantum_type,p,exception);\n                 p+=TIFFTileRowSize(tiff);\n                 if (SyncAuthenticPixels(image,exception) == MagickFalse)\n                   break;\n               }\n             }\n           }\n           if ((samples_per_pixel > 1) && (interlace != PLANARCONFIG_SEPARATE))\n             break;\n           if (image->previous == (Image *) NULL)\n             {\n               status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) i,\n                 samples_per_pixel);\n               if (status == MagickFalse)\n                 break;\n             }\n         }\n         tile_pixels=(unsigned char *) RelinquishMagickMemory(tile_pixels);\n         break;\n       }\n       case ReadGenericMethod:\n       default:\n       {\n         MemoryInfo\n           *generic_info = (MemoryInfo * ) NULL;\n \n         register uint32\n           *p;\n \n         uint32\n           *pixels;\n \n         if (HeapOverflowSanityCheck(image->rows,sizeof(*pixels)) != MagickFalse)\n           ThrowTIFFException(ResourceLimitError,\"MemoryAllocationFailed\");\n         number_pixels=(MagickSizeType) image->columns*image->rows;\n         number_pixels+=image->columns*sizeof(uint32);\n         generic_info=AcquireVirtualMemory(number_pixels,sizeof(uint32));\n         if (generic_info == (MemoryInfo *) NULL)\n           ThrowTIFFException(ResourceLimitError,\"MemoryAllocationFailed\");\n         pixels=(uint32 *) GetVirtualMemoryBlob(generic_info);\n         (void) TIFFReadRGBAImage(tiff,(uint32) image->columns,(uint32)\n           image->rows,(uint32 *) pixels,0);\n         p=pixels+(image->columns*image->rows)-1;\n         for (y=0; y < (ssize_t) image->rows; y++)\n         {\n           register ssize_t\n             x;\n \n           register Quantum\n             *magick_restrict q;\n \n           q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n           if (q == (Quantum *) NULL)\n             break;\n           q+=GetPixelChannels(image)*(image->columns-1);\n           for (x=0; x < (ssize_t) image->columns; x++)\n           {\n             SetPixelRed(image,ScaleCharToQuantum((unsigned char)\n               TIFFGetR(*p)),q);\n             SetPixelGreen(image,ScaleCharToQuantum((unsigned char)\n               TIFFGetG(*p)),q);\n             SetPixelBlue(image,ScaleCharToQuantum((unsigned char)\n               TIFFGetB(*p)),q);\n             if (image->alpha_trait != UndefinedPixelTrait)\n               SetPixelAlpha(image,ScaleCharToQuantum((unsigned char)\n                 TIFFGetA(*p)),q);\n             p--;\n             q-=GetPixelChannels(image);\n           }\n           if (SyncAuthenticPixels(image,exception) == MagickFalse)\n             break;\n           if (image->previous == (Image *) NULL)\n             {\n               status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n                 image->rows);\n               if (status == MagickFalse)\n                 break;\n             }\n         }\n         generic_info=RelinquishVirtualMemory(generic_info);\n         break;\n       }\n     }\n     pixel_info=RelinquishVirtualMemory(pixel_info);\n     SetQuantumImageType(image,quantum_type);\n   next_tiff_frame:\n     if (quantum_info != (QuantumInfo *) NULL)\n       quantum_info=DestroyQuantumInfo(quantum_info);\n     if (photometric == PHOTOMETRIC_CIELAB)\n       DecodeLabImage(image,exception);\n     if ((photometric == PHOTOMETRIC_LOGL) ||\n         (photometric == PHOTOMETRIC_MINISBLACK) ||\n         (photometric == PHOTOMETRIC_MINISWHITE))\n       {\n         image->type=GrayscaleType;\n         if (bits_per_sample == 1)\n           image->type=BilevelType;\n       }\n     if (image_info->number_scenes != 0)\n       if (image->scene >= (image_info->scene+image_info->number_scenes-1))\n         break;\n     more_frames=TIFFReadDirectory(tiff) != 0 ? MagickTrue : MagickFalse;\n     if (more_frames != MagickFalse)\n       {\n         AcquireNextImage(image_info,image,exception);\n         if (GetNextImageInList(image) == (Image *) NULL)\n           {\n             status=MagickFalse;\n             break;\n           }\n         image=SyncNextImageInList(image);\n         status=SetImageProgress(image,LoadImagesTag,image->scene-1,\n           image->scene);\n         if (status == MagickFalse)\n           break;\n       }\n   } while ((status != MagickFalse) && (more_frames != MagickFalse));\n   TIFFClose(tiff);\n   if (status != MagickFalse)\n     TIFFReadPhotoshopLayers(image_info,image,exception);\n   if ((image_info->number_scenes != 0) &&\n       (image_info->scene >= GetImageListLength(image)))\n     status=MagickFalse;\n   if (status == MagickFalse)\n     return(DestroyImageList(image));\n   return(GetFirstImageInList(image));\n }\n \n", "target": "// fix_start\n          2*sizeof(*strip_pixels));\n// fix_end\n", "cwe": "CWE-703", "cwe_name": "Improper Check or Handling of Exceptional Conditions", "cve": "CVE-2020-27829", "cve_desc": "A heap based buffer overflow in coders/tiff.c may result in program crash and denial of service in ImageMagick before 7.0.10-45.", "project": "ImageMagick", "idx": 211237}
{"source": " static apr_byte_t oidc_validate_post_logout_url(request_rec *r, const char *url,\n \t\tchar **err_str, char **err_desc) {\n \tapr_uri_t uri;\n \tconst char *c_host = NULL;\n \n \tif (apr_uri_parse(r->pool, url, &uri) != APR_SUCCESS) {\n \t\t*err_str = apr_pstrdup(r->pool, \"Malformed URL\");\n \t\t*err_desc = apr_psprintf(r->pool, \"Logout URL malformed: %s\", url);\n \t\toidc_error(r, \"%s: %s\", *err_str, *err_desc);\n \t\treturn FALSE;\n \t}\n \n \tc_host = oidc_get_current_url_host(r);\n \tif ((uri.hostname != NULL)\n \t\t\t&& ((strstr(c_host, uri.hostname) == NULL)\n \t\t\t\t\t|| (strstr(uri.hostname, c_host) == NULL))) {\n \t\t*err_str = apr_pstrdup(r->pool, \"Invalid Request\");\n \t\t*err_desc =\n \t\t\t\tapr_psprintf(r->pool,\n \t\t\t\t\t\t\"logout value \\\"%s\\\" does not match the hostname of the current request \\\"%s\\\"\",\n \t\t\t\t\t\tapr_uri_unparse(r->pool, &uri, 0), c_host);\n \t\toidc_error(r, \"%s: %s\", *err_str, *err_desc);\n \t\treturn FALSE;\n// bug_start\n\t} else if (strstr(url, \"/\") != url) {\n// bug_end\n \t\t*err_str = apr_pstrdup(r->pool, \"Malformed URL\");\n \t\t*err_desc =\n \t\t\t\tapr_psprintf(r->pool,\n \t\t\t\t\t\t\"No hostname was parsed and it does not seem to be relative, i.e starting with '/': %s\",\n \t\t\t\t\t\turl);\n \t\toidc_error(r, \"%s: %s\", *err_str, *err_desc);\n \t\treturn FALSE;\n \t}\n \n \tif (((strstr(url, \"\\n\") != NULL) || strstr(url, \"\\r\") != NULL)) {\n \t\t*err_str = apr_pstrdup(r->pool, \"Invalid Request\");\n \t\t*err_desc =\n \t\t\t\tapr_psprintf(r->pool,\n \t\t\t\t\t\t\"logout value \\\"%s\\\" contains illegal \\\"\\n\\\" or \\\"\\r\\\" character(s)\",\n \t\t\t\t\t\turl);\n \t\toidc_error(r, \"%s: %s\", *err_str, *err_desc);\n \t\treturn FALSE;\n \t}\n \n \treturn TRUE;\n }\n \n", "target": "// fix_start\n\t} else if ((uri.hostname == NULL) && (strstr(url, \"/\") != url)) {\n// fix_end\n", "cwe": "CWE-601", "cwe_name": "URL Redirection to Untrusted Site ('Open Redirect')", "cve": "CVE-2019-14857", "cve_desc": "A flaw was found in mod_auth_openidc before version 2.4.0.1. An open redirect issue exists in URLs with trailing slashes similar to CVE-2019-3877 in mod_auth_mellon.", "project": "mod_auth_openidc", "idx": 211253}
{"source": " int jp2_encode(jas_image_t *image, jas_stream_t *out, const char *optstr)\n {\n \tjp2_box_t *box;\n \tjp2_ftyp_t *ftyp;\n \tjp2_ihdr_t *ihdr;\n \tjas_stream_t *tmpstream;\n \tint allcmptssame;\n \tjp2_bpcc_t *bpcc;\n \tlong len;\n \tuint_fast16_t cmptno;\n \tjp2_colr_t *colr;\n \tchar buf[4096];\n \tuint_fast32_t overhead;\n \tjp2_cdefchan_t *cdefchanent;\n \tjp2_cdef_t *cdef;\n \tint i;\n \tuint_fast32_t typeasoc;\n \tjas_iccprof_t *iccprof;\n \tjas_stream_t *iccstream;\n \tint pos;\n \tint needcdef;\n \tint prec;\n \tint sgnd;\n \n \tbox = 0;\n \ttmpstream = 0;\n \ticcstream = 0;\n \ticcprof = 0;\n \n \tif (jas_image_numcmpts(image) < 1) {\n \t\tjas_eprintf(\"image must have at least one component\\n\");\n \t\tgoto error;\n \t}\n \n \tallcmptssame = 1;\n \tsgnd = jas_image_cmptsgnd(image, 0);\n \tprec = jas_image_cmptprec(image, 0);\n \tfor (i = 1; i < jas_image_numcmpts(image); ++i) {\n \t\tif (jas_image_cmptsgnd(image, i) != sgnd ||\n \t\t  jas_image_cmptprec(image, i) != prec) {\n \t\t\tallcmptssame = 0;\n \t\t\tbreak;\n \t\t}\n \t}\n \n \n \tif (!(box = jp2_box_create(JP2_BOX_JP))) {\n \t\tjas_eprintf(\"cannot create JP box\\n\");\n \t\tgoto error;\n \t}\n \tbox->data.jp.magic = JP2_JP_MAGIC;\n \tif (jp2_box_put(box, out)) {\n \t\tjas_eprintf(\"cannot write JP box\\n\");\n \t\tgoto error;\n \t}\n \tjp2_box_destroy(box);\n \tbox = 0;\n \n \n \tif (!(box = jp2_box_create(JP2_BOX_FTYP))) {\n \t\tjas_eprintf(\"cannot create FTYP box\\n\");\n \t\tgoto error;\n \t}\n \tftyp = &box->data.ftyp;\n \tftyp->majver = JP2_FTYP_MAJVER;\n \tftyp->minver = JP2_FTYP_MINVER;\n \tftyp->numcompatcodes = 1;\n \tftyp->compatcodes[0] = JP2_FTYP_COMPATCODE;\n \tif (jp2_box_put(box, out)) {\n \t\tjas_eprintf(\"cannot write FTYP box\\n\");\n \t\tgoto error;\n \t}\n \tjp2_box_destroy(box);\n \tbox = 0;\n \n \n \tif (!(tmpstream = jas_stream_memopen(0, 0))) {\n \t\tjas_eprintf(\"cannot create temporary stream\\n\");\n \t\tgoto error;\n \t}\n \n \n \tif (!(box = jp2_box_create(JP2_BOX_IHDR))) {\n \t\tjas_eprintf(\"cannot create IHDR box\\n\");\n \t\tgoto error;\n \t}\n \tihdr = &box->data.ihdr;\n \tihdr->width = jas_image_width(image);\n \tihdr->height = jas_image_height(image);\n \tihdr->numcmpts = jas_image_numcmpts(image);\n \tihdr->bpc = allcmptssame ? JP2_SPTOBPC(jas_image_cmptsgnd(image, 0),\n \t  jas_image_cmptprec(image, 0)) : JP2_IHDR_BPCNULL;\n \tihdr->comptype = JP2_IHDR_COMPTYPE;\n \tihdr->csunk = 0;\n \tihdr->ipr = 0;\n \tif (jp2_box_put(box, tmpstream)) {\n \t\tjas_eprintf(\"cannot write IHDR box\\n\");\n \t\tgoto error;\n \t}\n \tjp2_box_destroy(box);\n \tbox = 0;\n \n \n \tif (!allcmptssame) {\n \t\tif (!(box = jp2_box_create(JP2_BOX_BPCC))) {\n \t\t\tjas_eprintf(\"cannot create BPCC box\\n\");\n \t\t\tgoto error;\n \t\t}\n \t\tbpcc = &box->data.bpcc;\n \t\tbpcc->numcmpts = jas_image_numcmpts(image);\n \t\tif (!(bpcc->bpcs = jas_alloc2(bpcc->numcmpts,\n \t\t  sizeof(uint_fast8_t)))) {\n \t\t\tjas_eprintf(\"memory allocation failed\\n\");\n \t\t\tgoto error;\n \t\t}\n \t\tfor (cmptno = 0; cmptno < bpcc->numcmpts; ++cmptno) {\n \t\t\tbpcc->bpcs[cmptno] = JP2_SPTOBPC(jas_image_cmptsgnd(image,\n \t\t\t  cmptno), jas_image_cmptprec(image, cmptno));\n \t\t}\n \t\tif (jp2_box_put(box, tmpstream)) {\n \t\t\tjas_eprintf(\"cannot write BPCC box\\n\");\n \t\t\tgoto error;\n \t\t}\n \t\tjp2_box_destroy(box);\n \t\tbox = 0;\n \t}\n \n \n \tif (!(box = jp2_box_create(JP2_BOX_COLR))) {\n \t\tjas_eprintf(\"cannot create COLR box\\n\");\n \t\tgoto error;\n \t}\n \tcolr = &box->data.colr;\n \tswitch (jas_image_clrspc(image)) {\n \tcase JAS_CLRSPC_SRGB:\n \tcase JAS_CLRSPC_SYCBCR:\n \tcase JAS_CLRSPC_SGRAY:\n \t\tcolr->method = JP2_COLR_ENUM;\n \t\tcolr->csid = clrspctojp2(jas_image_clrspc(image));\n \t\tcolr->pri = JP2_COLR_PRI;\n \t\tcolr->approx = 0;\n \t\tbreak;\n \tdefault:\n \t\tcolr->method = JP2_COLR_ICC;\n \t\tcolr->pri = JP2_COLR_PRI;\n \t\tcolr->approx = 0;\n \t\tif (!jas_image_cmprof(image)) {\n \t\t\tjas_eprintf(\"CM profile is null\\n\");\n \t\t\tgoto error;\n \t\t}\n \t\tif (!(iccprof = jas_iccprof_createfromcmprof(\n \t\t  jas_image_cmprof(image)))) {\n \t\t\tjas_eprintf(\"cannot create ICC profile\\n\");\n \t\t\tgoto error;\n \t\t}\n \t\tif (!(iccstream = jas_stream_memopen(0, 0))) {\n \t\t\tjas_eprintf(\"cannot create temporary stream\\n\");\n \t\t\tgoto error;\n \t\t}\n \t\tif (jas_iccprof_save(iccprof, iccstream)) {\n \t\t\tjas_eprintf(\"cannot write ICC profile\\n\");\n \t\t\tgoto error;\n \t\t}\n \t\tif ((pos = jas_stream_tell(iccstream)) < 0) {\n \t\t\tjas_eprintf(\"cannot get stream position\\n\");\n \t\t\tgoto error;\n \t\t}\n \t\tcolr->iccplen = pos;\n \t\tif (!(colr->iccp = jas_malloc(pos))) {\n \t\t\tjas_eprintf(\"memory allocation failed\\n\");\n \t\t\tgoto error;\n \t\t}\n \t\tjas_stream_rewind(iccstream);\n \t\tif (jas_stream_read(iccstream, colr->iccp, colr->iccplen) !=\n \t\t  colr->iccplen) {\n \t\t\tjas_eprintf(\"cannot read temporary stream\\n\");\n \t\t\tgoto error;\n \t\t}\n \t\tjas_stream_close(iccstream);\n \t\ticcstream = 0;\n \t\tjas_iccprof_destroy(iccprof);\n \t\ticcprof = 0;\n \t\tbreak;\n \t}\n \tif (jp2_box_put(box, tmpstream)) {\n \t\tjas_eprintf(\"cannot write box\\n\");\n \t\tgoto error;\n \t}\n \tjp2_box_destroy(box);\n \tbox = 0;\n \n \tneedcdef = 1;\n \tswitch (jas_clrspc_fam(jas_image_clrspc(image))) {\n \tcase JAS_CLRSPC_FAM_RGB:\n// bug_start\n\t\tif (jas_image_cmpttype(image, 0) ==\n// bug_end\n \t\t  JAS_IMAGE_CT_COLOR(JAS_CLRSPC_CHANIND_RGB_R) &&\n \t\t  jas_image_cmpttype(image, 1) ==\n \t\t  JAS_IMAGE_CT_COLOR(JAS_CLRSPC_CHANIND_RGB_G) &&\n \t\t  jas_image_cmpttype(image, 2) ==\n \t\t  JAS_IMAGE_CT_COLOR(JAS_CLRSPC_CHANIND_RGB_B))\n \t\t\tneedcdef = 0;\n \t\tbreak;\n \tcase JAS_CLRSPC_FAM_YCBCR:\n// bug_start\n\t\tif (jas_image_cmpttype(image, 0) ==\n// bug_end\n \t\t  JAS_IMAGE_CT_COLOR(JAS_CLRSPC_CHANIND_YCBCR_Y) &&\n \t\t  jas_image_cmpttype(image, 1) ==\n \t\t  JAS_IMAGE_CT_COLOR(JAS_CLRSPC_CHANIND_YCBCR_CB) &&\n \t\t  jas_image_cmpttype(image, 2) ==\n \t\t  JAS_IMAGE_CT_COLOR(JAS_CLRSPC_CHANIND_YCBCR_CR))\n \t\t\tneedcdef = 0;\n \t\tbreak;\n \tcase JAS_CLRSPC_FAM_GRAY:\n// bug_start\n\t\tif (jas_image_cmpttype(image, 0) ==\n// bug_end\n \t\t  JAS_IMAGE_CT_COLOR(JAS_IMAGE_CT_GRAY_Y))\n \t\t\tneedcdef = 0;\n \t\tbreak;\n \tdefault:\n \t\tabort();\n \t\tbreak;\n \t}\n \n \tif (needcdef) {\n \t\tif (!(box = jp2_box_create(JP2_BOX_CDEF))) {\n \t\t\tjas_eprintf(\"cannot create CDEF box\\n\");\n \t\t\tgoto error;\n \t\t}\n \t\tcdef = &box->data.cdef;\n \t\tcdef->numchans = jas_image_numcmpts(image);\n \t\tcdef->ents = jas_alloc2(cdef->numchans, sizeof(jp2_cdefchan_t));\n \t\tfor (i = 0; i < jas_image_numcmpts(image); ++i) {\n \t\t\tcdefchanent = &cdef->ents[i];\n \t\t\tcdefchanent->channo = i;\n \t\t\ttypeasoc = jp2_gettypeasoc(jas_image_clrspc(image), jas_image_cmpttype(image, i));\n \t\t\tcdefchanent->type = typeasoc >> 16;\n \t\t\tcdefchanent->assoc = typeasoc & 0x7fff;\n \t\t}\n \t\tif (jp2_box_put(box, tmpstream)) {\n \t\t\tjas_eprintf(\"cannot write CDEF box\\n\");\n \t\t\tgoto error;\n \t\t}\n \t\tjp2_box_destroy(box);\n \t\tbox = 0;\n \t}\n \n \n \tlen = jas_stream_tell(tmpstream);\n \tjas_stream_rewind(tmpstream);\n \n \n \tif (!(box = jp2_box_create(JP2_BOX_JP2H))) {\n \t\tjas_eprintf(\"cannot create JP2H box\\n\");\n \t\tgoto error;\n \t}\n \tbox->len = len + JP2_BOX_HDRLEN(false);\n \tif (jp2_box_put(box, out)) {\n \t\tjas_eprintf(\"cannot write JP2H box\\n\");\n \t\tgoto error;\n \t}\n \tjp2_box_destroy(box);\n \tbox = 0;\n \n \tif (jas_stream_copy(out, tmpstream, len)) {\n \t\tjas_eprintf(\"cannot copy stream\\n\");\n \t\tgoto error;\n \t}\n \n \tjas_stream_close(tmpstream);\n \ttmpstream = 0;\n \n \n \tif (!(box = jp2_box_create(JP2_BOX_JP2C))) {\n \t\tjas_eprintf(\"cannot create JP2C box\\n\");\n \t\tgoto error;\n \t}\n \tbox->len = 0;\n \tif (jp2_box_put(box, out)) {\n \t\tjas_eprintf(\"cannot write JP2C box\\n\");\n \t\tgoto error;\n \t}\n \tjp2_box_destroy(box);\n \tbox = 0;\n \n \n \toverhead = jas_stream_getrwcount(out);\n \tsprintf(buf, \"%s\\n_jp2overhead=%lu\\n\", (optstr ? optstr : \"\"),\n \t  (unsigned long) overhead);\n \n \tif (jpc_encode(image, out, buf)) {\n \t\tjas_eprintf(\"jpc_encode failed\\n\");\n \t\tgoto error;\n \t}\n \n \treturn 0;\n \n error:\n \n \tif (iccprof) {\n \t\tjas_iccprof_destroy(iccprof);\n \t}\n \tif (iccstream) {\n \t\tjas_stream_close(iccstream);\n \t}\n \tif (box) {\n \t\tjp2_box_destroy(box);\n \t}\n \tif (tmpstream) {\n \t\tjas_stream_close(tmpstream);\n \t}\n \treturn -1;\n }\n \n", "target": "// fix_start\n\t\tif (jas_image_numcmpts(image) >= 3 &&\n\t\t  jas_image_cmpttype(image, 0) ==\n// fix_end\n// fix_start\n\t\tif (jas_image_numcmpts(image) >= 3 &&\n\t\t  jas_image_cmpttype(image, 0) ==\n// fix_end\n// fix_start\n\t\tif (jas_image_numcmpts(image) >= 1 &&\n\t\t  jas_image_cmpttype(image, 0) ==\n// fix_end\n", "cwe": "CWE-125", "cwe_name": "Out-of-bounds Read", "cve": "CVE-2018-20570", "cve_desc": "jp2_encode in jp2/jp2_enc.c in JasPer 2.0.14 has a heap-based buffer over-read.", "project": "jasper", "idx": 211483}
{"source": " static BOOL clear_decompress_subcode_rlex(wStream* s, UINT32 bitmapDataByteCount, UINT32 width,\n                                           UINT32 height, BYTE* pDstData, UINT32 DstFormat,\n                                           UINT32 nDstStep, UINT32 nXDstRel, UINT32 nYDstRel,\n                                           UINT32 nDstWidth, UINT32 nDstHeight)\n {\n \tUINT32 x = 0, y = 0;\n \tUINT32 i;\n \tUINT32 pixelCount;\n \tUINT32 bitmapDataOffset;\n// bug_start\n\tUINT32 pixelIndex;\n// bug_end\n \tUINT32 numBits;\n \tBYTE startIndex;\n \tBYTE stopIndex;\n \tBYTE suiteIndex;\n \tBYTE suiteDepth;\n \tBYTE paletteCount;\n \tUINT32 palette[128] = { 0 };\n \n \tif (Stream_GetRemainingLength(s) < bitmapDataByteCount)\n \t{\n \t\tWLog_ERR(TAG, \"stream short %\" PRIuz \" [%\" PRIu32 \" expected]\",\n \t\t         Stream_GetRemainingLength(s), bitmapDataByteCount);\n \t\treturn FALSE;\n \t}\n \n// bug_start\n// bug_end\n \tStream_Read_UINT8(s, paletteCount);\n \tbitmapDataOffset = 1 + (paletteCount * 3);\n \n \tif ((paletteCount > 127) || (paletteCount < 1))\n \t{\n \t\tWLog_ERR(TAG, \"paletteCount %\" PRIu8 \"\", paletteCount);\n \t\treturn FALSE;\n \t}\n// bug_start\n// bug_end\n \n \tfor (i = 0; i < paletteCount; i++)\n \t{\n \t\tBYTE r, g, b;\n \t\tStream_Read_UINT8(s, b);\n \t\tStream_Read_UINT8(s, g);\n \t\tStream_Read_UINT8(s, r);\n \t\tpalette[i] = FreeRDPGetColor(DstFormat, r, g, b, 0xFF);\n \t}\n \n \tpixelIndex = 0;\n \tpixelCount = width * height;\n \tnumBits = CLEAR_LOG2_FLOOR[paletteCount - 1] + 1;\n \n \twhile (bitmapDataOffset < bitmapDataByteCount)\n \t{\n \t\tUINT32 tmp;\n \t\tUINT32 color;\n \t\tUINT32 runLengthFactor;\n \n \t\tif (Stream_GetRemainingLength(s) < 2)\n \t\t{\n \t\t\tWLog_ERR(TAG, \"stream short %\" PRIuz \" [2 expected]\", Stream_GetRemainingLength(s));\n \t\t\treturn FALSE;\n \t\t}\n \n \t\tStream_Read_UINT8(s, tmp);\n \t\tStream_Read_UINT8(s, runLengthFactor);\n \t\tbitmapDataOffset += 2;\n \t\tsuiteDepth = (tmp >> numBits) & CLEAR_8BIT_MASKS[(8 - numBits)];\n \t\tstopIndex = tmp & CLEAR_8BIT_MASKS[numBits];\n \t\tstartIndex = stopIndex - suiteDepth;\n \n \t\tif (runLengthFactor >= 0xFF)\n \t\t{\n \t\t\tif (Stream_GetRemainingLength(s) < 2)\n \t\t\t{\n \t\t\t\tWLog_ERR(TAG, \"stream short %\" PRIuz \" [2 expected]\", Stream_GetRemainingLength(s));\n \t\t\t\treturn FALSE;\n \t\t\t}\n \n \t\t\tStream_Read_UINT16(s, runLengthFactor);\n \t\t\tbitmapDataOffset += 2;\n \n \t\t\tif (runLengthFactor >= 0xFFFF)\n \t\t\t{\n \t\t\t\tif (Stream_GetRemainingLength(s) < 4)\n \t\t\t\t{\n \t\t\t\t\tWLog_ERR(TAG, \"stream short %\" PRIuz \" [4 expected]\",\n \t\t\t\t\t         Stream_GetRemainingLength(s));\n \t\t\t\t\treturn FALSE;\n \t\t\t\t}\n \n \t\t\t\tStream_Read_UINT32(s, runLengthFactor);\n \t\t\t\tbitmapDataOffset += 4;\n \t\t\t}\n \t\t}\n \n \t\tif (startIndex >= paletteCount)\n \t\t{\n \t\t\tWLog_ERR(TAG, \"startIndex %\" PRIu8 \" > paletteCount %\" PRIu8 \"]\", startIndex,\n \t\t\t         paletteCount);\n \t\t\treturn FALSE;\n \t\t}\n \n \t\tif (stopIndex >= paletteCount)\n \t\t{\n \t\t\tWLog_ERR(TAG, \"stopIndex %\" PRIu8 \" > paletteCount %\" PRIu8 \"]\", stopIndex,\n \t\t\t         paletteCount);\n \t\t\treturn FALSE;\n \t\t}\n \n \t\tsuiteIndex = startIndex;\n \n \t\tif (suiteIndex > 127)\n \t\t{\n \t\t\tWLog_ERR(TAG, \"suiteIndex %\" PRIu8 \" > 127]\", suiteIndex);\n \t\t\treturn FALSE;\n \t\t}\n \n \t\tcolor = palette[suiteIndex];\n \n \t\tif ((pixelIndex + runLengthFactor) > pixelCount)\n \t\t{\n \t\t\tWLog_ERR(TAG,\n \t\t\t         \"pixelIndex %\" PRIu32 \" + runLengthFactor %\" PRIu32 \" > pixelCount %\" PRIu32\n \t\t\t         \"\",\n \t\t\t         pixelIndex, runLengthFactor, pixelCount);\n \t\t\treturn FALSE;\n \t\t}\n \n \t\tfor (i = 0; i < runLengthFactor; i++)\n \t\t{\n \t\t\tBYTE* pTmpData =\n \t\t\t    &pDstData[(nXDstRel + x) * GetBytesPerPixel(DstFormat) + (nYDstRel + y) * nDstStep];\n \n \t\t\tif ((nXDstRel + x < nDstWidth) && (nYDstRel + y < nDstHeight))\n \t\t\t\tWriteColor(pTmpData, DstFormat, color);\n \n \t\t\tif (++x >= width)\n \t\t\t{\n \t\t\t\ty++;\n \t\t\t\tx = 0;\n \t\t\t}\n \t\t}\n \n \t\tpixelIndex += runLengthFactor;\n \n \t\tif ((pixelIndex + (suiteDepth + 1)) > pixelCount)\n \t\t{\n \t\t\tWLog_ERR(TAG,\n \t\t\t         \"pixelIndex %\" PRIu32 \" + suiteDepth %\" PRIu8 \" + 1 > pixelCount %\" PRIu32 \"\",\n \t\t\t         pixelIndex, suiteDepth, pixelCount);\n \t\t\treturn FALSE;\n \t\t}\n \n \t\tfor (i = 0; i <= suiteDepth; i++)\n \t\t{\n \t\t\tBYTE* pTmpData =\n \t\t\t    &pDstData[(nXDstRel + x) * GetBytesPerPixel(DstFormat) + (nYDstRel + y) * nDstStep];\n \t\t\tUINT32 color = palette[suiteIndex];\n \n \t\t\tif (suiteIndex > 127)\n \t\t\t{\n \t\t\t\tWLog_ERR(TAG, \"suiteIndex %\" PRIu8 \" > 127\", suiteIndex);\n \t\t\t\treturn FALSE;\n \t\t\t}\n \n \t\t\tsuiteIndex++;\n \n \t\t\tif ((nXDstRel + x < nDstWidth) && (nYDstRel + y < nDstHeight))\n \t\t\t\tWriteColor(pTmpData, DstFormat, color);\n \n \t\t\tif (++x >= width)\n \t\t\t{\n \t\t\t\ty++;\n \t\t\t\tx = 0;\n \t\t\t}\n \t\t}\n \n \t\tpixelIndex += (suiteDepth + 1);\n \t}\n \n \tif (pixelIndex != pixelCount)\n \t{\n// bug_start\n\t\tWLog_ERR(TAG, \"pixelIndex %\" PRIu32 \" != pixelCount %\" PRIu32 \"\", pixelIndex, pixelCount);\n// bug_end\n \t\treturn FALSE;\n \t}\n \n \treturn TRUE;\n }\n \n", "target": "// fix_start\n\tsize_t pixelIndex;\n// fix_end\n// fix_start\n\tif (Stream_GetRemainingLength(s) < 1)\n\t\treturn FALSE;\n// fix_end\n// fix_start\n\n\tif (Stream_GetRemainingLength(s) < 3ULL * paletteCount)\n\t\treturn FALSE;\n// fix_end\n// fix_start\n\t\tWLog_ERR(TAG, \"pixelIndex %\" PRIdz \" != pixelCount %\" PRIu32 \"\", pixelIndex, pixelCount);\n// fix_end\n", "cwe": "CWE-125", "cwe_name": "Out-of-bounds Read", "cve": "CVE-2020-11040", "cve_desc": "In FreeRDP less than or equal to 2.0.0, there is an out-of-bound data read from memory in clear_decompress_subcode_rlex, visualized on screen as color. This has been patched in 2.1.0.", "project": "FreeRDP", "idx": 211489}
{"source": " ImagingFliDecode(Imaging im, ImagingCodecState state, UINT8* buf, Py_ssize_t bytes)\n {\n     UINT8* ptr;\n     int framesize;\n     int c, chunks, advance;\n     int l, lines;\n     int i, j, x = 0, y, ymax;\n \n \n     if (bytes < 4)\n \treturn 0;\n \n \n     ptr = buf;\n \n     framesize = I32(ptr);\n     if (framesize < I32(ptr))\n \treturn 0;\n \n \n// bug_start\n// bug_end\n     if (I16(ptr+4) != 0xF1FA) {\n \tstate->errcode = IMAGING_CODEC_UNKNOWN;\n \treturn -1;\n     }\n \n     chunks = I16(ptr+6);\n     ptr += 16;\n     bytes -= 16;\n \n     for (c = 0; c < chunks; c++) {\n \tUINT8* data;\n \tif (bytes < 10) {\n \t    state->errcode = IMAGING_CODEC_OVERRUN;\n \t    return -1;\n \t}\n \tdata = ptr + 6;\n \tswitch (I16(ptr+4)) {\n \tcase 4: case 11:\n \t    break;\n \tcase 7:\n \t    lines = I16(data); data += 2;\n \t    for (l = y = 0; l < lines && y < state->ysize; l++, y++) {\n \t\tUINT8* buf = (UINT8*) im->image[y];\n \t\tint p, packets;\n \t\tpackets = I16(data); data += 2;\n \t\twhile (packets & 0x8000) {\n \t\t    if (packets & 0x4000) {\n \t\t\ty += 65536 - packets;\n \t\t\tif (y >= state->ysize) {\n \t\t\t    state->errcode = IMAGING_CODEC_OVERRUN;\n \t\t\t    return -1;\n \t\t\t}\n \t\t\tbuf = (UINT8*) im->image[y];\n \t\t    } else {\n \t\t\tbuf[state->xsize-1] = (UINT8) packets;\n \t\t    }\n \t\t    packets = I16(data); data += 2;\n \t\t}\n \t\tfor (p = x = 0; p < packets; p++) {\n \t\t    x += data[0];\n \t\t    if (data[1] >= 128) {\n \t\t\ti = 256-data[1];\n \t\t\tif (x + i + i > state->xsize)\n \t\t\t    break;\n \t\t\tfor (j = 0; j < i; j++) {\n \t\t\t    buf[x++] = data[2];\n \t\t\t    buf[x++] = data[3];\n \t\t\t}\n \t\t\tdata += 2 + 2;\n \t\t    } else {\n \t\t\ti = 2 * (int) data[1];\n \t\t\tif (x + i > state->xsize)\n \t\t\t    break;\n \t\t\tmemcpy(buf + x, data + 2, i);\n \t\t\tdata += 2 + i;\n \t\t\tx += i;\n \t\t    }\n \t\t}\n \t\tif (p < packets)\n \t\t    break;\n \t    }\n \t    if (l < lines) {\n \t\tstate->errcode = IMAGING_CODEC_OVERRUN;\n \t\treturn -1;\n \t    }\n \t    break;\n \tcase 12:\n \t    y = I16(data); ymax = y + I16(data+2); data += 4;\n \t    for (; y < ymax && y < state->ysize; y++) {\n \t\tUINT8* out = (UINT8*) im->image[y];\n \t\tint p, packets = *data++;\n \t\tfor (p = x = 0; p < packets; p++, x += i) {\n \t\t    x += data[0];\n \t\t    if (data[1] & 0x80) {\n \t\t\ti = 256-data[1];\n \t\t\tif (x + i > state->xsize)\n \t\t\t    break;\n \t\t\tmemset(out + x, data[2], i);\n \t\t\tdata += 3;\n \t\t    } else {\n \t\t\ti = data[1];\n \t\t\tif (x + i > state->xsize)\n \t\t\t    break;\n \t\t\tmemcpy(out + x, data + 2, i);\n \t\t\tdata += i + 2;\n \t\t    }\n \t\t}\n \t\tif (p < packets)\n \t\t    break;\n \t    }\n \t    if (y < ymax) {\n \t\tstate->errcode = IMAGING_CODEC_OVERRUN;\n \t\treturn -1;\n \t    }\n \t    break;\n \tcase 13:\n \t    for (y = 0; y < state->ysize; y++)\n \t\tmemset(im->image[y], 0, state->xsize);\n \t    break;\n \tcase 15:\n \t    for (y = 0; y < state->ysize; y++) {\n \t\tUINT8* out = (UINT8*) im->image[y];\n \t\tdata += 1;\n \t\tfor (x = 0; x < state->xsize; x += i) {\n \t\t    if (data[0] & 0x80) {\n \t\t\ti = 256 - data[0];\n \t\t\tif (x + i > state->xsize)\n \t\t\t    break;\n \t\t\tmemcpy(out + x, data + 1, i);\n \t\t\tdata += i + 1;\n \t\t    } else {\n \t\t\ti = data[0];\n \t\t\tif (x + i > state->xsize)\n \t\t\t    break;\n \t\t\tmemset(out + x, data[1], i);\n \t\t\tdata += 2;\n \t\t    }\n \t\t}\n \t\tif (x != state->xsize) {\n \t\t    state->errcode = IMAGING_CODEC_OVERRUN;\n \t\t    return -1;\n \t\t}\n \t    }\n \t    break;\n \tcase 16:\n \t    for (y = 0; y < state->ysize; y++) {\n \t\tUINT8* buf = (UINT8*) im->image[y];\n \t\tmemcpy(buf, data, state->xsize);\n \t\tdata += state->xsize;\n \t    }\n \t    break;\n \tcase 18:\n \t    break;\n \tdefault:\n \t    state->errcode = IMAGING_CODEC_UNKNOWN;\n \t    return -1;\n \t}\n \tadvance = I32(ptr);\n \tptr += advance;\n \tbytes -= advance;\n     }\n \n     return -1;\n }\n \n", "target": "// fix_start\n    if (bytes < 8) {\n        state->errcode = IMAGING_CODEC_OVERRUN;\n        return -1;\n    }\n// fix_end\n", "cwe": "CWE-787", "cwe_name": "Out-of-bounds Write", "cve": "CVE-2020-5313", "cve_desc": "libImaging/FliDecode.c in Pillow before 6.2.2 has an FLI buffer overflow.", "project": "Pillow", "idx": 211493}
{"source": " bool RGWSwiftWebsiteHandler::is_web_dir() const\n {\n   std::string subdir_name = url_decode(s->object.name);\n \n   if (subdir_name.empty()) {\n     return false;\n   } else if (subdir_name.back() == '/') {\n     subdir_name.pop_back();\n// bug_start\n// bug_end\n   }\n \n   rgw_obj obj(s->bucket, std::move(subdir_name));\n \n   RGWObjectCtx& obj_ctx = *static_cast<RGWObjectCtx *>(s->obj_ctx);\n   obj_ctx.set_atomic(obj);\n   obj_ctx.set_prefetch_data(obj);\n \n   RGWObjState* state = nullptr;\n   if (store->get_obj_state(&obj_ctx, s->bucket_info, obj, &state, false) < 0) {\n     return false;\n   }\n \n   if (! state->exists) {\n     return false;\n   }\n \n   std::string content_type;\n   get_contype_from_attrs(state->attrset, content_type);\n \n   const auto& ws_conf = s->bucket_info.website_conf;\n   const std::string subdir_marker = ws_conf.subdir_marker.empty()\n                                       ? \"application/directory\"\n                                       : ws_conf.subdir_marker;\n   return subdir_marker == content_type && state->size <= 1;\n }\n \n", "target": "// fix_start\n    if (subdir_name.empty()) {\n      return false;\n    }\n// fix_end\n", "cwe": "CWE-617", "cwe_name": "Reachable Assertion", "cve": "CVE-2021-3531", "cve_desc": "A flaw was found in the Red Hat Ceph Storage RGW in versions before 14.2.21. When processing a GET Request for a swift URL that ends with two slashes it can cause the rgw to crash, resulting in a denial of service. The greatest threat to the system is of availability.", "project": "ceph", "idx": 211502}
{"source": " PJ_DEF(pj_status_t) pjmedia_sdp_neg_modify_local_offer2(\n                                     pj_pool_t *pool,\n \t\t\t\t    pjmedia_sdp_neg *neg,\n                                     unsigned flags,\n \t\t\t\t    const pjmedia_sdp_session *local)\n {\n     pjmedia_sdp_session *new_offer;\n     pjmedia_sdp_session *old_offer;\n// bug_start\n    char media_used[PJMEDIA_MAX_SDP_MEDIA];\n// bug_end\n     unsigned oi;\n     pj_status_t status;\n \n     PJ_ASSERT_RETURN(pool && neg && local, PJ_EINVAL);\n \n     PJ_ASSERT_RETURN(neg->state == PJMEDIA_SDP_NEG_STATE_DONE,\n \t\t     PJMEDIA_SDPNEG_EINSTATE);\n \n     status = pjmedia_sdp_validate(local);\n     if (status != PJ_SUCCESS)\n \treturn status;\n \n     neg->state = PJMEDIA_SDP_NEG_STATE_LOCAL_OFFER;\n \n// bug_start\n    pj_bzero(media_used, sizeof(media_used));\n// bug_end\n     old_offer = neg->active_local_sdp;\n     new_offer = pjmedia_sdp_session_clone(pool, local);\n \n     pj_strdup(pool, &new_offer->origin.user, &old_offer->origin.user);\n     new_offer->origin.id = old_offer->origin.id;\n \n     pj_strdup(pool, &new_offer->origin.net_type, &old_offer->origin.net_type);\n     pj_strdup(pool, &new_offer->origin.addr_type,&old_offer->origin.addr_type);\n     pj_strdup(pool, &new_offer->origin.addr, &old_offer->origin.addr);\n \n     if ((flags & PJMEDIA_SDP_NEG_ALLOW_MEDIA_CHANGE) == 0) {\n         for (oi = 0; oi < old_offer->media_count; ++oi) {\n \t    pjmedia_sdp_media *om;\n \t    pjmedia_sdp_media *nm;\n \t    unsigned ni;\n \t    pj_bool_t found = PJ_FALSE;\n \n \t    om = old_offer->media[oi];\n \t    for (ni = oi; ni < new_offer->media_count; ++ni) {\n \t        nm = new_offer->media[ni];\n \t        if (pj_strcmp(&nm->desc.media, &om->desc.media) == 0) {\n \t\t    if (ni != oi) {\n \t\t        pj_array_insert(\n                             new_offer->media,\n \t\t\t    sizeof(new_offer->media[0]),\n \t\t\t    ni,\n \t\t            oi,\n \t\t\t    &nm);\n \t\t    }\n \t\t    found = PJ_TRUE;\n \t\t    break;\n \t        }\n \t    }\n \t    if (!found) {\n \t        pjmedia_sdp_media *m;\n \n \t        m = sdp_media_clone_deactivate(pool, om, om, local);\n \n \t        pj_array_insert(new_offer->media, sizeof(new_offer->media[0]),\n \t\t\t        new_offer->media_count++, oi, &m);\n \t    }\n         }\n     } else {\n         for (oi = new_offer->media_count; oi < old_offer->media_count; ++oi) {\n             pjmedia_sdp_media *m;\n \n \t    m = sdp_media_clone_deactivate(pool, old_offer->media[oi],\n                                            old_offer->media[oi], local);\n \n \t    pj_array_insert(new_offer->media, sizeof(new_offer->media[0]),\n \t                    new_offer->media_count++, oi, &m);\n \n         }\n     }\n \n #if PJMEDIA_SDP_NEG_COMPARE_BEFORE_INC_VERSION\n     new_offer->origin.version = old_offer->origin.version;\n \n     if (pjmedia_sdp_session_cmp(new_offer, neg->initial_sdp, 0) != PJ_SUCCESS)\n     {\n \t++new_offer->origin.version;\n     }\n #else\n     new_offer->origin.version = old_offer->origin.version + 1;\n #endif\n \n     neg->initial_sdp_tmp = neg->initial_sdp;\n     neg->initial_sdp = new_offer;\n     neg->neg_local_sdp = pjmedia_sdp_session_clone(pool, new_offer);\n \n     return PJ_SUCCESS;\n }\n \n", "target": "// fix_start\n// fix_end\n// fix_start\n    if (!neg->active_local_sdp) {\n\tneg->initial_sdp_tmp = NULL;\n\tneg->initial_sdp = pjmedia_sdp_session_clone(pool, local);\n\tneg->neg_local_sdp = pjmedia_sdp_session_clone(pool, local);\n\n\treturn PJ_SUCCESS;\n    }\n\n// fix_end\n", "cwe": "CWE-200", "cwe_name": "Exposure of Sensitive Information to an Unauthorized Actor", "cve": "CVE-2021-21375", "cve_desc": "PJSIP is a free and open source multimedia communication library written in C language implementing standard based protocols such as SIP, SDP, RTP, STUN, TURN, and ICE. In PJSIP version 2.10 and earlier, after an initial INVITE has been sent, when two 183 responses are received, with the first one causing negotiation failure, a crash will occur. This results in a denial of service.", "project": "pjproject", "idx": 211591}
{"source": " static int __init lp_setup (char *str)\n {\n \tstatic int parport_ptr;\n \tint x;\n \n \tif (get_option(&str, &x)) {\n \t\tif (x == 0) {\n \t\t\tparport_nr[0] = LP_PARPORT_OFF;\n \t\t} else {\n \t\t\tprintk(KERN_WARNING \"warning: 'lp=0x%x' is deprecated, ignored\\n\", x);\n \t\t\treturn 0;\n \t\t}\n \t} else if (!strncmp(str, \"parport\", 7)) {\n \t\tint n = simple_strtoul(str+7, NULL, 10);\n \t\tif (parport_ptr < LP_NO)\n \t\t\tparport_nr[parport_ptr++] = n;\n \t\telse\n \t\t\tprintk(KERN_INFO \"lp: too many ports, %s ignored.\\n\",\n \t\t\t       str);\n \t} else if (!strcmp(str, \"auto\")) {\n \t\tparport_nr[0] = LP_PARPORT_AUTO;\n \t} else if (!strcmp(str, \"none\")) {\n// bug_start\n\t\tparport_nr[parport_ptr++] = LP_PARPORT_NONE;\n// bug_end\n \t} else if (!strcmp(str, \"reset\")) {\n \t\treset = 1;\n \t}\n \treturn 1;\n }\n \n", "target": "// fix_start\n\t\tif (parport_ptr < LP_NO)\n\t\t\tparport_nr[parport_ptr++] = LP_PARPORT_NONE;\n\t\telse\n\t\t\tprintk(KERN_INFO \"lp: too many ports, %s ignored.\\n\",\n\t\t\t       str);\n// fix_end\n", "cwe": "CWE-787", "cwe_name": "Out-of-bounds Write", "cve": "CVE-2017-1000363", "cve_desc": "Linux drivers/char/lp.c Out-of-Bounds Write. Due to a missing bounds check, and the fact that parport_ptr integer is static, a 'secure boot' kernel command line adversary (can happen due to bootloader vulns, e.g. Google Nexus 6's CVE-2016-10277, where due to a vulnerability the adversary has partial control over the command line) can overflow the parport_nr array in the following code, by appending many (>LP_NO) 'lp=none' arguments to the command line.", "project": "linux", "idx": 211709}
{"source": " static struct ext4_dir_entry_2 *do_split(handle_t *handle, struct inode *dir,\n \t\t\tstruct buffer_head **bh,struct dx_frame *frame,\n \t\t\tstruct dx_hash_info *hinfo)\n {\n \tunsigned blocksize = dir->i_sb->s_blocksize;\n \tunsigned count, continued;\n \tstruct buffer_head *bh2;\n \text4_lblk_t newblock;\n \tu32 hash2;\n \tstruct dx_map_entry *map;\n \tchar *data1 = (*bh)->b_data, *data2;\n \tunsigned split, move, size;\n \tstruct ext4_dir_entry_2 *de = NULL, *de2;\n \tint\tcsum_size = 0;\n \tint\terr = 0, i;\n \n \tif (ext4_has_metadata_csum(dir->i_sb))\n \t\tcsum_size = sizeof(struct ext4_dir_entry_tail);\n \n \tbh2 = ext4_append(handle, dir, &newblock);\n \tif (IS_ERR(bh2)) {\n \t\tbrelse(*bh);\n \t\t*bh = NULL;\n \t\treturn (struct ext4_dir_entry_2 *) bh2;\n \t}\n \n \tBUFFER_TRACE(*bh, \"get_write_access\");\n \terr = ext4_journal_get_write_access(handle, *bh);\n \tif (err)\n \t\tgoto journal_error;\n \n \tBUFFER_TRACE(frame->bh, \"get_write_access\");\n \terr = ext4_journal_get_write_access(handle, frame->bh);\n \tif (err)\n \t\tgoto journal_error;\n \n \tdata2 = bh2->b_data;\n \n \tmap = (struct dx_map_entry *) (data2 + blocksize);\n \tcount = dx_make_map(dir, (struct ext4_dir_entry_2 *) data1,\n \t\t\t     blocksize, hinfo, map);\n \tmap -= count;\n \tdx_sort_map(map, count);\n \tsize = 0;\n \tmove = 0;\n \tfor (i = count-1; i >= 0; i--) {\n \t\tif (size + map[i].size/2 > blocksize/2)\n \t\t\tbreak;\n \t\tsize += map[i].size;\n \t\tmove++;\n \t}\n// bug_start\n\tsplit = count - move;\n// bug_end\n \thash2 = map[split].hash;\n \tcontinued = hash2 == map[split - 1].hash;\n \tdxtrace(printk(KERN_INFO \"Split block %lu at %x, %i/%i\\n\",\n \t\t\t(unsigned long)dx_get_block(frame->at),\n \t\t\t\t\thash2, split, count-split));\n \n \tde2 = dx_move_dirents(data1, data2, map + split, count - split,\n \t\t\t      blocksize);\n \tde = dx_pack_dirents(data1, blocksize);\n \tde->rec_len = ext4_rec_len_to_disk(data1 + (blocksize - csum_size) -\n \t\t\t\t\t   (char *) de,\n \t\t\t\t\t   blocksize);\n \tde2->rec_len = ext4_rec_len_to_disk(data2 + (blocksize - csum_size) -\n \t\t\t\t\t    (char *) de2,\n \t\t\t\t\t    blocksize);\n \tif (csum_size) {\n \t\text4_initialize_dirent_tail(*bh, blocksize);\n \t\text4_initialize_dirent_tail(bh2, blocksize);\n \t}\n \n \tdxtrace(dx_show_leaf(dir, hinfo, (struct ext4_dir_entry_2 *) data1,\n \t\t\tblocksize, 1));\n \tdxtrace(dx_show_leaf(dir, hinfo, (struct ext4_dir_entry_2 *) data2,\n \t\t\tblocksize, 1));\n \n \tif (hinfo->hash >= hash2) {\n \t\tswap(*bh, bh2);\n \t\tde = de2;\n \t}\n \tdx_insert_block(frame, hash2 + continued, newblock);\n \terr = ext4_handle_dirty_dirblock(handle, dir, bh2);\n \tif (err)\n \t\tgoto journal_error;\n \terr = ext4_handle_dirty_dx_node(handle, dir, frame->bh);\n \tif (err)\n \t\tgoto journal_error;\n \tbrelse(bh2);\n \tdxtrace(dx_show_index(\"frame\", frame->entries));\n \treturn de;\n \n journal_error:\n \tbrelse(*bh);\n \tbrelse(bh2);\n \t*bh = NULL;\n \text4_std_error(dir->i_sb, err);\n \treturn ERR_PTR(err);\n }\n \n", "target": "// fix_start\n\tif (i > 0)\n\t\tsplit = count - move;\n\telse\n\t\tsplit = count/2;\n\n// fix_end\n", "cwe": "CWE-125", "cwe_name": "Out-of-bounds Read", "cve": "CVE-2020-14314", "cve_desc": "A memory out-of-bounds read flaw was found in the Linux kernel before 5.9-rc2 with the ext3/ext4 file system, in the way it accesses a directory with broken indexing. This flaw allows a local user to crash the system if the directory exists. The highest threat from this vulnerability is to system availability.", "project": "linux", "idx": 211725}
{"source": " int ImagingLibTiffDecode(Imaging im, ImagingCodecState state, UINT8* buffer, Py_ssize_t bytes) {\n     TIFFSTATE *clientstate = (TIFFSTATE *)state->context;\n     char *filename = \"tempfile.tif\";\n     char *mode = \"r\";\n     TIFF *tiff;\n \n \n     TRACE((\"in decoder: bytes %d\\n\", bytes));\n     TRACE((\"State: count %d, state %d, x %d, y %d, ystep %d\\n\", state->count, state->state,\n            state->x, state->y, state->ystep));\n     TRACE((\"State: xsize %d, ysize %d, xoff %d, yoff %d \\n\", state->xsize, state->ysize,\n            state->xoff, state->yoff));\n     TRACE((\"State: bits %d, bytes %d \\n\", state->bits, state->bytes));\n     TRACE((\"Buffer: %p: %c%c%c%c\\n\", buffer, (char)buffer[0], (char)buffer[1],(char)buffer[2], (char)buffer[3]));\n     TRACE((\"State->Buffer: %c%c%c%c\\n\", (char)state->buffer[0], (char)state->buffer[1],(char)state->buffer[2], (char)state->buffer[3]));\n     TRACE((\"Image: mode %s, type %d, bands: %d, xsize %d, ysize %d \\n\",\n            im->mode, im->type, im->bands, im->xsize, im->ysize));\n     TRACE((\"Image: image8 %p, image32 %p, image %p, block %p \\n\",\n            im->image8, im->image32, im->image, im->block));\n     TRACE((\"Image: pixelsize: %d, linesize %d \\n\",\n            im->pixelsize, im->linesize));\n \n     dump_state(clientstate);\n     clientstate->size = bytes;\n     clientstate->eof = clientstate->size;\n     clientstate->loc = 0;\n     clientstate->data = (tdata_t)buffer;\n     clientstate->flrealloc = 0;\n     dump_state(clientstate);\n \n     TIFFSetWarningHandler(NULL);\n     TIFFSetWarningHandlerExt(NULL);\n \n     if (clientstate->fp) {\n         TRACE((\"Opening using fd: %d\\n\",clientstate->fp));\n         lseek(clientstate->fp,0,SEEK_SET);\n         tiff = TIFFFdOpen(clientstate->fp, filename, mode);\n     } else {\n         TRACE((\"Opening from string\\n\"));\n         tiff = TIFFClientOpen(filename, mode,\n                               (thandle_t) clientstate,\n                               _tiffReadProc, _tiffWriteProc,\n                               _tiffSeekProc, _tiffCloseProc, _tiffSizeProc,\n                               _tiffMapProc, _tiffUnmapProc);\n     }\n \n     if (!tiff){\n         TRACE((\"Error, didn't get the tiff\\n\"));\n         state->errcode = IMAGING_CODEC_BROKEN;\n         return -1;\n     }\n \n     if (clientstate->ifd){\n         int rv;\n         uint32 ifdoffset = clientstate->ifd;\n         TRACE((\"reading tiff ifd %u\\n\", ifdoffset));\n         rv = TIFFSetSubDirectory(tiff, ifdoffset);\n         if (!rv){\n             TRACE((\"error in TIFFSetSubDirectory\"));\n             return -1;\n         }\n     }\n \n     if (TIFFIsTiled(tiff)) {\n         UINT32 x, y, tile_y, row_byte_size;\n         UINT32 tile_width, tile_length, current_tile_width;\n         UINT8 *new_data;\n \n         TIFFGetField(tiff, TIFFTAG_TILEWIDTH, &tile_width);\n         TIFFGetField(tiff, TIFFTAG_TILELENGTH, &tile_length);\n \n         row_byte_size = (tile_width * state->bits + 7) / 8;\n// bug_start\n        state->bytes = row_byte_size * tile_length;\n// bug_end\n \n// bug_start\n        if (state->bytes > INT_MAX - 1) {\n// bug_end\n             state->errcode = IMAGING_CODEC_MEMORY;\n             TIFFClose(tiff);\n             return -1;\n         }\n// bug_start\n// bug_end\n \n         new_data = realloc (state->buffer, state->bytes);\n         if (!new_data) {\n             state->errcode = IMAGING_CODEC_MEMORY;\n             TIFFClose(tiff);\n             return -1;\n         }\n \n         state->buffer = new_data;\n \n         TRACE((\"TIFFTileSize: %d\\n\", state->bytes));\n \n         for (y = state->yoff; y < state->ysize; y += tile_length) {\n             for (x = state->xoff; x < state->xsize; x += tile_width) {\n                 if (ReadTile(tiff, x, y, (UINT32*) state->buffer) == -1) {\n                     TRACE((\"Decode Error, Tile at %dx%d\\n\", x, y));\n                     state->errcode = IMAGING_CODEC_BROKEN;\n                     TIFFClose(tiff);\n                     return -1;\n                 }\n \n                 TRACE((\"Read tile at %dx%d; \\n\\n\", x, y));\n \n                 current_tile_width = min(tile_width, state->xsize - x);\n \n                 for (tile_y = 0; tile_y < min(tile_length, state->ysize - y); tile_y++) {\n                     TRACE((\"Writing tile data at %dx%d using tile_width: %d; \\n\", tile_y + y, x, current_tile_width));\n \n \n                     state->shuffle((UINT8*) im->image[tile_y + y] + x * im->pixelsize,\n                        state->buffer + tile_y * row_byte_size,\n                        current_tile_width\n                     );\n                 }\n             }\n         }\n     } else {\n         UINT32 strip_row, row_byte_size;\n         UINT8 *new_data;\n         UINT32 rows_per_strip;\n         int ret;\n \n         ret = TIFFGetField(tiff, TIFFTAG_ROWSPERSTRIP, &rows_per_strip);\n         if (ret != 1) {\n             rows_per_strip = state->ysize;\n         }\n         TRACE((\"RowsPerStrip: %u \\n\", rows_per_strip));\n \n         row_byte_size = (state->xsize * state->bits + 7) / 8;\n// bug_start\n// bug_end\n         state->bytes = rows_per_strip * row_byte_size;\n \n         TRACE((\"StripSize: %d \\n\", state->bytes));\n \n         new_data = realloc (state->buffer, state->bytes);\n         if (!new_data) {\n             state->errcode = IMAGING_CODEC_MEMORY;\n             TIFFClose(tiff);\n             return -1;\n         }\n \n         state->buffer = new_data;\n \n         for (; state->y < state->ysize; state->y += rows_per_strip) {\n             if (ReadStrip(tiff, state->y, (UINT32 *)state->buffer) == -1) {\n                 TRACE((\"Decode Error, strip %d\\n\", TIFFComputeStrip(tiff, state->y, 0)));\n                 state->errcode = IMAGING_CODEC_BROKEN;\n                 TIFFClose(tiff);\n                 return -1;\n             }\n \n             TRACE((\"Decoded strip for row %d \\n\", state->y));\n \n             for (strip_row = 0; strip_row < min(rows_per_strip, state->ysize - state->y); strip_row++) {\n                 TRACE((\"Writing data into line %d ; \\n\", state->y + strip_row));\n \n \n                 state->shuffle((UINT8*) im->image[state->y + state->yoff + strip_row] +\n                                state->xoff * im->pixelsize,\n                                state->buffer + strip_row * row_byte_size,\n                                state->xsize);\n             }\n         }\n     }\n \n     TIFFClose(tiff);\n     TRACE((\"Done Decoding, Returning \\n\"));\n     return -1;\n }\n \n", "target": "// fix_start\n// fix_end\n// fix_start\n        if (INT_MAX / row_byte_size < tile_length) {\n// fix_end\n// fix_start\n\n        state->bytes = row_byte_size * tile_length;\n// fix_end\n// fix_start\n\n        if (INT_MAX / row_byte_size < rows_per_strip) {\n            state->errcode = IMAGING_CODEC_MEMORY;\n            TIFFClose(tiff);\n            return -1;\n        }\n\n// fix_end\n", "cwe": "CWE-787", "cwe_name": "Out-of-bounds Write", "cve": "CVE-2020-5310", "cve_desc": "libImaging/TiffDecode.c in Pillow before 6.2.2 has a TIFF decoding integer overflow, related to realloc.", "project": "Pillow", "idx": 211908}
{"source": "// bug_start\n\nstatic void bfq_idle_slice_timer_body(struct bfq_queue *bfqq)\n// bug_end\n {\n// bug_start\n\tstruct bfq_data *bfqd = bfqq->bfqd;\n// bug_end\n \tenum bfqq_expiration reason;\n \tunsigned long flags;\n \n \tspin_lock_irqsave(&bfqd->lock, flags);\n// bug_start\n\tbfq_clear_bfqq_wait_request(bfqq);\n// bug_end\n \n \tif (bfqq != bfqd->in_service_queue) {\n \t\tspin_unlock_irqrestore(&bfqd->lock, flags);\n \t\treturn;\n \t}\n// bug_start\n// bug_end\n \n \tif (bfq_bfqq_budget_timeout(bfqq))\n \t\treason = BFQQE_BUDGET_TIMEOUT;\n \telse if (bfqq->queued[0] == 0 && bfqq->queued[1] == 0)\n \t\treason = BFQQE_TOO_IDLE;\n \telse\n \t\tgoto schedule_dispatch;\n \n \tbfq_bfqq_expire(bfqd, bfqq, true, reason);\n \n schedule_dispatch:\n \tspin_unlock_irqrestore(&bfqd->lock, flags);\n \tbfq_schedule_dispatch(bfqd);\n \n", "target": "// fix_start\nstatic void\nbfq_idle_slice_timer_body(struct bfq_data *bfqd, struct bfq_queue *bfqq)\n// fix_end\n// fix_start\n// fix_end\n// fix_start\n// fix_end\n// fix_start\n\n\tbfq_clear_bfqq_wait_request(bfqq);\n// fix_end\n", "cwe": "CWE-416", "cwe_name": "Use After Free", "cve": "CVE-2020-12657", "cve_desc": "An issue was discovered in the Linux kernel before 5.6.5. There is a use-after-free in block/bfq-iosched.c related to bfq_idle_slice_timer_body.", "project": "linux", "idx": 211918}
{"source": " crypt_pw_cmp(const char *userpwd, const char *dbpwd)\n {\n// bug_start\n    int rc;\n    char *cp;\n// bug_end\n     struct crypt_data data;\n     data.initialized = 0;\n \n// bug_start\n    cp = crypt_r(userpwd, dbpwd, &data);\n    if (cp) {\n        rc = slapi_ct_memcmp(dbpwd, cp, strlen(dbpwd));\n// bug_end\n     } else {\n         rc = -1;\n     }\n     return rc;\n }\n \n", "target": "// fix_start\n    int rc = -1;\n    char *cp = NULL;\n    size_t dbpwd_len = strlen(dbpwd);\n// fix_end\n// fix_start\n    if (dbpwd_len >= 3) {\n        cp = crypt_r(userpwd, dbpwd, &data);\n    }\n    if (cp && dbpwd_len == strlen(cp)) {\n        rc = slapi_ct_memcmp(dbpwd, cp, dbpwd_len);\n// fix_end\n", "cwe": "CWE-284", "cwe_name": "Improper Access Control", "cve": "CVE-2021-3652", "cve_desc": "A flaw was found in 389-ds-base. If an asterisk is imported as password hashes, either accidentally or maliciously, then instead of being inactive, any password will successfully match during authentication. This flaw allows an attacker to successfully authenticate as a user whose password was disabled.", "project": "389-ds-base", "idx": 211936}
{"source": " static int tcos_decipher(sc_card_t *card, const u8 * crgram, size_t crgram_len, u8 * out, size_t outlen)\n {\n \tsc_context_t *ctx;\n \tsc_apdu_t apdu;\n \tu8 rbuf[SC_MAX_APDU_BUFFER_SIZE];\n \tu8 sbuf[SC_MAX_APDU_BUFFER_SIZE];\n \ttcos_data *data;\n \tint tcos3, r;\n \n \tassert(card != NULL && crgram != NULL && out != NULL);\n \tctx = card->ctx;\n \ttcos3=(card->type==SC_CARD_TYPE_TCOS_V3);\n \tdata=(tcos_data *)card->drv_data;\n \n \tLOG_FUNC_CALLED(ctx);\n \tsc_log(ctx,\n \t\t\"TCOS3:%d PKCS1:%d\\n\",tcos3,\n \t\t!!(data->pad_flags & SC_ALGORITHM_RSA_PAD_PKCS1));\n \n \tsc_format_apdu(card, &apdu, crgram_len>255 ? SC_APDU_CASE_4_EXT : SC_APDU_CASE_4_SHORT, 0x2A, 0x80, 0x86);\n \tapdu.resp = rbuf;\n \tapdu.resplen = sizeof(rbuf);\n \tapdu.le = crgram_len;\n \n \tapdu.data = sbuf;\n \tapdu.lc = apdu.datalen = crgram_len+1;\n \tsbuf[0] = tcos3 ? 0x00 : ((data->pad_flags & SC_ALGORITHM_RSA_PAD_PKCS1) ? 0x81 : 0x02);\n// bug_start\n// bug_end\n \tmemcpy(sbuf+1, crgram, crgram_len);\n \n \tr = sc_transmit_apdu(card, &apdu);\n \tLOG_TEST_RET(card->ctx, r, \"APDU transmit failed\");\n \n \tif (apdu.sw1==0x90 && apdu.sw2==0x00) {\n \t\tsize_t len= (apdu.resplen>outlen) ? outlen : apdu.resplen;\n \t\tunsigned int offset=0;\n \t\tif(tcos3 && (data->pad_flags & SC_ALGORITHM_RSA_PAD_PKCS1) && apdu.resp[0]==0 && apdu.resp[1]==2) {\n \t\t\toffset=2; while(offset<len && apdu.resp[offset]!=0) ++offset;\n \t\t\toffset=(offset<len-1) ? offset+1 : 0;\n \t\t}\n \t\tmemcpy(out, apdu.resp+offset, len-offset);\n \t\tSC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_VERBOSE, len-offset);\n \t}\n \tSC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_VERBOSE, sc_check_sw(card, apdu.sw1, apdu.sw2));\n }\n \n", "target": "// fix_start\n\tif (sizeof sbuf - 1 < crgram_len)\n\t\treturn SC_ERROR_INVALID_ARGUMENTS;\n// fix_end\n", "cwe": "CWE-787", "cwe_name": "Out-of-bounds Write", "cve": "CVE-2020-26572", "cve_desc": "The TCOS smart card software driver in OpenSC before 0.21.0-rc1 has a stack-based buffer overflow in tcos_decipher.", "project": "OpenSC", "idx": 211948}
{"source": " void luaD_callnoyield (lua_State *L, StkId func, int nResults) {\n   incXCcalls(L);\n// bug_start\n  if (getCcalls(L) <= CSTACKERR)\n    luaE_freeCI(L);\n// bug_end\n   luaD_call(L, func, nResults);\n   decXCcalls(L);\n }\n \n", "target": "// fix_start\n  if (getCcalls(L) <= CSTACKERR) {\n    luaE_exitCcall(L);\n    luaE_enterCcall(L);\n  }\n// fix_end\n", "cwe": "CWE-787", "cwe_name": "Out-of-bounds Write", "cve": "CVE-2020-24342", "cve_desc": "Lua through 5.4.0 allows a stack redzone cross in luaO_pushvfstring because a protection mechanism wrongly calls luaD_callnoyield twice in a row.", "project": "lua", "idx": 211977}
{"source": " static int jpc_dec_decodepkt(jpc_dec_t *dec, jas_stream_t *pkthdrstream, jas_stream_t *in, int compno, int rlvlno,\n   int prcno, int lyrno)\n {\n \tjpc_bitstream_t *inb;\n \tjpc_dec_tcomp_t *tcomp;\n \tjpc_dec_rlvl_t *rlvl;\n \tjpc_dec_band_t *band;\n \tjpc_dec_cblk_t *cblk;\n \tint n;\n \tint m;\n \tint i;\n \tjpc_tagtreenode_t *leaf;\n \tint included;\n \tint ret;\n \tint numnewpasses;\n \tjpc_dec_seg_t *seg;\n \tint len;\n \tint present;\n \tint savenumnewpasses;\n \tint mycounter;\n \tjpc_ms_t *ms;\n \tjpc_dec_tile_t *tile;\n \tjpc_dec_ccp_t *ccp;\n \tjpc_dec_cp_t *cp;\n \tint bandno;\n \tjpc_dec_prc_t *prc;\n \tint usedcblkcnt;\n \tint cblkno;\n \tuint_fast32_t bodylen;\n \tbool discard;\n \tint passno;\n \tint maxpasses;\n \tint hdrlen;\n \tint hdroffstart;\n \tint hdroffend;\n \n \tbodylen = 0;\n \n \tdiscard = (lyrno >= dec->maxlyrs);\n \n \ttile = dec->curtile;\n \tcp = tile->cp;\n \tccp = &cp->ccps[compno];\n \n \n \tif (cp->csty & JPC_COD_SOP) {\n \t\tif (jpc_dec_lookahead(in) == JPC_MS_SOP) {\n \t\t\tif (!(ms = jpc_getms(in, dec->cstate))) {\n \t\t\t\treturn -1;\n \t\t\t}\n \t\t\tif (jpc_ms_gettype(ms) != JPC_MS_SOP) {\n \t\t\t\tjpc_ms_destroy(ms);\n \t\t\t\tjas_eprintf(\"missing SOP marker segment\\n\");\n \t\t\t\treturn -1;\n \t\t\t}\n \t\t\tjpc_ms_destroy(ms);\n \t\t}\n \t}\n \n hdroffstart = jas_stream_getrwcount(pkthdrstream);\n \n \tif (!(inb = jpc_bitstream_sopen(pkthdrstream, \"r\"))) {\n \t\treturn -1;\n \t}\n \n \tif ((present = jpc_bitstream_getbit(inb)) < 0) {\n \t\tjpc_bitstream_close(inb);\n \t\treturn 1;\n \t}\n \tJAS_DBGLOG(10, (\"\\n\", present));\n \tJAS_DBGLOG(10, (\"present=%d \", present));\n \n \tif (present) {\n \t\ttcomp = &tile->tcomps[compno];\n \t\trlvl = &tcomp->rlvls[rlvlno];\n \t\tbodylen = 0;\n \t\tfor (bandno = 0, band = rlvl->bands; bandno < rlvl->numbands;\n \t\t  ++bandno, ++band) {\n \t\t\tif (!band->data) {\n \t\t\t\tcontinue;\n \t\t\t}\n \t\t\tprc = &band->prcs[prcno];\n \t\t\tif (!prc->cblks) {\n \t\t\t\tcontinue;\n \t\t\t}\n \t\t\tusedcblkcnt = 0;\n \t\t\tfor (cblkno = 0, cblk = prc->cblks; cblkno < prc->numcblks;\n \t\t\t  ++cblkno, ++cblk) {\n \t\t\t\t++usedcblkcnt;\n \t\t\t\tif (!cblk->numpasses) {\n \t\t\t\t\tleaf = jpc_tagtree_getleaf(prc->incltagtree, usedcblkcnt - 1);\n \t\t\t\t\tif ((included = jpc_tagtree_decode(prc->incltagtree, leaf, lyrno + 1, inb)) < 0) {\n \t\t\t\t\t\tjpc_bitstream_close(inb);\n \t\t\t\t\t\treturn -1;\n \t\t\t\t\t}\n \t\t\t\t} else {\n \t\t\t\t\tif ((included = jpc_bitstream_getbit(inb)) < 0) {\n \t\t\t\t\t\tjpc_bitstream_close(inb);\n \t\t\t\t\t\treturn -1;\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\tJAS_DBGLOG(10, (\"\\n\"));\n \t\t\t\tJAS_DBGLOG(10, (\"included=%d \", included));\n \t\t\t\tif (!included) {\n \t\t\t\t\tcontinue;\n \t\t\t\t}\n \t\t\t\tif (!cblk->numpasses) {\n \t\t\t\t\ti = 1;\n \t\t\t\t\tleaf = jpc_tagtree_getleaf(prc->numimsbstagtree, usedcblkcnt - 1);\n \t\t\t\t\tfor (;;) {\n \t\t\t\t\t\tif ((ret = jpc_tagtree_decode(prc->numimsbstagtree, leaf, i, inb)) < 0) {\n \t\t\t\t\t\t\tjpc_bitstream_close(inb);\n \t\t\t\t\t\t\treturn -1;\n \t\t\t\t\t\t}\n \t\t\t\t\t\tif (ret) {\n \t\t\t\t\t\t\tbreak;\n \t\t\t\t\t\t}\n \t\t\t\t\t\t++i;\n \t\t\t\t\t}\n \t\t\t\t\tcblk->numimsbs = i - 1;\n \t\t\t\t\tcblk->firstpassno = cblk->numimsbs * 3;\n \t\t\t\t}\n \t\t\t\tif ((numnewpasses = jpc_getnumnewpasses(inb)) < 0) {\n \t\t\t\t\tjpc_bitstream_close(inb);\n \t\t\t\t\treturn -1;\n \t\t\t\t}\n \t\t\t\tJAS_DBGLOG(10, (\"numnewpasses=%d \", numnewpasses));\n \t\t\t\tseg = cblk->curseg;\n \t\t\t\tsavenumnewpasses = numnewpasses;\n \t\t\t\tmycounter = 0;\n \t\t\t\tif (numnewpasses > 0) {\n// bug_start\n// bug_end\n \t\t\t\t\tif ((m = jpc_getcommacode(inb)) < 0) {\n \t\t\t\t\t\tjpc_bitstream_close(inb);\n \t\t\t\t\t\treturn -1;\n \t\t\t\t\t}\n \t\t\t\t\tcblk->numlenbits += m;\n \t\t\t\t\tJAS_DBGLOG(10, (\"increment=%d \", m));\n \t\t\t\t\twhile (numnewpasses > 0) {\n \t\t\t\t\t\tpassno = cblk->firstpassno + cblk->numpasses + mycounter;\n \t\t\t\t\t\tmaxpasses = JPC_SEGPASSCNT(passno, cblk->firstpassno, 10000, (ccp->cblkctx & JPC_COX_LAZY) != 0, (ccp->cblkctx & JPC_COX_TERMALL) != 0);\n \t\t\t\t\t\tif (!discard && !seg) {\n \t\t\t\t\t\t\tif (!(seg = jpc_seg_alloc())) {\n \t\t\t\t\t\t\t\tjpc_bitstream_close(inb);\n \t\t\t\t\t\t\t\treturn -1;\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\tjpc_seglist_insert(&cblk->segs, cblk->segs.tail, seg);\n \t\t\t\t\t\t\tif (!cblk->curseg) {\n \t\t\t\t\t\t\t\tcblk->curseg = seg;\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\tseg->passno = passno;\n \t\t\t\t\t\t\tseg->type = JPC_SEGTYPE(seg->passno, cblk->firstpassno, (ccp->cblkctx & JPC_COX_LAZY) != 0);\n \t\t\t\t\t\t\tseg->maxpasses = maxpasses;\n \t\t\t\t\t\t}\n \t\t\t\t\t\tn = JAS_MIN(numnewpasses, maxpasses);\n \t\t\t\t\t\tmycounter += n;\n \t\t\t\t\t\tnumnewpasses -= n;\n \t\t\t\t\t\tif ((len = jpc_bitstream_getbits(inb, cblk->numlenbits + jpc_floorlog2(n))) < 0) {\n \t\t\t\t\t\t\tjpc_bitstream_close(inb);\n \t\t\t\t\t\t\treturn -1;\n \t\t\t\t\t\t}\n \t\t\t\t\t\tJAS_DBGLOG(10, (\"len=%d \", len));\n \t\t\t\t\t\tif (!discard) {\n \t\t\t\t\t\t\tseg->lyrno = lyrno;\n \t\t\t\t\t\t\tseg->numpasses += n;\n \t\t\t\t\t\t\tseg->cnt = len;\n \t\t\t\t\t\t\tseg = seg->next;\n \t\t\t\t\t\t}\n \t\t\t\t\t\tbodylen += len;\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\tcblk->numpasses += savenumnewpasses;\n \t\t\t}\n \t\t}\n \n \t\tjpc_bitstream_inalign(inb, 0, 0);\n \n \t} else {\n \t\tif (jpc_bitstream_inalign(inb, 0x7f, 0)) {\n \t\t\tjas_eprintf(\"alignment failed\\n\");\n \t\t\tjpc_bitstream_close(inb);\n \t\t\treturn -1;\n \t\t}\n \t}\n \tjpc_bitstream_close(inb);\n \n \thdroffend = jas_stream_getrwcount(pkthdrstream);\n \thdrlen = hdroffend - hdroffstart;\n \tif (jas_getdbglevel() >= 5) {\n \t\tjas_eprintf(\"hdrlen=%lu bodylen=%lu \\n\", (unsigned long) hdrlen,\n \t\t  (unsigned long) bodylen);\n \t}\n \n \tif (cp->csty & JPC_COD_EPH) {\n \t\tif (jpc_dec_lookahead(pkthdrstream) == JPC_MS_EPH) {\n \t\t\tif (!(ms = jpc_getms(pkthdrstream, dec->cstate))) {\n \t\t\t\tjas_eprintf(\"cannot get (EPH) marker segment\\n\");\n \t\t\t\treturn -1;\n \t\t\t}\n \t\t\tif (jpc_ms_gettype(ms) != JPC_MS_EPH) {\n \t\t\t\tjpc_ms_destroy(ms);\n \t\t\t\tjas_eprintf(\"missing EPH marker segment\\n\");\n \t\t\t\treturn -1;\n \t\t\t}\n \t\t\tjpc_ms_destroy(ms);\n \t\t}\n \t}\n \n \n \tif (jas_getdbglevel() >= 1) {\n \t\tjas_eprintf(\"packet body offset=%06ld\\n\", (long) jas_stream_getrwcount(in));\n \t}\n \n \tif (!discard) {\n \t\ttcomp = &tile->tcomps[compno];\n \t\trlvl = &tcomp->rlvls[rlvlno];\n \t\tfor (bandno = 0, band = rlvl->bands; bandno < rlvl->numbands;\n \t\t  ++bandno, ++band) {\n \t\t\tif (!band->data) {\n \t\t\t\tcontinue;\n \t\t\t}\n \t\t\tprc = &band->prcs[prcno];\n \t\t\tif (!prc->cblks) {\n \t\t\t\tcontinue;\n \t\t\t}\n \t\t\tfor (cblkno = 0, cblk = prc->cblks; cblkno < prc->numcblks;\n \t\t\t  ++cblkno, ++cblk) {\n \t\t\t\tseg = cblk->curseg;\n \t\t\t\twhile (seg) {\n \t\t\t\t\tif (!seg->stream) {\n \t\t\t\t\t\tif (!(seg->stream = jas_stream_memopen(0, 0))) {\n \t\t\t\t\t\t\treturn -1;\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n #if 0\n jas_eprintf(\"lyrno=%02d, compno=%02d, lvlno=%02d, prcno=%02d, bandno=%02d, cblkno=%02d, passno=%02d numpasses=%02d cnt=%d numbps=%d, numimsbs=%d\\n\", lyrno, compno, rlvlno, prcno, band - rlvl->bands, cblk - prc->cblks, seg->passno, seg->numpasses, seg->cnt, band->numbps, cblk->numimsbs);\n #endif\n \t\t\t\t\tif (seg->cnt > 0) {\n \t\t\t\t\t\tif (jpc_getdata(in, seg->stream, seg->cnt) < 0) {\n \t\t\t\t\t\t\treturn -1;\n \t\t\t\t\t\t}\n \t\t\t\t\t\tseg->cnt = 0;\n \t\t\t\t\t}\n \t\t\t\t\tif (seg->numpasses >= seg->maxpasses) {\n \t\t\t\t\t\tcblk->curseg = seg->next;\n \t\t\t\t\t}\n \t\t\t\t\tseg = seg->next;\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \t} else {\n \t\tif (jas_stream_gobble(in, bodylen) != JAS_CAST(int, bodylen)) {\n \t\t\treturn -1;\n \t\t}\n \t}\n \treturn 0;\n }\n \n", "target": "// fix_start\n\t\t\t\t\tif (cblk->firstpassno > 10000) {\n\t\t\t\t\t\tjpc_bitstream_close(inb);\n\t\t\t\t\t\treturn -1;\n\t\t\t\t\t}\n// fix_end\n", "cwe": "CWE-617", "cwe_name": "Reachable Assertion", "cve": "CVE-2016-9398", "cve_desc": "The jpc_floorlog2 function in jpc_math.c in JasPer before 1.900.17 allows remote attackers to cause a denial of service (assertion failure) via unspecified vectors.", "project": "jasper", "idx": 212027}
{"source": " wsrep_cb_status_t wsrep_sst_donate_cb (void* app_ctx, void* recv_ctx,\n                                        const void* msg, size_t msg_len,\n                                        const wsrep_gtid_t* current_gtid,\n                                        const char* state, size_t state_len,\n                                        bool bypass)\n {\n// bug_start\n  local_status.set(WSREP_MEMBER_DONOR);\n\n// bug_end\n   const char* method = (char*)msg;\n   size_t method_len  = strlen (method);\n// bug_start\n// bug_end\n   const char* data   = method + method_len + 1;\n// bug_start\n// bug_end\n \n   char uuid_str[37];\n   wsrep_uuid_print (&current_gtid->uuid, uuid_str, sizeof(uuid_str));\n// bug_start\n// bug_end\n \n   wsp::env env(NULL);\n   if (env.error())\n   {\n     WSREP_ERROR(\"wsrep_sst_donate_cb(): env var ctor failed: %d\", -env.error());\n     return WSREP_CB_FAILURE;\n   }\n \n   int ret;\n   if ((ret= sst_append_auth_env(env, sst_auth_real)))\n   {\n     WSREP_ERROR(\"wsrep_sst_donate_cb(): appending auth env failed: %d\", ret);\n     return WSREP_CB_FAILURE;\n   }\n \n   if (!strcmp (WSREP_SST_MYSQLDUMP, method))\n   {\n     ret = sst_donate_mysqldump(data, &current_gtid->uuid, uuid_str,\n                                current_gtid->seqno, bypass, env());\n   }\n   else\n   {\n     ret = sst_donate_other(method, data, uuid_str,\n                            current_gtid->seqno, bypass, env());\n   }\n \n   return (ret >= 0 ? WSREP_CB_SUCCESS : WSREP_CB_FAILURE);\n }\n \n", "target": "// fix_start\n// fix_end\n// fix_start\n\n  if (check_request_str(method, filename_char))\n  {\n    WSREP_ERROR(\"Bad SST method name. SST canceled.\");\n    return WSREP_CB_FAILURE;\n  }\n\n// fix_end\n// fix_start\n\n  if (check_request_str(data, address_char))\n  {\n    WSREP_ERROR(\"Bad SST address string. SST canceled.\");\n    return WSREP_CB_FAILURE;\n  }\n// fix_end\n// fix_start\n\n  local_status.set(WSREP_MEMBER_DONOR);\n// fix_end\n", "cwe": "CWE-77", "cwe_name": "Improper Neutralization of Special Elements used in a Command ('Command Injection')", "cve": "CVE-2020-15180", "cve_desc": "A flaw was found in the mysql-wsrep component of mariadb. Lack of input sanitization in `wsrep_sst_method` allows for command injection that can be exploited by a remote attacker to execute arbitrary commands on galera cluster nodes. This threatens the system's confidentiality, integrity, and availability. This flaw affects mariadb versions before 10.1.47, before 10.2.34, before 10.3.25, before 10.4.15 and before 10.5.6.", "project": "mysql-wsrep", "idx": 212088}
{"source": " FLAC__bool FLAC__bitreader_read_rice_signed_block(FLAC__BitReader *br, int vals[], uint32_t nvals, uint32_t parameter)\n {\n \tuint32_t cwords, words, lsbs, msbs, x, y;\n \tuint32_t ucbits;\n \tbrword b;\n \tint *val, *end;\n \n \tFLAC__ASSERT(0 != br);\n \tFLAC__ASSERT(0 != br->buffer);\n \tFLAC__ASSERT(FLAC__BITS_PER_WORD >= 32);\n \tFLAC__ASSERT(parameter < 32);\n \n \tval = vals;\n \tend = vals + nvals;\n \n \tif(parameter == 0) {\n \t\twhile(val < end) {\n \t\t\tif(!FLAC__bitreader_read_unary_unsigned(br, &msbs))\n \t\t\t\treturn false;\n \n \t\t\t*val++ = (int)(msbs >> 1) ^ -(int)(msbs & 1);\n \t\t}\n \n \t\treturn true;\n \t}\n \n \tFLAC__ASSERT(parameter > 0);\n \n \tcwords = br->consumed_words;\n \twords = br->words;\n \n \tif(cwords >= words) {\n \t\tx = 0;\n \t\tgoto process_tail;\n \t}\n \n \tucbits = FLAC__BITS_PER_WORD - br->consumed_bits;\n \tb = br->buffer[cwords] << br->consumed_bits;\n \n \twhile(val < end) {\n \t\tx = y = COUNT_ZERO_MSBS2(b);\n \t\tif(x == FLAC__BITS_PER_WORD) {\n \t\t\tx = ucbits;\n \t\t\tdo {\n \t\t\t\tcwords++;\n \t\t\t\tif (cwords >= words)\n \t\t\t\t\tgoto incomplete_msbs;\n \t\t\t\tb = br->buffer[cwords];\n \t\t\t\ty = COUNT_ZERO_MSBS2(b);\n \t\t\t\tx += y;\n \t\t\t} while(y == FLAC__BITS_PER_WORD);\n \t\t}\n \t\tb <<= y;\n \t\tb <<= 1;\n \t\tucbits = (ucbits - x - 1) % FLAC__BITS_PER_WORD;\n \t\tmsbs = x;\n \n \t\tx = (FLAC__uint32)(b >> (FLAC__BITS_PER_WORD - parameter));\n \t\tif(parameter <= ucbits) {\n \t\t\tucbits -= parameter;\n \t\t\tb <<= parameter;\n \t\t} else {\n \t\t\tcwords++;\n \t\t\tif (cwords >= words)\n \t\t\t\tgoto incomplete_lsbs;\n \t\t\tb = br->buffer[cwords];\n \t\t\tucbits += FLAC__BITS_PER_WORD - parameter;\n \t\t\tx |= (FLAC__uint32)(b >> ucbits);\n \t\t\tb <<= FLAC__BITS_PER_WORD - ucbits;\n \t\t}\n \t\tlsbs = x;\n \n \t\tx = (msbs << parameter) | lsbs;\n \t\t*val++ = (int)(x >> 1) ^ -(int)(x & 1);\n \n \t\tcontinue;\n \n process_tail:\n \t\tdo {\n \t\t\tif(0) {\n incomplete_msbs:\n \t\t\t\tbr->consumed_bits = 0;\n \t\t\t\tbr->consumed_words = cwords;\n \t\t\t}\n \n \t\t\tif(!FLAC__bitreader_read_unary_unsigned(br, &msbs))\n \t\t\t\treturn false;\n \t\t\tmsbs += x;\n \t\t\tx = ucbits = 0;\n \n \t\t\tif(0) {\n incomplete_lsbs:\n \t\t\t\tbr->consumed_bits = 0;\n \t\t\t\tbr->consumed_words = cwords;\n \t\t\t}\n \n \t\t\tif(!FLAC__bitreader_read_raw_uint32(br, &lsbs, parameter - ucbits))\n \t\t\t\treturn false;\n \t\t\tlsbs = x | lsbs;\n \n \t\t\tx = (msbs << parameter) | lsbs;\n \t\t\t*val++ = (int)(x >> 1) ^ -(int)(x & 1);\n \t\t\tx = 0;\n \n \t\t\tcwords = br->consumed_words;\n \t\t\twords = br->words;\n \t\t\tucbits = FLAC__BITS_PER_WORD - br->consumed_bits;\n// bug_start\n\t\t\tb = br->buffer[cwords] << br->consumed_bits;\n// bug_end\n \t\t} while(cwords >= words && val < end);\n \t}\n \n \tif(ucbits == 0 && cwords < words) {\n \t\tcwords++;\n \t\tucbits = FLAC__BITS_PER_WORD;\n \t}\n \n \tbr->consumed_bits = FLAC__BITS_PER_WORD - ucbits;\n \tbr->consumed_words = cwords;\n \n \treturn true;\n }\n \n", "target": "// fix_start\n\t\t\tb = cwords < br->capacity ? br->buffer[cwords] << br->consumed_bits : 0;\n// fix_end\n", "cwe": "CWE-125", "cwe_name": "Out-of-bounds Read", "cve": "CVE-2020-0499", "cve_desc": "In FLAC__bitreader_read_rice_signed_block of bitreader.c, there is a possible out of bounds read due to a heap buffer overflow. This could lead to remote information disclosure with no additional execution privileges needed. User interaction is needed for exploitation.Product: AndroidVersions: Android-11Android ID: A-156076070", "project": "flac", "idx": 212139}
{"source": " void stralgoLCS(client *c) {\n     uint32_t i, j;\n     long long minmatchlen = 0;\n     sds a = NULL, b = NULL;\n     int getlen = 0, getidx = 0, withmatchlen = 0;\n     robj *obja = NULL, *objb = NULL;\n \n     for (j = 2; j < (uint32_t)c->argc; j++) {\n         char *opt = c->argv[j]->ptr;\n         int moreargs = (c->argc-1) - j;\n \n         if (!strcasecmp(opt,\"IDX\")) {\n             getidx = 1;\n         } else if (!strcasecmp(opt,\"LEN\")) {\n             getlen = 1;\n         } else if (!strcasecmp(opt,\"WITHMATCHLEN\")) {\n             withmatchlen = 1;\n         } else if (!strcasecmp(opt,\"MINMATCHLEN\") && moreargs) {\n             if (getLongLongFromObjectOrReply(c,c->argv[j+1],&minmatchlen,NULL)\n                 != C_OK) goto cleanup;\n             if (minmatchlen < 0) minmatchlen = 0;\n             j++;\n         } else if (!strcasecmp(opt,\"STRINGS\") && moreargs > 1) {\n             if (a != NULL) {\n                 addReplyError(c,\"Either use STRINGS or KEYS\");\n                 goto cleanup;\n             }\n             a = c->argv[j+1]->ptr;\n             b = c->argv[j+2]->ptr;\n             j += 2;\n         } else if (!strcasecmp(opt,\"KEYS\") && moreargs > 1) {\n             if (a != NULL) {\n                 addReplyError(c,\"Either use STRINGS or KEYS\");\n                 goto cleanup;\n             }\n             obja = lookupKeyRead(c->db,c->argv[j+1]);\n             objb = lookupKeyRead(c->db,c->argv[j+2]);\n             if ((obja && obja->type != OBJ_STRING) ||\n                 (objb && objb->type != OBJ_STRING))\n             {\n                 addReplyError(c,\n                     \"The specified keys must contain string values\");\n                 obja = NULL;\n                 objb = NULL;\n                 goto cleanup;\n             }\n             obja = obja ? getDecodedObject(obja) : createStringObject(\"\",0);\n             objb = objb ? getDecodedObject(objb) : createStringObject(\"\",0);\n             a = obja->ptr;\n             b = objb->ptr;\n             j += 2;\n         } else {\n             addReplyErrorObject(c,shared.syntaxerr);\n             goto cleanup;\n         }\n     }\n \n     if (a == NULL) {\n         addReplyError(c,\"Please specify two strings: \"\n                         \"STRINGS or KEYS options are mandatory\");\n         goto cleanup;\n     } else if (getlen && getidx) {\n         addReplyError(c,\n             \"If you want both the length and indexes, please \"\n             \"just use IDX.\");\n         goto cleanup;\n     }\n \n     uint32_t alen = sdslen(a);\n     uint32_t blen = sdslen(b);\n \n// bug_start\n    uint32_t *lcs = zmalloc((alen+1)*(blen+1)*sizeof(uint32_t));\n// bug_end\n     #define LCS(A,B) lcs[(B)+((A)*(blen+1))]\n \n     for (uint32_t i = 0; i <= alen; i++) {\n         for (uint32_t j = 0; j <= blen; j++) {\n             if (i == 0 || j == 0) {\n                 LCS(i,j) = 0;\n             } else if (a[i-1] == b[j-1]) {\n                 LCS(i,j) = LCS(i-1,j-1)+1;\n             } else {\n                 uint32_t lcs1 = LCS(i-1,j);\n                 uint32_t lcs2 = LCS(i,j-1);\n                 LCS(i,j) = lcs1 > lcs2 ? lcs1 : lcs2;\n             }\n         }\n     }\n \n     uint32_t idx = LCS(alen,blen);\n     sds result = NULL;\n     void *arraylenptr = NULL;\n     uint32_t arange_start = alen,\n              arange_end = 0,\n              brange_start = 0,\n              brange_end = 0;\n \n     int computelcs = getidx || !getlen;\n     if (computelcs) result = sdsnewlen(SDS_NOINIT,idx);\n \n     uint32_t arraylen = 0;\n     if (getidx) {\n         addReplyMapLen(c,2);\n         addReplyBulkCString(c,\"matches\");\n         arraylenptr = addReplyDeferredLen(c);\n     }\n \n     i = alen, j = blen;\n     while (computelcs && i > 0 && j > 0) {\n         int emit_range = 0;\n         if (a[i-1] == b[j-1]) {\n             result[idx-1] = a[i-1];\n \n             if (arange_start == alen) {\n                 arange_start = i-1;\n                 arange_end = i-1;\n                 brange_start = j-1;\n                 brange_end = j-1;\n             } else {\n                 if (arange_start == i && brange_start == j) {\n                     arange_start--;\n                     brange_start--;\n                 } else {\n                     emit_range = 1;\n                 }\n             }\n             if (arange_start == 0 || brange_start == 0) emit_range = 1;\n             idx--; i--; j--;\n         } else {\n             uint32_t lcs1 = LCS(i-1,j);\n             uint32_t lcs2 = LCS(i,j-1);\n             if (lcs1 > lcs2)\n                 i--;\n             else\n                 j--;\n             if (arange_start != alen) emit_range = 1;\n         }\n \n         uint32_t match_len = arange_end - arange_start + 1;\n         if (emit_range) {\n             if (minmatchlen == 0 || match_len >= minmatchlen) {\n                 if (arraylenptr) {\n                     addReplyArrayLen(c,2+withmatchlen);\n                     addReplyArrayLen(c,2);\n                     addReplyLongLong(c,arange_start);\n                     addReplyLongLong(c,arange_end);\n                     addReplyArrayLen(c,2);\n                     addReplyLongLong(c,brange_start);\n                     addReplyLongLong(c,brange_end);\n                     if (withmatchlen) addReplyLongLong(c,match_len);\n                     arraylen++;\n                 }\n             }\n             arange_start = alen;\n         }\n     }\n \n \n     if (arraylenptr) {\n         addReplyBulkCString(c,\"len\");\n         addReplyLongLong(c,LCS(alen,blen));\n         setDeferredArrayLen(c,arraylenptr,arraylen);\n     } else if (getlen) {\n         addReplyLongLong(c,LCS(alen,blen));\n     } else {\n         addReplyBulkSds(c,result);\n         result = NULL;\n     }\n \n     sdsfree(result);\n     zfree(lcs);\n \n cleanup:\n     if (obja) decrRefCount(obja);\n     if (objb) decrRefCount(objb);\n     return;\n }\n \n", "target": "// fix_start\n    uint32_t *lcs = zmalloc((size_t)(alen+1)*(blen+1)*sizeof(uint32_t));\n// fix_end\n", "cwe": "CWE-190", "cwe_name": "Integer Overflow or Wraparound", "cve": "CVE-2021-29477", "cve_desc": "Redis is an open source (BSD licensed), in-memory data structure store, used as a database, cache, and message broker. An integer overflow bug in Redis version 6.0 or newer could be exploited using the `STRALGO LCS` command to corrupt the heap and potentially result with remote code execution. The problem is fixed in version 6.2.3 and 6.0.13. An additional workaround to mitigate the problem without patching the redis-server executable is to use ACL configuration to prevent clients from using the `STRALGO LCS` command.", "project": "redis", "idx": 212155}
{"source": " int RGWGetObj_ObjStore_S3::send_response_data(bufferlist& bl, off_t bl_ofs,\n \t\t\t\t\t      off_t bl_len)\n {\n   const char *content_type = NULL;\n   string content_type_str;\n   map<string, string> response_attrs;\n   map<string, string>::iterator riter;\n   bufferlist metadata_bl;\n \n   if (sent_header)\n     goto send_data;\n \n   if (custom_http_ret) {\n     set_req_state_err(s, 0);\n     dump_errno(s, custom_http_ret);\n   } else {\n     set_req_state_err(s, (partial_content && !op_ret) ? STATUS_PARTIAL_CONTENT\n                   : op_ret);\n     dump_errno(s);\n   }\n \n   if (op_ret)\n     goto done;\n \n   if (range_str)\n     dump_range(s, start, end, s->obj_size);\n \n   if (s->system_request &&\n       s->info.args.exists(RGW_SYS_PARAM_PREFIX \"prepend-metadata\")) {\n \n     dump_header(s, \"Rgwx-Object-Size\", (long long)total_len);\n \n     if (rgwx_stat) {\n       total_len = 0;\n     }\n \n     JSONFormatter jf;\n     jf.open_object_section(\"obj_metadata\");\n     encode_json(\"attrs\", attrs, &jf);\n     utime_t ut(lastmod);\n     encode_json(\"mtime\", ut, &jf);\n     jf.close_section();\n     stringstream ss;\n     jf.flush(ss);\n     metadata_bl.append(ss.str());\n     dump_header(s, \"Rgwx-Embedded-Metadata-Len\", metadata_bl.length());\n     total_len += metadata_bl.length();\n   }\n \n   if (s->system_request && !real_clock::is_zero(lastmod)) {\n     dump_epoch_header(s, \"Rgwx-Mtime\", lastmod);\n     uint64_t pg_ver = 0;\n     int r = decode_attr_bl_single_value(attrs, RGW_ATTR_PG_VER, &pg_ver, (uint64_t)0);\n     if (r < 0) {\n       ldout(s->cct, 0) << \"ERROR: failed to decode pg ver attr, ignoring\" << dendl;\n     }\n     dump_header(s, \"Rgwx-Obj-PG-Ver\", pg_ver);\n \n     uint32_t source_zone_short_id = 0;\n     r = decode_attr_bl_single_value(attrs, RGW_ATTR_SOURCE_ZONE, &source_zone_short_id, (uint32_t)0);\n     if (r < 0) {\n       ldout(s->cct, 0) << \"ERROR: failed to decode pg ver attr, ignoring\" << dendl;\n     }\n     if (source_zone_short_id != 0) {\n       dump_header(s, \"Rgwx-Source-Zone-Short-Id\", source_zone_short_id);\n     }\n   }\n \n   for (auto &it : crypt_http_responses)\n     dump_header(s, it.first, it.second);\n \n   dump_content_length(s, total_len);\n   dump_last_modified(s, lastmod);\n   dump_header_if_nonempty(s, \"x-amz-version-id\", version_id);\n   if (attrs.find(RGW_ATTR_APPEND_PART_NUM) != attrs.end()) {\n     dump_header(s, \"x-rgw-object-type\", \"Appendable\");\n     dump_header(s, \"x-rgw-next-append-position\", s->obj_size);\n   } else {\n     dump_header(s, \"x-rgw-object-type\", \"Normal\");\n   }\n \n   if (! op_ret) {\n     if (! lo_etag.empty()) {\n       dump_etag(s, lo_etag);\n     } else {\n       auto iter = attrs.find(RGW_ATTR_ETAG);\n       if (iter != attrs.end()) {\n         dump_etag(s, iter->second.to_str());\n       }\n     }\n \n     for (struct response_attr_param *p = resp_attr_params; p->param; p++) {\n       bool exists;\n       string val = s->info.args.get(p->param, &exists);\n       if (exists) {\n \tif (s->auth.identity->is_anonymous()) {\n \t  return -ERR_INVALID_REQUEST;\n \t}\n// bug_start\n// bug_end\n \tif (strcmp(p->param, \"response-content-type\") != 0) {\n \t  response_attrs[p->http_attr] = val;\n \t} else {\n \t  content_type_str = val;\n \t  content_type = content_type_str.c_str();\n \t}\n       }\n     }\n \n     for (auto iter = attrs.begin(); iter != attrs.end(); ++iter) {\n       const char *name = iter->first.c_str();\n       map<string, string>::iterator aiter = rgw_to_http_attrs.find(name);\n       if (aiter != rgw_to_http_attrs.end()) {\n         if (response_attrs.count(aiter->second) == 0) {\n \n           size_t len = iter->second.length();\n           string s(iter->second.c_str(), len);\n           while (len && !s[len - 1]) {\n             --len;\n             s.resize(len);\n           }\n           response_attrs[aiter->second] = s;\n         }\n       } else if (iter->first.compare(RGW_ATTR_CONTENT_TYPE) == 0) {\n         if (!content_type) {\n           content_type_str = rgw_bl_str(iter->second);\n           content_type = content_type_str.c_str();\n         }\n       } else if (strcmp(name, RGW_ATTR_SLO_UINDICATOR) == 0) {\n         dump_header(s, \"X-Object-Meta-Static-Large-Object\", \"True\");\n       } else if (strncmp(name, RGW_ATTR_META_PREFIX,\n \t\t\t sizeof(RGW_ATTR_META_PREFIX)-1) == 0) {\n         name += sizeof(RGW_ATTR_PREFIX) - 1;\n         dump_header(s, name, iter->second);\n       } else if (iter->first.compare(RGW_ATTR_TAGS) == 0) {\n         RGWObjTags obj_tags;\n         try{\n           auto it = iter->second.cbegin();\n           obj_tags.decode(it);\n         } catch (buffer::error &err) {\n           ldout(s->cct,0) << \"Error caught buffer::error couldn't decode TagSet \" << dendl;\n         }\n         dump_header(s, RGW_AMZ_TAG_COUNT, obj_tags.count());\n       } else if (iter->first.compare(RGW_ATTR_OBJECT_RETENTION) == 0 && get_retention){\n         RGWObjectRetention retention;\n         try {\n           decode(retention, iter->second);\n           dump_header(s, \"x-amz-object-lock-mode\", retention.get_mode());\n           dump_time_header(s, \"x-amz-object-lock-retain-until-date\", retention.get_retain_until_date());\n         } catch (buffer::error& err) {\n           ldpp_dout(this, 0) << \"ERROR: failed to decode RGWObjectRetention\" << dendl;\n         }\n       } else if (iter->first.compare(RGW_ATTR_OBJECT_LEGAL_HOLD) == 0 && get_legal_hold) {\n         RGWObjectLegalHold legal_hold;\n         try {\n           decode(legal_hold, iter->second);\n           dump_header(s, \"x-amz-object-lock-legal-hold\",legal_hold.get_status());\n         } catch (buffer::error& err) {\n           ldpp_dout(this, 0) << \"ERROR: failed to decode RGWObjectLegalHold\" << dendl;\n         }\n       }\n     }\n   }\n \n done:\n   for (riter = response_attrs.begin(); riter != response_attrs.end();\n        ++riter) {\n     dump_header(s, riter->first, riter->second);\n   }\n \n   if (op_ret == -ERR_NOT_MODIFIED) {\n       end_header(s, this);\n   } else {\n       if (!content_type)\n           content_type = \"binary/octet-stream\";\n \n       end_header(s, this, content_type);\n   }\n \n   if (metadata_bl.length()) {\n     dump_body(s, metadata_bl);\n   }\n   sent_header = true;\n \n send_data:\n   if (get_data && !op_ret) {\n     int r = dump_body(s, bl.c_str() + bl_ofs, bl_len);\n     if (r < 0)\n       return r;\n   }\n \n   return 0;\n }\n \n", "target": "// fix_start\n        if(str_has_cntrl(val)) {\n          return -ERR_INVALID_REQUEST;\n        }\n\n// fix_end\n", "cwe": "CWE-79", "cwe_name": "Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')", "cve": "CVE-2020-1760", "cve_desc": "A flaw was found in the Ceph Object Gateway, where it supports request sent by an anonymous user in Amazon S3. This flaw could lead to potential XSS attacks due to the lack of proper neutralization of untrusted input.", "project": "ceph", "idx": 212167}
{"source": " gtTileContig(TIFFRGBAImage* img, uint32* raster, uint32 w, uint32 h)\n {\n     TIFF* tif = img->tif;\n     tileContigRoutine put = img->put.contig;\n     uint32 col, row, y, rowstoread;\n     tmsize_t pos;\n     uint32 tw, th;\n     unsigned char* buf = NULL;\n     int32 fromskew, toskew;\n     uint32 nrow;\n     int ret = 1, flip;\n     uint32 this_tw, tocol;\n     int32 this_toskew, leftmost_toskew;\n     int32 leftmost_fromskew;\n     uint32 leftmost_tw;\n     tmsize_t bufsize;\n \n     bufsize = TIFFTileSize(tif);\n     if (bufsize == 0) {\n         TIFFErrorExt(tif->tif_clientdata, TIFFFileName(tif), \"%s\", \"No space for tile buffer\");\n         return (0);\n     }\n \n     TIFFGetField(tif, TIFFTAG_TILEWIDTH, &tw);\n     TIFFGetField(tif, TIFFTAG_TILELENGTH, &th);\n \n     flip = setorientation(img);\n     if (flip & FLIP_VERTICALLY) {\n// bug_start\n\t    y = h - 1;\n\t    toskew = -(int32)(tw + w);\n// bug_end\n     }\n     else {\n// bug_start\n\t    y = 0;\n\t    toskew = -(int32)(tw - w);\n// bug_end\n     }\n \n     leftmost_fromskew = img->col_offset % tw;\n     leftmost_tw = tw - leftmost_fromskew;\n     leftmost_toskew = toskew + leftmost_fromskew;\n     for (row = 0; ret != 0 && row < h; row += nrow)\n     {\n         rowstoread = th - (row + img->row_offset) % th;\n     \tnrow = (row + rowstoread > h ? h - row : rowstoread);\n \tfromskew = leftmost_fromskew;\n \tthis_tw = leftmost_tw;\n \tthis_toskew = leftmost_toskew;\n \ttocol = 0;\n \tcol = img->col_offset;\n \twhile (tocol < w)\n         {\n \t    if (_TIFFReadTileAndAllocBuffer(tif, (void**) &buf, bufsize, col,\n \t\t\t     row+img->row_offset, 0, 0)==(tmsize_t)(-1) &&\n                 (buf == NULL || img->stoponerr))\n             {\n                 ret = 0;\n                 break;\n             }\n             pos = ((row+img->row_offset) % th) * TIFFTileRowSize(tif) + \\\n \t\t   ((tmsize_t) fromskew * img->samplesperpixel);\n \t    if (tocol + this_tw > w)\n \t    {\n \t\tfromskew = tw - (w - tocol);\n \t\tthis_tw = tw - fromskew;\n \t\tthis_toskew = toskew + fromskew;\n \t    }\n \t    (*put)(img, raster+y*w+tocol, tocol, y, this_tw, nrow, fromskew, this_toskew, buf + pos);\n \t    tocol += this_tw;\n \t    col += this_tw;\n \t    fromskew = 0;\n \t    this_tw = tw;\n \t    this_toskew = toskew;\n \t}\n \n         y += ((flip & FLIP_VERTICALLY) ? -(int32) nrow : (int32) nrow);\n     }\n     _TIFFfree(buf);\n \n     if (flip & FLIP_HORIZONTALLY) {\n \t    uint32 line;\n \n \t    for (line = 0; line < h; line++) {\n \t\t    uint32 *left = raster + (line * w);\n \t\t    uint32 *right = left + w - 1;\n \n \t\t    while ( left < right ) {\n \t\t\t    uint32 temp = *left;\n \t\t\t    *left = *right;\n \t\t\t    *right = temp;\n \t\t\t    left++;\n \t\t\t\tright--;\n \t\t    }\n \t    }\n     }\n \n     return (ret);\n }\n \n", "target": "// fix_start\n        if ((tw + w) > INT_MAX) {\n            TIFFErrorExt(tif->tif_clientdata, TIFFFileName(tif), \"%s\", \"unsupported tile size (too wide)\");\n            return (0);\n        }\n        y = h - 1;\n        toskew = -(int32)(tw + w);\n// fix_end\n// fix_start\n        if (tw > (INT_MAX + w)) {\n            TIFFErrorExt(tif->tif_clientdata, TIFFFileName(tif), \"%s\", \"unsupported tile size (too wide)\");\n            return (0);\n        }\n        y = 0;\n        toskew = -(int32)(tw - w);\n// fix_end\n", "cwe": "CWE-190", "cwe_name": "Integer Overflow or Wraparound", "cve": "CVE-2020-35523", "cve_desc": "An integer overflow flaw was found in libtiff that exists in the tif_getimage.c file. This flaw allows an attacker to inject and execute arbitrary code when a user opens a crafted TIFF file. The highest threat from this vulnerability is to confidentiality, integrity, as well as system availability.", "project": "libtiff", "idx": 212214}
{"source": " static void io_async_task_func(struct callback_head *cb)\n {\n \tstruct io_kiocb *req = container_of(cb, struct io_kiocb, task_work);\n \tstruct async_poll *apoll = req->apoll;\n \tstruct io_ring_ctx *ctx = req->ctx;\n \n \ttrace_io_uring_task_run(req->ctx, req->opcode, req->user_data);\n \n \tif (io_poll_rewait(req, &apoll->poll)) {\n \t\tspin_unlock_irq(&ctx->completion_lock);\n// bug_start\n// bug_end\n \t\treturn;\n \t}\n \n \tif (hash_hashed(&req->hash_node))\n \t\thash_del(&req->hash_node);\n \n \tio_poll_remove_double(req, apoll->double_poll);\n \tspin_unlock_irq(&ctx->completion_lock);\n \n \tif (!READ_ONCE(apoll->poll.canceled))\n \t\t__io_req_task_submit(req);\n \telse\n \t\t__io_req_task_cancel(req, -ECANCELED);\n \n// bug_start\n// bug_end\n \tkfree(apoll->double_poll);\n \tkfree(apoll);\n }\n \n", "target": "// fix_start\n\t\tpercpu_ref_put(&ctx->refs);\n// fix_end\n// fix_start\n\tpercpu_ref_put(&ctx->refs);\n// fix_end\n", "cwe": "CWE-416", "cwe_name": "Use After Free", "cve": "CVE-2020-36387", "cve_desc": "An issue was discovered in the Linux kernel before 5.8.2. fs/io_uring.c has a use-after-free related to io_async_task_func and ctx reference holding, aka CID-6d816e088c35.", "project": "linux", "idx": 212266}
{"source": " \n private int\n mget(struct magic_set *ms, const unsigned char *s, struct magic *m,\n     size_t nbytes, size_t o, unsigned int cont_level, int mode, int text,\n     int flip, int recursion_level, int *printed_something,\n     int *need_separator, int *returnval)\n {\n \tuint32_t soffset, offset = ms->offset;\n \tuint32_t count = m->str_range;\n \tint rv, oneed_separator;\n \tchar *sbuf, *rbuf;\n \tunion VALUETYPE *p = &ms->ms_value;\n \tstruct mlist ml;\n \n \tif (recursion_level >= 20) {\n \t\tfile_error(ms, 0, \"recursion nesting exceeded\");\n \t\treturn -1;\n \t}\n \n \tif (mcopy(ms, p, m->type, m->flag & INDIR, s, (uint32_t)(offset + o),\n \t    (uint32_t)nbytes, count) == -1)\n \t\treturn -1;\n \n \tif ((ms->flags & MAGIC_DEBUG) != 0) {\n \t\tfprintf(stderr, \"mget(type=%d, flag=%x, offset=%u, o=%zu, \"\n \t\t    \"nbytes=%zu, count=%u)\\n\", m->type, m->flag, offset, o,\n \t\t    nbytes, count);\n \t\tmdebug(offset, (char *)(void *)p, sizeof(union VALUETYPE));\n \t}\n \n \tif (m->flag & INDIR) {\n \t\tint off = m->in_offset;\n \t\tif (m->in_op & FILE_OPINDIRECT) {\n \t\t\tconst union VALUETYPE *q = CAST(const union VALUETYPE *,\n \t\t\t    ((const void *)(s + offset + off)));\n \t\t\tswitch (cvt_flip(m->in_type, flip)) {\n \t\t\tcase FILE_BYTE:\n \t\t\t\toff = q->b;\n \t\t\t\tbreak;\n \t\t\tcase FILE_SHORT:\n \t\t\t\toff = q->h;\n \t\t\t\tbreak;\n \t\t\tcase FILE_BESHORT:\n \t\t\t\toff = (short)((q->hs[0]<<8)|(q->hs[1]));\n \t\t\t\tbreak;\n \t\t\tcase FILE_LESHORT:\n \t\t\t\toff = (short)((q->hs[1]<<8)|(q->hs[0]));\n \t\t\t\tbreak;\n \t\t\tcase FILE_LONG:\n \t\t\t\toff = q->l;\n \t\t\t\tbreak;\n \t\t\tcase FILE_BELONG:\n \t\t\tcase FILE_BEID3:\n \t\t\t\toff = (int32_t)((q->hl[0]<<24)|(q->hl[1]<<16)|\n \t\t\t\t\t\t (q->hl[2]<<8)|(q->hl[3]));\n \t\t\t\tbreak;\n \t\t\tcase FILE_LEID3:\n \t\t\tcase FILE_LELONG:\n \t\t\t\toff = (int32_t)((q->hl[3]<<24)|(q->hl[2]<<16)|\n \t\t\t\t\t\t (q->hl[1]<<8)|(q->hl[0]));\n \t\t\t\tbreak;\n \t\t\tcase FILE_MELONG:\n \t\t\t\toff = (int32_t)((q->hl[1]<<24)|(q->hl[0]<<16)|\n \t\t\t\t\t\t (q->hl[3]<<8)|(q->hl[2]));\n \t\t\t\tbreak;\n \t\t\t}\n \t\t\tif ((ms->flags & MAGIC_DEBUG) != 0)\n \t\t\t\tfprintf(stderr, \"indirect offs=%u\\n\", off);\n \t\t}\n \t\tswitch (cvt_flip(m->in_type, flip)) {\n \t\tcase FILE_BYTE:\n \t\t\tif (nbytes < (offset + 1))\n \t\t\t\treturn 0;\n \t\t\tif (off) {\n \t\t\t\tswitch (m->in_op & FILE_OPS_MASK) {\n \t\t\t\tcase FILE_OPAND:\n \t\t\t\t\toffset = p->b & off;\n \t\t\t\t\tbreak;\n \t\t\t\tcase FILE_OPOR:\n \t\t\t\t\toffset = p->b | off;\n \t\t\t\t\tbreak;\n \t\t\t\tcase FILE_OPXOR:\n \t\t\t\t\toffset = p->b ^ off;\n \t\t\t\t\tbreak;\n \t\t\t\tcase FILE_OPADD:\n \t\t\t\t\toffset = p->b + off;\n \t\t\t\t\tbreak;\n \t\t\t\tcase FILE_OPMINUS:\n \t\t\t\t\toffset = p->b - off;\n \t\t\t\t\tbreak;\n \t\t\t\tcase FILE_OPMULTIPLY:\n \t\t\t\t\toffset = p->b * off;\n \t\t\t\t\tbreak;\n \t\t\t\tcase FILE_OPDIVIDE:\n \t\t\t\t\toffset = p->b / off;\n \t\t\t\t\tbreak;\n \t\t\t\tcase FILE_OPMODULO:\n \t\t\t\t\toffset = p->b % off;\n \t\t\t\t\tbreak;\n \t\t\t\t}\n \t\t\t} else\n \t\t\t\toffset = p->b;\n \t\t\tif (m->in_op & FILE_OPINVERSE)\n \t\t\t\toffset = ~offset;\n \t\t\tbreak;\n \t\tcase FILE_BESHORT:\n \t\t\tif (nbytes < (offset + 2))\n \t\t\t\treturn 0;\n \t\t\tif (off) {\n \t\t\t\tswitch (m->in_op & FILE_OPS_MASK) {\n \t\t\t\tcase FILE_OPAND:\n \t\t\t\t\toffset = (short)((p->hs[0]<<8)|\n \t\t\t\t\t\t\t (p->hs[1])) &\n \t\t\t\t\t\t off;\n \t\t\t\t\tbreak;\n \t\t\t\tcase FILE_OPOR:\n \t\t\t\t\toffset = (short)((p->hs[0]<<8)|\n \t\t\t\t\t\t\t (p->hs[1])) |\n \t\t\t\t\t\t off;\n \t\t\t\t\tbreak;\n \t\t\t\tcase FILE_OPXOR:\n \t\t\t\t\toffset = (short)((p->hs[0]<<8)|\n \t\t\t\t\t\t\t (p->hs[1])) ^\n \t\t\t\t\t\t off;\n \t\t\t\t\tbreak;\n \t\t\t\tcase FILE_OPADD:\n \t\t\t\t\toffset = (short)((p->hs[0]<<8)|\n \t\t\t\t\t\t\t (p->hs[1])) +\n \t\t\t\t\t\t off;\n \t\t\t\t\tbreak;\n \t\t\t\tcase FILE_OPMINUS:\n \t\t\t\t\toffset = (short)((p->hs[0]<<8)|\n \t\t\t\t\t\t\t (p->hs[1])) -\n \t\t\t\t\t\t off;\n \t\t\t\t\tbreak;\n \t\t\t\tcase FILE_OPMULTIPLY:\n \t\t\t\t\toffset = (short)((p->hs[0]<<8)|\n \t\t\t\t\t\t\t (p->hs[1])) *\n \t\t\t\t\t\t off;\n \t\t\t\t\tbreak;\n \t\t\t\tcase FILE_OPDIVIDE:\n \t\t\t\t\toffset = (short)((p->hs[0]<<8)|\n \t\t\t\t\t\t\t (p->hs[1])) /\n \t\t\t\t\t\t off;\n \t\t\t\t\tbreak;\n \t\t\t\tcase FILE_OPMODULO:\n \t\t\t\t\toffset = (short)((p->hs[0]<<8)|\n \t\t\t\t\t\t\t (p->hs[1])) %\n \t\t\t\t\t\t off;\n \t\t\t\t\tbreak;\n \t\t\t\t}\n \t\t\t} else\n \t\t\t\toffset = (short)((p->hs[0]<<8)|\n \t\t\t\t\t\t (p->hs[1]));\n \t\t\tif (m->in_op & FILE_OPINVERSE)\n \t\t\t\toffset = ~offset;\n \t\t\tbreak;\n \t\tcase FILE_LESHORT:\n \t\t\tif (nbytes < (offset + 2))\n \t\t\t\treturn 0;\n \t\t\tif (off) {\n \t\t\t\tswitch (m->in_op & FILE_OPS_MASK) {\n \t\t\t\tcase FILE_OPAND:\n \t\t\t\t\toffset = (short)((p->hs[1]<<8)|\n \t\t\t\t\t\t\t (p->hs[0])) &\n \t\t\t\t\t\t off;\n \t\t\t\t\tbreak;\n \t\t\t\tcase FILE_OPOR:\n \t\t\t\t\toffset = (short)((p->hs[1]<<8)|\n \t\t\t\t\t\t\t (p->hs[0])) |\n \t\t\t\t\t\t off;\n \t\t\t\t\tbreak;\n \t\t\t\tcase FILE_OPXOR:\n \t\t\t\t\toffset = (short)((p->hs[1]<<8)|\n \t\t\t\t\t\t\t (p->hs[0])) ^\n \t\t\t\t\t\t off;\n \t\t\t\t\tbreak;\n \t\t\t\tcase FILE_OPADD:\n \t\t\t\t\toffset = (short)((p->hs[1]<<8)|\n \t\t\t\t\t\t\t (p->hs[0])) +\n \t\t\t\t\t\t off;\n \t\t\t\t\tbreak;\n \t\t\t\tcase FILE_OPMINUS:\n \t\t\t\t\toffset = (short)((p->hs[1]<<8)|\n \t\t\t\t\t\t\t (p->hs[0])) -\n \t\t\t\t\t\t off;\n \t\t\t\t\tbreak;\n \t\t\t\tcase FILE_OPMULTIPLY:\n \t\t\t\t\toffset = (short)((p->hs[1]<<8)|\n \t\t\t\t\t\t\t (p->hs[0])) *\n \t\t\t\t\t\t off;\n \t\t\t\t\tbreak;\n \t\t\t\tcase FILE_OPDIVIDE:\n \t\t\t\t\toffset = (short)((p->hs[1]<<8)|\n \t\t\t\t\t\t\t (p->hs[0])) /\n \t\t\t\t\t\t off;\n \t\t\t\t\tbreak;\n \t\t\t\tcase FILE_OPMODULO:\n \t\t\t\t\toffset = (short)((p->hs[1]<<8)|\n \t\t\t\t\t\t\t (p->hs[0])) %\n \t\t\t\t\t\t off;\n \t\t\t\t\tbreak;\n \t\t\t\t}\n \t\t\t} else\n \t\t\t\toffset = (short)((p->hs[1]<<8)|\n \t\t\t\t\t\t (p->hs[0]));\n \t\t\tif (m->in_op & FILE_OPINVERSE)\n \t\t\t\toffset = ~offset;\n \t\t\tbreak;\n \t\tcase FILE_SHORT:\n \t\t\tif (nbytes < (offset + 2))\n \t\t\t\treturn 0;\n \t\t\tif (off) {\n \t\t\t\tswitch (m->in_op & FILE_OPS_MASK) {\n \t\t\t\tcase FILE_OPAND:\n \t\t\t\t\toffset = p->h & off;\n \t\t\t\t\tbreak;\n \t\t\t\tcase FILE_OPOR:\n \t\t\t\t\toffset = p->h | off;\n \t\t\t\t\tbreak;\n \t\t\t\tcase FILE_OPXOR:\n \t\t\t\t\toffset = p->h ^ off;\n \t\t\t\t\tbreak;\n \t\t\t\tcase FILE_OPADD:\n \t\t\t\t\toffset = p->h + off;\n \t\t\t\t\tbreak;\n \t\t\t\tcase FILE_OPMINUS:\n \t\t\t\t\toffset = p->h - off;\n \t\t\t\t\tbreak;\n \t\t\t\tcase FILE_OPMULTIPLY:\n \t\t\t\t\toffset = p->h * off;\n \t\t\t\t\tbreak;\n \t\t\t\tcase FILE_OPDIVIDE:\n \t\t\t\t\toffset = p->h / off;\n \t\t\t\t\tbreak;\n \t\t\t\tcase FILE_OPMODULO:\n \t\t\t\t\toffset = p->h % off;\n \t\t\t\t\tbreak;\n \t\t\t\t}\n \t\t\t}\n \t\t\telse\n \t\t\t\toffset = p->h;\n \t\t\tif (m->in_op & FILE_OPINVERSE)\n \t\t\t\toffset = ~offset;\n \t\t\tbreak;\n \t\tcase FILE_BELONG:\n \t\tcase FILE_BEID3:\n \t\t\tif (nbytes < (offset + 4))\n \t\t\t\treturn 0;\n \t\t\tif (off) {\n \t\t\t\tswitch (m->in_op & FILE_OPS_MASK) {\n \t\t\t\tcase FILE_OPAND:\n \t\t\t\t\toffset = (int32_t)((p->hl[0]<<24)|\n \t\t\t\t\t\t\t (p->hl[1]<<16)|\n \t\t\t\t\t\t\t (p->hl[2]<<8)|\n \t\t\t\t\t\t\t (p->hl[3])) &\n \t\t\t\t\t\t off;\n \t\t\t\t\tbreak;\n \t\t\t\tcase FILE_OPOR:\n \t\t\t\t\toffset = (int32_t)((p->hl[0]<<24)|\n \t\t\t\t\t\t\t (p->hl[1]<<16)|\n \t\t\t\t\t\t\t (p->hl[2]<<8)|\n \t\t\t\t\t\t\t (p->hl[3])) |\n \t\t\t\t\t\t off;\n \t\t\t\t\tbreak;\n \t\t\t\tcase FILE_OPXOR:\n \t\t\t\t\toffset = (int32_t)((p->hl[0]<<24)|\n \t\t\t\t\t\t\t (p->hl[1]<<16)|\n \t\t\t\t\t\t\t (p->hl[2]<<8)|\n \t\t\t\t\t\t\t (p->hl[3])) ^\n \t\t\t\t\t\t off;\n \t\t\t\t\tbreak;\n \t\t\t\tcase FILE_OPADD:\n \t\t\t\t\toffset = (int32_t)((p->hl[0]<<24)|\n \t\t\t\t\t\t\t (p->hl[1]<<16)|\n \t\t\t\t\t\t\t (p->hl[2]<<8)|\n \t\t\t\t\t\t\t (p->hl[3])) +\n \t\t\t\t\t\t off;\n \t\t\t\t\tbreak;\n \t\t\t\tcase FILE_OPMINUS:\n \t\t\t\t\toffset = (int32_t)((p->hl[0]<<24)|\n \t\t\t\t\t\t\t (p->hl[1]<<16)|\n \t\t\t\t\t\t\t (p->hl[2]<<8)|\n \t\t\t\t\t\t\t (p->hl[3])) -\n \t\t\t\t\t\t off;\n \t\t\t\t\tbreak;\n \t\t\t\tcase FILE_OPMULTIPLY:\n \t\t\t\t\toffset = (int32_t)((p->hl[0]<<24)|\n \t\t\t\t\t\t\t (p->hl[1]<<16)|\n \t\t\t\t\t\t\t (p->hl[2]<<8)|\n \t\t\t\t\t\t\t (p->hl[3])) *\n \t\t\t\t\t\t off;\n \t\t\t\t\tbreak;\n \t\t\t\tcase FILE_OPDIVIDE:\n \t\t\t\t\toffset = (int32_t)((p->hl[0]<<24)|\n \t\t\t\t\t\t\t (p->hl[1]<<16)|\n \t\t\t\t\t\t\t (p->hl[2]<<8)|\n \t\t\t\t\t\t\t (p->hl[3])) /\n \t\t\t\t\t\t off;\n \t\t\t\t\tbreak;\n \t\t\t\tcase FILE_OPMODULO:\n \t\t\t\t\toffset = (int32_t)((p->hl[0]<<24)|\n \t\t\t\t\t\t\t (p->hl[1]<<16)|\n \t\t\t\t\t\t\t (p->hl[2]<<8)|\n \t\t\t\t\t\t\t (p->hl[3])) %\n \t\t\t\t\t\t off;\n \t\t\t\t\tbreak;\n \t\t\t\t}\n \t\t\t} else\n \t\t\t\toffset = (int32_t)((p->hl[0]<<24)|\n \t\t\t\t\t\t (p->hl[1]<<16)|\n \t\t\t\t\t\t (p->hl[2]<<8)|\n \t\t\t\t\t\t (p->hl[3]));\n \t\t\tif (m->in_op & FILE_OPINVERSE)\n \t\t\t\toffset = ~offset;\n \t\t\tbreak;\n \t\tcase FILE_LELONG:\n \t\tcase FILE_LEID3:\n \t\t\tif (nbytes < (offset + 4))\n \t\t\t\treturn 0;\n \t\t\tif (off) {\n \t\t\t\tswitch (m->in_op & FILE_OPS_MASK) {\n \t\t\t\tcase FILE_OPAND:\n \t\t\t\t\toffset = (int32_t)((p->hl[3]<<24)|\n \t\t\t\t\t\t\t (p->hl[2]<<16)|\n \t\t\t\t\t\t\t (p->hl[1]<<8)|\n \t\t\t\t\t\t\t (p->hl[0])) &\n \t\t\t\t\t\t off;\n \t\t\t\t\tbreak;\n \t\t\t\tcase FILE_OPOR:\n \t\t\t\t\toffset = (int32_t)((p->hl[3]<<24)|\n \t\t\t\t\t\t\t (p->hl[2]<<16)|\n \t\t\t\t\t\t\t (p->hl[1]<<8)|\n \t\t\t\t\t\t\t (p->hl[0])) |\n \t\t\t\t\t\t off;\n \t\t\t\t\tbreak;\n \t\t\t\tcase FILE_OPXOR:\n \t\t\t\t\toffset = (int32_t)((p->hl[3]<<24)|\n \t\t\t\t\t\t\t (p->hl[2]<<16)|\n \t\t\t\t\t\t\t (p->hl[1]<<8)|\n \t\t\t\t\t\t\t (p->hl[0])) ^\n \t\t\t\t\t\t off;\n \t\t\t\t\tbreak;\n \t\t\t\tcase FILE_OPADD:\n \t\t\t\t\toffset = (int32_t)((p->hl[3]<<24)|\n \t\t\t\t\t\t\t (p->hl[2]<<16)|\n \t\t\t\t\t\t\t (p->hl[1]<<8)|\n \t\t\t\t\t\t\t (p->hl[0])) +\n \t\t\t\t\t\t off;\n \t\t\t\t\tbreak;\n \t\t\t\tcase FILE_OPMINUS:\n \t\t\t\t\toffset = (int32_t)((p->hl[3]<<24)|\n \t\t\t\t\t\t\t (p->hl[2]<<16)|\n \t\t\t\t\t\t\t (p->hl[1]<<8)|\n \t\t\t\t\t\t\t (p->hl[0])) -\n \t\t\t\t\t\t off;\n \t\t\t\t\tbreak;\n \t\t\t\tcase FILE_OPMULTIPLY:\n \t\t\t\t\toffset = (int32_t)((p->hl[3]<<24)|\n \t\t\t\t\t\t\t (p->hl[2]<<16)|\n \t\t\t\t\t\t\t (p->hl[1]<<8)|\n \t\t\t\t\t\t\t (p->hl[0])) *\n \t\t\t\t\t\t off;\n \t\t\t\t\tbreak;\n \t\t\t\tcase FILE_OPDIVIDE:\n \t\t\t\t\toffset = (int32_t)((p->hl[3]<<24)|\n \t\t\t\t\t\t\t (p->hl[2]<<16)|\n \t\t\t\t\t\t\t (p->hl[1]<<8)|\n \t\t\t\t\t\t\t (p->hl[0])) /\n \t\t\t\t\t\t off;\n \t\t\t\t\tbreak;\n \t\t\t\tcase FILE_OPMODULO:\n \t\t\t\t\toffset = (int32_t)((p->hl[3]<<24)|\n \t\t\t\t\t\t\t (p->hl[2]<<16)|\n \t\t\t\t\t\t\t (p->hl[1]<<8)|\n \t\t\t\t\t\t\t (p->hl[0])) %\n \t\t\t\t\t\t off;\n \t\t\t\t\tbreak;\n \t\t\t\t}\n \t\t\t} else\n \t\t\t\toffset = (int32_t)((p->hl[3]<<24)|\n \t\t\t\t\t\t (p->hl[2]<<16)|\n \t\t\t\t\t\t (p->hl[1]<<8)|\n \t\t\t\t\t\t (p->hl[0]));\n \t\t\tif (m->in_op & FILE_OPINVERSE)\n \t\t\t\toffset = ~offset;\n \t\t\tbreak;\n \t\tcase FILE_MELONG:\n \t\t\tif (nbytes < (offset + 4))\n \t\t\t\treturn 0;\n \t\t\tif (off) {\n \t\t\t\tswitch (m->in_op & FILE_OPS_MASK) {\n \t\t\t\tcase FILE_OPAND:\n \t\t\t\t\toffset = (int32_t)((p->hl[1]<<24)|\n \t\t\t\t\t\t\t (p->hl[0]<<16)|\n \t\t\t\t\t\t\t (p->hl[3]<<8)|\n \t\t\t\t\t\t\t (p->hl[2])) &\n \t\t\t\t\t\t off;\n \t\t\t\t\tbreak;\n \t\t\t\tcase FILE_OPOR:\n \t\t\t\t\toffset = (int32_t)((p->hl[1]<<24)|\n \t\t\t\t\t\t\t (p->hl[0]<<16)|\n \t\t\t\t\t\t\t (p->hl[3]<<8)|\n \t\t\t\t\t\t\t (p->hl[2])) |\n \t\t\t\t\t\t off;\n \t\t\t\t\tbreak;\n \t\t\t\tcase FILE_OPXOR:\n \t\t\t\t\toffset = (int32_t)((p->hl[1]<<24)|\n \t\t\t\t\t\t\t (p->hl[0]<<16)|\n \t\t\t\t\t\t\t (p->hl[3]<<8)|\n \t\t\t\t\t\t\t (p->hl[2])) ^\n \t\t\t\t\t\t off;\n \t\t\t\t\tbreak;\n \t\t\t\tcase FILE_OPADD:\n \t\t\t\t\toffset = (int32_t)((p->hl[1]<<24)|\n \t\t\t\t\t\t\t (p->hl[0]<<16)|\n \t\t\t\t\t\t\t (p->hl[3]<<8)|\n \t\t\t\t\t\t\t (p->hl[2])) +\n \t\t\t\t\t\t off;\n \t\t\t\t\tbreak;\n \t\t\t\tcase FILE_OPMINUS:\n \t\t\t\t\toffset = (int32_t)((p->hl[1]<<24)|\n \t\t\t\t\t\t\t (p->hl[0]<<16)|\n \t\t\t\t\t\t\t (p->hl[3]<<8)|\n \t\t\t\t\t\t\t (p->hl[2])) -\n \t\t\t\t\t\t off;\n \t\t\t\t\tbreak;\n \t\t\t\tcase FILE_OPMULTIPLY:\n \t\t\t\t\toffset = (int32_t)((p->hl[1]<<24)|\n \t\t\t\t\t\t\t (p->hl[0]<<16)|\n \t\t\t\t\t\t\t (p->hl[3]<<8)|\n \t\t\t\t\t\t\t (p->hl[2])) *\n \t\t\t\t\t\t off;\n \t\t\t\t\tbreak;\n \t\t\t\tcase FILE_OPDIVIDE:\n \t\t\t\t\toffset = (int32_t)((p->hl[1]<<24)|\n \t\t\t\t\t\t\t (p->hl[0]<<16)|\n \t\t\t\t\t\t\t (p->hl[3]<<8)|\n \t\t\t\t\t\t\t (p->hl[2])) /\n \t\t\t\t\t\t off;\n \t\t\t\t\tbreak;\n \t\t\t\tcase FILE_OPMODULO:\n \t\t\t\t\toffset = (int32_t)((p->hl[1]<<24)|\n \t\t\t\t\t\t\t (p->hl[0]<<16)|\n \t\t\t\t\t\t\t (p->hl[3]<<8)|\n \t\t\t\t\t\t\t (p->hl[2])) %\n \t\t\t\t\t\t off;\n \t\t\t\t\tbreak;\n \t\t\t\t}\n \t\t\t} else\n \t\t\t\toffset = (int32_t)((p->hl[1]<<24)|\n \t\t\t\t\t\t (p->hl[0]<<16)|\n \t\t\t\t\t\t (p->hl[3]<<8)|\n \t\t\t\t\t\t (p->hl[2]));\n \t\t\tif (m->in_op & FILE_OPINVERSE)\n \t\t\t\toffset = ~offset;\n \t\t\tbreak;\n \t\tcase FILE_LONG:\n \t\t\tif (nbytes < (offset + 4))\n \t\t\t\treturn 0;\n \t\t\tif (off) {\n \t\t\t\tswitch (m->in_op & FILE_OPS_MASK) {\n \t\t\t\tcase FILE_OPAND:\n \t\t\t\t\toffset = p->l & off;\n \t\t\t\t\tbreak;\n \t\t\t\tcase FILE_OPOR:\n \t\t\t\t\toffset = p->l | off;\n \t\t\t\t\tbreak;\n \t\t\t\tcase FILE_OPXOR:\n \t\t\t\t\toffset = p->l ^ off;\n \t\t\t\t\tbreak;\n \t\t\t\tcase FILE_OPADD:\n \t\t\t\t\toffset = p->l + off;\n \t\t\t\t\tbreak;\n \t\t\t\tcase FILE_OPMINUS:\n \t\t\t\t\toffset = p->l - off;\n \t\t\t\t\tbreak;\n \t\t\t\tcase FILE_OPMULTIPLY:\n \t\t\t\t\toffset = p->l * off;\n \t\t\t\t\tbreak;\n \t\t\t\tcase FILE_OPDIVIDE:\n \t\t\t\t\toffset = p->l / off;\n \t\t\t\t\tbreak;\n \t\t\t\tcase FILE_OPMODULO:\n \t\t\t\t\toffset = p->l % off;\n \t\t\t\t\tbreak;\n \t\t\t\t}\n \t\t\t} else\n \t\t\t\toffset = p->l;\n \t\t\tif (m->in_op & FILE_OPINVERSE)\n \t\t\t\toffset = ~offset;\n \t\t\tbreak;\n \t\t}\n \n \t\tswitch (cvt_flip(m->in_type, flip)) {\n \t\tcase FILE_LEID3:\n \t\tcase FILE_BEID3:\n \t\t\toffset = ((((offset >>  0) & 0x7f) <<  0) |\n \t\t\t\t (((offset >>  8) & 0x7f) <<  7) |\n \t\t\t\t (((offset >> 16) & 0x7f) << 14) |\n \t\t\t\t (((offset >> 24) & 0x7f) << 21)) + 10;\n \t\t\tbreak;\n \t\tdefault:\n \t\t\tbreak;\n \t\t}\n \n \t\tif (m->flag & INDIROFFADD) {\n \t\t\toffset += ms->c.li[cont_level-1].off;\n \t\t\tif (offset == 0) {\n \t\t\t\tif ((ms->flags & MAGIC_DEBUG) != 0)\n \t\t\t\t\tfprintf(stderr,\n \t\t\t\t\t    \"indirect *zero* offset\\n\");\n \t\t\t\treturn 0;\n \t\t\t}\n \t\t\tif ((ms->flags & MAGIC_DEBUG) != 0)\n \t\t\t\tfprintf(stderr, \"indirect +offs=%u\\n\", offset);\n \t\t}\n \t\tif (mcopy(ms, p, m->type, 0, s, offset, nbytes, count) == -1)\n \t\t\treturn -1;\n \t\tms->offset = offset;\n \n \t\tif ((ms->flags & MAGIC_DEBUG) != 0) {\n \t\t\tmdebug(offset, (char *)(void *)p,\n \t\t\t    sizeof(union VALUETYPE));\n \t\t}\n \t}\n \n \tswitch (m->type) {\n \tcase FILE_BYTE:\n \t\tif (nbytes < (offset + 1))\n \t\t\treturn 0;\n \t\tbreak;\n \n \tcase FILE_SHORT:\n \tcase FILE_BESHORT:\n \tcase FILE_LESHORT:\n \t\tif (nbytes < (offset + 2))\n \t\t\treturn 0;\n \t\tbreak;\n \n \tcase FILE_LONG:\n \tcase FILE_BELONG:\n \tcase FILE_LELONG:\n \tcase FILE_MELONG:\n \tcase FILE_DATE:\n \tcase FILE_BEDATE:\n \tcase FILE_LEDATE:\n \tcase FILE_MEDATE:\n \tcase FILE_LDATE:\n \tcase FILE_BELDATE:\n \tcase FILE_LELDATE:\n \tcase FILE_MELDATE:\n \tcase FILE_FLOAT:\n \tcase FILE_BEFLOAT:\n \tcase FILE_LEFLOAT:\n \t\tif (nbytes < (offset + 4))\n \t\t\treturn 0;\n \t\tbreak;\n \n \tcase FILE_DOUBLE:\n \tcase FILE_BEDOUBLE:\n \tcase FILE_LEDOUBLE:\n \t\tif (nbytes < (offset + 8))\n \t\t\treturn 0;\n \t\tbreak;\n \n \tcase FILE_STRING:\n \tcase FILE_PSTRING:\n \tcase FILE_SEARCH:\n \t\tif (nbytes < (offset + m->vallen))\n \t\t\treturn 0;\n \t\tbreak;\n \n \tcase FILE_REGEX:\n \t\tif (nbytes < offset)\n \t\t\treturn 0;\n \t\tbreak;\n \n \tcase FILE_INDIRECT:\n \t\tif (nbytes < offset)\n \t\t\treturn 0;\n \t\tsbuf = ms->o.buf;\n \t\tsoffset = ms->offset;\n \t\tms->o.buf = NULL;\n \t\tms->offset = 0;\n \t\trv = file_softmagic(ms, s + offset, nbytes - offset,\n \t\t    BINTEST, text);\n \t\tif ((ms->flags & MAGIC_DEBUG) != 0)\n \t\t\tfprintf(stderr, \"indirect @offs=%u[%d]\\n\", offset, rv);\n \t\trbuf = ms->o.buf;\n \t\tms->o.buf = sbuf;\n \t\tms->offset = soffset;\n \t\tif (rv == 1) {\n \t  \tif ((ms->flags & (MAGIC_MIME|MAGIC_APPLE)) == 0 &&\n \t\t\t    file_printf(ms, m->desc, offset) == -1)\n \t\t\treturn -1;\n \t\t\tif (file_printf(ms, \"%s\", rbuf) == -1)\n \t\t\t\treturn -1;\n// bug_start\n\t\t\tfree(rbuf);\n// bug_end\n \t\t}\n \t\treturn rv;\n \n \tcase FILE_USE:\n \t\tif (nbytes < offset)\n \t\t\treturn 0;\n \t\tsbuf = m->value.s;\n \t\tif (*sbuf == '^') {\n \t\t\tsbuf++;\n \t\t\tflip = !flip;\n \t\t}\n \t\tif (file_magicfind(ms, sbuf, &ml) == -1) {\n \t\t\tfile_error(ms, 0, \"cannot find entry `%s'\", sbuf);\n \t\t\treturn -1;\n \t\t}\n \n \t\toneed_separator = *need_separator;\n \t\tif (m->flag & NOSPACE)\n \t\t\t*need_separator = 0;\n \t\trv = match(ms, ml.magic, ml.nmagic, s, nbytes, offset + o,\n \t\t    mode, text, flip, recursion_level, printed_something,\n \t\t    need_separator, returnval);\n \t\tif (rv != 1)\n \t\t    *need_separator = oneed_separator;\n \t\treturn rv;\n \n \tcase FILE_NAME:\n \t\tif (file_printf(ms, \"%s\", m->desc) == -1)\n \t\t\treturn -1;\n \t\treturn 1;\n \tcase FILE_DEFAULT:\n \tdefault:\n \t\tbreak;\n \t}\n \tif (!mconvert(ms, m, flip))\n \t\treturn 0;\n \n", "target": "// fix_start\n\t\t\tefree(rbuf);\n// fix_end\n", "cwe": "CWE-20", "cwe_name": "Improper Input Validation", "cve": "CVE-2013-4636", "cve_desc": "The mget function in libmagic/softmagic.c in the Fileinfo component in PHP 5.4.x before 5.4.16 allows remote attackers to cause a denial of service (invalid pointer dereference and application crash) via an MP3 file that triggers incorrect MIME type detection during access to an finfo object.", "project": "php-src", "idx": 212275}
{"source": " ImagingFliDecode(Imaging im, ImagingCodecState state, UINT8 *buf, Py_ssize_t bytes) {\n     UINT8 *ptr;\n     int framesize;\n     int c, chunks, advance;\n     int l, lines;\n     int i, j, x = 0, y, ymax;\n \n \n     if (bytes < 4) {\n         return 0;\n     }\n \n \n     ptr = buf;\n \n     framesize = I32(ptr);\n     if (framesize < I32(ptr)) {\n         return 0;\n     }\n \n \n     if (bytes < 8) {\n         state->errcode = IMAGING_CODEC_OVERRUN;\n         return -1;\n     }\n     if (I16(ptr + 4) != 0xF1FA) {\n         state->errcode = IMAGING_CODEC_UNKNOWN;\n         return -1;\n     }\n \n     chunks = I16(ptr + 6);\n     ptr += 16;\n     bytes -= 16;\n \n     for (c = 0; c < chunks; c++) {\n         UINT8 *data;\n         if (bytes < 10) {\n             state->errcode = IMAGING_CODEC_OVERRUN;\n             return -1;\n         }\n         data = ptr + 6;\n         switch (I16(ptr + 4)) {\n             case 4:\n             case 11:\n                 break;\n             case 7:\n                 lines = I16(data);\n                 data += 2;\n                 for (l = y = 0; l < lines && y < state->ysize; l++, y++) {\n                     UINT8 *local_buf = (UINT8 *)im->image[y];\n                     int p, packets;\n                     ERR_IF_DATA_OOB(2)\n                     packets = I16(data);\n                     data += 2;\n                     while (packets & 0x8000) {\n                         if (packets & 0x4000) {\n                             y += 65536 - packets;\n                             if (y >= state->ysize) {\n                                 state->errcode = IMAGING_CODEC_OVERRUN;\n                                 return -1;\n                             }\n                             local_buf = (UINT8 *)im->image[y];\n                         } else {\n                             local_buf[state->xsize - 1] = (UINT8)packets;\n                         }\n                         ERR_IF_DATA_OOB(2)\n                         packets = I16(data);\n                         data += 2;\n                     }\n                     for (p = x = 0; p < packets; p++) {\n                         ERR_IF_DATA_OOB(2)\n                         x += data[0];\n                         if (data[1] >= 128) {\n                             ERR_IF_DATA_OOB(4)\n                             i = 256 - data[1];\n                             if (x + i + i > state->xsize) {\n                                 break;\n                             }\n                             for (j = 0; j < i; j++) {\n                                 local_buf[x++] = data[2];\n                                 local_buf[x++] = data[3];\n                             }\n                             data += 2 + 2;\n                         } else {\n                             i = 2 * (int)data[1];\n                             if (x + i > state->xsize) {\n                                 break;\n                             }\n                             ERR_IF_DATA_OOB(2 + i)\n                             memcpy(local_buf + x, data + 2, i);\n                             data += 2 + i;\n                             x += i;\n                         }\n                     }\n                     if (p < packets) {\n                         break;\n                     }\n                 }\n                 if (l < lines) {\n                     state->errcode = IMAGING_CODEC_OVERRUN;\n                     return -1;\n                 }\n                 break;\n             case 12:\n                 y = I16(data);\n                 ymax = y + I16(data + 2);\n                 data += 4;\n                 for (; y < ymax && y < state->ysize; y++) {\n                     UINT8 *out = (UINT8 *)im->image[y];\n                     ERR_IF_DATA_OOB(1)\n                     int p, packets = *data++;\n                     for (p = x = 0; p < packets; p++, x += i) {\n                         ERR_IF_DATA_OOB(2)\n                         x += data[0];\n                         if (data[1] & 0x80) {\n                             i = 256 - data[1];\n                             if (x + i > state->xsize) {\n                                 break;\n                             }\n                             ERR_IF_DATA_OOB(3)\n                             memset(out + x, data[2], i);\n                             data += 3;\n                         } else {\n                             i = data[1];\n                             if (x + i > state->xsize) {\n                                 break;\n                             }\n                             ERR_IF_DATA_OOB(2 + i)\n                             memcpy(out + x, data + 2, i);\n                             data += i + 2;\n                         }\n                     }\n                     if (p < packets) {\n                         break;\n                     }\n                 }\n                 if (y < ymax) {\n                     state->errcode = IMAGING_CODEC_OVERRUN;\n                     return -1;\n                 }\n                 break;\n             case 13:\n                 for (y = 0; y < state->ysize; y++) {\n                     memset(im->image[y], 0, state->xsize);\n                 }\n                 break;\n             case 15:\n                 for (y = 0; y < state->ysize; y++) {\n                     UINT8 *out = (UINT8 *)im->image[y];\n                     data += 1;\n                     for (x = 0; x < state->xsize; x += i) {\n                         ERR_IF_DATA_OOB(2)\n                         if (data[0] & 0x80) {\n                             i = 256 - data[0];\n                             if (x + i > state->xsize) {\n                                 break;\n                             }\n                             ERR_IF_DATA_OOB(i + 1)\n                             memcpy(out + x, data + 1, i);\n                             data += i + 1;\n                         } else {\n                             i = data[0];\n                             if (x + i > state->xsize) {\n                                 break;\n                             }\n                             memset(out + x, data[1], i);\n                             data += 2;\n                         }\n                     }\n                     if (x != state->xsize) {\n                         state->errcode = IMAGING_CODEC_OVERRUN;\n                         return -1;\n                     }\n                 }\n                 break;\n             case 16:\n                 if (state->xsize > bytes / state->ysize) {\n                     return ptr - buf;\n                 }\n                 for (y = 0; y < state->ysize; y++) {\n                     UINT8 *local_buf = (UINT8 *)im->image[y];\n                     memcpy(local_buf, data, state->xsize);\n                     data += state->xsize;\n                 }\n                 break;\n             case 18:\n                 break;\n             default:\n                 state->errcode = IMAGING_CODEC_UNKNOWN;\n                 return -1;\n         }\n         advance = I32(ptr);\n// bug_start\n// bug_end\n         if (advance < 0 || advance > bytes) {\n             state->errcode = IMAGING_CODEC_OVERRUN;\n             return -1;\n         }\n         ptr += advance;\n         bytes -= advance;\n     }\n \n     return -1;\n }\n \n", "target": "// fix_start\n        if (advance == 0 ) {\n            state->errcode = IMAGING_CODEC_BROKEN;\n            return -1;\n        }\n// fix_end\n", "cwe": "CWE-835", "cwe_name": "Loop with Unreachable Exit Condition ('Infinite Loop')", "cve": "CVE-2021-28676", "cve_desc": "An issue was discovered in Pillow before 8.2.0. For FLI data, FliDecode did not properly check that the block advance was non-zero, potentially leading to an infinite loop on load.", "project": "Pillow", "idx": 212350}
{"source": " int vt_ioctl(struct tty_struct *tty,\n \t     unsigned int cmd, unsigned long arg)\n {\n \tstruct vc_data *vc = tty->driver_data;\n \tstruct console_font_op op;\n \tunsigned int console;\n \tunsigned char ucval;\n \tunsigned int uival;\n \tvoid __user *up = (void __user *)arg;\n \tint i, perm;\n \tint ret = 0;\n \n \tconsole = vc->vc_num;\n \n \n \tif (!vc_cons_allocated(console)) {\n \t\tret = -ENOIOCTLCMD;\n \t\tgoto out;\n \t}\n \n \n \tperm = 0;\n \tif (current->signal->tty == tty || capable(CAP_SYS_TTY_CONFIG))\n \t\tperm = 1;\n \n \tswitch (cmd) {\n \tcase TIOCLINUX:\n \t\tret = tioclinux(tty, arg);\n \t\tbreak;\n \tcase KIOCSOUND:\n \t\tif (!perm)\n \t\t\treturn -EPERM;\n \t\tif (arg)\n \t\t\targ = PIT_TICK_RATE / arg;\n \t\tkd_mksound(arg, 0);\n \t\tbreak;\n \n \tcase KDMKTONE:\n \t\tif (!perm)\n \t\t\treturn -EPERM;\n \t{\n \t\tunsigned int ticks, count;\n \n \t\tticks = msecs_to_jiffies((arg >> 16) & 0xffff);\n \t\tcount = ticks ? (arg & 0xffff) : 0;\n \t\tif (count)\n \t\t\tcount = PIT_TICK_RATE / count;\n \t\tkd_mksound(count, ticks);\n \t\tbreak;\n \t}\n \n \tcase KDGKBTYPE:\n \t\tucval = KB_101;\n \t\tret = put_user(ucval, (char __user *)arg);\n \t\tbreak;\n \n #ifdef CONFIG_X86\n \tcase KDADDIO:\n \tcase KDDELIO:\n \t\tif (arg < GPFIRST || arg > GPLAST) {\n \t\t\tret = -EINVAL;\n \t\t\tbreak;\n \t\t}\n \t\tret = ksys_ioperm(arg, 1, (cmd == KDADDIO)) ? -ENXIO : 0;\n \t\tbreak;\n \n \tcase KDENABIO:\n \tcase KDDISABIO:\n \t\tret = ksys_ioperm(GPFIRST, GPNUM,\n \t\t\t\t  (cmd == KDENABIO)) ? -ENXIO : 0;\n \t\tbreak;\n #endif\n \n \n \tcase KDKBDREP:\n \t{\n \t\tstruct kbd_repeat kbrep;\n \n \t\tif (!capable(CAP_SYS_TTY_CONFIG))\n \t\t\treturn -EPERM;\n \n \t\tif (copy_from_user(&kbrep, up, sizeof(struct kbd_repeat))) {\n \t\t\tret =  -EFAULT;\n \t\t\tbreak;\n \t\t}\n \t\tret = kbd_rate(&kbrep);\n \t\tif (ret)\n \t\t\tbreak;\n \t\tif (copy_to_user(up, &kbrep, sizeof(struct kbd_repeat)))\n \t\t\tret = -EFAULT;\n \t\tbreak;\n \t}\n \n \tcase KDSETMODE:\n \t\tif (!perm)\n \t\t\treturn -EPERM;\n \t\tswitch (arg) {\n \t\tcase KD_GRAPHICS:\n \t\t\tbreak;\n \t\tcase KD_TEXT0:\n \t\tcase KD_TEXT1:\n \t\t\targ = KD_TEXT;\n \t\tcase KD_TEXT:\n \t\t\tbreak;\n \t\tdefault:\n \t\t\tret = -EINVAL;\n \t\t\tgoto out;\n \t\t}\n \t\tif (vc->vc_mode == (unsigned char) arg)\n \t\t\tbreak;\n \t\tvc->vc_mode = (unsigned char) arg;\n \t\tif (console != fg_console)\n \t\t\tbreak;\n \t\tconsole_lock();\n \t\tif (arg == KD_TEXT)\n \t\t\tdo_unblank_screen(1);\n \t\telse\n \t\t\tdo_blank_screen(1);\n \t\tconsole_unlock();\n \t\tbreak;\n \n \tcase KDGETMODE:\n \t\tuival = vc->vc_mode;\n \t\tgoto setint;\n \n \tcase KDMAPDISP:\n \tcase KDUNMAPDISP:\n \t\tret = -EINVAL;\n \t\tbreak;\n \n \tcase KDSKBMODE:\n \t\tif (!perm)\n \t\t\treturn -EPERM;\n \t\tret = vt_do_kdskbmode(console, arg);\n \t\tif (ret == 0)\n \t\t\ttty_ldisc_flush(tty);\n \t\tbreak;\n \n \tcase KDGKBMODE:\n \t\tuival = vt_do_kdgkbmode(console);\n \t\tret = put_user(uival, (int __user *)arg);\n \t\tbreak;\n \n \tcase KDSKBMETA:\n \t\tret = vt_do_kdskbmeta(console, arg);\n \t\tbreak;\n \n \tcase KDGKBMETA:\n \t\tuival = vt_do_kdgkbmeta(console);\n \tsetint:\n \t\tret = put_user(uival, (int __user *)arg);\n \t\tbreak;\n \n \tcase KDGETKEYCODE:\n \tcase KDSETKEYCODE:\n \t\tif(!capable(CAP_SYS_TTY_CONFIG))\n \t\t\tperm = 0;\n \t\tret = vt_do_kbkeycode_ioctl(cmd, up, perm);\n \t\tbreak;\n \n \tcase KDGKBENT:\n \tcase KDSKBENT:\n \t\tret = vt_do_kdsk_ioctl(cmd, up, perm, console);\n \t\tbreak;\n \n \tcase KDGKBSENT:\n \tcase KDSKBSENT:\n \t\tret = vt_do_kdgkb_ioctl(cmd, up, perm);\n \t\tbreak;\n \n \tcase KDGKBDIACR:\n \tcase KDGKBDIACRUC:\n \tcase KDSKBDIACR:\n \tcase KDSKBDIACRUC:\n \t\tret = vt_do_diacrit(cmd, up, perm);\n \t\tbreak;\n \n \tcase KDGKBLED:\n \tcase KDSKBLED:\n \tcase KDGETLED:\n \tcase KDSETLED:\n \t\tret = vt_do_kdskled(console, cmd, arg, perm);\n \t\tbreak;\n \n \tcase KDSIGACCEPT:\n \t{\n \t\tif (!perm || !capable(CAP_KILL))\n \t\t\treturn -EPERM;\n \t\tif (!valid_signal(arg) || arg < 1 || arg == SIGKILL)\n \t\t\tret = -EINVAL;\n \t\telse {\n \t\t\tspin_lock_irq(&vt_spawn_con.lock);\n \t\t\tput_pid(vt_spawn_con.pid);\n \t\t\tvt_spawn_con.pid = get_pid(task_pid(current));\n \t\t\tvt_spawn_con.sig = arg;\n \t\t\tspin_unlock_irq(&vt_spawn_con.lock);\n \t\t}\n \t\tbreak;\n \t}\n \n \tcase VT_SETMODE:\n \t{\n \t\tstruct vt_mode tmp;\n \n \t\tif (!perm)\n \t\t\treturn -EPERM;\n \t\tif (copy_from_user(&tmp, up, sizeof(struct vt_mode))) {\n \t\t\tret = -EFAULT;\n \t\t\tgoto out;\n \t\t}\n \t\tif (tmp.mode != VT_AUTO && tmp.mode != VT_PROCESS) {\n \t\t\tret = -EINVAL;\n \t\t\tgoto out;\n \t\t}\n \t\tconsole_lock();\n \t\tvc->vt_mode = tmp;\n \t\tvc->vt_mode.frsig = 0;\n \t\tput_pid(vc->vt_pid);\n \t\tvc->vt_pid = get_pid(task_pid(current));\n \t\tvc->vt_newvt = -1;\n \t\tconsole_unlock();\n \t\tbreak;\n \t}\n \n \tcase VT_GETMODE:\n \t{\n \t\tstruct vt_mode tmp;\n \t\tint rc;\n \n \t\tconsole_lock();\n \t\tmemcpy(&tmp, &vc->vt_mode, sizeof(struct vt_mode));\n \t\tconsole_unlock();\n \n \t\trc = copy_to_user(up, &tmp, sizeof(struct vt_mode));\n \t\tif (rc)\n \t\t\tret = -EFAULT;\n \t\tbreak;\n \t}\n \n \tcase VT_GETSTATE:\n \t{\n \t\tstruct vt_stat __user *vtstat = up;\n \t\tunsigned short state, mask;\n \n \t\tif (put_user(fg_console + 1, &vtstat->v_active))\n \t\t\tret = -EFAULT;\n \t\telse {\n \t\t\tstate = 1;\n \t\t\tfor (i = 0, mask = 2; i < MAX_NR_CONSOLES && mask;\n \t\t\t\t\t\t\t++i, mask <<= 1)\n \t\t\t\tif (VT_IS_IN_USE(i))\n \t\t\t\t\tstate |= mask;\n \t\t\tret = put_user(state, &vtstat->v_state);\n \t\t}\n \t\tbreak;\n \t}\n \n \tcase VT_OPENQRY:\n \t\tfor (i = 0; i < MAX_NR_CONSOLES; ++i)\n \t\t\tif (! VT_IS_IN_USE(i))\n \t\t\t\tbreak;\n \t\tuival = i < MAX_NR_CONSOLES ? (i+1) : -1;\n \t\tgoto setint;\n \n \tcase VT_ACTIVATE:\n \t\tif (!perm)\n \t\t\treturn -EPERM;\n \t\tif (arg == 0 || arg > MAX_NR_CONSOLES)\n \t\t\tret =  -ENXIO;\n \t\telse {\n \t\t\targ--;\n \t\t\tconsole_lock();\n \t\t\tret = vc_allocate(arg);\n \t\t\tconsole_unlock();\n \t\t\tif (ret)\n \t\t\t\tbreak;\n \t\t\tset_console(arg);\n \t\t}\n \t\tbreak;\n \n \tcase VT_SETACTIVATE:\n \t{\n \t\tstruct vt_setactivate vsa;\n \n \t\tif (!perm)\n \t\t\treturn -EPERM;\n \n \t\tif (copy_from_user(&vsa, (struct vt_setactivate __user *)arg,\n \t\t\t\t\tsizeof(struct vt_setactivate))) {\n \t\t\tret = -EFAULT;\n \t\t\tgoto out;\n \t\t}\n \t\tif (vsa.console == 0 || vsa.console > MAX_NR_CONSOLES)\n \t\t\tret = -ENXIO;\n \t\telse {\n \t\t\tvsa.console = array_index_nospec(vsa.console,\n \t\t\t\t\t\t\t MAX_NR_CONSOLES + 1);\n \t\t\tvsa.console--;\n \t\t\tconsole_lock();\n \t\t\tret = vc_allocate(vsa.console);\n \t\t\tif (ret == 0) {\n \t\t\t\tstruct vc_data *nvc;\n \t\t\t\tnvc = vc_cons[vsa.console].d;\n \t\t\t\tnvc->vt_mode = vsa.mode;\n \t\t\t\tnvc->vt_mode.frsig = 0;\n \t\t\t\tput_pid(nvc->vt_pid);\n \t\t\t\tnvc->vt_pid = get_pid(task_pid(current));\n \t\t\t}\n \t\t\tconsole_unlock();\n \t\t\tif (ret)\n \t\t\t\tbreak;\n \t\t\tset_console(vsa.console);\n \t\t}\n \t\tbreak;\n \t}\n \n \tcase VT_WAITACTIVE:\n \t\tif (!perm)\n \t\t\treturn -EPERM;\n \t\tif (arg == 0 || arg > MAX_NR_CONSOLES)\n \t\t\tret = -ENXIO;\n \t\telse\n \t\t\tret = vt_waitactive(arg);\n \t\tbreak;\n \n \tcase VT_RELDISP:\n \t\tif (!perm)\n \t\t\treturn -EPERM;\n \n \t\tconsole_lock();\n \t\tif (vc->vt_mode.mode != VT_PROCESS) {\n \t\t\tconsole_unlock();\n \t\t\tret = -EINVAL;\n \t\t\tbreak;\n \t\t}\n \t\tif (vc->vt_newvt >= 0) {\n \t\t\tif (arg == 0)\n \t\t\t\tvc->vt_newvt = -1;\n \n \t\t\telse {\n \t\t\t\tint newvt;\n \t\t\t\tnewvt = vc->vt_newvt;\n \t\t\t\tvc->vt_newvt = -1;\n \t\t\t\tret = vc_allocate(newvt);\n \t\t\t\tif (ret) {\n \t\t\t\t\tconsole_unlock();\n \t\t\t\t\tbreak;\n \t\t\t\t}\n \t\t\t\tcomplete_change_console(vc_cons[newvt].d);\n \t\t\t}\n \t\t} else {\n \t\t\tif (arg != VT_ACKACQ)\n \t\t\t\tret = -EINVAL;\n \t\t}\n \t\tconsole_unlock();\n \t\tbreak;\n \n \t case VT_DISALLOCATE:\n \t\tif (arg > MAX_NR_CONSOLES) {\n \t\t\tret = -ENXIO;\n \t\t\tbreak;\n \t\t}\n \t\tif (arg == 0)\n \t\t\tvt_disallocate_all();\n \t\telse\n \t\t\tret = vt_disallocate(--arg);\n \t\tbreak;\n \n \tcase VT_RESIZE:\n \t{\n \t\tstruct vt_sizes __user *vtsizes = up;\n \t\tstruct vc_data *vc;\n \n \t\tushort ll,cc;\n \t\tif (!perm)\n \t\t\treturn -EPERM;\n \t\tif (get_user(ll, &vtsizes->v_rows) ||\n \t\t    get_user(cc, &vtsizes->v_cols))\n \t\t\tret = -EFAULT;\n \t\telse {\n \t\t\tconsole_lock();\n \t\t\tfor (i = 0; i < MAX_NR_CONSOLES; i++) {\n \t\t\t\tvc = vc_cons[i].d;\n \n \t\t\t\tif (vc) {\n \t\t\t\t\tvc->vc_resize_user = 1;\n \t\t\t\t\tvc_resize(vc_cons[i].d, cc, ll);\n \t\t\t\t}\n \t\t\t}\n \t\t\tconsole_unlock();\n \t\t}\n \t\tbreak;\n \t}\n \n \tcase VT_RESIZEX:\n \t{\n \t\tstruct vt_consize v;\n \t\tif (!perm)\n \t\t\treturn -EPERM;\n \t\tif (copy_from_user(&v, up, sizeof(struct vt_consize)))\n \t\t\treturn -EFAULT;\n \t\tif (!v.v_vlin)\n \t\t\tv.v_vlin = vc->vc_scan_lines;\n \t\tif (v.v_clin) {\n \t\t\tint rows = v.v_vlin/v.v_clin;\n \t\t\tif (v.v_rows != rows) {\n \t\t\t\tif (v.v_rows)\n \t\t\t\t\treturn -EINVAL;\n \t\t\t\tv.v_rows = rows;\n \t\t\t}\n \t\t}\n \t\tif (v.v_vcol && v.v_ccol) {\n \t\t\tint cols = v.v_vcol/v.v_ccol;\n \t\t\tif (v.v_cols != cols) {\n \t\t\t\tif (v.v_cols)\n \t\t\t\t\treturn -EINVAL;\n \t\t\t\tv.v_cols = cols;\n \t\t\t}\n \t\t}\n \n \t\tif (v.v_clin > 32)\n \t\t\treturn -EINVAL;\n \n \t\tfor (i = 0; i < MAX_NR_CONSOLES; i++) {\n// bug_start\n// bug_end\n \t\t\tif (!vc_cons[i].d)\n \t\t\t\tcontinue;\n \t\t\tconsole_lock();\n// bug_start\n\t\t\tif (v.v_vlin)\n\t\t\t\tvc_cons[i].d->vc_scan_lines = v.v_vlin;\n\t\t\tif (v.v_clin)\n\t\t\t\tvc_cons[i].d->vc_font.height = v.v_clin;\n\t\t\tvc_cons[i].d->vc_resize_user = 1;\n\t\t\tvc_resize(vc_cons[i].d, v.v_cols, v.v_rows);\n// bug_end\n \t\t\tconsole_unlock();\n \t\t}\n \t\tbreak;\n \t}\n \n \tcase PIO_FONT: {\n \t\tif (!perm)\n \t\t\treturn -EPERM;\n \t\top.op = KD_FONT_OP_SET;\n \t\top.flags = KD_FONT_FLAG_OLD | KD_FONT_FLAG_DONT_RECALC;\n \t\top.width = 8;\n \t\top.height = 0;\n \t\top.charcount = 256;\n \t\top.data = up;\n \t\tret = con_font_op(vc_cons[fg_console].d, &op);\n \t\tbreak;\n \t}\n \n \tcase GIO_FONT: {\n \t\top.op = KD_FONT_OP_GET;\n \t\top.flags = KD_FONT_FLAG_OLD;\n \t\top.width = 8;\n \t\top.height = 32;\n \t\top.charcount = 256;\n \t\top.data = up;\n \t\tret = con_font_op(vc_cons[fg_console].d, &op);\n \t\tbreak;\n \t}\n \n \tcase PIO_CMAP:\n                 if (!perm)\n \t\t\tret = -EPERM;\n \t\telse\n \t                ret = con_set_cmap(up);\n \t\tbreak;\n \n \tcase GIO_CMAP:\n                 ret = con_get_cmap(up);\n \t\tbreak;\n \n \tcase PIO_FONTX:\n \tcase GIO_FONTX:\n \t\tret = do_fontx_ioctl(cmd, up, perm, &op);\n \t\tbreak;\n \n \tcase PIO_FONTRESET:\n \t{\n \t\tif (!perm)\n \t\t\treturn -EPERM;\n \n #ifdef BROKEN_GRAPHICS_PROGRAMS\n \t\tret = -ENOSYS;\n \t\tbreak;\n #else\n \t\t{\n \t\top.op = KD_FONT_OP_SET_DEFAULT;\n \t\top.data = NULL;\n \t\tret = con_font_op(vc_cons[fg_console].d, &op);\n \t\tif (ret)\n \t\t\tbreak;\n \t\tconsole_lock();\n \t\tcon_set_default_unimap(vc_cons[fg_console].d);\n \t\tconsole_unlock();\n \t\tbreak;\n \t\t}\n #endif\n \t}\n \n \tcase KDFONTOP: {\n \t\tif (copy_from_user(&op, up, sizeof(op))) {\n \t\t\tret = -EFAULT;\n \t\t\tbreak;\n \t\t}\n \t\tif (!perm && op.op != KD_FONT_OP_GET)\n \t\t\treturn -EPERM;\n \t\tret = con_font_op(vc, &op);\n \t\tif (ret)\n \t\t\tbreak;\n \t\tif (copy_to_user(up, &op, sizeof(op)))\n \t\t\tret = -EFAULT;\n \t\tbreak;\n \t}\n \n \tcase PIO_SCRNMAP:\n \t\tif (!perm)\n \t\t\tret = -EPERM;\n \t\telse\n \t\t\tret = con_set_trans_old(up);\n \t\tbreak;\n \n \tcase GIO_SCRNMAP:\n \t\tret = con_get_trans_old(up);\n \t\tbreak;\n \n \tcase PIO_UNISCRNMAP:\n \t\tif (!perm)\n \t\t\tret = -EPERM;\n \t\telse\n \t\t\tret = con_set_trans_new(up);\n \t\tbreak;\n \n \tcase GIO_UNISCRNMAP:\n \t\tret = con_get_trans_new(up);\n \t\tbreak;\n \n \tcase PIO_UNIMAPCLR:\n \t\tif (!perm)\n \t\t\treturn -EPERM;\n \t\tcon_clear_unimap(vc);\n \t\tbreak;\n \n \tcase PIO_UNIMAP:\n \tcase GIO_UNIMAP:\n \t\tret = do_unimap_ioctl(cmd, up, perm, vc);\n \t\tbreak;\n \n \tcase VT_LOCKSWITCH:\n \t\tif (!capable(CAP_SYS_TTY_CONFIG))\n \t\t\treturn -EPERM;\n \t\tvt_dont_switch = 1;\n \t\tbreak;\n \tcase VT_UNLOCKSWITCH:\n \t\tif (!capable(CAP_SYS_TTY_CONFIG))\n \t\t\treturn -EPERM;\n \t\tvt_dont_switch = 0;\n \t\tbreak;\n \tcase VT_GETHIFONTMASK:\n \t\tret = put_user(vc->vc_hi_font_mask,\n \t\t\t\t\t(unsigned short __user *)arg);\n \t\tbreak;\n \tcase VT_WAITEVENT:\n \t\tret = vt_event_wait_ioctl((struct vt_event __user *)arg);\n \t\tbreak;\n \tdefault:\n \t\tret = -ENOIOCTLCMD;\n \t}\n out:\n \treturn ret;\n }\n \n", "target": "// fix_start\n\t\t\tstruct vc_data *vcp;\n\n// fix_end\n// fix_start\n\t\t\tvcp = vc_cons[i].d;\n\t\t\tif (vcp) {\n\t\t\t\tif (v.v_vlin)\n\t\t\t\t\tvcp->vc_scan_lines = v.v_vlin;\n\t\t\t\tif (v.v_clin)\n\t\t\t\t\tvcp->vc_font.height = v.v_clin;\n\t\t\t\tvcp->vc_resize_user = 1;\n\t\t\t\tvc_resize(vcp, v.v_cols, v.v_rows);\n\t\t\t}\n// fix_end\n", "cwe": "CWE-703", "cwe_name": "Improper Check or Handling of Exceptional Conditions", "cve": "CVE-2020-36558", "cve_desc": "A race condition in the Linux kernel before 5.5.7 involving VT_RESIZEX could lead to a NULL pointer dereference and general protection fault.", "project": "linux", "idx": 212365}
{"source": " Pl_ASCIIHexDecoder::flush()\n {\n     if (this->pos == 0)\n     {\n \tQTC::TC(\"libtests\", \"Pl_ASCIIHexDecoder no-op flush\");\n \treturn;\n     }\n     int b[2];\n     for (int i = 0; i < 2; ++i)\n     {\n \tif (this->inbuf[i] >= 'A')\n \t{\n \t    b[i] = this->inbuf[i] - 'A' + 10;\n \t}\n \telse\n \t{\n \t    b[i] = this->inbuf[i] - '0';\n \t}\n     }\n     unsigned char ch = static_cast<unsigned char>((b[0] << 4) + b[1]);\n \n     QTC::TC(\"libtests\", \"Pl_ASCIIHexDecoder partial flush\",\n \t    (this->pos == 2) ? 0 : 1);\n// bug_start\n    getNext()->write(&ch, 1);\n\n// bug_end\n     this->pos = 0;\n     this->inbuf[0] = '0';\n     this->inbuf[1] = '0';\n     this->inbuf[2] = '\\0';\n// bug_start\n// bug_end\n }\n \n", "target": "// fix_start\n// fix_end\n// fix_start\n\n    getNext()->write(&ch, 1);\n// fix_end\n", "cwe": "CWE-787", "cwe_name": "Out-of-bounds Write", "cve": "CVE-2021-36978", "cve_desc": "QPDF 9.x through 9.1.1 and 10.x through 10.0.4 has a heap-based buffer overflow in Pl_ASCII85Decoder::write (called from Pl_AES_PDF::flush and Pl_AES_PDF::finish) when a certain downstream write fails.", "project": "qpdf", "idx": 212373}
{"source": " Pl_AES_PDF::flush(bool strip_padding)\n {\n     assert(this->offset == this->buf_size);\n \n     if (first)\n     {\n \tfirst = false;\n         bool return_after_init = false;\n \tif (this->cbc_mode)\n \t{\n \t    if (encrypt)\n \t    {\n \t\tinitializeVector();\n                 if (! (this->use_zero_iv || this->use_specified_iv))\n                 {\n                     getNext()->write(this->cbc_block, this->buf_size);\n                 }\n \t    }\n \t    else if (this->use_zero_iv || this->use_specified_iv)\n             {\n                 initializeVector();\n             }\n             else\n \t    {\n \t\tmemcpy(this->cbc_block, this->inbuf, this->buf_size);\n \t\tthis->offset = 0;\n                 return_after_init = true;\n \t    }\n \t}\n         this->crypto->rijndael_init(\n             encrypt, this->key.get(), key_bytes,\n             this->cbc_mode, this->cbc_block);\n         if (return_after_init)\n         {\n             return;\n         }\n     }\n \n     if (this->encrypt)\n     {\n \tthis->crypto->rijndael_process(this->inbuf, this->outbuf);\n     }\n     else\n     {\n \tthis->crypto->rijndael_process(this->inbuf, this->outbuf);\n     }\n     unsigned int bytes = this->buf_size;\n     if (strip_padding)\n     {\n \tunsigned char last = this->outbuf[this->buf_size - 1];\n \tif (last <= this->buf_size)\n \t{\n \t    bool strip = true;\n \t    for (unsigned int i = 1; i <= last; ++i)\n \t    {\n \t\tif (this->outbuf[this->buf_size - i] != last)\n \t\t{\n \t\t    strip = false;\n \t\t    break;\n \t\t}\n \t    }\n \t    if (strip)\n \t    {\n \t\tbytes -= last;\n \t    }\n \t}\n     }\n// bug_start\n// bug_end\n     getNext()->write(this->outbuf, bytes);\n// bug_start\n    this->offset = 0;\n// bug_end\n }\n \n", "target": "// fix_start\n    this->offset = 0;\n// fix_end\n// fix_start\n// fix_end\n", "cwe": "CWE-787", "cwe_name": "Out-of-bounds Write", "cve": "CVE-2021-36978", "cve_desc": "QPDF 9.x through 9.1.1 and 10.x through 10.0.4 has a heap-based buffer overflow in Pl_ASCII85Decoder::write (called from Pl_AES_PDF::flush and Pl_AES_PDF::finish) when a certain downstream write fails.", "project": "qpdf", "idx": 212374}
{"source": " Pl_ASCII85Decoder::flush()\n {\n     if (this->pos == 0)\n     {\n \tQTC::TC(\"libtests\", \"Pl_ASCII85Decoder no-op flush\");\n \treturn;\n     }\n     unsigned long lval = 0;\n     for (int i = 0; i < 5; ++i)\n     {\n \tlval *= 85;\n \tlval += (this->inbuf[i] - 33U);\n     }\n \n     unsigned char outbuf[4];\n     memset(outbuf, 0, 4);\n     for (int i = 3; i >= 0; --i)\n     {\n \toutbuf[i] = lval & 0xff;\n \tlval >>= 8;\n     }\n \n     QTC::TC(\"libtests\", \"Pl_ASCII85Decoder partial flush\",\n \t    (this->pos == 5) ? 0 : 1);\n// bug_start\n    getNext()->write(outbuf, this->pos - 1);\n\n// bug_end\n     this->pos = 0;\n     memset(this->inbuf, 117, 5);\n// bug_start\n// bug_end\n }\n \n", "target": "// fix_start\n    auto t = this->pos - 1;\n// fix_end\n// fix_start\n\n    getNext()->write(outbuf, t);\n// fix_end\n", "cwe": "CWE-787", "cwe_name": "Out-of-bounds Write", "cve": "CVE-2021-36978", "cve_desc": "QPDF 9.x through 9.1.1 and 10.x through 10.0.4 has a heap-based buffer overflow in Pl_ASCII85Decoder::write (called from Pl_AES_PDF::flush and Pl_AES_PDF::finish) when a certain downstream write fails.", "project": "qpdf", "idx": 212375}
{"source": " Pl_Count::write(unsigned char* buf, size_t len)\n {\n     if (len)\n     {\n \tthis->m->count += QIntC::to_offset(len);\n// bug_start\n// bug_end\n \tgetNext()->write(buf, len);\n// bug_start\n\tthis->m->last_char = buf[len - 1];\n// bug_end\n     }\n }\n \n", "target": "// fix_start\n\tthis->m->last_char = buf[len - 1];\n// fix_end\n// fix_start\n// fix_end\n", "cwe": "CWE-787", "cwe_name": "Out-of-bounds Write", "cve": "CVE-2021-36978", "cve_desc": "QPDF 9.x through 9.1.1 and 10.x through 10.0.4 has a heap-based buffer overflow in Pl_ASCII85Decoder::write (called from Pl_AES_PDF::flush and Pl_AES_PDF::finish) when a certain downstream write fails.", "project": "qpdf", "idx": 212376}
{"source": " static int mt_touch_input_mapping(struct hid_device *hdev, struct hid_input *hi,\n \t\tstruct hid_field *field, struct hid_usage *usage,\n \t\tunsigned long **bit, int *max, struct mt_application *app)\n {\n \tstruct mt_device *td = hid_get_drvdata(hdev);\n \tstruct mt_class *cls = &td->mtclass;\n \tint code;\n \tstruct hid_usage *prev_usage = NULL;\n \n \tif (field->application == HID_DG_TOUCHSCREEN &&\n \t    (usage->hid & HID_USAGE_PAGE) == HID_UP_BUTTON) {\n \t\tapp->mt_flags |= INPUT_MT_POINTER;\n \t\ttd->inputmode_value = MT_INPUTMODE_TOUCHPAD;\n \t}\n \n \tif ((usage->hid & HID_USAGE_PAGE) == HID_UP_BUTTON)\n \t\tapp->buttons_count++;\n \n \tif (usage->usage_index)\n \t\tprev_usage = &field->usage[usage->usage_index - 1];\n \n \tswitch (usage->hid & HID_USAGE_PAGE) {\n \n \tcase HID_UP_GENDESK:\n \t\tswitch (usage->hid) {\n \t\tcase HID_GD_X:\n \t\t\tif (prev_usage && (prev_usage->hid == usage->hid)) {\n \t\t\t\tcode = ABS_MT_TOOL_X;\n \t\t\t\tMT_STORE_FIELD(cx);\n \t\t\t} else {\n \t\t\t\tcode = ABS_MT_POSITION_X;\n \t\t\t\tMT_STORE_FIELD(x);\n \t\t\t}\n \n \t\t\tset_abs(hi->input, code, field, cls->sn_move);\n \n \t\t\tif (field->application == HID_GD_SYSTEM_MULTIAXIS) {\n \t\t\t\t__set_bit(INPUT_PROP_DIRECT,\n \t\t\t\t\t  hi->input->propbit);\n \t\t\t\tinput_set_abs_params(hi->input,\n \t\t\t\t\t\t     ABS_MT_TOOL_TYPE,\n \t\t\t\t\t\t     MT_TOOL_DIAL,\n \t\t\t\t\t\t     MT_TOOL_DIAL, 0, 0);\n \t\t\t}\n \n \t\t\treturn 1;\n \t\tcase HID_GD_Y:\n \t\t\tif (prev_usage && (prev_usage->hid == usage->hid)) {\n \t\t\t\tcode = ABS_MT_TOOL_Y;\n \t\t\t\tMT_STORE_FIELD(cy);\n \t\t\t} else {\n \t\t\t\tcode = ABS_MT_POSITION_Y;\n \t\t\t\tMT_STORE_FIELD(y);\n \t\t\t}\n \n \t\t\tset_abs(hi->input, code, field, cls->sn_move);\n \n \t\t\treturn 1;\n \t\t}\n \t\treturn 0;\n \n \tcase HID_UP_DIGITIZER:\n \t\tswitch (usage->hid) {\n \t\tcase HID_DG_INRANGE:\n \t\t\tif (app->quirks & MT_QUIRK_HOVERING) {\n \t\t\t\tinput_set_abs_params(hi->input,\n \t\t\t\t\tABS_MT_DISTANCE, 0, 1, 0, 0);\n \t\t\t}\n \t\t\tMT_STORE_FIELD(inrange_state);\n \t\t\treturn 1;\n \t\tcase HID_DG_CONFIDENCE:\n \t\t\tif (cls->name == MT_CLS_WIN_8 &&\n \t\t\t\t(field->application == HID_DG_TOUCHPAD ||\n \t\t\t\t field->application == HID_DG_TOUCHSCREEN))\n \t\t\t\tapp->quirks |= MT_QUIRK_CONFIDENCE;\n \n \t\t\tif (app->quirks & MT_QUIRK_CONFIDENCE)\n \t\t\t\tinput_set_abs_params(hi->input,\n \t\t\t\t\t\t     ABS_MT_TOOL_TYPE,\n \t\t\t\t\t\t     MT_TOOL_FINGER,\n \t\t\t\t\t\t     MT_TOOL_PALM, 0, 0);\n \n \t\t\tMT_STORE_FIELD(confidence_state);\n \t\t\treturn 1;\n \t\tcase HID_DG_TIPSWITCH:\n \t\t\tif (field->application != HID_GD_SYSTEM_MULTIAXIS)\n \t\t\t\tinput_set_capability(hi->input,\n \t\t\t\t\t\t     EV_KEY, BTN_TOUCH);\n \t\t\tMT_STORE_FIELD(tip_state);\n \t\t\treturn 1;\n \t\tcase HID_DG_CONTACTID:\n \t\t\tMT_STORE_FIELD(contactid);\n \t\t\tapp->touches_by_report++;\n \t\t\treturn 1;\n \t\tcase HID_DG_WIDTH:\n \t\t\tif (!(app->quirks & MT_QUIRK_NO_AREA))\n \t\t\t\tset_abs(hi->input, ABS_MT_TOUCH_MAJOR, field,\n \t\t\t\t\tcls->sn_width);\n \t\t\tMT_STORE_FIELD(w);\n \t\t\treturn 1;\n \t\tcase HID_DG_HEIGHT:\n \t\t\tif (!(app->quirks & MT_QUIRK_NO_AREA)) {\n \t\t\t\tset_abs(hi->input, ABS_MT_TOUCH_MINOR, field,\n \t\t\t\t\tcls->sn_height);\n \n \t\t\t\tif (!test_bit(ABS_MT_ORIENTATION,\n \t\t\t\t\t\thi->input->absbit))\n \t\t\t\t\tinput_set_abs_params(hi->input,\n \t\t\t\t\t\tABS_MT_ORIENTATION, 0, 1, 0, 0);\n \t\t\t}\n \t\t\tMT_STORE_FIELD(h);\n \t\t\treturn 1;\n \t\tcase HID_DG_TIPPRESSURE:\n \t\t\tset_abs(hi->input, ABS_MT_PRESSURE, field,\n \t\t\t\tcls->sn_pressure);\n \t\t\tMT_STORE_FIELD(p);\n \t\t\treturn 1;\n \t\tcase HID_DG_SCANTIME:\n \t\t\tinput_set_capability(hi->input, EV_MSC, MSC_TIMESTAMP);\n \t\t\tapp->scantime = &field->value[usage->usage_index];\n \t\t\tapp->scantime_logical_max = field->logical_maximum;\n \t\t\treturn 1;\n \t\tcase HID_DG_CONTACTCOUNT:\n \t\t\tapp->have_contact_count = true;\n \t\t\tapp->raw_cc = &field->value[usage->usage_index];\n \t\t\treturn 1;\n \t\tcase HID_DG_AZIMUTH:\n \t\t\tinput_set_abs_params(hi->input, ABS_MT_ORIENTATION,\n \t\t\t\t-field->logical_maximum / 4,\n \t\t\t\tfield->logical_maximum / 4,\n \t\t\t\tcls->sn_move ?\n \t\t\t\tfield->logical_maximum / cls->sn_move : 0, 0);\n \t\t\tMT_STORE_FIELD(a);\n \t\t\treturn 1;\n \t\tcase HID_DG_CONTACTMAX:\n \t\t\treturn -1;\n \t\tcase HID_DG_TOUCH:\n \t\t\treturn -1;\n \t\t}\n \t\treturn 0;\n \n \tcase HID_UP_BUTTON:\n \t\tcode = BTN_MOUSE + ((usage->hid - 1) & HID_USAGE);\n \t\tif ((app->quirks & MT_QUIRK_WIN8_PTP_BUTTONS) &&\n \t\t    field->application == HID_DG_TOUCHPAD &&\n \t\t    (usage->hid & HID_USAGE) > 1)\n \t\t\tcode--;\n \n \t\tif (field->application == HID_GD_SYSTEM_MULTIAXIS)\n \t\t\tcode = BTN_0  + ((usage->hid - 1) & HID_USAGE);\n \n \t\thid_map_usage(hi, usage, bit, max, EV_KEY, code);\n// bug_start\n// bug_end\n \t\tinput_set_capability(hi->input, EV_KEY, code);\n \t\treturn 1;\n \n \tcase 0xff000000:\n \t\treturn -1;\n \t}\n \n \treturn 0;\n }\n \n", "target": "// fix_start\n\t\tif (!*bit)\n\t\t\treturn -1;\n// fix_end\n", "cwe": "CWE-787", "cwe_name": "Out-of-bounds Write", "cve": "CVE-2020-0465", "cve_desc": "In various methods of hid-multitouch.c, there is a possible out of bounds write due to a missing bounds check. This could lead to local escalation of privilege with no additional execution privileges needed. User interaction is not needed for exploitation.Product: AndroidVersions: Android kernelAndroid ID: A-162844689References: Upstream kernel", "project": "linux", "idx": 212377}
{"source": " ecc_decrypt_raw (gcry_sexp_t *r_plain, gcry_sexp_t s_data, gcry_sexp_t keyparms)\n {\n   unsigned int nbits;\n   gpg_err_code_t rc;\n   struct pk_encoding_ctx ctx;\n   gcry_sexp_t l1 = NULL;\n   gcry_mpi_t data_e = NULL;\n   ECC_secret_key sk;\n   gcry_mpi_t mpi_g = NULL;\n   char *curvename = NULL;\n   mpi_ec_t ec = NULL;\n   mpi_point_struct kG;\n   mpi_point_struct R;\n   gcry_mpi_t r = NULL;\n   int flags = 0;\n \n   memset (&sk, 0, sizeof sk);\n   point_init (&kG);\n   point_init (&R);\n \n   _gcry_pk_util_init_encoding_ctx (&ctx, PUBKEY_OP_DECRYPT,\n                                    (nbits = ecc_get_nbits (keyparms)));\n \n   l1 = sexp_find_token (keyparms, \"flags\", 0);\n   if (l1)\n     {\n       rc = _gcry_pk_util_parse_flaglist (l1, &flags, NULL);\n       if (rc)\n         goto leave;\n     }\n   sexp_release (l1);\n   l1 = NULL;\n \n   rc = _gcry_pk_util_preparse_encval (s_data, ecc_names, &l1, &ctx);\n   if (rc)\n     goto leave;\n   rc = sexp_extract_param (l1, NULL, \"e\", &data_e, NULL);\n   if (rc)\n     goto leave;\n   if (DBG_CIPHER)\n     log_printmpi (\"ecc_decrypt  d_e\", data_e);\n   if (mpi_is_opaque (data_e))\n     {\n       rc = GPG_ERR_INV_DATA;\n       goto leave;\n     }\n \n   rc = sexp_extract_param (keyparms, NULL, \"-p?a?b?g?n?h?+d\",\n                            &sk.E.p, &sk.E.a, &sk.E.b, &mpi_g, &sk.E.n,\n                            &sk.E.h, &sk.d, NULL);\n   if (rc)\n     goto leave;\n   if (mpi_g)\n     {\n       point_init (&sk.E.G);\n       rc = _gcry_ecc_os2ec (&sk.E.G, mpi_g);\n       if (rc)\n         goto leave;\n     }\n   sexp_release (l1);\n   l1 = sexp_find_token (keyparms, \"curve\", 5);\n   if (l1)\n     {\n       curvename = sexp_nth_string (l1, 1);\n       if (curvename)\n         {\n           rc = _gcry_ecc_fill_in_curve (0, curvename, &sk.E, NULL);\n           if (rc)\n             goto leave;\n         }\n     }\n   if (!curvename)\n     {\n       sk.E.model = MPI_EC_WEIERSTRASS;\n       sk.E.dialect = ECC_DIALECT_STANDARD;\n       if (!sk.E.h)\n \tsk.E.h = mpi_const (MPI_C_ONE);\n     }\n   if (DBG_CIPHER)\n     {\n       log_debug (\"ecc_decrypt info: %s/%s\\n\",\n                  _gcry_ecc_model2str (sk.E.model),\n                  _gcry_ecc_dialect2str (sk.E.dialect));\n       if (sk.E.name)\n         log_debug  (\"ecc_decrypt name: %s\\n\", sk.E.name);\n       log_printmpi (\"ecc_decrypt    p\", sk.E.p);\n       log_printmpi (\"ecc_decrypt    a\", sk.E.a);\n       log_printmpi (\"ecc_decrypt    b\", sk.E.b);\n       log_printpnt (\"ecc_decrypt  g\",   &sk.E.G, NULL);\n       log_printmpi (\"ecc_decrypt    n\", sk.E.n);\n       log_printmpi (\"ecc_decrypt    h\", sk.E.h);\n       if (!fips_mode ())\n         log_printmpi (\"ecc_decrypt    d\", sk.d);\n     }\n   if (!sk.E.p || !sk.E.a || !sk.E.b || !sk.E.G.x || !sk.E.n || !sk.E.h || !sk.d)\n     {\n       rc = GPG_ERR_NO_OBJ;\n       goto leave;\n     }\n \n \n   ec = _gcry_mpi_ec_p_internal_new (sk.E.model, sk.E.dialect, flags,\n                                     sk.E.p, sk.E.a, sk.E.b);\n \n   if (ec->model == MPI_EC_MONTGOMERY)\n     rc = _gcry_ecc_mont_decodepoint (data_e, ec, &kG);\n   else\n     rc = _gcry_ecc_os2ec (&kG, data_e);\n   if (rc)\n     goto leave;\n \n   if (DBG_CIPHER)\n     log_printpnt (\"ecc_decrypt    kG\", &kG, NULL);\n \n// bug_start\n  if (!(flags & PUBKEY_FLAG_DJB_TWEAK)\n      && !_gcry_mpi_ec_curve_point (&kG, ec))\n// bug_end\n     {\n       rc = GPG_ERR_INV_DATA;\n       goto leave;\n     }\n \n   _gcry_mpi_ec_mul_point (&R, sk.d, &kG, ec);\n \n   {\n     gcry_mpi_t x, y;\n \n     x = mpi_new (0);\n     if (ec->model == MPI_EC_MONTGOMERY)\n       y = NULL;\n     else\n       y = mpi_new (0);\n \n     if (_gcry_mpi_ec_get_affine (x, y, &R, ec))\n       {\n         rc = GPG_ERR_INV_DATA;\n         goto leave;\n       }\n \n     if (y)\n       r = _gcry_ecc_ec2os (x, y, sk.E.p);\n     else\n       {\n         unsigned char *rawmpi;\n         unsigned int rawmpilen;\n \n         rawmpi = _gcry_mpi_get_buffer_extra (x, nbits/8, -1,\n                                              &rawmpilen, NULL);\n         if (!rawmpi)\n           {\n             rc = gpg_err_code_from_syserror ();\n             goto leave;\n           }\n         else\n           {\n             rawmpi[0] = 0x40;\n             rawmpilen++;\n             r = mpi_new (0);\n             mpi_set_opaque (r, rawmpi, rawmpilen*8);\n           }\n       }\n     if (!r)\n       rc = gpg_err_code_from_syserror ();\n     else\n       rc = 0;\n     mpi_free (x);\n     mpi_free (y);\n   }\n   if (DBG_CIPHER)\n     log_printmpi (\"ecc_decrypt  res\", r);\n \n   if (!rc)\n     rc = sexp_build (r_plain, NULL, \"(value %m)\", r);\n \n  leave:\n   point_free (&R);\n   point_free (&kG);\n   _gcry_mpi_release (r);\n   _gcry_mpi_release (sk.E.p);\n   _gcry_mpi_release (sk.E.a);\n   _gcry_mpi_release (sk.E.b);\n   _gcry_mpi_release (mpi_g);\n   point_free (&sk.E.G);\n   _gcry_mpi_release (sk.E.n);\n   _gcry_mpi_release (sk.E.h);\n   _gcry_mpi_release (sk.d);\n   _gcry_mpi_release (data_e);\n   xfree (curvename);\n   sexp_release (l1);\n   _gcry_mpi_ec_free (ec);\n   _gcry_pk_util_free_encoding_ctx (&ctx);\n   if (DBG_CIPHER)\n     log_debug (\"ecc_decrypt    => %s\\n\", gpg_strerror (rc));\n   return rc;\n }\n \n", "target": "// fix_start\n  if ((flags & PUBKEY_FLAG_DJB_TWEAK))\n    {\n      if (_gcry_mpi_ec_bad_point (&kG, ec))\n        {\n          rc = GPG_ERR_INV_DATA;\n          goto leave;\n        }\n    }\n  else if (!_gcry_mpi_ec_curve_point (&kG, ec))\n// fix_end\n", "cwe": "CWE-200", "cwe_name": "Exposure of Sensitive Information to an Unauthorized Actor", "cve": "CVE-2017-0379", "cve_desc": "Libgcrypt before 1.8.1 does not properly consider Curve25519 side-channel attacks, which makes it easier for attackers to discover a secret key, related to cipher/ecc.c and mpi/ec.c.", "project": "libgcrypt", "idx": 212389}
{"source": " static MagickBooleanType ReadHEICImageByID(const ImageInfo *image_info,\n   Image *image,struct heif_context *heif_context,heif_item_id image_id,\n   ExceptionInfo *exception)\n {\n   const char\n     *option;\n \n   int\n     stride_y,\n     stride_cb,\n     stride_cr;\n \n   MagickBooleanType\n     status;\n \n   ssize_t\n     y;\n \n   struct heif_decoding_options\n     *decode_options;\n \n   struct heif_error\n     error;\n \n   struct heif_image\n     *heif_image;\n \n   struct heif_image_handle\n     *image_handle;\n \n   const uint8_t\n     *p_y,\n     *p_cb,\n     *p_cr;\n \n   error=heif_context_get_image_handle(heif_context,image_id,&image_handle);\n   if (IsHeifSuccess(&error,image,exception) == MagickFalse)\n     return(MagickFalse);\n   if (ReadHEICColorProfile(image,image_handle,exception) == MagickFalse)\n     {\n       heif_image_handle_release(image_handle);\n       return(MagickFalse);\n     }\n   if (ReadHEICExifProfile(image,image_handle,exception) == MagickFalse)\n     {\n       heif_image_handle_release(image_handle);\n       return(MagickFalse);\n     }\n   image->depth=8;\n   image->columns=(size_t) heif_image_handle_get_width(image_handle);\n   image->rows=(size_t) heif_image_handle_get_height(image_handle);\n   if (image_info->ping != MagickFalse)\n     {\n       image->colorspace=YCbCrColorspace;\n       heif_image_handle_release(image_handle);\n       return(MagickTrue);\n     }\n   if (HEICSkipImage(image_info,image) != MagickFalse)\n     {\n       heif_image_handle_release(image_handle);\n       return(MagickTrue);\n     }\n   status=SetImageExtent(image,image->columns,image->rows,exception);\n   if (status == MagickFalse)\n     {\n       heif_image_handle_release(image_handle);\n       return(MagickFalse);\n     }\n   (void) SetImageColorspace(image,YCbCrColorspace,exception);\n   decode_options=(struct heif_decoding_options *) NULL;\n   option=GetImageOption(image_info,\"heic:preserve-orientation\");\n   if (IsStringTrue(option) == MagickTrue)\n     {\n       decode_options=heif_decoding_options_alloc();\n       decode_options->ignore_transformations=1;\n     }\n   else\n     (void) SetImageProperty(image,\"exif:Orientation\",\"1\",exception);\n   error=heif_decode_image(image_handle,&heif_image,heif_colorspace_YCbCr,\n     heif_chroma_420,decode_options);\n// bug_start\n// bug_end\n   if (IsHeifSuccess(&error,image,exception) == MagickFalse)\n     {\n       heif_image_handle_release(image_handle);\n       return(MagickFalse);\n     }\n// bug_start\n  if (decode_options != (struct heif_decoding_options *) NULL)\n// bug_end\n     {\n// bug_start\n      image->columns=(size_t) heif_image_get_width(heif_image,heif_channel_Y);\n      image->rows=(size_t) heif_image_get_height(heif_image,heif_channel_Y);\n      status=SetImageExtent(image,image->columns,image->rows,exception);\n      heif_decoding_options_free(decode_options);\n      if (status == MagickFalse)\n        {\n          heif_image_release(heif_image);\n          heif_image_handle_release(image_handle);\n          return(MagickFalse);\n        }\n// bug_end\n     }\n   p_y=heif_image_get_plane_readonly(heif_image,heif_channel_Y,&stride_y);\n   p_cb=heif_image_get_plane_readonly(heif_image,heif_channel_Cb,&stride_cb);\n   p_cr=heif_image_get_plane_readonly(heif_image,heif_channel_Cr,&stride_cr);\n   for (y=0; y < (ssize_t) image->rows; y++)\n   {\n     Quantum\n       *q;\n \n     register ssize_t\n       x;\n \n     q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n     if (q == (Quantum *) NULL)\n       break;\n     for (x=0; x < (ssize_t) image->columns; x++)\n     {\n       SetPixelRed(image,ScaleCharToQuantum((unsigned char) p_y[y*\n         stride_y+x]),q);\n       SetPixelGreen(image,ScaleCharToQuantum((unsigned char) p_cb[(y/2)*\n         stride_cb+x/2]),q);\n       SetPixelBlue(image,ScaleCharToQuantum((unsigned char) p_cr[(y/2)*\n         stride_cr+x/2]),q);\n       q+=GetPixelChannels(image);\n     }\n     if (SyncAuthenticPixels(image,exception) == MagickFalse)\n       break;\n   }\n   heif_image_release(heif_image);\n   heif_image_handle_release(image_handle);\n   return(MagickTrue);\n }\n \n", "target": "// fix_start\n  if (decode_options != (struct heif_decoding_options *) NULL)\n    heif_decoding_options_free(decode_options);\n// fix_end\n// fix_start\n  image->columns=(size_t) heif_image_get_width(heif_image,heif_channel_Y);\n  image->rows=(size_t) heif_image_get_height(heif_image,heif_channel_Y);\n  status=SetImageExtent(image,image->columns,image->rows,exception);\n  if (status == MagickFalse)\n// fix_end\n// fix_start\n      heif_image_release(heif_image);\n      heif_image_handle_release(image_handle);\n      return(MagickFalse);\n// fix_end\n", "cwe": "CWE-125", "cwe_name": "Out-of-bounds Read", "cve": "CVE-2020-10251", "cve_desc": "In ImageMagick 7.0.9, an out-of-bounds read vulnerability exists within the ReadHEICImageByID function in coders\\heic.c. It can be triggered via an image with a width or height value that exceeds the actual size of the image.", "project": "ImageMagick", "idx": 212425}
{"source": " static MagickBooleanType TIFFGetProfiles(TIFF *tiff,Image *image,\n   ExceptionInfo *exception)\n {\n   MagickBooleanType\n     status;\n \n   uint32\n     length = 0;\n \n   unsigned char\n     *profile = (unsigned char *) NULL;\n \n   status=MagickTrue;\n #if defined(TIFFTAG_ICCPROFILE)\n   if ((TIFFGetField(tiff,TIFFTAG_ICCPROFILE,&length,&profile) == 1) &&\n       (profile != (unsigned char *) NULL))\n     status=ReadProfile(image,\"icc\",profile,(ssize_t) length,exception);\n #endif\n #if defined(TIFFTAG_PHOTOSHOP)\n   if ((TIFFGetField(tiff,TIFFTAG_PHOTOSHOP,&length,&profile) == 1) &&\n       (profile != (unsigned char *) NULL))\n     status=ReadProfile(image,\"8bim\",profile,(ssize_t) length,exception);\n #endif\n #if defined(TIFFTAG_RICHTIFFIPTC)\n   if ((TIFFGetField(tiff,TIFFTAG_RICHTIFFIPTC,&length,&profile) == 1) &&\n       (profile != (unsigned char *) NULL))\n     {\n// bug_start\n// bug_end\n       if (TIFFIsByteSwapped(tiff) != 0)\n         TIFFSwabArrayOfLong((uint32 *) profile,(size_t) length);\n// bug_start\n      status=ReadProfile(image,\"iptc\",profile,4L*length,exception);\n// bug_end\n     }\n #endif\n #if defined(TIFFTAG_XMLPACKET)\n   if ((TIFFGetField(tiff,TIFFTAG_XMLPACKET,&length,&profile) == 1) &&\n       (profile != (unsigned char *) NULL))\n     {\n       StringInfo\n         *dng;\n \n       status=ReadProfile(image,\"xmp\",profile,(ssize_t) length,exception);\n       dng=BlobToStringInfo(profile,length);\n       if (dng != (StringInfo *) NULL)\n         {\n           const char\n             *target = \"dc:format=\\\"image/dng\\\"\";\n \n           if (strstr((char *) GetStringInfoDatum(dng),target) != (char *) NULL)\n             (void) CopyMagickString(image->magick,\"DNG\",MagickPathExtent);\n           dng=DestroyStringInfo(dng);\n         }\n     }\n #endif\n   if ((TIFFGetField(tiff,34118,&length,&profile) == 1) &&\n       (profile != (unsigned char *) NULL))\n     status=ReadProfile(image,\"tiff:34118\",profile,(ssize_t) length,\n       exception);\n   if ((TIFFGetField(tiff,37724,&length,&profile) == 1) &&\n       (profile != (unsigned char *) NULL))\n     status=ReadProfile(image,\"tiff:37724\",profile,(ssize_t) length,exception);\n   return(status);\n }\n \n", "target": "// fix_start\n      const TIFFField\n        *field;\n\n// fix_end\n// fix_start\n      field=TIFFFieldWithTag(tiff,TIFFTAG_RICHTIFFIPTC);\n      if (TIFFFieldDataType(field) == TIFF_LONG)\n        status=ReadProfile(image,\"iptc\",profile,4L*length,exception);\n      else\n        status=ReadProfile(image,\"iptc\",profile,length,exception);\n// fix_end\n", "cwe": "CWE-125", "cwe_name": "Out-of-bounds Read", "cve": "CVE-2020-13902", "cve_desc": "ImageMagick 7.0.9-27 through 7.0.10-17 has a heap-based buffer over-read in BlobToStringInfo in MagickCore/string.c during TIFF image decoding.", "project": "ImageMagick", "idx": 212435}
{"source": " readfile(\n     char_u\t*fname,\n     char_u\t*sfname,\n     linenr_T\tfrom,\n     linenr_T\tlines_to_skip,\n     linenr_T\tlines_to_read,\n     exarg_T\t*eap,\n     int\t\tflags)\n {\n     int\t\tfd = 0;\n     int\t\tnewfile = (flags & READ_NEW);\n     int\t\tcheck_readonly;\n     int\t\tfiltering = (flags & READ_FILTER);\n     int\t\tread_stdin = (flags & READ_STDIN);\n     int\t\tread_buffer = (flags & READ_BUFFER);\n     int\t\tread_fifo = (flags & READ_FIFO);\n     int\t\tset_options = newfile || read_buffer\n \t\t\t\t\t   || (eap != NULL && eap->read_edit);\n     linenr_T\tread_buf_lnum = 1;\n     colnr_T\tread_buf_col = 0;\n     char_u\tc;\n     linenr_T\tlnum = from;\n     char_u\t*ptr = NULL;\n     char_u\t*buffer = NULL;\n     char_u\t*new_buffer = NULL;\n     char_u\t*line_start = NULL;\n     int\t\twasempty;\n     colnr_T\tlen;\n     long\tsize = 0;\n     char_u\t*p;\n     off_T\tfilesize = 0;\n     int\t\tskip_read = FALSE;\n #ifdef FEAT_CRYPT\n     char_u\t*cryptkey = NULL;\n     int\t\tdid_ask_for_key = FALSE;\n #endif\n #ifdef FEAT_PERSISTENT_UNDO\n     context_sha256_T sha_ctx;\n     int\t\tread_undo_file = FALSE;\n #endif\n     int\t\tsplit = 0;\n #define UNKNOWN\t 0x0fffffff\n     linenr_T\tlinecnt;\n     int\t\terror = FALSE;\n     int\t\tff_error = EOL_UNKNOWN;\n     long\tlinerest = 0;\n #ifdef UNIX\n     int\t\tperm = 0;\n     int\t\tswap_mode = -1;\n #else\n     int\t\tperm;\n #endif\n     int\t\tfileformat = 0;\n     int\t\tkeep_fileformat = FALSE;\n     stat_T\tst;\n     int\t\tfile_readonly;\n     linenr_T\tskip_count = 0;\n     linenr_T\tread_count = 0;\n     int\t\tmsg_save = msg_scroll;\n     linenr_T\tread_no_eol_lnum = 0;\n     int\t\ttry_mac;\n     int\t\ttry_dos;\n     int\t\ttry_unix;\n     int\t\tfile_rewind = FALSE;\n #ifdef FEAT_MBYTE\n     int\t\tcan_retry;\n     linenr_T\tconv_error = 0;\n     linenr_T\tillegal_byte = 0;\n     int\t\tkeep_dest_enc = FALSE;\n     int\t\tbad_char_behavior = BAD_REPLACE;\n     char_u\t*tmpname = NULL;\n     int\t\tfio_flags = 0;\n     char_u\t*fenc;\n     int\t\tfenc_alloced;\n     char_u\t*fenc_next = NULL;\n     int\t\tadvance_fenc = FALSE;\n     long\treal_size = 0;\n # ifdef USE_ICONV\n     iconv_t\ticonv_fd = (iconv_t)-1;\n #  ifdef FEAT_EVAL\n     int\t\tdid_iconv = FALSE;\n #  endif\n # endif\n     int\t\tconverted = FALSE;\n     int\t\tnotconverted = FALSE;\n     char_u\tconv_rest[CONV_RESTLEN];\n     int\t\tconv_restlen = 0;\n #endif\n #ifdef FEAT_AUTOCMD\n     buf_T\t*old_curbuf;\n     char_u\t*old_b_ffname;\n     char_u\t*old_b_fname;\n     int\t\tusing_b_ffname;\n     int\t\tusing_b_fname;\n #endif\n \n #ifdef FEAT_AUTOCMD\n     au_did_filetype = FALSE;\n #endif\n \n     curbuf->b_no_eol_lnum = 0;\n \n     if (curbuf->b_ffname == NULL\n \t    && !filtering\n \t    && fname != NULL\n \t    && vim_strchr(p_cpo, CPO_FNAMER) != NULL\n \t    && !(flags & READ_DUMMY))\n     {\n \tif (set_rw_fname(fname, sfname) == FAIL)\n \t    return FAIL;\n     }\n \n #ifdef FEAT_AUTOCMD\n     old_curbuf = curbuf;\n     old_b_ffname = curbuf->b_ffname;\n     old_b_fname = curbuf->b_fname;\n     using_b_ffname = (fname == curbuf->b_ffname)\n \t\t\t\t\t      || (sfname == curbuf->b_ffname);\n     using_b_fname = (fname == curbuf->b_fname) || (sfname == curbuf->b_fname);\n #endif\n \n     ex_no_reprint = TRUE;\n \n     need_fileinfo = FALSE;\n \n     if (sfname == NULL)\n \tsfname = fname;\n #if defined(UNIX)\n     fname = sfname;\n #endif\n \n #ifdef FEAT_AUTOCMD\n     if (!filtering && !read_stdin && !read_buffer)\n     {\n \tpos_T\t    pos;\n \n \tpos = curbuf->b_op_start;\n \n \tcurbuf->b_op_start.lnum = ((from == 0) ? 1 : from);\n \tcurbuf->b_op_start.col = 0;\n \n \tif (newfile)\n \t{\n \t    if (apply_autocmds_exarg(EVENT_BUFREADCMD, NULL, sfname,\n \t\t\t\t\t\t\t  FALSE, curbuf, eap))\n #ifdef FEAT_EVAL\n \t\treturn aborting() ? FAIL : OK;\n #else\n \t\treturn OK;\n #endif\n \t}\n \telse if (apply_autocmds_exarg(EVENT_FILEREADCMD, sfname, sfname,\n \t\t\t\t\t\t\t    FALSE, NULL, eap))\n #ifdef FEAT_EVAL\n \t    return aborting() ? FAIL : OK;\n #else\n \t    return OK;\n #endif\n \n \tcurbuf->b_op_start = pos;\n     }\n #endif\n \n     if ((shortmess(SHM_OVER) || curbuf->b_help) && p_verbose == 0)\n \tmsg_scroll = FALSE;\n     else\n \tmsg_scroll = TRUE;\n \n     if (fname != NULL && *fname != NUL)\n     {\n \tp = fname + STRLEN(fname);\n \tif (after_pathsep(fname, p) || STRLEN(fname) >= MAXPATHL)\n \t{\n \t    filemess(curbuf, fname, (char_u *)_(\"Illegal file name\"), 0);\n \t    msg_end();\n \t    msg_scroll = msg_save;\n \t    return FAIL;\n \t}\n     }\n \n     if (!read_stdin && !read_buffer && !read_fifo)\n     {\n #ifdef UNIX\n \tperm = mch_getperm(fname);\n \tif (perm >= 0 && !S_ISREG(perm)\n # ifdef S_ISFIFO\n \t\t      && !S_ISFIFO(perm)\n # endif\n # ifdef S_ISSOCK\n \t\t      && !S_ISSOCK(perm)\n # endif\n # ifdef OPEN_CHR_FILES\n \t\t      && !(S_ISCHR(perm) && is_dev_fd_file(fname))\n # endif\n \t\t\t\t\t\t)\n \t{\n \t    int retval = FAIL;\n \n \t    if (S_ISDIR(perm))\n \t    {\n \t\tfilemess(curbuf, fname, (char_u *)_(\"is a directory\"), 0);\n \t\tretval = NOTDONE;\n \t    }\n \t    else\n \t\tfilemess(curbuf, fname, (char_u *)_(\"is not a file\"), 0);\n \t    msg_end();\n \t    msg_scroll = msg_save;\n \t    return retval;\n \t}\n #endif\n #if defined(MSWIN)\n \tif (!p_odev && mch_nodetype(fname) == NODE_WRITABLE)\n \t{\n \t    filemess(curbuf, fname, (char_u *)_(\"is a device (disabled with 'opendevice' option)\"), 0);\n \t    msg_end();\n \t    msg_scroll = msg_save;\n \t    return FAIL;\n \t}\n #endif\n     }\n \n     set_file_options(set_options, eap);\n \n     check_readonly = (newfile && (curbuf->b_flags & BF_CHECK_RO));\n     if (check_readonly && !readonlymode)\n \tcurbuf->b_p_ro = FALSE;\n \n     if (newfile && !read_stdin && !read_buffer && !read_fifo)\n     {\n \tif (mch_stat((char *)fname, &st) >= 0)\n \t{\n \t    buf_store_time(curbuf, &st, fname);\n \t    curbuf->b_mtime_read = curbuf->b_mtime;\n #ifdef UNIX\n \t    swap_mode = (st.st_mode & 0644) | 0600;\n #endif\n #ifdef FEAT_CW_EDITOR\n \t    (void)GetFSSpecFromPath(curbuf->b_ffname, &curbuf->b_FSSpec);\n #endif\n #ifdef VMS\n \t    curbuf->b_fab_rfm = st.st_fab_rfm;\n \t    curbuf->b_fab_rat = st.st_fab_rat;\n \t    curbuf->b_fab_mrs = st.st_fab_mrs;\n #endif\n \t}\n \telse\n \t{\n \t    curbuf->b_mtime = 0;\n \t    curbuf->b_mtime_read = 0;\n \t    curbuf->b_orig_size = 0;\n \t    curbuf->b_orig_mode = 0;\n \t}\n \n \tcurbuf->b_flags &= ~(BF_NEW | BF_NEW_W);\n     }\n \n     file_readonly = FALSE;\n     if (read_stdin)\n     {\n #if defined(MSWIN)\n \tsetmode(0, O_BINARY);\n #endif\n     }\n     else if (!read_buffer)\n     {\n #ifdef USE_MCH_ACCESS\n \tif (\n # ifdef UNIX\n \t    !(perm & 0222) ||\n # endif\n \t\t\t\tmch_access((char *)fname, W_OK))\n \t    file_readonly = TRUE;\n \tfd = mch_open((char *)fname, O_RDONLY | O_EXTRA, 0);\n #else\n \tif (!newfile\n \t\t|| readonlymode\n \t\t|| (fd = mch_open((char *)fname, O_RDWR | O_EXTRA, 0)) < 0)\n \t{\n \t    file_readonly = TRUE;\n \t    fd = mch_open((char *)fname, O_RDONLY | O_EXTRA, 0);\n \t}\n #endif\n     }\n \n     if (fd < 0)\n     {\n #ifndef UNIX\n \tint\tisdir_f;\n #endif\n \tmsg_scroll = msg_save;\n #ifndef UNIX\n \tisdir_f = (mch_isdir(fname));\n \tperm = mch_getperm(fname);\n \tif (isdir_f)\n \t{\n \t    filemess(curbuf, sfname, (char_u *)_(\"is a directory\"), 0);\n \t    curbuf->b_p_ro = TRUE;\n \t}\n \telse\n #endif\n \t    if (newfile)\n \t    {\n \t\tif (perm < 0\n #ifdef ENOENT\n \t\t\t&& errno == ENOENT\n #endif\n \t\t   )\n \t\t{\n \t\t    curbuf->b_flags |= BF_NEW;\n \n #ifdef FEAT_QUICKFIX\n \t\t    if (!bt_dontwrite(curbuf))\n #endif\n \t\t    {\n \t\t\tcheck_need_swap(newfile);\n #ifdef FEAT_AUTOCMD\n \t\t\tif (curbuf != old_curbuf\n \t\t\t\t|| (using_b_ffname\n \t\t\t\t\t&& (old_b_ffname != curbuf->b_ffname))\n \t\t\t\t|| (using_b_fname\n \t\t\t\t\t && (old_b_fname != curbuf->b_fname)))\n \t\t\t{\n \t\t\t    EMSG(_(e_auchangedbuf));\n \t\t\t    return FAIL;\n \t\t\t}\n #endif\n \t\t    }\n \t\t    if (dir_of_file_exists(fname))\n \t\t\tfilemess(curbuf, sfname, (char_u *)_(\"[New File]\"), 0);\n \t\t    else\n \t\t\tfilemess(curbuf, sfname,\n \t\t\t\t\t   (char_u *)_(\"[New DIRECTORY]\"), 0);\n #ifdef FEAT_VIMINFO\n \t\t    check_marks_read();\n #endif\n #ifdef FEAT_MBYTE\n \t\t    if (eap != NULL)\n \t\t\tset_forced_fenc(eap);\n #endif\n #ifdef FEAT_AUTOCMD\n \t\t    apply_autocmds_exarg(EVENT_BUFNEWFILE, sfname, sfname,\n \t\t\t\t\t\t\t  FALSE, curbuf, eap);\n #endif\n \t\t    save_file_ff(curbuf);\n \n #if defined(FEAT_AUTOCMD) && defined(FEAT_EVAL)\n \t\t    if (aborting())\n \t\t\treturn FAIL;\n #endif\n \t\t    return OK;\n \t\t}\n \t\telse\n \t\t{\n \t\t    filemess(curbuf, sfname, (char_u *)(\n # ifdef EFBIG\n \t\t\t    (errno == EFBIG) ? _(\"[File too big]\") :\n # endif\n # ifdef EOVERFLOW\n \t\t\t    (errno == EOVERFLOW) ? _(\"[File too big]\") :\n # endif\n \t\t\t\t\t\t_(\"[Permission Denied]\")), 0);\n \t\t    curbuf->b_p_ro = TRUE;\n \t\t}\n \t    }\n \n \treturn FAIL;\n     }\n \n     if ((check_readonly && file_readonly) || curbuf->b_help)\n \tcurbuf->b_p_ro = TRUE;\n \n     if (set_options)\n     {\n \tif (!read_buffer)\n \t{\n \t    curbuf->b_p_eol = TRUE;\n \t    curbuf->b_start_eol = TRUE;\n \t}\n #ifdef FEAT_MBYTE\n \tcurbuf->b_p_bomb = FALSE;\n \tcurbuf->b_start_bomb = FALSE;\n #endif\n     }\n \n #ifdef FEAT_QUICKFIX\n     if (!bt_dontwrite(curbuf))\n #endif\n     {\n \tcheck_need_swap(newfile);\n #ifdef FEAT_AUTOCMD\n \tif (!read_stdin && (curbuf != old_curbuf\n \t\t|| (using_b_ffname && (old_b_ffname != curbuf->b_ffname))\n \t\t|| (using_b_fname && (old_b_fname != curbuf->b_fname))))\n \t{\n \t    EMSG(_(e_auchangedbuf));\n \t    if (!read_buffer)\n \t\tclose(fd);\n \t    return FAIL;\n \t}\n #endif\n #ifdef UNIX\n \tif (swap_mode > 0 && curbuf->b_ml.ml_mfp != NULL\n \t\t\t  && curbuf->b_ml.ml_mfp->mf_fname != NULL)\n// bug_start\n\t    (void)mch_setperm(curbuf->b_ml.ml_mfp->mf_fname, (long)swap_mode);\n// bug_end\n #endif\n     }\n \n #if defined(HAS_SWAP_EXISTS_ACTION)\n     if (swap_exists_action == SEA_QUIT)\n     {\n \tif (!read_buffer && !read_stdin)\n \t    close(fd);\n \treturn FAIL;\n     }\n #endif\n \n     ++no_wait_return;\n \n     curbuf->b_op_start.lnum = ((from == 0) ? 1 : from);\n     curbuf->b_op_start.col = 0;\n \n     try_mac = (vim_strchr(p_ffs, 'm') != NULL);\n     try_dos = (vim_strchr(p_ffs, 'd') != NULL);\n     try_unix = (vim_strchr(p_ffs, 'x') != NULL);\n \n #ifdef FEAT_AUTOCMD\n     if (!read_buffer)\n     {\n \tint\tm = msg_scroll;\n \tint\tn = msg_scrolled;\n \n \tif (!read_stdin)\n \t    close(fd);\n \n \tmsg_scroll = TRUE;\n \tif (filtering)\n \t    apply_autocmds_exarg(EVENT_FILTERREADPRE, NULL, sfname,\n \t\t\t\t\t\t\t  FALSE, curbuf, eap);\n \telse if (read_stdin)\n \t    apply_autocmds_exarg(EVENT_STDINREADPRE, NULL, sfname,\n \t\t\t\t\t\t\t  FALSE, curbuf, eap);\n \telse if (newfile)\n \t    apply_autocmds_exarg(EVENT_BUFREADPRE, NULL, sfname,\n \t\t\t\t\t\t\t  FALSE, curbuf, eap);\n \telse\n \t    apply_autocmds_exarg(EVENT_FILEREADPRE, sfname, sfname,\n \t\t\t\t\t\t\t    FALSE, NULL, eap);\n \ttry_mac = (vim_strchr(p_ffs, 'm') != NULL);\n \ttry_dos = (vim_strchr(p_ffs, 'd') != NULL);\n \ttry_unix = (vim_strchr(p_ffs, 'x') != NULL);\n \n \tif (msg_scrolled == n)\n \t    msg_scroll = m;\n \n #ifdef FEAT_EVAL\n \tif (aborting())\n \t{\n \t    --no_wait_return;\n \t    msg_scroll = msg_save;\n \t    curbuf->b_p_ro = TRUE;\n \t    return FAIL;\n \t}\n #endif\n \tif (!read_stdin && (curbuf != old_curbuf\n \t\t|| (using_b_ffname && (old_b_ffname != curbuf->b_ffname))\n \t\t|| (using_b_fname && (old_b_fname != curbuf->b_fname))\n \t\t|| (fd = mch_open((char *)fname, O_RDONLY | O_EXTRA, 0)) < 0))\n \t{\n \t    --no_wait_return;\n \t    msg_scroll = msg_save;\n \t    if (fd < 0)\n \t\tEMSG(_(\"E200: *ReadPre autocommands made the file unreadable\"));\n \t    else\n \t\tEMSG(_(\"E201: *ReadPre autocommands must not change current buffer\"));\n \t    curbuf->b_p_ro = TRUE;\n \t    return FAIL;\n \t}\n     }\n #endif\n \n     wasempty = (curbuf->b_ml.ml_flags & ML_EMPTY);\n \n     if (!recoverymode && !filtering && !(flags & READ_DUMMY))\n     {\n \tif (read_stdin)\n \t{\n #ifndef ALWAYS_USE_GUI\n \t    mch_msg(_(\"Vim: Reading from stdin...\\n\"));\n #endif\n #ifdef FEAT_GUI\n \t    if (gui.in_use && !gui.dying && !gui.starting)\n \t    {\n \t\tp = (char_u *)_(\"Reading from stdin...\");\n \t\tgui_write(p, (int)STRLEN(p));\n \t    }\n #endif\n \t}\n \telse if (!read_buffer)\n \t    filemess(curbuf, sfname, (char_u *)\"\", 0);\n     }\n \n     msg_scroll = FALSE;\n \n     linecnt = curbuf->b_ml.ml_line_count;\n \n #ifdef FEAT_MBYTE\n     if (eap != NULL && eap->bad_char != 0)\n     {\n \tbad_char_behavior = eap->bad_char;\n \tif (set_options)\n \t    curbuf->b_bad_char = eap->bad_char;\n     }\n     else\n \tcurbuf->b_bad_char = 0;\n \n     if (eap != NULL && eap->force_enc != 0)\n     {\n \tfenc = enc_canonize(eap->cmd + eap->force_enc);\n \tfenc_alloced = TRUE;\n \tkeep_dest_enc = TRUE;\n     }\n     else if (curbuf->b_p_bin)\n     {\n \tfenc = (char_u *)\"\";\n \tfenc_alloced = FALSE;\n     }\n     else if (curbuf->b_help)\n     {\n \tchar_u\t    firstline[80];\n \tint\t    fc;\n \n \tfenc = (char_u *)\"latin1\";\n \tc = enc_utf8;\n \tif (!c && !read_stdin)\n \t{\n \t    fc = fname[STRLEN(fname) - 1];\n \t    if (TOLOWER_ASC(fc) == 'x')\n \t    {\n \t\tlen = read_eintr(fd, firstline, 80);\n \t\tvim_lseek(fd, (off_T)0L, SEEK_SET);\n \t\tfor (p = firstline; p < firstline + len; ++p)\n \t\t    if (*p >= 0x80)\n \t\t    {\n \t\t\tc = TRUE;\n \t\t\tbreak;\n \t\t    }\n \t    }\n \t}\n \n \tif (c)\n \t{\n \t    fenc_next = fenc;\n \t    fenc = (char_u *)\"utf-8\";\n \n \t    if (!enc_utf8)\n \t\tkeep_dest_enc = TRUE;\n \t}\n \tfenc_alloced = FALSE;\n     }\n     else if (*p_fencs == NUL)\n     {\n \tfenc = curbuf->b_p_fenc;\n \tfenc_alloced = FALSE;\n     }\n     else\n     {\n \tfenc_next = p_fencs;\n \tfenc = next_fenc(&fenc_next);\n \tfenc_alloced = TRUE;\n     }\n #endif\n \n retry:\n \n     if (file_rewind)\n     {\n \tif (read_buffer)\n \t{\n \t    read_buf_lnum = 1;\n \t    read_buf_col = 0;\n \t}\n \telse if (read_stdin || vim_lseek(fd, (off_T)0L, SEEK_SET) != 0)\n \t{\n \t    error = TRUE;\n \t    goto failed;\n \t}\n \twhile (lnum > from)\n \t    ml_delete(lnum--, FALSE);\n \tfile_rewind = FALSE;\n #ifdef FEAT_MBYTE\n \tif (set_options)\n \t{\n \t    curbuf->b_p_bomb = FALSE;\n \t    curbuf->b_start_bomb = FALSE;\n \t}\n \tconv_error = 0;\n #endif\n     }\n \n     if (keep_fileformat)\n \tkeep_fileformat = FALSE;\n     else\n     {\n \tif (eap != NULL && eap->force_ff != 0)\n \t{\n \t    fileformat = get_fileformat_force(curbuf, eap);\n \t    try_unix = try_dos = try_mac = FALSE;\n \t}\n \telse if (curbuf->b_p_bin)\n \t    fileformat = EOL_UNIX;\n \telse if (*p_ffs == NUL)\n \t    fileformat = get_fileformat(curbuf);\n \telse\n \t    fileformat = EOL_UNKNOWN;\n     }\n \n #ifdef FEAT_MBYTE\n # ifdef USE_ICONV\n     if (iconv_fd != (iconv_t)-1)\n     {\n \ticonv_close(iconv_fd);\n \ticonv_fd = (iconv_t)-1;\n     }\n # endif\n \n     if (advance_fenc)\n     {\n \tadvance_fenc = FALSE;\n \n \tif (eap != NULL && eap->force_enc != 0)\n \t{\n \t    notconverted = TRUE;\n \t    conv_error = 0;\n \t    if (fenc_alloced)\n \t\tvim_free(fenc);\n \t    fenc = (char_u *)\"\";\n \t    fenc_alloced = FALSE;\n \t}\n \telse\n \t{\n \t    if (fenc_alloced)\n \t\tvim_free(fenc);\n \t    if (fenc_next != NULL)\n \t    {\n \t\tfenc = next_fenc(&fenc_next);\n \t\tfenc_alloced = (fenc_next != NULL);\n \t    }\n \t    else\n \t    {\n \t\tfenc = (char_u *)\"\";\n \t\tfenc_alloced = FALSE;\n \t    }\n \t}\n \tif (tmpname != NULL)\n \t{\n \t    mch_remove(tmpname);\n \t    vim_free(tmpname);\n \t    tmpname = NULL;\n \t}\n     }\n \n     fio_flags = 0;\n     converted = need_conversion(fenc);\n     if (converted)\n     {\n \n \tif (STRCMP(fenc, ENC_UCSBOM) == 0)\n \t    fio_flags = FIO_UCSBOM;\n \n \telse if (enc_utf8 || STRCMP(p_enc, \"latin1\") == 0)\n \t    fio_flags = get_fio_flags(fenc);\n \n # ifdef WIN3264\n \tif (fio_flags == 0)\n \t    fio_flags = get_win_fio_flags(fenc);\n # endif\n \n # ifdef MACOS_CONVERT\n \tif (fio_flags == 0)\n \t    fio_flags = get_mac_fio_flags(fenc);\n # endif\n \n # ifdef USE_ICONV\n \tif (fio_flags == 0\n #  ifdef FEAT_EVAL\n \t\t&& !did_iconv\n #  endif\n \t\t)\n \t    iconv_fd = (iconv_t)my_iconv_open(\n \t\t\t\t  enc_utf8 ? (char_u *)\"utf-8\" : p_enc, fenc);\n # endif\n \n # ifdef FEAT_EVAL\n \tif (fio_flags == 0 && !read_stdin && !read_buffer && *p_ccv != NUL\n \t\t\t\t\t\t    && !read_fifo\n #  ifdef USE_ICONV\n \t\t\t\t\t\t    && iconv_fd == (iconv_t)-1\n #  endif\n \t\t)\n \t{\n #  ifdef USE_ICONV\n \t    did_iconv = FALSE;\n #  endif\n \t    if (tmpname == NULL)\n \t    {\n \t\ttmpname = readfile_charconvert(fname, fenc, &fd);\n \t\tif (tmpname == NULL)\n \t\t{\n \t\t    advance_fenc = TRUE;\n \t\t    if (fd < 0)\n \t\t    {\n \t\t\tEMSG(_(\"E202: Conversion made file unreadable!\"));\n \t\t\terror = TRUE;\n \t\t\tgoto failed;\n \t\t    }\n \t\t    goto retry;\n \t\t}\n \t    }\n \t}\n \telse\n # endif\n \t{\n \t    if (fio_flags == 0\n # ifdef USE_ICONV\n \t\t    && iconv_fd == (iconv_t)-1\n # endif\n \t       )\n \t    {\n \t\tadvance_fenc = TRUE;\n \t\tgoto retry;\n \t    }\n \t}\n     }\n \n     can_retry = (*fenc != NUL && !read_stdin && !read_fifo && !keep_dest_enc);\n #endif\n \n     if (!skip_read)\n     {\n \tlinerest = 0;\n \tfilesize = 0;\n \tskip_count = lines_to_skip;\n \tread_count = lines_to_read;\n #ifdef FEAT_MBYTE\n \tconv_restlen = 0;\n #endif\n #ifdef FEAT_PERSISTENT_UNDO\n \tread_undo_file = (newfile && (flags & READ_KEEP_UNDO) == 0\n \t\t\t\t  && curbuf->b_ffname != NULL\n \t\t\t\t  && curbuf->b_p_udf\n \t\t\t\t  && !filtering\n \t\t\t\t  && !read_fifo\n \t\t\t\t  && !read_stdin\n \t\t\t\t  && !read_buffer);\n \tif (read_undo_file)\n \t    sha256_start(&sha_ctx);\n #endif\n #ifdef FEAT_CRYPT\n \tif (curbuf->b_cryptstate != NULL)\n \t{\n \t    crypt_free_state(curbuf->b_cryptstate);\n \t    curbuf->b_cryptstate = NULL;\n \t}\n #endif\n     }\n \n     while (!error && !got_int)\n     {\n #if VIM_SIZEOF_INT <= 2\n \tif (linerest >= 0x7ff0)\n \t{\n \t    ++split;\n \t    *ptr = NL;\n \t    size = 1;\n \t}\n \telse\n #endif\n \t{\n \t    if (!skip_read)\n \t    {\n #if VIM_SIZEOF_INT > 2\n # if defined(SSIZE_MAX) && (SSIZE_MAX < 0x10000L)\n \t\tsize = SSIZE_MAX;\n # else\n \t\tsize = 0x10000L;\n # endif\n #else\n \t\tsize = 0x7ff0L - linerest;\n #endif\n \n \t\tfor ( ; size >= 10; size = (long)((long_u)size >> 1))\n \t\t{\n \t\t    if ((new_buffer = lalloc((long_u)(size + linerest + 1),\n \t\t\t\t\t\t\t      FALSE)) != NULL)\n \t\t\tbreak;\n \t\t}\n \t\tif (new_buffer == NULL)\n \t\t{\n \t\t    do_outofmem_msg((long_u)(size * 2 + linerest + 1));\n \t\t    error = TRUE;\n \t\t    break;\n \t\t}\n \t\tif (linerest)\n \t\t    mch_memmove(new_buffer, ptr - linerest, (size_t)linerest);\n \t\tvim_free(buffer);\n \t\tbuffer = new_buffer;\n \t\tptr = buffer + linerest;\n \t\tline_start = buffer;\n \n #ifdef FEAT_MBYTE\n \t\treal_size = (int)size;\n # ifdef USE_ICONV\n \t\tif (iconv_fd != (iconv_t)-1)\n \t\t    size = size / ICONV_MULT;\n \t\telse\n # endif\n \t\t    if (fio_flags & FIO_LATIN1)\n \t\t    size = size / 2;\n \t\telse if (fio_flags & (FIO_UCS2 | FIO_UTF16))\n \t\t    size = (size * 2 / 3) & ~1;\n \t\telse if (fio_flags & FIO_UCS4)\n \t\t    size = (size * 2 / 3) & ~3;\n \t\telse if (fio_flags == FIO_UCSBOM)\n \t\t    size = size / ICONV_MULT;\n # ifdef WIN3264\n \t\telse if (fio_flags & FIO_CODEPAGE)\n \t\t    size = size / ICONV_MULT;\n # endif\n # ifdef MACOS_CONVERT\n \t\telse if (fio_flags & FIO_MACROMAN)\n \t\t    size = size / ICONV_MULT;\n # endif\n #endif\n \n #ifdef FEAT_MBYTE\n \t\tif (conv_restlen > 0)\n \t\t{\n \t\t    mch_memmove(ptr, conv_rest, conv_restlen);\n \t\t    ptr += conv_restlen;\n \t\t    size -= conv_restlen;\n \t\t}\n #endif\n \n \t\tif (read_buffer)\n \t\t{\n \t\t    if (read_buf_lnum > from)\n \t\t\tsize = 0;\n \t\t    else\n \t\t    {\n \t\t\tint\tn, ni;\n \t\t\tlong\ttlen;\n \n \t\t\ttlen = 0;\n \t\t\tfor (;;)\n \t\t\t{\n \t\t\t    p = ml_get(read_buf_lnum) + read_buf_col;\n \t\t\t    n = (int)STRLEN(p);\n \t\t\t    if ((int)tlen + n + 1 > size)\n \t\t\t    {\n \t\t\t\tn = (int)(size - tlen);\n \t\t\t\tfor (ni = 0; ni < n; ++ni)\n \t\t\t\t{\n \t\t\t\t    if (p[ni] == NL)\n \t\t\t\t\tptr[tlen++] = NUL;\n \t\t\t\t    else\n \t\t\t\t\tptr[tlen++] = p[ni];\n \t\t\t\t}\n \t\t\t\tread_buf_col += n;\n \t\t\t\tbreak;\n \t\t\t    }\n \t\t\t    else\n \t\t\t    {\n \t\t\t\tfor (ni = 0; ni < n; ++ni)\n \t\t\t\t{\n \t\t\t\t    if (p[ni] == NL)\n \t\t\t\t\tptr[tlen++] = NUL;\n \t\t\t\t    else\n \t\t\t\t\tptr[tlen++] = p[ni];\n \t\t\t\t}\n \t\t\t\tptr[tlen++] = NL;\n \t\t\t\tread_buf_col = 0;\n \t\t\t\tif (++read_buf_lnum > from)\n \t\t\t\t{\n \t\t\t\t    if (!curbuf->b_p_eol)\n \t\t\t\t\t--tlen;\n \t\t\t\t    size = tlen;\n \t\t\t\t    break;\n \t\t\t\t}\n \t\t\t    }\n \t\t\t}\n \t\t    }\n \t\t}\n \t\telse\n \t\t{\n \t\t    size = read_eintr(fd, ptr, size);\n \t\t}\n \n #ifdef FEAT_CRYPT\n \t\tif (filesize == 0 && size > 0)\n \t\t    cryptkey = check_for_cryptkey(cryptkey, ptr, &size,\n \t\t\t\t\t\t  &filesize, newfile, sfname,\n \t\t\t\t\t\t  &did_ask_for_key);\n \t\tif (cryptkey != NULL && curbuf->b_cryptstate != NULL\n \t\t\t\t\t\t\t\t   && size > 0)\n \t\t{\n \t\t    if (crypt_works_inplace(curbuf->b_cryptstate))\n \t\t    {\n \t\t\tcrypt_decode_inplace(curbuf->b_cryptstate, ptr, size);\n \t\t    }\n \t\t    else\n \t\t    {\n \t\t\tchar_u\t*newptr = NULL;\n \t\t\tint\tdecrypted_size;\n \n \t\t\tdecrypted_size = crypt_decode_alloc(\n \t\t\t\t    curbuf->b_cryptstate, ptr, size, &newptr);\n \n \t\t\tif (size > 0 && decrypted_size == 0)\n \t\t\t    continue;\n \n \t\t\tif (linerest == 0)\n \t\t\t{\n \t\t\t    new_buffer = newptr;\n \t\t\t}\n \t\t\telse\n \t\t\t{\n \t\t\t    long_u\tnew_size;\n \n \t\t\t    new_size = (long_u)(decrypted_size + linerest + 1);\n \t\t\t    new_buffer = lalloc(new_size, FALSE);\n \t\t\t    if (new_buffer == NULL)\n \t\t\t    {\n \t\t\t\tdo_outofmem_msg(new_size);\n \t\t\t\terror = TRUE;\n \t\t\t\tbreak;\n \t\t\t    }\n \n \t\t\t    mch_memmove(new_buffer, buffer, linerest);\n \t\t\t    if (newptr != NULL)\n \t\t\t\tmch_memmove(new_buffer + linerest, newptr,\n \t\t\t\t\t\t\t      decrypted_size);\n \t\t\t}\n \n \t\t\tif (new_buffer != NULL)\n \t\t\t{\n \t\t\t    vim_free(buffer);\n \t\t\t    buffer = new_buffer;\n \t\t\t    new_buffer = NULL;\n \t\t\t    line_start = buffer;\n \t\t\t    ptr = buffer + linerest;\n \t\t\t}\n \t\t\tsize = decrypted_size;\n \t\t    }\n \t\t}\n #endif\n \n \t\tif (size <= 0)\n \t\t{\n \t\t    if (size < 0)\n \t\t\terror = TRUE;\n #ifdef FEAT_MBYTE\n \t\t    else if (conv_restlen > 0)\n \t\t    {\n \n \t\t\tif (fio_flags != 0\n # ifdef USE_ICONV\n \t\t\t\t|| iconv_fd != (iconv_t)-1\n # endif\n \t\t\t   )\n \t\t\t{\n \t\t\t    if (can_retry)\n \t\t\t\tgoto rewind_retry;\n \t\t\t    if (conv_error == 0)\n \t\t\t\tconv_error = curbuf->b_ml.ml_line_count\n \t\t\t\t\t\t\t\t- linecnt + 1;\n \t\t\t}\n \t\t\telse if (illegal_byte == 0)\n \t\t\t    illegal_byte = curbuf->b_ml.ml_line_count\n \t\t\t\t\t\t\t\t- linecnt + 1;\n \t\t\tif (bad_char_behavior == BAD_DROP)\n \t\t\t{\n \t\t\t    *(ptr - conv_restlen) = NUL;\n \t\t\t    conv_restlen = 0;\n \t\t\t}\n \t\t\telse\n \t\t\t{\n \t\t\t    if (bad_char_behavior != BAD_KEEP && (fio_flags != 0\n # ifdef USE_ICONV\n \t\t\t\t    || iconv_fd != (iconv_t)-1\n # endif\n \t\t\t       ))\n \t\t\t    {\n \t\t\t\twhile (conv_restlen > 0)\n \t\t\t\t{\n \t\t\t\t    *(--ptr) = bad_char_behavior;\n \t\t\t\t    --conv_restlen;\n \t\t\t\t}\n \t\t\t    }\n \t\t\t    fio_flags = 0;\n # ifdef USE_ICONV\n \t\t\t    if (iconv_fd != (iconv_t)-1)\n \t\t\t    {\n \t\t\t\ticonv_close(iconv_fd);\n \t\t\t\ticonv_fd = (iconv_t)-1;\n \t\t\t    }\n # endif\n \t\t\t}\n \t\t    }\n #endif\n \t\t}\n \t    }\n \t    skip_read = FALSE;\n \n #ifdef FEAT_MBYTE\n \t    if ((filesize == 0\n # ifdef FEAT_CRYPT\n \t\t   || (cryptkey != NULL\n \t\t\t&& filesize == crypt_get_header_len(\n \t\t\t\t\t\t crypt_get_method_nr(curbuf)))\n # endif\n \t\t       )\n \t\t    && (fio_flags == FIO_UCSBOM\n \t\t\t|| (!curbuf->b_p_bomb\n \t\t\t    && tmpname == NULL\n \t\t\t    && (*fenc == 'u' || (*fenc == NUL && enc_utf8)))))\n \t    {\n \t\tchar_u\t*ccname;\n \t\tint\tblen;\n \n \t\tif (size < 2 || curbuf->b_p_bin)\n \t\t    ccname = NULL;\n \t\telse\n \t\t    ccname = check_for_bom(ptr, size, &blen,\n \t\t      fio_flags == FIO_UCSBOM ? FIO_ALL : get_fio_flags(fenc));\n \t\tif (ccname != NULL)\n \t\t{\n \t\t    filesize += blen;\n \t\t    size -= blen;\n \t\t    mch_memmove(ptr, ptr + blen, (size_t)size);\n \t\t    if (set_options)\n \t\t    {\n \t\t\tcurbuf->b_p_bomb = TRUE;\n \t\t\tcurbuf->b_start_bomb = TRUE;\n \t\t    }\n \t\t}\n \n \t\tif (fio_flags == FIO_UCSBOM)\n \t\t{\n \t\t    if (ccname == NULL)\n \t\t    {\n \t\t\tadvance_fenc = TRUE;\n \t\t    }\n \t\t    else\n \t\t    {\n \t\t\tif (fenc_alloced)\n \t\t\t    vim_free(fenc);\n \t\t\tfenc = ccname;\n \t\t\tfenc_alloced = FALSE;\n \t\t    }\n \t\t    skip_read = TRUE;\n \t\t    goto retry;\n \t\t}\n \t    }\n \n \t    ptr -= conv_restlen;\n \t    size += conv_restlen;\n \t    conv_restlen = 0;\n #endif\n \t    if (size <= 0)\n \t\tbreak;\n \n #ifdef FEAT_MBYTE\n \n # ifdef USE_ICONV\n \t    if (iconv_fd != (iconv_t)-1)\n \t    {\n \t\tconst char\t*fromp;\n \t\tchar\t\t*top;\n \t\tsize_t\t\tfrom_size;\n \t\tsize_t\t\tto_size;\n \n \t\tfromp = (char *)ptr;\n \t\tfrom_size = size;\n \t\tptr += size;\n \t\ttop = (char *)ptr;\n \t\tto_size = real_size - size;\n \n \t\twhile ((iconv(iconv_fd, (void *)&fromp, &from_size,\n \t\t\t\t\t\t\t       &top, &to_size)\n \t\t\t    == (size_t)-1 && ICONV_ERRNO != ICONV_EINVAL)\n \t\t\t\t\t\t  || from_size > CONV_RESTLEN)\n \t\t{\n \t\t    if (can_retry)\n \t\t\tgoto rewind_retry;\n \t\t    if (conv_error == 0)\n \t\t\tconv_error = readfile_linenr(linecnt,\n \t\t\t\t\t\t\t  ptr, (char_u *)top);\n \n \t\t    ++fromp;\n \t\t    --from_size;\n \t\t    if (bad_char_behavior == BAD_KEEP)\n \t\t    {\n \t\t\t*top++ = *(fromp - 1);\n \t\t\t--to_size;\n \t\t    }\n \t\t    else if (bad_char_behavior != BAD_DROP)\n \t\t    {\n \t\t\t*top++ = bad_char_behavior;\n \t\t\t--to_size;\n \t\t    }\n \t\t}\n \n \t\tif (from_size > 0)\n \t\t{\n \t\t    mch_memmove(conv_rest, (char_u *)fromp, from_size);\n \t\t    conv_restlen = (int)from_size;\n \t\t}\n \n \t\tline_start = ptr - linerest;\n \t\tmch_memmove(line_start, buffer, (size_t)linerest);\n \t\tsize = (long)((char_u *)top - ptr);\n \t    }\n # endif\n \n # ifdef WIN3264\n \t    if (fio_flags & FIO_CODEPAGE)\n \t    {\n \t\tchar_u\t*src, *dst;\n \t\tWCHAR\tucs2buf[3];\n \t\tint\tucs2len;\n \t\tint\tcodepage = FIO_GET_CP(fio_flags);\n \t\tint\tbytelen;\n \t\tint\tfound_bad;\n \t\tchar\treplstr[2];\n \n \n \t\tif (bad_char_behavior > 0)\n \t\t    replstr[0] = bad_char_behavior;\n \t\telse\n \t\t    replstr[0] = '?';\n \t\treplstr[1] = NUL;\n \n \t\tsrc = ptr + real_size - size;\n \t\tmch_memmove(src, ptr, size);\n \n \t\tdst = ptr;\n \t\tsize = size;\n \t\twhile (size > 0)\n \t\t{\n \t\t    found_bad = FALSE;\n \n #  ifdef CP_UTF8\n \t\t    if (codepage == CP_UTF8)\n \t\t    {\n \t\t\tbytelen = (int)utf_ptr2len_len(src, size);\n \t\t\tif (bytelen > size)\n \t\t\t{\n \t\t\t    if (bytelen <= CONV_RESTLEN)\n \t\t\t\tbreak;\n \n \t\t\t    bytelen = size;\n \t\t\t    found_bad = TRUE;\n \t\t\t}\n \t\t\telse\n \t\t\t{\n \t\t\t    int\t    u8c = utf_ptr2char(src);\n \n \t\t\t    if (u8c > 0xffff || (*src >= 0x80 && bytelen == 1))\n \t\t\t\tfound_bad = TRUE;\n \t\t\t    ucs2buf[0] = u8c;\n \t\t\t    ucs2len = 1;\n \t\t\t}\n \t\t    }\n \t\t    else\n #  endif\n \t\t    {\n \t\t\tfor (bytelen = 1; bytelen <= size && bytelen <= 3;\n \t\t\t\t\t\t\t\t    ++bytelen)\n \t\t\t{\n \t\t\t    ucs2len = MultiByteToWideChar(codepage,\n \t\t\t\t\t\t\t MB_ERR_INVALID_CHARS,\n \t\t\t\t\t\t\t (LPCSTR)src, bytelen,\n \t\t\t\t\t\t\t\t   ucs2buf, 3);\n \t\t\t    if (ucs2len > 0)\n \t\t\t\tbreak;\n \t\t\t}\n \t\t\tif (ucs2len == 0)\n \t\t\t{\n \t\t\t    if (size == 1)\n \t\t\t\tbreak;\n \t\t\t    found_bad = TRUE;\n \t\t\t    bytelen = 1;\n \t\t\t}\n \t\t    }\n \n \t\t    if (!found_bad)\n \t\t    {\n \t\t\tint\ti;\n \n \t\t\tif (enc_utf8)\n \t\t\t{\n \t\t\t    for (i = 0; i < ucs2len; ++i)\n \t\t\t\tdst += utf_char2bytes(ucs2buf[i], dst);\n \t\t\t}\n \t\t\telse\n \t\t\t{\n \t\t\t    BOOL\tbad = FALSE;\n \t\t\t    int\t\tdstlen;\n \n \t\t\t    dstlen = WideCharToMultiByte(enc_codepage, 0,\n \t\t\t\t    (LPCWSTR)ucs2buf, ucs2len,\n \t\t\t\t    (LPSTR)dst, (int)(src - dst),\n \t\t\t\t    replstr, &bad);\n \t\t\t    if (bad)\n \t\t\t\tfound_bad = TRUE;\n \t\t\t    else\n \t\t\t\tdst += dstlen;\n \t\t\t}\n \t\t    }\n \n \t\t    if (found_bad)\n \t\t    {\n \t\t\tif (can_retry)\n \t\t\t    goto rewind_retry;\n \t\t\tif (conv_error == 0)\n \t\t\t    conv_error = readfile_linenr(linecnt, ptr, dst);\n \t\t\tif (bad_char_behavior != BAD_DROP)\n \t\t\t{\n \t\t\t    if (bad_char_behavior == BAD_KEEP)\n \t\t\t    {\n \t\t\t\tmch_memmove(dst, src, bytelen);\n \t\t\t\tdst += bytelen;\n \t\t\t    }\n \t\t\t    else\n \t\t\t\t*dst++ = bad_char_behavior;\n \t\t\t}\n \t\t    }\n \n \t\t    src += bytelen;\n \t\t    size -= bytelen;\n \t\t}\n \n \t\tif (size > 0)\n \t\t{\n \t\t    mch_memmove(conv_rest, src, size);\n \t\t    conv_restlen = size;\n \t\t}\n \n \t\tsize = (long)(dst - ptr);\n \t    }\n \t    else\n # endif\n # ifdef MACOS_CONVERT\n \t    if (fio_flags & FIO_MACROMAN)\n \t    {\n \t\tif (macroman2enc(ptr, &size, real_size) == FAIL)\n \t\t    goto rewind_retry;\n \t    }\n \t    else\n # endif\n \t    if (fio_flags != 0)\n \t    {\n \t\tint\tu8c;\n \t\tchar_u\t*dest;\n \t\tchar_u\t*tail = NULL;\n \n \t\tdest = ptr + real_size;\n \t\tif (fio_flags == FIO_LATIN1 || fio_flags == FIO_UTF8)\n \t\t{\n \t\t    p = ptr + size;\n \t\t    if (fio_flags == FIO_UTF8)\n \t\t    {\n \t\t\ttail = ptr + size - 1;\n \t\t\twhile (tail > ptr && (*tail & 0xc0) == 0x80)\n \t\t\t    --tail;\n \t\t\tif (tail + utf_byte2len(*tail) <= ptr + size)\n \t\t\t    tail = NULL;\n \t\t\telse\n \t\t\t    p = tail;\n \t\t    }\n \t\t}\n \t\telse if (fio_flags & (FIO_UCS2 | FIO_UTF16))\n \t\t{\n \t\t    p = ptr + (size & ~1);\n \t\t    if (size & 1)\n \t\t\ttail = p;\n \t\t    if ((fio_flags & FIO_UTF16) && p > ptr)\n \t\t    {\n \t\t\tif (fio_flags & FIO_ENDIAN_L)\n \t\t\t{\n \t\t\t    u8c = (*--p << 8);\n \t\t\t    u8c += *--p;\n \t\t\t}\n \t\t\telse\n \t\t\t{\n \t\t\t    u8c = *--p;\n \t\t\t    u8c += (*--p << 8);\n \t\t\t}\n \t\t\tif (u8c >= 0xd800 && u8c <= 0xdbff)\n \t\t\t    tail = p;\n \t\t\telse\n \t\t\t    p += 2;\n \t\t    }\n \t\t}\n \t\telse\n \t\t{\n \t\t    p = ptr + (size & ~3);\n \t\t    if (size & 3)\n \t\t\ttail = p;\n \t\t}\n \n \t\tif (tail != NULL)\n \t\t{\n \t\t    conv_restlen = (int)((ptr + size) - tail);\n \t\t    mch_memmove(conv_rest, (char_u *)tail, conv_restlen);\n \t\t    size -= conv_restlen;\n \t\t}\n \n \n \t\twhile (p > ptr)\n \t\t{\n \t\t    if (fio_flags & FIO_LATIN1)\n \t\t\tu8c = *--p;\n \t\t    else if (fio_flags & (FIO_UCS2 | FIO_UTF16))\n \t\t    {\n \t\t\tif (fio_flags & FIO_ENDIAN_L)\n \t\t\t{\n \t\t\t    u8c = (*--p << 8);\n \t\t\t    u8c += *--p;\n \t\t\t}\n \t\t\telse\n \t\t\t{\n \t\t\t    u8c = *--p;\n \t\t\t    u8c += (*--p << 8);\n \t\t\t}\n \t\t\tif ((fio_flags & FIO_UTF16)\n \t\t\t\t\t    && u8c >= 0xdc00 && u8c <= 0xdfff)\n \t\t\t{\n \t\t\t    int u16c;\n \n \t\t\t    if (p == ptr)\n \t\t\t    {\n \t\t\t\tif (can_retry)\n \t\t\t\t    goto rewind_retry;\n \t\t\t\tif (conv_error == 0)\n \t\t\t\t    conv_error = readfile_linenr(linecnt,\n \t\t\t\t\t\t\t\t      ptr, p);\n \t\t\t\tif (bad_char_behavior == BAD_DROP)\n \t\t\t\t    continue;\n \t\t\t\tif (bad_char_behavior != BAD_KEEP)\n \t\t\t\t    u8c = bad_char_behavior;\n \t\t\t    }\n \n \t\t\t    if (fio_flags & FIO_ENDIAN_L)\n \t\t\t    {\n \t\t\t\tu16c = (*--p << 8);\n \t\t\t\tu16c += *--p;\n \t\t\t    }\n \t\t\t    else\n \t\t\t    {\n \t\t\t\tu16c = *--p;\n \t\t\t\tu16c += (*--p << 8);\n \t\t\t    }\n \t\t\t    u8c = 0x10000 + ((u16c & 0x3ff) << 10)\n \t\t\t\t\t\t\t      + (u8c & 0x3ff);\n \n \t\t\t    if (u16c < 0xd800 || u16c > 0xdbff)\n \t\t\t    {\n \t\t\t\tif (can_retry)\n \t\t\t\t    goto rewind_retry;\n \t\t\t\tif (conv_error == 0)\n \t\t\t\t    conv_error = readfile_linenr(linecnt,\n \t\t\t\t\t\t\t\t      ptr, p);\n \t\t\t\tif (bad_char_behavior == BAD_DROP)\n \t\t\t\t    continue;\n \t\t\t\tif (bad_char_behavior != BAD_KEEP)\n \t\t\t\t    u8c = bad_char_behavior;\n \t\t\t    }\n \t\t\t}\n \t\t    }\n \t\t    else if (fio_flags & FIO_UCS4)\n \t\t    {\n \t\t\tif (fio_flags & FIO_ENDIAN_L)\n \t\t\t{\n \t\t\t    u8c = (unsigned)*--p << 24;\n \t\t\t    u8c += (unsigned)*--p << 16;\n \t\t\t    u8c += (unsigned)*--p << 8;\n \t\t\t    u8c += *--p;\n \t\t\t}\n \t\t\telse\n \t\t\t{\n \t\t\t    u8c = *--p;\n \t\t\t    u8c += (unsigned)*--p << 8;\n \t\t\t    u8c += (unsigned)*--p << 16;\n \t\t\t    u8c += (unsigned)*--p << 24;\n \t\t\t}\n \t\t    }\n \t\t    else\n \t\t    {\n \t\t\tif (*--p < 0x80)\n \t\t\t    u8c = *p;\n \t\t\telse\n \t\t\t{\n \t\t\t    len = utf_head_off(ptr, p);\n", "target": "// fix_start\n\t{\n\t    char_u *swap_fname = curbuf->b_ml.ml_mfp->mf_fname;\n\n\t    if ((swap_mode & 044) == 040)\n\t    {\n\t\tstat_T\tswap_st;\n\n\t\tif (mch_stat((char *)swap_fname, &swap_st) >= 0\n\t\t\t&& st.st_gid != swap_st.st_gid\n\t\t\t&& fchown(curbuf->b_ml.ml_mfp->mf_fd, -1, st.st_gid)\n\t\t\t\t\t\t\t\t\t == -1)\n\t\t    swap_mode &= 0600;\n\t    }\n\n\t    (void)mch_setperm(swap_fname, (long)swap_mode);\n\t}\n// fix_end\n", "cwe": "CWE-668", "cwe_name": "Exposure of Resource to Wrong Sphere", "cve": "CVE-2017-17087", "cve_desc": "fileio.c in Vim prior to 8.0.1263 sets the group ownership of a .swp file to the editor's primary group (which may be different from the group ownership of the original file), which allows local users to obtain sensitive information by leveraging an applicable group membership, as demonstrated by /etc/shadow owned by root:shadow mode 0640, but /etc/.shadow.swp owned by root:users mode 0640, a different vulnerability than CVE-2017-1000382.", "project": "vim", "idx": 212695}
{"source": " static int do_jit(struct bpf_prog *bpf_prog, int *addrs, u8 *image,\n \t\t  int oldproglen, struct jit_context *ctx, bool jmp_padding)\n {\n \tbool tail_call_reachable = bpf_prog->aux->tail_call_reachable;\n \tstruct bpf_insn *insn = bpf_prog->insnsi;\n \tbool callee_regs_used[4] = {};\n \tint insn_cnt = bpf_prog->len;\n \tbool tail_call_seen = false;\n \tbool seen_exit = false;\n \tu8 temp[BPF_MAX_INSN_SIZE + BPF_INSN_SAFETY];\n \tint i, cnt = 0, excnt = 0;\n \tint ilen, proglen = 0;\n \tu8 *prog = temp;\n \tint err;\n \n \tdetect_reg_usage(insn, insn_cnt, callee_regs_used,\n \t\t\t &tail_call_seen);\n \n \ttail_call_reachable |= tail_call_seen;\n \n \temit_prologue(&prog, bpf_prog->aux->stack_depth,\n \t\t      bpf_prog_was_classic(bpf_prog), tail_call_reachable,\n \t\t      bpf_prog->aux->func_idx != 0);\n \tpush_callee_regs(&prog, callee_regs_used);\n \n \tilen = prog - temp;\n \tif (image)\n \t\tmemcpy(image + proglen, temp, ilen);\n \tproglen += ilen;\n \taddrs[0] = proglen;\n \tprog = temp;\n \n \tfor (i = 1; i <= insn_cnt; i++, insn++) {\n \t\tconst s32 imm32 = insn->imm;\n \t\tu32 dst_reg = insn->dst_reg;\n \t\tu32 src_reg = insn->src_reg;\n \t\tu8 b2 = 0, b3 = 0;\n \t\tu8 *start_of_ldx;\n \t\ts64 jmp_offset;\n \t\tu8 jmp_cond;\n \t\tu8 *func;\n \t\tint nops;\n \n \t\tswitch (insn->code) {\n \t\tcase BPF_ALU | BPF_ADD | BPF_X:\n \t\tcase BPF_ALU | BPF_SUB | BPF_X:\n \t\tcase BPF_ALU | BPF_AND | BPF_X:\n \t\tcase BPF_ALU | BPF_OR | BPF_X:\n \t\tcase BPF_ALU | BPF_XOR | BPF_X:\n \t\tcase BPF_ALU64 | BPF_ADD | BPF_X:\n \t\tcase BPF_ALU64 | BPF_SUB | BPF_X:\n \t\tcase BPF_ALU64 | BPF_AND | BPF_X:\n \t\tcase BPF_ALU64 | BPF_OR | BPF_X:\n \t\tcase BPF_ALU64 | BPF_XOR | BPF_X:\n \t\t\tmaybe_emit_mod(&prog, dst_reg, src_reg,\n \t\t\t\t       BPF_CLASS(insn->code) == BPF_ALU64);\n \t\t\tb2 = simple_alu_opcodes[BPF_OP(insn->code)];\n \t\t\tEMIT2(b2, add_2reg(0xC0, dst_reg, src_reg));\n \t\t\tbreak;\n \n \t\tcase BPF_ALU64 | BPF_MOV | BPF_X:\n \t\tcase BPF_ALU | BPF_MOV | BPF_X:\n \t\t\temit_mov_reg(&prog,\n \t\t\t\t     BPF_CLASS(insn->code) == BPF_ALU64,\n \t\t\t\t     dst_reg, src_reg);\n \t\t\tbreak;\n \n \t\tcase BPF_ALU | BPF_NEG:\n \t\tcase BPF_ALU64 | BPF_NEG:\n \t\t\tif (BPF_CLASS(insn->code) == BPF_ALU64)\n \t\t\t\tEMIT1(add_1mod(0x48, dst_reg));\n \t\t\telse if (is_ereg(dst_reg))\n \t\t\t\tEMIT1(add_1mod(0x40, dst_reg));\n \t\t\tEMIT2(0xF7, add_1reg(0xD8, dst_reg));\n \t\t\tbreak;\n \n \t\tcase BPF_ALU | BPF_ADD | BPF_K:\n \t\tcase BPF_ALU | BPF_SUB | BPF_K:\n \t\tcase BPF_ALU | BPF_AND | BPF_K:\n \t\tcase BPF_ALU | BPF_OR | BPF_K:\n \t\tcase BPF_ALU | BPF_XOR | BPF_K:\n \t\tcase BPF_ALU64 | BPF_ADD | BPF_K:\n \t\tcase BPF_ALU64 | BPF_SUB | BPF_K:\n \t\tcase BPF_ALU64 | BPF_AND | BPF_K:\n \t\tcase BPF_ALU64 | BPF_OR | BPF_K:\n \t\tcase BPF_ALU64 | BPF_XOR | BPF_K:\n \t\t\tif (BPF_CLASS(insn->code) == BPF_ALU64)\n \t\t\t\tEMIT1(add_1mod(0x48, dst_reg));\n \t\t\telse if (is_ereg(dst_reg))\n \t\t\t\tEMIT1(add_1mod(0x40, dst_reg));\n \n \t\t\tswitch (BPF_OP(insn->code)) {\n \t\t\tcase BPF_ADD:\n \t\t\t\tb3 = 0xC0;\n \t\t\t\tb2 = 0x05;\n \t\t\t\tbreak;\n \t\t\tcase BPF_SUB:\n \t\t\t\tb3 = 0xE8;\n \t\t\t\tb2 = 0x2D;\n \t\t\t\tbreak;\n \t\t\tcase BPF_AND:\n \t\t\t\tb3 = 0xE0;\n \t\t\t\tb2 = 0x25;\n \t\t\t\tbreak;\n \t\t\tcase BPF_OR:\n \t\t\t\tb3 = 0xC8;\n \t\t\t\tb2 = 0x0D;\n \t\t\t\tbreak;\n \t\t\tcase BPF_XOR:\n \t\t\t\tb3 = 0xF0;\n \t\t\t\tb2 = 0x35;\n \t\t\t\tbreak;\n \t\t\t}\n \n \t\t\tif (is_imm8(imm32))\n \t\t\t\tEMIT3(0x83, add_1reg(b3, dst_reg), imm32);\n \t\t\telse if (is_axreg(dst_reg))\n \t\t\t\tEMIT1_off32(b2, imm32);\n \t\t\telse\n \t\t\t\tEMIT2_off32(0x81, add_1reg(b3, dst_reg), imm32);\n \t\t\tbreak;\n \n \t\tcase BPF_ALU64 | BPF_MOV | BPF_K:\n \t\tcase BPF_ALU | BPF_MOV | BPF_K:\n \t\t\temit_mov_imm32(&prog, BPF_CLASS(insn->code) == BPF_ALU64,\n \t\t\t\t       dst_reg, imm32);\n \t\t\tbreak;\n \n \t\tcase BPF_LD | BPF_IMM | BPF_DW:\n \t\t\temit_mov_imm64(&prog, dst_reg, insn[1].imm, insn[0].imm);\n \t\t\tinsn++;\n \t\t\ti++;\n \t\t\tbreak;\n \n \t\tcase BPF_ALU | BPF_MOD | BPF_X:\n \t\tcase BPF_ALU | BPF_DIV | BPF_X:\n \t\tcase BPF_ALU | BPF_MOD | BPF_K:\n \t\tcase BPF_ALU | BPF_DIV | BPF_K:\n \t\tcase BPF_ALU64 | BPF_MOD | BPF_X:\n \t\tcase BPF_ALU64 | BPF_DIV | BPF_X:\n \t\tcase BPF_ALU64 | BPF_MOD | BPF_K:\n \t\tcase BPF_ALU64 | BPF_DIV | BPF_K:\n \t\t\tEMIT1(0x50);\n \t\t\tEMIT1(0x52);\n \n \t\t\tif (BPF_SRC(insn->code) == BPF_X)\n \t\t\t\tEMIT_mov(AUX_REG, src_reg);\n \t\t\telse\n \t\t\t\tEMIT3_off32(0x49, 0xC7, 0xC3, imm32);\n \n \t\t\tEMIT_mov(BPF_REG_0, dst_reg);\n \n \t\t\tEMIT2(0x31, 0xd2);\n \n \t\t\tif (BPF_CLASS(insn->code) == BPF_ALU64)\n \t\t\t\tEMIT3(0x49, 0xF7, 0xF3);\n \t\t\telse\n \t\t\t\tEMIT3(0x41, 0xF7, 0xF3);\n \n \t\t\tif (BPF_OP(insn->code) == BPF_MOD)\n \t\t\t\tEMIT3(0x49, 0x89, 0xD3);\n \t\t\telse\n \t\t\t\tEMIT3(0x49, 0x89, 0xC3);\n \n \t\t\tEMIT1(0x5A);\n \t\t\tEMIT1(0x58);\n \n \t\t\tEMIT_mov(dst_reg, AUX_REG);\n \t\t\tbreak;\n \n \t\tcase BPF_ALU | BPF_MUL | BPF_K:\n \t\tcase BPF_ALU | BPF_MUL | BPF_X:\n \t\tcase BPF_ALU64 | BPF_MUL | BPF_K:\n \t\tcase BPF_ALU64 | BPF_MUL | BPF_X:\n \t\t{\n \t\t\tbool is64 = BPF_CLASS(insn->code) == BPF_ALU64;\n \n \t\t\tif (dst_reg != BPF_REG_0)\n \t\t\t\tEMIT1(0x50);\n \t\t\tif (dst_reg != BPF_REG_3)\n \t\t\t\tEMIT1(0x52);\n \n \t\t\tEMIT_mov(AUX_REG, dst_reg);\n \n \t\t\tif (BPF_SRC(insn->code) == BPF_X)\n \t\t\t\temit_mov_reg(&prog, is64, BPF_REG_0, src_reg);\n \t\t\telse\n \t\t\t\temit_mov_imm32(&prog, is64, BPF_REG_0, imm32);\n \n \t\t\tif (is64)\n \t\t\t\tEMIT1(add_1mod(0x48, AUX_REG));\n \t\t\telse if (is_ereg(AUX_REG))\n \t\t\t\tEMIT1(add_1mod(0x40, AUX_REG));\n \t\t\tEMIT2(0xF7, add_1reg(0xE0, AUX_REG));\n \n \t\t\tif (dst_reg != BPF_REG_3)\n \t\t\t\tEMIT1(0x5A);\n \t\t\tif (dst_reg != BPF_REG_0) {\n \t\t\t\tEMIT_mov(dst_reg, BPF_REG_0);\n \t\t\t\tEMIT1(0x58);\n \t\t\t}\n \t\t\tbreak;\n \t\t}\n \t\tcase BPF_ALU | BPF_LSH | BPF_K:\n \t\tcase BPF_ALU | BPF_RSH | BPF_K:\n \t\tcase BPF_ALU | BPF_ARSH | BPF_K:\n \t\tcase BPF_ALU64 | BPF_LSH | BPF_K:\n \t\tcase BPF_ALU64 | BPF_RSH | BPF_K:\n \t\tcase BPF_ALU64 | BPF_ARSH | BPF_K:\n \t\t\tif (BPF_CLASS(insn->code) == BPF_ALU64)\n \t\t\t\tEMIT1(add_1mod(0x48, dst_reg));\n \t\t\telse if (is_ereg(dst_reg))\n \t\t\t\tEMIT1(add_1mod(0x40, dst_reg));\n \n \t\t\tb3 = simple_alu_opcodes[BPF_OP(insn->code)];\n \t\t\tif (imm32 == 1)\n \t\t\t\tEMIT2(0xD1, add_1reg(b3, dst_reg));\n \t\t\telse\n \t\t\t\tEMIT3(0xC1, add_1reg(b3, dst_reg), imm32);\n \t\t\tbreak;\n \n \t\tcase BPF_ALU | BPF_LSH | BPF_X:\n \t\tcase BPF_ALU | BPF_RSH | BPF_X:\n \t\tcase BPF_ALU | BPF_ARSH | BPF_X:\n \t\tcase BPF_ALU64 | BPF_LSH | BPF_X:\n \t\tcase BPF_ALU64 | BPF_RSH | BPF_X:\n \t\tcase BPF_ALU64 | BPF_ARSH | BPF_X:\n \n \t\t\tif (dst_reg == BPF_REG_4) {\n \t\t\t\tEMIT_mov(AUX_REG, dst_reg);\n \t\t\t\tdst_reg = AUX_REG;\n \t\t\t}\n \n \t\t\tif (src_reg != BPF_REG_4) {\n \t\t\t\tEMIT1(0x51);\n \n \t\t\t\tEMIT_mov(BPF_REG_4, src_reg);\n \t\t\t}\n \n \t\t\tif (BPF_CLASS(insn->code) == BPF_ALU64)\n \t\t\t\tEMIT1(add_1mod(0x48, dst_reg));\n \t\t\telse if (is_ereg(dst_reg))\n \t\t\t\tEMIT1(add_1mod(0x40, dst_reg));\n \n \t\t\tb3 = simple_alu_opcodes[BPF_OP(insn->code)];\n \t\t\tEMIT2(0xD3, add_1reg(b3, dst_reg));\n \n \t\t\tif (src_reg != BPF_REG_4)\n \t\t\t\tEMIT1(0x59);\n \n \t\t\tif (insn->dst_reg == BPF_REG_4)\n \t\t\t\tEMIT_mov(insn->dst_reg, AUX_REG);\n \t\t\tbreak;\n \n \t\tcase BPF_ALU | BPF_END | BPF_FROM_BE:\n \t\t\tswitch (imm32) {\n \t\t\tcase 16:\n \t\t\t\tEMIT1(0x66);\n \t\t\t\tif (is_ereg(dst_reg))\n \t\t\t\t\tEMIT1(0x41);\n \t\t\t\tEMIT3(0xC1, add_1reg(0xC8, dst_reg), 8);\n \n \t\t\t\tif (is_ereg(dst_reg))\n \t\t\t\t\tEMIT3(0x45, 0x0F, 0xB7);\n \t\t\t\telse\n \t\t\t\t\tEMIT2(0x0F, 0xB7);\n \t\t\t\tEMIT1(add_2reg(0xC0, dst_reg, dst_reg));\n \t\t\t\tbreak;\n \t\t\tcase 32:\n \t\t\t\tif (is_ereg(dst_reg))\n \t\t\t\t\tEMIT2(0x41, 0x0F);\n \t\t\t\telse\n \t\t\t\t\tEMIT1(0x0F);\n \t\t\t\tEMIT1(add_1reg(0xC8, dst_reg));\n \t\t\t\tbreak;\n \t\t\tcase 64:\n \t\t\t\tEMIT3(add_1mod(0x48, dst_reg), 0x0F,\n \t\t\t\t      add_1reg(0xC8, dst_reg));\n \t\t\t\tbreak;\n \t\t\t}\n \t\t\tbreak;\n \n \t\tcase BPF_ALU | BPF_END | BPF_FROM_LE:\n \t\t\tswitch (imm32) {\n \t\t\tcase 16:\n \t\t\t\tif (is_ereg(dst_reg))\n \t\t\t\t\tEMIT3(0x45, 0x0F, 0xB7);\n \t\t\t\telse\n \t\t\t\t\tEMIT2(0x0F, 0xB7);\n \t\t\t\tEMIT1(add_2reg(0xC0, dst_reg, dst_reg));\n \t\t\t\tbreak;\n \t\t\tcase 32:\n \t\t\t\tif (is_ereg(dst_reg))\n \t\t\t\t\tEMIT1(0x45);\n \t\t\t\tEMIT2(0x89, add_2reg(0xC0, dst_reg, dst_reg));\n \t\t\t\tbreak;\n \t\t\tcase 64:\n \t\t\t\tbreak;\n \t\t\t}\n \t\t\tbreak;\n \n \t\tcase BPF_ST | BPF_MEM | BPF_B:\n \t\t\tif (is_ereg(dst_reg))\n \t\t\t\tEMIT2(0x41, 0xC6);\n \t\t\telse\n \t\t\t\tEMIT1(0xC6);\n \t\t\tgoto st;\n \t\tcase BPF_ST | BPF_MEM | BPF_H:\n \t\t\tif (is_ereg(dst_reg))\n \t\t\t\tEMIT3(0x66, 0x41, 0xC7);\n \t\t\telse\n \t\t\t\tEMIT2(0x66, 0xC7);\n \t\t\tgoto st;\n \t\tcase BPF_ST | BPF_MEM | BPF_W:\n \t\t\tif (is_ereg(dst_reg))\n \t\t\t\tEMIT2(0x41, 0xC7);\n \t\t\telse\n \t\t\t\tEMIT1(0xC7);\n \t\t\tgoto st;\n \t\tcase BPF_ST | BPF_MEM | BPF_DW:\n \t\t\tEMIT2(add_1mod(0x48, dst_reg), 0xC7);\n \n st:\t\t\tif (is_imm8(insn->off))\n \t\t\t\tEMIT2(add_1reg(0x40, dst_reg), insn->off);\n \t\t\telse\n \t\t\t\tEMIT1_off32(add_1reg(0x80, dst_reg), insn->off);\n \n \t\t\tEMIT(imm32, bpf_size_to_x86_bytes(BPF_SIZE(insn->code)));\n \t\t\tbreak;\n \n \t\tcase BPF_STX | BPF_MEM | BPF_B:\n \t\tcase BPF_STX | BPF_MEM | BPF_H:\n \t\tcase BPF_STX | BPF_MEM | BPF_W:\n \t\tcase BPF_STX | BPF_MEM | BPF_DW:\n \t\t\temit_stx(&prog, BPF_SIZE(insn->code), dst_reg, src_reg, insn->off);\n \t\t\tbreak;\n \n \t\tcase BPF_LDX | BPF_MEM | BPF_B:\n \t\tcase BPF_LDX | BPF_PROBE_MEM | BPF_B:\n \t\tcase BPF_LDX | BPF_MEM | BPF_H:\n \t\tcase BPF_LDX | BPF_PROBE_MEM | BPF_H:\n \t\tcase BPF_LDX | BPF_MEM | BPF_W:\n \t\tcase BPF_LDX | BPF_PROBE_MEM | BPF_W:\n \t\tcase BPF_LDX | BPF_MEM | BPF_DW:\n \t\tcase BPF_LDX | BPF_PROBE_MEM | BPF_DW:\n \t\t\tif (BPF_MODE(insn->code) == BPF_PROBE_MEM) {\n \t\t\t\tmaybe_emit_mod(&prog, src_reg, src_reg, true);\n \t\t\t\tEMIT2(0x85, add_2reg(0xC0, src_reg, src_reg));\n \t\t\t\tEMIT2(X86_JNE, 0);\n \t\t\t\temit_mov_imm32(&prog, false, dst_reg, 0);\n \t\t\t\tEMIT2(0xEB, 0);\n \n \t\t\t\ttemp[4] = prog - temp - 5 ;\n \t\t\t\tstart_of_ldx = prog;\n \t\t\t}\n \t\t\temit_ldx(&prog, BPF_SIZE(insn->code), dst_reg, src_reg, insn->off);\n \t\t\tif (BPF_MODE(insn->code) == BPF_PROBE_MEM) {\n \t\t\t\tstruct exception_table_entry *ex;\n \t\t\t\tu8 *_insn = image + proglen;\n \t\t\t\ts64 delta;\n \n \t\t\t\tstart_of_ldx[-1] = prog - start_of_ldx;\n \n \t\t\t\tif (!bpf_prog->aux->extable)\n \t\t\t\t\tbreak;\n \n \t\t\t\tif (excnt >= bpf_prog->aux->num_exentries) {\n \t\t\t\t\tpr_err(\"ex gen bug\\n\");\n \t\t\t\t\treturn -EFAULT;\n \t\t\t\t}\n \t\t\t\tex = &bpf_prog->aux->extable[excnt++];\n \n \t\t\t\tdelta = _insn - (u8 *)&ex->insn;\n \t\t\t\tif (!is_simm32(delta)) {\n \t\t\t\t\tpr_err(\"extable->insn doesn't fit into 32-bit\\n\");\n \t\t\t\t\treturn -EFAULT;\n \t\t\t\t}\n \t\t\t\tex->insn = delta;\n \n \t\t\t\tdelta = (u8 *)ex_handler_bpf - (u8 *)&ex->handler;\n \t\t\t\tif (!is_simm32(delta)) {\n \t\t\t\t\tpr_err(\"extable->handler doesn't fit into 32-bit\\n\");\n \t\t\t\t\treturn -EFAULT;\n \t\t\t\t}\n \t\t\t\tex->handler = delta;\n \n \t\t\t\tif (dst_reg > BPF_REG_9) {\n \t\t\t\t\tpr_err(\"verifier error\\n\");\n \t\t\t\t\treturn -EFAULT;\n \t\t\t\t}\n \t\t\t\tex->fixup = (prog - temp) | (reg2pt_regs[dst_reg] << 8);\n \t\t\t}\n \t\t\tbreak;\n \n \t\tcase BPF_STX | BPF_ATOMIC | BPF_W:\n \t\tcase BPF_STX | BPF_ATOMIC | BPF_DW:\n \t\t\tif (insn->imm == (BPF_AND | BPF_FETCH) ||\n \t\t\t    insn->imm == (BPF_OR | BPF_FETCH) ||\n \t\t\t    insn->imm == (BPF_XOR | BPF_FETCH)) {\n \t\t\t\tu8 *branch_target;\n \t\t\t\tbool is64 = BPF_SIZE(insn->code) == BPF_DW;\n \t\t\t\tu32 real_src_reg = src_reg;\n \n \n \t\t\t\temit_mov_reg(&prog, true, BPF_REG_AX, BPF_REG_0);\n \t\t\t\tif (src_reg == BPF_REG_0)\n \t\t\t\t\treal_src_reg = BPF_REG_AX;\n \n \t\t\t\tbranch_target = prog;\n \t\t\t\temit_ldx(&prog, BPF_SIZE(insn->code),\n \t\t\t\t\t BPF_REG_0, dst_reg, insn->off);\n \t\t\t\temit_mov_reg(&prog, is64, AUX_REG, BPF_REG_0);\n \t\t\t\tmaybe_emit_mod(&prog, AUX_REG, real_src_reg, is64);\n \t\t\t\tEMIT2(simple_alu_opcodes[BPF_OP(insn->imm)],\n \t\t\t\t      add_2reg(0xC0, AUX_REG, real_src_reg));\n \t\t\t\terr = emit_atomic(&prog, BPF_CMPXCHG,\n \t\t\t\t\t\t  dst_reg, AUX_REG, insn->off,\n \t\t\t\t\t\t  BPF_SIZE(insn->code));\n \t\t\t\tif (WARN_ON(err))\n \t\t\t\t\treturn err;\n \t\t\t\tEMIT2(X86_JNE, -(prog - branch_target) - 2);\n \t\t\t\temit_mov_reg(&prog, is64, real_src_reg, BPF_REG_0);\n \t\t\t\temit_mov_reg(&prog, true, BPF_REG_0, BPF_REG_AX);\n \t\t\t\tbreak;\n \n \t\t\t}\n \n \t\t\terr = emit_atomic(&prog, insn->imm, dst_reg, src_reg,\n \t\t\t\t\t\t  insn->off, BPF_SIZE(insn->code));\n \t\t\tif (err)\n \t\t\t\treturn err;\n \t\t\tbreak;\n \n \t\tcase BPF_JMP | BPF_CALL:\n \t\t\tfunc = (u8 *) __bpf_call_base + imm32;\n \t\t\tif (tail_call_reachable) {\n \t\t\t\tEMIT3_off32(0x48, 0x8B, 0x85,\n \t\t\t\t\t    -(bpf_prog->aux->stack_depth + 8));\n \t\t\t\tif (!imm32 || emit_call(&prog, func, image + addrs[i - 1] + 7))\n \t\t\t\t\treturn -EINVAL;\n \t\t\t} else {\n \t\t\t\tif (!imm32 || emit_call(&prog, func, image + addrs[i - 1]))\n \t\t\t\t\treturn -EINVAL;\n \t\t\t}\n \t\t\tbreak;\n \n \t\tcase BPF_JMP | BPF_TAIL_CALL:\n \t\t\tif (imm32)\n \t\t\t\temit_bpf_tail_call_direct(&bpf_prog->aux->poke_tab[imm32 - 1],\n \t\t\t\t\t\t\t  &prog, addrs[i], image,\n \t\t\t\t\t\t\t  callee_regs_used,\n \t\t\t\t\t\t\t  bpf_prog->aux->stack_depth);\n \t\t\telse\n \t\t\t\temit_bpf_tail_call_indirect(&prog,\n \t\t\t\t\t\t\t    callee_regs_used,\n \t\t\t\t\t\t\t    bpf_prog->aux->stack_depth);\n \t\t\tbreak;\n \n \t\tcase BPF_JMP | BPF_JEQ | BPF_X:\n \t\tcase BPF_JMP | BPF_JNE | BPF_X:\n \t\tcase BPF_JMP | BPF_JGT | BPF_X:\n \t\tcase BPF_JMP | BPF_JLT | BPF_X:\n \t\tcase BPF_JMP | BPF_JGE | BPF_X:\n \t\tcase BPF_JMP | BPF_JLE | BPF_X:\n \t\tcase BPF_JMP | BPF_JSGT | BPF_X:\n \t\tcase BPF_JMP | BPF_JSLT | BPF_X:\n \t\tcase BPF_JMP | BPF_JSGE | BPF_X:\n \t\tcase BPF_JMP | BPF_JSLE | BPF_X:\n \t\tcase BPF_JMP32 | BPF_JEQ | BPF_X:\n \t\tcase BPF_JMP32 | BPF_JNE | BPF_X:\n \t\tcase BPF_JMP32 | BPF_JGT | BPF_X:\n \t\tcase BPF_JMP32 | BPF_JLT | BPF_X:\n \t\tcase BPF_JMP32 | BPF_JGE | BPF_X:\n \t\tcase BPF_JMP32 | BPF_JLE | BPF_X:\n \t\tcase BPF_JMP32 | BPF_JSGT | BPF_X:\n \t\tcase BPF_JMP32 | BPF_JSLT | BPF_X:\n \t\tcase BPF_JMP32 | BPF_JSGE | BPF_X:\n \t\tcase BPF_JMP32 | BPF_JSLE | BPF_X:\n \t\t\tmaybe_emit_mod(&prog, dst_reg, src_reg,\n \t\t\t\t       BPF_CLASS(insn->code) == BPF_JMP);\n \t\t\tEMIT2(0x39, add_2reg(0xC0, dst_reg, src_reg));\n \t\t\tgoto emit_cond_jmp;\n \n \t\tcase BPF_JMP | BPF_JSET | BPF_X:\n \t\tcase BPF_JMP32 | BPF_JSET | BPF_X:\n \t\t\tmaybe_emit_mod(&prog, dst_reg, src_reg,\n \t\t\t\t       BPF_CLASS(insn->code) == BPF_JMP);\n \t\t\tEMIT2(0x85, add_2reg(0xC0, dst_reg, src_reg));\n \t\t\tgoto emit_cond_jmp;\n \n \t\tcase BPF_JMP | BPF_JSET | BPF_K:\n \t\tcase BPF_JMP32 | BPF_JSET | BPF_K:\n \t\t\tif (BPF_CLASS(insn->code) == BPF_JMP)\n \t\t\t\tEMIT1(add_1mod(0x48, dst_reg));\n \t\t\telse if (is_ereg(dst_reg))\n \t\t\t\tEMIT1(add_1mod(0x40, dst_reg));\n \t\t\tEMIT2_off32(0xF7, add_1reg(0xC0, dst_reg), imm32);\n \t\t\tgoto emit_cond_jmp;\n \n \t\tcase BPF_JMP | BPF_JEQ | BPF_K:\n \t\tcase BPF_JMP | BPF_JNE | BPF_K:\n \t\tcase BPF_JMP | BPF_JGT | BPF_K:\n \t\tcase BPF_JMP | BPF_JLT | BPF_K:\n \t\tcase BPF_JMP | BPF_JGE | BPF_K:\n \t\tcase BPF_JMP | BPF_JLE | BPF_K:\n \t\tcase BPF_JMP | BPF_JSGT | BPF_K:\n \t\tcase BPF_JMP | BPF_JSLT | BPF_K:\n \t\tcase BPF_JMP | BPF_JSGE | BPF_K:\n \t\tcase BPF_JMP | BPF_JSLE | BPF_K:\n \t\tcase BPF_JMP32 | BPF_JEQ | BPF_K:\n \t\tcase BPF_JMP32 | BPF_JNE | BPF_K:\n \t\tcase BPF_JMP32 | BPF_JGT | BPF_K:\n \t\tcase BPF_JMP32 | BPF_JLT | BPF_K:\n \t\tcase BPF_JMP32 | BPF_JGE | BPF_K:\n \t\tcase BPF_JMP32 | BPF_JLE | BPF_K:\n \t\tcase BPF_JMP32 | BPF_JSGT | BPF_K:\n \t\tcase BPF_JMP32 | BPF_JSLT | BPF_K:\n \t\tcase BPF_JMP32 | BPF_JSGE | BPF_K:\n \t\tcase BPF_JMP32 | BPF_JSLE | BPF_K:\n \t\t\tif (imm32 == 0) {\n \t\t\t\tmaybe_emit_mod(&prog, dst_reg, dst_reg,\n \t\t\t\t\t       BPF_CLASS(insn->code) == BPF_JMP);\n \t\t\t\tEMIT2(0x85, add_2reg(0xC0, dst_reg, dst_reg));\n \t\t\t\tgoto emit_cond_jmp;\n \t\t\t}\n \n \t\t\tif (BPF_CLASS(insn->code) == BPF_JMP)\n \t\t\t\tEMIT1(add_1mod(0x48, dst_reg));\n \t\t\telse if (is_ereg(dst_reg))\n \t\t\t\tEMIT1(add_1mod(0x40, dst_reg));\n \n \t\t\tif (is_imm8(imm32))\n \t\t\t\tEMIT3(0x83, add_1reg(0xF8, dst_reg), imm32);\n \t\t\telse\n \t\t\t\tEMIT2_off32(0x81, add_1reg(0xF8, dst_reg), imm32);\n \n emit_cond_jmp:\n \t\t\tswitch (BPF_OP(insn->code)) {\n \t\t\tcase BPF_JEQ:\n \t\t\t\tjmp_cond = X86_JE;\n \t\t\t\tbreak;\n \t\t\tcase BPF_JSET:\n \t\t\tcase BPF_JNE:\n \t\t\t\tjmp_cond = X86_JNE;\n \t\t\t\tbreak;\n \t\t\tcase BPF_JGT:\n \t\t\t\tjmp_cond = X86_JA;\n \t\t\t\tbreak;\n \t\t\tcase BPF_JLT:\n \t\t\t\tjmp_cond = X86_JB;\n \t\t\t\tbreak;\n \t\t\tcase BPF_JGE:\n \t\t\t\tjmp_cond = X86_JAE;\n \t\t\t\tbreak;\n \t\t\tcase BPF_JLE:\n \t\t\t\tjmp_cond = X86_JBE;\n \t\t\t\tbreak;\n \t\t\tcase BPF_JSGT:\n \t\t\t\tjmp_cond = X86_JG;\n \t\t\t\tbreak;\n \t\t\tcase BPF_JSLT:\n \t\t\t\tjmp_cond = X86_JL;\n \t\t\t\tbreak;\n \t\t\tcase BPF_JSGE:\n \t\t\t\tjmp_cond = X86_JGE;\n \t\t\t\tbreak;\n \t\t\tcase BPF_JSLE:\n \t\t\t\tjmp_cond = X86_JLE;\n \t\t\t\tbreak;\n \t\t\tdefault:\n \t\t\t\treturn -EFAULT;\n \t\t\t}\n \t\t\tjmp_offset = addrs[i + insn->off] - addrs[i];\n \t\t\tif (is_imm8(jmp_offset)) {\n \t\t\t\tif (jmp_padding) {\n \t\t\t\t\tnops = INSN_SZ_DIFF - 2;\n \t\t\t\t\tif (nops != 0 && nops != 4) {\n \t\t\t\t\t\tpr_err(\"unexpected jmp_cond padding: %d bytes\\n\",\n \t\t\t\t\t\t       nops);\n \t\t\t\t\t\treturn -EFAULT;\n \t\t\t\t\t}\n \t\t\t\t\tcnt += emit_nops(&prog, nops);\n \t\t\t\t}\n \t\t\t\tEMIT2(jmp_cond, jmp_offset);\n \t\t\t} else if (is_simm32(jmp_offset)) {\n \t\t\t\tEMIT2_off32(0x0F, jmp_cond + 0x10, jmp_offset);\n \t\t\t} else {\n \t\t\t\tpr_err(\"cond_jmp gen bug %llx\\n\", jmp_offset);\n \t\t\t\treturn -EFAULT;\n \t\t\t}\n \n \t\t\tbreak;\n \n \t\tcase BPF_JMP | BPF_JA:\n \t\t\tif (insn->off == -1)\n \t\t\t\tjmp_offset = -2;\n \t\t\telse\n \t\t\t\tjmp_offset = addrs[i + insn->off] - addrs[i];\n \n \t\t\tif (!jmp_offset) {\n \t\t\t\tif (jmp_padding) {\n \t\t\t\t\tnops = INSN_SZ_DIFF;\n \t\t\t\t\tif (nops != 0 && nops != 2 && nops != 5) {\n \t\t\t\t\t\tpr_err(\"unexpected nop jump padding: %d bytes\\n\",\n \t\t\t\t\t\t       nops);\n \t\t\t\t\t\treturn -EFAULT;\n \t\t\t\t\t}\n \t\t\t\t\tcnt += emit_nops(&prog, nops);\n \t\t\t\t}\n \t\t\t\tbreak;\n \t\t\t}\n emit_jmp:\n \t\t\tif (is_imm8(jmp_offset)) {\n \t\t\t\tif (jmp_padding) {\n \t\t\t\t\tnops = INSN_SZ_DIFF - 2;\n \t\t\t\t\tif (nops != 0 && nops != 3) {\n \t\t\t\t\t\tpr_err(\"unexpected jump padding: %d bytes\\n\",\n \t\t\t\t\t\t       nops);\n \t\t\t\t\t\treturn -EFAULT;\n \t\t\t\t\t}\n \t\t\t\t\tcnt += emit_nops(&prog, INSN_SZ_DIFF - 2);\n \t\t\t\t}\n \t\t\t\tEMIT2(0xEB, jmp_offset);\n \t\t\t} else if (is_simm32(jmp_offset)) {\n \t\t\t\tEMIT1_off32(0xE9, jmp_offset);\n \t\t\t} else {\n \t\t\t\tpr_err(\"jmp gen bug %llx\\n\", jmp_offset);\n \t\t\t\treturn -EFAULT;\n \t\t\t}\n \t\t\tbreak;\n \n \t\tcase BPF_JMP | BPF_EXIT:\n \t\t\tif (seen_exit) {\n \t\t\t\tjmp_offset = ctx->cleanup_addr - addrs[i];\n \t\t\t\tgoto emit_jmp;\n \t\t\t}\n \t\t\tseen_exit = true;\n \t\t\tctx->cleanup_addr = proglen;\n \t\t\tpop_callee_regs(&prog, callee_regs_used);\n \t\t\tEMIT1(0xC9);\n \t\t\tEMIT1(0xC3);\n \t\t\tbreak;\n \n \t\tdefault:\n \t\t\tpr_err(\"bpf_jit: unknown opcode %02x\\n\", insn->code);\n \t\t\treturn -EINVAL;\n \t\t}\n \n \t\tilen = prog - temp;\n \t\tif (ilen > BPF_MAX_INSN_SIZE) {\n \t\t\tpr_err(\"bpf_jit: fatal insn size error\\n\");\n \t\t\treturn -EFAULT;\n \t\t}\n \n \t\tif (image) {\n// bug_start\n\t\t\tif (unlikely(proglen + ilen > oldproglen)) {\n// bug_end\n \t\t\t\tpr_err(\"bpf_jit: fatal error\\n\");\n \t\t\t\treturn -EFAULT;\n \t\t\t}\n \t\t\tmemcpy(image + proglen, temp, ilen);\n \t\t}\n \t\tproglen += ilen;\n \t\taddrs[i] = proglen;\n \t\tprog = temp;\n \t}\n \n \tif (image && excnt != bpf_prog->aux->num_exentries) {\n \t\tpr_err(\"extable is not populated\\n\");\n \t\treturn -EFAULT;\n \t}\n \treturn proglen;\n }\n \n", "target": "// fix_start\n\t\t\tif (unlikely(proglen + ilen > oldproglen ||\n\t\t\t\t     proglen + ilen != addrs[i])) {\n// fix_end\n", "cwe": "CWE-77", "cwe_name": "Improper Neutralization of Special Elements used in a Command ('Command Injection')", "cve": "CVE-2021-29154", "cve_desc": "BPF JIT compilers in the Linux kernel through 5.11.12 have incorrect computation of branch displacements, allowing them to execute arbitrary code within the kernel context. This affects arch/x86/net/bpf_jit_comp.c and arch/x86/net/bpf_jit_comp32.c.", "project": "linux", "idx": 212767}
{"source": " void rsi_mac80211_detach(struct rsi_hw *adapter)\n {\n \tstruct ieee80211_hw *hw = adapter->hw;\n \tenum nl80211_band band;\n \n \tif (hw) {\n \t\tieee80211_stop_queues(hw);\n \t\tieee80211_unregister_hw(hw);\n \t\tieee80211_free_hw(hw);\n// bug_start\n// bug_end\n \t}\n \n \tfor (band = 0; band < NUM_NL80211_BANDS; band++) {\n \t\tstruct ieee80211_supported_band *sband =\n \t\t\t\t\t&adapter->sbands[band];\n \n \t\tkfree(sband->channels);\n \t}\n \n #ifdef CONFIG_RSI_DEBUGFS\n \trsi_remove_dbgfs(adapter);\n \tkfree(adapter->dfsentry);\n #endif\n }\n \n", "target": "// fix_start\n\t\tadapter->hw = NULL;\n// fix_end\n", "cwe": "CWE-416", "cwe_name": "Use After Free", "cve": "CVE-2018-21008", "cve_desc": "An issue was discovered in the Linux kernel before 4.16.7. A use-after-free can be caused by the function rsi_mac80211_detach in the file drivers/net/wireless/rsi/rsi_91x_mac80211.c.", "project": "linux", "idx": 212771}
{"source": " PHP_FUNCTION( msgfmt_parse_message )\n {\n \tUChar      *spattern = NULL;\n \tint         spattern_len = 0;\n \tchar       *pattern = NULL;\n \tsize_t      pattern_len = 0;\n \tconst char *slocale = NULL;\n \tsize_t      slocale_len = 0;\n \tchar       *source = NULL;\n \tsize_t      src_len = 0;\n \tMessageFormatter_object mf;\n \tMessageFormatter_object *mfo = &mf;\n \n \tif( zend_parse_parameters( ZEND_NUM_ARGS(), \"sss\",\n \t\t  &slocale, &slocale_len, &pattern, &pattern_len, &source, &src_len ) == FAILURE )\n \t{\n \t\tintl_error_set( NULL, U_ILLEGAL_ARGUMENT_ERROR,\n \t\t\t\"msgfmt_parse_message: unable to parse input params\", 0 );\n \n \t\tRETURN_FALSE;\n \t}\n \n// bug_start\n// bug_end\n \tmemset(mfo, 0, sizeof(*mfo));\n \tmsgformat_data_init(&mfo->mf_data);\n \n \tif(pattern && pattern_len) {\n \t\tintl_convert_utf8_to_utf16(&spattern, &spattern_len, pattern, pattern_len, &INTL_DATA_ERROR_CODE(mfo));\n \t\tif( U_FAILURE(INTL_DATA_ERROR_CODE((mfo))) )\n \t\t{\n \t\t\tintl_error_set( NULL, U_ILLEGAL_ARGUMENT_ERROR,\n \t\t\t\t\"msgfmt_parse_message: error converting pattern to UTF-16\", 0 );\n \t\t\tRETURN_FALSE;\n \t\t}\n \t} else {\n \t\tspattern_len = 0;\n \t\tspattern = NULL;\n \t}\n \n \tif(slocale_len == 0) {\n \t\tslocale = intl_locale_get_default();\n \t}\n \n #ifdef MSG_FORMAT_QUOTE_APOS\n \tif(msgformat_fix_quotes(&spattern, &spattern_len, &INTL_DATA_ERROR_CODE(mfo)) != SUCCESS) {\n \t\tintl_error_set( NULL, U_INVALID_FORMAT_ERROR,\n \t\t\t\"msgfmt_parse_message: error converting pattern to quote-friendly format\", 0 );\n \t\tRETURN_FALSE;\n \t}\n #endif\n \n \tMSG_FORMAT_OBJECT(mfo) = umsg_open(spattern, spattern_len, slocale, NULL, &INTL_DATA_ERROR_CODE(mfo));\n \tif(spattern && spattern_len) {\n \t\tefree(spattern);\n \t}\n \tINTL_METHOD_CHECK_STATUS(mfo, \"Creating message formatter failed\");\n \n \tmsgfmt_do_parse(mfo, source, src_len, return_value);\n \n \tmsgformat_data_free(&mfo->mf_data);\n }\n \n", "target": "// fix_start\n\tINTL_CHECK_LOCALE_LEN(slocale_len);\n// fix_end\n", "cwe": "CWE-119", "cwe_name": "Improper Restriction of Operations within the Bounds of a Memory Buffer", "cve": "CVE-2017-11362", "cve_desc": "In PHP 7.x before 7.0.21 and 7.1.x before 7.1.7, ext/intl/msgformat/msgformat_parse.c does not restrict the locale length, which allows remote attackers to cause a denial of service (stack-based buffer overflow and application crash) or possibly have unspecified other impact within International Components for Unicode (ICU) for C/C++ via a long first argument to the msgfmt_parse_message function.", "project": "php-src", "idx": 212820}
{"source": " writepid (const char* pidfile, pid_t pid)\n {\n// bug_start\n\tFILE* f;\n// bug_end\n \n// bug_start\n\tif ((f = fopen(pidfile, \"w\")) ==  NULL ) {\n// bug_end\n \t\tlog_err(\"cannot open pidfile %s: %s\",\n \t\t\tpidfile, strerror(errno));\n \t\treturn;\n \t}\n// bug_start\n\tif(fprintf(f, \"%lu\\n\", (unsigned long)pid) < 0) {\n\t\tlog_err(\"cannot write to pidfile %s: %s\",\n\t\t\tpidfile, strerror(errno));\n// bug_end\n \t}\n// bug_start\n\tfclose(f);\n// bug_end\n }\n \n", "target": "// fix_start\n\tint fd;\n\tchar pidbuf[32];\n\tsize_t count = 0;\n\tsnprintf(pidbuf, sizeof(pidbuf), \"%lu\\n\", (unsigned long)pid);\n// fix_end\n// fix_start\n\tif((fd = open(pidfile, O_WRONLY | O_CREAT | O_TRUNC\n#ifdef O_NOFOLLOW\n\t\t| O_NOFOLLOW\n#endif\n\t\t, 0644)) == -1) {\n// fix_end\n// fix_start\n\twhile(count < strlen(pidbuf)) {\n\t\tssize_t r = write(fd, pidbuf+count, strlen(pidbuf)-count);\n\t\tif(r == -1) {\n\t\t\tif(errno == EAGAIN || errno == EINTR)\n\t\t\t\tcontinue;\n\t\t\tlog_err(\"cannot write to pidfile %s: %s\",\n\t\t\t\tpidfile, strerror(errno));\n\t\t\tbreak;\n\t\t}\n\t\tcount += r;\n// fix_end\n// fix_start\n\tclose(fd);\n// fix_end\n", "cwe": "CWE-59", "cwe_name": "Improper Link Resolution Before File Access ('Link Following')", "cve": "CVE-2020-28935", "cve_desc": "NLnet Labs Unbound, up to and including version 1.12.0, and NLnet Labs NSD, up to and including version 4.3.3, contain a local vulnerability that would allow for a local symlink attack. When writing the PID file, Unbound and NSD create the file if it is not there, or open an existing file for writing. In case the file was already present, they would follow symlinks if the file happened to be a symlink instead of a regular file. An additional chown of the file would then take place after it was written, making the user Unbound/NSD is supposed to run as the new owner of the file. If an attacker has local access to the user Unbound/NSD runs as, she could create a symlink in place of the PID file pointing to a file that she would like to erase. If then Unbound/NSD is killed and the PID file is not cleared, upon restarting with root privileges, Unbound/NSD will rewrite any file pointed at by the symlink. This is a local vulnerability that could create a Denial of Service of the system Unbound/NSD is running on. It requires an attacker having access to the limited permission user Unbound/NSD runs as and point through the symlink to a critical file on the system.", "project": "unbound", "idx": 212821}
{"source": " static int dw_spi_transfer_one(struct spi_controller *master,\n \t\tstruct spi_device *spi, struct spi_transfer *transfer)\n {\n \tstruct dw_spi *dws = spi_controller_get_devdata(master);\n \tstruct chip_data *chip = spi_get_ctldata(spi);\n// bug_start\n// bug_end\n \tu8 imask = 0;\n \tu16 txlevel = 0;\n \tu32 cr0;\n \tint ret;\n \n \tdws->dma_mapped = 0;\n// bug_start\n\n// bug_end\n \tdws->tx = (void *)transfer->tx_buf;\n \tdws->tx_end = dws->tx + transfer->len;\n \tdws->rx = transfer->rx_buf;\n \tdws->rx_end = dws->rx + transfer->len;\n \tdws->len = transfer->len;\n// bug_start\n// bug_end\n \n \tspi_enable_chip(dws, 0);\n \n \tif (transfer->speed_hz != dws->current_freq) {\n \t\tif (transfer->speed_hz != chip->speed_hz) {\n \t\t\tchip->clk_div = (DIV_ROUND_UP(dws->max_freq, transfer->speed_hz) + 1) & 0xfffe;\n \t\t\tchip->speed_hz = transfer->speed_hz;\n \t\t}\n \t\tdws->current_freq = transfer->speed_hz;\n \t\tspi_set_clk(dws, chip->clk_div);\n \t}\n \n \tdws->n_bytes = DIV_ROUND_UP(transfer->bits_per_word, BITS_PER_BYTE);\n \tdws->dma_width = DIV_ROUND_UP(transfer->bits_per_word, BITS_PER_BYTE);\n \n \tcr0 = (transfer->bits_per_word - 1)\n \t\t| (chip->type << SPI_FRF_OFFSET)\n \t\t| ((((spi->mode & SPI_CPOL) ? 1 : 0) << SPI_SCOL_OFFSET) |\n \t\t\t(((spi->mode & SPI_CPHA) ? 1 : 0) << SPI_SCPH_OFFSET))\n \t\t| (chip->tmode << SPI_TMOD_OFFSET);\n \n \tif (chip->cs_control) {\n \t\tif (dws->rx && dws->tx)\n \t\t\tchip->tmode = SPI_TMOD_TR;\n \t\telse if (dws->rx)\n \t\t\tchip->tmode = SPI_TMOD_RO;\n \t\telse\n \t\t\tchip->tmode = SPI_TMOD_TO;\n \n \t\tcr0 &= ~SPI_TMOD_MASK;\n \t\tcr0 |= (chip->tmode << SPI_TMOD_OFFSET);\n \t}\n \n \tdw_writel(dws, DW_SPI_CTRL0, cr0);\n \n \tif (master->can_dma && master->can_dma(master, spi, transfer))\n \t\tdws->dma_mapped = master->cur_msg_mapped;\n \n \tspi_mask_intr(dws, 0xff);\n \n \tif (dws->dma_mapped) {\n \t\tret = dws->dma_ops->dma_setup(dws, transfer);\n \t\tif (ret < 0) {\n \t\t\tspi_enable_chip(dws, 1);\n \t\t\treturn ret;\n \t\t}\n \t} else if (!chip->poll_mode) {\n \t\ttxlevel = min_t(u16, dws->fifo_len / 2, dws->len / dws->n_bytes);\n \t\tdw_writel(dws, DW_SPI_TXFLTR, txlevel);\n \n \t\timask |= SPI_INT_TXEI | SPI_INT_TXOI |\n \t\t\t SPI_INT_RXUI | SPI_INT_RXOI;\n \t\tspi_umask_intr(dws, imask);\n \n \t\tdws->transfer_handler = interrupt_transfer;\n \t}\n \n \tspi_enable_chip(dws, 1);\n \n \tif (dws->dma_mapped) {\n \t\tret = dws->dma_ops->dma_transfer(dws, transfer);\n \t\tif (ret < 0)\n \t\t\treturn ret;\n \t}\n \n \tif (chip->poll_mode)\n \t\treturn poll_transfer(dws);\n \n \treturn 1;\n }\n \n", "target": "// fix_start\n\tunsigned long flags;\n// fix_end\n// fix_start\n\tspin_lock_irqsave(&dws->buf_lock, flags);\n// fix_end\n// fix_start\n\tspin_unlock_irqrestore(&dws->buf_lock, flags);\n// fix_end\n", "cwe": "CWE-662", "cwe_name": "Improper Synchronization", "cve": "CVE-2020-12769", "cve_desc": "An issue was discovered in the Linux kernel before 5.4.17. drivers/spi/spi-dw.c allows attackers to cause a panic via concurrent calls to dw_spi_irq and dw_spi_transfer_one, aka CID-19b61392c5a8.", "project": "linux", "idx": 212837}
{"source": "// bug_start\nINLINE void gdi_RectToCRgn(const HGDI_RECT rect, INT32* x, INT32* y, INT32* w, INT32* h)\n// bug_end\n {\n// bug_start\n\t*x = rect->left;\n\t*y = rect->top;\n\t*w = rect->right - rect->left + 1;\n\t*h = rect->bottom - rect->top + 1;\n// bug_end\n }\n \n", "target": "// fix_start\nINLINE void gdi_RectToRgn(HGDI_RECT rect, HGDI_RGN rgn)\n// fix_end\n// fix_start\n\trgn->x = rect->left;\n\trgn->y = rect->top;\n\trgn->w = rect->right - rect->left + 1;\n\trgn->h = rect->bottom - rect->top + 1;\n// fix_end\n", "cwe": "CWE-190", "cwe_name": "Integer Overflow or Wraparound", "cve": "CVE-2020-11523", "cve_desc": "libfreerdp/gdi/region.c in FreeRDP versions > 1.0 through 2.0.0-rc4 has an Integer Overflow.", "project": "FreeRDP", "idx": 212839}
{"source": " static const char *GetMagickPropertyLetter(const ImageInfo *image_info,\n   Image *image,const char letter)\n {\n// bug_start\n// bug_end\n   char\n     value[MaxTextExtent];\n \n   const char\n     *string;\n \n   assert(image != (Image *) NULL);\n   assert(image->signature == MagickCoreSignature);\n   if (image->debug != MagickFalse)\n     (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n   *value='\\0';\n   string=(char *) NULL;\n   switch (letter)\n   {\n     case 'b':\n     {\n       (void) FormatMagickSize(image->extent,MagickFalse,value);\n       if (image->extent == 0)\n         (void) FormatMagickSize(GetBlobSize(image),MagickFalse,value);\n       break;\n     }\n     case 'c':\n     {\n       string=GetImageProperty(image,\"comment\");\n       if (string == (const char *) NULL)\n         string=\"\";\n       break;\n     }\n     case 'd':\n     {\n       GetPathComponent(image->magick_filename,HeadPath,value);\n       if (*value == '\\0')\n         string=\"\";\n       break;\n     }\n     case 'e':\n     {\n       GetPathComponent(image->magick_filename,ExtensionPath,value);\n       if (*value == '\\0')\n         string=\"\";\n       break;\n     }\n     case 'f':\n     {\n       GetPathComponent(image->magick_filename,TailPath,value);\n       if (*value == '\\0')\n         string=\"\";\n       break;\n     }\n     case 'g':\n     {\n       (void) FormatLocaleString(value,MaxTextExtent,\"%.20gx%.20g%+.20g%+.20g\",\n         (double) image->page.width,(double) image->page.height,\n         (double) image->page.x,(double) image->page.y);\n       break;\n     }\n     case 'h':\n     {\n       (void) FormatLocaleString(value,MaxTextExtent,\"%.20g\",(double)\n         (image->rows != 0 ? image->rows : image->magick_rows));\n       break;\n     }\n     case 'i':\n     {\n       string=image->filename;\n       break;\n     }\n     case 'k':\n     {\n       (void) FormatLocaleString(value,MaxTextExtent,\"%.20g\",(double)\n         GetNumberColors(image,(FILE *) NULL,&image->exception));\n       break;\n     }\n     case 'l':\n     {\n       string=GetImageProperty(image,\"label\");\n       if (string == (const char *) NULL)\n         string=\"\";\n       break;\n     }\n     case 'm':\n     {\n       string=image->magick;\n       break;\n     }\n     case 'n':\n     {\n       (void) FormatLocaleString(value,MaxTextExtent,\"%.20g\",(double)\n         GetImageListLength(image));\n       break;\n     }\n     case 'o':\n     {\n// bug_start\n// bug_end\n       string=image_info->filename;\n       break;\n     }\n     case 'p':\n     {\n       (void) FormatLocaleString(value,MaxTextExtent,\"%.20g\",(double)\n         GetImageIndexInList(image));\n       break;\n     }\n     case 'q':\n     {\n       (void) FormatLocaleString(value,MaxTextExtent,\"%.20g\",(double)\n         MAGICKCORE_QUANTUM_DEPTH);\n       break;\n     }\n     case 'r':\n     {\n       ColorspaceType\n         colorspace;\n \n       colorspace=image->colorspace;\n       if ((image->columns != 0) && (image->rows != 0) &&\n           (SetImageGray(image,&image->exception) != MagickFalse))\n         colorspace=GRAYColorspace;\n       (void) FormatLocaleString(value,MaxTextExtent,\"%s %s %s\",\n         CommandOptionToMnemonic(MagickClassOptions,(ssize_t)\n         image->storage_class),CommandOptionToMnemonic(MagickColorspaceOptions,\n         (ssize_t) colorspace),image->matte != MagickFalse ? \"Matte\" : \"\" );\n       break;\n     }\n     case 's':\n     {\n// bug_start\n// bug_end\n       if (image_info->number_scenes != 0)\n         (void) FormatLocaleString(value,MaxTextExtent,\"%.20g\",(double)\n           image_info->scene);\n       else\n         (void) FormatLocaleString(value,MaxTextExtent,\"%.20g\",(double)\n           image->scene);\n       break;\n     }\n     case 't':\n     {\n       GetPathComponent(image->magick_filename,BasePath,value);\n       break;\n     }\n     case 'u':\n     {\n// bug_start\n// bug_end\n       string=image_info->unique;\n       break;\n     }\n     case 'w':\n     {\n       (void) FormatLocaleString(value,MaxTextExtent,\"%.20g\",(double)\n         (image->columns != 0 ? image->columns : image->magick_columns));\n       break;\n     }\n     case 'x':\n     {\n       (void) FormatLocaleString(value,MaxTextExtent,\"%.20g\",\n         fabs(image->x_resolution) > MagickEpsilon ? image->x_resolution : 72.0);\n       break;\n     }\n     case 'y':\n     {\n       (void) FormatLocaleString(value,MaxTextExtent,\"%.20g\",\n         fabs(image->y_resolution) > MagickEpsilon ? image->y_resolution : 72.0);\n       break;\n     }\n     case 'z':\n     {\n       (void) FormatLocaleString(value,MaxTextExtent,\"%.20g\",(double)\n         image->depth);\n       break;\n     }\n     case 'A':\n     {\n       (void) FormatLocaleString(value,MaxTextExtent,\"%s\",\n          CommandOptionToMnemonic(MagickBooleanOptions,(ssize_t) image->matte));\n       break;\n     }\n     case 'B':\n     {\n       (void) FormatLocaleString(value,MaxTextExtent,\"%.20g\",(double)\n         image->extent);\n       if (image->extent == 0)\n         (void) FormatLocaleString(value,MaxTextExtent,\"%.20g\",(double)\n           GetBlobSize(image));\n       break;\n     }\n     case 'C':\n     {\n       (void) FormatLocaleString(value,MaxTextExtent,\"%s\",\n         CommandOptionToMnemonic(MagickCompressOptions,(ssize_t)\n           image->compression));\n       break;\n     }\n     case 'D':\n     {\n       (void) FormatLocaleString(value,MaxTextExtent,\"%s\",\n         CommandOptionToMnemonic(MagickDisposeOptions,(ssize_t) image->dispose));\n       break;\n     }\n     case 'F':\n     {\n       const char\n         *q;\n \n       register char\n         *p;\n \n       static char\n         whitelist[] =\n           \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789 \"\n           \"$-_.+!*'(),{}|\\\\^~[]`\\\"><#%;/?:@&=\";\n \n       (void) CopyMagickString(value,image->magick_filename,MaxTextExtent);\n       p=value;\n       q=value+strlen(value);\n       for (p+=strspn(p,whitelist); p != q; p+=strspn(p,whitelist))\n         *p='_';\n       break;\n     }\n     case 'G':\n     {\n       (void) FormatLocaleString(value,MaxTextExtent,\"%.20gx%.20g\",(double)\n         image->magick_columns,(double) image->magick_rows);\n       break;\n     }\n     case 'H':\n     {\n       (void) FormatLocaleString(value,MaxTextExtent,\"%.20g\",(double)\n         image->page.height);\n       break;\n     }\n     case 'M':\n     {\n       string=image->magick_filename;\n       break;\n     }\n     case 'O':\n     {\n       (void) FormatLocaleString(value,MaxTextExtent,\"%+ld%+ld\",(long)\n         image->page.x,(long) image->page.y);\n       break;\n     }\n     case 'P':\n     {\n       (void) FormatLocaleString(value,MaxTextExtent,\"%.20gx%.20g\",(double)\n         image->page.width,(double) image->page.height);\n       break;\n     }\n     case 'Q':\n     {\n       (void) FormatLocaleString(value,MaxTextExtent,\"%.20g\",(double)\n         (image->quality == 0 ? 92 : image->quality));\n       break;\n     }\n     case 'S':\n     {\n// bug_start\n// bug_end\n       if (image_info->number_scenes == 0)\n         string=\"2147483647\";\n       else\n         (void) FormatLocaleString(value,MaxTextExtent,\"%.20g\",(double)\n           image_info->scene+image_info->number_scenes);\n       break;\n     }\n     case 'T':\n     {\n       (void) FormatLocaleString(value,MaxTextExtent,\"%.20g\",(double)\n         image->delay);\n       break;\n     }\n     case 'U':\n     {\n       (void) FormatLocaleString(value,MaxTextExtent,\"%s\",\n         CommandOptionToMnemonic(MagickResolutionOptions,(ssize_t)\n           image->units));\n       break;\n     }\n     case 'W':\n     {\n       (void) FormatLocaleString(value,MaxTextExtent,\"%.20g\",(double)\n         image->page.width);\n       break;\n     }\n     case 'X':\n     {\n       (void) FormatLocaleString(value,MaxTextExtent,\"%+.20g\",(double)\n         image->page.x);\n       break;\n     }\n     case 'Y':\n     {\n       (void) FormatLocaleString(value,MaxTextExtent,\"%+.20g\",(double)\n         image->page.y);\n       break;\n     }\n     case 'Z':\n     {\n// bug_start\n// bug_end\n       string=image_info->zero;\n       break;\n     }\n     case '@':\n     {\n       RectangleInfo\n         page;\n \n       page=GetImageBoundingBox(image,&image->exception);\n       (void) FormatLocaleString(value,MaxTextExtent,\"%.20gx%.20g%+.20g%+.20g\",\n         (double) page.width,(double) page.height,(double) page.x,(double)\n         page.y);\n       break;\n     }\n     case '#':\n     {\n       if ((image->columns != 0) && (image->rows != 0))\n         (void) SignatureImage(image);\n       string=GetImageProperty(image,\"signature\");\n       break;\n     }\n     case '%':\n     {\n       string=\"%\";\n       break;\n     }\n   }\n   if (*value != '\\0')\n     string=value;\n   if (string != (char *) NULL)\n     {\n       (void) SetImageArtifact(image,\"get-property\",string);\n       return(GetImageArtifact(image,\"get-property\"));\n     }\n   return((char *) NULL);\n }\n \n", "target": "// fix_start\n#define WarnNoImageInfoReturn(format,arg) \\\n  if (image_info == (ImageInfo *) NULL ) { \\\n    (void) ThrowMagickException(&image->exception,GetMagickModule(), \\\n      OptionWarning,\"NoImageInfoForProperty\",format,arg); \\\n    return((const char *) NULL); \\\n  }\n\n// fix_end\n// fix_start\n      WarnNoImageInfoReturn(\"\\\"%%%c\\\"\",letter);\n// fix_end\n// fix_start\n      WarnNoImageInfoReturn(\"\\\"%%%c\\\"\",letter);\n// fix_end\n// fix_start\n      WarnNoImageInfoReturn(\"\\\"%%%c\\\"\",letter);\n// fix_end\n// fix_start\n      WarnNoImageInfoReturn(\"\\\"%%%c\\\"\",letter);\n// fix_end\n// fix_start\n      WarnNoImageInfoReturn(\"\\\"%%%c\\\"\",letter);\n// fix_end\n", "cwe": "CWE-476", "cwe_name": "NULL Pointer Dereference", "cve": "CVE-2018-16329", "cve_desc": "In ImageMagick before 7.0.8-8, a NULL pointer dereference exists in the GetMagickProperty function in MagickCore/property.c.", "project": "ImageMagick6", "idx": 212909}
{"source": " formUpdateBuffer(Anchor *a, Buffer *buf, FormItemList *form)\n {\n     Buffer save;\n     char *p;\n     int spos, epos, rows, c_rows, pos, col = 0;\n     Line *l;\n \n     copyBuffer(&save, buf);\n     gotoLine(buf, a->start.line);\n     switch (form->type) {\n     case FORM_TEXTAREA:\n     case FORM_INPUT_TEXT:\n     case FORM_INPUT_FILE:\n     case FORM_INPUT_PASSWORD:\n     case FORM_INPUT_CHECKBOX:\n     case FORM_INPUT_RADIO:\n #ifdef MENU_SELECT\n     case FORM_SELECT:\n #endif\n \tspos = a->start.pos;\n \tepos = a->end.pos;\n \tbreak;\n     default:\n \tspos = a->start.pos + 1;\n \tepos = a->end.pos - 1;\n     }\n     switch (form->type) {\n     case FORM_INPUT_CHECKBOX:\n     case FORM_INPUT_RADIO:\n// bug_start\n\tif (spos >= buf->currentLine->len || spos < 0)\n// bug_end\n \t    break;\n \tif (form->checked)\n \t    buf->currentLine->lineBuf[spos] = '*';\n \telse\n \t    buf->currentLine->lineBuf[spos] = ' ';\n \tbreak;\n     case FORM_INPUT_TEXT:\n     case FORM_INPUT_FILE:\n     case FORM_INPUT_PASSWORD:\n     case FORM_TEXTAREA:\n #ifdef MENU_SELECT\n     case FORM_SELECT:\n \tif (form->type == FORM_SELECT) {\n \t    p = form->label->ptr;\n \t    updateSelectOption(form, form->select_option);\n \t}\n \telse\n #endif\n \t{\n \t    if (!form->value)\n \t\tbreak;\n \t    p = form->value->ptr;\n \t}\n \tl = buf->currentLine;\n \tif (!l)\n \t    break;\n \tif (form->type == FORM_TEXTAREA) {\n \t    int n = a->y - buf->currentLine->linenumber;\n \t    if (n > 0)\n \t\tfor (; l && n; l = l->prev, n--) ;\n \t    else if (n < 0)\n \t\tfor (; l && n; l = l->prev, n++) ;\n \t    if (!l)\n \t\tbreak;\n \t}\n \trows = form->rows ? form->rows : 1;\n \tcol = COLPOS(l, a->start.pos);\n \tfor (c_rows = 0; c_rows < rows; c_rows++, l = l->next) {\n \t    if (rows > 1) {\n \t\tpos = columnPos(l, col);\n \t\ta = retrieveAnchor(buf->formitem, l->linenumber, pos);\n \t\tif (a == NULL)\n \t\t    break;\n \t\tspos = a->start.pos;\n \t\tepos = a->end.pos;\n \t    }\n \t    if (a->start.line != a->end.line || spos > epos || epos >= l->len || spos < 0 || epos < 0)\n \t\tbreak;\n \t    pos = form_update_line(l, &p, spos, epos, COLPOS(l, epos) - col,\n \t\t\t\t   rows > 1,\n \t\t\t\t   form->type == FORM_INPUT_PASSWORD);\n \t    if (pos != epos) {\n \t\tshiftAnchorPosition(buf->href, buf->hmarklist,\n \t\t\t\t    a->start.line, spos, pos - epos);\n \t\tshiftAnchorPosition(buf->name, buf->hmarklist,\n \t\t\t\t    a->start.line, spos, pos - epos);\n \t\tshiftAnchorPosition(buf->img, buf->hmarklist,\n \t\t\t\t    a->start.line, spos, pos - epos);\n \t\tshiftAnchorPosition(buf->formitem, buf->hmarklist,\n \t\t\t\t    a->start.line, spos, pos - epos);\n \t    }\n \t}\n \tbreak;\n     }\n     copyBuffer(buf, &save);\n     arrangeLine(buf);\n }\n \n", "target": "// fix_start\n\tif (buf->currentLine == NULL ||\n\t    spos >= buf->currentLine->len || spos < 0)\n// fix_end\n", "cwe": "CWE-476", "cwe_name": "NULL Pointer Dereference", "cve": "CVE-2016-9624", "cve_desc": "An issue was discovered in the Tatsuya Kinoshita w3m fork before 0.5.3-33. w3m allows remote attackers to cause a denial of service (segmentation fault and crash) via a crafted HTML page.", "project": "w3m", "idx": 212915}
{"source": " static void ttm_put_pages(struct page **pages, unsigned npages, int flags,\n \t\t\t  enum ttm_caching_state cstate)\n {\n \tstruct ttm_page_pool *pool = ttm_get_pool(flags, false, cstate);\n #ifdef CONFIG_TRANSPARENT_HUGEPAGE\n \tstruct ttm_page_pool *huge = ttm_get_pool(flags, true, cstate);\n #endif\n \tunsigned long irq_flags;\n \tunsigned i;\n \n \tif (pool == NULL) {\n \t\ti = 0;\n \t\twhile (i < npages) {\n #ifdef CONFIG_TRANSPARENT_HUGEPAGE\n \t\t\tstruct page *p = pages[i];\n #endif\n \t\t\tunsigned order = 0, j;\n \n \t\t\tif (!pages[i]) {\n \t\t\t\t++i;\n \t\t\t\tcontinue;\n \t\t\t}\n \n #ifdef CONFIG_TRANSPARENT_HUGEPAGE\n \t\t\tif (!(flags & TTM_PAGE_FLAG_DMA32) &&\n \t\t\t    (npages - i) >= HPAGE_PMD_NR) {\n \t\t\t\tfor (j = 1; j < HPAGE_PMD_NR; ++j)\n// bug_start\n\t\t\t\t\tif (p++ != pages[i + j])\n// bug_end\n \t\t\t\t\t    break;\n \n \t\t\t\tif (j == HPAGE_PMD_NR)\n \t\t\t\t\torder = HPAGE_PMD_ORDER;\n \t\t\t}\n #endif\n \n \t\t\tif (page_count(pages[i]) != 1)\n \t\t\t\tpr_err(\"Erroneous page count. Leaking pages.\\n\");\n \t\t\t__free_pages(pages[i], order);\n \n \t\t\tj = 1 << order;\n \t\t\twhile (j) {\n \t\t\t\tpages[i++] = NULL;\n \t\t\t\t--j;\n \t\t\t}\n \t\t}\n \t\treturn;\n \t}\n \n \ti = 0;\n #ifdef CONFIG_TRANSPARENT_HUGEPAGE\n \tif (huge) {\n \t\tunsigned max_size, n2free;\n \n \t\tspin_lock_irqsave(&huge->lock, irq_flags);\n \t\twhile ((npages - i) >= HPAGE_PMD_NR) {\n \t\t\tstruct page *p = pages[i];\n \t\t\tunsigned j;\n \n \t\t\tif (!p)\n \t\t\t\tbreak;\n \n \t\t\tfor (j = 1; j < HPAGE_PMD_NR; ++j)\n// bug_start\n\t\t\t\tif (p++ != pages[i + j])\n// bug_end\n \t\t\t\t    break;\n \n \t\t\tif (j != HPAGE_PMD_NR)\n \t\t\t\tbreak;\n \n \t\t\tlist_add_tail(&pages[i]->lru, &huge->list);\n \n \t\t\tfor (j = 0; j < HPAGE_PMD_NR; ++j)\n \t\t\t\tpages[i++] = NULL;\n \t\t\thuge->npages++;\n \t\t}\n \n \t\tmax_size = _manager->options.max_size;\n \t\tmax_size /= HPAGE_PMD_NR;\n \t\tif (huge->npages > max_size)\n \t\t\tn2free = huge->npages - max_size;\n \t\telse\n \t\t\tn2free = 0;\n \t\tspin_unlock_irqrestore(&huge->lock, irq_flags);\n \t\tif (n2free)\n \t\t\tttm_page_pool_free(huge, n2free, false);\n \t}\n #endif\n \n \tspin_lock_irqsave(&pool->lock, irq_flags);\n \twhile (i < npages) {\n \t\tif (pages[i]) {\n \t\t\tif (page_count(pages[i]) != 1)\n \t\t\t\tpr_err(\"Erroneous page count. Leaking pages.\\n\");\n \t\t\tlist_add_tail(&pages[i]->lru, &pool->list);\n \t\t\tpages[i] = NULL;\n \t\t\tpool->npages++;\n \t\t}\n \t\t++i;\n \t}\n \tnpages = 0;\n \tif (pool->npages > _manager->options.max_size) {\n \t\tnpages = pool->npages - _manager->options.max_size;\n \t\tif (npages < NUM_PAGES_TO_ALLOC)\n \t\t\tnpages = NUM_PAGES_TO_ALLOC;\n \t}\n \tspin_unlock_irqrestore(&pool->lock, irq_flags);\n \tif (npages)\n \t\tttm_page_pool_free(pool, npages, false);\n }\n \n", "target": "// fix_start\n\t\t\t\t\tif (++p != pages[i + j])\n// fix_end\n// fix_start\n\t\t\t\tif (++p != pages[i + j])\n// fix_end\n", "cwe": "CWE-125", "cwe_name": "Out-of-bounds Read", "cve": "CVE-2019-19927", "cve_desc": "In the Linux kernel 5.0.0-rc7 (as distributed in ubuntu/linux.git on kernel.ubuntu.com), mounting a crafted f2fs filesystem image and performing some operations can lead to slab-out-of-bounds read access in ttm_put_pages in drivers/gpu/drm/ttm/ttm_page_alloc.c. This is related to the vmwgfx or ttm module.", "project": "linux", "idx": 212944}
{"source": " ciphertext_to_compressed (gnutls_session_t session,\n                           gnutls_datum_t *ciphertext,\n                           uint8_t * compress_data,\n                           int compress_size,\n                           uint8_t type, record_parameters_st * params,\n                           uint64* sequence)\n {\n   uint8_t tag[MAX_HASH_SIZE];\n   uint8_t pad;\n   int length, length_to_decrypt;\n   uint16_t blocksize;\n   int ret, i, pad_failed = 0;\n   uint8_t preamble[MAX_PREAMBLE_SIZE];\n   unsigned int preamble_size;\n   unsigned int ver = gnutls_protocol_get_version (session);\n   unsigned int tag_size = _gnutls_auth_cipher_tag_len (&params->read.cipher_state);\n   unsigned int explicit_iv = _gnutls_version_has_explicit_iv (session->security_parameters.version);\n \n   blocksize = gnutls_cipher_get_block_size (params->cipher_algorithm);\n \n   switch (_gnutls_cipher_is_block (params->cipher_algorithm))\n     {\n     case CIPHER_STREAM:\n       if (explicit_iv && _gnutls_auth_cipher_is_aead(&params->read.cipher_state))\n         {\n           uint8_t nonce[blocksize];\n           if (params->read.IV.data == NULL || params->read.IV.size != 4)\n             return gnutls_assert_val(GNUTLS_E_INTERNAL_ERROR);\n \n           if (ciphertext->size < tag_size+AEAD_EXPLICIT_DATA_SIZE)\n             return gnutls_assert_val(GNUTLS_E_UNEXPECTED_PACKET_LENGTH);\n \n           memcpy(nonce, params->read.IV.data, AEAD_IMPLICIT_DATA_SIZE);\n           memcpy(&nonce[AEAD_IMPLICIT_DATA_SIZE], ciphertext->data, AEAD_EXPLICIT_DATA_SIZE);\n \n           _gnutls_auth_cipher_setiv(&params->read.cipher_state, nonce, AEAD_EXPLICIT_DATA_SIZE+AEAD_IMPLICIT_DATA_SIZE);\n \n           ciphertext->data += AEAD_EXPLICIT_DATA_SIZE;\n           ciphertext->size -= AEAD_EXPLICIT_DATA_SIZE;\n \n           length_to_decrypt = ciphertext->size - tag_size;\n         }\n       else\n         {\n           if (ciphertext->size < tag_size)\n             return gnutls_assert_val(GNUTLS_E_UNEXPECTED_PACKET_LENGTH);\n \n           length_to_decrypt = ciphertext->size;\n         }\n \n       length = ciphertext->size - tag_size;\n \n       preamble_size =\n         make_preamble (UINT64DATA(*sequence), type,\n                        length, ver, preamble);\n \n       ret = _gnutls_auth_cipher_add_auth (&params->read.cipher_state, preamble, preamble_size);\n       if (ret < 0)\n         return gnutls_assert_val(ret);\n \n       if ((ret =\n            _gnutls_auth_cipher_decrypt2 (&params->read.cipher_state,\n              ciphertext->data, length_to_decrypt,\n              ciphertext->data, ciphertext->size)) < 0)\n         return gnutls_assert_val(ret);\n \n       break;\n     case CIPHER_BLOCK:\n// bug_start\n      if (ciphertext->size < MAX(blocksize, tag_size) || (ciphertext->size % blocksize != 0))\n// bug_end\n         return gnutls_assert_val(GNUTLS_E_UNEXPECTED_PACKET_LENGTH);\n \n       if (explicit_iv)\n         {\n           _gnutls_auth_cipher_setiv(&params->read.cipher_state,\n             ciphertext->data, blocksize);\n \n           ciphertext->size -= blocksize;\n           ciphertext->data += blocksize;\n// bug_start\n// bug_end\n \n// bug_start\n          if (ciphertext->size == 0)\n            {\n              gnutls_assert ();\n              return GNUTLS_E_DECRYPTION_FAILED;\n            }\n        }\n// bug_end\n \n       if ((ret =\n            _gnutls_cipher_decrypt (&params->read.cipher_state.cipher,\n              ciphertext->data, ciphertext->size)) < 0)\n         return gnutls_assert_val(ret);\n \n       pad = ciphertext->data[ciphertext->size - 1] + 1;\n// bug_start\n// bug_end\n \n       if ((int) pad > (int) ciphertext->size - tag_size)\n         {\n           gnutls_assert ();\n           _gnutls_record_log\n             (\"REC[%p]: Short record length %d > %d - %d (under attack?)\\n\",\n              session, pad, ciphertext->size, tag_size);\n           pad_failed = GNUTLS_E_DECRYPTION_FAILED;\n           pad %= blocksize;\n         }\n \n       length = ciphertext->size - tag_size - pad;\n \n       if (ver != GNUTLS_SSL3)\n         for (i = 2; i < pad; i++)\n           {\n             if (ciphertext->data[ciphertext->size - i] !=\n                 ciphertext->data[ciphertext->size - 1])\n               pad_failed = GNUTLS_E_DECRYPTION_FAILED;\n           }\n \n       if (length < 0)\n         {\n           length = ciphertext->size - tag_size;\n         }\n \n       preamble_size =\n         make_preamble (UINT64DATA(*sequence), type,\n                        length, ver, preamble);\n       ret = _gnutls_auth_cipher_add_auth (&params->read.cipher_state, preamble, preamble_size);\n       if (ret < 0)\n         return gnutls_assert_val(ret);\n \n       ret = _gnutls_auth_cipher_add_auth (&params->read.cipher_state, ciphertext->data, length);\n       if (ret < 0)\n         return gnutls_assert_val(ret);\n \n       break;\n     default:\n       return gnutls_assert_val(GNUTLS_E_INTERNAL_ERROR);\n     }\n \n   ret = _gnutls_auth_cipher_tag(&params->read.cipher_state, tag, tag_size);\n   if (ret < 0)\n     return gnutls_assert_val(ret);\n \n   if (memcmp (tag, &ciphertext->data[length], tag_size) != 0 || pad_failed != 0)\n     return gnutls_assert_val(GNUTLS_E_DECRYPTION_FAILED);\n \n   if (compress_size < length)\n     return gnutls_assert_val(GNUTLS_E_DECOMPRESSION_FAILED);\n \n   if (compress_data != ciphertext->data)\n     memcpy (compress_data, ciphertext->data, length);\n \n   return length;\n }\n \n", "target": "// fix_start\n      if (ciphertext->size < blocksize || (ciphertext->size % blocksize != 0))\n// fix_end\n// fix_start\n        }\n// fix_end\n// fix_start\n      if (ciphertext->size < tag_size)\n        return gnutls_assert_val(GNUTLS_E_DECRYPTION_FAILED);\n// fix_end\n// fix_start\n\n// fix_end\n", "cwe": "CWE-310", "cwe_name": "Cryptographic Issues", "cve": "CVE-2012-1573", "cve_desc": "gnutls_cipher.c in libgnutls in GnuTLS before 2.12.17 and 3.x before 3.0.15 does not properly handle data encrypted with a block cipher, which allows remote attackers to cause a denial of service (heap memory corruption and application crash) via a crafted record, as demonstrated by a crafted GenericBlockCipher structure.", "project": "gnutls", "idx": 213025}
{"source": " table_regex_match(const char *string, const char *pattern)\n {\n \tregex_t preg;\n \tint\tcflags = REG_EXTENDED|REG_NOSUB;\n// bug_start\n// bug_end\n \n \tif (strncmp(pattern, \"(?i)\", 4) == 0) {\n \t\tcflags |= REG_ICASE;\n \t\tpattern += 4;\n \t}\n \n \tif (regcomp(&preg, pattern, cflags) != 0)\n \t\treturn (0);\n \n// bug_start\n\tif (regexec(&preg, string, 0, NULL, 0) != 0)\n// bug_end\n \t\treturn (0);\n \n \treturn (1);\n }\n \n", "target": "// fix_start\n\tint ret;\n// fix_end\n// fix_start\n\tret = regexec(&preg, string, 0, NULL, 0);\n\n\tregfree(&preg);\n\n\tif (ret != 0)\n// fix_end\n", "cwe": "CWE-401", "cwe_name": "Missing Release of Memory after Effective Lifetime", "cve": "CVE-2020-35679", "cve_desc": "smtpd/table.c in OpenSMTPD before 6.8.0p1 lacks a certain regfree, which might allow attackers to trigger a \"very significant\" memory leak via messages to an instance that performs many regex lookups.", "project": "src", "idx": 213469}
{"source": " static int __ip_append_data(struct sock *sk,\n \t\t\t    struct flowi4 *fl4,\n \t\t\t    struct sk_buff_head *queue,\n \t\t\t    struct inet_cork *cork,\n \t\t\t    struct page_frag *pfrag,\n \t\t\t    int getfrag(void *from, char *to, int offset,\n \t\t\t\t\tint len, int odd, struct sk_buff *skb),\n \t\t\t    void *from, int length, int transhdrlen,\n \t\t\t    unsigned int flags)\n {\n \tstruct inet_sock *inet = inet_sk(sk);\n \tstruct sk_buff *skb;\n \n \tstruct ip_options *opt = cork->opt;\n \tint hh_len;\n \tint exthdrlen;\n \tint mtu;\n \tint copy;\n \tint err;\n \tint offset = 0;\n \tunsigned int maxfraglen, fragheaderlen, maxnonfragsize;\n \tint csummode = CHECKSUM_NONE;\n \tstruct rtable *rt = (struct rtable *)cork->dst;\n \tu32 tskey = 0;\n \n \tskb = skb_peek_tail(queue);\n \n \texthdrlen = !skb ? rt->dst.header_len : 0;\n \tmtu = cork->fragsize;\n \tif (cork->tx_flags & SKBTX_ANY_SW_TSTAMP &&\n \t    sk->sk_tsflags & SOF_TIMESTAMPING_OPT_ID)\n \t\ttskey = sk->sk_tskey++;\n \n \thh_len = LL_RESERVED_SPACE(rt->dst.dev);\n \n \tfragheaderlen = sizeof(struct iphdr) + (opt ? opt->optlen : 0);\n \tmaxfraglen = ((mtu - fragheaderlen) & ~7) + fragheaderlen;\n \tmaxnonfragsize = ip_sk_ignore_df(sk) ? 0xFFFF : mtu;\n \n \tif (cork->length + length > maxnonfragsize - fragheaderlen) {\n \t\tip_local_error(sk, EMSGSIZE, fl4->daddr, inet->inet_dport,\n \t\t\t       mtu - (opt ? opt->optlen : 0));\n \t\treturn -EMSGSIZE;\n \t}\n \n \tif (transhdrlen &&\n \t    length + fragheaderlen <= mtu &&\n \t    rt->dst.dev->features & (NETIF_F_HW_CSUM | NETIF_F_IP_CSUM) &&\n \t    !(flags & MSG_MORE) &&\n \t    !exthdrlen)\n \t\tcsummode = CHECKSUM_PARTIAL;\n \n \tcork->length += length;\n// bug_start\n\tif ((((length + (skb ? skb->len : fragheaderlen)) > mtu) ||\n\t     (skb && skb_is_gso(skb))) &&\n// bug_end\n \t    (sk->sk_protocol == IPPROTO_UDP) &&\n \t    (rt->dst.dev->features & NETIF_F_UFO) && !dst_xfrm(&rt->dst) &&\n// bug_start\n\t    (sk->sk_type == SOCK_DGRAM) && !sk->sk_no_check_tx) {\n// bug_end\n \t\terr = ip_ufo_append_data(sk, queue, getfrag, from, length,\n \t\t\t\t\t hh_len, fragheaderlen, transhdrlen,\n \t\t\t\t\t maxfraglen, flags);\n \t\tif (err)\n \t\t\tgoto error;\n \t\treturn 0;\n \t}\n \n \n \tif (!skb)\n \t\tgoto alloc_new_skb;\n \n \twhile (length > 0) {\n \t\tcopy = mtu - skb->len;\n \t\tif (copy < length)\n \t\t\tcopy = maxfraglen - skb->len;\n \t\tif (copy <= 0) {\n \t\t\tchar *data;\n \t\t\tunsigned int datalen;\n \t\t\tunsigned int fraglen;\n \t\t\tunsigned int fraggap;\n \t\t\tunsigned int alloclen;\n \t\t\tstruct sk_buff *skb_prev;\n alloc_new_skb:\n \t\t\tskb_prev = skb;\n \t\t\tif (skb_prev)\n \t\t\t\tfraggap = skb_prev->len - maxfraglen;\n \t\t\telse\n \t\t\t\tfraggap = 0;\n \n \t\t\tdatalen = length + fraggap;\n \t\t\tif (datalen > mtu - fragheaderlen)\n \t\t\t\tdatalen = maxfraglen - fragheaderlen;\n \t\t\tfraglen = datalen + fragheaderlen;\n \n \t\t\tif ((flags & MSG_MORE) &&\n \t\t\t    !(rt->dst.dev->features&NETIF_F_SG))\n \t\t\t\talloclen = mtu;\n \t\t\telse\n \t\t\t\talloclen = fraglen;\n \n \t\t\talloclen += exthdrlen;\n \n \t\t\tif (datalen == length + fraggap)\n \t\t\t\talloclen += rt->dst.trailer_len;\n \n \t\t\tif (transhdrlen) {\n \t\t\t\tskb = sock_alloc_send_skb(sk,\n \t\t\t\t\t\talloclen + hh_len + 15,\n \t\t\t\t\t\t(flags & MSG_DONTWAIT), &err);\n \t\t\t} else {\n \t\t\t\tskb = NULL;\n \t\t\t\tif (refcount_read(&sk->sk_wmem_alloc) <=\n \t\t\t\t    2 * sk->sk_sndbuf)\n \t\t\t\t\tskb = sock_wmalloc(sk,\n \t\t\t\t\t\t\t   alloclen + hh_len + 15, 1,\n \t\t\t\t\t\t\t   sk->sk_allocation);\n \t\t\t\tif (unlikely(!skb))\n \t\t\t\t\terr = -ENOBUFS;\n \t\t\t}\n \t\t\tif (!skb)\n \t\t\t\tgoto error;\n \n \t\t\tskb->ip_summed = csummode;\n \t\t\tskb->csum = 0;\n \t\t\tskb_reserve(skb, hh_len);\n \n \t\t\tskb_shinfo(skb)->tx_flags = cork->tx_flags;\n \t\t\tcork->tx_flags = 0;\n \t\t\tskb_shinfo(skb)->tskey = tskey;\n \t\t\ttskey = 0;\n \n \t\t\tdata = skb_put(skb, fraglen + exthdrlen);\n \t\t\tskb_set_network_header(skb, exthdrlen);\n \t\t\tskb->transport_header = (skb->network_header +\n \t\t\t\t\t\t fragheaderlen);\n \t\t\tdata += fragheaderlen + exthdrlen;\n \n \t\t\tif (fraggap) {\n \t\t\t\tskb->csum = skb_copy_and_csum_bits(\n \t\t\t\t\tskb_prev, maxfraglen,\n \t\t\t\t\tdata + transhdrlen, fraggap, 0);\n \t\t\t\tskb_prev->csum = csum_sub(skb_prev->csum,\n \t\t\t\t\t\t\t  skb->csum);\n \t\t\t\tdata += fraggap;\n \t\t\t\tpskb_trim_unique(skb_prev, maxfraglen);\n \t\t\t}\n \n \t\t\tcopy = datalen - transhdrlen - fraggap;\n \t\t\tif (copy > 0 && getfrag(from, data + transhdrlen, offset, copy, fraggap, skb) < 0) {\n \t\t\t\terr = -EFAULT;\n \t\t\t\tkfree_skb(skb);\n \t\t\t\tgoto error;\n \t\t\t}\n \n \t\t\toffset += copy;\n \t\t\tlength -= datalen - fraggap;\n \t\t\ttranshdrlen = 0;\n \t\t\texthdrlen = 0;\n \t\t\tcsummode = CHECKSUM_NONE;\n \n \t\t\tif ((flags & MSG_CONFIRM) && !skb_prev)\n \t\t\t\tskb_set_dst_pending_confirm(skb, 1);\n \n \t\t\t__skb_queue_tail(queue, skb);\n \t\t\tcontinue;\n \t\t}\n \n \t\tif (copy > length)\n \t\t\tcopy = length;\n \n \t\tif (!(rt->dst.dev->features&NETIF_F_SG)) {\n \t\t\tunsigned int off;\n \n \t\t\toff = skb->len;\n \t\t\tif (getfrag(from, skb_put(skb, copy),\n \t\t\t\t\toffset, copy, off, skb) < 0) {\n \t\t\t\t__skb_trim(skb, off);\n \t\t\t\terr = -EFAULT;\n \t\t\t\tgoto error;\n \t\t\t}\n \t\t} else {\n \t\t\tint i = skb_shinfo(skb)->nr_frags;\n \n \t\t\terr = -ENOMEM;\n \t\t\tif (!sk_page_frag_refill(sk, pfrag))\n \t\t\t\tgoto error;\n \n \t\t\tif (!skb_can_coalesce(skb, i, pfrag->page,\n \t\t\t\t\t      pfrag->offset)) {\n \t\t\t\terr = -EMSGSIZE;\n \t\t\t\tif (i == MAX_SKB_FRAGS)\n \t\t\t\t\tgoto error;\n \n \t\t\t\t__skb_fill_page_desc(skb, i, pfrag->page,\n \t\t\t\t\t\t     pfrag->offset, 0);\n \t\t\t\tskb_shinfo(skb)->nr_frags = ++i;\n \t\t\t\tget_page(pfrag->page);\n \t\t\t}\n \t\t\tcopy = min_t(int, copy, pfrag->size - pfrag->offset);\n \t\t\tif (getfrag(from,\n \t\t\t\t    page_address(pfrag->page) + pfrag->offset,\n \t\t\t\t    offset, copy, skb->len, skb) < 0)\n \t\t\t\tgoto error_efault;\n \n \t\t\tpfrag->offset += copy;\n \t\t\tskb_frag_size_add(&skb_shinfo(skb)->frags[i - 1], copy);\n \t\t\tskb->len += copy;\n \t\t\tskb->data_len += copy;\n \t\t\tskb->truesize += copy;\n \t\t\trefcount_add(copy, &sk->sk_wmem_alloc);\n \t\t}\n \t\toffset += copy;\n \t\tlength -= copy;\n \t}\n \n \treturn 0;\n \n error_efault:\n \terr = -EFAULT;\n error:\n \tcork->length -= length;\n \tIP_INC_STATS(sock_net(sk), IPSTATS_MIB_OUTDISCARDS);\n \treturn err;\n }\n \n", "target": "// fix_start\n\tif ((skb && skb_is_gso(skb)) ||\n\t    (((length + (skb ? skb->len : fragheaderlen)) > mtu) &&\n\t    (skb_queue_len(queue) <= 1) &&\n// fix_end\n// fix_start\n\t    (sk->sk_type == SOCK_DGRAM) && !sk->sk_no_check_tx)) {\n// fix_end\n", "cwe": "CWE-362", "cwe_name": "Concurrent Execution using Shared Resource with Improper Synchronization ('Race Condition')", "cve": "CVE-2017-1000112", "cve_desc": "Linux kernel: Exploitable memory corruption due to UFO to non-UFO path switch. When building a UFO packet with MSG_MORE __ip_append_data() calls ip_ufo_append_data() to append. However in between two send() calls, the append path can be switched from UFO to non-UFO one, which leads to a memory corruption. In case UFO packet lengths exceeds MTU, copy = maxfraglen - skb->len becomes negative on the non-UFO path and the branch to allocate new skb is taken. This triggers fragmentation and computation of fraggap = skb_prev->len - maxfraglen. Fraggap can exceed MTU, causing copy = datalen - transhdrlen - fraggap to become negative. Subsequently skb_copy_and_csum_bits() writes out-of-bounds. A similar issue is present in IPv6 code. The bug was introduced in e89e9cf539a2 (\"[IPv4/IPv6]: UFO Scatter-gather approach\") on Oct 18 2005.", "project": "net", "idx": 213470}
{"source": " static int crypto_rsa_common(const BYTE* input, int length, UINT32 key_length, const BYTE* modulus,\n                              const BYTE* exponent, int exponent_size, BYTE* output)\n {\n// bug_start\n\tBN_CTX* ctx;\n// bug_end\n \tint output_length = -1;\n// bug_start\n\tBYTE* input_reverse;\n\tBYTE* modulus_reverse;\n\tBYTE* exponent_reverse;\n\tBIGNUM *mod, *exp, *x, *y;\n\tinput_reverse = (BYTE*)malloc(2 * key_length + exponent_size);\n// bug_end\n \n \tif (!input_reverse)\n \t\treturn -1;\n \n \tmodulus_reverse = input_reverse + key_length;\n \texponent_reverse = modulus_reverse + key_length;\n \tmemcpy(modulus_reverse, modulus, key_length);\n \tcrypto_reverse(modulus_reverse, key_length);\n \tmemcpy(exponent_reverse, exponent, exponent_size);\n \tcrypto_reverse(exponent_reverse, exponent_size);\n \tmemcpy(input_reverse, input, length);\n \tcrypto_reverse(input_reverse, length);\n \n \tif (!(ctx = BN_CTX_new()))\n \t\tgoto fail_bn_ctx;\n \n \tif (!(mod = BN_new()))\n \t\tgoto fail_bn_mod;\n \n \tif (!(exp = BN_new()))\n \t\tgoto fail_bn_exp;\n \n \tif (!(x = BN_new()))\n \t\tgoto fail_bn_x;\n \n \tif (!(y = BN_new()))\n \t\tgoto fail_bn_y;\n \n// bug_start\n\tBN_bin2bn(modulus_reverse, key_length, mod);\n\tBN_bin2bn(exponent_reverse, exponent_size, exp);\n\tBN_bin2bn(input_reverse, length, x);\n\tBN_mod_exp(y, x, exp, mod, ctx);\n// bug_end\n \toutput_length = BN_bn2bin(y, output);\n// bug_start\n// bug_end\n \tcrypto_reverse(output, output_length);\n \n// bug_start\n\tif (output_length < (int)key_length)\n// bug_end\n \t\tmemset(output + output_length, 0, key_length - output_length);\n \n// bug_start\n// bug_end\n \tBN_free(y);\n fail_bn_y:\n \tBN_clear_free(x);\n fail_bn_x:\n \tBN_free(exp);\n fail_bn_exp:\n \tBN_free(mod);\n fail_bn_mod:\n \tBN_CTX_free(ctx);\n fail_bn_ctx:\n \tfree(input_reverse);\n \treturn output_length;\n }\n \n", "target": "// fix_start\n\tBN_CTX* ctx = NULL;\n// fix_end\n// fix_start\n\tBYTE* input_reverse = NULL;\n\tBYTE* modulus_reverse = NULL;\n\tBYTE* exponent_reverse = NULL;\n\tBIGNUM* mod = NULL;\n\tBIGNUM* exp = NULL;\n\tBIGNUM* x = NULL;\n\tBIGNUM* y = NULL;\n\tsize_t bufferSize = 2 * key_length + exponent_size;\n\n\tif (!input || (length < 0) || (exponent_size < 0) || !modulus || !exponent || !output)\n\t\treturn -1;\n\n\tif (length > bufferSize)\n\t\tbufferSize = length;\n\n\tinput_reverse = (BYTE*)calloc(bufferSize, 1);\n// fix_end\n// fix_start\n\tif (!BN_bin2bn(modulus_reverse, key_length, mod))\n\t\tgoto fail;\n\n\tif (!BN_bin2bn(exponent_reverse, exponent_size, exp))\n\t\tgoto fail;\n\tif (!BN_bin2bn(input_reverse, length, x))\n\t\tgoto fail;\n\tif (BN_mod_exp(y, x, exp, mod, ctx) != 1)\n\t\tgoto fail;\n// fix_end\n// fix_start\n\tif (output_length < 0)\n\t\tgoto fail;\n// fix_end\n// fix_start\n\tif (output_length < key_length)\n// fix_end\n// fix_start\nfail:\n// fix_end\n", "cwe": "CWE-787", "cwe_name": "Out-of-bounds Write", "cve": "CVE-2020-13398", "cve_desc": "An issue was discovered in FreeRDP before 2.1.1. An out-of-bounds (OOB) write vulnerability has been detected in crypto_rsa_common in libfreerdp/crypto/crypto.c.", "project": "FreeRDP", "idx": 213662}
{"source": " open_ssl_connection (rfbClient *client, int sockfd, rfbBool anonTLS, rfbCredential *cred)\n {\n   SSL_CTX *ssl_ctx = NULL;\n   SSL *ssl = NULL;\n   int n, finished = 0;\n   X509_VERIFY_PARAM *param;\n// bug_start\n  uint8_t verify_crls = cred->x509Credential.x509CrlVerifyMode;\n// bug_end\n \n   if (!(ssl_ctx = SSL_CTX_new(SSLv23_client_method())))\n   {\n     rfbClientLog(\"Could not create new SSL context.\\n\");\n     return NULL;\n   }\n \n   param = X509_VERIFY_PARAM_new();\n \n   if (!anonTLS)\n   {\n// bug_start\n// bug_end\n     if (cred->x509Credential.x509CACertFile)\n     {\n       if (!SSL_CTX_load_verify_locations(ssl_ctx, cred->x509Credential.x509CACertFile, NULL))\n       {\n         rfbClientLog(\"Failed to load CA certificate from %s.\\n\",\n                      cred->x509Credential.x509CACertFile);\n         goto error_free_ctx;\n       }\n     } else {\n       rfbClientLog(\"Using default paths for certificate verification.\\n\");\n       SSL_CTX_set_default_verify_paths (ssl_ctx);\n     }\n \n     if (cred->x509Credential.x509CACrlFile)\n     {\n       if (!load_crls_from_file(cred->x509Credential.x509CACrlFile, ssl_ctx))\n       {\n         rfbClientLog(\"CRLs could not be loaded.\\n\");\n         goto error_free_ctx;\n       }\n       if (verify_crls == rfbX509CrlVerifyNone) verify_crls = rfbX509CrlVerifyAll;\n     }\n \n     if (cred->x509Credential.x509ClientCertFile && cred->x509Credential.x509ClientKeyFile)\n     {\n       if (SSL_CTX_use_certificate_chain_file(ssl_ctx, cred->x509Credential.x509ClientCertFile) != 1)\n       {\n         rfbClientLog(\"Client certificate could not be loaded.\\n\");\n         goto error_free_ctx;\n       }\n \n       if (SSL_CTX_use_PrivateKey_file(ssl_ctx, cred->x509Credential.x509ClientKeyFile,\n                                       SSL_FILETYPE_PEM) != 1)\n       {\n         rfbClientLog(\"Client private key could not be loaded.\\n\");\n         goto error_free_ctx;\n       }\n \n       if (SSL_CTX_check_private_key(ssl_ctx) == 0) {\n         rfbClientLog(\"Client certificate and private key do not match.\\n\");\n         goto error_free_ctx;\n       }\n     }\n \n     SSL_CTX_set_verify(ssl_ctx, SSL_VERIFY_PEER, NULL);\n \n     if (verify_crls == rfbX509CrlVerifyClient)\n       X509_VERIFY_PARAM_set_flags(param, X509_V_FLAG_CRL_CHECK);\n     else if (verify_crls == rfbX509CrlVerifyAll)\n       X509_VERIFY_PARAM_set_flags(param, X509_V_FLAG_CRL_CHECK | X509_V_FLAG_CRL_CHECK_ALL);\n \n     if(!X509_VERIFY_PARAM_set1_host(param, client->serverHost, strlen(client->serverHost)))\n     {\n       rfbClientLog(\"Could not set server name for verification.\\n\");\n       goto error_free_ctx;\n     }\n     SSL_CTX_set1_param(ssl_ctx, param);\n   }\n \n   if (!(ssl = SSL_new (ssl_ctx)))\n   {\n     rfbClientLog(\"Could not create a new SSL session.\\n\");\n     goto error_free_ctx;\n   }\n \n   SSL_set_cipher_list(ssl, \"ALL\");\n \n   SSL_set_fd (ssl, sockfd);\n   SSL_CTX_set_app_data (ssl_ctx, client);\n \n   do\n   {\n     n = SSL_connect(ssl);\n \n     if (n != 1)\n     {\n       if (wait_for_data(ssl, n, 1) != 1)\n       {\n         finished = 1;\n         SSL_shutdown(ssl);\n \n         goto error_free_ssl;\n       }\n     }\n   } while( n != 1 && finished != 1 );\n \n   X509_VERIFY_PARAM_free(param);\n   return ssl;\n \n error_free_ssl:\n   SSL_free(ssl);\n \n error_free_ctx:\n   X509_VERIFY_PARAM_free(param);\n   SSL_CTX_free(ssl_ctx);\n \n   return NULL;\n }\n \n", "target": "// fix_start\n  uint8_t verify_crls;\n// fix_end\n// fix_start\n    verify_crls = cred->x509Credential.x509CrlVerifyMode;\n// fix_end\n", "cwe": "CWE-476", "cwe_name": "NULL Pointer Dereference", "cve": "CVE-2020-14396", "cve_desc": "An issue was discovered in LibVNCServer before 0.9.13. libvncclient/tls_openssl.c has a NULL pointer dereference.", "project": "libvncserver", "idx": 214025}
{"source": " static int dissect_dvb_s2_bb(tvbuff_t *tvb, int cur_off, proto_tree *tree, packet_info *pinfo)\n {\n     proto_item *ti;\n     proto_tree *dvb_s2_bb_tree;\n \n     guint8      input8, matype1;\n     guint8      sync_flag = 0;\n     guint16     input16, bb_data_len = 0, user_packet_length;\n \n     int         sub_dissected        = 0, flag_is_ms = 0, new_off = 0;\n \n     static int * const bb_header_bitfields[] = {\n         &hf_dvb_s2_bb_matype1_gs,\n         &hf_dvb_s2_bb_matype1_mis,\n         &hf_dvb_s2_bb_matype1_acm,\n         &hf_dvb_s2_bb_matype1_issyi,\n         &hf_dvb_s2_bb_matype1_npd,\n         &hf_dvb_s2_bb_matype1_low_ro,\n         NULL\n     };\n \n     col_append_str(pinfo->cinfo, COL_PROTOCOL, \"BB \");\n     col_append_str(pinfo->cinfo, COL_INFO, \"Baseband \");\n \n     ti = proto_tree_add_item(tree, proto_dvb_s2_bb, tvb, cur_off, DVB_S2_BB_HEADER_LEN, ENC_NA);\n     dvb_s2_bb_tree = proto_item_add_subtree(ti, ett_dvb_s2_bb);\n \n     matype1 = tvb_get_guint8(tvb, cur_off + DVB_S2_BB_OFFS_MATYPE1);\n     new_off += 1;\n \n     if (BIT_IS_CLEAR(matype1, DVB_S2_BB_MIS_POS))\n         flag_is_ms = 1;\n \n     proto_tree_add_bitmask_with_flags(dvb_s2_bb_tree, tvb, cur_off + DVB_S2_BB_OFFS_MATYPE1, hf_dvb_s2_bb_matype1,\n         ett_dvb_s2_bb_matype1, bb_header_bitfields, ENC_BIG_ENDIAN, BMT_NO_FLAGS);\n \n     input8 = tvb_get_guint8(tvb, cur_off + DVB_S2_BB_OFFS_MATYPE1);\n \n     if ((pinfo->fd->num == 1) && (_use_low_rolloff_value != 0)) {\n         _use_low_rolloff_value = 0;\n     }\n     if (((input8 & 0x03) == 3) && !_use_low_rolloff_value) {\n       _use_low_rolloff_value = 1;\n     }\n     if (_use_low_rolloff_value) {\n        proto_tree_add_item(dvb_s2_bb_tree, hf_dvb_s2_bb_matype1_low_ro, tvb,\n                            cur_off + DVB_S2_BB_OFFS_MATYPE1, 1, ENC_BIG_ENDIAN);\n     } else {\n        proto_tree_add_item(dvb_s2_bb_tree, hf_dvb_s2_bb_matype1_high_ro, tvb,\n                            cur_off + DVB_S2_BB_OFFS_MATYPE1, 1, ENC_BIG_ENDIAN);\n     }\n \n     input8 = tvb_get_guint8(tvb, cur_off + DVB_S2_BB_OFFS_MATYPE2);\n     new_off += 1;\n     if (flag_is_ms) {\n         proto_tree_add_uint_format_value(dvb_s2_bb_tree, hf_dvb_s2_bb_matype2, tvb,\n                                    cur_off + DVB_S2_BB_OFFS_MATYPE2, 1, input8, \"Input Stream Identifier (ISI): %d\",\n                                    input8);\n     } else {\n         proto_tree_add_uint_format_value(dvb_s2_bb_tree, hf_dvb_s2_bb_matype2, tvb,\n                                    cur_off + DVB_S2_BB_OFFS_MATYPE2, 1, input8, \"reserved\");\n     }\n \n     user_packet_length = input16 = tvb_get_ntohs(tvb, cur_off + DVB_S2_BB_OFFS_UPL);\n     new_off += 2;\n \n     proto_tree_add_uint_format(dvb_s2_bb_tree, hf_dvb_s2_bb_upl, tvb,\n                                cur_off + DVB_S2_BB_OFFS_UPL, 2, input16, \"User Packet Length: %d bits (%d bytes)\",\n                                (guint16) input16, (guint16) input16 / 8);\n \n     bb_data_len = input16 = tvb_get_ntohs(tvb, cur_off + DVB_S2_BB_OFFS_DFL);\n     bb_data_len /= 8;\n     new_off += 2;\n \n     proto_tree_add_uint_format_value(dvb_s2_bb_tree, hf_dvb_s2_bb_dfl, tvb,\n                                cur_off + DVB_S2_BB_OFFS_DFL, 2, input16, \"%d bits (%d bytes)\", input16, input16 / 8);\n \n     new_off += 1;\n     sync_flag = tvb_get_guint8(tvb, cur_off + DVB_S2_BB_OFFS_SYNC);\n     proto_tree_add_item(dvb_s2_bb_tree, hf_dvb_s2_bb_sync, tvb, cur_off + DVB_S2_BB_OFFS_SYNC, 1, ENC_BIG_ENDIAN);\n \n     new_off += 2;\n     proto_tree_add_item(dvb_s2_bb_tree, hf_dvb_s2_bb_syncd, tvb, cur_off + DVB_S2_BB_OFFS_SYNCD, 2, ENC_BIG_ENDIAN);\n \n     new_off += 1;\n     proto_tree_add_checksum(dvb_s2_bb_tree, tvb, cur_off + DVB_S2_BB_OFFS_CRC, hf_dvb_s2_bb_crc, hf_dvb_s2_bb_crc_status, &ei_dvb_s2_bb_crc, pinfo,\n         compute_crc8(tvb, DVB_S2_BB_HEADER_LEN - 1, cur_off), ENC_NA, PROTO_CHECKSUM_VERIFY);\n \n     switch (matype1 & DVB_S2_BB_TSGS_MASK) {\n     case DVB_S2_BB_TSGS_GENERIC_CONTINUOUS:\n         if (BIT_IS_SET(matype1, DVB_S2_BB_ISSYI_POS)) {\n             expert_add_info(pinfo, ti, &ei_dvb_s2_bb_issy_invalid);\n         }\n         if (BIT_IS_SET(matype1, DVB_S2_BB_NPD_POS)) {\n             expert_add_info(pinfo, ti, &ei_dvb_s2_bb_npd_invalid);\n         }\n         if (user_packet_length != 0x0000) {\n             expert_add_info_format(pinfo, ti, &ei_dvb_s2_bb_upl_invalid,\n                 \"UPL is 0x%04x. It must be 0x0000 for GSE packets.\", user_packet_length);\n         }\n \n \n         if (dvb_s2_df_dissection) {\n             while (bb_data_len) {\n                 if (sync_flag == DVB_S2_BB_SYNC_EIP_CRC32 && bb_data_len == DVB_S2_BB_EIP_CRC32_LEN) {\n                     proto_tree_add_item(dvb_s2_bb_tree, hf_dvb_s2_bb_eip_crc32, tvb, cur_off + new_off, bb_data_len, ENC_NA);\n                     bb_data_len = 0;\n                     new_off += DVB_S2_BB_EIP_CRC32_LEN;\n                 } else {\n                     sub_dissected = dissect_dvb_s2_gse(tvb, cur_off + new_off, tree, pinfo, bb_data_len);\n                     new_off += sub_dissected;\n \n                     if ((sub_dissected <= bb_data_len) && (sub_dissected >= DVB_S2_GSE_MINSIZE)) {\n                         bb_data_len -= sub_dissected;\n                         if (bb_data_len < DVB_S2_GSE_MINSIZE)\n                             bb_data_len = 0;\n// bug_start\n// bug_end\n                     }\n                 }\n             }\n         } else {\n             proto_tree_add_item(dvb_s2_bb_tree, hf_dvb_s2_bb_df, tvb, cur_off + new_off, bb_data_len, ENC_NA);\n             new_off += bb_data_len;\n         }\n         break;\n \n     case DVB_S2_BB_TSGS_GENERIC_PACKETIZED:\n         proto_tree_add_item(tree, hf_dvb_s2_bb_packetized, tvb, cur_off + new_off, bb_data_len, ENC_NA);\n         new_off += bb_data_len;\n         break;\n \n     case DVB_S2_BB_TSGS_TRANSPORT_STREAM:\n         proto_tree_add_item(tree, hf_dvb_s2_bb_transport, tvb, cur_off + new_off, bb_data_len, ENC_NA);\n         new_off += bb_data_len;\n         break;\n \n     default:\n         proto_tree_add_item(tree, hf_dvb_s2_bb_reserved, tvb, cur_off + new_off,bb_data_len, ENC_NA);\n         new_off += bb_data_len;\n         expert_add_info(pinfo, ti, &ei_dvb_s2_bb_reserved);\n         break;\n     }\n \n     return new_off;\n }\n \n", "target": "// fix_start\n                    } else {\n                        bb_data_len = 0;\n// fix_end\n", "cwe": "CWE-835", "cwe_name": "Loop with Unreachable Exit Condition ('Infinite Loop')", "cve": "CVE-2021-22222", "cve_desc": "Infinite loop in DVB-S2-BB dissector in Wireshark 3.4.0 to 3.4.5 allows denial of service via packet injection or crafted capture file", "project": "wireshark", "idx": 214056}
{"source": " static void inline ConvertXYZToJzazbz(const double X,const double Y,\n   const double Z,const double white_luminance,double *Jz,double *az,double *bz)\n {\n #define Jzazbz_b  1.15\n #define Jzazbz_g  0.66\n #define Jzazbz_c1  (3424.0/4096.0)\n #define Jzazbz_c2  (2413.0/128.0)\n #define Jzazbz_c3  (2392.0/128.0)\n #define Jzazbz_n  (2610.0/16384.0)\n #define Jzazbz_p  (1.7*2523.0/32.0)\n #define Jzazbz_d  (-0.56)\n #define Jzazbz_d0  (1.6295499532821566e-11)\n \n   double\n     gamma,\n     Iz,\n     L,\n     Lp,\n     M,\n     Mp,\n     S,\n     Sp,\n     Xp,\n     Yp,\n     Zp;\n \n   Xp=(Jzazbz_b*X-Z*(Jzazbz_b-1));\n   Yp=(Jzazbz_g*Y-X*(Jzazbz_g-1));\n   Zp=Z;\n   L=0.41478972*Xp+0.579999*Yp+0.0146480*Zp;\n   M=(-0.2015100)*Xp+1.120649*Yp+0.0531008*Zp;\n   S=(-0.0166008)*Xp+0.264800*Yp+0.6684799*Zp;\n// bug_start\n  gamma=pow(L/white_luminance,Jzazbz_n);\n// bug_end\n   Lp=pow((Jzazbz_c1+Jzazbz_c2*gamma)/(1.0+Jzazbz_c3*gamma),Jzazbz_p);\n// bug_start\n  gamma=pow(M/white_luminance,Jzazbz_n);\n// bug_end\n   Mp=pow((Jzazbz_c1+Jzazbz_c2*gamma)/(1.0+Jzazbz_c3*gamma),Jzazbz_p);\n// bug_start\n  gamma=pow(S/white_luminance,Jzazbz_n);\n// bug_end\n   Sp=pow((Jzazbz_c1+Jzazbz_c2*gamma)/(1.0+Jzazbz_c3*gamma),Jzazbz_p);\n   Iz=0.5*Lp+0.5*Mp;\n   *az=3.52400*Lp-4.066708*Mp+0.542708*Sp+0.5;\n   *bz=0.199076*Lp+1.096799*Mp-1.295875*Sp+0.5;\n   *Jz=((Jzazbz_d+1.0)*Iz)/(Jzazbz_d*Iz+1.0)-Jzazbz_d0;\n }\n \n", "target": "// fix_start\n  gamma=pow(L*PerceptibleReciprocal(white_luminance),Jzazbz_n);\n// fix_end\n// fix_start\n  gamma=pow(M*PerceptibleReciprocal(white_luminance),Jzazbz_n);\n// fix_end\n// fix_start\n  gamma=pow(S*PerceptibleReciprocal(white_luminance),Jzazbz_n);\n// fix_end\n", "cwe": "CWE-369", "cwe_name": "Divide By Zero", "cve": "CVE-2021-20310", "cve_desc": "A flaw was found in ImageMagick in versions before 7.0.11, where a division by zero ConvertXYZToJzazbz() of MagickCore/colorspace.c may trigger undefined behavior via a crafted image file that is submitted by an attacker and processed by an application using ImageMagick. The highest threat from this vulnerability is to system availability.", "project": "ImageMagick", "idx": 214120}
{"source": " static void dp8393x_do_transmit_packets(dp8393xState *s)\n {\n     NetClientState *nc = qemu_get_queue(s->nic);\n     int width, size;\n     int tx_len, len;\n     uint16_t i;\n \n     width = (s->regs[SONIC_DCR] & SONIC_DCR_DW) ? 2 : 1;\n \n     while (1) {\n         size = sizeof(uint16_t) * 6 * width;\n         s->regs[SONIC_TTDA] = s->regs[SONIC_CTDA];\n         DPRINTF(\"Transmit packet at %08x\\n\", dp8393x_ttda(s));\n         address_space_read(&s->as, dp8393x_ttda(s) + sizeof(uint16_t) * width,\n                            MEMTXATTRS_UNSPECIFIED, s->data, size);\n         tx_len = 0;\n \n         s->regs[SONIC_TCR] = dp8393x_get(s, width, 0) & 0xf000;\n         s->regs[SONIC_TPS] = dp8393x_get(s, width, 1);\n         s->regs[SONIC_TFC] = dp8393x_get(s, width, 2);\n         s->regs[SONIC_TSA0] = dp8393x_get(s, width, 3);\n         s->regs[SONIC_TSA1] = dp8393x_get(s, width, 4);\n         s->regs[SONIC_TFS] = dp8393x_get(s, width, 5);\n \n         if (s->regs[SONIC_TCR] & SONIC_TCR_PINT) {\n             s->regs[SONIC_ISR] |= SONIC_ISR_PINT;\n         } else {\n             s->regs[SONIC_ISR] &= ~SONIC_ISR_PINT;\n         }\n \n         for (i = 0; i < s->regs[SONIC_TFC]; ) {\n             len = s->regs[SONIC_TFS];\n             if (tx_len + len > sizeof(s->tx_buffer)) {\n                 len = sizeof(s->tx_buffer) - tx_len;\n             }\n             address_space_read(&s->as, dp8393x_tsa(s), MEMTXATTRS_UNSPECIFIED,\n                                &s->tx_buffer[tx_len], len);\n             tx_len += len;\n \n             i++;\n             if (i != s->regs[SONIC_TFC]) {\n                 size = sizeof(uint16_t) * 3 * width;\n                 address_space_read(&s->as,\n                                    dp8393x_ttda(s)\n                                    + sizeof(uint16_t) * width * (4 + 3 * i),\n                                    MEMTXATTRS_UNSPECIFIED, s->data,\n                                    size);\n                 s->regs[SONIC_TSA0] = dp8393x_get(s, width, 0);\n                 s->regs[SONIC_TSA1] = dp8393x_get(s, width, 1);\n                 s->regs[SONIC_TFS] = dp8393x_get(s, width, 2);\n             }\n         }\n \n         if (!(s->regs[SONIC_TCR] & SONIC_TCR_CRCI)) {\n         } else {\n             tx_len -= 4;\n             if (tx_len < 0) {\n                 SONIC_ERROR(\"tx_len is %d\\n\", tx_len);\n                 break;\n             }\n         }\n \n         if (s->regs[SONIC_RCR] & (SONIC_RCR_LB1 | SONIC_RCR_LB0)) {\n             s->regs[SONIC_TCR] |= SONIC_TCR_CRSL;\n             if (nc->info->can_receive(nc)) {\n                 s->loopback_packet = 1;\n// bug_start\n                nc->info->receive(nc, s->tx_buffer, tx_len);\n// bug_end\n             }\n         } else {\n             qemu_send_packet(nc, s->tx_buffer, tx_len);\n         }\n         s->regs[SONIC_TCR] |= SONIC_TCR_PTX;\n \n         dp8393x_put(s, width, 0,\n                     s->regs[SONIC_TCR] & 0x0fff);\n         size = sizeof(uint16_t) * width;\n         address_space_write(&s->as, dp8393x_ttda(s),\n                             MEMTXATTRS_UNSPECIFIED, s->data, size);\n \n         if (!(s->regs[SONIC_CR] & SONIC_CR_HTX)) {\n             size = sizeof(uint16_t) * width;\n             address_space_read(&s->as,\n                                dp8393x_ttda(s)\n                                + sizeof(uint16_t) * width\n                                  * (4 + 3 * s->regs[SONIC_TFC]),\n                                MEMTXATTRS_UNSPECIFIED, s->data,\n                                size);\n             s->regs[SONIC_CTDA] = dp8393x_get(s, width, 0);\n             if (s->regs[SONIC_CTDA] & SONIC_DESC_EOL) {\n                 break;\n             }\n         }\n     }\n \n     s->regs[SONIC_CR] &= ~SONIC_CR_TXP;\n     s->regs[SONIC_ISR] |= SONIC_ISR_TXDN;\n     dp8393x_update_irq(s);\n }\n \n", "target": "// fix_start\n                qemu_receive_packet(nc, s->tx_buffer, tx_len);\n// fix_end\n", "cwe": "CWE-835", "cwe_name": "Loop with Unreachable Exit Condition ('Infinite Loop')", "cve": "CVE-2021-3416", "cve_desc": "A potential stack overflow via infinite loop issue was found in various NIC emulators of QEMU in versions up to and including 5.2.0. The issue occurs in loopback mode of a NIC wherein reentrant DMA checks get bypassed. A guest user/process may use this flaw to consume CPU cycles or crash the QEMU process on the host resulting in DoS scenario.", "project": "qemu", "idx": 214193}
{"source": " int main(int argc, char **argv, char **envp)\n {\n #ifdef DYNLOAD\n     if (!uc_dyn_load(NULL, 0)) {\n         printf(\"Error dynamically loading shared library.\\n\");\n         printf(\"Please check that unicorn.dll/unicorn.so is available as well as\\n\");\n         printf(\"any other dependent dll/so files.\\n\");\n         printf(\"The easiest way is to place them in the same directory as this app.\\n\");\n         return 1;\n     }\n #endif\n \n     test_arm();\n     printf(\"==========================\\n\");\n     test_thumb();\n// bug_start\n\n// bug_end\n #ifdef DYNLOAD\n     uc_dyn_free();\n #endif\n \n     return 0;\n }\n \n", "target": "// fix_start\n    printf(\"==========================\\n\");\n    test_thumb_ite();\n// fix_end\n", "cwe": "CWE-295", "cwe_name": "Improper Certificate Validation", "cve": "CVE-2021-36979", "cve_desc": "Unicorn Engine 1.0.2 has an out-of-bounds write in tb_flush_armeb (called from cpu_arm_exec_armeb and tcg_cpu_exec_armeb).", "project": "unicorn", "idx": 214241}
{"source": " static bool l2cap_check_enc_key_size(struct hci_conn *hcon)\n {\n \treturn (!test_bit(HCI_CONN_ENCRYPT, &hcon->flags) ||\n// bug_start\n\t\thcon->enc_key_size > HCI_MIN_ENC_KEY_SIZE);\n// bug_end\n }\n \n", "target": "// fix_start\n\t\thcon->enc_key_size >= HCI_MIN_ENC_KEY_SIZE);\n// fix_end\n", "cwe": "CWE-327", "cwe_name": "Use of a Broken or Risky Cryptographic Algorithm", "cve": "CVE-2019-9506", "cve_desc": "The Bluetooth BR/EDR specification up to and including version 5.1 permits sufficiently low encryption key length and does not prevent an attacker from influencing the key length negotiation. This allows practical brute-force attacks (aka \"KNOB\") that can decrypt traffic and inject arbitrary ciphertext without the victim noticing.", "project": "linux", "idx": 214365}
{"source": " spell_read_tree(\n     FILE\t*fd,\n     char_u\t**bytsp,\n     idx_T\t**idxsp,\n     int\t\tprefixtree,\n     int\t\tprefixcnt)\n {\n     int\t\tlen;\n     int\t\tidx;\n     char_u\t*bp;\n     idx_T\t*ip;\n \n     len = get4c(fd);\n     if (len < 0)\n \treturn SP_TRUNCERROR;\n// bug_start\n// bug_end\n     if (len > 0)\n     {\n \tbp = lalloc((long_u)len, TRUE);\n \tif (bp == NULL)\n \t    return SP_OTHERERROR;\n \t*bytsp = bp;\n \n \tip = (idx_T *)lalloc_clear((long_u)(len * sizeof(int)), TRUE);\n \tif (ip == NULL)\n \t    return SP_OTHERERROR;\n \t*idxsp = ip;\n \n \tidx = read_tree_node(fd, bp, ip, len, 0, prefixtree, prefixcnt);\n \tif (idx < 0)\n \t    return idx;\n     }\n     return 0;\n }\n \n", "target": "// fix_start\n    if (len >= 0x3ffffff)\n\treturn SP_FORMERROR;\n// fix_end\n", "cwe": "CWE-190", "cwe_name": "Integer Overflow or Wraparound", "cve": "CVE-2017-5953", "cve_desc": "vim before patch 8.0.0322 does not properly validate values for tree length when handling a spell file, which may result in an integer overflow at a memory allocation site and a resultant buffer overflow.", "project": "vim", "idx": 214366}
{"source": " static void host_callback(void *arg, int status, int timeouts,\n                           unsigned char *abuf, int alen)\n {\n   struct host_query *hquery = (struct host_query*)arg;\n   int addinfostatus = ARES_SUCCESS;\n   hquery->timeouts += timeouts;\n   hquery->remaining--;\n \n   if (status == ARES_SUCCESS)\n     {\n       addinfostatus = ares__parse_into_addrinfo(abuf, alen, hquery->ai);\n     }\n   else if (status == ARES_EDESTRUCTION)\n     {\n       end_hquery(hquery, status);\n// bug_start\n// bug_end\n     }\n \n   if (!hquery->remaining)\n     {\n       if (addinfostatus != ARES_SUCCESS)\n         {\n           end_hquery(hquery, addinfostatus);\n         }\n       else if (hquery->ai->nodes)\n         {\n           end_hquery(hquery, ARES_SUCCESS);\n         }\n       else if (status == ARES_ENOTFOUND)\n         {\n           next_lookup(hquery, status);\n         }\n       else\n         {\n           end_hquery(hquery, status);\n         }\n     }\n \n }\n \n", "target": "// fix_start\n      return;\n// fix_end\n", "cwe": "CWE-310", "cwe_name": "Cryptographic Issues", "cve": "CVE-2020-14354", "cve_desc": "A possible use-after-free and double-free in c-ares lib version 1.16.0 if ares_destroy() is called prior to ares_getaddrinfo() completing. This flaw possibly allows an attacker to crash the service that uses c-ares lib. The highest threat from this vulnerability is to this service availability.", "project": "c-ares", "idx": 214405}
{"source": " opj_image_t *pngtoimage(const char *read_idf, opj_cparameters_t * params)\n {\n     png_structp  png = NULL;\n     png_infop    info = NULL;\n     double gamma;\n     int bit_depth, interlace_type, compression_type, filter_type;\n     OPJ_UINT32 i;\n     png_uint_32  width, height = 0U;\n     int color_type;\n     FILE *reader = NULL;\n     OPJ_BYTE** rows = NULL;\n     OPJ_INT32* row32s = NULL;\n     opj_image_t *image = NULL;\n     opj_image_cmptparm_t cmptparm[4];\n     OPJ_UINT32 nr_comp;\n     OPJ_BYTE sigbuf[8];\n     convert_XXx32s_C1R cvtXXTo32s = NULL;\n     convert_32s_CXPX cvtCxToPx = NULL;\n     OPJ_INT32* planes[4];\n \n     if ((reader = fopen(read_idf, \"rb\")) == NULL) {\n         fprintf(stderr, \"pngtoimage: can not open %s\\n\", read_idf);\n         return NULL;\n     }\n \n     if (fread(sigbuf, 1, MAGIC_SIZE, reader) != MAGIC_SIZE\n             || memcmp(sigbuf, PNG_MAGIC, MAGIC_SIZE) != 0) {\n         fprintf(stderr, \"pngtoimage: %s is no valid PNG file\\n\", read_idf);\n         goto fin;\n     }\n \n     if ((png = png_create_read_struct(PNG_LIBPNG_VER_STRING,\n                                       NULL, NULL, NULL)) == NULL) {\n         goto fin;\n     }\n     if ((info = png_create_info_struct(png)) == NULL) {\n         goto fin;\n     }\n \n     if (setjmp(png_jmpbuf(png))) {\n         goto fin;\n     }\n \n     png_init_io(png, reader);\n     png_set_sig_bytes(png, MAGIC_SIZE);\n \n     png_read_info(png, info);\n \n     if (png_get_IHDR(png, info, &width, &height,\n                      &bit_depth, &color_type, &interlace_type,\n                      &compression_type, &filter_type) == 0) {\n         goto fin;\n     }\n \n     if (color_type == PNG_COLOR_TYPE_PALETTE) {\n         png_set_expand(png);\n     }\n \n     if (png_get_valid(png, info, PNG_INFO_tRNS)) {\n         png_set_expand(png);\n     }\n \n     if (!png_get_gAMA(png, info, &gamma)) {\n         gamma = 1.0;\n     }\n \n     png_set_gamma(png, 1.0, gamma);\n \n     png_read_update_info(png, info);\n \n     color_type = png_get_color_type(png, info);\n \n     switch (color_type) {\n     case PNG_COLOR_TYPE_GRAY:\n         nr_comp = 1;\n         break;\n     case PNG_COLOR_TYPE_GRAY_ALPHA:\n         nr_comp = 2;\n         break;\n     case PNG_COLOR_TYPE_RGB:\n         nr_comp = 3;\n         break;\n     case PNG_COLOR_TYPE_RGB_ALPHA:\n         nr_comp = 4;\n         break;\n     default:\n         fprintf(stderr, \"pngtoimage: colortype %d is not supported\\n\", color_type);\n         goto fin;\n     }\n     cvtCxToPx = convert_32s_CXPX_LUT[nr_comp];\n     bit_depth = png_get_bit_depth(png, info);\n \n     switch (bit_depth) {\n     case 1:\n     case 2:\n     case 4:\n     case 8:\n         cvtXXTo32s = convert_XXu32s_C1R_LUT[bit_depth];\n         break;\n     case 16:\n         cvtXXTo32s = convert_16u32s_C1R;\n         break;\n     default:\n         fprintf(stderr, \"pngtoimage: bit depth %d is not supported\\n\", bit_depth);\n         goto fin;\n     }\n \n \n     rows = (OPJ_BYTE**)calloc(height + 1, sizeof(OPJ_BYTE*));\n     if (rows == NULL) {\n         fprintf(stderr, \"pngtoimage: memory out\\n\");\n         goto fin;\n     }\n     for (i = 0; i < height; ++i) {\n         rows[i] = (OPJ_BYTE*)malloc(png_get_rowbytes(png, info));\n         if (rows[i] == NULL) {\n             fprintf(stderr, \"pngtoimage: memory out\\n\");\n             goto fin;\n         }\n     }\n     png_read_image(png, rows);\n \n     memset(cmptparm, 0, sizeof(cmptparm));\n     for (i = 0; i < nr_comp; ++i) {\n         cmptparm[i].prec = (OPJ_UINT32)bit_depth;\n         cmptparm[i].bpp = (OPJ_UINT32)bit_depth;\n         cmptparm[i].sgnd = 0;\n         cmptparm[i].dx = (OPJ_UINT32)params->subsampling_dx;\n         cmptparm[i].dy = (OPJ_UINT32)params->subsampling_dy;\n         cmptparm[i].w = (OPJ_UINT32)width;\n         cmptparm[i].h = (OPJ_UINT32)height;\n     }\n \n     image = opj_image_create(nr_comp, &cmptparm[0],\n                              (nr_comp > 2U) ? OPJ_CLRSPC_SRGB : OPJ_CLRSPC_GRAY);\n     if (image == NULL) {\n         goto fin;\n     }\n     image->x0 = (OPJ_UINT32)params->image_offset_x0;\n     image->y0 = (OPJ_UINT32)params->image_offset_y0;\n     image->x1 = (OPJ_UINT32)(image->x0 + (width  - 1) * (OPJ_UINT32)\n// bug_start\n                             params->subsampling_dx + 1 + image->x0);\n// bug_end\n     image->y1 = (OPJ_UINT32)(image->y0 + (height - 1) * (OPJ_UINT32)\n// bug_start\n                             params->subsampling_dy + 1 + image->y0);\n// bug_end\n \n     row32s = (OPJ_INT32 *)malloc((size_t)width * nr_comp * sizeof(OPJ_INT32));\n     if (row32s == NULL) {\n         goto fin;\n     }\n \n     image->comps[nr_comp - 1U].alpha = 1U - (nr_comp & 1U);\n \n     for (i = 0; i < nr_comp; i++) {\n         planes[i] = image->comps[i].data;\n     }\n \n     for (i = 0; i < height; ++i) {\n         cvtXXTo32s(rows[i], row32s, (OPJ_SIZE_T)width * nr_comp);\n         cvtCxToPx(row32s, planes, width);\n         planes[0] += width;\n         planes[1] += width;\n         planes[2] += width;\n         planes[3] += width;\n     }\n fin:\n     if (rows) {\n         for (i = 0; i < height; ++i)\n             if (rows[i]) {\n                 free(rows[i]);\n             }\n         free(rows);\n     }\n     if (row32s) {\n         free(row32s);\n     }\n     if (png) {\n         png_destroy_read_struct(&png, &info, NULL);\n     }\n \n     fclose(reader);\n \n     return image;\n \n }\n \n", "target": "// fix_start\n                             params->subsampling_dx + 1);\n// fix_end\n// fix_start\n                             params->subsampling_dy + 1);\n// fix_end\n", "cwe": "CWE-787", "cwe_name": "Out-of-bounds Write", "cve": "CVE-2020-27823", "cve_desc": "A flaw was found in OpenJPEG\u2019s encoder. This flaw allows an attacker to pass specially crafted x,y offset input to OpenJPEG to use during encoding. The highest threat from this vulnerability is to confidentiality, integrity, as well as system availability.", "project": "openjpeg", "idx": 214409}
{"source": " static void slc_bump(struct slcan *sl)\n {\n \tstruct sk_buff *skb;\n \tstruct can_frame cf;\n \tint i, tmp;\n \tu32 tmpid;\n \tchar *cmd = sl->rbuff;\n \n// bug_start\n\tcf.can_id = 0;\n// bug_end\n \n \tswitch (*cmd) {\n \tcase 'r':\n \t\tcf.can_id = CAN_RTR_FLAG;\n \tcase 't':\n \t\tcf.can_dlc = sl->rbuff[SLC_CMD_LEN + SLC_SFF_ID_LEN];\n \t\tsl->rbuff[SLC_CMD_LEN + SLC_SFF_ID_LEN] = 0;\n \t\tcmd += SLC_CMD_LEN + SLC_SFF_ID_LEN + 1;\n \t\tbreak;\n \tcase 'R':\n \t\tcf.can_id = CAN_RTR_FLAG;\n \tcase 'T':\n \t\tcf.can_id |= CAN_EFF_FLAG;\n \t\tcf.can_dlc = sl->rbuff[SLC_CMD_LEN + SLC_EFF_ID_LEN];\n \t\tsl->rbuff[SLC_CMD_LEN + SLC_EFF_ID_LEN] = 0;\n \t\tcmd += SLC_CMD_LEN + SLC_EFF_ID_LEN + 1;\n \t\tbreak;\n \tdefault:\n \t\treturn;\n \t}\n \n \tif (kstrtou32(sl->rbuff + SLC_CMD_LEN, 16, &tmpid))\n \t\treturn;\n \n \tcf.can_id |= tmpid;\n \n \tif (cf.can_dlc >= '0' && cf.can_dlc < '9')\n \t\tcf.can_dlc -= '0';\n \telse\n \t\treturn;\n// bug_start\n\n\t*(u64 *) (&cf.data) = 0;\n// bug_end\n \n \tif (!(cf.can_id & CAN_RTR_FLAG)) {\n \t\tfor (i = 0; i < cf.can_dlc; i++) {\n \t\t\ttmp = hex_to_bin(*cmd++);\n \t\t\tif (tmp < 0)\n \t\t\t\treturn;\n \t\t\tcf.data[i] = (tmp << 4);\n \t\t\ttmp = hex_to_bin(*cmd++);\n \t\t\tif (tmp < 0)\n \t\t\t\treturn;\n \t\t\tcf.data[i] |= tmp;\n \t\t}\n \t}\n \n \tskb = dev_alloc_skb(sizeof(struct can_frame) +\n \t\t\t    sizeof(struct can_skb_priv));\n \tif (!skb)\n \t\treturn;\n \n \tskb->dev = sl->dev;\n \tskb->protocol = htons(ETH_P_CAN);\n \tskb->pkt_type = PACKET_BROADCAST;\n \tskb->ip_summed = CHECKSUM_UNNECESSARY;\n \n \tcan_skb_reserve(skb);\n \tcan_skb_prv(skb)->ifindex = sl->dev->ifindex;\n \tcan_skb_prv(skb)->skbcnt = 0;\n \n \tskb_put_data(skb, &cf, sizeof(struct can_frame));\n \n \tsl->dev->stats.rx_packets++;\n \tsl->dev->stats.rx_bytes += cf.can_dlc;\n \tnetif_rx_ni(skb);\n }\n \n", "target": "// fix_start\n\tmemset(&cf, 0, sizeof(cf));\n// fix_end\n// fix_start\n// fix_end\n", "cwe": "CWE-200", "cwe_name": "Exposure of Sensitive Information to an Unauthorized Actor", "cve": "CVE-2020-11494", "cve_desc": "An issue was discovered in slc_bump in drivers/net/can/slcan.c in the Linux kernel 3.16 through 5.6.2. It allows attackers to read uninitialized can_frame data, potentially containing sensitive information from kernel stack memory, if the configuration lacks CONFIG_INIT_STACK_ALL, aka CID-b9258a2cece4.", "project": "linux", "idx": 214425}
{"source": " static unsigned int xdr_set_page_base(struct xdr_stream *xdr,\n \t\t\t\t      unsigned int base, unsigned int len)\n {\n \tunsigned int pgnr;\n \tunsigned int maxlen;\n \tunsigned int pgoff;\n \tunsigned int pgend;\n \tvoid *kaddr;\n \n \tmaxlen = xdr->buf->page_len;\n// bug_start\n\tif (base >= maxlen) {\n\t\tbase = maxlen;\n\t\tmaxlen = 0;\n\t} else\n// bug_end\n \t\tmaxlen -= base;\n \tif (len > maxlen)\n \t\tlen = maxlen;\n \n \txdr_stream_page_set_pos(xdr, base);\n \tbase += xdr->buf->page_base;\n \n \tpgnr = base >> PAGE_SHIFT;\n \txdr->page_ptr = &xdr->buf->pages[pgnr];\n \tkaddr = page_address(*xdr->page_ptr);\n \n \tpgoff = base & ~PAGE_MASK;\n \txdr->p = (__be32*)(kaddr + pgoff);\n \n \tpgend = pgoff + len;\n \tif (pgend > PAGE_SIZE)\n \t\tpgend = PAGE_SIZE;\n \txdr->end = (__be32*)(kaddr + pgend);\n \txdr->iov = NULL;\n \treturn len;\n }\n \n", "target": "// fix_start\n\tif (base >= maxlen)\n\t\treturn 0;\n\telse\n// fix_end\n", "cwe": "CWE-787", "cwe_name": "Out-of-bounds Write", "cve": "CVE-2021-38201", "cve_desc": "net/sunrpc/xdr.c in the Linux kernel before 5.13.4 allows remote attackers to cause a denial of service (xdr_set_page_base slab-out-of-bounds access) by performing many NFS 4.2 READ_PLUS operations.", "project": "linux", "idx": 214890}
{"source": " static void suboption(struct Curl_easy *data)\n {\n   struct curl_slist *v;\n   unsigned char temp[2048];\n   ssize_t bytes_written;\n   size_t len;\n   int err;\n   char varname[128] = \"\";\n   char varval[128] = \"\";\n   struct TELNET *tn = data->req.p.telnet;\n   struct connectdata *conn = data->conn;\n \n   printsub(data, '<', (unsigned char *)tn->subbuffer, CURL_SB_LEN(tn) + 2);\n   switch(CURL_SB_GET(tn)) {\n     case CURL_TELOPT_TTYPE:\n       len = strlen(tn->subopt_ttype) + 4 + 2;\n       msnprintf((char *)temp, sizeof(temp),\n                 \"%c%c%c%c%s%c%c\", CURL_IAC, CURL_SB, CURL_TELOPT_TTYPE,\n                 CURL_TELQUAL_IS, tn->subopt_ttype, CURL_IAC, CURL_SE);\n       bytes_written = swrite(conn->sock[FIRSTSOCKET], temp, len);\n       if(bytes_written < 0) {\n         err = SOCKERRNO;\n         failf(data,\"Sending data failed (%d)\",err);\n       }\n       printsub(data, '>', &temp[2], len-2);\n       break;\n     case CURL_TELOPT_XDISPLOC:\n       len = strlen(tn->subopt_xdisploc) + 4 + 2;\n       msnprintf((char *)temp, sizeof(temp),\n                 \"%c%c%c%c%s%c%c\", CURL_IAC, CURL_SB, CURL_TELOPT_XDISPLOC,\n                 CURL_TELQUAL_IS, tn->subopt_xdisploc, CURL_IAC, CURL_SE);\n       bytes_written = swrite(conn->sock[FIRSTSOCKET], temp, len);\n       if(bytes_written < 0) {\n         err = SOCKERRNO;\n         failf(data,\"Sending data failed (%d)\",err);\n       }\n       printsub(data, '>', &temp[2], len-2);\n       break;\n     case CURL_TELOPT_NEW_ENVIRON:\n       msnprintf((char *)temp, sizeof(temp),\n                 \"%c%c%c%c\", CURL_IAC, CURL_SB, CURL_TELOPT_NEW_ENVIRON,\n                 CURL_TELQUAL_IS);\n       len = 4;\n \n       for(v = tn->telnet_vars; v; v = v->next) {\n         size_t tmplen = (strlen(v->data) + 1);\n         if(len + tmplen < (int)sizeof(temp)-6) {\n// bug_start\n          if(sscanf(v->data, \"%127[^,],%127s\", varname, varval)) {\n// bug_end\n             msnprintf((char *)&temp[len], sizeof(temp) - len,\n                       \"%c%s%c%s\", CURL_NEW_ENV_VAR, varname,\n                       CURL_NEW_ENV_VALUE, varval);\n             len += tmplen;\n           }\n         }\n       }\n       msnprintf((char *)&temp[len], sizeof(temp) - len,\n                 \"%c%c\", CURL_IAC, CURL_SE);\n       len += 2;\n       bytes_written = swrite(conn->sock[FIRSTSOCKET], temp, len);\n       if(bytes_written < 0) {\n         err = SOCKERRNO;\n         failf(data,\"Sending data failed (%d)\",err);\n       }\n       printsub(data, '>', &temp[2], len-2);\n       break;\n   }\n   return;\n }\n \n", "target": "// fix_start\n          if(sscanf(v->data, \"%127[^,],%127s\", varname, varval) == 2) {\n// fix_end\n", "cwe": "CWE-200", "cwe_name": "Exposure of Sensitive Information to an Unauthorized Actor", "cve": "CVE-2021-22898", "cve_desc": "curl 7.7 through 7.76.1 suffers from an information disclosure when the `-t` command line option, known as `CURLOPT_TELNETOPTIONS` in libcurl, is used to send variable=content pairs to TELNET servers. Due to a flaw in the option parser for sending NEW_ENV variables, libcurl could be made to pass on uninitialized data from a stack based buffer to the server, resulting in potentially revealing sensitive internal information to the server using a clear-text network protocol.", "project": "curl", "idx": 214926}
{"source": " void LibRaw::identify_process_dng_fields()\n {\n \tif (!dng_version) return;\n \tint c;\n \t{\n \t\tint iifd = find_ifd_by_offset(data_offset);\n \t\tint pifd = find_ifd_by_offset(thumb_offset);\n \n #define CFAROUND(value, filters)                                               \\\n   filters ? (filters >= 1000 ? ((value + 1) / 2) * 2 : ((value + 5) / 6) * 6)  \\\n           : value\n \n #define IFDCOLORINDEX(ifd, subset, bit)                                        \\\n   (tiff_ifd[ifd].dng_color[subset].parsedfields & bit)                         \\\n       ? ifd                                                                    \\\n       : ((tiff_ifd[0].dng_color[subset].parsedfields & bit) ? 0 : -1)\n \n #define IFDLEVELINDEX(ifd, bit)                                                \\\n   (tiff_ifd[ifd].dng_levels.parsedfields & bit)                                \\\n       ? ifd                                                                    \\\n       : ((tiff_ifd[0].dng_levels.parsedfields & bit) ? 0 : -1)\n \n #define COPYARR(to, from) memmove(&to, &from, sizeof(from))\n \n \t\tif (iifd < (int)tiff_nifds && iifd >= 0)\n \t\t{\n \t\t\tint sidx;\n \t\t\tif (!(imgdata.params.raw_processing_options &\n \t\t\t\tLIBRAW_PROCESSING_DONT_CHECK_DNG_ILLUMINANT))\n \t\t\t{\n \t\t\t\tint illidx[2], cmidx[2], calidx[2], abidx;\n \t\t\t\tfor (int i = 0; i < 2; i++)\n \t\t\t\t{\n \t\t\t\t\tillidx[i] = IFDCOLORINDEX(iifd, i, LIBRAW_DNGFM_ILLUMINANT);\n \t\t\t\t\tcmidx[i] = IFDCOLORINDEX(iifd, i, LIBRAW_DNGFM_COLORMATRIX);\n \t\t\t\t\tcalidx[i] = IFDCOLORINDEX(iifd, i, LIBRAW_DNGFM_CALIBRATION);\n \t\t\t\t}\n \t\t\t\tabidx = IFDLEVELINDEX(iifd, LIBRAW_DNGFM_ANALOGBALANCE);\n \t\t\t\tif (illidx[0] >= 0 && illidx[0] < (int)tiff_nifds &&\n \t\t\t\t\tillidx[0] == illidx[1] && illidx[0] == cmidx[0] &&\n \t\t\t\t\tillidx[0] == cmidx[1] &&\n \t\t\t\t\ttiff_ifd[illidx[0]].dng_color[0].illuminant > 0 &&\n \t\t\t\t\ttiff_ifd[illidx[0]].dng_color[1].illuminant > 0)\n \t\t\t\t{\n \t\t\t\t\tsidx = illidx[0];\n \t\t\t\t\tdouble cc[4][4], cm[4][3], cam_xyz[4][3];\n \t\t\t\t\tfor (int j = 0; j < 4; j++)\n \t\t\t\t\t\tfor (int i = 0; i < 4; i++)\n \t\t\t\t\t\t\tcc[j][i] = i == j;\n \t\t\t\t\tint colidx = -1;\n \n \t\t\t\t\tfor (int i = 0; i < 2; i++)\n \t\t\t\t\t{\n \t\t\t\t\t\tif (tiff_ifd[sidx].dng_color[i].illuminant == LIBRAW_WBI_D65)\n \t\t\t\t\t\t{\n \t\t\t\t\t\t\tcolidx = i;\n \t\t\t\t\t\t\tbreak;\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \n \t\t\t\t\tif (colidx < 0)\n \t\t\t\t\t\tfor (int i = 0; i < 2; i++)\n \t\t\t\t\t\t{\n \t\t\t\t\t\t\tint ill = tiff_ifd[sidx].dng_color[i].illuminant;\n \t\t\t\t\t\t\tif (ill == LIBRAW_WBI_Daylight || ill == LIBRAW_WBI_D55 ||\n \t\t\t\t\t\t\t\till == LIBRAW_WBI_D75 || ill == LIBRAW_WBI_D50 ||\n \t\t\t\t\t\t\t\till == LIBRAW_WBI_Flash)\n \t\t\t\t\t\t\t{\n \t\t\t\t\t\t\t\tcolidx = i;\n \t\t\t\t\t\t\t\tbreak;\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}\n \t\t\t\t\tif (colidx >= 0)\n \t\t\t\t\t{\n \t\t\t\t\t\tFORCC for (int j = 0; j < 3; j++) cm[c][j] =\n \t\t\t\t\t\t\ttiff_ifd[sidx].dng_color[colidx].colormatrix[c][j];\n \n \t\t\t\t\t\tif (calidx[colidx] == sidx)\n \t\t\t\t\t\t{\n// bug_start\n\t\t\t\t\t\t\tfor (int i = 0; i < colors; i++)\n// bug_end\n \t\t\t\t\t\t\t\tFORCC\n \t\t\t\t\t\t\t\tcc[i][c] = tiff_ifd[sidx].dng_color[colidx].calibration[i][c];\n \t\t\t\t\t\t}\n \n \t\t\t\t\t\tif (abidx == sidx)\n// bug_start\n\t\t\t\t\t\t\tfor (int i = 0; i < colors; i++)\n// bug_end\n \t\t\t\t\t\t\t\tFORCC cc[i][c] *= tiff_ifd[sidx].dng_levels.analogbalance[i];\n \t\t\t\t\t\tint j;\n// bug_start\n\t\t\t\t\t\tFORCC for (int i = 0; i < 3; i++) for (cam_xyz[c][i] = j = 0;\n\t\t\t\t\t\t\tj < colors; j++)\n\t\t\t\t\t\t\tcam_xyz[c][i] +=\n\t\t\t\t\t\t\tcc[c][j] * cm[j][i];\n// bug_end\n \t\t\t\t\t\tcam_xyz_coeff(cmatrix, cam_xyz);\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tbool noFujiDNGCrop = makeIs(LIBRAW_CAMERAMAKER_Fujifilm)\n \t\t\t\t&& (!strcmp(normalized_model, \"S3Pro\")\n \t\t\t\t\t|| !strcmp(normalized_model, \"S5Pro\")\n \t\t\t\t\t|| !strcmp(normalized_model, \"S2Pro\"));\n \n \t\t\tif (!noFujiDNGCrop &&\n \t\t\t\t(imgdata.params.raw_processing_options &LIBRAW_PROCESSING_USE_DNG_DEFAULT_CROP))\n \t\t\t{\n \t\t\t\tsidx = IFDLEVELINDEX(iifd, LIBRAW_DNGFM_CROPORIGIN);\n \t\t\t\tint sidx2 = IFDLEVELINDEX(iifd, LIBRAW_DNGFM_CROPSIZE);\n \t\t\t\tif (sidx >= 0 && sidx == sidx2 &&\n \t\t\t\t\ttiff_ifd[sidx].dng_levels.default_crop[2] > 0 &&\n \t\t\t\t\ttiff_ifd[sidx].dng_levels.default_crop[3] > 0)\n \t\t\t\t{\n \t\t\t\t\tint lm = tiff_ifd[sidx].dng_levels.default_crop[0];\n \t\t\t\t\tint lmm = CFAROUND(lm, filters);\n \t\t\t\t\tint tm = tiff_ifd[sidx].dng_levels.default_crop[1];\n \t\t\t\t\tint tmm = CFAROUND(tm, filters);\n \t\t\t\t\tint ww = tiff_ifd[sidx].dng_levels.default_crop[2];\n \t\t\t\t\tint hh = tiff_ifd[sidx].dng_levels.default_crop[3];\n \t\t\t\t\tif (lmm > lm)\n \t\t\t\t\t\tww -= (lmm - lm);\n \t\t\t\t\tif (tmm > tm)\n \t\t\t\t\t\thh -= (tmm - tm);\n \t\t\t\t\tif (left_margin + lm + ww <= raw_width &&\n \t\t\t\t\t\ttop_margin + tm + hh <= raw_height)\n \t\t\t\t\t{\n \t\t\t\t\t\tleft_margin += lmm;\n \t\t\t\t\t\ttop_margin += tmm;\n \t\t\t\t\t\twidth = ww;\n \t\t\t\t\t\theight = hh;\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \t\t\tif (!(imgdata.color.dng_color[0].parsedfields &\n \t\t\t\tLIBRAW_DNGFM_FORWARDMATRIX))\n \t\t\t{\n \t\t\t\tsidx = IFDCOLORINDEX(iifd, 0, LIBRAW_DNGFM_FORWARDMATRIX);\n \t\t\t\tif (sidx >= 0)\n \t\t\t\t\tCOPYARR(imgdata.color.dng_color[0].forwardmatrix,\n \t\t\t\t\t\ttiff_ifd[sidx].dng_color[0].forwardmatrix);\n \t\t\t}\n \t\t\tif (!(imgdata.color.dng_color[1].parsedfields &\n \t\t\t\tLIBRAW_DNGFM_FORWARDMATRIX))\n \t\t\t{\n \t\t\t\tsidx = IFDCOLORINDEX(iifd, 1, LIBRAW_DNGFM_FORWARDMATRIX);\n \t\t\t\tif (sidx >= 0)\n \t\t\t\t\tCOPYARR(imgdata.color.dng_color[1].forwardmatrix,\n \t\t\t\t\t\ttiff_ifd[sidx].dng_color[1].forwardmatrix);\n \t\t\t}\n \t\t\tfor (int ss = 0; ss < 2; ss++)\n \t\t\t{\n \t\t\t\tsidx = IFDCOLORINDEX(iifd, ss, LIBRAW_DNGFM_COLORMATRIX);\n \t\t\t\tif (sidx >= 0)\n \t\t\t\t\tCOPYARR(imgdata.color.dng_color[ss].colormatrix,\n \t\t\t\t\t\ttiff_ifd[sidx].dng_color[ss].colormatrix);\n \n \t\t\t\tsidx = IFDCOLORINDEX(iifd, ss, LIBRAW_DNGFM_CALIBRATION);\n \t\t\t\tif (sidx >= 0)\n \t\t\t\t\tCOPYARR(imgdata.color.dng_color[ss].calibration,\n \t\t\t\t\t\ttiff_ifd[sidx].dng_color[ss].calibration);\n \n \t\t\t\tsidx = IFDCOLORINDEX(iifd, ss, LIBRAW_DNGFM_ILLUMINANT);\n \t\t\t\tif (sidx >= 0)\n \t\t\t\t\timgdata.color.dng_color[ss].illuminant =\n \t\t\t\t\ttiff_ifd[sidx].dng_color[ss].illuminant;\n \t\t\t}\n \t\t\tsidx = IFDLEVELINDEX(iifd, LIBRAW_DNGFM_ANALOGBALANCE);\n \t\t\tif (sidx >= 0)\n \t\t\t\tCOPYARR(imgdata.color.dng_levels.analogbalance,\n \t\t\t\t\ttiff_ifd[sidx].dng_levels.analogbalance);\n \n \t\t\tsidx = IFDLEVELINDEX(iifd, LIBRAW_DNGFM_BASELINEEXPOSURE);\n \t\t\tif (sidx >= 0)\n \t\t\t\timgdata.color.dng_levels.baseline_exposure =\n \t\t\t\ttiff_ifd[sidx].dng_levels.baseline_exposure;\n \n \t\t\tsidx = IFDLEVELINDEX(iifd, LIBRAW_DNGFM_WHITE);\n \t\t\tif (sidx >= 0 && tiff_ifd[sidx].dng_levels.dng_whitelevel[0])\n \t\t\t\tCOPYARR(imgdata.color.dng_levels.dng_whitelevel,\n \t\t\t\t\ttiff_ifd[sidx].dng_levels.dng_whitelevel);\n \t\t\telse if (tiff_ifd[iifd].sample_format <= 2 && tiff_ifd[iifd].bps > 0 && tiff_ifd[iifd].bps < 32)\n \t\t\t\tFORC4\n \t\t\t\timgdata.color.dng_levels.dng_whitelevel[c] = (1 << tiff_ifd[iifd].bps) - 1;\n \n \n \n \t\t\tsidx = IFDLEVELINDEX(iifd, LIBRAW_DNGFM_ASSHOTNEUTRAL);\n \t\t\tif (sidx >= 0)\n \t\t\t{\n \t\t\t\tCOPYARR(imgdata.color.dng_levels.asshotneutral,\n \t\t\t\t\ttiff_ifd[sidx].dng_levels.asshotneutral);\n \t\t\t\tif (imgdata.color.dng_levels.asshotneutral[0])\n \t\t\t\t{\n \t\t\t\t\tcam_mul[3] = 0;\n \t\t\t\t\tFORCC\n \t\t\t\t\t\tif (fabs(imgdata.color.dng_levels.asshotneutral[c]) > 0.0001)\n \t\t\t\t\t\t\tcam_mul[c] = 1 / imgdata.color.dng_levels.asshotneutral[c];\n \t\t\t\t}\n \t\t\t}\n \t\t\tsidx = IFDLEVELINDEX(iifd, LIBRAW_DNGFM_BLACK);\n \t\t\tif (sidx >= 0)\n \t\t\t{\n \t\t\t\timgdata.color.dng_levels.dng_fblack =\n \t\t\t\t\ttiff_ifd[sidx].dng_levels.dng_fblack;\n \t\t\t\timgdata.color.dng_levels.dng_black =\n \t\t\t\t\ttiff_ifd[sidx].dng_levels.dng_black;\n \t\t\t\tCOPYARR(imgdata.color.dng_levels.dng_cblack,\n \t\t\t\t\ttiff_ifd[sidx].dng_levels.dng_cblack);\n \t\t\t\tCOPYARR(imgdata.color.dng_levels.dng_fcblack,\n \t\t\t\t\ttiff_ifd[sidx].dng_levels.dng_fcblack);\n \t\t\t}\n \n \n \t\t\tif (pifd >= 0)\n \t\t\t{\n \t\t\t\tsidx = IFDLEVELINDEX(pifd, LIBRAW_DNGFM_PREVIEWCS);\n \t\t\t\tif (sidx >= 0)\n \t\t\t\t\timgdata.color.dng_levels.preview_colorspace =\n \t\t\t\t\ttiff_ifd[sidx].dng_levels.preview_colorspace;\n \t\t\t}\n \t\t\tsidx = IFDLEVELINDEX(iifd, LIBRAW_DNGFM_OPCODE2);\n \t\t\tif (sidx >= 0)\n \t\t\t\tmeta_offset = tiff_ifd[sidx].opcode2_offset;\n \n \t\t\tsidx = IFDLEVELINDEX(iifd, LIBRAW_DNGFM_LINTABLE);\n \t\t\tINT64 linoff = -1;\n \t\t\tint linlen = 0;\n \t\t\tif (sidx >= 0)\n \t\t\t{\n \t\t\t\tlinoff = tiff_ifd[sidx].lineartable_offset;\n \t\t\t\tlinlen = tiff_ifd[sidx].lineartable_len;\n \t\t\t}\n \n \t\t\tif (linoff >= 0 && linlen > 0)\n \t\t\t{\n \t\t\t\tINT64 pos = ftell(ifp);\n \t\t\t\tfseek(ifp, linoff, SEEK_SET);\n \t\t\t\tlinear_table(linlen);\n \t\t\t\tfseek(ifp, pos, SEEK_SET);\n \t\t\t}\n \t\t}\n \t\tif (load_raw == &LibRaw::lossy_dng_load_raw)\n \t\t{\n \t\t\tmaximum = 0xffff;\n \t\t\tFORC4 imgdata.color.linear_max[c] = imgdata.color.dng_levels.dng_whitelevel[c] = 0xffff;\n \t\t}\n \t\telse\n \t\t{\n \t\t\tmaximum = imgdata.color.dng_levels.dng_whitelevel[0];\n \t\t}\n \t\tblack = imgdata.color.dng_levels.dng_black;\n \n \t\tif (tiff_samples == 2 && imgdata.color.dng_levels.dng_cblack[4] * imgdata.color.dng_levels.dng_cblack[5] * tiff_samples\n \t\t\t== imgdata.color.dng_levels.dng_cblack[LIBRAW_CBLACK_SIZE - 1])\n \t\t{\n \t\t\tunsigned ff = filters;\n \t\t\tif (filters > 999 && colors == 3)\n \t\t\t\tfilters |= ((filters >> 2 & 0x22222222) | (filters << 2 & 0x88888888)) &\n \t\t\t\tfilters << 1;\n \n \t\t\tint csum[4] = { 0,0,0,0 }, ccount[4] = { 0,0,0,0 };\n \t\t\tint i = 6 + shot_select;\n \t\t\tfor (unsigned row = 0; row < imgdata.color.dng_levels.dng_cblack[4]; row++)\n \t\t\t\tfor (unsigned col = 0; col < imgdata.color.dng_levels.dng_cblack[5]; col++)\n \t\t\t\t{\n \t\t\t\t\tcsum[FC(row, col)] += imgdata.color.dng_levels.dng_cblack[i];\n \t\t\t\t\tccount[FC(row, col)]++;\n \t\t\t\t\ti += tiff_samples;\n \t\t\t\t}\n \t\t\tfor (int c = 0; c < 4; c++)\n \t\t\t\tif (ccount[c])\n \t\t\t\t\timgdata.color.dng_levels.dng_cblack[c] += csum[c] / ccount[c];\n \t\t\timgdata.color.dng_levels.dng_cblack[4] = imgdata.color.dng_levels.dng_cblack[5] = 0;\n \t\t\tfilters = ff;\n \t\t}\n \t\telse if (tiff_samples > 2 && tiff_samples <= 4 && imgdata.color.dng_levels.dng_cblack[4] * imgdata.color.dng_levels.dng_cblack[5] * tiff_samples\n \t\t\t== imgdata.color.dng_levels.dng_cblack[LIBRAW_CBLACK_SIZE - 1])\n \t\t{\n \t\t\tint csum[4] = { 0,0,0,0 }, ccount[4] = { 0,0,0,0 };\n \t\t\tint i = 6;\n \t\t\tfor (unsigned row = 0; row < imgdata.color.dng_levels.dng_cblack[4]; row++)\n \t\t\t\tfor (unsigned col = 0; col < imgdata.color.dng_levels.dng_cblack[5]; col++)\n// bug_start\n\t\t\t\t\tfor (unsigned c = 0; c < tiff_samples; c++)\n// bug_end\n \t\t\t\t\t{\n \t\t\t\t\t\tcsum[c] += imgdata.color.dng_levels.dng_cblack[i];\n \t\t\t\t\t\tccount[c]++;\n \t\t\t\t\t\ti++;\n \t\t\t\t\t}\n \t\t\tfor (int c = 0; c < 4; c++)\n \t\t\t\tif (ccount[c])\n \t\t\t\t\timgdata.color.dng_levels.dng_cblack[c] += csum[c] / ccount[c];\n \t\t\timgdata.color.dng_levels.dng_cblack[4] = imgdata.color.dng_levels.dng_cblack[5] = 0;\n \t\t}\n \n \t\tmemmove(cblack, imgdata.color.dng_levels.dng_cblack, sizeof(cblack));\n \n \t\tif (iifd < (int)tiff_nifds && iifd >= 0)\n \t\t{\n \t\t\tint sidx = IFDLEVELINDEX(iifd, LIBRAW_DNGFM_LINEARRESPONSELIMIT);\n \t\t\tif (sidx >= 0)\n \t\t\t{\n \t\t\t\timgdata.color.dng_levels.LinearResponseLimit =\n \t\t\t\t\ttiff_ifd[sidx].dng_levels.LinearResponseLimit;\n \t\t\t\tif (imgdata.color.dng_levels.LinearResponseLimit > 0.1 &&\n \t\t\t\t\timgdata.color.dng_levels.LinearResponseLimit <= 1.0)\n \t\t\t\t{\n \t\t\t\t\tint bl4 = 0, bl64 = 0;\n \t\t\t\t\tfor (int chan = 0; chan < colors && chan < 4; chan++)\n \t\t\t\t\t\tbl4 += cblack[chan];\n \t\t\t\t\tbl4 /= LIM(colors, 1, 4);\n \n \t\t\t\t\tif (cblack[4] * cblack[5] > 0)\n \t\t\t\t\t{\n \t\t\t\t\t\tunsigned cnt = 0;\n \t\t\t\t\t\tfor (unsigned c = 0; c < 4096 && c < cblack[4] * cblack[5]; c++)\n \t\t\t\t\t\t{\n \t\t\t\t\t\t\tbl64 += cblack[c + 6];\n \t\t\t\t\t\t\tcnt++;\n \t\t\t\t\t\t}\n \t\t\t\t\t\tbl64 /= LIM(cnt, 1, 4096);\n \t\t\t\t\t}\n \t\t\t\t\tint rblack = black + bl4 + bl64;\n \t\t\t\t\tfor (int chan = 0; chan < colors && chan < 4; chan++)\n \t\t\t\t\t\timgdata.color.linear_max[chan] =\n \t\t\t\t\t\t(maximum - rblack) *\n \t\t\t\t\t\timgdata.color.dng_levels.LinearResponseLimit +\n \t\t\t\t\t\trblack;\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \t}\n }\n \n", "target": "// fix_start\n\t\t\t\t\t\t\tfor (int i = 0; i < colors && i < 4; i++)\n// fix_end\n// fix_start\n\t\t\t\t\t\t\tfor (int i = 0; i < colors && i < 4; i++)\n// fix_end\n// fix_start\n\t\t\t\t\t\tFORCC for (int i = 0; i < 3; i++)\n                            for (cam_xyz[c][i] = j = 0; j < colors && j < 4; j++)\n\t\t\t\t\t\t\t    cam_xyz[c][i] +=\n\t\t\t\t\t\t\t        cc[c][j] * cm[j][i];\n// fix_end\n// fix_start\n\t\t\t\t\tfor (unsigned c = 0; c < tiff_samples && c < 4; c++)\n// fix_end\n", "cwe": "CWE-787", "cwe_name": "Out-of-bounds Write", "cve": "CVE-2020-24870", "cve_desc": "Libraw before 0.20.1 has a stack buffer overflow via LibRaw::identify_process_dng_fields in identify.cpp.", "project": "LibRaw", "idx": 214990}
{"source": " struct clock_source *dce100_clock_source_create(\n \tstruct dc_context *ctx,\n \tstruct dc_bios *bios,\n \tenum clock_source_id id,\n \tconst struct dce110_clk_src_regs *regs,\n \tbool dp_clk_src)\n {\n \tstruct dce110_clk_src *clk_src =\n \t\tkzalloc(sizeof(struct dce110_clk_src), GFP_KERNEL);\n \n \tif (!clk_src)\n \t\treturn NULL;\n \n \tif (dce110_clk_src_construct(clk_src, ctx, bios, id,\n \t\t\tregs, &cs_shift, &cs_mask)) {\n \t\tclk_src->base.dp_clk_src = dp_clk_src;\n \t\treturn &clk_src->base;\n \t}\n \n// bug_start\n// bug_end\n \tBREAK_TO_DEBUGGER();\n \treturn NULL;\n }\n \n", "target": "// fix_start\n\tkfree(clk_src);\n// fix_end\n", "cwe": "CWE-703", "cwe_name": "Improper Check or Handling of Exceptional Conditions", "cve": "CVE-2019-19083", "cve_desc": "Memory leaks in *clock_source_create() functions under drivers/gpu/drm/amd/display/dc in the Linux kernel before 5.3.8 allow attackers to cause a denial of service (memory consumption). This affects the dce112_clock_source_create() function in drivers/gpu/drm/amd/display/dc/dce112/dce112_resource.c, the dce100_clock_source_create() function in drivers/gpu/drm/amd/display/dc/dce100/dce100_resource.c, the dcn10_clock_source_create() function in drivers/gpu/drm/amd/display/dc/dcn10/dcn10_resource.c, the dcn20_clock_source_create() function in drivers/gpu/drm/amd/display/dc/dcn20/dcn20_resource.c, the dce120_clock_source_create() function in drivers/gpu/drm/amd/display/dc/dce120/dce120_resource.c, the dce110_clock_source_create() function in drivers/gpu/drm/amd/display/dc/dce110/dce110_resource.c, and the dce80_clock_source_create() function in drivers/gpu/drm/amd/display/dc/dce80/dce80_resource.c, aka CID-055e547478a1.", "project": "linux", "idx": 215059}
{"source": "// bug_start\nstruct clock_source *dce80_clock_source_create(\n// bug_end\n \tstruct dc_context *ctx,\n \tstruct dc_bios *bios,\n \tenum clock_source_id id,\n \tconst struct dce110_clk_src_regs *regs,\n \tbool dp_clk_src)\n {\n \tstruct dce110_clk_src *clk_src =\n \t\tkzalloc(sizeof(struct dce110_clk_src), GFP_KERNEL);\n \n \tif (!clk_src)\n \t\treturn NULL;\n \n \tif (dce110_clk_src_construct(clk_src, ctx, bios, id,\n \t\t\tregs, &cs_shift, &cs_mask)) {\n \t\tclk_src->base.dp_clk_src = dp_clk_src;\n \t\treturn &clk_src->base;\n \t}\n \n// bug_start\n// bug_end\n \tBREAK_TO_DEBUGGER();\n \treturn NULL;\n }\n \n", "target": "// fix_start\nstruct clock_source *dce100_clock_source_create(\n// fix_end\n// fix_start\n\tkfree(clk_src);\n// fix_end\n", "cwe": "CWE-703", "cwe_name": "Improper Check or Handling of Exceptional Conditions", "cve": "CVE-2019-19083", "cve_desc": "Memory leaks in *clock_source_create() functions under drivers/gpu/drm/amd/display/dc in the Linux kernel before 5.3.8 allow attackers to cause a denial of service (memory consumption). This affects the dce112_clock_source_create() function in drivers/gpu/drm/amd/display/dc/dce112/dce112_resource.c, the dce100_clock_source_create() function in drivers/gpu/drm/amd/display/dc/dce100/dce100_resource.c, the dcn10_clock_source_create() function in drivers/gpu/drm/amd/display/dc/dcn10/dcn10_resource.c, the dcn20_clock_source_create() function in drivers/gpu/drm/amd/display/dc/dcn20/dcn20_resource.c, the dce120_clock_source_create() function in drivers/gpu/drm/amd/display/dc/dce120/dce120_resource.c, the dce110_clock_source_create() function in drivers/gpu/drm/amd/display/dc/dce110/dce110_resource.c, and the dce80_clock_source_create() function in drivers/gpu/drm/amd/display/dc/dce80/dce80_resource.c, aka CID-055e547478a1.", "project": "linux", "idx": 215060}
{"source": "// bug_start\nstruct clock_source *dcn10_clock_source_create(\n// bug_end\n \tstruct dc_context *ctx,\n \tstruct dc_bios *bios,\n \tenum clock_source_id id,\n \tconst struct dce110_clk_src_regs *regs,\n \tbool dp_clk_src)\n {\n \tstruct dce110_clk_src *clk_src =\n \t\tkzalloc(sizeof(struct dce110_clk_src), GFP_KERNEL);\n \n \tif (!clk_src)\n \t\treturn NULL;\n \n// bug_start\n\tif (dce112_clk_src_construct(clk_src, ctx, bios, id,\n// bug_end\n \t\t\tregs, &cs_shift, &cs_mask)) {\n \t\tclk_src->base.dp_clk_src = dp_clk_src;\n \t\treturn &clk_src->base;\n \t}\n \n// bug_start\n// bug_end\n \tBREAK_TO_DEBUGGER();\n \treturn NULL;\n }\n \n", "target": "// fix_start\nstruct clock_source *dce100_clock_source_create(\n// fix_end\n// fix_start\n\tif (dce110_clk_src_construct(clk_src, ctx, bios, id,\n// fix_end\n// fix_start\n\tkfree(clk_src);\n// fix_end\n", "cwe": "CWE-703", "cwe_name": "Improper Check or Handling of Exceptional Conditions", "cve": "CVE-2019-19083", "cve_desc": "Memory leaks in *clock_source_create() functions under drivers/gpu/drm/amd/display/dc in the Linux kernel before 5.3.8 allow attackers to cause a denial of service (memory consumption). This affects the dce112_clock_source_create() function in drivers/gpu/drm/amd/display/dc/dce112/dce112_resource.c, the dce100_clock_source_create() function in drivers/gpu/drm/amd/display/dc/dce100/dce100_resource.c, the dcn10_clock_source_create() function in drivers/gpu/drm/amd/display/dc/dcn10/dcn10_resource.c, the dcn20_clock_source_create() function in drivers/gpu/drm/amd/display/dc/dcn20/dcn20_resource.c, the dce120_clock_source_create() function in drivers/gpu/drm/amd/display/dc/dce120/dce120_resource.c, the dce110_clock_source_create() function in drivers/gpu/drm/amd/display/dc/dce110/dce110_resource.c, and the dce80_clock_source_create() function in drivers/gpu/drm/amd/display/dc/dce80/dce80_resource.c, aka CID-055e547478a1.", "project": "linux", "idx": 215061}
{"source": "// bug_start\nstruct clock_source *dce112_clock_source_create(\n// bug_end\n \tstruct dc_context *ctx,\n \tstruct dc_bios *bios,\n \tenum clock_source_id id,\n \tconst struct dce110_clk_src_regs *regs,\n \tbool dp_clk_src)\n {\n \tstruct dce110_clk_src *clk_src =\n \t\tkzalloc(sizeof(struct dce110_clk_src), GFP_KERNEL);\n \n \tif (!clk_src)\n \t\treturn NULL;\n \n// bug_start\n\tif (dce112_clk_src_construct(clk_src, ctx, bios, id,\n// bug_end\n \t\t\tregs, &cs_shift, &cs_mask)) {\n \t\tclk_src->base.dp_clk_src = dp_clk_src;\n \t\treturn &clk_src->base;\n \t}\n \n// bug_start\n// bug_end\n \tBREAK_TO_DEBUGGER();\n \treturn NULL;\n }\n \n", "target": "// fix_start\nstruct clock_source *dce100_clock_source_create(\n// fix_end\n// fix_start\n\tif (dce110_clk_src_construct(clk_src, ctx, bios, id,\n// fix_end\n// fix_start\n\tkfree(clk_src);\n// fix_end\n", "cwe": "CWE-703", "cwe_name": "Improper Check or Handling of Exceptional Conditions", "cve": "CVE-2019-19083", "cve_desc": "Memory leaks in *clock_source_create() functions under drivers/gpu/drm/amd/display/dc in the Linux kernel before 5.3.8 allow attackers to cause a denial of service (memory consumption). This affects the dce112_clock_source_create() function in drivers/gpu/drm/amd/display/dc/dce112/dce112_resource.c, the dce100_clock_source_create() function in drivers/gpu/drm/amd/display/dc/dce100/dce100_resource.c, the dcn10_clock_source_create() function in drivers/gpu/drm/amd/display/dc/dcn10/dcn10_resource.c, the dcn20_clock_source_create() function in drivers/gpu/drm/amd/display/dc/dcn20/dcn20_resource.c, the dce120_clock_source_create() function in drivers/gpu/drm/amd/display/dc/dce120/dce120_resource.c, the dce110_clock_source_create() function in drivers/gpu/drm/amd/display/dc/dce110/dce110_resource.c, and the dce80_clock_source_create() function in drivers/gpu/drm/amd/display/dc/dce80/dce80_resource.c, aka CID-055e547478a1.", "project": "linux", "idx": 215062}
{"source": "// bug_start\nstruct clock_source *dce110_clock_source_create(\n// bug_end\n \tstruct dc_context *ctx,\n \tstruct dc_bios *bios,\n \tenum clock_source_id id,\n \tconst struct dce110_clk_src_regs *regs,\n \tbool dp_clk_src)\n {\n \tstruct dce110_clk_src *clk_src =\n \t\tkzalloc(sizeof(struct dce110_clk_src), GFP_KERNEL);\n \n \tif (!clk_src)\n \t\treturn NULL;\n \n \tif (dce110_clk_src_construct(clk_src, ctx, bios, id,\n \t\t\tregs, &cs_shift, &cs_mask)) {\n \t\tclk_src->base.dp_clk_src = dp_clk_src;\n \t\treturn &clk_src->base;\n \t}\n \n// bug_start\n// bug_end\n \tBREAK_TO_DEBUGGER();\n \treturn NULL;\n }\n \n", "target": "// fix_start\nstruct clock_source *dce100_clock_source_create(\n// fix_end\n// fix_start\n\tkfree(clk_src);\n// fix_end\n", "cwe": "CWE-703", "cwe_name": "Improper Check or Handling of Exceptional Conditions", "cve": "CVE-2019-19083", "cve_desc": "Memory leaks in *clock_source_create() functions under drivers/gpu/drm/amd/display/dc in the Linux kernel before 5.3.8 allow attackers to cause a denial of service (memory consumption). This affects the dce112_clock_source_create() function in drivers/gpu/drm/amd/display/dc/dce112/dce112_resource.c, the dce100_clock_source_create() function in drivers/gpu/drm/amd/display/dc/dce100/dce100_resource.c, the dcn10_clock_source_create() function in drivers/gpu/drm/amd/display/dc/dcn10/dcn10_resource.c, the dcn20_clock_source_create() function in drivers/gpu/drm/amd/display/dc/dcn20/dcn20_resource.c, the dce120_clock_source_create() function in drivers/gpu/drm/amd/display/dc/dce120/dce120_resource.c, the dce110_clock_source_create() function in drivers/gpu/drm/amd/display/dc/dce110/dce110_resource.c, and the dce80_clock_source_create() function in drivers/gpu/drm/amd/display/dc/dce80/dce80_resource.c, aka CID-055e547478a1.", "project": "linux", "idx": 215063}
{"source": "// bug_start\nstruct clock_source *dcn20_clock_source_create(\n// bug_end\n \tstruct dc_context *ctx,\n \tstruct dc_bios *bios,\n \tenum clock_source_id id,\n \tconst struct dce110_clk_src_regs *regs,\n \tbool dp_clk_src)\n {\n \tstruct dce110_clk_src *clk_src =\n \t\tkzalloc(sizeof(struct dce110_clk_src), GFP_KERNEL);\n \n \tif (!clk_src)\n \t\treturn NULL;\n \n// bug_start\n\tif (dcn20_clk_src_construct(clk_src, ctx, bios, id,\n// bug_end\n \t\t\tregs, &cs_shift, &cs_mask)) {\n \t\tclk_src->base.dp_clk_src = dp_clk_src;\n \t\treturn &clk_src->base;\n \t}\n \n// bug_start\n// bug_end\n \tBREAK_TO_DEBUGGER();\n \treturn NULL;\n }\n \n", "target": "// fix_start\nstruct clock_source *dcn10_clock_source_create(\n// fix_end\n// fix_start\n\tif (dce112_clk_src_construct(clk_src, ctx, bios, id,\n// fix_end\n// fix_start\n\tkfree(clk_src);\n// fix_end\n", "cwe": "CWE-703", "cwe_name": "Improper Check or Handling of Exceptional Conditions", "cve": "CVE-2019-19083", "cve_desc": "Memory leaks in *clock_source_create() functions under drivers/gpu/drm/amd/display/dc in the Linux kernel before 5.3.8 allow attackers to cause a denial of service (memory consumption). This affects the dce112_clock_source_create() function in drivers/gpu/drm/amd/display/dc/dce112/dce112_resource.c, the dce100_clock_source_create() function in drivers/gpu/drm/amd/display/dc/dce100/dce100_resource.c, the dcn10_clock_source_create() function in drivers/gpu/drm/amd/display/dc/dcn10/dcn10_resource.c, the dcn20_clock_source_create() function in drivers/gpu/drm/amd/display/dc/dcn20/dcn20_resource.c, the dce120_clock_source_create() function in drivers/gpu/drm/amd/display/dc/dce120/dce120_resource.c, the dce110_clock_source_create() function in drivers/gpu/drm/amd/display/dc/dce110/dce110_resource.c, and the dce80_clock_source_create() function in drivers/gpu/drm/amd/display/dc/dce80/dce80_resource.c, aka CID-055e547478a1.", "project": "linux", "idx": 215064}
{"source": " static struct clock_source *dce120_clock_source_create(\n \tstruct dc_context *ctx,\n \tstruct dc_bios *bios,\n \tenum clock_source_id id,\n \tconst struct dce110_clk_src_regs *regs,\n \tbool dp_clk_src)\n {\n \tstruct dce110_clk_src *clk_src =\n \t\tkzalloc(sizeof(*clk_src), GFP_KERNEL);\n \n \tif (!clk_src)\n \t\treturn NULL;\n \n \tif (dce112_clk_src_construct(clk_src, ctx, bios, id,\n \t\t\t\t     regs, &cs_shift, &cs_mask)) {\n \t\tclk_src->base.dp_clk_src = dp_clk_src;\n \t\treturn &clk_src->base;\n \t}\n \n// bug_start\n// bug_end\n \tBREAK_TO_DEBUGGER();\n \treturn NULL;\n }\n \n", "target": "// fix_start\n\tkfree(clk_src);\n// fix_end\n", "cwe": "CWE-703", "cwe_name": "Improper Check or Handling of Exceptional Conditions", "cve": "CVE-2019-19083", "cve_desc": "Memory leaks in *clock_source_create() functions under drivers/gpu/drm/amd/display/dc in the Linux kernel before 5.3.8 allow attackers to cause a denial of service (memory consumption). This affects the dce112_clock_source_create() function in drivers/gpu/drm/amd/display/dc/dce112/dce112_resource.c, the dce100_clock_source_create() function in drivers/gpu/drm/amd/display/dc/dce100/dce100_resource.c, the dcn10_clock_source_create() function in drivers/gpu/drm/amd/display/dc/dcn10/dcn10_resource.c, the dcn20_clock_source_create() function in drivers/gpu/drm/amd/display/dc/dcn20/dcn20_resource.c, the dce120_clock_source_create() function in drivers/gpu/drm/amd/display/dc/dce120/dce120_resource.c, the dce110_clock_source_create() function in drivers/gpu/drm/amd/display/dc/dce110/dce110_resource.c, and the dce80_clock_source_create() function in drivers/gpu/drm/amd/display/dc/dce80/dce80_resource.c, aka CID-055e547478a1.", "project": "linux", "idx": 215065}
{"source": " static void get_over(struct SYMBOL *s)\n {\n \tstruct VOICE_S *p_voice, *p_voice2, *p_voice3;\n \tint range, voice, voice2, voice3;\n static char tx_wrong_dur[] = \"Wrong duration in voice overlay\";\n static char txt_no_note[] = \"No note in voice overlay\";\n \n \tp_voice = curvoice;\n \tif (p_voice->ignore)\n \t\treturn;\n \tif (s->abc_type == ABC_T_BAR\n \t || s->u.v_over.type == V_OVER_E)  {\n \t\tif (!p_voice->last_sym) {\n \t\t\terror(1, s, txt_no_note);\n \t\t\treturn;\n \t\t}\n \t\tp_voice->last_sym->sflags |= S_BEAM_END;\n \t\tover_bar = 0;\n \t\tif (over_time < 0) {\n \t\t\terror(1, s, \"Erroneous end of voice overlap\");\n \t\t\treturn;\n \t\t}\n// bug_start\n\t\tif (p_voice->time != over_mxtime)\n// bug_end\n \t\t\terror(1, s, tx_wrong_dur);\n// bug_start\n\t\tcurvoice = &voice_tb[over_voice];\n// bug_end\n \t\tover_mxtime = 0;\n \t\tover_voice = -1;\n \t\tover_time = -1;\n \t\treturn;\n \t}\n \n \tif (s->u.v_over.type == V_OVER_S) {\n \t\tover_voice = p_voice - voice_tb;\n \t\tover_time = p_voice->time;\n \t\treturn;\n \t}\n \n \tif (!p_voice->last_sym) {\n \t\terror(1, s, txt_no_note);\n \t\treturn;\n \t}\n \tp_voice->last_sym->sflags |= S_BEAM_END;\n \tvoice2 = s->u.v_over.voice;\n \tp_voice2 = &voice_tb[voice2];\n \tif (parsys->voice[voice2].range < 0) {\n \t\tint clone;\n \n \t\tif (cfmt.abc2pscompat) {\n \t\t\terror(1, s, \"Cannot have %%%%abc2pscompat\");\n \t\t\tcfmt.abc2pscompat = 0;\n \t\t}\n \t\tclone = p_voice->clone >= 0;\n \t\tp_voice2->id[0] = '&';\n \t\tp_voice2->id[1] = '\\0';\n \t\tp_voice2->second = 1;\n \t\tparsys->voice[voice2].second = 1;\n \t\tp_voice2->scale = p_voice->scale;\n \t\tp_voice2->octave = p_voice->octave;\n \t\tp_voice2->transpose = p_voice->transpose;\n \t\tmemcpy(&p_voice2->key, &p_voice->key,\n \t\t\t\t\tsizeof p_voice2->key);\n \t\tmemcpy(&p_voice2->ckey, &p_voice->ckey,\n \t\t\t\t\tsizeof p_voice2->ckey);\n \t\tmemcpy(&p_voice2->okey, &p_voice->okey,\n \t\t\t\t\tsizeof p_voice2->okey);\n \t\tp_voice2->posit = p_voice->posit;\n \t\tp_voice2->staff = p_voice->staff;\n \t\tp_voice2->cstaff = p_voice->cstaff;\n \t\tp_voice2->color = p_voice->color;\n \t\tp_voice2->map_name = p_voice->map_name;\n \t\trange = parsys->voice[p_voice - voice_tb].range;\n \t\tfor (voice = 0; voice < MAXVOICE; voice++) {\n \t\t\tif (parsys->voice[voice].range > range)\n \t\t\t\tparsys->voice[voice].range += clone + 1;\n \t\t}\n \t\tparsys->voice[voice2].range = range + 1;\n \t\tvoice_link(p_voice2);\n \t\tif (clone) {\n \t\t\tfor (voice3 = MAXVOICE; --voice3 >= 0; ) {\n \t\t\t\tif (parsys->voice[voice3].range < 0)\n \t\t\t\t\tbreak;\n \t\t\t}\n \t\t\tif (voice3 > 0) {\n \t\t\t\tp_voice3 = &voice_tb[voice3];\n \t\t\t\tstrcpy(p_voice3->id, p_voice2->id);\n \t\t\t\tp_voice3->second = 1;\n \t\t\t\tparsys->voice[voice3].second = 1;\n \t\t\t\tp_voice3->scale = voice_tb[p_voice->clone].scale;\n \t\t\t\tparsys->voice[voice3].range = range + 2;\n \t\t\t\tvoice_link(p_voice3);\n \t\t\t\tp_voice2->clone = voice3;\n \t\t\t} else {\n \t\t\t\terror(1, s,\n \t\t\t\t      \"Too many voices for overlay cloning\");\n \t\t\t}\n \t\t}\n \t}\n \tvoice = p_voice - voice_tb;\n \n \tif (over_time < 0) {\n \t\tint time;\n \n \t\tover_bar = 1;\n \t\tover_mxtime = p_voice->time;\n \t\tover_voice = voice;\n \t\ttime = p_voice2->time;\n \t\tfor (s = p_voice->last_sym; ; s = s->prev) {\n \t\t\tif (s->type == BAR\n \t\t\t || s->time <= time)\n \t\t\t\tbreak;\n \t\t}\n \t\tover_time = s->time;\n \t} else {\n \t\tif (over_mxtime == 0)\n \t\t\tover_mxtime = p_voice->time;\n \t\telse if (p_voice->time != over_mxtime)\n \t\t\terror(1, s, tx_wrong_dur);\n \t}\n \tp_voice2->time = over_time;\n \tcurvoice = p_voice2;\n }\n \n", "target": "// fix_start\n\t\tcurvoice = &voice_tb[over_voice];\n\t\tif (p_voice->time != over_mxtime) {\n// fix_end\n// fix_start\n\t\t\tif (p_voice->time > over_mxtime)\n\t\t\t\tcurvoice->time = p_voice->time;\n\t\t\telse\n\t\t\t\tp_voice->time = curvoice->time;\n\t\t}\n// fix_end\n", "cwe": "CWE-703", "cwe_name": "Improper Check or Handling of Exceptional Conditions", "cve": "CVE-2021-32436", "cve_desc": "An out-of-bounds read in the function write_title() in subs.c of abcm2ps v8.14.11 allows remote attackers to cause a Denial of Service (DoS) via unspecified vectors.", "project": "abcm2ps", "idx": 215165}
{"source": " static int exif_process_IFD_in_MAKERNOTE(image_info_type *ImageInfo, char * value_ptr, int value_len, char *offset_base, size_t IFDlength, size_t displacement TSRMLS_DC)\n {\n \tint de, i=0, section_index = SECTION_MAKERNOTE;\n \tint NumDirEntries, old_motorola_intel, offset_diff;\n \tconst maker_note_type *maker_note;\n \tchar *dir_start;\n// bug_start\n// bug_end\n \n \tfor (i=0; i<=sizeof(maker_note_array)/sizeof(maker_note_type); i++) {\n \t\tif (i==sizeof(maker_note_array)/sizeof(maker_note_type)) {\n #ifdef EXIF_DEBUG\n \t\t\texif_error_docref(NULL EXIFERR_CC, ImageInfo, E_NOTICE, \"No maker note data found. Detected maker: %s (length = %d)\", ImageInfo->make, strlen(ImageInfo->make));\n #endif\n \t\t\treturn TRUE;\n \t\t}\n \n \t\tmaker_note = maker_note_array+i;\n \n \t\tif (maker_note->make && (!ImageInfo->make || strcmp(maker_note->make, ImageInfo->make)))\n \t\t\tcontinue;\n \t\tif (maker_note->model && (!ImageInfo->model || strcmp(maker_note->model, ImageInfo->model)))\n \t\t\tcontinue;\n \t\tif (maker_note->id_string && strncmp(maker_note->id_string, value_ptr, maker_note->id_string_len))\n \t\t\tcontinue;\n \t\tbreak;\n \t}\n \n \tif (maker_note->offset >= value_len) {\n \t\texif_error_docref(\"exif_read_data#error_ifd\" EXIFERR_CC, ImageInfo, E_WARNING, \"IFD data too short: 0x%04X offset 0x%04X\", value_len, maker_note->offset);\n \t\treturn FALSE;\n \t}\n \n \tdir_start = value_ptr + maker_note->offset;\n \n #ifdef EXIF_DEBUG\n \texif_error_docref(NULL EXIFERR_CC, ImageInfo, E_NOTICE, \"Process %s @x%04X + 0x%04X=%d: %s\", exif_get_sectionname(section_index), (int)dir_start-(int)offset_base+maker_note->offset+displacement, value_len, value_len, exif_char_dump(value_ptr, value_len, (int)dir_start-(int)offset_base+maker_note->offset+displacement));\n #endif\n \n \tImageInfo->sections_found |= FOUND_MAKERNOTE;\n \n \told_motorola_intel = ImageInfo->motorola_intel;\n \tswitch (maker_note->byte_order) {\n \t\tcase MN_ORDER_INTEL:\n \t\t\tImageInfo->motorola_intel = 0;\n \t\t\tbreak;\n \t\tcase MN_ORDER_MOTOROLA:\n \t\t\tImageInfo->motorola_intel = 1;\n \t\t\tbreak;\n \t\tdefault:\n \t\tcase MN_ORDER_NORMAL:\n \t\t\tbreak;\n \t}\n \n \tNumDirEntries = php_ifd_get16u(dir_start, ImageInfo->motorola_intel);\n \n \tswitch (maker_note->offset_mode) {\n \t\tcase MN_OFFSET_MAKER:\n \t\t\toffset_base = value_ptr;\n// bug_start\n// bug_end\n \t\t\tbreak;\n \t\tcase MN_OFFSET_GUESS:\n \t\t\tif (maker_note->offset + 10 + 4 >= value_len) {\n \t\t\t\texif_error_docref(\"exif_read_data#error_ifd\" EXIFERR_CC, ImageInfo, E_WARNING, \"IFD data too short: 0x%04X\", value_len);\n \t\t\t\treturn FALSE;\n \t\t\t}\n \t\t\toffset_diff = 2 + NumDirEntries*12 + 4 - php_ifd_get32u(dir_start+10, ImageInfo->motorola_intel);\n #ifdef EXIF_DEBUG\n \t\t\texif_error_docref(NULL EXIFERR_CC, ImageInfo, E_NOTICE, \"Using automatic offset correction: 0x%04X\", ((int)dir_start-(int)offset_base+maker_note->offset+displacement) + offset_diff);\n #endif\n \t\t\tif (offset_diff < 0 || offset_diff >= value_len ) {\n \t\t\t\texif_error_docref(\"exif_read_data#error_ifd\" EXIFERR_CC, ImageInfo, E_WARNING, \"IFD data bad offset: 0x%04X length 0x%04X\", offset_diff, value_len);\n \t\t\t\treturn FALSE;\n \t\t\t}\n \t\t\toffset_base = value_ptr + offset_diff;\n// bug_start\n// bug_end\n \t\t\tbreak;\n \t\tdefault:\n \t\tcase MN_OFFSET_NORMAL:\n \t\t\tbreak;\n \t}\n \n \tif ((2+NumDirEntries*12) > value_len) {\n \t\texif_error_docref(\"exif_read_data#error_ifd\" EXIFERR_CC, ImageInfo, E_WARNING, \"Illegal IFD size: 2 + 0x%04X*12 = 0x%04X > 0x%04X\", NumDirEntries, 2+NumDirEntries*12, value_len);\n \t\treturn FALSE;\n \t}\n \n \tfor (de=0;de<NumDirEntries;de++) {\n \t\tif (!exif_process_IFD_TAG(ImageInfo, dir_start + 2 + 12 * de,\n// bug_start\n\t\t\t\t\t\t\t\t  offset_base, IFDlength, displacement, section_index, 0, maker_note->tag_table TSRMLS_CC)) {\n// bug_end\n \t\t\treturn FALSE;\n \t\t}\n \t}\n \tImageInfo->motorola_intel = old_motorola_intel;\n #ifdef EXIF_DEBUG\n \texif_error_docref(NULL EXIFERR_CC, ImageInfo, E_NOTICE, \"Subsection %s done\", exif_get_sectionname(SECTION_MAKERNOTE));\n #endif\n \treturn TRUE;\n }\n \n", "target": "// fix_start\n\tint data_len;\n// fix_end\n// fix_start\n\t\t\tdata_len = value_len;\n// fix_end\n// fix_start\n\t\t\tdata_len = value_len - offset_diff;\n// fix_end\n// fix_start\n\t\t\t\t\t\t\t\t  offset_base, data_len, displacement, section_index, 0, maker_note->tag_table TSRMLS_CC)) {\n// fix_end\n", "cwe": "CWE-125", "cwe_name": "Out-of-bounds Read", "cve": "CVE-2018-14851", "cve_desc": "exif_process_IFD_in_MAKERNOTE in ext/exif/exif.c in PHP before 5.6.37, 7.0.x before 7.0.31, 7.1.x before 7.1.20, and 7.2.x before 7.2.8 allows remote attackers to cause a denial of service (out-of-bounds read and application crash) via a crafted JPEG file.", "project": "php-src", "idx": 215213}
{"source": " gdImagePtr gdImageCrop(gdImagePtr src, const gdRectPtr crop)\n {\n \tgdImagePtr dst;\n \tint y;\n \n// bug_start\n\tif (crop->width<=0 || crop->height<=0) {\n\t\treturn NULL;\n\t}\n\n// bug_end\n \tif (src->trueColor) {\n \t\tdst = gdImageCreateTrueColor(crop->width, crop->height);\n// bug_start\n// bug_end\n \t\tgdImageSaveAlpha(dst, 1);\n \t} else {\n \t\tdst = gdImageCreate(crop->width, crop->height);\n// bug_start\n// bug_end\n \t\tgdImagePaletteCopy(dst, src);\n// bug_start\n\t}\n\tif (dst == NULL) {\n\t\treturn NULL;\n// bug_end\n \t}\n \tdst->transparent = src->transparent;\n \n \tif (crop->x < 0 || crop->x>=src->sx || crop->y<0 || crop->y>=src->sy) {\n \t\treturn dst;\n \t}\n \n \tif ((src->sx - crop->width) < crop->x) {\n \t\tcrop->width = src->sx - crop->x;\n \t}\n \tif ((src->sy - crop->height) < crop->y) {\n \t\tcrop->height = src->sy - crop->y;\n \t}\n \n #if 0\n printf(\"rect->x: %i\\nrect->y: %i\\nrect->width: %i\\nrect->height: %i\\n\", crop->x, crop->y, crop->width, crop->height);\n #endif\n \ty = crop->y;\n \tif (src->trueColor) {\n \t\tunsigned int dst_y = 0;\n \t\twhile (y < (crop->y + (crop->height - 1))) {\n \t\t\tmemcpy(dst->tpixels[dst_y++], src->tpixels[y++] + crop->x, crop->width * 4);\n \t\t}\n \t} else {\n \t\tint x;\n \t\tfor (y = crop->y; y < (crop->y + (crop->height - 1)); y++) {\n \t\t\tfor (x = crop->x; x < (crop->x + (crop->width - 1)); x++) {\n \t\t\t\tdst->pixels[y - crop->y][x - crop->x] = src->pixels[y][x];\n \t\t\t}\n \t\t}\n \t}\n \treturn dst;\n }\n \n", "target": "// fix_start\n// fix_end\n// fix_start\n\t\tif (dst == NULL) {\n\t\t\treturn NULL;\n\t\t}\n// fix_end\n// fix_start\n\t\tif (dst == NULL) {\n\t\t\treturn NULL;\n\t\t}\n// fix_end\n// fix_start\n// fix_end\n", "cwe": "CWE-189", "cwe_name": "Numeric Errors", "cve": "CVE-2013-7226", "cve_desc": "Integer overflow in the gdImageCrop function in ext/gd/gd.c in PHP 5.5.x before 5.5.9 allows remote attackers to cause a denial of service (application crash) or possibly have unspecified other impact via an imagecrop function call with a large x dimension value, leading to a heap-based buffer overflow.", "project": "php-src", "idx": 215215}
{"source": " isdn_net_setcfg(isdn_net_ioctl_cfg * cfg)\n {\n \tisdn_net_dev *p = isdn_net_findif(cfg->name);\n \tulong features;\n \tint i;\n \tint drvidx;\n \tint chidx;\n \tchar drvid[25];\n \n \tif (p) {\n \t\tisdn_net_local *lp = p->local;\n \n \t\tfeatures = ((1 << cfg->l2_proto) << ISDN_FEATURE_L2_SHIFT) |\n \t\t\t((1 << cfg->l3_proto) << ISDN_FEATURE_L3_SHIFT);\n \t\tfor (i = 0; i < ISDN_MAX_DRIVERS; i++)\n \t\t\tif (dev->drv[i])\n \t\t\t\tif ((dev->drv[i]->interface->features & features) == features)\n \t\t\t\t\tbreak;\n \t\tif (i == ISDN_MAX_DRIVERS) {\n \t\t\tprintk(KERN_WARNING \"isdn_net: No driver with selected features\\n\");\n \t\t\treturn -ENODEV;\n \t\t}\n \t\tif (lp->p_encap != cfg->p_encap){\n #ifdef CONFIG_ISDN_X25\n \t\t\tstruct concap_proto * cprot = p -> cprot;\n #endif\n \t\t\tif (isdn_net_device_started(p)) {\n \t\t\t\tprintk(KERN_WARNING \"%s: cannot change encap when if is up\\n\",\n \t\t\t\t       p->dev->name);\n \t\t\t\treturn -EBUSY;\n \t\t\t}\n #ifdef CONFIG_ISDN_X25\n \t\t\tif( cprot && cprot -> pops )\n \t\t\t\tcprot -> pops -> proto_del ( cprot );\n \t\t\tp -> cprot = NULL;\n \t\t\tlp -> dops = NULL;\n \t\t\tswitch ( cfg -> p_encap ){\n \t\t\tcase ISDN_NET_ENCAP_X25IFACE:\n \t\t\t\tlp -> dops = &isdn_concap_reliable_dl_dops;\n \t\t\t}\n \t\t\tp -> cprot = isdn_concap_new( cfg -> p_encap );\n #endif\n \t\t}\n \t\tswitch ( cfg->p_encap ) {\n \t\tcase ISDN_NET_ENCAP_SYNCPPP:\n #ifndef CONFIG_ISDN_PPP\n \t\t\tprintk(KERN_WARNING \"%s: SyncPPP support not configured\\n\",\n \t\t\t       p->dev->name);\n \t\t\treturn -EINVAL;\n #else\n \t\t\tp->dev->type = ARPHRD_PPP;\n \t\t\tp->dev->addr_len = 0;\n \t\t\tp->dev->do_ioctl = isdn_ppp_dev_ioctl;\n #endif\n \t\t\tbreak;\n \t\tcase ISDN_NET_ENCAP_X25IFACE:\n #ifndef CONFIG_ISDN_X25\n \t\t\tprintk(KERN_WARNING \"%s: isdn-x25 support not configured\\n\",\n \t\t\t       p->dev->name);\n \t\t\treturn -EINVAL;\n #else\n \t\t\tp->dev->type = ARPHRD_X25;\n \t\t\tp->dev->addr_len = 0;\n #endif\n \t\t\tbreak;\n \t\tcase ISDN_NET_ENCAP_CISCOHDLCK:\n \t\t\tp->dev->do_ioctl = isdn_ciscohdlck_dev_ioctl;\n \t\t\tbreak;\n \t\tdefault:\n \t\t\tif( cfg->p_encap >= 0 &&\n \t\t\t    cfg->p_encap <= ISDN_NET_ENCAP_MAX_ENCAP )\n \t\t\t\tbreak;\n \t\t\tprintk(KERN_WARNING\n \t\t\t       \"%s: encapsulation protocol %d not supported\\n\",\n \t\t\t       p->dev->name, cfg->p_encap);\n \t\t\treturn -EINVAL;\n \t\t}\n \t\tif (strlen(cfg->drvid)) {\n \t\t\tchar *c,\n \t\t\t*e;\n \n \t\t\tdrvidx = -1;\n \t\t\tchidx = -1;\n \t\t\tstrcpy(drvid, cfg->drvid);\n \t\t\tif ((c = strchr(drvid, ','))) {\n \t\t\t\tchidx = (int) simple_strtoul(c + 1, &e, 10);\n \t\t\t\tif (e == c)\n \t\t\t\t\tchidx = -1;\n \t\t\t\t*c = '\\0';\n \t\t\t}\n \t\t\tfor (i = 0; i < ISDN_MAX_DRIVERS; i++)\n \t\t\t\tif (!(strcmp(dev->drvid[i], drvid))) {\n \t\t\t\t\tdrvidx = i;\n \t\t\t\t\tbreak;\n \t\t\t\t}\n \t\t\tif ((drvidx == -1) || (chidx == -1))\n \t\t\t\treturn -ENODEV;\n \t\t} else {\n \t\t\tdrvidx = lp->pre_device;\n \t\t\tchidx = lp->pre_channel;\n \t\t}\n \t\tif (cfg->exclusive > 0) {\n \t\t\tunsigned long flags;\n \n \t\t\tspin_lock_irqsave(&dev->lock, flags);\n \t\t\tif ((i = isdn_get_free_channel(ISDN_USAGE_NET,\n \t\t\t\tlp->l2_proto, lp->l3_proto, drvidx,\n \t\t\t\tchidx, lp->msn)) < 0) {\n \t\t\t\tlp->exclusive = -1;\n \t\t\t\tspin_unlock_irqrestore(&dev->lock, flags);\n \t\t\t\treturn -EBUSY;\n \t\t\t}\n \t\t\tdev->usage[i] = ISDN_USAGE_EXCLUSIVE;\n \t\t\tisdn_info_update();\n \t\t\tspin_unlock_irqrestore(&dev->lock, flags);\n \t\t\tlp->exclusive = i;\n \t\t} else {\n \t\t\tlp->exclusive = -1;\n \t\t\tif ((lp->pre_device != -1) && (cfg->exclusive == -1)) {\n \t\t\t\tisdn_unexclusive_channel(lp->pre_device, lp->pre_channel);\n \t\t\t\tisdn_free_channel(lp->pre_device, lp->pre_channel, ISDN_USAGE_NET);\n \t\t\t\tdrvidx = -1;\n \t\t\t\tchidx = -1;\n \t\t\t}\n \t\t}\n// bug_start\n\t\tstrcpy(lp->msn, cfg->eaz);\n// bug_end\n \t\tlp->pre_device = drvidx;\n \t\tlp->pre_channel = chidx;\n \t\tlp->onhtime = cfg->onhtime;\n \t\tlp->charge = cfg->charge;\n \t\tlp->l2_proto = cfg->l2_proto;\n \t\tlp->l3_proto = cfg->l3_proto;\n \t\tlp->cbdelay = cfg->cbdelay;\n \t\tlp->dialmax = cfg->dialmax;\n \t\tlp->triggercps = cfg->triggercps;\n \t\tlp->slavedelay = cfg->slavedelay * HZ;\n \t\tlp->pppbind = cfg->pppbind;\n \t\tlp->dialtimeout = cfg->dialtimeout >= 0 ? cfg->dialtimeout * HZ : -1;\n \t\tlp->dialwait = cfg->dialwait * HZ;\n \t\tif (cfg->secure)\n \t\t\tlp->flags |= ISDN_NET_SECURE;\n \t\telse\n \t\t\tlp->flags &= ~ISDN_NET_SECURE;\n \t\tif (cfg->cbhup)\n \t\t\tlp->flags |= ISDN_NET_CBHUP;\n \t\telse\n \t\t\tlp->flags &= ~ISDN_NET_CBHUP;\n \t\tswitch (cfg->callback) {\n \t\t\tcase 0:\n \t\t\t\tlp->flags &= ~(ISDN_NET_CALLBACK | ISDN_NET_CBOUT);\n \t\t\t\tbreak;\n \t\t\tcase 1:\n \t\t\t\tlp->flags |= ISDN_NET_CALLBACK;\n \t\t\t\tlp->flags &= ~ISDN_NET_CBOUT;\n \t\t\t\tbreak;\n \t\t\tcase 2:\n \t\t\t\tlp->flags |= ISDN_NET_CBOUT;\n \t\t\t\tlp->flags &= ~ISDN_NET_CALLBACK;\n \t\t\t\tbreak;\n \t\t}\n \t\tlp->flags &= ~ISDN_NET_DIALMODE_MASK;\n \t\tif (cfg->dialmode && !(cfg->dialmode & ISDN_NET_DIALMODE_MASK)) {\n \t\t\tprintk(KERN_WARNING\n \t\t\t     \"Old isdnctrl version detected! Please update.\\n\");\n \t\t\tlp->flags |= ISDN_NET_DM_OFF;\n \t\t}\n \t\telse {\n \t\t\tlp->flags |= cfg->dialmode;\n \t\t}\n \t\tif (cfg->chargehup)\n \t\t\tlp->hupflags |= ISDN_CHARGEHUP;\n \t\telse\n \t\t\tlp->hupflags &= ~ISDN_CHARGEHUP;\n \t\tif (cfg->ihup)\n \t\t\tlp->hupflags |= ISDN_INHUP;\n \t\telse\n \t\t\tlp->hupflags &= ~ISDN_INHUP;\n \t\tif (cfg->chargeint > 10) {\n \t\t\tlp->hupflags |= ISDN_CHARGEHUP | ISDN_HAVECHARGE | ISDN_MANCHARGE;\n \t\t\tlp->chargeint = cfg->chargeint * HZ;\n \t\t}\n \t\tif (cfg->p_encap != lp->p_encap) {\n \t\t\tif (cfg->p_encap == ISDN_NET_ENCAP_RAWIP) {\n \t\t\t\tp->dev->header_ops = NULL;\n \t\t\t\tp->dev->flags = IFF_NOARP|IFF_POINTOPOINT;\n \t\t\t} else {\n \t\t\t\tp->dev->header_ops = &isdn_header_ops;\n \t\t\t\tif (cfg->p_encap == ISDN_NET_ENCAP_ETHER)\n \t\t\t\t\tp->dev->flags = IFF_BROADCAST | IFF_MULTICAST;\n \t\t\t\telse\n \t\t\t\t\tp->dev->flags = IFF_NOARP|IFF_POINTOPOINT;\n \t\t\t}\n \t\t}\n \t\tlp->p_encap = cfg->p_encap;\n \t\treturn 0;\n \t}\n \treturn -ENODEV;\n }\n \n", "target": "// fix_start\n\t\tstrlcpy(lp->msn, cfg->eaz, sizeof(lp->msn));\n// fix_end\n", "cwe": "CWE-119", "cwe_name": "Improper Restriction of Operations within the Bounds of a Memory Buffer", "cve": "CVE-2007-6063", "cve_desc": "Buffer overflow in the isdn_net_setcfg function in isdn_net.c in Linux kernel 2.6.23 allows local users to have an unknown impact via a crafted argument to the isdn_ioctl function.", "project": "linux-2.6", "idx": 215300}
{"source": " static int dccp_setsockopt_change(struct sock *sk, int type,\n \t\t\t\t  struct dccp_so_feat __user *optval)\n {\n \tstruct dccp_so_feat opt;\n \tu8 *val;\n \tint rc;\n \n \tif (copy_from_user(&opt, optval, sizeof(opt)))\n \t\treturn -EFAULT;\n// bug_start\n// bug_end\n \n \tval = kmalloc(opt.dccpsf_len, GFP_KERNEL);\n \tif (!val)\n \t\treturn -ENOMEM;\n \n \tif (copy_from_user(val, opt.dccpsf_val, opt.dccpsf_len)) {\n \t\trc = -EFAULT;\n \t\tgoto out_free_val;\n \t}\n \n \trc = dccp_feat_change(dccp_msk(sk), type, opt.dccpsf_feat,\n \t\t\t      val, opt.dccpsf_len, GFP_KERNEL);\n \tif (rc)\n \t\tgoto out_free_val;\n \n out:\n \treturn rc;\n \n out_free_val:\n \tkfree(val);\n \tgoto out;\n }\n \n", "target": "// fix_start\n\tif (opt.dccpsf_len < 1)\n\t\treturn -EINVAL;\n// fix_end\n", "cwe": "CWE-189", "cwe_name": "Numeric Errors", "cve": "CVE-2008-3276", "cve_desc": "Integer overflow in the dccp_setsockopt_change function in net/dccp/proto.c in the Datagram Congestion Control Protocol (DCCP) subsystem in the Linux kernel 2.6.17-rc1 through 2.6.26.2 allows remote attackers to cause a denial of service (panic) via a crafted integer value, related to Change L and Change R options without at least one byte in the dccpsf_val field.", "project": "linux-2.6", "idx": 215361}
{"source": " sbni_ioctl( struct net_device  *dev,  struct ifreq  *ifr,  int  cmd )\n {\n \tstruct net_local  *nl = (struct net_local *) dev->priv;\n \tstruct sbni_flags  flags;\n \tint  error = 0;\n \n #ifdef CONFIG_SBNI_MULTILINE\n \tstruct net_device  *slave_dev;\n \tchar  slave_name[ 8 ];\n #endif\n \n \tswitch( cmd ) {\n \tcase  SIOCDEVGETINSTATS :\n \t\tif (copy_to_user( ifr->ifr_data, &nl->in_stats,\n \t\t\t\t\tsizeof(struct sbni_in_stats) ))\n \t\t\terror = -EFAULT;\n \t\tbreak;\n \n \tcase  SIOCDEVRESINSTATS :\n// bug_start\n\t\tif( current->euid != 0 )\n// bug_end\n \t\t\treturn  -EPERM;\n \t\tmemset( &nl->in_stats, 0, sizeof(struct sbni_in_stats) );\n \t\tbreak;\n \n \tcase  SIOCDEVGHWSTATE :\n \t\tflags.mac_addr\t= *(u32 *)(dev->dev_addr + 3);\n \t\tflags.rate\t= nl->csr1.rate;\n \t\tflags.slow_mode\t= (nl->state & FL_SLOW_MODE) != 0;\n \t\tflags.rxl\t= nl->cur_rxl_index;\n \t\tflags.fixed_rxl\t= nl->delta_rxl == 0;\n \n \t\tif (copy_to_user( ifr->ifr_data, &flags, sizeof flags ))\n \t\t\terror = -EFAULT;\n \t\tbreak;\n \n \tcase  SIOCDEVSHWSTATE :\n// bug_start\n\t\tif( current->euid != 0 )\n// bug_end\n \t\t\treturn  -EPERM;\n \n \t\tspin_lock( &nl->lock );\n \t\tflags = *(struct sbni_flags*) &ifr->ifr_ifru;\n \t\tif( flags.fixed_rxl )\n \t\t\tnl->delta_rxl = 0,\n \t\t\tnl->cur_rxl_index = flags.rxl;\n \t\telse\n \t\t\tnl->delta_rxl = DEF_RXL_DELTA,\n \t\t\tnl->cur_rxl_index = DEF_RXL;\n \n \t\tnl->csr1.rxl = rxl_tab[ nl->cur_rxl_index ];\n \t\tnl->csr1.rate = flags.rate;\n \t\toutb( *(u8 *)&nl->csr1 | PR_RES, dev->base_addr + CSR1 );\n \t\tspin_unlock( &nl->lock );\n \t\tbreak;\n \n #ifdef CONFIG_SBNI_MULTILINE\n \n \tcase  SIOCDEVENSLAVE :\n// bug_start\n\t\tif( current->euid != 0 )\n// bug_end\n \t\t\treturn  -EPERM;\n \n \t\tif (copy_from_user( slave_name, ifr->ifr_data, sizeof slave_name ))\n \t\t\treturn -EFAULT;\n \t\tslave_dev = dev_get_by_name(&init_net, slave_name );\n \t\tif( !slave_dev  ||  !(slave_dev->flags & IFF_UP) ) {\n \t\t\tprintk( KERN_ERR \"%s: trying to enslave non-active \"\n \t\t\t\t\"device %s\\n\", dev->name, slave_name );\n \t\t\treturn  -EPERM;\n \t\t}\n \n \t\treturn  enslave( dev, slave_dev );\n \n \tcase  SIOCDEVEMANSIPATE :\n// bug_start\n\t\tif( current->euid != 0 )\n// bug_end\n \t\t\treturn  -EPERM;\n \n \t\treturn  emancipate( dev );\n \n #endif\n \n \tdefault :\n \t\treturn  -EOPNOTSUPP;\n \t}\n \n \treturn  error;\n }\n \n", "target": "// fix_start\n\t\tif (!capable(CAP_NET_ADMIN))\n// fix_end\n// fix_start\n\t\tif (!capable(CAP_NET_ADMIN))\n// fix_end\n// fix_start\n\t\tif (!capable(CAP_NET_ADMIN))\n// fix_end\n// fix_start\n\t\tif (!capable(CAP_NET_ADMIN))\n// fix_end\n", "cwe": "CWE-264", "cwe_name": "Permissions, Privileges, and Access Controls", "cve": "CVE-2008-3525", "cve_desc": "The sbni_ioctl function in drivers/net/wan/sbni.c in the wan subsystem in the Linux kernel 2.6.26.3 does not check for the CAP_NET_ADMIN capability before processing a (1) SIOCDEVRESINSTATS, (2) SIOCDEVSHWSTATE, (3) SIOCDEVENSLAVE, or (4) SIOCDEVEMANSIPATE ioctl request, which allows local users to bypass intended capability restrictions.", "project": "linux-2.6", "idx": 215379}
{"source": " static int svc_listen(struct socket *sock,int backlog)\n {\n \tDEFINE_WAIT(wait);\n \tstruct sock *sk = sock->sk;\n \tstruct atm_vcc *vcc = ATM_SD(sock);\n \tint error;\n \n \tpr_debug(\"svc_listen %p\\n\",vcc);\n \tlock_sock(sk);\n \tif (test_bit(ATM_VF_SESSION,&vcc->flags)) {\n \t\terror = -EINVAL;\n \t\tgoto out;\n \t}\n// bug_start\n\tvcc_insert_socket(sk);\n// bug_end\n \tset_bit(ATM_VF_WAITING, &vcc->flags);\n \tprepare_to_wait(sk->sk_sleep, &wait, TASK_UNINTERRUPTIBLE);\n \tsigd_enq(vcc,as_listen,NULL,NULL,&vcc->local);\n \twhile (test_bit(ATM_VF_WAITING, &vcc->flags) && sigd) {\n \t\tschedule();\n \t\tprepare_to_wait(sk->sk_sleep, &wait, TASK_UNINTERRUPTIBLE);\n \t}\n \tfinish_wait(sk->sk_sleep, &wait);\n \tif (!sigd) {\n \t\terror = -EUNATCH;\n \t\tgoto out;\n \t}\n \tset_bit(ATM_VF_LISTEN,&vcc->flags);\n// bug_start\n// bug_end\n \tsk->sk_max_ack_backlog = backlog > 0 ? backlog : ATM_BACKLOG_DEFAULT;\n \terror = -sk->sk_err;\n out:\n \trelease_sock(sk);\n \treturn error;\n }\n \n", "target": "// fix_start\n\tif (test_bit(ATM_VF_LISTEN, &vcc->flags)) {\n\t\terror = -EADDRINUSE;\n\t\tgoto out;\n        }\n// fix_end\n// fix_start\n\tvcc_insert_socket(sk);\n// fix_end\n", "cwe": "CWE-399", "cwe_name": "Resource Management Errors", "cve": "CVE-2008-5079", "cve_desc": "net/atm/svc.c in the ATM subsystem in the Linux kernel 2.6.27.8 and earlier allows local users to cause a denial of service (kernel infinite loop) by making two calls to svc_listen for the same socket, and then reading a /proc/net/atm/*vc file, related to corruption of the vcc table.", "project": "linux-2.6", "idx": 215446}
{"source": " int ext4_group_add(struct super_block *sb, struct ext4_new_group_data *input)\n {\n \tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n \tstruct ext4_super_block *es = sbi->s_es;\n \tint reserved_gdb = ext4_bg_has_super(sb, input->group) ?\n \t\tle16_to_cpu(es->s_reserved_gdt_blocks) : 0;\n \tstruct buffer_head *primary = NULL;\n \tstruct ext4_group_desc *gdp;\n \tstruct inode *inode = NULL;\n \thandle_t *handle;\n \tint gdb_off, gdb_num;\n \tint num_grp_locked = 0;\n \tint err, err2;\n \n \tgdb_num = input->group / EXT4_DESC_PER_BLOCK(sb);\n \tgdb_off = input->group % EXT4_DESC_PER_BLOCK(sb);\n \n \tif (gdb_off == 0 && !EXT4_HAS_RO_COMPAT_FEATURE(sb,\n \t\t\t\t\tEXT4_FEATURE_RO_COMPAT_SPARSE_SUPER)) {\n \t\text4_warning(sb, __func__,\n \t\t\t     \"Can't resize non-sparse filesystem further\");\n \t\treturn -EPERM;\n \t}\n \n \tif (ext4_blocks_count(es) + input->blocks_count <\n \t    ext4_blocks_count(es)) {\n \t\text4_warning(sb, __func__, \"blocks_count overflow\");\n \t\treturn -EINVAL;\n \t}\n \n \tif (le32_to_cpu(es->s_inodes_count) + EXT4_INODES_PER_GROUP(sb) <\n \t    le32_to_cpu(es->s_inodes_count)) {\n \t\text4_warning(sb, __func__, \"inodes_count overflow\");\n \t\treturn -EINVAL;\n \t}\n \n \tif (reserved_gdb || gdb_off == 0) {\n \t\tif (!EXT4_HAS_COMPAT_FEATURE(sb,\n \t\t\t\t\t     EXT4_FEATURE_COMPAT_RESIZE_INODE)\n \t\t    || !le16_to_cpu(es->s_reserved_gdt_blocks)) {\n \t\t\text4_warning(sb, __func__,\n \t\t\t\t     \"No reserved GDT blocks, can't resize\");\n \t\t\treturn -EPERM;\n \t\t}\n \t\tinode = ext4_iget(sb, EXT4_RESIZE_INO);\n \t\tif (IS_ERR(inode)) {\n \t\t\text4_warning(sb, __func__,\n \t\t\t\t     \"Error opening resize inode\");\n \t\t\treturn PTR_ERR(inode);\n \t\t}\n \t}\n \n \n \tif ((err = verify_group_input(sb, input)))\n \t\tgoto exit_put;\n \n \tif ((err = setup_new_group_blocks(sb, input)))\n \t\tgoto exit_put;\n \n \thandle = ext4_journal_start_sb(sb,\n \t\t\t\t       ext4_bg_has_super(sb, input->group) ?\n \t\t\t\t       3 + reserved_gdb : 4);\n \tif (IS_ERR(handle)) {\n \t\terr = PTR_ERR(handle);\n \t\tgoto exit_put;\n \t}\n \n \tlock_super(sb);\n \tif (input->group != sbi->s_groups_count) {\n \t\text4_warning(sb, __func__,\n \t\t\t     \"multiple resizers run on filesystem!\");\n \t\terr = -EBUSY;\n \t\tgoto exit_journal;\n \t}\n \n \tif ((err = ext4_journal_get_write_access(handle, sbi->s_sbh)))\n \t\tgoto exit_journal;\n \n \tif (gdb_off) {\n \t\tprimary = sbi->s_group_desc[gdb_num];\n \t\tif ((err = ext4_journal_get_write_access(handle, primary)))\n \t\t\tgoto exit_journal;\n \n \t\tif (reserved_gdb && ext4_bg_num_gdb(sb, input->group) &&\n \t\t    (err = reserve_backup_gdb(handle, inode, input)))\n \t\t\tgoto exit_journal;\n \t} else if ((err = add_new_gdb(handle, inode, input, &primary)))\n \t\tgoto exit_journal;\n \n \n \tnum_grp_locked = ext4_mb_get_buddy_cache_lock(sb, input->group);\n \tgdp = (struct ext4_group_desc *)((char *)primary->b_data +\n \t\t\t\t\t gdb_off * EXT4_DESC_SIZE(sb));\n \n// bug_start\n// bug_end\n \text4_block_bitmap_set(sb, gdp, input->block_bitmap);\n \text4_inode_bitmap_set(sb, gdp, input->inode_bitmap);\n \text4_inode_table_set(sb, gdp, input->inode_table);\n \text4_free_blks_set(sb, gdp, input->free_blocks_count);\n \text4_free_inodes_set(sb, gdp, EXT4_INODES_PER_GROUP(sb));\n// bug_start\n\tgdp->bg_flags |= cpu_to_le16(EXT4_BG_INODE_ZEROED);\n// bug_end\n \tgdp->bg_checksum = ext4_group_desc_csum(sbi, input->group, gdp);\n \n \terr = ext4_mb_add_groupinfo(sb, input->group, gdp);\n \tif (err) {\n \t\text4_mb_put_buddy_cache_lock(sb, input->group, num_grp_locked);\n \t\tgoto exit_journal;\n \t}\n \n \text4_blocks_count_set(es, ext4_blocks_count(es) +\n \t\tinput->blocks_count);\n \tle32_add_cpu(&es->s_inodes_count, EXT4_INODES_PER_GROUP(sb));\n \n \tsmp_wmb();\n \n \tsbi->s_groups_count++;\n \text4_mb_put_buddy_cache_lock(sb, input->group, num_grp_locked);\n \n \text4_handle_dirty_metadata(handle, NULL, primary);\n \n \text4_r_blocks_count_set(es, ext4_r_blocks_count(es) +\n \t\tinput->reserved_blocks);\n \n \tpercpu_counter_add(&sbi->s_freeblocks_counter,\n \t\t\t   input->free_blocks_count);\n \tpercpu_counter_add(&sbi->s_freeinodes_counter,\n \t\t\t   EXT4_INODES_PER_GROUP(sb));\n \n \tif (EXT4_HAS_INCOMPAT_FEATURE(sb, EXT4_FEATURE_INCOMPAT_FLEX_BG)) {\n \t\text4_group_t flex_group;\n \t\tflex_group = ext4_flex_group(sbi, input->group);\n \t\tsbi->s_flex_groups[flex_group].free_blocks +=\n \t\t\tinput->free_blocks_count;\n \t\tsbi->s_flex_groups[flex_group].free_inodes +=\n \t\t\tEXT4_INODES_PER_GROUP(sb);\n \t}\n \n \text4_handle_dirty_metadata(handle, NULL, sbi->s_sbh);\n \tsb->s_dirt = 1;\n \n exit_journal:\n \tunlock_super(sb);\n \tif ((err2 = ext4_journal_stop(handle)) && !err)\n \t\terr = err2;\n \tif (!err) {\n \t\tupdate_backups(sb, sbi->s_sbh->b_blocknr, (char *)es,\n \t\t\t       sizeof(struct ext4_super_block));\n \t\tupdate_backups(sb, primary->b_blocknr, primary->b_data,\n \t\t\t       primary->b_size);\n \t}\n exit_put:\n \tiput(inode);\n \treturn err;\n }\n \n", "target": "// fix_start\n\tmemset(gdp, 0, EXT4_DESC_SIZE(sb));\n// fix_end\n// fix_start\n\tgdp->bg_flags = cpu_to_le16(EXT4_BG_INODE_ZEROED);\n// fix_end\n", "cwe": "CWE-20", "cwe_name": "Improper Input Validation", "cve": "CVE-2009-0745", "cve_desc": "The ext4_group_add function in fs/ext4/resize.c in the Linux kernel 2.6.27 before 2.6.27.19 and 2.6.28 before 2.6.28.7 does not properly initialize the group descriptor during a resize (aka resize2fs) operation, which might allow local users to cause a denial of service (OOPS) by arranging for crafted values to be present in available memory.", "project": "linux-2.6", "idx": 215458}
{"source": "// bug_start\necryptfs_write_metadata_to_contents(struct ecryptfs_crypt_stat *crypt_stat,\n\t\t\t\t    struct dentry *ecryptfs_dentry,\n\t\t\t\t    char *virt)\n// bug_end\n {\n \tint rc;\n \n \trc = ecryptfs_write_lower(ecryptfs_dentry->d_inode, virt,\n// bug_start\n\t\t\t\t  0, crypt_stat->num_header_bytes_at_front);\n// bug_end\n \tif (rc)\n \t\tprintk(KERN_ERR \"%s: Error attempting to write header \"\n \t\t       \"information to lower file; rc = [%d]\\n\", __func__,\n \t\t       rc);\n \treturn rc;\n }\n \n", "target": "// fix_start\necryptfs_write_metadata_to_contents(struct dentry *ecryptfs_dentry,\n\t\t\t\t    char *virt, size_t virt_len)\n// fix_end\n// fix_start\n\t\t\t\t  0, virt_len);\n// fix_end\n", "cwe": "CWE-189", "cwe_name": "Numeric Errors", "cve": "CVE-2009-0787", "cve_desc": "The ecryptfs_write_metadata_to_contents function in the eCryptfs functionality in the Linux kernel 2.6.28 before 2.6.28.9 uses an incorrect size when writing kernel memory to an eCryptfs file header, which triggers an out-of-bounds read and allows local users to obtain portions of kernel memory.", "project": "linux-2.6", "idx": 215467}
{"source": " size_t util_path_encode(char *s, size_t len)\n {\n// bug_start\n\tchar t[(len * 3)+1];\n// bug_end\n \tsize_t i, j;\n \n \tfor (i = 0, j = 0; s[i] != '\\0'; i++) {\n \t\tif (s[i] == '/') {\n \t\t\tmemcpy(&t[j], \"\\\\x2f\", 4);\n \t\t\tj += 4;\n \t\t} else if (s[i] == '\\\\') {\n \t\t\tmemcpy(&t[j], \"\\\\x5c\", 4);\n \t\t\tj += 4;\n \t\t} else {\n \t\t\tt[j] = s[i];\n \t\t\tj++;\n \t\t}\n \t}\n \tif (len == 0)\n \t\treturn j;\n \ti = (j < len - 1) ? j : len - 1;\n \tmemcpy(s, t, i);\n \ts[i] = '\\0';\n \treturn j;\n }\n \n", "target": "// fix_start\n\tchar t[(len * 4)+1];\n// fix_end\n", "cwe": "CWE-120", "cwe_name": "Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')", "cve": "CVE-2009-1186", "cve_desc": "Buffer overflow in the util_path_encode function in udev/lib/libudev-util.c in udev before 1.4.1 allows local users to cause a denial of service (service outage) via vectors that trigger a call with crafted arguments.", "project": "udev", "idx": 215481}
{"source": " long keyctl_session_to_parent(void)\n {\n #ifdef TIF_NOTIFY_RESUME\n \tstruct task_struct *me, *parent;\n \tconst struct cred *mycred, *pcred;\n \tstruct cred *cred, *oldcred;\n \tkey_ref_t keyring_r;\n \tint ret;\n \n \tkeyring_r = lookup_user_key(KEY_SPEC_SESSION_KEYRING, 0, KEY_LINK);\n \tif (IS_ERR(keyring_r))\n \t\treturn PTR_ERR(keyring_r);\n \n \tret = -ENOMEM;\n \tcred = cred_alloc_blank();\n \tif (!cred)\n \t\tgoto error_keyring;\n \n \tcred->tgcred->session_keyring = key_ref_to_ptr(keyring_r);\n \tkeyring_r = NULL;\n \n \tme = current;\n \trcu_read_lock();\n \twrite_lock_irq(&tasklist_lock);\n \n \tparent = me->real_parent;\n \tret = -EPERM;\n \n \tif (parent->pid <= 1 || !parent->mm)\n \t\tgoto not_permitted;\n \n \tif (!thread_group_empty(parent))\n \t\tgoto not_permitted;\n \n \tmycred = current_cred();\n \tpcred = __task_cred(parent);\n \tif (mycred == pcred ||\n \t    mycred->tgcred->session_keyring == pcred->tgcred->session_keyring)\n \t\tgoto already_same;\n \n \tif (pcred->uid\t!= mycred->euid\t||\n \t    pcred->euid\t!= mycred->euid\t||\n \t    pcred->suid\t!= mycred->euid\t||\n \t    pcred->gid\t!= mycred->egid\t||\n \t    pcred->egid\t!= mycred->egid\t||\n \t    pcred->sgid\t!= mycred->egid)\n \t\tgoto not_permitted;\n \n// bug_start\n\tif (pcred->tgcred->session_keyring->uid != mycred->euid ||\n// bug_end\n \t    mycred->tgcred->session_keyring->uid != mycred->euid)\n \t\tgoto not_permitted;\n \n \toldcred = parent->replacement_session_keyring;\n \n \tparent->replacement_session_keyring = cred;\n \tcred = NULL;\n \tset_ti_thread_flag(task_thread_info(parent), TIF_NOTIFY_RESUME);\n \n \twrite_unlock_irq(&tasklist_lock);\n \trcu_read_unlock();\n \tif (oldcred)\n \t\tput_cred(oldcred);\n \treturn 0;\n \n already_same:\n \tret = 0;\n not_permitted:\n \twrite_unlock_irq(&tasklist_lock);\n \trcu_read_unlock();\n \tput_cred(cred);\n \treturn ret;\n \n error_keyring:\n \tkey_ref_put(keyring_r);\n \treturn ret;\n \n #else\n #warning TIF_NOTIFY_RESUME not implemented\n \treturn -EOPNOTSUPP;\n #endif\n }\n \n", "target": "// fix_start\n\tif ((pcred->tgcred->session_keyring &&\n\t     pcred->tgcred->session_keyring->uid != mycred->euid) ||\n// fix_end\n", "cwe": "CWE-476", "cwe_name": "NULL Pointer Dereference", "cve": "CVE-2010-2960", "cve_desc": "The keyctl_session_to_parent function in security/keys/keyctl.c in the Linux kernel 2.6.35.4 and earlier expects that a certain parent session keyring exists, which allows local users to cause a denial of service (NULL pointer dereference and system crash) or possibly have unspecified other impact via a KEYCTL_SESSION_TO_PARENT argument to the keyctl function.", "project": "linux-2.6", "idx": 215590}
{"source": " grep (int fd, char const *file, struct stats *stats)\n {\n// bug_start\n  int nlines, i;\n// bug_end\n   int not_text;\n   size_t residue, save;\n   char oldc;\n   char *beg;\n   char *lim;\n   char eol = eolbyte;\n \n   if (!reset (fd, file, stats))\n     return 0;\n \n   if (file && directories == RECURSE_DIRECTORIES\n       && S_ISDIR (stats->stat.st_mode))\n     {\n       if (close (fd) != 0)\n         suppressible_error (file, errno);\n       return grepdir (file, stats) - 2;\n     }\n \n   totalcc = 0;\n   lastout = 0;\n   totalnl = 0;\n   outleft = max_count;\n   after_last_match = 0;\n   pending = 0;\n \n   nlines = 0;\n   residue = 0;\n   save = 0;\n \n   if (! fillbuf (save, stats))\n     {\n       suppressible_error (filename, errno);\n       return 0;\n     }\n \n   not_text = (((binary_files == BINARY_BINARY_FILES && !out_quiet)\n                || binary_files == WITHOUT_MATCH_BINARY_FILES)\n               && memchr (bufbeg, eol ? '\\0' : '\\200', buflim - bufbeg));\n   if (not_text && binary_files == WITHOUT_MATCH_BINARY_FILES)\n     return 0;\n   done_on_match += not_text;\n   out_quiet += not_text;\n \n   for (;;)\n     {\n       lastnl = bufbeg;\n       if (lastout)\n         lastout = bufbeg;\n \n       beg = bufbeg + save;\n \n       if (beg == buflim)\n         break;\n \n       oldc = beg[-1];\n       beg[-1] = eol;\n       for (lim = buflim; lim[-1] != eol; lim--)\n         continue;\n       beg[-1] = oldc;\n       if (lim == beg)\n         lim = beg - residue;\n       beg -= residue;\n       residue = buflim - lim;\n \n       if (beg < lim)\n         {\n           if (outleft)\n             nlines += grepbuf (beg, lim);\n           if (pending)\n             prpending (lim);\n           if ((!outleft && !pending) || (nlines && done_on_match && !out_invert))\n             goto finish_grep;\n         }\n \n       i = 0;\n       beg = lim;\n       while (i < out_before && beg > bufbeg && beg != lastout)\n         {\n           ++i;\n           do\n             --beg;\n           while (beg[-1] != eol);\n         }\n \n       if (beg != lastout)\n         lastout = 0;\n \n       save = residue + lim - beg;\n       if (out_byte)\n         totalcc = add_count (totalcc, buflim - bufbeg - save);\n       if (out_line)\n         nlscan (beg);\n       if (! fillbuf (save, stats))\n         {\n           suppressible_error (filename, errno);\n           goto finish_grep;\n         }\n     }\n   if (residue)\n     {\n       *buflim++ = eol;\n       if (outleft)\n         nlines += grepbuf (bufbeg + save - residue, buflim);\n       if (pending)\n         prpending (buflim);\n     }\n \n  finish_grep:\n   done_on_match -= not_text;\n   out_quiet -= not_text;\n   if ((not_text & ~out_quiet) && nlines != 0)\n     printf (_(\"Binary file %s matches\\n\"), filename);\n   return nlines;\n }\n \n", "target": "// fix_start\n  intmax_t nlines, i;\n// fix_end\n", "cwe": "CWE-189", "cwe_name": "Numeric Errors", "cve": "CVE-2012-5667", "cve_desc": "Multiple integer overflows in GNU Grep before 2.11 might allow context-dependent attackers to execute arbitrary code via vectors involving a long input line that triggers a heap-based buffer overflow.", "project": "grep", "idx": 215830}
{"source": " translate_hierarchy_event (ClutterBackendX11       *backend_x11,\n                            ClutterDeviceManagerXI2 *manager_xi2,\n                            XIHierarchyEvent        *ev)\n {\n   int i;\n \n   for (i = 0; i < ev->num_info; i++)\n     {\n       if (ev->info[i].flags & XIDeviceEnabled)\n         {\n           XIDeviceInfo *info;\n           int n_devices;\n \n           CLUTTER_NOTE (EVENT, \"Hierarchy event: device enabled\");\n \n// bug_start\n// bug_end\n           info = XIQueryDevice (backend_x11->xdpy,\n                                 ev->info[i].deviceid,\n                                 &n_devices);\n// bug_start\n          add_device (manager_xi2, backend_x11, &info[0], FALSE);\n// bug_end\n         }\n       else if (ev->info[i].flags & XIDeviceDisabled)\n         {\n           CLUTTER_NOTE (EVENT, \"Hierarchy event: device disabled\");\n \n           remove_device (manager_xi2, ev->info[i].deviceid);\n         }\n       else if ((ev->info[i].flags & XISlaveAttached) ||\n                (ev->info[i].flags & XISlaveDetached))\n         {\n           ClutterInputDevice *master, *slave;\n           XIDeviceInfo *info;\n           int n_devices;\n           gboolean send_changed = FALSE;\n \n           CLUTTER_NOTE (EVENT, \"Hierarchy event: slave %s\",\n                         (ev->info[i].flags & XISlaveAttached)\n                           ? \"attached\"\n                           : \"detached\");\n \n           slave = g_hash_table_lookup (manager_xi2->devices_by_id,\n                                        GINT_TO_POINTER (ev->info[i].deviceid));\n           master = clutter_input_device_get_associated_device (slave);\n \n           if (master != NULL)\n             {\n               _clutter_input_device_remove_slave (master, slave);\n               _clutter_input_device_set_associated_device (slave, NULL);\n \n               send_changed = TRUE;\n             }\n \n           if (ev->info[i].flags & XISlaveAttached)\n             {\n// bug_start\n// bug_end\n               info = XIQueryDevice (backend_x11->xdpy,\n                                     ev->info[i].deviceid,\n                                     &n_devices);\n// bug_start\n              master = g_hash_table_lookup (manager_xi2->devices_by_id,\n                                            GINT_TO_POINTER (info->attachment));\n              _clutter_input_device_set_associated_device (slave, master);\n              _clutter_input_device_add_slave (master, slave);\n// bug_end\n \n// bug_start\n              send_changed = TRUE;\n              XIFreeDeviceInfo (info);\n// bug_end\n             }\n \n           if (send_changed)\n             {\n               ClutterStage *stage = _clutter_input_device_get_stage (master);\n               if (stage != NULL)\n                 _clutter_stage_x11_events_device_changed (CLUTTER_STAGE_X11 (_clutter_stage_get_window (stage)),\n                                                           master,\n                                                           CLUTTER_DEVICE_MANAGER (manager_xi2));\n             }\n         }\n     }\n }\n \n", "target": "// fix_start\n          clutter_x11_trap_x_errors ();\n// fix_end\n// fix_start\n          clutter_x11_untrap_x_errors ();\n          if (info != NULL)\n            {\n              add_device (manager_xi2, backend_x11, &info[0], FALSE);\n              XIFreeDeviceInfo (info);\n            }\n// fix_end\n// fix_start\n              clutter_x11_trap_x_errors ();\n// fix_end\n// fix_start\n              clutter_x11_untrap_x_errors ();\n              if (info != NULL)\n                {\n                  master = g_hash_table_lookup (manager_xi2->devices_by_id,\n                                                GINT_TO_POINTER (info->attachment));\n                  if (master != NULL)\n                    {\n                      _clutter_input_device_set_associated_device (slave, master);\n                      _clutter_input_device_add_slave (master, slave);\n// fix_end\n// fix_start\n                      send_changed = TRUE;\n                    }\n                  XIFreeDeviceInfo (info);\n                }\n// fix_end\n", "cwe": "CWE-264", "cwe_name": "Permissions, Privileges, and Access Controls", "cve": "CVE-2013-2190", "cve_desc": "The translate_hierarchy_event function in x11/clutter-device-manager-xi2.c in Clutter, when resuming the system, does not properly handle XIQueryDevice errors when a device has \"disappeared,\" which causes the gnome-shell to crash and allows physically proximate attackers to access the previous gnome-shell session via unspecified vectors.", "project": "clutter", "idx": 215902}
{"source": " ms_escher_get_data (MSEscherState *state,\n \t\t    gint offset,\n \t\t    gint num_bytes,\n \t\t    gboolean * needs_free)\n {\n \tBiffQuery *q = state->q;\n \tguint8    *res;\n \n \tg_return_val_if_fail (offset >= state->start_offset, NULL);\n \n \twhile (offset >= state->end_offset) {\n \t\tif (!ms_biff_query_next (q)) {\n \t\t\tg_warning (\"unexpected end of stream;\");\n \t\t\treturn NULL;\n \t\t}\n \n \t\tif (q->opcode != BIFF_MS_O_DRAWING &&\n \t\t    q->opcode != BIFF_MS_O_DRAWING_GROUP &&\n \t\t    q->opcode != BIFF_MS_O_DRAWING_SELECTION &&\n \t\t    q->opcode != BIFF_CHART_gelframe &&\n \t\t    q->opcode != BIFF_CONTINUE) {\n \t\t  g_warning (\"Unexpected record type 0x%x len=0x%x @ 0x%lx;\", q->opcode, q->length, (long)q->streamPos);\n \t\t\treturn NULL;\n \t\t}\n \n \t\td (1, g_printerr (\"Target is 0x%x bytes at 0x%x, current = 0x%x..0x%x;\\n\"\n \t\t\t      \"Adding biff-0x%x of length 0x%x;\\n\",\n \t\t\t      num_bytes, offset,\n \t\t\t      state->start_offset,\n \t\t\t      state->end_offset,\n \t\t\t      q->opcode, q->length););\n \n \t\tstate->start_offset = state->end_offset;\n \t\tstate->end_offset += q->length;\n \t\tstate->segment_len = q->length;\n \t}\n \n \tg_return_val_if_fail (offset >= state->start_offset, NULL);\n \tg_return_val_if_fail ((size_t)(offset - state->start_offset) < q->length, NULL);\n \n \tres = q->data + offset - state->start_offset;\n \tif ((*needs_free = ((offset + num_bytes) > state->end_offset))) {\n \t\tguint8 *buffer = g_malloc (num_bytes);\n \t\tguint8 *tmp = buffer;\n \n \t\tint len = q->length - (res - q->data);\n \t\tint counter = 0;\n \n// bug_start\n\t\td (1, g_printerr (\"MERGE needed (%d) which is >= %d + %d;\\n\",\n// bug_end\n \t\t\t      num_bytes, offset, state->end_offset););\n \n \t\tdo {\n// bug_start\n// bug_end\n \t\t\td (1, g_printerr (\"record %d) add %d bytes;\\n\", ++counter, len););\n// bug_start\n// bug_end\n \t\t\tmemcpy (tmp, res, len);\n \t\t\ttmp += len;\n \n \t\t\tif (!ms_biff_query_next (q)) {\n \t\t\t\tg_warning (\"unexpected end of stream;\");\n \t\t\t\treturn NULL;\n \t\t\t}\n \n \t\t\tif (q->opcode != BIFF_MS_O_DRAWING &&\n \t\t\t    q->opcode != BIFF_MS_O_DRAWING_GROUP &&\n \t\t\t    q->opcode != BIFF_MS_O_DRAWING_SELECTION &&\n \t\t\t    q->opcode != BIFF_CHART_gelframe &&\n \t\t\t    q->opcode != BIFF_CONTINUE) {\n// bug_start\n\t\t\t  g_warning (\"Unexpected record type 0x%x @ 0x%lx;\", q->opcode, (long)q->streamPos);\n// bug_end\n \t\t\t\treturn NULL;\n \t\t\t}\n \n \t\t\tstate->start_offset = state->end_offset;\n \t\t\tstate->end_offset += q->length;\n \t\t\tstate->segment_len = q->length;\n \n \t\t\tres = q->data;\n \t\t\tlen = q->length;\n \n \t\t} while ((num_bytes - (tmp - buffer)) > len);\n \n \t\tmemcpy (tmp, res, num_bytes - (tmp-buffer));\n \t\td (1, g_printerr (\"record %d) add %d bytes;\\n\",\n \t\t\t      ++counter,\n \t\t\t      num_bytes - (int)(tmp-buffer)););\n \t\treturn buffer;\n \t}\n \n \treturn res;\n }\n \n", "target": "// fix_start\n\t\td (1, g_printerr (\"MERGE needed (%d) which is >= -%d + %d;\\n\",\n// fix_end\n// fix_start\n\t\t\tint maxlen = (buffer + num_bytes) - tmp;\n\t\t\tlen = MIN (len, maxlen);\n// fix_end\n// fix_start\n\n// fix_end\n// fix_start\n\t\t\t\tg_warning (\"Unexpected record type 0x%x @ 0x%lx;\", q->opcode, (long)q->streamPos);\n\t\t\t\tg_free (buffer);\n// fix_end\n", "cwe": "CWE-119", "cwe_name": "Improper Restriction of Operations within the Bounds of a Memory Buffer", "cve": "CVE-2013-6836", "cve_desc": "Heap-based buffer overflow in the ms_escher_get_data function in plugins/excel/ms-escher.c in GNOME Office Gnumeric before 1.12.9 allows remote attackers to cause a denial of service (crash) via a crafted xls file with a crafted length value.", "project": "gnumeric", "idx": 215903}
{"source": " int ssh_bind_accept_fd(ssh_bind sshbind, ssh_session session, socket_t fd){\n     int i, rc;\n \n     if (session == NULL){\n         ssh_set_error(sshbind, SSH_FATAL,\"session is null\");\n         return SSH_ERROR;\n     }\n \n     session->server = 1;\n     session->version = 2;\n \n     for (i = 0; i < 10; ++i) {\n       if (sshbind->wanted_methods[i]) {\n         session->opts.wanted_methods[i] = strdup(sshbind->wanted_methods[i]);\n         if (session->opts.wanted_methods[i] == NULL) {\n           return SSH_ERROR;\n         }\n       }\n     }\n \n     if (sshbind->bindaddr == NULL)\n       session->opts.bindaddr = NULL;\n     else {\n       SAFE_FREE(session->opts.bindaddr);\n       session->opts.bindaddr = strdup(sshbind->bindaddr);\n       if (session->opts.bindaddr == NULL) {\n         return SSH_ERROR;\n       }\n     }\n \n     session->common.log_verbosity = sshbind->common.log_verbosity;\n     if(sshbind->banner != NULL)\n     \tsession->opts.custombanner = strdup(sshbind->banner);\n     ssh_socket_free(session->socket);\n     session->socket = ssh_socket_new(session);\n     if (session->socket == NULL) {\n       ssh_set_error_oom(sshbind);\n       return SSH_ERROR;\n     }\n     ssh_socket_set_fd(session->socket, fd);\n     ssh_socket_get_poll_handle_out(session->socket);\n \n     rc = ssh_bind_import_keys(sshbind);\n     if (rc != SSH_OK) {\n       return SSH_ERROR;\n     }\n \n #ifdef HAVE_ECC\n     if (sshbind->ecdsa) {\n         session->srv.ecdsa_key = ssh_key_dup(sshbind->ecdsa);\n         if (session->srv.ecdsa_key == NULL) {\n           ssh_set_error_oom(sshbind);\n           return SSH_ERROR;\n         }\n     }\n #endif\n     if (sshbind->dsa) {\n         session->srv.dsa_key = ssh_key_dup(sshbind->dsa);\n         if (session->srv.dsa_key == NULL) {\n           ssh_set_error_oom(sshbind);\n           return SSH_ERROR;\n         }\n     }\n     if (sshbind->rsa) {\n         session->srv.rsa_key = ssh_key_dup(sshbind->rsa);\n         if (session->srv.rsa_key == NULL) {\n           ssh_set_error_oom(sshbind);\n           return SSH_ERROR;\n         }\n     }\n// bug_start\n// bug_end\n     return SSH_OK;\n }\n \n", "target": "// fix_start\n    ssh_reseed();\n// fix_end\n", "cwe": "CWE-310", "cwe_name": "Cryptographic Issues", "cve": "CVE-2014-0017", "cve_desc": "The RAND_bytes function in libssh before 0.6.3, when forking is enabled, does not properly reset the state of the OpenSSL pseudo-random number generator (PRNG), which causes the state to be shared between children processes and allows local users to obtain sensitive information by leveraging a pid collision.", "project": "libssh", "idx": 215904}
{"source": " load_image (const gchar  *filename,\n             GError      **error)\n {\n   FILE     *fp;\n   tga_info  info;\n   guchar    header[18];\n   guchar    footer[26];\n   guchar    extension[495];\n   long      offset;\n \n   gint32 image_ID = -1;\n \n   fp = g_fopen (filename, \"rb\");\n \n   if (! fp)\n     {\n       g_set_error (error, G_FILE_ERROR, g_file_error_from_errno (errno),\n                    _(\"Could not open '%s' for reading: %s\"),\n                    gimp_filename_to_utf8 (filename), g_strerror (errno));\n       return -1;\n     }\n \n   gimp_progress_init_printf (_(\"Opening '%s'\"),\n                              gimp_filename_to_utf8 (filename));\n \n   if (!fseek (fp, -26L, SEEK_END))\n     {\n       if (fread (footer, sizeof (footer), 1, fp) != 1)\n         {\n           g_message (_(\"Cannot read footer from '%s'\"),\n                      gimp_filename_to_utf8 (filename));\n           return -1;\n         }\n       else if (memcmp (footer + 8, magic, sizeof (magic)) == 0)\n         {\n \n           offset = (footer[0]          +\n                     footer[1] * 256L   +\n                     footer[2] * 65536L +\n                     footer[3] * 16777216L);\n \n           if (offset != 0)\n             {\n               if (fseek (fp, offset, SEEK_SET) ||\n                   fread (extension, sizeof (extension), 1, fp) != 1)\n                 {\n                   g_message (_(\"Cannot read extension from '%s'\"),\n                              gimp_filename_to_utf8 (filename));\n                   return -1;\n                 }\n             }\n         }\n     }\n \n   if (fseek (fp, 0, SEEK_SET) ||\n       fread (header, sizeof (header), 1, fp) != 1)\n     {\n       g_message (_(\"Cannot read header from '%s'\"),\n                  gimp_filename_to_utf8 (filename));\n       return -1;\n     }\n \n   switch (header[2])\n     {\n     case 1:\n       info.imageType        = TGA_TYPE_MAPPED;\n       info.imageCompression = TGA_COMP_NONE;\n       break;\n     case 2:\n       info.imageType        = TGA_TYPE_COLOR;\n       info.imageCompression = TGA_COMP_NONE;\n       break;\n     case 3:\n       info.imageType        = TGA_TYPE_GRAY;\n       info.imageCompression = TGA_COMP_NONE;\n       break;\n \n     case 9:\n       info.imageType        = TGA_TYPE_MAPPED;\n       info.imageCompression = TGA_COMP_RLE;\n       break;\n     case 10:\n       info.imageType        = TGA_TYPE_COLOR;\n       info.imageCompression = TGA_COMP_RLE;\n       break;\n     case 11:\n       info.imageType        = TGA_TYPE_GRAY;\n       info.imageCompression = TGA_COMP_RLE;\n       break;\n \n     default:\n       info.imageType = 0;\n     }\n \n   info.idLength     = header[0];\n   info.colorMapType = header[1];\n \n   info.colorMapIndex  = header[3] + header[4] * 256;\n   info.colorMapLength = header[5] + header[6] * 256;\n   info.colorMapSize   = header[7];\n \n   info.xOrigin = header[8]  + header[9] * 256;\n   info.yOrigin = header[10] + header[11] * 256;\n   info.width   = header[12] + header[13] * 256;\n   info.height  = header[14] + header[15] * 256;\n \n   info.bpp       = header[16];\n   info.bytes     = (info.bpp + 7) / 8;\n   info.alphaBits = header[17] & 0x0f;\n   info.flipHoriz = (header[17] & 0x10) ? 1 : 0;\n   info.flipVert  = (header[17] & 0x20) ? 0 : 1;\n \n   if (info.alphaBits == info.bpp)\n     info.alphaBits = 0;\n \n   if (info.alphaBits == 0)\n     {\n       if (info.imageType == TGA_TYPE_COLOR && info.bpp == 32)\n         info.alphaBits = 8;\n \n       if (info.imageType == TGA_TYPE_GRAY && info.bpp == 16)\n         info.alphaBits = 8;\n     }\n \n   switch (info.imageType)\n     {\n       case TGA_TYPE_MAPPED:\n         if (info.bpp != 8)\n           {\n             g_message (\"Unhandled sub-format in '%s' (type = %u, bpp = %u)\",\n                        gimp_filename_to_utf8 (filename),\n                        info.imageType, info.bpp);\n             return -1;\n           }\n         break;\n       case TGA_TYPE_COLOR:\n         if ((info.bpp != 15 && info.bpp != 16 &&\n              info.bpp != 24 && info.bpp != 32)      ||\n             ((info.bpp == 15 || info.bpp == 24) &&\n              info.alphaBits != 0)                   ||\n// bug_start\n            (info.bpp == 16 && info.alphaBits != 1) ||\n// bug_end\n             (info.bpp == 32 && info.alphaBits != 8))\n           {\n             g_message (\"Unhandled sub-format in '%s' (type = %u, bpp = %u, alpha = %u)\",\n                        gimp_filename_to_utf8 (filename),\n                        info.imageType, info.bpp, info.alphaBits);\n             return -1;\n           }\n         break;\n       case TGA_TYPE_GRAY:\n         if (info.bpp != 8 &&\n             (info.alphaBits != 8 || (info.bpp != 16 && info.bpp != 15)))\n           {\n             g_message (\"Unhandled sub-format in '%s' (type = %u, bpp = %u)\",\n                        gimp_filename_to_utf8 (filename),\n                        info.imageType, info.bpp);\n             return -1;\n           }\n         break;\n \n       default:\n         g_message (\"Unknown image type %u for '%s'\",\n                    info.imageType, gimp_filename_to_utf8 (filename));\n         return -1;\n     }\n \n   if (info.bytes * 8 != info.bpp && info.bpp != 15)\n     {\n       g_message (\"Unhandled sub-format in '%s' (type = %u, bpp = %u)\",\n                  gimp_filename_to_utf8 (filename),\n                  info.imageType, info.bpp);\n       return -1;\n     }\n \n   if (info.imageType == TGA_TYPE_MAPPED && info.colorMapType != 1)\n     {\n       g_message (\"Indexed image has invalid color map type %u\",\n                  info.colorMapType);\n       return -1;\n     }\n   else if (info.imageType != TGA_TYPE_MAPPED && info.colorMapType != 0)\n     {\n       g_message (\"Non-indexed image has invalid color map type %u\",\n                  info.colorMapType);\n       return -1;\n     }\n \n   if (info.idLength && fseek (fp, info.idLength, SEEK_CUR))\n     {\n       g_message (\"File '%s' is truncated or corrupted\",\n                  gimp_filename_to_utf8 (filename));\n       return -1;\n     }\n \n   image_ID = ReadImage (fp, &info, filename);\n \n   fclose (fp);\n \n   return image_ID;\n }\n \n", "target": "// fix_start\n            (info.bpp == 16 && info.alphaBits != 1 &&\n             info.alphaBits != 0)                   ||\n// fix_end\n", "cwe": "CWE-125", "cwe_name": "Out-of-bounds Read", "cve": "CVE-2017-17786", "cve_desc": "In GIMP 2.8.22, there is a heap-based buffer over-read in ReadImage in plug-ins/common/file-tga.c (related to bgr2rgb.part.1) via an unexpected bits-per-pixel value for an RGBA image.", "project": "GIMP", "idx": 215994}
{"source": " do_ed_script (char const *inname, char const *outname,\n \t      bool *outname_needs_removal, FILE *ofp)\n {\n     static char const editor_program[] = EDITOR_PROGRAM;\n \n     file_offset beginning_of_this_line;\n     size_t chars_read;\n     FILE *tmpfp = 0;\n     char const *tmpname;\n     int tmpfd;\n     pid_t pid;\n \n     if (! dry_run && ! skip_rest_of_patch)\n       {\n \n \ttmpfd = make_tempfile (&tmpname, 'e', NULL, O_RDWR | O_BINARY, 0);\n \tif (tmpfd == -1)\n \t  pfatal (\"Can't create temporary file %s\", quotearg (tmpname));\n \ttmpfp = fdopen (tmpfd, \"w+b\");\n \tif (! tmpfp)\n \t  pfatal (\"Can't open stream for file %s\", quotearg (tmpname));\n       }\n \n     for (;;) {\n \tchar ed_command_letter;\n \tbeginning_of_this_line = file_tell (pfp);\n \tchars_read = get_line ();\n \tif (! chars_read) {\n \t    next_intuit_at(beginning_of_this_line,p_input_line);\n \t    break;\n \t}\n \ted_command_letter = get_ed_command_letter (buf);\n \tif (ed_command_letter) {\n \t    if (tmpfp)\n \t\tif (! fwrite (buf, sizeof *buf, chars_read, tmpfp))\n \t\t    write_fatal ();\n \t    if (ed_command_letter != 'd' && ed_command_letter != 's') {\n \t        p_pass_comments_through = true;\n \t\twhile ((chars_read = get_line ()) != 0) {\n \t\t    if (tmpfp)\n \t\t\tif (! fwrite (buf, sizeof *buf, chars_read, tmpfp))\n \t\t\t    write_fatal ();\n \t\t    if (chars_read == 2  &&  strEQ (buf, \".\\n\"))\n \t\t\tbreak;\n \t\t}\n \t\tp_pass_comments_through = false;\n \t    }\n \t}\n \telse {\n \t    next_intuit_at(beginning_of_this_line,p_input_line);\n \t    break;\n \t}\n     }\n     if (!tmpfp)\n       return;\n     if (fwrite (\"w\\nq\\n\", sizeof (char), (size_t) 4, tmpfp) == 0\n \t|| fflush (tmpfp) != 0)\n       write_fatal ();\n \n     if (lseek (tmpfd, 0, SEEK_SET) == -1)\n       pfatal (\"Can't rewind to the beginning of file %s\", quotearg (tmpname));\n \n     if (! dry_run && ! skip_rest_of_patch) {\n \tint exclusive = *outname_needs_removal ? 0 : O_EXCL;\n \t*outname_needs_removal = true;\n \tif (inerrno != ENOENT)\n \t  {\n \t    *outname_needs_removal = true;\n \t    copy_file (inname, outname, 0, exclusive, instat.st_mode, true);\n \t  }\n// bug_start\n\tsprintf (buf, \"%s %s%s\", editor_program,\n\t\t verbosity == VERBOSE ? \"\" : \"- \",\n\t\t outname);\n// bug_end\n \tfflush (stdout);\n \n \tpid = fork();\n \tif (pid == -1)\n \t  pfatal (\"Can't fork\");\n \telse if (pid == 0)\n \t  {\n \t    dup2 (tmpfd, 0);\n// bug_start\n\t    execl (\"/bin/sh\", \"sh\", \"-c\", buf, (char *) 0);\n// bug_end\n \t    _exit (2);\n \t  }\n \telse\n \t  {\n \t    int wstatus;\n \t    if (waitpid (pid, &wstatus, 0) == -1\n \t        || ! WIFEXITED (wstatus)\n \t\t|| WEXITSTATUS (wstatus) != 0)\n \t      fatal (\"%s FAILED\", editor_program);\n \t  }\n     }\n \n     fclose (tmpfp);\n     safe_unlink (tmpname);\n \n     if (ofp)\n       {\n \tFILE *ifp = fopen (outname, binary_transput ? \"rb\" : \"r\");\n \tint c;\n \tif (!ifp)\n \t  pfatal (\"can't open '%s'\", outname);\n \twhile ((c = getc (ifp)) != EOF)\n \t  if (putc (c, ofp) == EOF)\n \t    write_fatal ();\n \tif (ferror (ifp) || fclose (ifp) != 0)\n \t  read_fatal ();\n       }\n }\n \n", "target": "// fix_start\n// fix_end\n// fix_start\n\t    assert (outname[0] != '!' && outname[0] != '-');\n\t    execlp (editor_program, editor_program, \"-\", outname, (char  *) NULL);\n// fix_end\n", "cwe": "CWE-78", "cwe_name": "Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')", "cve": "CVE-2019-13638", "cve_desc": "GNU patch through 2.7.6 is vulnerable to OS shell command injection that can be exploited by opening a crafted patch file that contains an ed style diff payload with shell metacharacters. The ed editor does not need to be present on the vulnerable system. This is different from CVE-2018-1000156.", "project": "patch", "idx": 216036}
{"source": " _eddsa_hash (const struct ecc_modulo *m,\n \t     mp_limb_t *rp, size_t digest_size, const uint8_t *digest)\n {\n   mp_size_t nlimbs = (8*digest_size + GMP_NUMB_BITS - 1) / GMP_NUMB_BITS;\n// bug_start\n// bug_end\n \n   mpn_set_base256_le (rp, nlimbs, digest, digest_size);\n \n   if (nlimbs > 2*m->size)\n     {\n       mp_limb_t hi = rp[2*m->size];\n       assert (nlimbs == 2*m->size + 1);\n \n       hi = mpn_addmul_1 (rp + m->size, m->B, m->size, hi);\n       assert (hi <= 1);\n       hi = mpn_cnd_add_n (hi, rp + m->size, rp + m->size, m->B, m->size);\n       assert (hi == 0);\n     }\n// bug_start\n  m->mod (m, rp, rp);\n// bug_end\n }\n \n", "target": "// fix_start\n  mp_limb_t cy;\n// fix_end\n// fix_start\n  m->mod (m, rp + m->size , rp);\n  cy = mpn_sub_n (rp, rp + m->size, m->m, m->size);\n  cnd_copy (cy, rp, rp + m->size, m->size);\n// fix_end\n", "cwe": "CWE-787", "cwe_name": "Out-of-bounds Write", "cve": "CVE-2021-20305", "cve_desc": "A flaw was found in Nettle in versions before 3.7.2, where several Nettle signature verification functions (GOST DSA, EDDSA & ECDSA) result in the Elliptic Curve Cryptography point (ECC) multiply function being called with out-of-range scalers, possibly resulting in incorrect results. This flaw allows an attacker to force an invalid signature, causing an assertion failure or possible validation. The highest threat to this vulnerability is to confidentiality, integrity, as well as system availability.", "project": "nettle", "idx": 216084}
{"source": " ds_fgetstr (FILE *f, dynamic_string *s, char eos)\n {\n// bug_start\n  int insize;\n  int strsize;\n// bug_end\n   int next_ch;\n \n// bug_start\n  insize = 0;\n  strsize = s->ds_length;\n// bug_end\n \n// bug_start\n  next_ch = getc (f);\n  while (next_ch != eos && next_ch != EOF)\n// bug_end\n     {\n// bug_start\n      if (insize >= strsize - 1)\n\t{\n\t  ds_resize (s, strsize * 2 + 2);\n\t  strsize = s->ds_length;\n\t}\n      s->ds_string[insize++] = next_ch;\n      next_ch = getc (f);\n// bug_end\n     }\n// bug_start\n  s->ds_string[insize++] = '\\0';\n// bug_end\n \n// bug_start\n  if (insize == 1 && next_ch == EOF)\n// bug_end\n     return NULL;\n   else\n     return s->ds_string;\n }\n \n", "target": "// fix_start\n// fix_end\n// fix_start\n  s->ds_idx = 0;\n// fix_end\n// fix_start\n  while ((next_ch = getc (f)) != eos && next_ch != EOF)\n// fix_end\n// fix_start\n      ds_resize (s);\n      s->ds_string[s->ds_idx++] = next_ch;\n// fix_end\n// fix_start\n  ds_resize (s);\n  s->ds_string[s->ds_idx] = '\\0';\n// fix_end\n// fix_start\n  if (s->ds_idx == 0 && next_ch == EOF)\n// fix_end\n", "cwe": "CWE-190", "cwe_name": "Integer Overflow or Wraparound", "cve": "CVE-2021-38185", "cve_desc": "GNU cpio through 2.13 allows attackers to execute arbitrary code via a crafted pattern file, because of a dstring.c ds_fgetstr integer overflow that triggers an out-of-bounds heap write. NOTE: it is unclear whether there are common cases where the pattern file, associated with the -E option, is untrusted data.", "project": "cpio", "idx": 216101}
{"source": " unsigned int get_random_int(void)\n {\n// bug_start\n\treturn secure_ip_id((__force __be32)(current->pid + jiffies));\n// bug_end\n }\n \n", "target": "// fix_start\n\tstruct keydata *keyptr;\n\t__u32 *hash = get_cpu_var(get_random_int_hash);\n\tint ret;\n\n\tkeyptr = get_keyptr();\n\thash[0] += current->pid + jiffies + get_cycles() + (int)(long)&ret;\n\n\tret = half_md4_transform(hash, keyptr->secret);\n\tput_cpu_var(get_random_int_hash);\n\n\treturn ret;\n// fix_end\n", "cwe": "CWE-310", "cwe_name": "Cryptographic Issues", "cve": "CVE-2009-3238", "cve_desc": "The get_random_int function in drivers/char/random.c in the Linux kernel before 2.6.30 produces insufficiently random numbers, which allows attackers to predict the return value, and possibly defeat protection mechanisms based on randomization, via vectors that leverage the function's tendency to \"return the same value over and over again for long stretches of time.\"", "project": "linux-2.6", "idx": 216119}
{"source": " int ssl3_send_client_key_exchange(SSL *s)\n \t{\n \tunsigned char *p,*d;\n \tint n;\n \tunsigned long l;\n #ifndef OPENSSL_NO_RSA\n \tunsigned char *q;\n \tEVP_PKEY *pkey=NULL;\n #endif\n #ifndef OPENSSL_NO_KRB5\n \tKSSL_ERR kssl_err;\n #endif\n #ifndef OPENSSL_NO_ECDH\n \tEC_KEY *clnt_ecdh = NULL;\n \tconst EC_POINT *srvr_ecpoint = NULL;\n \tEVP_PKEY *srvr_pub_pkey = NULL;\n \tunsigned char *encodedPoint = NULL;\n \tint encoded_pt_len = 0;\n \tBN_CTX * bn_ctx = NULL;\n #endif\n \n \tif (s->state == SSL3_ST_CW_KEY_EXCH_A)\n \t\t{\n \t\td=(unsigned char *)s->init_buf->data;\n \t\tp= &(d[4]);\n \n \t\tl=s->s3->tmp.new_cipher->algorithms;\n \n \t\tif (0) {}\n #ifndef OPENSSL_NO_RSA\n \t\telse if (l & SSL_kRSA)\n \t\t\t{\n \t\t\tRSA *rsa;\n \t\t\tunsigned char tmp_buf[SSL_MAX_MASTER_KEY_LENGTH];\n \n \t\t\tif (s->session->sess_cert->peer_rsa_tmp != NULL)\n \t\t\t\trsa=s->session->sess_cert->peer_rsa_tmp;\n \t\t\telse\n \t\t\t\t{\n \t\t\t\tpkey=X509_get_pubkey(s->session->sess_cert->peer_pkeys[SSL_PKEY_RSA_ENC].x509);\n \t\t\t\tif ((pkey == NULL) ||\n \t\t\t\t\t(pkey->type != EVP_PKEY_RSA) ||\n \t\t\t\t\t(pkey->pkey.rsa == NULL))\n \t\t\t\t\t{\n \t\t\t\t\tSSLerr(SSL_F_SSL3_SEND_CLIENT_KEY_EXCHANGE,ERR_R_INTERNAL_ERROR);\n \t\t\t\t\tgoto err;\n \t\t\t\t\t}\n \t\t\t\trsa=pkey->pkey.rsa;\n \t\t\t\tEVP_PKEY_free(pkey);\n \t\t\t\t}\n \n \t\t\ttmp_buf[0]=s->client_version>>8;\n \t\t\ttmp_buf[1]=s->client_version&0xff;\n \t\t\tif (RAND_bytes(&(tmp_buf[2]),sizeof tmp_buf-2) <= 0)\n \t\t\t\t\tgoto err;\n \n \t\t\ts->session->master_key_length=sizeof tmp_buf;\n \n \t\t\tq=p;\n \t\t\tif (s->version > SSL3_VERSION)\n \t\t\t\tp+=2;\n \t\t\tn=RSA_public_encrypt(sizeof tmp_buf,\n \t\t\t\ttmp_buf,p,rsa,RSA_PKCS1_PADDING);\n #ifdef PKCS1_CHECK\n \t\t\tif (s->options & SSL_OP_PKCS1_CHECK_1) p[1]++;\n \t\t\tif (s->options & SSL_OP_PKCS1_CHECK_2) tmp_buf[0]=0x70;\n #endif\n \t\t\tif (n <= 0)\n \t\t\t\t{\n \t\t\t\tSSLerr(SSL_F_SSL3_SEND_CLIENT_KEY_EXCHANGE,SSL_R_BAD_RSA_ENCRYPT);\n \t\t\t\tgoto err;\n \t\t\t\t}\n \n \t\t\tif (s->version > SSL3_VERSION)\n \t\t\t\t{\n \t\t\t\ts2n(n,q);\n \t\t\t\tn+=2;\n \t\t\t\t}\n \n \t\t\ts->session->master_key_length=\n \t\t\t\ts->method->ssl3_enc->generate_master_secret(s,\n \t\t\t\t\ts->session->master_key,\n \t\t\t\t\ttmp_buf,sizeof tmp_buf);\n \t\t\tOPENSSL_cleanse(tmp_buf,sizeof tmp_buf);\n \t\t\t}\n #endif\n #ifndef OPENSSL_NO_KRB5\n \t\telse if (l & SSL_kKRB5)\n \t\t\t{\n \t\t\tkrb5_error_code\tkrb5rc;\n \t\t\tKSSL_CTX\t*kssl_ctx = s->kssl_ctx;\n \t\t\tkrb5_data\t*enc_ticket;\n \t\t\tkrb5_data\tauthenticator, *authp = NULL;\n \t\t\tEVP_CIPHER_CTX\tciph_ctx;\n \t\t\tEVP_CIPHER\t*enc = NULL;\n \t\t\tunsigned char\tiv[EVP_MAX_IV_LENGTH];\n \t\t\tunsigned char\ttmp_buf[SSL_MAX_MASTER_KEY_LENGTH];\n \t\t\tunsigned char\tepms[SSL_MAX_MASTER_KEY_LENGTH\n \t\t\t\t\t\t+ EVP_MAX_IV_LENGTH];\n \t\t\tint \t\tpadl, outl = sizeof(epms);\n \n \t\t\tEVP_CIPHER_CTX_init(&ciph_ctx);\n \n #ifdef KSSL_DEBUG\n \t\t\tprintf(\"ssl3_send_client_key_exchange(%lx & %lx)\\n\",\n \t\t\t        l, SSL_kKRB5);\n #endif\n \n \t\t\tauthp = NULL;\n #ifdef KRB5SENDAUTH\n \t\t\tif (KRB5SENDAUTH)  authp = &authenticator;\n #endif\n \n \t\t\tkrb5rc = kssl_cget_tkt(kssl_ctx, &enc_ticket, authp,\n \t\t\t\t&kssl_err);\n \t\t\tenc = kssl_map_enc(kssl_ctx->enctype);\n \t\t\tif (enc == NULL)\n \t\t\t    goto err;\n #ifdef KSSL_DEBUG\n \t\t\t{\n \t\t\tprintf(\"kssl_cget_tkt rtn %d\\n\", krb5rc);\n \t\t\tif (krb5rc && kssl_err.text)\n \t\t\t  printf(\"kssl_cget_tkt kssl_err=%s\\n\", kssl_err.text);\n \t\t\t}\n #endif\n \n \t\t\tif (krb5rc)\n \t\t\t\t{\n \t\t\t\tssl3_send_alert(s,SSL3_AL_FATAL,\n \t\t\t\t\t\tSSL_AD_HANDSHAKE_FAILURE);\n \t\t\t\tSSLerr(SSL_F_SSL3_SEND_CLIENT_KEY_EXCHANGE,\n \t\t\t\t\t\tkssl_err.reason);\n \t\t\t\tgoto err;\n \t\t\t\t}\n \n \n \t\t\ts2n(enc_ticket->length,p);\n \t\t\tmemcpy(p, enc_ticket->data, enc_ticket->length);\n \t\t\tp+= enc_ticket->length;\n \t\t\tn = enc_ticket->length + 2;\n \n \t\t\tif (authp  &&  authp->length)\n \t\t\t\t{\n \t\t\t\ts2n(authp->length,p);\n \t\t\t\tmemcpy(p, authp->data, authp->length);\n \t\t\t\tp+= authp->length;\n \t\t\t\tn+= authp->length + 2;\n \n \t\t\t\tfree(authp->data);\n \t\t\t\tauthp->data = NULL;\n \t\t\t\tauthp->length = 0;\n \t\t\t\t}\n \t\t\telse\n \t\t\t\t{\n \t\t\t\ts2n(0,p);\n \t\t\t\tn+=2;\n \t\t\t\t}\n \n \t\t\t    tmp_buf[0]=s->client_version>>8;\n \t\t\t    tmp_buf[1]=s->client_version&0xff;\n \t\t\t    if (RAND_bytes(&(tmp_buf[2]),sizeof tmp_buf-2) <= 0)\n \t\t\t\tgoto err;\n \n \n \t\t\tmemset(iv, 0, sizeof iv);\n \t\t\tEVP_EncryptInit_ex(&ciph_ctx,enc, NULL,\n \t\t\t\tkssl_ctx->key,iv);\n \t\t\tEVP_EncryptUpdate(&ciph_ctx,epms,&outl,tmp_buf,\n \t\t\t\tsizeof tmp_buf);\n \t\t\tEVP_EncryptFinal_ex(&ciph_ctx,&(epms[outl]),&padl);\n \t\t\toutl += padl;\n \t\t\tif (outl > sizeof epms)\n \t\t\t\t{\n \t\t\t\tSSLerr(SSL_F_SSL3_SEND_CLIENT_KEY_EXCHANGE, ERR_R_INTERNAL_ERROR);\n \t\t\t\tgoto err;\n \t\t\t\t}\n \t\t\tEVP_CIPHER_CTX_cleanup(&ciph_ctx);\n \n \t\t\ts2n(outl,p);\n \t\t\tmemcpy(p, epms, outl);\n \t\t\tp+=outl;\n \t\t\tn+=outl + 2;\n \n \t\t\ts->session->master_key_length=\n \t\t\t        s->method->ssl3_enc->generate_master_secret(s,\n \t\t\t\t\ts->session->master_key,\n \t\t\t\t\ttmp_buf, sizeof tmp_buf);\n \n \t\t\tOPENSSL_cleanse(tmp_buf, sizeof tmp_buf);\n \t\t\tOPENSSL_cleanse(epms, outl);\n \t\t\t}\n #endif\n #ifndef OPENSSL_NO_DH\n \t\telse if (l & (SSL_kEDH|SSL_kDHr|SSL_kDHd))\n \t\t\t{\n \t\t\tDH *dh_srvr,*dh_clnt;\n \n \t\t\tif (s->session->sess_cert == NULL)\n \t\t\t\t{\n \t\t\t\tssl3_send_alert(s,SSL3_AL_FATAL,SSL_AD_UNEXPECTED_MESSAGE);\n \t\t\t\tSSLerr(SSL_F_SSL3_SEND_CLIENT_KEY_EXCHANGE,SSL_R_UNEXPECTED_MESSAGE);\n \t\t\t\tgoto err;\n \t\t\t        }\n \n \t\t\tif (s->session->sess_cert->peer_dh_tmp != NULL)\n \t\t\t\tdh_srvr=s->session->sess_cert->peer_dh_tmp;\n \t\t\telse\n \t\t\t\t{\n \t\t\t\tssl3_send_alert(s,SSL3_AL_FATAL,SSL_AD_HANDSHAKE_FAILURE);\n \t\t\t\tSSLerr(SSL_F_SSL3_SEND_CLIENT_KEY_EXCHANGE,SSL_R_UNABLE_TO_FIND_DH_PARAMETERS);\n \t\t\t\tgoto err;\n \t\t\t\t}\n \n \t\t\tif ((dh_clnt=DHparams_dup(dh_srvr)) == NULL)\n \t\t\t\t{\n \t\t\t\tSSLerr(SSL_F_SSL3_SEND_CLIENT_KEY_EXCHANGE,ERR_R_DH_LIB);\n \t\t\t\tgoto err;\n \t\t\t\t}\n \t\t\tif (!DH_generate_key(dh_clnt))\n \t\t\t\t{\n \t\t\t\tSSLerr(SSL_F_SSL3_SEND_CLIENT_KEY_EXCHANGE,ERR_R_DH_LIB);\n \t\t\t\tgoto err;\n \t\t\t\t}\n \n \n \t\t\tn=DH_compute_key(p,dh_srvr->pub_key,dh_clnt);\n \n \t\t\tif (n <= 0)\n \t\t\t\t{\n \t\t\t\tSSLerr(SSL_F_SSL3_SEND_CLIENT_KEY_EXCHANGE,ERR_R_DH_LIB);\n \t\t\t\tgoto err;\n \t\t\t\t}\n \n \t\t\ts->session->master_key_length=\n \t\t\t\ts->method->ssl3_enc->generate_master_secret(s,\n \t\t\t\t\ts->session->master_key,p,n);\n \t\t\tmemset(p,0,n);\n \n \t\t\tn=BN_num_bytes(dh_clnt->pub_key);\n \t\t\ts2n(n,p);\n \t\t\tBN_bn2bin(dh_clnt->pub_key,p);\n \t\t\tn+=2;\n \n \t\t\tDH_free(dh_clnt);\n \n \t\t\t}\n #endif\n \n #ifndef OPENSSL_NO_ECDH\n \t\telse if ((l & SSL_kECDH) || (l & SSL_kECDHE))\n \t\t\t{\n \t\t\tconst EC_GROUP *srvr_group = NULL;\n \t\t\tEC_KEY *tkey;\n \t\t\tint ecdh_clnt_cert = 0;\n \t\t\tint field_size = 0;\n \n// bug_start\n// bug_end\n \t\t\tif ((l & SSL_kECDH) && (s->cert != NULL))\n \t\t\t\t{\n \t\t\t\t}\n \n \t\t\tif (s->session->sess_cert->peer_ecdh_tmp != NULL)\n \t\t\t\t{\n \t\t\t\ttkey = s->session->sess_cert->peer_ecdh_tmp;\n \t\t\t\t}\n \t\t\telse\n \t\t\t\t{\n \t\t\t\tsrvr_pub_pkey = X509_get_pubkey(s->session-> \\\n \t\t\t\t    sess_cert->peer_pkeys[SSL_PKEY_ECC].x509);\n \t\t\t\tif ((srvr_pub_pkey == NULL) ||\n \t\t\t\t    (srvr_pub_pkey->type != EVP_PKEY_EC) ||\n \t\t\t\t    (srvr_pub_pkey->pkey.ec == NULL))\n \t\t\t\t\t{\n \t\t\t\t\tSSLerr(SSL_F_SSL3_SEND_CLIENT_KEY_EXCHANGE,\n \t\t\t\t\t    ERR_R_INTERNAL_ERROR);\n \t\t\t\t\tgoto err;\n \t\t\t\t\t}\n \n \t\t\t\ttkey = srvr_pub_pkey->pkey.ec;\n \t\t\t\t}\n \n \t\t\tsrvr_group   = EC_KEY_get0_group(tkey);\n \t\t\tsrvr_ecpoint = EC_KEY_get0_public_key(tkey);\n \n \t\t\tif ((srvr_group == NULL) || (srvr_ecpoint == NULL))\n \t\t\t\t{\n \t\t\t\tSSLerr(SSL_F_SSL3_SEND_CLIENT_KEY_EXCHANGE,\n \t\t\t\t    ERR_R_INTERNAL_ERROR);\n \t\t\t\tgoto err;\n \t\t\t\t}\n \n \t\t\tif ((clnt_ecdh=EC_KEY_new()) == NULL)\n \t\t\t\t{\n \t\t\t\tSSLerr(SSL_F_SSL3_SEND_CLIENT_KEY_EXCHANGE,ERR_R_MALLOC_FAILURE);\n \t\t\t\tgoto err;\n \t\t\t\t}\n \n \t\t\tif (!EC_KEY_set_group(clnt_ecdh, srvr_group))\n \t\t\t\t{\n \t\t\t\tSSLerr(SSL_F_SSL3_SEND_CLIENT_KEY_EXCHANGE,ERR_R_EC_LIB);\n \t\t\t\tgoto err;\n \t\t\t\t}\n \t\t\tif (ecdh_clnt_cert)\n \t\t\t\t{\n \t\t\t\tconst BIGNUM *priv_key;\n \t\t\t\ttkey = s->cert->key->privatekey->pkey.ec;\n \t\t\t\tpriv_key = EC_KEY_get0_private_key(tkey);\n \t\t\t\tif (priv_key == NULL)\n \t\t\t\t\t{\n \t\t\t\t\tSSLerr(SSL_F_SSL3_SEND_CLIENT_KEY_EXCHANGE,ERR_R_MALLOC_FAILURE);\n \t\t\t\t\tgoto err;\n \t\t\t\t\t}\n \t\t\t\tif (!EC_KEY_set_private_key(clnt_ecdh, priv_key))\n \t\t\t\t\t{\n \t\t\t\t\tSSLerr(SSL_F_SSL3_SEND_CLIENT_KEY_EXCHANGE,ERR_R_EC_LIB);\n \t\t\t\t\tgoto err;\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\telse\n \t\t\t\t{\n \t\t\t\tif (!(EC_KEY_generate_key(clnt_ecdh)))\n \t\t\t\t\t{\n \t\t\t\t\tSSLerr(SSL_F_SSL3_SEND_CLIENT_KEY_EXCHANGE, ERR_R_ECDH_LIB);\n \t\t\t\t\tgoto err;\n \t\t\t\t\t}\n \t\t\t\t}\n \n \n \t\t\tfield_size = EC_GROUP_get_degree(srvr_group);\n \t\t\tif (field_size <= 0)\n \t\t\t\t{\n \t\t\t\tSSLerr(SSL_F_SSL3_SEND_CLIENT_KEY_EXCHANGE,\n \t\t\t\t       ERR_R_ECDH_LIB);\n \t\t\t\tgoto err;\n \t\t\t\t}\n \t\t\tn=ECDH_compute_key(p, (field_size+7)/8, srvr_ecpoint, clnt_ecdh, NULL);\n \t\t\tif (n <= 0)\n \t\t\t\t{\n \t\t\t\tSSLerr(SSL_F_SSL3_SEND_CLIENT_KEY_EXCHANGE,\n \t\t\t\t       ERR_R_ECDH_LIB);\n \t\t\t\tgoto err;\n \t\t\t\t}\n \n \t\t\ts->session->master_key_length = s->method->ssl3_enc \\\n \t\t\t    -> generate_master_secret(s,\n \t\t\t\ts->session->master_key,\n \t\t\t\tp, n);\n \n \t\t\tmemset(p, 0, n);\n \n \t\t\tif (ecdh_clnt_cert)\n \t\t\t\t{\n \t\t\t\tn = 0;\n \t\t\t\t}\n \t\t\telse\n \t\t\t\t{\n \t\t\t\tencoded_pt_len =\n \t\t\t\t    EC_POINT_point2oct(srvr_group,\n \t\t\t\t\tEC_KEY_get0_public_key(clnt_ecdh),\n \t\t\t\t\tPOINT_CONVERSION_UNCOMPRESSED,\n \t\t\t\t\tNULL, 0, NULL);\n \n \t\t\t\tencodedPoint = (unsigned char *)\n \t\t\t\t    OPENSSL_malloc(encoded_pt_len *\n \t\t\t\t\tsizeof(unsigned char));\n \t\t\t\tbn_ctx = BN_CTX_new();\n \t\t\t\tif ((encodedPoint == NULL) ||\n \t\t\t\t    (bn_ctx == NULL))\n \t\t\t\t\t{\n \t\t\t\t\tSSLerr(SSL_F_SSL3_SEND_CLIENT_KEY_EXCHANGE,ERR_R_MALLOC_FAILURE);\n \t\t\t\t\tgoto err;\n \t\t\t\t\t}\n \n \t\t\t\tn = EC_POINT_point2oct(srvr_group,\n \t\t\t\t    EC_KEY_get0_public_key(clnt_ecdh),\n \t\t\t\t    POINT_CONVERSION_UNCOMPRESSED,\n \t\t\t\t    encodedPoint, encoded_pt_len, bn_ctx);\n \n \t\t\t\t*p = n;\n \t\t\t\tp += 1;\n \t\t\t\tmemcpy((unsigned char *)p, encodedPoint, n);\n \t\t\t\tn += 1;\n \t\t\t\t}\n \n \t\t\tBN_CTX_free(bn_ctx);\n \t\t\tif (encodedPoint != NULL) OPENSSL_free(encodedPoint);\n \t\t\tif (clnt_ecdh != NULL)\n \t\t\t\t EC_KEY_free(clnt_ecdh);\n \t\t\tEVP_PKEY_free(srvr_pub_pkey);\n \t\t\t}\n #endif\n \t\telse\n \t\t\t{\n \t\t\tssl3_send_alert(s, SSL3_AL_FATAL,\n \t\t\t    SSL_AD_HANDSHAKE_FAILURE);\n \t\t\tSSLerr(SSL_F_SSL3_SEND_CLIENT_KEY_EXCHANGE,\n \t\t\t    ERR_R_INTERNAL_ERROR);\n \t\t\tgoto err;\n \t\t\t}\n \n \t\t*(d++)=SSL3_MT_CLIENT_KEY_EXCHANGE;\n \t\tl2n3(n,d);\n \n \t\ts->state=SSL3_ST_CW_KEY_EXCH_B;\n \t\ts->init_num=n+4;\n \t\ts->init_off=0;\n \t\t}\n \n \treturn(ssl3_do_write(s,SSL3_RT_HANDSHAKE));\n err:\n #ifndef OPENSSL_NO_ECDH\n \tBN_CTX_free(bn_ctx);\n \tif (encodedPoint != NULL) OPENSSL_free(encodedPoint);\n \tif (clnt_ecdh != NULL)\n \t\tEC_KEY_free(clnt_ecdh);\n \tEVP_PKEY_free(srvr_pub_pkey);\n #endif\n \treturn(-1);\n \t}\n \n", "target": "// fix_start\n\t\t\tif (s->session->sess_cert == NULL)\n\t\t\t\t{\n\t\t\t\tssl3_send_alert(s,SSL3_AL_FATAL,SSL_AD_UNEXPECTED_MESSAGE);\n\t\t\t\tSSLerr(SSL_F_SSL3_SEND_CLIENT_KEY_EXCHANGE,SSL_R_UNEXPECTED_MESSAGE);\n\t\t\t\tgoto err;\n\t\t\t\t}\n\n// fix_end\n", "cwe": "CWE-476", "cwe_name": "NULL Pointer Dereference", "cve": "CVE-2014-3470", "cve_desc": "The ssl3_send_client_key_exchange function in s3_clnt.c in OpenSSL before 0.9.8za, 1.0.0 before 1.0.0m, and 1.0.1 before 1.0.1h, when an anonymous ECDH cipher suite is used, allows remote attackers to cause a denial of service (NULL pointer dereference and client crash) by triggering a NULL certificate value.", "project": "openssl", "idx": 216368}
{"source": " int X509_verify_cert(X509_STORE_CTX *ctx)\n {\n     X509 *x, *xtmp, *xtmp2, *chain_ss = NULL;\n     int bad_chain = 0;\n     X509_VERIFY_PARAM *param = ctx->param;\n     int depth, i, ok = 0;\n     int num, j, retry;\n     int (*cb) (int xok, X509_STORE_CTX *xctx);\n     STACK_OF(X509) *sktmp = NULL;\n     if (ctx->cert == NULL) {\n         X509err(X509_F_X509_VERIFY_CERT, X509_R_NO_CERT_SET_FOR_US_TO_VERIFY);\n         return -1;\n     }\n     if (ctx->chain != NULL) {\n         X509err(X509_F_X509_VERIFY_CERT, ERR_R_SHOULD_NOT_HAVE_BEEN_CALLED);\n         return -1;\n     }\n \n     cb = ctx->verify_cb;\n \n     if (((ctx->chain = sk_X509_new_null()) == NULL) ||\n         (!sk_X509_push(ctx->chain, ctx->cert))) {\n         X509err(X509_F_X509_VERIFY_CERT, ERR_R_MALLOC_FAILURE);\n         goto end;\n     }\n     CRYPTO_add(&ctx->cert->references, 1, CRYPTO_LOCK_X509);\n     ctx->last_untrusted = 1;\n \n     if (ctx->untrusted != NULL\n         && (sktmp = sk_X509_dup(ctx->untrusted)) == NULL) {\n         X509err(X509_F_X509_VERIFY_CERT, ERR_R_MALLOC_FAILURE);\n         goto end;\n     }\n \n     num = sk_X509_num(ctx->chain);\n     x = sk_X509_value(ctx->chain, num - 1);\n     depth = param->depth;\n \n     for (;;) {\n         if (depth < num)\n             break;\n \n         if (ctx->check_issued(ctx, x, x))\n             break;\n \n         if (ctx->untrusted != NULL) {\n             xtmp = find_issuer(ctx, sktmp, x);\n             if (xtmp != NULL) {\n                 if (!sk_X509_push(ctx->chain, xtmp)) {\n                     X509err(X509_F_X509_VERIFY_CERT, ERR_R_MALLOC_FAILURE);\n                     goto end;\n                 }\n                 CRYPTO_add(&xtmp->references, 1, CRYPTO_LOCK_X509);\n                 (void)sk_X509_delete_ptr(sktmp, xtmp);\n                 ctx->last_untrusted++;\n                 x = xtmp;\n                 num++;\n                 continue;\n             }\n         }\n         break;\n     }\n \n     j = num;\n \n     do {\n         i = sk_X509_num(ctx->chain);\n         x = sk_X509_value(ctx->chain, i - 1);\n         if (ctx->check_issued(ctx, x, x)) {\n             if (sk_X509_num(ctx->chain) == 1) {\n                 ok = ctx->get_issuer(&xtmp, ctx, x);\n                 if ((ok <= 0) || X509_cmp(x, xtmp)) {\n                     ctx->error = X509_V_ERR_DEPTH_ZERO_SELF_SIGNED_CERT;\n                     ctx->current_cert = x;\n                     ctx->error_depth = i - 1;\n                     if (ok == 1)\n                         X509_free(xtmp);\n                     bad_chain = 1;\n                     ok = cb(0, ctx);\n                     if (!ok)\n                         goto end;\n                 } else {\n                     X509_free(x);\n                     x = xtmp;\n                     (void)sk_X509_set(ctx->chain, i - 1, x);\n                     ctx->last_untrusted = 0;\n                 }\n             } else {\n                 chain_ss = sk_X509_pop(ctx->chain);\n                 ctx->last_untrusted--;\n                 num--;\n                 j--;\n                 x = sk_X509_value(ctx->chain, num - 1);\n             }\n         }\n         for (;;) {\n             if (depth < num)\n                 break;\n             if (ctx->check_issued(ctx, x, x))\n                 break;\n             ok = ctx->get_issuer(&xtmp, ctx, x);\n             if (ok < 0)\n                 return ok;\n             if (ok == 0)\n                 break;\n             x = xtmp;\n             if (!sk_X509_push(ctx->chain, x)) {\n                 X509_free(xtmp);\n                 X509err(X509_F_X509_VERIFY_CERT, ERR_R_MALLOC_FAILURE);\n                 return 0;\n             }\n             num++;\n         }\n \n         retry = 0;\n// bug_start\n        if (j == ctx->last_untrusted &&\n// bug_end\n             !(ctx->param->flags & X509_V_FLAG_NO_ALT_CHAINS)) {\n             while (j-- > 1) {\n                 xtmp2 = sk_X509_value(ctx->chain, j - 1);\n                 ok = ctx->get_issuer(&xtmp, ctx, xtmp2);\n                 if (ok < 0)\n                     goto end;\n                 if (ok > 0) {\n                     X509_free(xtmp);\n \n                     while (num > j) {\n                         xtmp = sk_X509_pop(ctx->chain);\n                         X509_free(xtmp);\n                         num--;\n                     }\n                     ctx->last_untrusted = sk_X509_num(ctx->chain);\n                     retry = 1;\n                     break;\n                 }\n             }\n         }\n     } while (retry);\n \n     if (!ctx->check_issued(ctx, x, x)) {\n         if ((chain_ss == NULL) || !ctx->check_issued(ctx, x, chain_ss)) {\n             if (ctx->last_untrusted >= num)\n                 ctx->error = X509_V_ERR_UNABLE_TO_GET_ISSUER_CERT_LOCALLY;\n             else\n                 ctx->error = X509_V_ERR_UNABLE_TO_GET_ISSUER_CERT;\n             ctx->current_cert = x;\n         } else {\n \n             sk_X509_push(ctx->chain, chain_ss);\n             num++;\n             ctx->last_untrusted = num;\n             ctx->current_cert = chain_ss;\n             ctx->error = X509_V_ERR_SELF_SIGNED_CERT_IN_CHAIN;\n             chain_ss = NULL;\n         }\n \n         ctx->error_depth = num - 1;\n         bad_chain = 1;\n         ok = cb(0, ctx);\n         if (!ok)\n             goto end;\n     }\n \n     ok = check_chain_extensions(ctx);\n \n     if (!ok)\n         goto end;\n \n \n     ok = check_name_constraints(ctx);\n \n     if (!ok)\n         goto end;\n \n \n     if (param->trust > 0)\n         ok = check_trust(ctx);\n \n     if (!ok)\n         goto end;\n \n     X509_get_pubkey_parameters(NULL, ctx->chain);\n \n \n     ok = ctx->check_revocation(ctx);\n     if (!ok)\n         goto end;\n \n     if (ctx->verify != NULL)\n         ok = ctx->verify(ctx);\n     else\n         ok = internal_verify(ctx);\n     if (!ok)\n         goto end;\n \n #ifndef OPENSSL_NO_RFC3779\n     ok = v3_asid_validate_path(ctx);\n     if (!ok)\n         goto end;\n     ok = v3_addr_validate_path(ctx);\n     if (!ok)\n         goto end;\n #endif\n \n     if (!bad_chain && (ctx->param->flags & X509_V_FLAG_POLICY_CHECK))\n         ok = ctx->check_policy(ctx);\n     if (!ok)\n         goto end;\n     if (0) {\n  end:\n         X509_get_pubkey_parameters(NULL, ctx->chain);\n     }\n     if (sktmp != NULL)\n         sk_X509_free(sktmp);\n     if (chain_ss != NULL)\n         X509_free(chain_ss);\n     return ok;\n }\n \n", "target": "// fix_start\n        if (num == ctx->last_untrusted &&\n// fix_end\n", "cwe": "CWE-254", "cwe_name": "Security Features", "cve": "CVE-2015-1793", "cve_desc": "The X509_verify_cert function in crypto/x509/x509_vfy.c in OpenSSL 1.0.1n, 1.0.1o, 1.0.2b, and 1.0.2c does not properly process X.509 Basic Constraints cA values during identification of alternative certificate chains, which allows remote attackers to spoof a Certification Authority role and trigger unintended certificate verifications via a valid leaf certificate.", "project": "openssl", "idx": 216521}
{"source": " int ssl3_read_bytes(SSL *s, int type, int *recvd_type, unsigned char *buf,\n                     int len, int peek)\n {\n     int al, i, j, ret;\n     unsigned int n, curr_rec, num_recs, read_bytes;\n     SSL3_RECORD *rr;\n     SSL3_BUFFER *rbuf;\n     void (*cb) (const SSL *ssl, int type2, int val) = NULL;\n \n     rbuf = &s->rlayer.rbuf;\n \n     if (!SSL3_BUFFER_is_initialised(rbuf)) {\n         if (!ssl3_setup_read_buffer(s))\n             return (-1);\n     }\n \n     if ((type && (type != SSL3_RT_APPLICATION_DATA)\n          && (type != SSL3_RT_HANDSHAKE)) || (peek\n                                              && (type !=\n                                                  SSL3_RT_APPLICATION_DATA))) {\n         SSLerr(SSL_F_SSL3_READ_BYTES, ERR_R_INTERNAL_ERROR);\n         return -1;\n     }\n \n     if ((type == SSL3_RT_HANDSHAKE) && (s->rlayer.handshake_fragment_len > 0))\n     {\n         unsigned char *src = s->rlayer.handshake_fragment;\n         unsigned char *dst = buf;\n         unsigned int k;\n \n         n = 0;\n         while ((len > 0) && (s->rlayer.handshake_fragment_len > 0)) {\n             *dst++ = *src++;\n             len--;\n             s->rlayer.handshake_fragment_len--;\n             n++;\n         }\n         for (k = 0; k < s->rlayer.handshake_fragment_len; k++)\n             s->rlayer.handshake_fragment[k] = *src++;\n \n         if (recvd_type != NULL)\n             *recvd_type = SSL3_RT_HANDSHAKE;\n \n         return n;\n     }\n \n \n     if (!ossl_statem_get_in_handshake(s) && SSL_in_init(s)) {\n         i = s->handshake_func(s);\n         if (i < 0)\n             return (i);\n         if (i == 0) {\n             SSLerr(SSL_F_SSL3_READ_BYTES, SSL_R_SSL_HANDSHAKE_FAILURE);\n             return (-1);\n         }\n     }\n  start:\n     s->rwstate = SSL_NOTHING;\n \n     rr = s->rlayer.rrec;\n     num_recs = RECORD_LAYER_get_numrpipes(&s->rlayer);\n \n     do {\n         if (num_recs == 0) {\n             ret = ssl3_get_record(s);\n             if (ret <= 0)\n                 return (ret);\n             num_recs = RECORD_LAYER_get_numrpipes(&s->rlayer);\n             if (num_recs == 0) {\n                 al = SSL_AD_INTERNAL_ERROR;\n                 SSLerr(SSL_F_SSL3_READ_BYTES, ERR_R_INTERNAL_ERROR);\n                 goto f_err;\n             }\n         }\n         for (curr_rec = 0;\n              curr_rec < num_recs && SSL3_RECORD_is_read(&rr[curr_rec]);\n              curr_rec++) ;\n         if (curr_rec == num_recs) {\n             RECORD_LAYER_set_numrpipes(&s->rlayer, 0);\n             num_recs = 0;\n             curr_rec = 0;\n         }\n     } while (num_recs == 0);\n     rr = &rr[curr_rec];\n \n     if (SSL3_RECORD_get_type(rr) != SSL3_RT_ALERT\n             && SSL3_RECORD_get_length(rr) != 0)\n         s->rlayer.alert_count = 0;\n \n \n     if (s->s3->change_cipher_spec\n         && (SSL3_RECORD_get_type(rr) != SSL3_RT_HANDSHAKE)) {\n         al = SSL_AD_UNEXPECTED_MESSAGE;\n         SSLerr(SSL_F_SSL3_READ_BYTES, SSL_R_DATA_BETWEEN_CCS_AND_FINISHED);\n         goto f_err;\n     }\n \n     if (s->shutdown & SSL_RECEIVED_SHUTDOWN) {\n         SSL3_RECORD_set_length(rr, 0);\n         s->rwstate = SSL_NOTHING;\n         return (0);\n     }\n \n     if (type == SSL3_RECORD_get_type(rr)\n         || (SSL3_RECORD_get_type(rr) == SSL3_RT_CHANGE_CIPHER_SPEC\n             && type == SSL3_RT_HANDSHAKE && recvd_type != NULL)) {\n         if (SSL_in_init(s) && (type == SSL3_RT_APPLICATION_DATA) &&\n             (s->enc_read_ctx == NULL)) {\n             al = SSL_AD_UNEXPECTED_MESSAGE;\n             SSLerr(SSL_F_SSL3_READ_BYTES, SSL_R_APP_DATA_IN_HANDSHAKE);\n             goto f_err;\n         }\n \n         if (type == SSL3_RT_HANDSHAKE\n             && SSL3_RECORD_get_type(rr) == SSL3_RT_CHANGE_CIPHER_SPEC\n             && s->rlayer.handshake_fragment_len > 0) {\n             al = SSL_AD_UNEXPECTED_MESSAGE;\n             SSLerr(SSL_F_SSL3_READ_BYTES, SSL_R_CCS_RECEIVED_EARLY);\n             goto f_err;\n         }\n \n         if (recvd_type != NULL)\n             *recvd_type = SSL3_RECORD_get_type(rr);\n \n         if (len <= 0)\n             return (len);\n \n         read_bytes = 0;\n         do {\n             if ((unsigned int)len - read_bytes > SSL3_RECORD_get_length(rr))\n                 n = SSL3_RECORD_get_length(rr);\n             else\n                 n = (unsigned int)len - read_bytes;\n \n             memcpy(buf, &(rr->data[rr->off]), n);\n             buf += n;\n// bug_start\n            if (!peek) {\n// bug_end\n                 SSL3_RECORD_sub_length(rr, n);\n                 SSL3_RECORD_add_off(rr, n);\n                 if (SSL3_RECORD_get_length(rr) == 0) {\n                     s->rlayer.rstate = SSL_ST_READ_HEADER;\n                     SSL3_RECORD_set_off(rr, 0);\n                     SSL3_RECORD_set_read(rr);\n                 }\n             }\n             if (SSL3_RECORD_get_length(rr) == 0\n                 || (peek && n == SSL3_RECORD_get_length(rr))) {\n                 curr_rec++;\n                 rr++;\n             }\n             read_bytes += n;\n         } while (type == SSL3_RT_APPLICATION_DATA && curr_rec < num_recs\n                  && read_bytes < (unsigned int)len);\n         if (read_bytes == 0) {\n             goto start;\n         }\n         if (!peek && curr_rec == num_recs\n             && (s->mode & SSL_MODE_RELEASE_BUFFERS)\n             && SSL3_BUFFER_get_left(rbuf) == 0)\n             ssl3_release_read_buffer(s);\n         return read_bytes;\n     }\n \n \n     if (rr->rec_version == SSL2_VERSION) {\n         al = SSL_AD_INTERNAL_ERROR;\n         SSLerr(SSL_F_SSL3_READ_BYTES, ERR_R_INTERNAL_ERROR);\n         goto f_err;\n     }\n \n     if (s->method->version == TLS_ANY_VERSION\n         && (s->server || rr->type != SSL3_RT_ALERT)) {\n         s->version = rr->rec_version;\n         al = SSL_AD_UNEXPECTED_MESSAGE;\n         SSLerr(SSL_F_SSL3_READ_BYTES, SSL_R_UNEXPECTED_MESSAGE);\n         goto f_err;\n     }\n \n     {\n         unsigned int dest_maxlen = 0;\n         unsigned char *dest = NULL;\n         unsigned int *dest_len = NULL;\n \n         if (SSL3_RECORD_get_type(rr) == SSL3_RT_HANDSHAKE) {\n             dest_maxlen = sizeof s->rlayer.handshake_fragment;\n             dest = s->rlayer.handshake_fragment;\n             dest_len = &s->rlayer.handshake_fragment_len;\n         } else if (SSL3_RECORD_get_type(rr) == SSL3_RT_ALERT) {\n             dest_maxlen = sizeof s->rlayer.alert_fragment;\n             dest = s->rlayer.alert_fragment;\n             dest_len = &s->rlayer.alert_fragment_len;\n         }\n \n         if (dest_maxlen > 0) {\n             n = dest_maxlen - *dest_len;\n             if (SSL3_RECORD_get_length(rr) < n)\n                 n = SSL3_RECORD_get_length(rr);\n \n             while (n-- > 0) {\n                 dest[(*dest_len)++] =\n                     SSL3_RECORD_get_data(rr)[SSL3_RECORD_get_off(rr)];\n                 SSL3_RECORD_add_off(rr, 1);\n                 SSL3_RECORD_add_length(rr, -1);\n             }\n \n             if (*dest_len < dest_maxlen) {\n                 SSL3_RECORD_set_read(rr);\n                 goto start;\n             }\n         }\n     }\n \n \n     if ((!s->server) &&\n         (s->rlayer.handshake_fragment_len >= 4) &&\n         (s->rlayer.handshake_fragment[0] == SSL3_MT_HELLO_REQUEST) &&\n         (s->session != NULL) && (s->session->cipher != NULL)) {\n         s->rlayer.handshake_fragment_len = 0;\n \n         if ((s->rlayer.handshake_fragment[1] != 0) ||\n             (s->rlayer.handshake_fragment[2] != 0) ||\n             (s->rlayer.handshake_fragment[3] != 0)) {\n             al = SSL_AD_DECODE_ERROR;\n             SSLerr(SSL_F_SSL3_READ_BYTES, SSL_R_BAD_HELLO_REQUEST);\n             goto f_err;\n         }\n \n         if (s->msg_callback)\n             s->msg_callback(0, s->version, SSL3_RT_HANDSHAKE,\n                             s->rlayer.handshake_fragment, 4, s,\n                             s->msg_callback_arg);\n \n         if (SSL_is_init_finished(s) &&\n             !(s->s3->flags & SSL3_FLAGS_NO_RENEGOTIATE_CIPHERS) &&\n             !s->s3->renegotiate) {\n             ssl3_renegotiate(s);\n             if (ssl3_renegotiate_check(s)) {\n                 i = s->handshake_func(s);\n                 if (i < 0)\n                     return (i);\n                 if (i == 0) {\n                     SSLerr(SSL_F_SSL3_READ_BYTES, SSL_R_SSL_HANDSHAKE_FAILURE);\n                     return (-1);\n                 }\n \n                 if (!(s->mode & SSL_MODE_AUTO_RETRY)) {\n                     if (SSL3_BUFFER_get_left(rbuf) == 0) {\n                         BIO *bio;\n                         s->rwstate = SSL_READING;\n                         bio = SSL_get_rbio(s);\n                         BIO_clear_retry_flags(bio);\n                         BIO_set_retry_read(bio);\n                         return (-1);\n                     }\n                 }\n             }\n         }\n         goto start;\n     }\n     if (s->server &&\n         SSL_is_init_finished(s) &&\n         !s->s3->send_connection_binding &&\n         (s->version > SSL3_VERSION) &&\n         (s->rlayer.handshake_fragment_len >= 4) &&\n         (s->rlayer.handshake_fragment[0] == SSL3_MT_CLIENT_HELLO) &&\n         (s->session != NULL) && (s->session->cipher != NULL) &&\n         !(s->ctx->options & SSL_OP_ALLOW_UNSAFE_LEGACY_RENEGOTIATION)) {\n         SSL3_RECORD_set_length(rr, 0);\n         SSL3_RECORD_set_read(rr);\n         ssl3_send_alert(s, SSL3_AL_WARNING, SSL_AD_NO_RENEGOTIATION);\n         goto start;\n     }\n     if (s->rlayer.alert_fragment_len >= 2) {\n         int alert_level = s->rlayer.alert_fragment[0];\n         int alert_descr = s->rlayer.alert_fragment[1];\n \n         s->rlayer.alert_fragment_len = 0;\n \n         if (s->msg_callback)\n             s->msg_callback(0, s->version, SSL3_RT_ALERT,\n                             s->rlayer.alert_fragment, 2, s,\n                             s->msg_callback_arg);\n \n         if (s->info_callback != NULL)\n             cb = s->info_callback;\n         else if (s->ctx->info_callback != NULL)\n             cb = s->ctx->info_callback;\n \n         if (cb != NULL) {\n             j = (alert_level << 8) | alert_descr;\n             cb(s, SSL_CB_READ_ALERT, j);\n         }\n \n         if (alert_level == SSL3_AL_WARNING) {\n             s->s3->warn_alert = alert_descr;\n             SSL3_RECORD_set_read(rr);\n \n             s->rlayer.alert_count++;\n             if (s->rlayer.alert_count == MAX_WARN_ALERT_COUNT) {\n                 al = SSL_AD_UNEXPECTED_MESSAGE;\n                 SSLerr(SSL_F_SSL3_READ_BYTES, SSL_R_TOO_MANY_WARN_ALERTS);\n                 goto f_err;\n             }\n \n             if (alert_descr == SSL_AD_CLOSE_NOTIFY) {\n                 s->shutdown |= SSL_RECEIVED_SHUTDOWN;\n                 return (0);\n             }\n             else if (alert_descr == SSL_AD_NO_RENEGOTIATION) {\n                 al = SSL_AD_HANDSHAKE_FAILURE;\n                 SSLerr(SSL_F_SSL3_READ_BYTES, SSL_R_NO_RENEGOTIATION);\n                 goto f_err;\n             }\n #ifdef SSL_AD_MISSING_SRP_USERNAME\n             else if (alert_descr == SSL_AD_MISSING_SRP_USERNAME)\n                 return (0);\n #endif\n         } else if (alert_level == SSL3_AL_FATAL) {\n             char tmp[16];\n \n             s->rwstate = SSL_NOTHING;\n             s->s3->fatal_alert = alert_descr;\n             SSLerr(SSL_F_SSL3_READ_BYTES, SSL_AD_REASON_OFFSET + alert_descr);\n             BIO_snprintf(tmp, sizeof tmp, \"%d\", alert_descr);\n             ERR_add_error_data(2, \"SSL alert number \", tmp);\n             s->shutdown |= SSL_RECEIVED_SHUTDOWN;\n             SSL3_RECORD_set_read(rr);\n             SSL_CTX_remove_session(s->session_ctx, s->session);\n             return (0);\n         } else {\n             al = SSL_AD_ILLEGAL_PARAMETER;\n             SSLerr(SSL_F_SSL3_READ_BYTES, SSL_R_UNKNOWN_ALERT_TYPE);\n             goto f_err;\n         }\n \n         goto start;\n     }\n \n     if (s->shutdown & SSL_SENT_SHUTDOWN) {\n         s->rwstate = SSL_NOTHING;\n         SSL3_RECORD_set_length(rr, 0);\n         SSL3_RECORD_set_read(rr);\n         return (0);\n     }\n \n     if (SSL3_RECORD_get_type(rr) == SSL3_RT_CHANGE_CIPHER_SPEC) {\n         al = SSL_AD_UNEXPECTED_MESSAGE;\n         SSLerr(SSL_F_SSL3_READ_BYTES, SSL_R_CCS_RECEIVED_EARLY);\n         goto f_err;\n     }\n \n     if ((s->rlayer.handshake_fragment_len >= 4)\n         && !ossl_statem_get_in_handshake(s)) {\n         if (SSL_is_init_finished(s) &&\n             !(s->s3->flags & SSL3_FLAGS_NO_RENEGOTIATE_CIPHERS)) {\n             ossl_statem_set_in_init(s, 1);\n             s->renegotiate = 1;\n             s->new_session = 1;\n         }\n         i = s->handshake_func(s);\n         if (i < 0)\n             return (i);\n         if (i == 0) {\n             SSLerr(SSL_F_SSL3_READ_BYTES, SSL_R_SSL_HANDSHAKE_FAILURE);\n             return (-1);\n         }\n \n         if (!(s->mode & SSL_MODE_AUTO_RETRY)) {\n             if (SSL3_BUFFER_get_left(rbuf) == 0) {\n                 BIO *bio;\n                 s->rwstate = SSL_READING;\n                 bio = SSL_get_rbio(s);\n                 BIO_clear_retry_flags(bio);\n                 BIO_set_retry_read(bio);\n                 return (-1);\n             }\n         }\n         goto start;\n     }\n \n     switch (SSL3_RECORD_get_type(rr)) {\n     default:\n         if (s->version >= TLS1_VERSION && s->version <= TLS1_1_VERSION) {\n             SSL3_RECORD_set_length(rr, 0);\n             SSL3_RECORD_set_read(rr);\n             goto start;\n         }\n         al = SSL_AD_UNEXPECTED_MESSAGE;\n         SSLerr(SSL_F_SSL3_READ_BYTES, SSL_R_UNEXPECTED_RECORD);\n         goto f_err;\n     case SSL3_RT_CHANGE_CIPHER_SPEC:\n     case SSL3_RT_ALERT:\n     case SSL3_RT_HANDSHAKE:\n         al = SSL_AD_UNEXPECTED_MESSAGE;\n         SSLerr(SSL_F_SSL3_READ_BYTES, ERR_R_INTERNAL_ERROR);\n         goto f_err;\n     case SSL3_RT_APPLICATION_DATA:\n         if (ossl_statem_app_data_allowed(s)) {\n             s->s3->in_read_app_data = 2;\n             return (-1);\n         } else {\n             al = SSL_AD_UNEXPECTED_MESSAGE;\n             SSLerr(SSL_F_SSL3_READ_BYTES, SSL_R_UNEXPECTED_RECORD);\n             goto f_err;\n         }\n     }\n \n  f_err:\n     ssl3_send_alert(s, SSL3_AL_FATAL, al);\n     return (-1);\n }\n \n", "target": "// fix_start\n            if (peek) {\n                if (SSL3_RECORD_get_length(rr) == 0)\n                    SSL3_RECORD_set_read(rr);\n            } else {\n// fix_end\n", "cwe": "CWE-20", "cwe_name": "Improper Input Validation", "cve": "CVE-2016-6305", "cve_desc": "The ssl3_read_bytes function in record/rec_layer_s3.c in OpenSSL 1.1.0 before 1.1.0a allows remote attackers to cause a denial of service (infinite loop) by triggering a zero-length record in an SSL_peek call.", "project": "openssl", "idx": 216634}
{"source": " void auth_client_request_abort(struct auth_client_request **_request)\n {\n \tstruct auth_client_request *request = *_request;\n \n \t*_request = NULL;\n \n \tauth_client_send_cancel(request->conn->client, request->id);\n \tcall_callback(request, AUTH_REQUEST_STATUS_ABORT, NULL, NULL);\n// bug_start\n// bug_end\n \tpool_unref(&request->pool);\n }\n \n", "target": "// fix_start\n\tauth_server_connection_remove_request(request->conn, request->id);\n// fix_end\n", "cwe": "CWE-772", "cwe_name": "Missing Release of Resource after Effective Lifetime", "cve": "CVE-2017-15132", "cve_desc": "A flaw was found in dovecot 2.0 up to 2.2.33 and 2.3.0. An abort of SASL authentication results in a memory leak in dovecot's auth client used by login processes. The leak has impact in high performance configuration where same login processes are reused and can cause the process to crash due to memory exhaustion.", "project": "core", "idx": 216710}
{"source": " ECDSA_SIG *ossl_ecdsa_sign_sig(const unsigned char *dgst, int dgst_len,\n                                const BIGNUM *in_kinv, const BIGNUM *in_r,\n                                EC_KEY *eckey)\n {\n     int ok = 0, i;\n// bug_start\n    BIGNUM *kinv = NULL, *s, *m = NULL, *tmp = NULL;\n// bug_end\n     const BIGNUM *order, *ckinv;\n     BN_CTX *ctx = NULL;\n     const EC_GROUP *group;\n     ECDSA_SIG *ret;\n     const BIGNUM *priv_key;\n \n     group = EC_KEY_get0_group(eckey);\n     priv_key = EC_KEY_get0_private_key(eckey);\n \n     if (group == NULL || priv_key == NULL) {\n         ECerr(EC_F_OSSL_ECDSA_SIGN_SIG, ERR_R_PASSED_NULL_PARAMETER);\n         return NULL;\n     }\n \n     if (!EC_KEY_can_sign(eckey)) {\n         ECerr(EC_F_OSSL_ECDSA_SIGN_SIG, EC_R_CURVE_DOES_NOT_SUPPORT_SIGNING);\n         return NULL;\n     }\n \n     ret = ECDSA_SIG_new();\n     if (ret == NULL) {\n         ECerr(EC_F_OSSL_ECDSA_SIGN_SIG, ERR_R_MALLOC_FAILURE);\n         return NULL;\n     }\n     ret->r = BN_new();\n     ret->s = BN_new();\n     if (ret->r == NULL || ret->s == NULL) {\n         ECerr(EC_F_OSSL_ECDSA_SIGN_SIG, ERR_R_MALLOC_FAILURE);\n         goto err;\n     }\n     s = ret->s;\n \n// bug_start\n    if ((ctx = BN_CTX_new()) == NULL ||\n        (tmp = BN_new()) == NULL || (m = BN_new()) == NULL) {\n// bug_end\n         ECerr(EC_F_OSSL_ECDSA_SIGN_SIG, ERR_R_MALLOC_FAILURE);\n         goto err;\n     }\n \n     order = EC_GROUP_get0_order(group);\n     if (order == NULL) {\n         ECerr(EC_F_OSSL_ECDSA_SIGN_SIG, ERR_R_EC_LIB);\n         goto err;\n     }\n     i = BN_num_bits(order);\n     if (8 * dgst_len > i)\n         dgst_len = (i + 7) / 8;\n     if (!BN_bin2bn(dgst, dgst_len, m)) {\n         ECerr(EC_F_OSSL_ECDSA_SIGN_SIG, ERR_R_BN_LIB);\n         goto err;\n     }\n     if ((8 * dgst_len > i) && !BN_rshift(m, m, 8 - (i & 0x7))) {\n         ECerr(EC_F_OSSL_ECDSA_SIGN_SIG, ERR_R_BN_LIB);\n         goto err;\n     }\n     do {\n         if (in_kinv == NULL || in_r == NULL) {\n             if (!ecdsa_sign_setup(eckey, ctx, &kinv, &ret->r, dgst, dgst_len)) {\n                 ECerr(EC_F_OSSL_ECDSA_SIGN_SIG, ERR_R_ECDSA_LIB);\n                 goto err;\n             }\n             ckinv = kinv;\n         } else {\n             ckinv = in_kinv;\n             if (BN_copy(ret->r, in_r) == NULL) {\n                 ECerr(EC_F_OSSL_ECDSA_SIGN_SIG, ERR_R_MALLOC_FAILURE);\n                 goto err;\n             }\n         }\n \n// bug_start\n        if (!BN_mod_mul(tmp, priv_key, ret->r, order, ctx)) {\n// bug_end\n             ECerr(EC_F_OSSL_ECDSA_SIGN_SIG, ERR_R_BN_LIB);\n             goto err;\n         }\n// bug_start\n        if (!BN_mod_add_quick(s, tmp, m, order)) {\n// bug_end\n             ECerr(EC_F_OSSL_ECDSA_SIGN_SIG, ERR_R_BN_LIB);\n             goto err;\n         }\n// bug_start\n// bug_end\n         if (!BN_mod_mul(s, s, ckinv, order, ctx)) {\n             ECerr(EC_F_OSSL_ECDSA_SIGN_SIG, ERR_R_BN_LIB);\n             goto err;\n         }\n// bug_start\n// bug_end\n         if (BN_is_zero(s)) {\n             if (in_kinv != NULL && in_r != NULL) {\n                 ECerr(EC_F_OSSL_ECDSA_SIGN_SIG, EC_R_NEED_NEW_SETUP_VALUES);\n                 goto err;\n             }\n         } else\n             break;\n     }\n     while (1);\n \n     ok = 1;\n  err:\n     if (!ok) {\n         ECDSA_SIG_free(ret);\n         ret = NULL;\n     }\n// bug_start\n// bug_end\n     BN_CTX_free(ctx);\n// bug_start\n    BN_clear_free(m);\n    BN_clear_free(tmp);\n// bug_end\n     BN_clear_free(kinv);\n     return ret;\n }\n \n", "target": "// fix_start\n    BIGNUM *kinv = NULL, *s, *m = NULL, *tmp = NULL, *blind = NULL;\n    BIGNUM *blindm = NULL;\n// fix_end\n// fix_start\n    ctx = BN_CTX_secure_new();\n    if (ctx == NULL) {\n        ECerr(EC_F_OSSL_ECDSA_SIGN_SIG, ERR_R_MALLOC_FAILURE);\n        goto err;\n    }\n\n    BN_CTX_start(ctx);\n    tmp = BN_CTX_get(ctx);\n    m = BN_CTX_get(ctx);\n    blind = BN_CTX_get(ctx);\n    blindm = BN_CTX_get(ctx);\n    if (blindm == NULL) {\n// fix_end\n// fix_start\n\n        do {\n            if (!BN_rand(blind, BN_num_bits(order) - 1, BN_RAND_TOP_ANY,\n                         BN_RAND_BOTTOM_ANY))\n                goto err;\n        } while (BN_is_zero(blind));\n        BN_set_flags(blind, BN_FLG_CONSTTIME);\n        BN_set_flags(blindm, BN_FLG_CONSTTIME);\n        BN_set_flags(tmp, BN_FLG_CONSTTIME);\n\n        if (!BN_mod_mul(tmp, blind, priv_key, order, ctx)) {\n// fix_end\n// fix_start\n        if (!BN_mod_mul(tmp, tmp, ret->r, order, ctx)) {\n// fix_end\n// fix_start\n\n        if (!BN_mod_mul(blindm, blind, m, order, ctx)) {\n            ECerr(EC_F_OSSL_ECDSA_SIGN_SIG, ERR_R_BN_LIB);\n            goto err;\n        }\n\n        if (!BN_mod_add_quick(s, tmp, blindm, order)) {\n            ECerr(EC_F_OSSL_ECDSA_SIGN_SIG, ERR_R_BN_LIB);\n            goto err;\n        }\n\n        if (BN_mod_inverse(blind, blind, order, ctx) == NULL) {\n            ECerr(EC_F_OSSL_ECDSA_SIGN_SIG, ERR_R_BN_LIB);\n            goto err;\n        }\n        if (!BN_mod_mul(s, s, blind, order, ctx)) {\n            ECerr(EC_F_OSSL_ECDSA_SIGN_SIG, ERR_R_BN_LIB);\n            goto err;\n        }\n\n// fix_end\n// fix_start\n\n// fix_end\n// fix_start\n    BN_CTX_end(ctx);\n// fix_end\n// fix_start\n// fix_end\n", "cwe": "CWE-203", "cwe_name": "Information Exposure Through Discrepancy", "cve": "CVE-2018-0495", "cve_desc": "Libgcrypt before 1.7.10 and 1.8.x before 1.8.3 allows a memory-cache side-channel attack on ECDSA signatures that can be mitigated through the use of blinding during the signing process in the _gcry_ecc_ecdsa_sign function in cipher/ecc-ecdsa.c, aka the Return Of the Hidden Number Problem or ROHNP. To discover an ECDSA key, the attacker needs access to either the local machine or a different virtual machine on the same physical host.", "project": "openssl", "idx": 216718}
{"source": "// bug_start\nAgraph_t *agroot(void* obj)\n// bug_end\n {\n     switch (AGTYPE(obj)) {\n     case AGINEDGE:\n     case AGOUTEDGE:\n \treturn ((Agedge_t *) obj)->node->root;\n     case AGNODE:\n \treturn ((Agnode_t *) obj)->root;\n     case AGRAPH:\n// bug_start\n\treturn ((Agraph_t *) obj)->root;\n// bug_end\n     default:\n// bug_start\n\tagerr(AGERR, \"agroot of a bad object\");\n// bug_end\n \treturn NILgraph;\n     }\n }\n \n", "target": "// fix_start\nAgraph_t *agraphof(void *obj)\n// fix_end\n// fix_start\n\treturn (Agraph_t *) obj;\n// fix_end\n// fix_start\n\tagerr(AGERR, \"agraphof a bad object\");\n// fix_end\n", "cwe": "CWE-476", "cwe_name": "NULL Pointer Dereference", "cve": "CVE-2019-11023", "cve_desc": "The agroot() function in cgraph\\obj.c in libcgraph.a in Graphviz 2.39.20160612.1140 has a NULL pointer dereference, as demonstrated by graphml2gv.", "project": "graphviz", "idx": 216728}
{"source": " static bool ntlmssp_check_buffer(const struct ntlmssp_buffer *buffer,\n \t\t\t\t size_t data_size, const char **error)\n {\n \tuint32_t offset = read_le32(&buffer->offset);\n \tuint16_t length = read_le16(&buffer->length);\n \tuint16_t space = read_le16(&buffer->space);\n \n \tif (length == 0 && space == 0)\n \t\treturn TRUE;\n// bug_start\n// bug_end\n \n \tif (offset >= data_size) {\n \t\t*error = \"buffer offset out of bounds\";\n \t\treturn FALSE;\n \t}\n \n \tif (offset + space > data_size) {\n \t\t*error = \"buffer end out of bounds\";\n \t\treturn FALSE;\n \t}\n \n \treturn TRUE;\n }\n \n", "target": "// fix_start\n\n\tif (length > data_size) {\n\t\t*error = \"buffer length out of bounds\";\n\t\treturn FALSE;\n\t}\n// fix_end\n", "cwe": "CWE-125", "cwe_name": "Out-of-bounds Read", "cve": "CVE-2020-12673", "cve_desc": "In Dovecot before 2.3.11.3, sending a specially formatted NTLM request will crash the auth service because of an out-of-bounds read.", "project": "core", "idx": 216799}
{"source": " print_set_output(char *name, TBOOLEAN datablock, TBOOLEAN append_p)\n {\n     if (print_out && print_out != stderr && print_out != stdout) {\n #ifdef PIPES\n \tif (print_out_name[0] == '|') {\n \t    if (0 > pclose(print_out))\n \t\tperror(print_out_name);\n \t} else\n #endif\n \t    if (0 > fclose(print_out))\n \t\tperror(print_out_name);\n// bug_start\n// bug_end\n     }\n \n     free(print_out_name);\n     print_out_name = NULL;\n     print_out_var = NULL;\n \n     if (! name) {\n \tprint_out = stderr;\n \treturn;\n     }\n \n     if (strcmp(name, \"-\") == 0) {\n \tprint_out = stdout;\n \treturn;\n     }\n \n #ifdef PIPES\n     if (name[0] == '|') {\n \trestrict_popen();\n \tprint_out = popen(name + 1, \"w\");\n \tif (!print_out)\n \t    perror(name);\n \telse\n \t    print_out_name = name;\n \treturn;\n     }\n #endif\n \n     if (!datablock) {\n \tprint_out = fopen(name, append_p ? \"a\" : \"w\");\n \tif (!print_out) {\n \t    perror(name);\n \t    return;\n \t}\n     } else {\n \tprint_out_var = add_udv_by_name(name);\n \tif (!append_p)\n \t    gpfree_datablock(&print_out_var->udv_value);\n \tif (print_out_var->udv_value.type != DATABLOCK) {\n \t    free_value(&print_out_var->udv_value);\n \t    print_out_var->udv_value.type = DATABLOCK;\n \t    print_out_var->udv_value.v.data_array = NULL;\n \t}\n     }\n \n     print_out_name = name;\n }\n \n", "target": "// fix_start\n\tprint_out = stderr;\n// fix_end\n", "cwe": "CWE-415", "cwe_name": "Double Free", "cve": "CVE-2020-25559", "cve_desc": "gnuplot 5.5 is affected by double free when executing print_set_output. This may result in context-dependent arbitrary code execution.", "project": "gnuplot", "idx": 216803}
{"source": " enhanced_recursion(\n     const char *p,\n     TBOOLEAN brace,\n     char *fontname,\n     double fontsize,\n     double base,\n     TBOOLEAN widthflag,\n     TBOOLEAN showflag,\n     int overprint)\n {\n     TBOOLEAN wasitalic, wasbold;\n \n     wasitalic = (strstr(fontname, \":Italic\") != NULL);\n     wasbold = (strstr(fontname, \":Bold\") != NULL);\n \n     FPRINTF((stderr, \"RECURSE WITH \\\"%s\\\", %d %s %.1f %.1f %d %d %d\",\n \t\tp, brace, fontname, fontsize, base, widthflag, showflag, overprint));\n \n     (term->enhanced_flush)();\n \n     if (base + fontsize > enhanced_max_height) {\n \tenhanced_max_height = base + fontsize;\n \tENH_DEBUG((\"Setting max height to %.1f\\n\", enhanced_max_height));\n     }\n \n     if (base < enhanced_min_height) {\n \tenhanced_min_height = base;\n \tENH_DEBUG((\"Setting min height to %.1f\\n\", enhanced_min_height));\n     }\n \n     while (*p) {\n \tdouble shift;\n \n \tif ((*p & 0x80) && (encoding == S_ENC_DEFAULT || encoding == S_ENC_UTF8)) {\n \t    unsigned long utf8char;\n \t    const char *nextchar = p;\n \n \t    (term->enhanced_open)(fontname, fontsize, base, widthflag, showflag, overprint);\n \t    if (utf8toulong(&utf8char, &nextchar)) {\n \t\twhile (p < nextchar)\n \t\t    (term->enhanced_writec)(*p++);\n \t\tp--;\n \t    } else {\n \t\t(term->enhanced_writec)(*p);\n \t    }\n \t} else if ((*p & 0x80) && (encoding == S_ENC_SJIS)) {\n \t    (term->enhanced_open)(fontname, fontsize, base, widthflag, showflag, overprint);\n \t    (term->enhanced_writec)(*(p++));\n \t    (term->enhanced_writec)(*p);\n \t} else\n \n \tswitch (*p) {\n \tcase '}'  :\n \t    if (brace)\n \t\treturn (p);\n \n \t    int_warn(NO_CARET, \"enhanced text parser - spurious }\");\n \t    break;\n \n \tcase '_'  :\n \tcase '^'  :\n \t    shift = (*p == '^') ? 0.5 : -0.3;\n \t    (term->enhanced_flush)();\n \t    p = enhanced_recursion(p + 1, FALSE, fontname, fontsize * 0.8,\n \t\t\t      base + shift * fontsize, widthflag,\n \t\t\t      showflag, overprint);\n \t    break;\n \tcase '{'  :\n \t    {\n \t\tTBOOLEAN isitalic = FALSE, isbold = FALSE, isnormal = FALSE;\n \t\tconst char *start_of_fontname = NULL;\n \t\tconst char *end_of_fontname = NULL;\n \t\tchar *localfontname = NULL;\n \t\tchar ch;\n \t\tdouble f = fontsize, ovp;\n \n \t\tchar *styledfontname = NULL;\n \n \n \t\tENH_DEBUG((\"Dealing with {\\n\"));\n \n \n \t\t++p;\n \t\tif (overprint == 2) {\n \t\t    char *end;\n \t\t    ovp = strtod(p,&end);\n \t\t    p = end;\n \t\t    if (term->flags & TERM_IS_POSTSCRIPT)\n \t\t\tbase = ovp*f;\n \t\t    else\n \t\t\tbase += ovp*f;\n \t\t}\n \t\t--p;\n \n \t\tif (*++p == '/') {\n \t\t    while (*++p == ' ')\n \t\t\t;\n \t\t    if (*p=='-') {\n \t\t\twhile (*++p == ' ')\n \t\t\t    ;\n \t\t    }\n \t\t    start_of_fontname = p;\n \n \t\t    if (*p == '\\'' || *p == '\"') {\n \t\t\t++p;\n \t\t\twhile (*p != '\\0' && *p != '}' && *p != *start_of_fontname)\n \t\t\t    ++p;\n \t\t\tif (*p != *start_of_fontname) {\n \t\t\t    int_warn(NO_CARET, \"cannot interpret font name %s\", start_of_fontname);\n// bug_start\n\t\t\t    p = start_of_fontname;\n// bug_end\n \t\t\t}\n \t\t\tstart_of_fontname++;\n \t\t\tend_of_fontname = p++;\n \t\t\tch = *p;\n \t\t    } else {\n \n \t\t\twhile ((ch = *p) > ' ' && ch != '=' && ch != '*' && ch != '}' && ch != ':')\n \t\t\t    ++p;\n \t\t\tend_of_fontname = p;\n \t\t    }\n \n \t\t    do {\n \t\t\tif (ch == '=') {\n \t\t\t    char *end;\n \t\t\t    p++;\n \t\t\t    ENH_DEBUG((\"Calling strtod(\\\"%s\\\") ...\", p));\n \t\t\t    f = strtod(p, &end);\n \t\t\t    p = end;\n \t\t\t    ENH_DEBUG((\"Returned %.1f and \\\"%s\\\"\\n\", f, p));\n \n \t\t\t    if (f == 0)\n \t\t\t\tf = fontsize;\n \t\t\t    else\n \t\t\t\tf *= enhanced_fontscale;\n \n \t\t\t    ENH_DEBUG((\"Font size %.1f\\n\", f));\n \t\t\t} else if (ch == '*') {\n \t\t\t    char *end;\n \t\t\t    p++;\n \t\t\t    ENH_DEBUG((\"Calling strtod(\\\"%s\\\") ...\", p));\n \t\t\t    f = strtod(p, &end);\n \t\t\t    p = end;\n \t\t\t    ENH_DEBUG((\"Returned %.1f and \\\"%s\\\"\\n\", f, p));\n \n \t\t\t    if (f)\n \t\t\t\tf *= fontsize;\n \t\t\t    else\n \t\t\t\tf = fontsize;\n \n \t\t\t    ENH_DEBUG((\"Font size %.1f\\n\", f));\n \t\t\t} else if (ch == ':') {\n \t\t\t    p++;\n \t\t\t    if (!strncmp(p,\"Bold\",4))\n \t\t\t\tisbold = TRUE;\n \t\t\t    if (!strncmp(p,\"Italic\",6))\n \t\t\t\tisitalic = TRUE;\n \t\t\t    if (!strncmp(p,\"Normal\",6))\n \t\t\t\tisnormal = TRUE;\n \t\t\t    while (isalpha((unsigned char)*p)) {p++;}\n \t\t\t}\n \t\t    } while (((ch = *p) == '=') || (ch == ':') || (ch == '*'));\n \n \t\t    if (ch == '}')\n \t\t\tint_warn(NO_CARET,\"bad syntax in enhanced text string\");\n \n \t\t    if (*p == ' ')\n \t\t\t++p;\n \t\t    if (!start_of_fontname || (start_of_fontname == end_of_fontname)) {\n \t\t\tlocalfontname = gp_strdup(fontname);\n \t\t    } else {\n \t\t\tint len = end_of_fontname - start_of_fontname;\n \t\t\tlocalfontname = gp_alloc(len+1,\"localfontname\");\n \t\t\tstrncpy(localfontname, start_of_fontname, len);\n \t\t\tlocalfontname[len] = '\\0';\n \t\t    }\n \t\t}\n \n \t\tisitalic = (wasitalic || isitalic) && !isnormal;\n \t\tisbold = (wasbold || isbold) && !isnormal;\n \n \t\tstyledfontname = stylefont(localfontname ? localfontname : fontname,\n \t\t\t\t\t    isbold, isitalic);\n \n \t\tp = enhanced_recursion(p, TRUE, styledfontname, f, base,\n \t\t\t\t  widthflag, showflag, overprint);\n \n \t\t(term->enhanced_flush)();\n \n \t\tfree(styledfontname);\n \t\tfree(localfontname);\n \n \t\tbreak;\n \t    }\n \tcase '@' :\n \t    (term->enhanced_flush)();\n \t    (term->enhanced_open)(fontname, fontsize, base, widthflag, showflag, 3);\n \t    p = enhanced_recursion(++p, FALSE, fontname, fontsize, base,\n \t\t\t      widthflag, showflag, overprint);\n \t    (term->enhanced_open)(fontname, fontsize, base, widthflag, showflag, 4);\n \t    break;\n \n \tcase '&' :\n \t    (term->enhanced_flush)();\n \n \t    p = enhanced_recursion(++p, FALSE, fontname, fontsize, base,\n \t\t\t      widthflag, FALSE, overprint);\n \t    break;\n \n \tcase '~' :\n \n \t    (term->enhanced_flush)();\n \t    p = enhanced_recursion(++p, FALSE, fontname, fontsize, base,\n \t\t\t      widthflag, showflag, 1);\n \t    (term->enhanced_flush)();\n \t    if (!*p)\n \t        break;\n \t    p = enhanced_recursion(++p, FALSE, fontname, fontsize, base,\n \t\t\t      FALSE, showflag, 2);\n \n \t    overprint = 0;\n \t    break;\n \n \tcase '('  :\n \tcase ')'  :\n \t    (term->enhanced_open)(fontname, fontsize, base, widthflag, showflag, overprint);\n \t    if (term->flags & TERM_IS_POSTSCRIPT)\n \t\t(term->enhanced_writec)('\\\\');\n \t    (term->enhanced_writec)(*p);\n \t    break;\n \n \tcase '\\\\'  :\n \t    (term->enhanced_open)(fontname, fontsize, base, widthflag, showflag, overprint);\n \n \t    if (p[1] == 'U' && p[2] == '+') {\n \t\tif (encoding == S_ENC_UTF8) {\n \t\t    uint32_t codepoint;\n \t\t    unsigned char utf8char[8];\n \t\t    int i, length;\n \n \t\t    sscanf(&(p[3]), \"%5x\", &codepoint);\n \t\t    length = ucs4toutf8(codepoint, utf8char);\n \t\t    p += (codepoint > 0xFFFF) ? 7 : 6;\n \t\t    for (i=0; i<length; i++)\n \t\t\t(term->enhanced_writec)(utf8char[i]);\n \t\t    break;\n \t\t}\n \n \t\t(term->enhanced_writec)(p[0]);\n \t\tbreak;\n \t    }\n \n \t    if (p[1] >= '0' && p[1] <= '7') {\n \t\tchar *e, escape[16], octal[4] = {'\\0','\\0','\\0','\\0'};\n \n \t\toctal[0] = *(++p);\n \t\tif (p[1] >= '0' && p[1] <= '7') {\n \t\t    octal[1] = *(++p);\n \t\t    if (p[1] >= '0' && p[1] <= '7')\n \t\t\toctal[2] = *(++p);\n \t\t}\n \t\tsprintf(escape, enhanced_escape_format, strtol(octal,NULL,8));\n \t\tfor (e=escape; *e; e++) {\n \t\t    (term->enhanced_writec)(*e);\n \t\t}\n \t\tbreak;\n \t    }\n \n \t    if (term->flags & TERM_IS_POSTSCRIPT) {\n \t\tif (p[1]=='\\\\' || p[1]=='(' || p[1]==')') {\n \t\t    (term->enhanced_writec)('\\\\');\n \t\t} else if (strchr(\"^_@&~{}\",p[1]) == NULL) {\n \t\t    (term->enhanced_writec)('\\\\');\n \t\t    (term->enhanced_writec)('\\\\');\n \t\t    break;\n \t\t}\n \t    }\n \n \t    ++p;\n \n \t    if (*p == '\\0') {\n \t\tint_warn(NO_CARET, \"enhanced text parser -- spurious backslash\");\n \t\tbreak;\n \t    }\n \n \t    if (*p == '&' && encoding == S_ENC_DEFAULT && !strcmp(term->name, \"svg\")) {\n \t\t(term->enhanced_writec)('\\376');\n \t\tbreak;\n \t    }\n \n \t    (term->enhanced_writec)(*p);\n \t    break;\n \n \tdefault:\n \t    (term->enhanced_open)(fontname, fontsize, base, widthflag, showflag, overprint);\n \t    (term->enhanced_writec)(*p);\n \t}\n \n \n \tif (!brace) {\n \t    (term->enhanced_flush)();\n \t    return(p);\n \t}\n \n \tif (*p)\n \t    ++p;\n     }\n \n     (term->enhanced_flush)();\n     return p;\n }\n \n", "target": "// fix_start\n\t\t\t    p = start_of_fontname + 1;\n// fix_end\n", "cwe": "CWE-787", "cwe_name": "Out-of-bounds Write", "cve": "CVE-2020-25412", "cve_desc": "com_line() in command.c in gnuplot 5.4 leads to an out-of-bounds-write from strncpy() that may lead to arbitrary code execution.", "project": "gnuplot", "idx": 216804}
{"source": "// bug_start\n  bool const_item() const { return used_tables() == 0; }\n// bug_end\n \n", "target": "// fix_start\n  bool const_item() const { return true; }\n// fix_end\n", "cwe": "CWE-617", "cwe_name": "Reachable Assertion", "cve": "CVE-2021-46666", "cve_desc": "MariaDB before 10.6.2 allows an application crash because of mishandling of a pushdown from a HAVING clause to a WHERE clause.", "project": "server", "idx": 216904}
{"source": " int setup_conds(THD *thd, TABLE_LIST *tables, List<TABLE_LIST> &leaves,\n                 COND **conds)\n {\n   SELECT_LEX *select_lex= thd->lex->current_select;\n   TABLE_LIST *table= NULL;\n   bool it_is_update= (select_lex == thd->lex->first_select_lex()) &&\n     thd->lex->which_check_option_applicable();\n   bool save_is_item_list_lookup= select_lex->is_item_list_lookup;\n   TABLE_LIST *derived= select_lex->master_unit()->derived;\n// bug_start\n// bug_end\n   DBUG_ENTER(\"setup_conds\");\n \n   select_lex->is_item_list_lookup= 0;\n// bug_start\n// bug_end\n \n   thd->column_usage= MARK_COLUMNS_READ;\n   DBUG_PRINT(\"info\", (\"thd->column_usage: %d\", thd->column_usage));\n   select_lex->cond_count= 0;\n   select_lex->between_count= 0;\n   select_lex->max_equal_elems= 0;\n \n   for (table= tables; table; table= table->next_local)\n   {\n     if (select_lex == thd->lex->first_select_lex() &&\n         select_lex->first_cond_optimization &&\n         table->merged_for_insert &&\n         table->prepare_where(thd, conds, FALSE))\n       goto err_no_arena;\n   }\n \n   if (*conds)\n   {\n     thd->where=\"where clause\";\n     DBUG_EXECUTE(\"where\",\n                  print_where(*conds,\n                              \"WHERE in setup_conds\",\n                              QT_ORDINARY););\n     if ((*conds)->type() == Item::FIELD_ITEM && !derived)\n       wrap_ident(thd, conds);\n     (*conds)->mark_as_condition_AND_part(NO_JOIN_NEST);\n     if ((*conds)->fix_fields_if_needed_for_bool(thd, conds))\n       goto err_no_arena;\n   }\n \n   if (setup_on_expr(thd, tables, it_is_update))\n     goto err_no_arena;\n \n   if (!thd->stmt_arena->is_conventional())\n   {\n     select_lex->where= *conds;\n   }\n   thd->lex->current_select->is_item_list_lookup= save_is_item_list_lookup;\n// bug_start\n// bug_end\n   DBUG_RETURN(thd->is_error());\n \n err_no_arena:\n   select_lex->is_item_list_lookup= save_is_item_list_lookup;\n   DBUG_RETURN(1);\n }\n \n", "target": "// fix_start\n  bool save_resolve_in_select_list= select_lex->context.resolve_in_select_list;\n// fix_end\n// fix_start\n  select_lex->context.resolve_in_select_list= false;\n// fix_end\n// fix_start\n  select_lex->context.resolve_in_select_list= save_resolve_in_select_list;\n// fix_end\n", "cwe": "CWE-416", "cwe_name": "Use After Free", "cve": "CVE-2022-27455", "cve_desc": "MariaDB Server v10.6.3 and below was discovered to contain an use-after-free in the component my_wildcmp_8bit_impl at /strings/ctype-simple.c.", "project": "server", "idx": 216967}
{"source": "// bug_start\naddress_space_translate_for_iotlb(CPUState *cpu, int asidx, hwaddr addr,\n// bug_end\n                                   hwaddr *xlat, hwaddr *plen,\n                                   MemTxAttrs attrs, int *prot)\n {\n     MemoryRegionSection *section;\n     IOMMUMemoryRegion *iommu_mr;\n     IOMMUMemoryRegionClass *imrc;\n     IOMMUTLBEntry iotlb;\n     int iommu_idx;\n// bug_start\n// bug_end\n     AddressSpaceDispatch *d =\n         qatomic_rcu_read(&cpu->cpu_ases[asidx].memory_dispatch);\n \n     for (;;) {\n         section = address_space_translate_internal(d, addr, &addr, plen, false);\n \n         iommu_mr = memory_region_get_iommu(section->mr);\n         if (!iommu_mr) {\n             break;\n         }\n \n         imrc = memory_region_get_iommu_class_nocheck(iommu_mr);\n \n         iommu_idx = imrc->attrs_to_index(iommu_mr, attrs);\n         tcg_register_iommu_notifier(cpu, iommu_mr, iommu_idx);\n         iotlb = imrc->translate(iommu_mr, addr, IOMMU_NONE, iommu_idx);\n         addr = ((iotlb.translated_addr & ~iotlb.addr_mask)\n                 | (addr & iotlb.addr_mask));\n         if (!(iotlb.perm & IOMMU_RO)) {\n             *prot &= ~(PAGE_READ | PAGE_EXEC);\n         }\n         if (!(iotlb.perm & IOMMU_WO)) {\n             *prot &= ~PAGE_WRITE;\n         }\n \n         if (!*prot) {\n             goto translate_fail;\n         }\n \n         d = flatview_to_dispatch(address_space_to_flatview(iotlb.target_as));\n     }\n \n     assert(!memory_region_is_iommu(section->mr));\n     *xlat = addr;\n     return section;\n \n translate_fail:\n// bug_start\n// bug_end\n     return &d->map.sections[PHYS_SECTION_UNASSIGNED];\n }\n \n", "target": "// fix_start\naddress_space_translate_for_iotlb(CPUState *cpu, int asidx, hwaddr orig_addr,\n// fix_end\n// fix_start\n    hwaddr addr = orig_addr;\n// fix_end\n// fix_start\n    assert((orig_addr & ~TARGET_PAGE_MASK) == 0);\n    *xlat = orig_addr;\n// fix_end\n", "cwe": "CWE-908", "cwe_name": "Use of Uninitialized Resource", "cve": "CVE-2022-35414", "cve_desc": "softmmu/physmem.c in QEMU through 7.0.0 can perform an uninitialized read on the translate_fail path, leading to an io_readx or io_writex crash. NOTE: a third party states that the Non-virtualization Use Case in the qemu.org reference applies here, i.e., \"Bugs affecting the non-virtualization use case are not considered security bugs at this time.", "project": "qemu", "idx": 216983}
{"source": " \tint lazy_bdecode(char const* start, char const* end, lazy_entry& ret\n \t\t, error_code& ec, int* error_pos, int depth_limit, int item_limit)\n \t{\n \t\tchar const* const orig_start = start;\n \t\tret.clear();\n \t\tif (start == end) return 0;\n \n \t\tstd::vector<lazy_entry*> stack;\n \n \t\tstack.push_back(&ret);\n \t\twhile (start <= end)\n \t\t{\n \t\t\tif (stack.empty()) break;\n \n \t\t\tlazy_entry* top = stack.back();\n \n \t\t\tif (int(stack.size()) > depth_limit) TORRENT_FAIL_BDECODE(bdecode_errors::depth_exceeded);\n \t\t\tif (start >= end) TORRENT_FAIL_BDECODE(bdecode_errors::unexpected_eof);\n \t\t\tchar t = *start;\n \t\t\t++start;\n \t\t\tif (start >= end && t != 'e') TORRENT_FAIL_BDECODE(bdecode_errors::unexpected_eof);\n \n \t\t\tswitch (top->type())\n \t\t\t{\n \t\t\t\tcase lazy_entry::dict_t:\n \t\t\t\t{\n \t\t\t\t\tif (t == 'e')\n \t\t\t\t\t{\n \t\t\t\t\t\ttop->set_end(start);\n \t\t\t\t\t\tstack.pop_back();\n \t\t\t\t\t\tcontinue;\n \t\t\t\t\t}\n \t\t\t\t\tif (!numeric(t)) TORRENT_FAIL_BDECODE(bdecode_errors::expected_string);\n \t\t\t\t\tboost::int64_t len = t - '0';\n \t\t\t\t\tbdecode_errors::error_code_enum e = bdecode_errors::no_error;\n \t\t\t\t\tstart = parse_int(start, end, ':', len, e);\n \t\t\t\t\tif (e)\n \t\t\t\t\t\tTORRENT_FAIL_BDECODE(e);\n \n// bug_start\n\t\t\t\t\tif (start + len + 1 > end)\n// bug_end\n \t\t\t\t\t\tTORRENT_FAIL_BDECODE(bdecode_errors::unexpected_eof);\n \n \t\t\t\t\tif (len < 0)\n \t\t\t\t\t\tTORRENT_FAIL_BDECODE(bdecode_errors::overflow);\n \n \t\t\t\t\t++start;\n \t\t\t\t\tif (start == end) TORRENT_FAIL_BDECODE(bdecode_errors::unexpected_eof);\n \t\t\t\t\tlazy_entry* ent = top->dict_append(start);\n \t\t\t\t\tif (ent == 0) TORRENT_FAIL_BDECODE(boost::system::errc::not_enough_memory);\n \t\t\t\t\tstart += len;\n \t\t\t\t\tif (start >= end) TORRENT_FAIL_BDECODE(bdecode_errors::unexpected_eof);\n \t\t\t\t\tstack.push_back(ent);\n \t\t\t\t\tt = *start;\n \t\t\t\t\t++start;\n \t\t\t\t\tbreak;\n \t\t\t\t}\n \t\t\t\tcase lazy_entry::list_t:\n \t\t\t\t{\n \t\t\t\t\tif (t == 'e')\n \t\t\t\t\t{\n \t\t\t\t\t\ttop->set_end(start);\n \t\t\t\t\t\tstack.pop_back();\n \t\t\t\t\t\tcontinue;\n \t\t\t\t\t}\n \t\t\t\t\tlazy_entry* ent = top->list_append();\n \t\t\t\t\tif (ent == 0) TORRENT_FAIL_BDECODE(boost::system::errc::not_enough_memory);\n \t\t\t\t\tstack.push_back(ent);\n \t\t\t\t\tbreak;\n \t\t\t\t}\n \t\t\t\tdefault: break;\n \t\t\t}\n \n \t\t\t--item_limit;\n \t\t\tif (item_limit <= 0) TORRENT_FAIL_BDECODE(bdecode_errors::limit_exceeded);\n \n \t\t\ttop = stack.back();\n \t\t\tswitch (t)\n \t\t\t{\n \t\t\t\tcase 'd':\n \t\t\t\t\ttop->construct_dict(start - 1);\n \t\t\t\t\tcontinue;\n \t\t\t\tcase 'l':\n \t\t\t\t\ttop->construct_list(start - 1);\n \t\t\t\t\tcontinue;\n \t\t\t\tcase 'i':\n \t\t\t\t{\n \t\t\t\t\tchar const* int_start = start;\n \t\t\t\t\tstart = find_char(start, end, 'e');\n \t\t\t\t\ttop->construct_int(int_start, start - int_start);\n \t\t\t\t\tif (start == end) TORRENT_FAIL_BDECODE(bdecode_errors::unexpected_eof);\n \t\t\t\t\tTORRENT_ASSERT(*start == 'e');\n \t\t\t\t\t++start;\n \t\t\t\t\tstack.pop_back();\n \t\t\t\t\tcontinue;\n \t\t\t\t}\n \t\t\t\tdefault:\n \t\t\t\t{\n \t\t\t\t\tif (!numeric(t))\n \t\t\t\t\t\tTORRENT_FAIL_BDECODE(bdecode_errors::expected_value);\n \n \t\t\t\t\tboost::int64_t len = t - '0';\n \t\t\t\t\tbdecode_errors::error_code_enum e = bdecode_errors::no_error;\n \t\t\t\t\tstart = parse_int(start, end, ':', len, e);\n \t\t\t\t\tif (e)\n \t\t\t\t\t\tTORRENT_FAIL_BDECODE(e);\n// bug_start\n\t\t\t\t\tif (start + len + 1 > end)\n// bug_end\n \t\t\t\t\t\tTORRENT_FAIL_BDECODE(bdecode_errors::unexpected_eof);\n \t\t\t\t\tif (len < 0)\n \t\t\t\t\t\tTORRENT_FAIL_BDECODE(bdecode_errors::overflow);\n \n \t\t\t\t\t++start;\n// bug_start\n// bug_end\n \t\t\t\t\ttop->construct_string(start, int(len));\n \t\t\t\t\tstack.pop_back();\n \t\t\t\t\tstart += len;\n \t\t\t\t\tcontinue;\n \t\t\t\t}\n \t\t\t}\n \t\t\treturn 0;\n \t\t}\n \t\treturn 0;\n \t}\n \n", "target": "// fix_start\n\t\t\t\t\tconst ptrdiff_t buff_size = end - start - 1;\n\t\t\t\t\tif (len > buff_size)\n// fix_end\n// fix_start\n\n\t\t\t\t\tconst ptrdiff_t buff_size = end - start - 1;\n\t\t\t\t\tif (len > buff_size)\n// fix_end\n// fix_start\n\t\t\t\t\tif (start == end) TORRENT_FAIL_BDECODE(bdecode_errors::unexpected_eof);\n// fix_end\n", "cwe": "CWE-20", "cwe_name": "Improper Input Validation", "cve": "CVE-2015-5685", "cve_desc": "The lazy_bdecode function in BitTorrent DHT bootstrap server (bootstrap-dht ) allows remote attackers to execute arbitrary code via a crafted packet, related to \"improper indexing.\"", "project": "bootstrap-dht", "idx": 217129}
{"source": " GetCode_(gdIOCtx *fd, CODE_STATIC_DATA *scd, int code_size, int flag, int *ZeroDataBlockP)\n {\n \tint i, j, ret;\n \tunsigned char count;\n \n \tif(flag) {\n \t\tscd->curbit = 0;\n \t\tscd->lastbit = 0;\n \t\tscd->last_byte = 0;\n \t\tscd->done = FALSE;\n \t\treturn 0;\n \t}\n \n \tif((scd->curbit + code_size) >= scd->lastbit) {\n \t\tif(scd->done) {\n \t\t\tif(scd->curbit >= scd->lastbit) {\n \t\t\t}\n \t\t\treturn -1;\n \t\t}\n \n \t\tscd->buf[0] = scd->buf[scd->last_byte - 2];\n \t\tscd->buf[1] = scd->buf[scd->last_byte - 1];\n \n \t\tif((count = GetDataBlock(fd, &scd->buf[2], ZeroDataBlockP)) <= 0) {\n \t\t\tscd->done = TRUE;\n \t\t}\n \n \t\tscd->last_byte = 2 + count;\n \t\tscd->curbit = (scd->curbit - scd->lastbit) + 16;\n \t\tscd->lastbit = (2 + count) * 8;\n \t}\n \n \tret = 0;\n \tfor (i = scd->curbit, j = 0; j < code_size; ++i, ++j) {\n// bug_start\n\t\tret |= ((scd->buf[i / 8] & (1 << (i % 8))) != 0) << j;\n// bug_end\n \t}\n \n \tscd->curbit += code_size;\n \n \treturn ret;\n }\n \n", "target": "// fix_start\n\t\tif (i < CSD_BUF_SIZE * 8) {\n\t\t\tret |= ((scd->buf[i / 8] & (1 << (i % 8))) != 0) << j;\n\t\t} else {\n\t\t\tret = -1;\n\t\t\tbreak;\n\t\t}\n// fix_end\n", "cwe": "CWE-119", "cwe_name": "Improper Restriction of Operations within the Bounds of a Memory Buffer", "cve": "CVE-2014-9709", "cve_desc": "The GetCode_ function in gd_gif_in.c in GD 2.1.1 and earlier, as used in PHP before 5.5.21 and 5.6.x before 5.6.5, allows remote attackers to cause a denial of service (buffer over-read and application crash) via a crafted GIF image that is improperly handled by the gdImageCreateFromGif function.", "project": "gd-libgd", "idx": 217131}
{"source": "// bug_start\nvoid ocall_malloc(size_t size, uint8_t **ret) {\n// bug_end\n   *ret = static_cast<uint8_t *>(malloc(size));\n }\n \n", "target": "// fix_start\nvoid unsafe_ocall_malloc(size_t size, uint8_t **ret) {\n// fix_end\n", "cwe": "CWE-787", "cwe_name": "Out-of-bounds Write", "cve": "CVE-2018-20742", "cve_desc": "An issue was discovered in UC Berkeley RISE Opaque before 2018-12-01. There is no boundary check on ocall_malloc. The return value could be a pointer to enclave memory. It could cause an arbitrary enclave memory write.", "project": "opaque", "idx": 217231}
{"source": " int data_on_connection(int fd, callback_remove_handler remove)\n {\n \tint nread;\n \tchar *network_packet;\n \tchar network_line[8192];\n \tchar *p;\n \tunsigned long id;\n \n \tchar string[1024];\n \tunsigned long msg_id = UINT32_MAX;\n \tenum network_protocol version = network_client_get_version(fd);\n \n \tioctl(fd, FIONREAD, &nread);\n \n \tunivention_debug(UV_DEBUG_TRANSFILE, UV_DEBUG_ALL, \"new connection data = %d\\n\",nread);\n \n \tif(nread == 0)\n \t{\n \t\tunivention_debug(UV_DEBUG_TRANSFILE, UV_DEBUG_PROCESS, \"%d failed, got 0 close connection to listener \", fd);\n \t\tclose(fd);\n \t\tFD_CLR(fd, &readfds);\n \t\tremove(fd);\n \t\tnetwork_client_dump ();\n \t\treturn 0;\n \t}\n \n \n \tif ( nread >= 8192 ) {\n \n \t\tunivention_debug(UV_DEBUG_TRANSFILE, UV_DEBUG_ERROR, \"%d failed, more than 8192 close connection to listener \", fd);\n \t\tclose(fd);\n \t\tFD_CLR(fd, &readfds);\n \t\tremove(fd);\n \n \t\treturn 0;\n \t}\n \n \tnetwork_packet=malloc((nread+1) * sizeof(char));\n \tread(fd, network_packet, nread);\n \tnetwork_packet[nread]='\\0';\n \n \tmemset(network_line, 0, 8192);\n \tp=network_packet;\n \tp_sem(sem_id);\n \n \twhile ( get_network_line(p, network_line) ) {\n \n \t\tif ( strlen(network_line) > 0 ) {\n \t\t\tunivention_debug(UV_DEBUG_TRANSFILE, UV_DEBUG_ALL, \"line = [%s]\",network_line);\n \t\t}\n \n \n \t\tif ( !strncmp(network_line, \"MSGID: \", strlen(\"MSGID: \")) ) {\n \n \t\t\tmsg_id=strtoul(&(network_line[strlen(\"MSGID: \")]), NULL, 10);\n \n \t\t\tp+=strlen(network_line);\n \n \n \t\t} else if ( !strncmp(network_line, \"Version: \", strlen(\"Version: \")) ) {\n \t\t\tchar *head = network_line, *end;\n \n \t\t\tunivention_debug(UV_DEBUG_TRANSFILE, UV_DEBUG_ALL, \"RECV: VERSION\");\n \n \t\t\tversion = strtoul(head + 9, &end, 10);\n \t\t\tif (!head[9] || *end)\n \t\t\t\tgoto failed;\n \n \t\t\tunivention_debug(UV_DEBUG_TRANSFILE, UV_DEBUG_ALL, \"VERSION=%d\", version);\n \n \t\t\tif (version < network_procotol_version) {\n \t\t\t\tunivention_debug(UV_DEBUG_TRANSFILE, UV_DEBUG_PROCESS, \"Forbidden VERSION=%d < %d, close connection to listener\", version, network_procotol_version);\n \t\t\t\tgoto close;\n \t\t\t} else if (version >= PROTOCOL_LAST) {\n \t\t\t\tunivention_debug(UV_DEBUG_TRANSFILE, UV_DEBUG_PROCESS, \"Future VERSION=%d\", version);\n \t\t\t\tversion = PROTOCOL_LAST - 1;\n \t\t\t}\n \t\t\tnetwork_client_set_version(fd, version);\n \n \t\t\tmsg_id = UINT32_MAX;\n \n \t\t\tp+=strlen(network_line);\n \n \n \t\t} else if ( !strncmp(network_line, \"Capabilities: \", strlen(\"Capabilities: \")) ) {\n \n \t\t\tunivention_debug(UV_DEBUG_TRANSFILE, UV_DEBUG_ALL, \"RECV: Capabilities\");\n \n \t\t\tif ( version > PROTOCOL_UNKNOWN ) {\n \n \t\t\t\tmemset(string, 0, sizeof(string));\n \n \t\t\t\tsnprintf(string, sizeof(string), \"Version: %d\\nCapabilities: \\n\\n\", version);\n \n \t\t\t\tunivention_debug(UV_DEBUG_TRANSFILE, UV_DEBUG_ALL, \"SEND: %s\", string);\n \n \t\t\t\twrite(fd, string, strlen(string));\n \n \t\t\t} else {\n \n \t\t\t\tunivention_debug(UV_DEBUG_TRANSFILE, UV_DEBUG_ALL, \"Capabilities recv, but no version line\");\n \n \t\t\t}\n \n \t\t\tp+=strlen(network_line);\n \n \n// bug_start\n\t\t} else if ( !strncmp(network_line, \"GET_DN \", strlen(\"GET_DN \")) && msg_id != UINT32_MAX && network_client_get_version(fd) > 0) {\n// bug_end\n \n \t\t\tunivention_debug(UV_DEBUG_TRANSFILE, UV_DEBUG_ALL, \"RECV: GET_DN\");\n \n \t\t\tid=strtoul(&(network_line[strlen(\"GET_DN \")]), NULL, 10);\n \n \t\t\tunivention_debug(UV_DEBUG_TRANSFILE, UV_DEBUG_ALL, \"id: %ld\",id);\n \n \t\t\tif ( id <= notify_last_id.id) {\n \n \t\t\t\tchar *dn_string = NULL;\n \n \t\t\t\tunivention_debug(UV_DEBUG_TRANSFILE, UV_DEBUG_ALL, \"try to read %ld from cache\", id);\n \n \t\t\t\tif ( (dn_string = notifier_cache_get(id)) == NULL ) {\n \n \t\t\t\t\tunivention_debug(UV_DEBUG_TRANSFILE, UV_DEBUG_ALL, \"%ld not found in cache\", id);\n \n \t\t\t\t\tunivention_debug(UV_DEBUG_TRANSFILE, UV_DEBUG_ALL, \"%ld get one dn\", id);\n \n \t\t\t\t\tif( (dn_string=notify_transcation_get_one_dn ( id )) == NULL ) {\n \n \t\t\t\t\t\tunivention_debug(UV_DEBUG_TRANSFILE, UV_DEBUG_ALL, \"%ld failed \", id);\n \n \t\t\t\t\t\tunivention_debug(UV_DEBUG_TRANSFILE, UV_DEBUG_ERROR, \"%d failed, close connection to listener \", fd);\n \t\t\t\t\t\tclose(fd);\n \t\t\t\t\t\tFD_CLR(fd, &readfds);\n \t\t\t\t\t\tremove(fd);\n \n \t\t\t\t\t\treturn 0;\n \t\t\t\t\t}\n \t\t\t\t}\n \n \t\t\t\tif ( dn_string != NULL ) {\n \n \t\t\t\t\tsnprintf(string, sizeof(string), \"MSGID: %ld\\n%s\\n\\n\",msg_id,dn_string);\n \n \t\t\t\t\tunivention_debug(UV_DEBUG_TRANSFILE, UV_DEBUG_ALL, \"--> %d: [%s]\",fd, string);\n \n \t\t\t\t\twrite(fd, string, strlen(string));\n \n \t\t\t\t\tfree(dn_string);\n \n \t\t\t\t}\n \n \n \t\t\t} else {\n \n \t\t\t\tnetwork_client_set_next_id(fd, id);\n \t\t\t\tnetwork_client_set_msg_id(fd, msg_id);\n \n \t\t\t}\n \n \t\t\tp+=strlen(network_line)+1;\n \t\t\tmsg_id = UINT32_MAX;\n \n \t\t} else if (!strncmp(p, \"WAIT_ID \", 8) && msg_id != UINT32_MAX && version >= PROTOCOL_3) {\n \t\t\tchar *head = network_line, *end;\n \t\t\tunivention_debug(UV_DEBUG_TRANSFILE, UV_DEBUG_ALL, \"RECV: WAIT_ID\");\n \t\t\tid = strtoul(head + 8, &end, 10);\n \t\t\tif (!head[8] || *end)\n \t\t\t\tgoto failed;\n \t\t\tunivention_debug(UV_DEBUG_TRANSFILE, UV_DEBUG_ALL, \"id: %ld\", id);\n \n \t\t\tif (id <= notify_last_id.id) {\n \t\t\t\tsnprintf(string, sizeof(string), \"MSGID: %ld\\n%ld\\n\\n\", msg_id, notify_last_id.id);\n \t\t\t\twrite(fd, string, strlen(string));\n \t\t\t} else {\n \t\t\t\tnetwork_client_set_next_id(fd, id);\n \t\t\t\tnetwork_client_set_msg_id(fd, msg_id);\n \t\t\t}\n \n \t\t\tp += strlen(network_line) + 1;\n \t\t\tmsg_id = UINT32_MAX;\n \n \t\t} else if ( !strncmp(network_line, \"GET_ID\", strlen(\"GET_ID\")) && msg_id != UINT32_MAX  && network_client_get_version(fd) > 0) {\n \n \t\t\tunivention_debug(UV_DEBUG_TRANSFILE, UV_DEBUG_ALL, \"RECV: GET_ID\");\n \n \t\t\tmemset(string, 0, sizeof(string));\n \n \t\t\tsnprintf(string, sizeof(string), \"MSGID: %ld\\n%ld\\n\\n\",msg_id,notify_last_id.id);\n \n \t\t\twrite(fd, string, strlen(string));\n \n \t\t\tp+=strlen(network_line)+1;\n \t\t\tmsg_id = UINT32_MAX;\n \n \n \t\t} else if ( !strncmp(network_line, \"GET_SCHEMA_ID\", strlen(\"GET_SCHEMA_ID\")) && msg_id != UINT32_MAX  && network_client_get_version(fd) > 0) {\n \n \t\t\tunivention_debug(UV_DEBUG_TRANSFILE, UV_DEBUG_ALL, \"RECV: GET_SCHEMA_ID\");\n \n \t\t\tmemset(string, 0, sizeof(string));\n \n \t\t\tsnprintf(string, sizeof(string), \"MSGID: %ld\\n%ld\\n\\n\",msg_id,SCHEMA_ID);\n \n \t\t\tunivention_debug(UV_DEBUG_TRANSFILE, UV_DEBUG_ALL, \"--> %d: [%s]\",fd, string);\n \n \t\t\twrite(fd, string, strlen(string));\n \n \t\t\tp+=strlen(network_line)+1;\n \t\t\tmsg_id = UINT32_MAX;\n \n \n \t\t} else if ( !strncmp(network_line, \"ALIVE\", strlen(\"ALIVE\")) && msg_id != UINT32_MAX  && network_client_get_version(fd) > 0) {\n \n \t\t\tunivention_debug(UV_DEBUG_TRANSFILE, UV_DEBUG_ALL, \"RECV: ALIVE\");\n \n \t\t\tsnprintf(string, sizeof(string), \"MSGID: %ld\\nOKAY\\n\\n\",msg_id);\n \n \t\t\twrite(fd, string, strlen(string));\n \n \t\t\tp+=strlen(network_line)+1;\n \t\t\tmsg_id = UINT32_MAX;\n \n \t\t} else {\n \n \t\t\tp+=strlen(network_line);\n \n \t\t\tif (strlen(network_line) == 0 ) {\n \t\t\t\tp+=1;\n  \t\t\t} else {\n \t\t\t\tunivention_debug(UV_DEBUG_TRANSFILE, UV_DEBUG_ERROR, \"Drop package [%s]\", network_line);\n \t\t\t}\n \n \t\t}\n \t}\n \tv_sem(sem_id);\n \n \tunivention_debug(UV_DEBUG_TRANSFILE, UV_DEBUG_ALL, \"END Package\");\n \n \n \tnetwork_client_dump ();\n \n \treturn 0;\n \n failed:\n \tunivention_debug(UV_DEBUG_TRANSFILE, UV_DEBUG_PROCESS, \"Failed parsing [%s]\", p);\n close:\n \tclose(fd);\n \tFD_CLR(fd, &readfds);\n \tremove(fd);\n \treturn 0;\n }\n \n", "target": "// fix_start\n\t\t} else if ( !strncmp(network_line, \"GET_DN \", strlen(\"GET_DN \")) && msg_id != UINT32_MAX && version > PROTOCOL_UNKNOWN && version < PROTOCOL_3) {\n// fix_end\n", "cwe": "CWE-200", "cwe_name": "Exposure of Sensitive Information to an Unauthorized Actor", "cve": "CVE-2019-1010283", "cve_desc": "Univention Corporate Server univention-directory-notifier 12.0.1-3 and earlier is affected by: CWE-213: Intentional Information Exposure. The impact is: Loss of Confidentiality. The component is: function data_on_connection() in src/callback.c. The attack vector is: network connectivity. The fixed version is: 12.0.1-4 and later.", "project": "univention-corporate-server", "idx": 217234}
{"source": " static bool MR_primality_test(UnsignedBigInteger n, const Vector<UnsignedBigInteger, 256>& tests)\n {\n     ASSERT(!(n < 4));\n     auto predecessor = n.minus({ 1 });\n     auto d = predecessor;\n     size_t r = 0;\n \n     {\n         auto div_result = d.divided_by(2);\n         while (div_result.remainder == 0) {\n             d = div_result.quotient;\n             div_result = d.divided_by(2);\n             ++r;\n         }\n     }\n     if (r == 0) {\n         return n == 2;\n     }\n \n// bug_start\n    for (auto a : tests) {\n// bug_end\n         ASSERT(a < n);\n         auto x = ModularPower(a, d, n);\n         if (x == 1 || x == predecessor)\n             continue;\n         bool skip_this_witness = false;\n         for (size_t i = 0; i < r - 1; ++i) {\n             x = ModularPower(x, 2, n);\n             if (x == predecessor) {\n                 skip_this_witness = true;\n                 break;\n             }\n         }\n         if (skip_this_witness)\n             continue;\n         return false;\n     }\n \n     return true;\n }\n \n", "target": "// fix_start\n    for (auto& a : tests) {\n// fix_end\n", "cwe": "CWE-120", "cwe_name": "Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')", "cve": "CVE-2021-27343", "cve_desc": "SerenityOS Unspecified is affected by: Buffer Overflow. The impact is: obtain sensitive information (context-dependent). The component is: /Userland/Libraries/LibCrypto/ASN1/DER.h Crypto::der_decode_sequence() function. The attack vector is: Parsing RSA Key ASN.1.", "project": "serenity", "idx": 217238}
{"source": " String UTF16BEDecoder::to_utf8(const StringView& input)\n {\n     StringBuilder builder(input.length() / 2);\n// bug_start\n    for (size_t i = 0; i < input.length(); i += 2) {\n// bug_end\n         u16 code_point = (input[i] << 8) | input[i + 1];\n         builder.append_code_point(code_point);\n     }\n     return builder.to_string();\n }\n \n", "target": "// fix_start\n    size_t utf16_length = input.length() - (input.length() % 2);\n    for (size_t i = 0; i < utf16_length; i += 2) {\n// fix_end\n", "cwe": "CWE-120", "cwe_name": "Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')", "cve": "CVE-2021-28874", "cve_desc": "SerenityOS fixed as of c9f25bca048443e317f1994ba9b106f2386688c3 contains a buffer overflow vulnerability in LibTextCode through opening a crafted file.", "project": "serenity", "idx": 217239}
{"source": "     bool read(ReadonlyBytes buffer)\n     {\n         auto fields_size = sizeof(CentralDirectoryRecord) - (sizeof(u8*) * 3);\n// bug_start\n        if (buffer.size() < fields_size)\n// bug_end\n             return false;\n         if (memcmp(buffer.data(), central_directory_record_signature, sizeof(central_directory_record_signature)) != 0)\n             return false;\n         memcpy(reinterpret_cast<void*>(&made_by_version), buffer.data() + sizeof(central_directory_record_signature), fields_size);\n// bug_start\n// bug_end\n         name = buffer.data() + sizeof(central_directory_record_signature) + fields_size;\n         extra_data = name + name_length;\n         comment = extra_data + extra_data_length;\n         return true;\n     }\n \n", "target": "// fix_start\n        if (buffer.size() < sizeof(central_directory_record_signature) + fields_size)\n// fix_end\n// fix_start\n        if (buffer.size() < sizeof(end_of_central_directory_signature) + fields_size + comment_length + name_length + extra_data_length)\n            return false;\n// fix_end\n", "cwe": "CWE-120", "cwe_name": "Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')", "cve": "CVE-2021-30045", "cve_desc": "SerenityOS 2021-03-27 contains a buffer overflow vulnerability in the EndOfCentralDirectory::read() function.", "project": "serenity", "idx": 217240}
{"source": "     bool read(ReadonlyBytes buffer)\n     {\n         auto fields_size = sizeof(LocalFileHeader) - (sizeof(u8*) * 3);\n// bug_start\n        if (buffer.size() < fields_size)\n// bug_end\n             return false;\n         if (memcmp(buffer.data(), local_file_header_signature, sizeof(local_file_header_signature)) != 0)\n             return false;\n         memcpy(reinterpret_cast<void*>(&minimum_version), buffer.data() + sizeof(local_file_header_signature), fields_size);\n// bug_start\n// bug_end\n         name = buffer.data() + sizeof(local_file_header_signature) + fields_size;\n         extra_data = name + name_length;\n         compressed_data = extra_data + extra_data_length;\n         return true;\n     }\n \n", "target": "// fix_start\n        if (buffer.size() < sizeof(local_file_header_signature) + fields_size)\n// fix_end\n// fix_start\n        if (buffer.size() < sizeof(end_of_central_directory_signature) + fields_size + name_length + extra_data_length + compressed_size)\n            return false;\n// fix_end\n", "cwe": "CWE-120", "cwe_name": "Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')", "cve": "CVE-2021-30045", "cve_desc": "SerenityOS 2021-03-27 contains a buffer overflow vulnerability in the EndOfCentralDirectory::read() function.", "project": "serenity", "idx": 217241}
{"source": "     bool read(ReadonlyBytes buffer)\n     {\n         auto fields_size = sizeof(EndOfCentralDirectory) - sizeof(u8*);\n// bug_start\n        if (buffer.size() < fields_size)\n// bug_end\n             return false;\n         if (memcmp(buffer.data(), end_of_central_directory_signature, sizeof(end_of_central_directory_signature)) != 0)\n             return false;\n         memcpy(reinterpret_cast<void*>(&disk_number), buffer.data() + sizeof(end_of_central_directory_signature), fields_size);\n// bug_start\n// bug_end\n         comment = buffer.data() + sizeof(end_of_central_directory_signature) + fields_size;\n         return true;\n     }\n \n", "target": "// fix_start\n        if (buffer.size() < sizeof(end_of_central_directory_signature) + fields_size)\n// fix_end\n// fix_start\n        if (buffer.size() < sizeof(end_of_central_directory_signature) + fields_size + comment_length)\n            return false;\n// fix_end\n", "cwe": "CWE-120", "cwe_name": "Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')", "cve": "CVE-2021-30045", "cve_desc": "SerenityOS 2021-03-27 contains a buffer overflow vulnerability in the EndOfCentralDirectory::read() function.", "project": "serenity", "idx": 217242}
{"source": " static int8_t sn_coap_parser_options_parse(struct coap_s *handle, uint8_t **packet_data_pptr, sn_coap_hdr_s *dst_coap_msg_ptr, uint8_t *packet_data_start_ptr, uint16_t packet_len)\n {\n     uint8_t previous_option_number = 0;\n     int8_t  ret_status             = 0;\n     uint16_t message_left          = sn_coap_parser_move_packet_ptr(packet_data_pptr,\n                                                                     packet_data_start_ptr,\n                                                                     packet_len,\n                                                                     0);\n \n     dst_coap_msg_ptr->token_len = *packet_data_start_ptr & COAP_HEADER_TOKEN_LENGTH_MASK;\n \n     if (dst_coap_msg_ptr->token_len) {\n         int8_t ptr_check_result;\n         if ((dst_coap_msg_ptr->token_len > 8) || dst_coap_msg_ptr->token_ptr) {\n             tr_error(\"sn_coap_parser_options_parse - token not valid!\");\n             return -1;\n         }\n \n         ptr_check_result = sn_coap_parser_check_packet_ptr(*packet_data_pptr, packet_data_start_ptr, packet_len, dst_coap_msg_ptr->token_len);\n         if (0 != ptr_check_result) {\n             tr_error(\"sn_coap_parser_options_parse - **packet_data_pptr overflow !\");\n             return -1;\n         }\n \n         dst_coap_msg_ptr->token_ptr = sn_coap_protocol_malloc_copy(handle, *packet_data_pptr, dst_coap_msg_ptr->token_len);\n \n         if (dst_coap_msg_ptr->token_ptr == NULL) {\n             tr_error(\"sn_coap_parser_options_parse - failed to allocate token!\");\n             return -1;\n         }\n \n         message_left = sn_coap_parser_move_packet_ptr(packet_data_pptr,\n                                                       packet_data_start_ptr,\n                                                       packet_len,\n                                                       dst_coap_msg_ptr->token_len);\n     }\n \n     while (message_left && (**packet_data_pptr != 0xff)) {\n         uint16_t option_len = (**packet_data_pptr & 0x0F);\n         uint16_t  option_number = (**packet_data_pptr >> COAP_OPTIONS_OPTION_NUMBER_SHIFT);\n \n         message_left = sn_coap_parser_move_packet_ptr(packet_data_pptr, packet_data_start_ptr, packet_len, 1);\n \n         int8_t    option_parse_result;\n         option_parse_result = parse_ext_option(&option_number,\n                                                 packet_data_pptr,\n                                                 packet_data_start_ptr,\n                                                 packet_len,\n                                                 &message_left);\n         if (option_parse_result != 0) {\n             return -1;\n         }\n// bug_start\n        option_number += previous_option_number;\n// bug_end\n \n         option_parse_result = parse_ext_option(&option_len,\n                                                 packet_data_pptr,\n                                                 packet_data_start_ptr,\n                                                 packet_len,\n                                                 &message_left);\n         if (option_parse_result != 0) {\n             return -1;\n         }\n \n         previous_option_number = option_number;\n         switch (option_number) {\n             case COAP_OPTION_MAX_AGE:\n             case COAP_OPTION_PROXY_URI:\n             case COAP_OPTION_ETAG:\n             case COAP_OPTION_URI_HOST:\n             case COAP_OPTION_LOCATION_PATH:\n             case COAP_OPTION_URI_PORT:\n             case COAP_OPTION_LOCATION_QUERY:\n             case COAP_OPTION_OBSERVE:\n             case COAP_OPTION_URI_QUERY:\n             case COAP_OPTION_BLOCK2:\n             case COAP_OPTION_BLOCK1:\n             case COAP_OPTION_ACCEPT:\n             case COAP_OPTION_SIZE1:\n             case COAP_OPTION_SIZE2:\n                 if (sn_coap_parser_alloc_options(handle, dst_coap_msg_ptr) == NULL) {\n                     tr_error(\"sn_coap_parser_options_parse - failed to allocate options!\");\n                     return -1;\n                 }\n                 break;\n         }\n \n         if (message_left < option_len){\n             tr_error(\"sn_coap_parser_options_parse - **packet_data_pptr would overflow when parsing options!\");\n             return -1;\n         }\n \n         switch (option_number) {\n             case COAP_OPTION_CONTENT_FORMAT:\n                 if ((option_len > 2) || (dst_coap_msg_ptr->content_format != COAP_CT_NONE)) {\n                     tr_error(\"sn_coap_parser_options_parse - COAP_OPTION_CONTENT_FORMAT not valid!\");\n                     return -1;\n                 }\n                 dst_coap_msg_ptr->content_format = (sn_coap_content_format_e) sn_coap_parser_options_parse_uint(packet_data_pptr, option_len);\n                 break;\n \n             case COAP_OPTION_MAX_AGE:\n                 if (option_len > 4) {\n                     tr_error(\"sn_coap_parser_options_parse - COAP_OPTION_MAX_AGE not valid!\");\n                     return -1;\n                 }\n                 dst_coap_msg_ptr->options_list_ptr->max_age = sn_coap_parser_options_parse_uint(packet_data_pptr, option_len);\n                 break;\n \n             case COAP_OPTION_PROXY_URI:\n                 if ((option_len > 1034) || (option_len < 1) || dst_coap_msg_ptr->options_list_ptr->proxy_uri_ptr) {\n                     tr_error(\"sn_coap_parser_options_parse - COAP_OPTION_PROXY_URI not valid!\");\n                     return -1;\n                 }\n                 dst_coap_msg_ptr->options_list_ptr->proxy_uri_len = option_len;\n                 dst_coap_msg_ptr->options_list_ptr->proxy_uri_ptr = sn_coap_protocol_malloc_copy(handle, *packet_data_pptr, option_len);\n \n                 if (dst_coap_msg_ptr->options_list_ptr->proxy_uri_ptr == NULL) {\n                     tr_error(\"sn_coap_parser_options_parse - COAP_OPTION_PROXY_URI allocation failed!\");\n                     return -1;\n                 }\n                 message_left = sn_coap_parser_move_packet_ptr(packet_data_pptr, packet_data_start_ptr, packet_len, option_len);\n                 break;\n \n             case COAP_OPTION_ETAG:\n// bug_start\n// bug_end\n                 ret_status = sn_coap_parser_options_parse_multiple_options(handle, packet_data_pptr,\n                              message_left,\n                              &dst_coap_msg_ptr->options_list_ptr->etag_ptr,\n                              (uint16_t *)&dst_coap_msg_ptr->options_list_ptr->etag_len,\n                              COAP_OPTION_ETAG, option_len);\n                 if (ret_status < 0) {\n                     tr_error(\"sn_coap_parser_options_parse - COAP_OPTION_ETAG not valid!\");\n                     return -1;\n                 }\n                 break;\n \n             case COAP_OPTION_URI_HOST:\n                 if ((option_len > 255) || (option_len < 1) || dst_coap_msg_ptr->options_list_ptr->uri_host_ptr) {\n                     tr_error(\"sn_coap_parser_options_parse - COAP_OPTION_URI_HOST not valid!\");\n                     return -1;\n                 }\n                 dst_coap_msg_ptr->options_list_ptr->uri_host_len = option_len;\n                 dst_coap_msg_ptr->options_list_ptr->uri_host_ptr = sn_coap_protocol_malloc_copy(handle, *packet_data_pptr, option_len);\n \n                 if (dst_coap_msg_ptr->options_list_ptr->uri_host_ptr == NULL) {\n                     tr_error(\"sn_coap_parser_options_parse - COAP_OPTION_URI_HOST allocation failed!\");\n                     return -1;\n                 }\n                 message_left = sn_coap_parser_move_packet_ptr(packet_data_pptr, packet_data_start_ptr, packet_len, option_len);\n                 break;\n \n             case COAP_OPTION_LOCATION_PATH:\n                 if (dst_coap_msg_ptr->options_list_ptr->location_path_ptr) {\n                     tr_error(\"sn_coap_parser_options_parse - COAP_OPTION_LOCATION_PATH exists!\");\n                     return -1;\n                 }\n                 ret_status = sn_coap_parser_options_parse_multiple_options(handle, packet_data_pptr, message_left,\n                              &dst_coap_msg_ptr->options_list_ptr->location_path_ptr, &dst_coap_msg_ptr->options_list_ptr->location_path_len,\n                              COAP_OPTION_LOCATION_PATH, option_len);\n                 if (ret_status <0) {\n                     tr_error(\"sn_coap_parser_options_parse - COAP_OPTION_LOCATION_PATH not valid!\");\n                     return -1;\n                 }\n                 break;\n \n             case COAP_OPTION_URI_PORT:\n                 if ((option_len > 2) || dst_coap_msg_ptr->options_list_ptr->uri_port != COAP_OPTION_URI_PORT_NONE) {\n                     tr_error(\"sn_coap_parser_options_parse - COAP_OPTION_URI_PORT not valid!\");\n                     return -1;\n                 }\n                 dst_coap_msg_ptr->options_list_ptr->uri_port = sn_coap_parser_options_parse_uint(packet_data_pptr, option_len);\n                 break;\n \n             case COAP_OPTION_LOCATION_QUERY:\n// bug_start\n// bug_end\n                 ret_status = sn_coap_parser_options_parse_multiple_options(handle, packet_data_pptr, message_left,\n                              &dst_coap_msg_ptr->options_list_ptr->location_query_ptr, &dst_coap_msg_ptr->options_list_ptr->location_query_len,\n                              COAP_OPTION_LOCATION_QUERY, option_len);\n                 if (ret_status < 0) {\n                     tr_error(\"sn_coap_parser_options_parse - COAP_OPTION_LOCATION_QUERY not valid!\");\n                     return -1;\n                 }\n \n                 break;\n \n             case COAP_OPTION_URI_PATH:\n// bug_start\n// bug_end\n                 ret_status = sn_coap_parser_options_parse_multiple_options(handle, packet_data_pptr, message_left,\n                              &dst_coap_msg_ptr->uri_path_ptr, &dst_coap_msg_ptr->uri_path_len,\n                              COAP_OPTION_URI_PATH, option_len);\n                 if (ret_status < 0) {\n                     tr_error(\"sn_coap_parser_options_parse - COAP_OPTION_URI_PATH not valid!\");\n                     return -1;\n                 }\n                 break;\n \n             case COAP_OPTION_OBSERVE:\n                 if ((option_len > 2) || dst_coap_msg_ptr->options_list_ptr->observe != COAP_OBSERVE_NONE) {\n                     tr_error(\"sn_coap_parser_options_parse - COAP_OPTION_OBSERVE not valid!\");\n                     return -1;\n                 }\n                 dst_coap_msg_ptr->options_list_ptr->observe = sn_coap_parser_options_parse_uint(packet_data_pptr, option_len);\n                 break;\n \n             case COAP_OPTION_URI_QUERY:\n                 ret_status = sn_coap_parser_options_parse_multiple_options(handle, packet_data_pptr, message_left,\n                              &dst_coap_msg_ptr->options_list_ptr->uri_query_ptr, &dst_coap_msg_ptr->options_list_ptr->uri_query_len,\n                              COAP_OPTION_URI_QUERY, option_len);\n                 if (ret_status < 0) {\n                     tr_error(\"sn_coap_parser_options_parse - COAP_OPTION_URI_QUERY not valid!\");\n                     return -1;\n                 }\n                 break;\n \n             case COAP_OPTION_BLOCK2:\n                 if ((option_len > 3) || dst_coap_msg_ptr->options_list_ptr->block2 != COAP_OPTION_BLOCK_NONE) {\n                     tr_error(\"sn_coap_parser_options_parse - COAP_OPTION_BLOCK2 not valid!\");\n                     return -1;\n                 }\n                 dst_coap_msg_ptr->options_list_ptr->block2 = sn_coap_parser_options_parse_uint(packet_data_pptr, option_len);\n                 break;\n \n             case COAP_OPTION_BLOCK1:\n                 if ((option_len > 3) || dst_coap_msg_ptr->options_list_ptr->block1 != COAP_OPTION_BLOCK_NONE) {\n                     tr_error(\"sn_coap_parser_options_parse - COAP_OPTION_BLOCK1 not valid!\");\n                     return -1;\n                 }\n                 dst_coap_msg_ptr->options_list_ptr->block1 = sn_coap_parser_options_parse_uint(packet_data_pptr, option_len);\n                 break;\n \n             case COAP_OPTION_ACCEPT:\n                 if ((option_len > 2) || (dst_coap_msg_ptr->options_list_ptr->accept != COAP_CT_NONE)) {\n                     tr_error(\"sn_coap_parser_options_parse - COAP_OPTION_ACCEPT not valid!\");\n                     return -1;\n                 }\n                 dst_coap_msg_ptr->options_list_ptr->accept = (sn_coap_content_format_e) sn_coap_parser_options_parse_uint(packet_data_pptr, option_len);\n                 break;\n \n             case COAP_OPTION_SIZE1:\n                 if ((option_len > 4) || dst_coap_msg_ptr->options_list_ptr->use_size1) {\n                     tr_error(\"sn_coap_parser_options_parse - COAP_OPTION_SIZE1 not valid!\");\n                     return -1;\n                 }\n                 dst_coap_msg_ptr->options_list_ptr->use_size1 = true;\n                 dst_coap_msg_ptr->options_list_ptr->size1 = sn_coap_parser_options_parse_uint(packet_data_pptr, option_len);\n                 break;\n \n             case COAP_OPTION_SIZE2:\n                 if ((option_len > 4) || dst_coap_msg_ptr->options_list_ptr->use_size2) {\n                     tr_error(\"sn_coap_parser_options_parse - COAP_OPTION_SIZE2 not valid!\");\n                     return -1;\n                 }\n                 dst_coap_msg_ptr->options_list_ptr->use_size2 = true;\n                 dst_coap_msg_ptr->options_list_ptr->size2 = sn_coap_parser_options_parse_uint(packet_data_pptr, option_len);\n                 break;\n \n             default:\n                 tr_error(\"sn_coap_parser_options_parse - unknown option!\");\n                 return -1;\n         }\n \n         if ((*packet_data_pptr - packet_data_start_ptr) > packet_len) {\n             return -1;\n         }\n         message_left = sn_coap_parser_move_packet_ptr(packet_data_pptr,\n                                                       packet_data_start_ptr,\n                                                       packet_len,\n                                                       0);\n     }\n     return 0;\n }\n \n", "target": "// fix_start\n        if(sn_coap_parser_add_u16_limit(option_number, previous_option_number, &option_number) != 0)\n        {\n            return -1;\n        }\n// fix_end\n// fix_start\n                if (dst_coap_msg_ptr->options_list_ptr->etag_ptr)\n                {\n                    tr_error(\"sn_coap_parser_options_parse - COAP_OPTION_ETAG exists!\");\n                    return -1;\n                }\n// fix_end\n// fix_start\n                if (dst_coap_msg_ptr->options_list_ptr->location_query_ptr)\n                {\n                    tr_error(\"sn_coap_parser_options_parse - COAP_OPTION_LOCATION_QUERY exists!\");\n                    return -1;\n                }\n// fix_end\n// fix_start\n                if (dst_coap_msg_ptr->uri_path_ptr)\n                {\n                    tr_error(\"sn_coap_parser_options_parse - COAP_OPTION_URI_PATH exists!\");\n                    return -1;\n                }\n// fix_end\n", "cwe": "CWE-401", "cwe_name": "Missing Release of Memory after Effective Lifetime", "cve": "CVE-2020-12887", "cve_desc": "Memory leaks were discovered in the CoAP library in Arm Mbed OS 5.15.3 when using the Arm mbed-coap library 5.1.5. The CoAP parser is responsible for parsing received CoAP packets. The function sn_coap_parser_options_parse() parses the CoAP option number field of all options present in the input packet. Each option number is calculated as a sum of the previous option number and a delta of the current option. The delta and the previous option number are expressed as unsigned 16-bit integers. Due to lack of overflow detection, it is possible to craft a packet that wraps the option number around and results in the same option number being processed again in a single packet. Certain options allocate memory by calling a memory allocation function. In the cases of COAP_OPTION_URI_QUERY, COAP_OPTION_URI_PATH, COAP_OPTION_LOCATION_QUERY, and COAP_OPTION_ETAG, there is no check on whether memory has already been allocated, which in conjunction with the option number integer overflow may lead to multiple assignments of allocated memory to a single pointer. This has been demonstrated to lead to memory leak by buffer orphaning. As a result, the memory is never freed.", "project": "mbed-coap", "idx": 217244}
{"source": " int PasswdMgr::updatePasswdSpecialFile(const std::string& userName,\n                                        const std::string& newUserName)\n {\n     phosphor::user::shadow::Lock lock();\n \n     size_t bytesWritten = 0;\n     size_t inBytesLen = 0;\n     size_t isUsrFound = false;\n     const EVP_CIPHER* cipher = EVP_aes_128_cbc();\n     std::vector<uint8_t> dataBuf;\n \n     if (readPasswdFileData(dataBuf) != 0)\n     {\n         log<level::DEBUG>(\"Error in reading the encrypted pass file\");\n         return -EIO;\n     }\n \n     if (dataBuf.size() != 0)\n     {\n         inBytesLen =\n             dataBuf.size() + newUserName.size() + EVP_CIPHER_block_size(cipher);\n     }\n \n     std::vector<uint8_t> inBytes(inBytesLen);\n     if (inBytesLen != 0)\n     {\n         char* outPtr = reinterpret_cast<char*>(dataBuf.data());\n         char* nToken = NULL;\n         char* linePtr = strtok_r(outPtr, \"\\n\", &nToken);\n         while (linePtr != NULL)\n         {\n             size_t userEPos = 0;\n \n             std::string lineStr(linePtr);\n             if ((userEPos = lineStr.find(\":\")) != std::string::npos)\n             {\n                 if (userName.compare(lineStr.substr(0, userEPos)) == 0)\n                 {\n                     isUsrFound = true;\n                     if (!newUserName.empty())\n                     {\n                         bytesWritten += std::snprintf(\n                             reinterpret_cast<char*>(&inBytes[0]) + bytesWritten,\n                             (inBytesLen - bytesWritten), \"%s%s\\n\",\n                             newUserName.c_str(),\n                             lineStr.substr(userEPos, lineStr.size()).data());\n                     }\n                 }\n                 else\n                 {\n                     bytesWritten += std::snprintf(\n                         reinterpret_cast<char*>(&inBytes[0]) + bytesWritten,\n                         (inBytesLen - bytesWritten), \"%s\\n\", lineStr.data());\n                 }\n             }\n             linePtr = strtok_r(NULL, \"\\n\", &nToken);\n         }\n         inBytesLen = bytesWritten;\n     }\n     if (!isUsrFound)\n     {\n         log<level::DEBUG>(\"User doesn't exist\");\n         return 0;\n     }\n \n     std::array<uint8_t, maxKeySize> keyBuff;\n     std::ifstream keyFile(encryptKeyFileName, std::ios::in | std::ios::binary);\n     if (!keyFile.good())\n     {\n         log<level::DEBUG>(\"Error in opening encryption key file\");\n         return -EIO;\n     }\n     keyFile.read(reinterpret_cast<char*>(keyBuff.data()), keyBuff.size());\n     if (keyFile.fail())\n     {\n         log<level::DEBUG>(\"Error in reading encryption key file\");\n         return -EIO;\n     }\n     keyFile.close();\n \n     struct stat st = {};\n     if (stat(passwdFileName, &st) != 0)\n     {\n         log<level::DEBUG>(\"Error in getting password file fstat()\");\n         return -EIO;\n     }\n \n     std::string pwdFile(passwdFileName);\n     std::vector<char> tempFileName(pwdFile.begin(), pwdFile.end());\n     std::vector<char> fileTemplate = {'_', '_', 'X', 'X', 'X',\n                                       'X', 'X', 'X', '\\0'};\n     tempFileName.insert(tempFileName.end(), fileTemplate.begin(),\n                         fileTemplate.end());\n     int fd = mkstemp((char*)tempFileName.data());\n     if (fd == -1)\n     {\n         log<level::DEBUG>(\"Error creating temp file\");\n         return -EIO;\n     }\n \n     std::string strTempFileName(tempFileName.data());\n     phosphor::user::File temp(fd, strTempFileName, \"w\", true);\n     if ((temp)() == NULL)\n     {\n         close(fd);\n         log<level::DEBUG>(\"Error creating temp file\");\n         return -EIO;\n     }\n \n// bug_start\n    if (fchmod(fileno((temp)()), st.st_mode) < 0)\n// bug_end\n     {\n         log<level::DEBUG>(\"Error setting fchmod for temp file\");\n         return -EIO;\n     }\n \n     const EVP_MD* digest = EVP_sha256();\n     size_t hashLen = EVP_MD_block_size(digest);\n     std::vector<uint8_t> hash(hashLen);\n     size_t ivLen = EVP_CIPHER_iv_length(cipher);\n     std::vector<uint8_t> iv(ivLen);\n     std::array<uint8_t, EVP_MAX_KEY_LENGTH> key;\n     size_t keyLen = key.size();\n     std::array<uint8_t, EVP_MAX_MD_SIZE> mac;\n     size_t macLen = mac.size();\n \n     if (RAND_bytes(hash.data(), hashLen) != 1)\n     {\n         log<level::DEBUG>(\"Hash genertion failed, bailing out\");\n         return -EIO;\n     }\n     if (NULL == HMAC(digest, keyBuff.data(), keyBuff.size(), hash.data(),\n                      hashLen, key.data(),\n                      reinterpret_cast<unsigned int*>(&keyLen)))\n     {\n         log<level::DEBUG>(\"Failed to create MAC for authentication\");\n         return -EIO;\n     }\n \n     if (RAND_bytes(iv.data(), ivLen) != 1)\n     {\n         log<level::DEBUG>(\"UV genertion failed, bailing out\");\n         return -EIO;\n     }\n \n     std::vector<uint8_t> outBytes(inBytesLen + EVP_MAX_BLOCK_LENGTH);\n     size_t outBytesLen = 0;\n     if (inBytesLen != 0)\n     {\n         if (encryptDecryptData(true, EVP_aes_128_cbc(), key.data(), keyLen,\n                                iv.data(), ivLen, inBytes.data(), inBytesLen,\n                                mac.data(), &macLen, outBytes.data(),\n                                &outBytesLen) != 0)\n         {\n             log<level::DEBUG>(\"Error while encrypting the data\");\n             return -EIO;\n         }\n         outBytes[outBytesLen] = 0;\n     }\n     OPENSSL_cleanse(key.data(), keyLen);\n \n     MetaPassStruct metaData = {META_PASSWD_SIG, {0, 0}, 0, 0, 0, 0, 0};\n     metaData.hashSize = hashLen;\n     metaData.ivSize = ivLen;\n     metaData.dataSize = bytesWritten;\n     metaData.padSize = outBytesLen - bytesWritten;\n     metaData.macSize = macLen;\n \n     if (fwrite(&metaData, 1, sizeof(metaData), (temp)()) != sizeof(metaData))\n     {\n         log<level::DEBUG>(\"Error in writing meta data\");\n         return -EIO;\n     }\n \n     if (fwrite(&hash[0], 1, hashLen, (temp)()) != hashLen)\n     {\n         log<level::DEBUG>(\"Error in writing hash data\");\n         return -EIO;\n     }\n \n     if (fwrite(&iv[0], 1, ivLen, (temp)()) != ivLen)\n     {\n         log<level::DEBUG>(\"Error in writing IV data\");\n         return -EIO;\n     }\n \n     if (fwrite(&outBytes[0], 1, outBytesLen, (temp)()) != outBytesLen)\n     {\n         log<level::DEBUG>(\"Error in writing encrypted data\");\n         return -EIO;\n     }\n \n     if (fwrite(&mac[0], 1, macLen, (temp)()) != macLen)\n     {\n         log<level::DEBUG>(\"Error in writing MAC data\");\n         return -EIO;\n     }\n \n     if (fflush((temp)()))\n     {\n         log<level::DEBUG>(\n             \"File fflush error while writing entries to special file\");\n         return -EIO;\n     }\n \n     OPENSSL_cleanse(iv.data(), ivLen);\n \n     if (std::rename(strTempFileName.data(), passwdFileName) != 0)\n     {\n         log<level::DEBUG>(\"Failed to rename tmp file to ipmi-pass\");\n         return -EIO;\n     }\n \n     return 0;\n }\n \n", "target": "// fix_start\n    if (fchmod(fileno((temp)()), S_IRUSR | S_IWUSR) < 0)\n// fix_end\n", "cwe": "CWE-276", "cwe_name": "Incorrect Default Permissions", "cve": "CVE-2020-14156", "cve_desc": "user_channel/passwd_mgr.cpp in OpenBMC phosphor-host-ipmid before 2020-04-03 does not ensure that /etc/ipmi-pass has strong file permissions.", "project": "phosphor-host-ipmid", "idx": 217248}
{"source": " static PyObject* patch(PyObject* self, PyObject* args)\n {\n     char *origData, *newData, *diffBlock, *extraBlock, *diffPtr, *extraPtr;\n     Py_ssize_t origDataLength, newDataLength, diffBlockLength, extraBlockLength;\n     PyObject *controlTuples, *tuple, *results;\n     off_t oldpos, newpos, x, y, z;\n     int i, j, numTuples;\n \n     if (!PyArg_ParseTuple(args, \"s#nO!s#s#\",\n                           &origData, &origDataLength, &newDataLength,\n                           &PyList_Type, &controlTuples,\n                           &diffBlock, &diffBlockLength,\n                           &extraBlock, &extraBlockLength))\n         return NULL;\n \n     newData = PyMem_Malloc(newDataLength + 1);\n     if (!newData)\n         return PyErr_NoMemory();\n \n     oldpos = 0;\n     newpos = 0;\n     diffPtr = diffBlock;\n     extraPtr = extraBlock;\n     numTuples = PyList_GET_SIZE(controlTuples);\n     for (i = 0; i < numTuples; i++) {\n         tuple = PyList_GET_ITEM(controlTuples, i);\n         if (!PyTuple_Check(tuple)) {\n             PyMem_Free(newData);\n             PyErr_SetString(PyExc_TypeError, \"expecting tuple\");\n             return NULL;\n         }\n         if (PyTuple_GET_SIZE(tuple) != 3) {\n             PyMem_Free(newData);\n             PyErr_SetString(PyExc_TypeError, \"expecting tuple of size 3\");\n             return NULL;\n         }\n         x = PyLong_AsLong(PyTuple_GET_ITEM(tuple, 0));\n         y = PyLong_AsLong(PyTuple_GET_ITEM(tuple, 1));\n         z = PyLong_AsLong(PyTuple_GET_ITEM(tuple, 2));\n         if (newpos + x > newDataLength ||\n// bug_start\n                diffPtr + x > diffBlock + diffBlockLength ||\n                extraPtr + y > extraBlock + extraBlockLength) {\n// bug_end\n             PyMem_Free(newData);\n             PyErr_SetString(PyExc_ValueError, \"corrupt patch (overflow)\");\n             return NULL;\n         }\n         memcpy(newData + newpos, diffPtr, x);\n         diffPtr += x;\n         for (j = 0; j < x; j++)\n             if ((oldpos + j >= 0) && (oldpos + j < origDataLength))\n                 newData[newpos + j] += origData[oldpos + j];\n         newpos += x;\n         oldpos += x;\n// bug_start\n// bug_end\n         memcpy(newData + newpos, extraPtr, y);\n         extraPtr += y;\n         newpos += y;\n         oldpos += z;\n     }\n \n     if (newpos != newDataLength ||\n             diffPtr != diffBlock + diffBlockLength ||\n             extraPtr != extraBlock + extraBlockLength) {\n         PyMem_Free(newData);\n         PyErr_SetString(PyExc_ValueError, \"corrupt patch (underflow)\");\n         return NULL;\n     }\n \n     results = PyBytes_FromStringAndSize(newData, newDataLength);\n     PyMem_Free(newData);\n     return results;\n }\n \n", "target": "// fix_start\n                diffPtr + x > diffBlock + diffBlockLength) {\n// fix_end\n// fix_start\n        if (newpos + y > newDataLength ||\n                extraPtr + y > extraBlock + extraBlockLength) {\n            PyMem_Free(newData);\n            PyErr_SetString(PyExc_ValueError, \"corrupt patch (overflow)\");\n            return NULL;\n        }\n// fix_end\n", "cwe": "CWE-787", "cwe_name": "Out-of-bounds Write", "cve": "CVE-2020-15904", "cve_desc": "A buffer overflow in the patching routine of bsdiff4 before 1.2.0 allows an attacker to write to heap memory (beyond allocated bounds) via a crafted patch file.", "project": "bsdiff4", "idx": 217249}
{"source": " static int src_parser_trans_stage_1_2_3(const int tmp_fd, const char *src, const struct trans_config cfg)\n {\n     struct parser_buf pbuf = {\n         .f_indx = 0,\n         .tmp_indx = 0,\n         .f_read_size = 0\n     };\n \n     int write_count = 0;\n     int src_fd;\n     int p_state = P_STATE_CODE;\n \n     src_fd = open(src, O_RDONLY);\n     if (src_fd == -1) {\n         fprintf(stderr, \"**Error: Could not open source file: %s.\\n\", src);\n         return -1;\n     }\n \n     while (p_buf_refill(&pbuf, src_fd) > 0) {\n \n         while (PBUF_F_REMD(pbuf)) {\n \n             switch (p_state) {\n             case P_STATE_COMMENT_C:\n \n                 switch (PBUF_F_CHAR(pbuf)) {\n                 case '*':\n                     p_buf_push_tmp_char(&pbuf, '*');\n                     continue;\n \n                 case '/':\n                     if (pbuf.tmp_indx && (PBUF_TMP_PREV_CHAR(pbuf) == '*')) {\n                         pbuf.tmp_indx--;\n                         p_state = P_STATE_CODE;\n                     }\n                     break;\n \n                 default:\n                     if (pbuf.tmp_indx && (PBUF_TMP_PREV_CHAR(pbuf) == '*'))\n                         pbuf.tmp_indx--;\n                     break;\n                 }\n \n                 pbuf.f_indx++;\n \n             case P_STATE_CODE:\n             default:\n \n \n                 switch (PBUF_F_CHAR(pbuf)) {\n                 case ' ':\n                 case '\\t':\n                     if (pbuf.tmp_indx &&\n                             (PBUF_TMP_PREV_CHAR(pbuf) == ' ' || PBUF_TMP_PREV_CHAR(pbuf) == '\\t' ||\n                              PBUF_TMP_PREV_CHAR(pbuf) == '\\n'))\n                         pbuf.f_indx++;\n                     else\n                         p_buf_push_tmp_char(&pbuf, ' ');\n \n                     continue;\n \n                 case '\\r':\n                 case '\\n':\n                     if (pbuf.tmp_indx &&\n                             (PBUF_TMP_PREV_CHAR(pbuf) == ' ' || PBUF_TMP_PREV_CHAR(pbuf) == '\\t' ||\n                              PBUF_TMP_PREV_CHAR(pbuf) == '\\n')) {\n                         pbuf.f_indx++;\n                     } else if (pbuf.tmp_indx &&\n                             (PBUF_TMP_PREV_CHAR(pbuf) == '\\\\')) {\n                         pbuf.tmp_indx--;\n                         pbuf.f_indx++;\n                     } else {\n                         p_buf_push_tmp_char(&pbuf, '\\n');\n                     }\n \n                     continue;\n \n                 case '\\\\':\n// bug_start\n// bug_end\n                     p_buf_push_tmp_char(&pbuf, '\\\\');\n                     continue;\n \n                 case '/':\n// bug_start\n// bug_end\n                     p_buf_push_tmp_char(&pbuf, '/');\n                     continue;\n \n                 case '*':\n                     if (pbuf.tmp_indx &&\n                             (PBUF_TMP_PREV_CHAR(pbuf) == '/')) {\n                         pbuf.tmp_indx--;\n                         pbuf.f_indx++;\n                         p_state = P_STATE_COMMENT_C;\n                         continue;\n                     }\n \n                 default:\n                     break;\n                 }\n \n                 p_buf_write_tmp(&pbuf, tmp_fd);\n                 p_buf_write_f_char(&pbuf, tmp_fd);\n             }\n         }\n     }\n \n     p_buf_write_tmp(&pbuf, tmp_fd);\n     return 0;\n }\n \n", "target": "// fix_start\n                    p_buf_write_tmp(&pbuf, tmp_fd);\n// fix_end\n// fix_start\n                    p_buf_write_tmp(&pbuf, tmp_fd);\n// fix_end\n", "cwe": "CWE-120", "cwe_name": "Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')", "cve": "CVE-2020-21572", "cve_desc": "Buffer overflow vulnerability in function src_parser_trans_stage_1_2_3 trgil gilcc before commit 803969389ca9c06237075a7f8eeb1a19e6651759, allows attackers to cause a denial of service.", "project": "gilcc", "idx": 217253}
{"source": " static XMLSharedNodeList* find_impl(xmlXPathContext* ctxt, const string& xpath)\n {\n \txmlXPathObject* result = xmlXPathEval((const xmlChar*)xpath.c_str(), ctxt);\n \n \tif (!result) {\n// bug_start\n// bug_end\n \t\txmlXPathFreeContext(ctxt);\n// bug_start\n\t\txmlFreeDoc(ctxt->doc);\n// bug_end\n \n \t\tthrow XMLException(\"Invalid XPath: \" + xpath);\n \t}\n \n \tif (result->type != XPATH_NODESET) {\n \t\txmlXPathFreeObject(result);\n// bug_start\n// bug_end\n \t\txmlXPathFreeContext(ctxt);\n// bug_start\n\t\txmlFreeDoc(ctxt->doc);\n// bug_end\n \n \t\tthrow XMLException(\"Only nodeset result types are supported.\");\n \t}\n \n \txmlNodeSet* nodeset = result->nodesetval;\n \tXMLSharedNodeList* nodes = new XMLSharedNodeList();\n \tif (nodeset) {\n \t\tfor (int i = 0; i < nodeset->nodeNr; ++i) {\n \t\t\tXMLNode* node = readnode(nodeset->nodeTab[i]);\n \t\t\tnodes->push_back(boost::shared_ptr<XMLNode>(node));\n \t\t}\n \t} else {\n \t}\n \n \txmlXPathFreeObject(result);\n \n \treturn nodes;\n }\n \n", "target": "// fix_start\n\t\txmlFreeDoc(ctxt->doc);\n// fix_end\n// fix_start\n// fix_end\n// fix_start\n\t\txmlFreeDoc(ctxt->doc);\n// fix_end\n// fix_start\n// fix_end\n", "cwe": "CWE-416", "cwe_name": "Use After Free", "cve": "CVE-2020-22617", "cve_desc": "Ardour v5.12 contains a use-after-free vulnerability in the component ardour/libs/pbd/xml++.cc when using xmlFreeDoc and xmlXPathFreeContext.", "project": "ardour", "idx": 217254}
{"source": " int Jsi_ObjArraySizer(Jsi_Interp *interp, Jsi_Obj *obj, uint len)\n {\n// bug_start\n    int nsiz = len + 1, mod = ALLOC_MOD_SIZE;\n// bug_end\n     assert(obj->isarrlist);\n     if (mod>1)\n         nsiz = nsiz + ((mod-1) - (nsiz + mod - 1)%mod);\n// bug_start\n    if (nsiz > MAX_ARRAY_LIST) {\n        Jsi_LogError(\"array size too large\");\n// bug_end\n         return 0;\n     }\n     if (len >= obj->arrMaxSize) {\n         int oldsz = (nsiz-obj->arrMaxSize);\n         obj->arr = (Jsi_Value**)Jsi_Realloc(obj->arr, nsiz*sizeof(Jsi_Value*));\n         memset(obj->arr+obj->arrMaxSize, 0, oldsz*sizeof(Jsi_Value*));\n         obj->arrMaxSize = nsiz;\n     }\n     if (len>obj->arrCnt)\n         obj->arrCnt = len;\n     return nsiz;\n }\n \n", "target": "// fix_start\n    uint nsiz = len + 1, mod = ALLOC_MOD_SIZE;\n// fix_end\n// fix_start\n    if (len >= interp->maxArrayList || nsiz > interp->maxArrayList) {\n        Jsi_LogError(\"array size too big: %u >= %u\", len, interp->maxArrayList);\n// fix_end\n", "cwe": "CWE-190", "cwe_name": "Integer Overflow or Wraparound", "cve": "CVE-2020-22874", "cve_desc": "Integer overflow vulnerability in function Jsi_ObjArraySizer in jsish before 3.0.8, allows remote attackers to execute arbitrary code.", "project": "jsish", "idx": 217321}
{"source": " ngx_http_auth_spnego_handler(\n         ngx_http_request_t * r)\n {\n     ngx_int_t ret = NGX_DECLINED;\n     ngx_http_auth_spnego_ctx_t *ctx;\n     ngx_http_auth_spnego_loc_conf_t *alcf;\n \n     alcf = ngx_http_get_module_loc_conf(r, ngx_http_auth_spnego_module);\n \n     if (alcf->protect == 0) {\n         return NGX_DECLINED;\n     }\n \n     ctx = ngx_http_get_module_ctx(r, ngx_http_auth_spnego_module);\n     if (NULL == ctx) {\n         ctx = ngx_palloc(r->pool, sizeof(ngx_http_auth_spnego_ctx_t));\n         if (NULL == ctx) {\n             return NGX_HTTP_INTERNAL_SERVER_ERROR;\n         }\n         ctx->token.len = 0;\n         ctx->token.data = NULL;\n         ctx->head = 0;\n         ctx->ret = NGX_HTTP_UNAUTHORIZED;\n         ngx_http_set_ctx(r, ctx, ngx_http_auth_spnego_module);\n     }\n \n     spnego_debug3(\"SSO auth handling IN: token.len=%d, head=%d, ret=%d\",\n             ctx->token.len, ctx->head, ctx->ret);\n \n     if (ctx->token.len && ctx->head) {\n         spnego_debug1(\"Found token and head, returning %d\", ctx->ret);\n         return ctx->ret;\n     }\n \n     if (NULL != r->headers_in.user.data) {\n         spnego_debug0(\"User header set\");\n         return NGX_OK;\n     }\n \n     spnego_debug0(\"Begin auth\");\n \n     if (alcf->allow_basic) {\n         spnego_debug0(\"Detect basic auth\");\n         ret = ngx_http_auth_basic_user(r);\n         if (NGX_OK == ret) {\n             spnego_debug0(\"Basic auth credentials supplied by client\");\n// bug_start\n            if (NGX_DECLINED == ngx_http_auth_spnego_basic(r, ctx, alcf)) {\n// bug_end\n                 spnego_debug0(\"Basic auth failed\");\n                 if (NGX_ERROR == ngx_http_auth_spnego_headers_basic_only(r, ctx, alcf)) {\n                     spnego_debug0(\"Error setting headers\");\n                     return (ctx->ret = NGX_HTTP_INTERNAL_SERVER_ERROR);\n                 }\n                 return (ctx->ret = NGX_HTTP_UNAUTHORIZED);\n             }\n \n             if (!ngx_spnego_authorized_principal(r, &r->headers_in.user, alcf)) {\n                 spnego_debug0(\"User not authorized\");\n                 return (ctx->ret = NGX_HTTP_FORBIDDEN);\n             }\n \n             spnego_debug0(\"Basic auth succeeded\");\n             return (ctx->ret = NGX_OK);\n         }\n     }\n \n     spnego_debug0(\"Detect SPNEGO token\");\n     ret = ngx_http_auth_spnego_token(r, ctx);\n     if (NGX_OK == ret) {\n         spnego_debug0(\"Client sent a reasonable Negotiate header\");\n         ret = ngx_http_auth_spnego_auth_user_gss(r, ctx, alcf);\n         if (NGX_ERROR == ret) {\n             spnego_debug0(\"GSSAPI failed\");\n             return (ctx->ret = NGX_HTTP_INTERNAL_SERVER_ERROR);\n         }\n         if (NGX_DECLINED == ret) {\n             spnego_debug0(\"GSSAPI failed\");\n             if(!alcf->allow_basic) {\n                 return (ctx->ret = NGX_HTTP_FORBIDDEN);\n             }\n             if (NGX_ERROR == ngx_http_auth_spnego_headers_basic_only(r, ctx, alcf)) {\n                 spnego_debug0(\"Error setting headers\");\n                 return (ctx->ret = NGX_HTTP_INTERNAL_SERVER_ERROR);\n             }\n             return (ctx->ret = NGX_HTTP_UNAUTHORIZED);\n         }\n \n         if (!ngx_spnego_authorized_principal(r, &r->headers_in.user, alcf)) {\n             spnego_debug0(\"User not authorized\");\n             return (ctx->ret = NGX_HTTP_FORBIDDEN);\n         }\n \n         spnego_debug0(\"GSSAPI auth succeeded\");\n     }\n \n     ngx_str_t *token_out_b64 = NULL;\n     switch(ret) {\n         case NGX_DECLINED:\n             ctx->ret = NGX_HTTP_UNAUTHORIZED;\n             break;\n         case NGX_OK:\n             ctx->ret = NGX_OK;\n             token_out_b64 = &ctx->token_out_b64;\n             break;\n         case NGX_ERROR:\n         default:\n             ctx->ret = NGX_HTTP_INTERNAL_SERVER_ERROR;\n             break;\n     }\n \n     if (NGX_ERROR == ngx_http_auth_spnego_headers(r, ctx, token_out_b64, alcf)) {\n         spnego_debug0(\"Error setting headers\");\n         ctx->ret = NGX_HTTP_INTERNAL_SERVER_ERROR;\n     }\n \n     spnego_debug3(\"SSO auth handling OUT: token.len=%d, head=%d, ret=%d\",\n             ctx->token.len, ctx->head, ctx->ret);\n     return ctx->ret;\n }\n \n", "target": "// fix_start\n            if (NGX_OK != ngx_http_auth_spnego_basic(r, ctx, alcf)) {\n// fix_end\n", "cwe": "CWE-287", "cwe_name": "Improper Authentication", "cve": "CVE-2021-21335", "cve_desc": "In the SPNEGO HTTP Authentication Module for nginx (spnego-http-auth-nginx-module) before version 1.1.1 basic Authentication can be bypassed using a malformed username. This affects users of spnego-http-auth-nginx-module that have enabled basic authentication. This is fixed in version 1.1.1 of spnego-http-auth-nginx-module. As a workaround, one may disable basic authentication.", "project": "spnego-http-auth-nginx-module", "idx": 217457}
{"source": " static uint64_t unpack_timestamp(const struct efi_time *timestamp)\n {\n \tuint64_t val = 0;\n// bug_start\n\tuint16_t year = le32_to_cpu(timestamp->year);\n// bug_end\n \n \tval |= ((uint64_t) timestamp->pad1 & 0xFF) << 0;\n \tval |= ((uint64_t) timestamp->second & 0xFF) << (1*8);\n \tval |= ((uint64_t) timestamp->minute & 0xFF) << (2*8);\n \tval |= ((uint64_t) timestamp->hour & 0xFF) << (3*8);\n \tval |= ((uint64_t) timestamp->day & 0xFF) << (4*8);\n \tval |= ((uint64_t) timestamp->month & 0xFF) << (5*8);\n \tval |= ((uint64_t) year) << (6*8);\n \n \treturn val;\n }\n \n", "target": "// fix_start\n\tuint16_t year = le16_to_cpu(timestamp->year);\n// fix_end\n", "cwe": "CWE-681", "cwe_name": "Incorrect Conversion between Numeric Types", "cve": "CVE-2021-36357", "cve_desc": "An issue was discovered in OpenPOWER 2.6 firmware. unpack_timestamp() calls le32_to_cpu() for endian conversion of a uint16_t \"year\" value, resulting in a type mismatch that can truncate a higher integer value to a smaller one, and bypass a timestamp check. The fix is to use the right endian conversion function.", "project": "skiboot", "idx": 217514}
