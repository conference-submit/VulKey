{"vul_id": "VUL4J-1", "cwe": "CWE-20", "cwe_name": "Improper Input Validation", "source": "public <T> T deserialze(DefaultJSONParser parser, Type type, Object fieldName) {\n    final JSONLexer lexer = parser.lexer;\n    if (lexer.token() == JSONToken.NULL) {\n        lexer.nextToken(JSONToken.COMMA);\n        return null;\n    }\n    if (lexer.token() == JSONToken.LITERAL_STRING) {\n        byte[] bytes = lexer.bytesValue();\n        lexer.nextToken(JSONToken.COMMA);\n        return (T) bytes;\n    }\n    Class componentClass;\n    Type componentType;\n    if (type instanceof GenericArrayType) {\n        GenericArrayType clazz = (GenericArrayType) type;\n        componentType = clazz.getGenericComponentType();\n        if (componentType instanceof TypeVariable) {\n            TypeVariable typeVar = (TypeVariable) componentType;\n            Type objType = parser.getContext().type;\n            if (objType instanceof ParameterizedType) {\n                ParameterizedType objParamType = (ParameterizedType) objType;\n                Type objRawType = objParamType.getRawType();\n                Type actualType = null;\n                if (objRawType instanceof Class) {\n                    TypeVariable[] objTypeParams = ((Class) objRawType).getTypeParameters();\n                    for (int i = 0; i < objTypeParams.length; ++i) {\n                        if (objTypeParams[i].getName().equals(typeVar.getName())) {\n                            actualType = objParamType.getActualTypeArguments()[i];\n                        }\n                    }\n                }\n                if (actualType instanceof Class) {\n                    componentClass = (Class) actualType;\n                } else {\n                    componentClass = Object.class;\n                }\n            } else {\n                componentClass = TypeUtils.getClass(typeVar.getBounds()[0]);\n            }\n        } else {\n            componentClass = TypeUtils.getClass(componentType);\n        }\n    } else {\n        Class clazz = (Class) type;\n        componentType = componentClass = clazz.getComponentType();\n    }\n    JSONArray array = new JSONArray();\n// bug_start\n    parser.parseArray(componentClass, array, fieldName);\n// bug_end\n    return (T) toObjectArray(parser, componentClass, array);\n}\n", "target": "// fix_start\n    parser.parseArray(componentType, array, fieldName);\n// fix_end\n"}
{"vul_id": "VUL4J-3", "cwe": "CWE-611", "cwe_name": "Improper Restriction of XML External Entity Reference ('XXE')", "source": "public SAXSource toSAXSourceFromStream(StreamSource source, Exchange exchange) throws SAXException {\n    InputSource inputSource;\n    if (source.getReader() != null) {\n        inputSource = new InputSource(source.getReader());\n    } else {\n        inputSource = new InputSource(source.getInputStream());\n    }\n    inputSource.setSystemId(source.getSystemId());\n    inputSource.setPublicId(source.getPublicId());\n    XMLReader xmlReader = null;\n    SAXParserFactory sfactory = null;\n    try {\n        if (exchange != null) {\n            sfactory = exchange.getProperty(Exchange.SAXPARSER_FACTORY, SAXParserFactory.class);\n        }\n        if (sfactory == null) {\n            sfactory = SAXParserFactory.newInstance();\n            try {\n                sfactory.setFeature(javax.xml.XMLConstants.FEATURE_SECURE_PROCESSING, true);\n            } catch (Exception e) {\n                LOG.warn(\"SAXParser doesn't support the feature {} with value {}, due to {}.\", new Object[]{javax.xml.XMLConstants.FEATURE_SECURE_PROCESSING, \"true\", e});\n            }\n        }\n// bug_start\n        sfactory.setNamespaceAware(true);\n// bug_end\n        SAXParser parser = sfactory.newSAXParser();\n        xmlReader = parser.getXMLReader();\n    } catch (Exception ex) {\n        LOG.warn(\"Cannot create the SAXParser XMLReader, due to {}\", ex);\n    }\n    return new SAXSource(xmlReader, inputSource);\n}\n", "target": "// fix_start\n        try {\n            sfactory.setFeature(\"http://xml.org/sax/features/external-general-entities\", false);\n        } catch (SAXException e) {\n            LOG.warn(\"SAXParser doesn't support the feature {} with value {}, due to {}.\", new Object[]{\"http://xml.org/sax/features/external-general-entities\", false, e});                \n        }\n        sfactory.setNamespaceAware(true);\n// fix_end\n"}
{"vul_id": "VUL4J-4", "cwe": "CWE-611", "cwe_name": "Improper Restriction of XML External Entity Reference ('XXE')", "source": "protected Object doGetDocument(Exchange exchange, Object body) throws Exception {\n    if (body == null) {\n        return null;\n    }\n    Object answer = null;\n    Class<?> type = getDocumentType();\n    Exception cause = null;\n    if (type != null) {\n        try {\n            answer = exchange.getContext().getTypeConverter().convertTo(type, exchange, body);\n        } catch (Exception e) {\n            cause = e;\n        }\n    }\n// bug_start\n    if (answer == null) {\n        if (body instanceof WrappedFile) {\n            InputStream is = exchange.getContext().getTypeConverter().convertTo(InputStream.class, exchange, body);\n            answer = new InputSource(is);\n        } else if (body instanceof BeanInvocation) {\n            BeanInvocation bi = exchange.getContext().getTypeConverter().convertTo(BeanInvocation.class, exchange, body);\n            if (bi.getArgs() != null && bi.getArgs().length == 1 && bi.getArgs()[0] == null) {\n                answer = null;\n            }\n        } else if (body instanceof String) {\n            answer = new InputSource(new StringReader((String) body));\n        }\n    }\n// bug_end\n    if (type == null && answer == null) {\n        answer = body;\n    } else if (answer == null) {\n        if (cause != null) {\n            throw cause;\n        } else {\n            throw new NoTypeConversionAvailableException(body, type);\n        }\n    }\n    return answer;\n}\n", "target": "// fix_start\n// fix_end\n"}
{"vul_id": "VUL4J-5", "cwe": "CWE-22", "cwe_name": "Path Traversal", "source": "private void expand(ArchiveEntrySupplier supplier, EntryWriter writer, File targetDirectory)\n    throws IOException {\n// bug_start\n    String targetDirPath = targetDirectory.getCanonicalPath();\n// bug_end\n    ArchiveEntry nextEntry = supplier.getNextReadableEntry();\n    while (nextEntry != null) {\n        File f = new File(targetDirectory, nextEntry.getName());\n        if (!f.getCanonicalPath().startsWith(targetDirPath)) {\n            throw new IOException(\"expanding \" + nextEntry.getName()\n                + \" would create file outside of \" + targetDirectory);\n        }\n        if (nextEntry.isDirectory()) {\n            if (!f.isDirectory() && !f.mkdirs()) {\n                throw new IOException(\"failed to create directory \" + f);\n            }\n        } else {\n            File parent = f.getParentFile();\n            if (!parent.isDirectory() && !parent.mkdirs()) {\n                throw new IOException(\"failed to create directory \" + parent);\n            }\n            try (OutputStream o = Files.newOutputStream(f.toPath())) {\n                writer.writeEntryDataTo(nextEntry, o);\n            }\n        }\n        nextEntry = supplier.getNextReadableEntry();\n    }\n}\n", "target": "// fix_start\n    String targetDirPath = targetDirectory.getCanonicalPath() + File.separatorChar;\n// fix_end\n"}
{"vul_id": "VUL4J-6", "cwe": "CWE-835", "cwe_name": "Loop with Unreachable Exit Condition ('Infinite Loop')", "source": "public void parseCentralDirectoryFormat(final byte[] data, final int offset, final int length) {\n    this.format = ZipShort.getValue(data, offset);\n    this.algId = EncryptionAlgorithm.getAlgorithmByCode(ZipShort.getValue(data, offset + 2));\n    this.bitlen = ZipShort.getValue(data, offset + 4);\n    this.flags = ZipShort.getValue(data, offset + 6);\n    this.rcount = ZipLong.getValue(data, offset + 8);\n    if (rcount > 0) {\n        this.hashAlg = HashAlgorithm.getAlgorithmByCode(ZipShort.getValue(data, offset + 12));\n        this.hashSize = ZipShort.getValue(data, offset + 14);\n// bug_start\n        for (int i = 0; i < this.rcount; i++) {\n// bug_end\n            for (int j = 0; j < this.hashSize; j++) {\n            }\n        }\n    }\n}\n", "target": "// fix_start\n        for (long i = 0; i < this.rcount; i++) {\n// fix_end\n"}
{"vul_id": "VUL4J-7", "cwe": "CWE-835", "cwe_name": "Loop with Unreachable Exit Condition ('Infinite Loop')", "source": "private int readStored(final byte[] buffer, final int offset, final int length) throws IOException {\n    if (current.hasDataDescriptor) {\n        if (lastStoredEntry == null) {\n            readStoredEntry();\n        }\n        return lastStoredEntry.read(buffer, offset, length);\n    }\n    final long csize = current.entry.getSize();\n    if (current.bytesRead >= csize) {\n        return -1;\n    }\n    if (buf.position() >= buf.limit()) {\n        buf.position(0);\n        final int l = in.read(buf.array());\n        if (l == -1) {\n// bug_start\n            return -1;\n// bug_end\n        }\n        buf.limit(l);\n        count(l);\n        current.bytesReadFromStream += l;\n    }\n    int toRead = Math.min(buf.remaining(), length);\n    if ((csize - current.bytesRead) < toRead) {\n        toRead = (int) (csize - current.bytesRead);\n    }\n    buf.get(buffer, offset, toRead);\n    current.bytesRead += toRead;\n    return toRead;\n}\n", "target": "// fix_start\n            buf.limit(0);\n            throw new IOException(\"Truncated ZIP file\");\n// fix_end\n"}
{"vul_id": "VUL4J-8", "cwe": "CWE-835", "cwe_name": "Loop with Unreachable Exit Condition ('Infinite Loop')", "source": "public ByteBuffer encode(final String name) {\n    final CharsetEncoder enc = newEncoder();\n    final CharBuffer cb = CharBuffer.wrap(name);\n    CharBuffer tmp = null;\n    ByteBuffer out = ByteBuffer.allocate(estimateInitialBufferSize(enc, cb.remaining()));\n    while (cb.remaining() > 0) {\n        final CoderResult res = enc.encode(cb, out, false);\n        if (res.isUnmappable() || res.isMalformed()) {\n            int spaceForSurrogate = estimateIncrementalEncodingSize(enc, 6 * res.length());\n            if (spaceForSurrogate > out.remaining()) {\n                int charCount = 0;\n                for (int i = cb.position() ; i < cb.limit(); i++) {\n                    charCount += !enc.canEncode(cb.get(i)) ? 6 : 1;\n                }\n                int totalExtraSpace = estimateIncrementalEncodingSize(enc, charCount);\n                out = ZipEncodingHelper.growBufferBy(out, totalExtraSpace - out.remaining());\n            }\n            if (tmp == null) {\n                tmp = CharBuffer.allocate(6);\n            }\n            for (int i = 0; i < res.length(); ++i) {\n                out = encodeFully(enc, encodeSurrogate(tmp, cb.get()), out);\n            }\n        } else if (res.isOverflow()) {\n            int increment = estimateIncrementalEncodingSize(enc, cb.remaining());\n            out = ZipEncodingHelper.growBufferBy(out, increment);\n// bug_start\n        }\n// bug_end\n    }\n    enc.encode(cb, out, true);\n    out.limit(out.position());\n    out.rewind();\n    return out;\n}\n", "target": "// fix_start\n        } else if (res.isUnderflow() || res.isError()) {\n            break;\n        }\n// fix_end\n"}
{"vul_id": "VUL4J-10", "cwe": "CWE-20", "cwe_name": "Improper Input Validation", "source": "private void readObject(ObjectInputStream in)\n        throws IOException, ClassNotFoundException {\n    in.defaultReadObject();\n// bug_start\n// bug_end\n    OutputStream output = getOutputStream();\n    if (cachedContent != null) {\n        output.write(cachedContent);\n    } else {\n        FileInputStream input = new FileInputStream(dfosFile);\n        IOUtils.copy(input, output);\n        dfosFile.delete();\n        dfosFile = null;\n    }\n    output.close();\n    cachedContent = null;\n}\n", "target": "// fix_start\n    if (repository != null) {\n        if (repository.isDirectory()) {\n            if (repository.getPath().contains(\"\\0\")) {\n                throw new IOException(format(\"The repository [%s] contains a null character\", repository.getPath()));\n            }\n        } else {\n            throw new IOException(format(\"The repository [%s] is not a directory\", repository.getAbsolutePath()));\n        }\n    }\n// fix_end\n"}
{"vul_id": "VUL4J-12", "cwe": "CWE-835", "cwe_name": "Loop with Unreachable Exit Condition ('Infinite Loop')", "source": "private int extend(int v, final int t) {\n    int vt = (1 << (t - 1));\n// bug_start\n    while (v < vt) {\n// bug_end\n        vt = (-1 << t) + 1;\n        v += vt;\n    }\n    return v;\n}\n", "target": "// fix_start\n    if (v < vt) {\n// fix_end\n"}
{"vul_id": "VUL4J-18", "cwe": "CWE-22", "cwe_name": "Path Traversal", "source": "public String getForwardPage( HttpServletRequest request )\n{\n// bug_start\n    return request.getPathInfo();\n// bug_end\n}\n", "target": "// fix_start\n    return \"Wiki.jsp\";\n// fix_end\n"}
{"vul_id": "VUL4J-19", "cwe": "CWE-269", "cwe_name": "Improper Privilege Management", "source": "public void prepareForDecryption(PDEncryption encryption, COSArray documentIDArray, DecryptionMaterial decryptionMaterial) throws IOException\n{\n    if(!(decryptionMaterial instanceof StandardDecryptionMaterial))\n    {\n        throw new IOException(\"Decryption material is not compatible with the document\");\n    }\n    setDecryptMetadata(encryption.isEncryptMetaData());\n    StandardDecryptionMaterial material = (StandardDecryptionMaterial)decryptionMaterial;\n    String password = material.getPassword();\n    if(password == null)\n    {\n        password = \"\";\n    }\n    int dicPermissions = encryption.getPermissions();\n    int dicRevision = encryption.getRevision();\n    int dicLength = encryption.getVersion() == 1 ? 5 : encryption.getLength() / 8;\n    byte[] documentIDBytes = getDocumentIDBytes(documentIDArray);\n    boolean encryptMetadata = encryption.isEncryptMetaData();\n    byte[] userKey = encryption.getUserKey();\n    byte[] ownerKey = encryption.getOwnerKey();\n    byte[] ue = null, oe = null;\n    Charset passwordCharset = Charsets.ISO_8859_1;\n    if (dicRevision == 6 || dicRevision == 5)\n    {\n        passwordCharset = Charsets.UTF_8;\n        ue = encryption.getUserEncryptionKey();\n        oe = encryption.getOwnerEncryptionKey();\n    }\n    AccessPermission currentAccessPermission;\n    if(isOwnerPassword(password.getBytes(passwordCharset), userKey, ownerKey, dicPermissions, documentIDBytes, dicRevision, dicLength, encryptMetadata))\n    {\n        currentAccessPermission = AccessPermission.getOwnerAccessPermission();\n        setCurrentAccessPermission(currentAccessPermission);\n        byte[] computedPassword;\n        if (dicRevision == 6 || dicRevision == 5)\n        {\n            computedPassword = password.getBytes(passwordCharset);\n        }\n        else\n        {\n            computedPassword = getUserPassword(password.getBytes(passwordCharset), ownerKey, dicRevision, dicLength);\n        }\n        encryptionKey = computeEncryptedKey(computedPassword, ownerKey, userKey, oe, ue, dicPermissions, documentIDBytes, dicRevision, dicLength, encryptMetadata, true);\n    }\n    else if(isUserPassword(password.getBytes(passwordCharset), userKey, ownerKey, dicPermissions, documentIDBytes, dicRevision, dicLength, encryptMetadata))\n    {\n        currentAccessPermission = new AccessPermission(dicPermissions);\n// bug_start\n        setCurrentAccessPermission(currentAccessPermission);\n// bug_end\n        encryptionKey = computeEncryptedKey( password.getBytes(passwordCharset), ownerKey, userKey, oe, ue, dicPermissions, documentIDBytes, dicRevision, dicLength, encryptMetadata, false);\n    }\n    else\n    {\n        throw new InvalidPasswordException(\"Cannot decrypt PDF, the password is incorrect\");\n    }\n    if (dicRevision == 6 || dicRevision == 5)\n    {\n        validatePerms(encryption, dicPermissions, encryptMetadata);\n    }\n    if (encryption.getVersion() == 4 || encryption.getVersion() == 5)\n    {\n        PDCryptFilterDictionary stdCryptFilterDictionary = encryption.getStdCryptFilterDictionary();\n        if (stdCryptFilterDictionary != null)\n        {\n            COSName cryptFilterMethod = stdCryptFilterDictionary.getCryptFilterMethod();\n            setAES(COSName.AESV2.equals(cryptFilterMethod) || COSName.AESV3.equals(cryptFilterMethod));\n        }\n    }\n}\n", "target": "// fix_start\n        currentAccessPermission.setReadOnly();\n        setCurrentAccessPermission(currentAccessPermission);\n// fix_end\n"}
{"vul_id": "VUL4J-20", "cwe": "CWE-20", "cwe_name": "Improper Input Validation", "source": "public float[] toFloatArray()\n{\n    float[] retval = new float[size()];\n    for (int i = 0; i < size(); i++)\n    {\n// bug_start\n        retval[i] = ((COSNumber)getObject( i )).floatValue();\n// bug_end\n    }\n    return retval;\n}\n", "target": "// fix_start\n        COSBase base = getObject(i);\n        retval[i] = base instanceof COSNumber ? ((COSNumber) base).floatValue() : 0;\n// fix_end\n"}
{"vul_id": "VUL4J-22", "cwe": "CWE-284", "cwe_name": "Improper Access Control", "source": "public static String getContextPath(HttpServletRequest request) {\n    String contextPath = (String) request.getAttribute(INCLUDE_CONTEXT_PATH_ATTRIBUTE);\n    if (contextPath == null) {\n        contextPath = request.getContextPath();\n    }\n// bug_start\n    if (\"/\".equals(contextPath)) {\n        contextPath = \"\";\n    }\n    return decodeRequestString(request, contextPath);\n// bug_end\n}\n", "target": "// fix_start\n    contextPath = normalize(decodeRequestString(request, contextPath));\n    if (\"/\".equals(contextPath)) {\n        contextPath = \"\";\n    }\n    return contextPath;\n// fix_end\n"}
{"vul_id": "VUL4J-23", "cwe": "CWE-79", "cwe_name": "Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')", "source": "public String encodeForJSString(String source) {\n// bug_start\n    return source == null ? null : Encode.forJavaScriptSource(source);\n// bug_end\n}\n", "target": "// fix_start\n    return source == null ? null : Encode.forJavaScript(source).replace(\"\\\\-\", \"\\\\u002D\");\n// fix_end\n"}
{"vul_id": "VUL4J-24", "cwe": "CWE-611", "cwe_name": "Improper Restriction of XML External Entity Reference ('XXE')", "source": "protected void activate() {\n    factory = SAXParserFactory.newInstance();\n    factory.setValidating(false);\n// bug_start\n    factory.setNamespaceAware(true);\n// bug_end\n}\n", "target": "// fix_start\n    factory.setNamespaceAware(true);\n    try {\n        factory.setFeature(\"http://apache.org/xml/features/nonvalidating/load-external-dtd\", false);\n        factory.setFeature(\"http://xml.org/sax/features/external-parameter-entities\", false);\n        factory.setFeature(\"http://xml.org/sax/features/external-general-entities\", false);\n    } catch (Exception e) {\n        LOGGER.error(\"SAX parser configuration error: \" + e.getMessage(), e);\n    }\n// fix_end\n"}
{"vul_id": "VUL4J-25", "cwe": "CWE-79", "cwe_name": "Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')", "source": "public String getValidHref(final String url) {\n    if (StringUtils.isNotEmpty(url)) {\n// bug_start\n        try {\n            String unescapedURL = URLDecoder.decode(url, StandardCharsets.UTF_8.name());\n            unescapedURL = StringEscapeUtils.unescapeXml(unescapedURL);\n            String encodedUrl = unescapedURL.replaceAll(\"\\\"\", \"%22\").replaceAll(\"'\", \"%27\").replaceAll(\">\", \"%3E\").replaceAll(\"<\", \"%3C\").replaceAll(\"`\", \"%60\").replaceAll(\" \", \"%20\");\n            int qMarkIx = encodedUrl.indexOf('?');\n            if (qMarkIx > 0) {\n                encodedUrl = encodedUrl.substring(0, qMarkIx) + encodedUrl.substring(qMarkIx).replaceAll(\":\", \"%3A\");\n            }\n            encodedUrl = mangleNamespaces(encodedUrl);\n            if (xssFilter.isValidHref(encodedUrl)) {\n                return encodedUrl;\n            }\n        } catch (UnsupportedEncodingException e) {\n            LOGGER.error(\"Unable to decode url: {}.\", url);\n// bug_end\n        }\n    }\n    return \"\";\n}\n", "target": "// fix_start\n        String unescapedURL = URLDecoder.decode(url, StandardCharsets.UTF_8.name());\n        unescapedURL = StringEscapeUtils.unescapeXml(unescapedURL);\n        String encodedUrl = unescapedURL.replaceAll(\"\\\"\", \"%22\").replaceAll(\"'\", \"%27\").replaceAll(\">\", \"%3E\").replaceAll(\"<\", \"%3C\").replaceAll(\"`\", \"%60\").replaceAll(\" \", \"%20\");\n        int qMarkIx = encodedUrl.indexOf('?');\n        if (qMarkIx > 0) {\n            encodedUrl = encodedUrl.substring(0, qMarkIx) + encodedUrl.substring(qMarkIx).replaceAll(\":\", \"%3A\");\n        }\n        encodedUrl = mangleNamespaces(encodedUrl);\n        if (xssFilter.isValidHref(encodedUrl)) {\n            return encodedUrl;\n// fix_end\n"}
{"vul_id": "VUL4J-26", "cwe": "CWE-20", "cwe_name": "Improper Input Validation", "source": "public String getUrlRegex() {\n    if (StringUtils.isNotEmpty(urlRegexExpression)) {\n        return (String) parse(urlRegexExpression, String.class);\n    } else if (StringUtils.isNotEmpty(urlRegex)) {\n        return urlRegex;\n    } else {\n        return \"^(https?|ftp):\\\\/\\\\/\" +\n                \"(([a-z0-9$_\\\\.\\\\+!\\\\*\\\\'\\\\(\\\\),;\\\\?&=-]|%[0-9a-f]{2})+\" +\n                \"(:([a-z0-9$_\\\\.\\\\+!\\\\*\\\\'\\\\(\\\\),;\\\\?&=-]|%[0-9a-f]{2})+)?\" +\n                \"@)?(#?\" +\n                \")((([a-z0-9]\\\\.|[a-z0-9][a-z0-9-]*[a-z0-9]\\\\.)*\" +\n                \"[a-z][a-z0-9-]*[a-z0-9]\" +\n                \"|((\\\\d|[1-9]\\\\d|1\\\\d{2}|2[0-4][0-9]|25[0-5])\\\\.){3}\" +\n                \"(\\\\d|[1-9]\\\\d|1\\\\d{2}|2[0-4][0-9]|25[0-5])\" +\n                \")(:\\\\d+)?\" +\n// bug_start\n                \")(((\\\\/+([a-z0-9$_\\\\.\\\\+!\\\\*\\\\'\\\\(\\\\),;:@&=-]|%[0-9a-f]{2})*)*\" +\n// bug_end\n                \"(\\\\?([a-z0-9$_\\\\.\\\\+!\\\\*\\\\'\\\\(\\\\),;:@&=-]|%[0-9a-f]{2})*)\" +\n                \"?)?)?\" +\n                \"(#([a-z0-9$_\\\\.\\\\+!\\\\*\\\\'\\\\(\\\\),;:@&=-]|%[0-9a-f]{2})*)?\" +\n                \"$\";\n    }\n}\n", "target": "// fix_start\n                \")(((\\\\/{0,1}([a-z0-9$_\\\\.\\\\+!\\\\*\\\\'\\\\(\\\\),;:@&=-]|%[0-9a-f]{2})*)*\" +\n// fix_end\n"}
{"vul_id": "VUL4J-30", "cwe": "CWE-20", "cwe_name": "Improper Input Validation", "source": "public void validate(Object object) throws ValidationException {\n    String fieldName = getFieldName();\n    Object value = this.getFieldValue(fieldName, object);\n    if (value == null || value.toString().length() == 0) {\n        return;\n    }\n// bug_start\n    if (!(value.getClass().equals(String.class)) || !Pattern.compile(getUrlRegex(), Pattern.CASE_INSENSITIVE).matcher(String.valueOf(value)).matches()) {\n// bug_end\n        addFieldError(fieldName, object);\n    }\n}\n", "target": "// fix_start\n    if (!(value.getClass().equals(String.class)) || !Pattern.compile(getUrlRegex(), Pattern.CASE_INSENSITIVE).matcher(String.valueOf(value).trim()).matches()) {\n// fix_end\n"}
{"vul_id": "VUL4J-33", "cwe": "CWE-77", "cwe_name": "Improper Neutralization of Special Elements used in a Command ('Command Injection')", "source": "private boolean isEvalExpression(Object tree, Map<String, Object> context) throws OgnlException {\n    if (tree instanceof SimpleNode) {\n        SimpleNode node = (SimpleNode) tree;\n        OgnlContext ognlContext = null;\n        if (context!=null && context instanceof OgnlContext) {\n            ognlContext = (OgnlContext) context;\n        }\n// bug_start\n        return node.isEvalChain(ognlContext);\n// bug_end\n    }\n    return false;\n}\n", "target": "// fix_start\n        return node.isEvalChain(ognlContext) || node.isSequence(ognlContext);\n// fix_end\n"}
{"vul_id": "VUL4J-39", "cwe": "CWE-200", "cwe_name": "Information Exposure", "source": "public String toString() {\n    StringBuilder sb = new StringBuilder();\n    if (origin != null) {\n        sb.append(\"remoteAddress=\").append(origin);\n    }\n    if (clientId != null) {\n        if (sb.length() > 0) {\n            sb.append(\", \");\n        }\n        sb.append(\"clientId=\").append(clientId);\n    }\n// bug_start\n    if (sessionId != null) {\n        if (sb.length() > 0) {\n            sb.append(\", \");\n        }\n        sb.append(\"sessionId=\").append(sessionId);\n    }\n// bug_end\n    return sb.toString();\n}", "target": "// fix_start\n// fix_end\n"}
{"vul_id": "VUL4J-40", "cwe": "CWE-287", "cwe_name": "Improper Authentication", "source": "public boolean isAllowed(HttpServletRequest request) throws IOException {\n    String requestBody = IOUtils.toString(request.getReader());\n    ScimUser scimUserFromRequest = JsonUtils.readValue(requestBody, ScimUser.class);\n    String id = UaaUrlUtils.extractPathVariableFromUrl(USER_ID_PATH_PARAMETER_INDEX, UaaUrlUtils.getRequestPath(request));\n    String zoneId = IdentityZoneHolder.get().getId();\n    ScimUser scimUserFromDb;\n    try {\n        scimUserFromDb = scimUserProvisioning.retrieve(id, zoneId);\n    } catch (ScimResourceNotFoundException e) {\n        return true;\n    }\n    if (!scimUserFromDb.getPrimaryEmail().equals(scimUserFromRequest.getPrimaryEmail())) {\n        return false;\n    }\n// bug_start\n    if (!scimUserFromDb.getUserName().equals(scimUserFromRequest.getUserName())) {\n// bug_end\n        return false;\n    }\n    if (scimUserFromDb.isVerified() != scimUserFromRequest.isVerified()) {\n        return false;\n    }\n    if (scimUserFromDb.isActive() != (scimUserFromRequest.isActive())) {\n        return false;\n    }\n    if (!scimUserFromDb.getOrigin().equals(scimUserFromRequest.getOrigin())) {\n        return false;\n    }\n    return true;\n}\n", "target": "// fix_start\n    if (!scimUserFromDb.getEmails().containsAll(scimUserFromRequest.getEmails())) {\n        return false;\n    }\n    if (!scimUserFromDb.getUserName().equals(scimUserFromRequest.getUserName())) {\n// fix_end\n"}
{"vul_id": "VUL4J-41", "cwe": "CWE-22", "cwe_name": "Path Traversal", "source": "protected void extractFile(final File srcF, final File dir, final InputStream compressedInputStream, final String entryName, final Date entryDate, final boolean isDirectory, final Integer mode, String symlinkDestination)\n    throws IOException, ArchiverException\n{\n// bug_start\n    final File f = FileUtils.resolveFile(dir, entryName);\n// bug_end\n    try\n    {\n        if (!isOverwrite() && f.exists() && (f.lastModified() >= entryDate.getTime()))\n        {\n            return;\n        }\n        final File dirF = f.getParentFile();\n        if (dirF != null)\n        {\n            dirF.mkdirs();\n        }\n        if (!StringUtils.isEmpty(symlinkDestination))\n        {\n            SymlinkUtils.createSymbolicLink(f, new File(symlinkDestination));\n        }\n        else if (isDirectory)\n        {\n            f.mkdirs();\n        }\n        else\n        {\n            OutputStream out = null;\n            try\n            {\n                out = new FileOutputStream(f);\n                IOUtil.copy(compressedInputStream, out);\n                out.close();\n                out = null;\n            }\n            finally\n            {\n                IOUtil.close(out);\n            }\n        }\n        f.setLastModified(entryDate.getTime());\n        if (!isIgnorePermissions() && mode != null && !isDirectory)\n        {\n            ArchiveEntryUtils.chmod(f, mode);\n        }\n    }\n    catch (final FileNotFoundException ex)\n    {\n        getLogger().warn(\"Unable to expand to file \" + f.getPath());\n    }\n}\n", "target": "// fix_start\n    final File f = FileUtils.resolveFile(dir, entryName);\n    String canonicalDirPath = dir.getCanonicalPath();\n    String canonicalDestPath = f.getCanonicalPath();\n    if (!canonicalDestPath.startsWith(canonicalDirPath))\n    {\n        throw new ArchiverException(\"Entry is outside of the target directory(\" + entryName + \")\");\n    }\n// fix_end\n"}
{"vul_id": "VUL4J-43", "cwe": "CWE-22", "cwe_name": "Path Traversal", "source": "public static void writeEntry(ZipFile zipFile, ZipEntry entry, File destDir)\n    throws IOException\n{\n// bug_start\n    File outFile = new File(destDir, entry.getName());\n// bug_end\n    if (entry.isDirectory()) {\n        outFile.mkdirs();\n    }\n    else {\n        outFile.getParentFile().mkdirs();\n        try (InputStream in = zipFile.getInputStream(entry)) {\n            IOUtil.writeStream(in, outFile);\n        }\n    }\n}\n", "target": "// fix_start\n    File outFile = new File(destDir, entry.getName());\n    if (! outFile.getCanonicalFile().toPath().startsWith(destDir.toPath())) {\n        throw new IOException(\"Zip entry outside destination directory: \" + entry.getName());\n    }\n// fix_end\n"}
{"vul_id": "VUL4J-44", "cwe": "CWE-310", "cwe_name": "Cryptographic Issues", "source": "public String encodeCharacter(char[] immune, Character c)\n{\n    String cStr = String.valueOf(c.charValue());\n    byte[] bytes;\n    StringBuilder sb;\n// bug_start\n    if(UNENCODED_SET.contains(c))\n// bug_end\n        return cStr;\n    bytes = toUtf8Bytes(cStr);\n    sb = new StringBuilder(bytes.length * 3);\n    for(byte b : bytes)\n        appendTwoUpperHex(sb.append('%'), b);\n    return sb.toString();\n}\n", "target": "// fix_start\n    if (immune != null && containsCharacter(c.charValue(), immune))\n        return cStr;\n    if(UNENCODED_SET.contains(c))\n// fix_end\n"}
{"vul_id": "VUL4J-46", "cwe": "CWE-611", "cwe_name": "Improper Restriction of XML External Entity Reference ('XXE')", "source": "protected XmlFactory(ObjectCodec oc, int xpFeatures, int xgFeatures,\n        XMLInputFactory xmlIn, XMLOutputFactory xmlOut,\n        String nameForTextElem)\n{\n    super(oc);\n    _xmlParserFeatures = xpFeatures;\n    _xmlGeneratorFeatures = xgFeatures;\n    _cfgNameForTextElement = nameForTextElem;\n    if (xmlIn == null) {\n// bug_start\n        xmlIn = XMLInputFactory.newInstance();\n// bug_end\n    }\n    if (xmlOut == null) {\n        xmlOut = XMLOutputFactory.newInstance();\n    }\n    _initFactories(xmlIn, xmlOut);\n    _xmlInputFactory = xmlIn;\n    _xmlOutputFactory = xmlOut;\n// bug_start\n}\n// bug_end\n", "target": "// fix_start\n        xmlIn = XMLInputFactory.newInstance();\n        xmlIn.setProperty(XMLInputFactory.IS_SUPPORTING_EXTERNAL_ENTITIES, Boolean.FALSE);\n// fix_end\n"}
{"vul_id": "VUL4J-47", "cwe": "CWE-611", "cwe_name": "Improper Restriction of XML External Entity Reference ('XXE')", "source": "protected XmlFactory(ObjectCodec oc, int xpFeatures, int xgFeatures,\n        XMLInputFactory xmlIn, XMLOutputFactory xmlOut,\n        String nameForTextElem)\n{\n    super(oc);\n    _xmlParserFeatures = xpFeatures;\n    _xmlGeneratorFeatures = xgFeatures;\n    _cfgNameForTextElement = nameForTextElem;\n    if (xmlIn == null) {\n        xmlIn = XMLInputFactory.newInstance();\n// bug_start\n        xmlIn.setProperty(XMLInputFactory.IS_SUPPORTING_EXTERNAL_ENTITIES, Boolean.FALSE);\n// bug_end\n    }\n    if (xmlOut == null) {\n        xmlOut = XMLOutputFactory.newInstance();\n    }\n    _initFactories(xmlIn, xmlOut);\n    _xmlInputFactory = xmlIn;\n    _xmlOutputFactory = xmlOut;\n}\n", "target": "// fix_start\n        xmlIn.setProperty(XMLInputFactory.IS_SUPPORTING_EXTERNAL_ENTITIES, Boolean.FALSE);\n        xmlIn.setProperty(XMLInputFactory.SUPPORT_DTD, Boolean.FALSE);\n// fix_end\n"}
{"vul_id": "VUL4J-50", "cwe": "CWE-79", "cwe_name": "Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')", "source": "private void writeSession(SessionInformations session, boolean displayUser) throws IOException {\n    final String nextColumnAlignRight = \"</td><td align='right'>\";\n    final String nextColumnAlignCenter = \"</td><td align='center'>\";\n    write(\"<td><a href='?part=sessions&amp;sessionId=\");\n    write(htmlEncodeButNotSpace(session.getId()));\n    write(\"'>\");\n    write(htmlEncodeButNotSpace(session.getId()));\n    write(\"</a>\");\n    write(nextColumnAlignRight);\n    write(durationFormat.format(session.getLastAccess()));\n    write(nextColumnAlignRight);\n    write(durationFormat.format(session.getAge()));\n    write(nextColumnAlignRight);\n    write(expiryFormat.format(session.getExpirationDate()));\n    write(nextColumnAlignRight);\n    write(integerFormat.format(session.getAttributeCount()));\n    write(nextColumnAlignCenter);\n    if (session.isSerializable()) {\n        write(\"#oui#\");\n    } else {\n        write(\"<span class='severe'>#non#</span>\");\n    }\n    write(nextColumnAlignRight);\n    write(integerFormat.format(session.getSerializedSize()));\n    final String nextColumn = \"</td><td>\";\n    write(nextColumn);\n    final String remoteAddr = session.getRemoteAddr();\n    if (remoteAddr == null) {\n        write(\"&nbsp;\");\n    } else {\n// bug_start\n        write(remoteAddr);\n// bug_end\n    }\n    write(nextColumnAlignCenter);\n    writeCountry(session);\n    if (displayUser) {\n        write(nextColumn);\n        final String remoteUser = session.getRemoteUser();\n        if (remoteUser == null) {\n            write(\"&nbsp;\");\n        } else {\n            writeDirectly(htmlEncodeButNotSpace(remoteUser));\n        }\n    }\n    write(\"</td><td align='center' class='noPrint'>\");\n    write(A_HREF_PART_SESSIONS);\n    write(\"&amp;action=invalidate_session&amp;sessionId=\");\n    write(urlEncode(session.getId()));\n    write(\"' onclick=\\\"javascript:return confirm('\" + getStringForJavascript(\"confirm_invalidate_session\") + \"');\\\">\");\n    write(\"<img width='16' height='16' src='?resource=user-trash.png' alt='#invalidate_session#' title='#invalidate_session#' />\");\n    write(\"</a>\");\n    write(\"</td>\");\n}\n", "target": "// fix_start\n        writeDirectly(htmlEncodeButNotSpace(remoteAddr));\n// fix_end\n"}
{"vul_id": "VUL4J-53", "cwe": "CWE-835", "cwe_name": "Loop with Unreachable Exit Condition ('Infinite Loop')", "source": "void setTo(Calendar c, int i) {\n// bug_start\n    c.set(field,i-offset);\n// bug_end\n}\n", "target": "// fix_start\n    c.set(field,Math.min(i-offset, c.getActualMaximum(field)));\n// fix_end\n"}
{"vul_id": "VUL4J-54", "cwe": "CWE-502", "cwe_name": "Deserialization of Untrusted Data", "source": "private void init() {\n    addImmutableType(Result.class);\n// bug_start\n// bug_end\n    registerConverter(new RobustCollectionConverter(getMapper(),getReflectionProvider()),10);\n    registerConverter(new RobustMapConverter(getMapper()), 10);\n    registerConverter(new ImmutableMapConverter(getMapper(),getReflectionProvider()),10);\n    registerConverter(new ImmutableSortedSetConverter(getMapper(),getReflectionProvider()),10);\n    registerConverter(new ImmutableSetConverter(getMapper(),getReflectionProvider()),10);\n    registerConverter(new ImmutableListConverter(getMapper(),getReflectionProvider()),10);\n    registerConverter(new ConcurrentHashMapConverter(getMapper(),getReflectionProvider()),10);\n    registerConverter(new CopyOnWriteMap.Tree.ConverterImpl(getMapper()),10);\n    registerConverter(new DescribableList.ConverterImpl(getMapper()),10);\n    registerConverter(new Label.ConverterImpl(),10);\n    registerConverter(new AssociatedConverterImpl(this), -10);\n    registerConverter(new BlacklistedTypesConverter(), PRIORITY_VERY_HIGH);\n    registerConverter(new DynamicProxyConverter(getMapper()) {\n        @Override public boolean canConvert(Class type) {\n            return type != null && super.canConvert(type);\n        }\n        @Override public Object unmarshal(HierarchicalStreamReader reader, UnmarshallingContext context) {\n            throw new ConversionException(\"<dynamic-proxy> not supported\");\n        }\n    }, PRIORITY_VERY_HIGH);\n}\n", "target": "// fix_start\n    denyTypes(new Class[] { void.class, Void.class });\n// fix_end\n"}
{"vul_id": "VUL4J-55", "cwe": "CWE-835", "cwe_name": "Loop with Unreachable Exit Condition ('Infinite Loop')", "source": "public Calendar ceil(Calendar cal) {\n    Calendar twoYearsFuture = (Calendar) cal.clone();\n    twoYearsFuture.add(Calendar.YEAR, 2);\n    OUTER:\n    while (true) {\n        if (cal.compareTo(twoYearsFuture) > 0) {\n            throw new RareOrImpossibleDateException();\n        }\n        for (CalendarField f : CalendarField.ADJUST_ORDER) {\n            int cur = f.valueOf(cal);\n            int next = f.ceil(this,cur);\n            if (cur==next)  continue;\n            for (CalendarField l=f.lowerField; l!=null; l=l.lowerField)\n                l.clear(cal);\n            if (next<0) {\n                f.rollUp(cal, 1);\n                f.setTo(cal,f.first(this));\n                continue OUTER;\n            } else {\n                f.setTo(cal,next);\n// bug_start\n// bug_end\n                if (f.redoAdjustmentIfModified)\n                    continue OUTER;\n            }\n        }\n        return cal;\n    }\n}\n", "target": "// fix_start\n                if (f.valueOf(cal) != next) {\n                    f.rollUp(cal, 1);\n                    f.setTo(cal,f.first(this));\n                    continue OUTER;\n                }\n// fix_end\n"}
{"vul_id": "VUL4J-57", "cwe": "CWE-532", "cwe_name": "Information Exposure Through Log Files", "source": "public boolean start() throws Exception {\n    String job = step.getJob();\n    Item item = Jenkins.getActiveInstance().getItem(job, invokingRun.getParent(), Item.class);\n    if (item == null) {\n        throw new AbortException(\"No item named \" + job + \" found\");\n    }\n// bug_start\n    if (step.getWait() && !(item instanceof Job)) {\n// bug_end\n        throw new AbortException(\"Waiting for non-job items is not supported\");\n    }\n    if (item instanceof ParameterizedJobMixIn.ParameterizedJob) {\n        final ParameterizedJobMixIn.ParameterizedJob project = (ParameterizedJobMixIn.ParameterizedJob) item;\n        listener.getLogger().println(\"Scheduling project: \" + ModelHyperlinkNote.encodeTo(project));\n        node.addAction(new LabelAction(Messages.BuildTriggerStepExecution_building_(project.getFullDisplayName())));\n        List<Action> actions = new ArrayList<>();\n        if (step.getWait()) {\n            StepContext context = getContext();\n            actions.add(new BuildTriggerAction(context, step.isPropagate()));\n            LOGGER.log(Level.FINER, \"scheduling a build of {0} from {1}\", new Object[]{project, context});\n        }\n        actions.add(new CauseAction(new Cause.UpstreamCause(invokingRun)));\n        List<ParameterValue> parameters = step.getParameters();\n        if (parameters != null) {\n            parameters = completeDefaultParameters(parameters, (Job) project);\n            actions.add(new ParametersAction(parameters));\n        }\n        Integer quietPeriod = step.getQuietPeriod();\n        if (quietPeriod == null) {\n            quietPeriod = project.getQuietPeriod();\n        }\n        QueueTaskFuture<?> f = new ParameterizedJobMixIn() {\n            @Override\n            protected Job asJob() {\n                return (Job) project;\n            }\n        }.scheduleBuild2(quietPeriod, actions.toArray(new Action[actions.size()]));\n        if (f == null) {\n            throw new AbortException(\"Failed to trigger build of \" + project.getFullName());\n        }\n    } else if (item instanceof Queue.Task){\n        if (step.getParameters() != null && !step.getParameters().isEmpty()) {\n            throw new AbortException(\"Item type does not support parameters\");\n        }\n        Queue.Task task = (Queue.Task) item;\n        listener.getLogger().println(\"Scheduling item: \" + ModelHyperlinkNote.encodeTo(item));\n        node.addAction(new LabelAction(Messages.BuildTriggerStepExecution_building_(task.getFullDisplayName())));\n        List<Action> actions = new ArrayList<>();\n        if (step.getWait()) {\n            StepContext context = getContext();\n            actions.add(new BuildTriggerAction(context, step.isPropagate()));\n            LOGGER.log(Level.FINER, \"scheduling a build of {0} from {1}\", new Object[]{task, context});\n        }\n        actions.add(new CauseAction(new Cause.UpstreamCause(invokingRun)));\n        Integer quietPeriod = step.getQuietPeriod();\n        if (quietPeriod == null) {\n            try {\n                Method getQuietPeriod = task.getClass().getMethod(\"getQuietPeriod\");\n                if (getQuietPeriod.getReturnType().equals(int.class)) {\n                    quietPeriod = (Integer) getQuietPeriod.invoke(task);\n                }\n            } catch (NoSuchMethodException e) {\n            } catch (IllegalAccessError | IllegalArgumentException | InvocationTargetException e) {\n                LOGGER.log(Level.WARNING, e);\n            }\n        }\n        if (quietPeriod == null) {\n            quietPeriod = Jenkins.getActiveInstance().getQuietPeriod();\n        }\n        ScheduleResult scheduleResult = Jenkins.getActiveInstance().getQueue().schedule2(task, quietPeriod,actions);\n        if (scheduleResult.isRefused()) {\n            throw new AbortException(\"Failed to trigger build of \" + item.getFullName());\n        }\n    } else {\n        throw new AbortException(\"The item named \" + job + \" is a \" + (item instanceof Describable ? ((Describable) item).getDescriptor().getDisplayName() : item.getClass().getName()) );\n    }\n    if (step.getWait()) {\n        return false;\n    } else {\n        getContext().onSuccess(null);\n        return true;\n    }\n}\n", "target": "// fix_start\n    item.checkPermission(Item.BUILD);\n    if (step.getWait() && !(item instanceof Job)) {\n// fix_end\n"}
{"vul_id": "VUL4J-59", "cwe": "CWE-79", "cwe_name": "Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')", "source": "BeforeAttributeValue {\n    void read(Tokeniser t, CharacterReader r) {\n        char c = r.consume();\n        switch (c) {\n            case '\\t':\n            case '\\n':\n            case '\\r':\n            case '\\f':\n            case ' ':\n                // ignore\n                break;\n            case '\"':\n                t.transition(AttributeValue_doubleQuoted);\n                break;\n            case '&':\n                r.unconsume();\n                t.transition(AttributeValue_unquoted);\n                break;\n            case '\\'':\n                t.transition(AttributeValue_singleQuoted);\n                break;\n            case nullChar:\n                t.error(this);\n                t.tagPending.appendAttributeValue(replacementChar);\n                t.transition(AttributeValue_unquoted);\n                break;\n            case eof:\n                t.eofError(this);\n// bug_start\n                t.transition(Data);\n// bug_end\n                break;\n            case '>':\n                t.error(this);\n                t.emitTagPending();\n                t.transition(Data);\n                break;\n            case '<':\n            case '=':\n            case '`':\n                t.error(this);\n                t.tagPending.appendAttributeValue(c);\n                t.transition(AttributeValue_unquoted);\n                break;\n            default:\n                r.unconsume();\n                t.transition(AttributeValue_unquoted);\n        }\n    }\n}\n", "target": "// fix_start\n                t.emitTagPending();\n                t.transition(Data);\n// fix_end\n"}
{"vul_id": "VUL4J-61", "cwe": "CWE-611", "cwe_name": "Improper Restriction of XML External Entity Reference ('XXE')", "source": "private Stream<MapResult> xmlXpathToMapResult(@Name(\"url\") String url, boolean simpleMode, String path, Map<String, Object> config) throws Exception {\n    if (config == null) config = Collections.emptyMap();\n    boolean failOnError = (boolean) config.getOrDefault(\"failOnError\", true);\n    List<MapResult> result = new ArrayList<>();\n    try {\n        DocumentBuilderFactory documentBuilderFactory = DocumentBuilderFactory.newInstance();\n        documentBuilderFactory.setNamespaceAware(true);\n        documentBuilderFactory.setIgnoringElementContentWhitespace(true);\n// bug_start\n        DocumentBuilder documentBuilder = documentBuilderFactory.newDocumentBuilder();\n// bug_end\n        FileUtils.checkReadAllowed(url);\n        Map<String, Object> headers = (Map) config.getOrDefault( \"headers\", Collections.emptyMap() );\n        Document doc = documentBuilder.parse(Util.openInputStream(url, headers, null));\n        XPathFactory xPathFactory = XPathFactory.newInstance();\n        XPath xPath = xPathFactory.newXPath();\n        path = StringUtils.isEmpty(path) ? \"/\" : path;\n        XPathExpression xPathExpression = xPath.compile(path);\n        NodeList nodeList = (NodeList) xPathExpression.evaluate(doc, XPathConstants.NODESET);\n        for (int i = 0; i < nodeList.getLength(); i++) {\n            final Deque<Map<String, Object>> stack = new LinkedList<>();\n            handleNode(stack, nodeList.item(i), simpleMode);\n            for (int index = 0; index < stack.size(); index++) {\n                result.add(new MapResult(stack.pollFirst()));\n            }\n        }\n    }\n    catch (FileNotFoundException e){\n        if(!failOnError)\n            return Stream.of(new MapResult(Collections.emptyMap()));\n        else\n            throw new FileNotFoundException(e.getMessage());\n    }\n    catch (Exception e){\n        if(!failOnError)\n            return Stream.of(new MapResult(Collections.emptyMap()));\n        else\n            throw new Exception(e);\n    }\n    return result.stream();\n}\n", "target": "// fix_start\n        documentBuilderFactory.setFeature(\"http://apache.org/xml/features/disallow-doctype-decl\", true);\n        DocumentBuilder documentBuilder = documentBuilderFactory.newDocumentBuilder();\n// fix_end\n"}
{"vul_id": "VUL4J-62", "cwe": "CWE-287", "cwe_name": "Improper Authentication", "source": "private LdapContext getLdapContextUsingStartTls(LdapContextFactory ldapContextFactory, Object principal, Object credentials) throws NamingException\n{\n    JndiLdapContextFactory jndiLdapContextFactory = (JndiLdapContextFactory) ldapContextFactory;\n    Hashtable<String, Object> env = new Hashtable<>();\n    env.put(Context.INITIAL_CONTEXT_FACTORY, jndiLdapContextFactory.getContextFactoryClassName());\n    env.put(Context.PROVIDER_URL, jndiLdapContextFactory.getUrl());\n    LdapContext ctx = null;\n    try\n    {\n        ctx = new InitialLdapContext(env, null);\n        StartTlsRequest startTlsRequest = new StartTlsRequest();\n        StartTlsResponse tls = (StartTlsResponse) ctx.extendedOperation(startTlsRequest);\n        tls.negotiate();\n        ctx.addToEnvironment(Context.SECURITY_AUTHENTICATION, jndiLdapContextFactory.getAuthenticationMechanism());\n        ctx.addToEnvironment(Context.SECURITY_PRINCIPAL, principal);\n        ctx.addToEnvironment(Context.SECURITY_CREDENTIALS, credentials);\n// bug_start\n        return ctx;\n// bug_end\n    }\n    catch (IOException e)\n    {\n        LdapUtils.closeContext(ctx);\n        securityLog.error(withRealm(\"Failed to negotiate TLS connection with '%s': \", server(jndiLdapContextFactory), e));\n        throw new CommunicationException(e.getMessage());\n    }\n    catch (Throwable t)\n    {\n        LdapUtils.closeContext(ctx);\n        securityLog.error(withRealm(\"Unexpected failure to negotiate TLS connection with '%s': \", server(jndiLdapContextFactory), t));\n        throw t;\n    }\n}\n", "target": "// fix_start\n        ctx.lookup(principal.toString());\n        return ctx;\n// fix_end\n"}
{"vul_id": "VUL4J-64", "cwe": "CWE-611", "cwe_name": "Improper Restriction of XML External Entity Reference ('XXE')", "source": "final static private XMLStreamReader createXMLStreamReader(InputStream inputStream) throws XMLStreamException, IOException {\n    XMLInputFactory factory = XMLInputFactory.newInstance();\n    factory.setProperty(XMLInputFactory.IS_COALESCING, true);\n    factory.setProperty(XMLInputFactory.IS_REPLACING_ENTITY_REFERENCES, true);\n// bug_start\n    return factory.createXMLStreamReader(wrapPrefixRemovingInputStream(inputStream));\n// bug_end\n}\n", "target": "// fix_start\n    factory.setProperty(XMLInputFactory.SUPPORT_DTD, false);\n    return factory.createXMLStreamReader(wrapPrefixRemovingInputStream(inputStream));\n// fix_end\n"}
{"vul_id": "VUL4J-65", "cwe": "CWE-22", "cwe_name": "Path Traversal", "source": "static public File allocateFile(File dir, String name) {\n    int q = name.indexOf('?');\n    if (q > 0) {\n        name = name.substring(0, q);\n    }\n// bug_start\n    File file = new File(dir, name);\n// bug_end\n    int dot = name.indexOf('.');\n    String prefix = dot < 0 ? name : name.substring(0, dot);\n    String suffix = dot < 0 ? \"\" : name.substring(dot);\n    int index = 2;\n    while (file.exists()) {\n        file = new File(dir, prefix + \"-\" + index++ + suffix);\n    }\n    file.getParentFile().mkdirs();\n    return file;\n}\n", "target": "// fix_start\n    File file = new File(dir, name);\n    if (!file.toPath().normalize().startsWith(dir.toPath().normalize())) {\n        throw new IllegalArgumentException(\"Zip archives with files escaping their root directory are not allowed.\");\n    }\n// fix_end\n"}
{"vul_id": "VUL4J-66", "cwe": "CWE-20", "cwe_name": "Improper Input Validation", "source": "protected static boolean isValid(String str)\n{\n    if (str == null || str.length() == 0) return false;\n    for (int i = 0; i < str.length(); i++) {\n        switch (str.charAt(i))\n        {\n        case '/':\n        case '\\\\':\n        case '?':\n        case ':':\n        case '<':\n        case '>':\n        case ';':\n        case '(':\n        case ')':\n        case '@':\n        case ',':\n        case '[':\n        case ']':\n        case '=':\n// bug_start\n// bug_end\n            return false;\n        default:\n            break;\n        }\n    }\n    return true;\n}\n", "target": "// fix_start\n        case '\\n':\n// fix_end\n"}
{"vul_id": "VUL4J-67", "cwe": "CWE-770", "cwe_name": "Allocation of Resources Without Limits or Throttling", "source": "private static PropertyPath create(String source, TypeInformation<?> type, String addTail, List<PropertyPath> base) {\n    PropertyReferenceException exception = null;\n    PropertyPath current = null;\n    try {\n// bug_start\n        current = new PropertyPath(source, type, base);\n// bug_end\n        if (!base.isEmpty()) {\n            base.get(base.size() - 1).next = current;\n        }\n        List<PropertyPath> newBase = new ArrayList<PropertyPath>(base);\n        newBase.add(current);\n        if (StringUtils.hasText(addTail)) {\n            current.next = create(addTail, current.type, newBase);\n        }\n        return current;\n    } catch (PropertyReferenceException e) {\n        if (current != null) {\n            throw e;\n        }\n        exception = e;\n    }\n    Pattern pattern = Pattern.compile(\"\\\\p{Lu}+\\\\p{Ll}*$\");\n    Matcher matcher = pattern.matcher(source);\n    if (matcher.find() && matcher.start() != 0) {\n        int position = matcher.start();\n        String head = source.substring(0, position);\n        String tail = source.substring(position);\n        try {\n            return create(head, type, tail + addTail, base);\n        } catch (PropertyReferenceException e) {\n            throw e.hasDeeperResolutionDepthThan(exception) ? e : exception;\n        }\n    }\n    throw exception;\n}\n", "target": "// fix_start\n        if (base.size() > 1000) {\n            throw new IllegalArgumentException(PARSE_DEPTH_EXCEEDED);\n        }\n        current = new PropertyPath(source, type, base);\n// fix_end\n"}
{"vul_id": "VUL4J-68", "cwe": "CWE-20", "cwe_name": "Improper Input Validation", "source": "protected <T> Object evaluateValueFromTarget(Object targetObject, Class<T> entityType) {\n    if (!path.endsWith(\"-\")) {\n        return super.evaluateValueFromTarget(targetObject, entityType);\n    }\n// bug_start\n    String pathSource = Arrays.stream(path.split(\"/\")).filter(it -> !it.matches(\"\\\\d\")).filter(it -> !it.equals(\"-\")).filter(it -> !it.isEmpty()).collect(Collectors.joining(\".\"));\n    PropertyPath propertyPath = PropertyPath.from(pathSource, entityType);\n    return value instanceof LateObjectEvaluator ? ((LateObjectEvaluator) value).evaluate(propertyPath.getType()) : value;\n// bug_end\n}\n", "target": "// fix_start\n    return evaluate(verifyPath(entityType).<Class<?>> map(it -> it.getType()).orElse(entityType));\n// fix_end\n"}
{"vul_id": "VUL4J-73", "cwe": "CWE-522", "cwe_name": "Insufficiently Protected Credentials", "source": "public boolean isPasswordValid(String encPass, String rawPass, Object salt) {\n// bug_start\n    String pass1 = encPass + \"\";\n// bug_end\n    String pass2 = mergePasswordAndSalt(rawPass, salt, false);\n    if (ignorePasswordCase) {\n        pass1 = pass1.toLowerCase(Locale.ENGLISH);\n        pass2 = pass2.toLowerCase(Locale.ENGLISH);\n    }\n    return PasswordEncoderUtils.equals(pass1, pass2);\n}\n", "target": "// fix_start\n    if (encPass == null) {\n        return false;\n    }\n    String pass1 = encPass + \"\";\n// fix_end\n"}
{"vul_id": "VUL4J-74", "cwe": "CWE-332", "cwe_name": "Insufficient Entropy", "source": "public SecureRandom getObject() throws Exception {\n    SecureRandom rnd = SecureRandom.getInstance(algorithm);\n    if (seed != null) {\n        byte[] seedBytes = FileCopyUtils.copyToByteArray(seed.getInputStream());\n        rnd.setSeed(seedBytes);\n    }\n// bug_start\n    else {\n        rnd.nextBytes(new byte[1]);\n    }\n// bug_end\n    return rnd;\n}\n", "target": "// fix_start\n    rnd.nextBytes(new byte[1]);\n// fix_end\n"}
