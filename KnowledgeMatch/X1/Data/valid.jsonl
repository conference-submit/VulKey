{"source": " @BeforeEach\n     public void startServer() throws Exception\n     {\n         String keystore = MavenTestingUtils.getTestResourceFile(\"keystore\").getAbsolutePath();\n// bug_start\n        SslContextFactory sslContextFactory = new SslContextFactory.Server();\n// bug_end\n         sslContextFactory.setKeyStorePath(keystore);\n         sslContextFactory.setKeyStorePassword(\"storepwd\");\n         sslContextFactory.setKeyManagerPassword(\"keypwd\");\n \n         server = new Server();\n         HttpConnectionFactory http = new HttpConnectionFactory();\n         http.setInputBufferSize(512);\n         http.getHttpConfiguration().setRequestHeaderSize(512);\n         connector = new ServerConnector(server, sslContextFactory, http);\n         connector.setPort(0);\n         connector.getConnectionFactory(HttpConnectionFactory.class).getHttpConfiguration().setSendDateHeader(false);\n \n         server.addConnector(connector);\n     }\n \n", "target": "// fix_start\n        sslContextFactory = new SslContextFactory.Server();\n// fix_end\n", "cwe": "CWE-59", "cwe_name": "Improper Link Resolution Before File Access ('Link Following')", "idx": 65382}
{"source": " @Override\n         public int fill(ByteBuffer buffer) throws IOException\n         {\n             try\n             {\n                 synchronized (_decryptedEndPoint)\n                 {\n                     if (LOG.isDebugEnabled())\n                         LOG.debug(\">fill {}\", SslConnection.this);\n \n                     int filled = -2;\n                     try\n                     {\n                         if (_fillState != FillState.IDLE)\n                             return filled = 0;\n \n                         if (BufferUtil.hasContent(_decryptedInput))\n                             return filled = BufferUtil.append(buffer, _decryptedInput);\n \n                         while (true)\n                         {\n                             HandshakeStatus status = _sslEngine.getHandshakeStatus();\n                             if (LOG.isDebugEnabled())\n                                 LOG.debug(\"fill {}\", status);\n                             switch (status)\n                             {\n                                 case NEED_UNWRAP:\n                                 case NOT_HANDSHAKING:\n                                     break;\n \n                                 case NEED_TASK:\n                                     _sslEngine.getDelegatedTask().run();\n                                     continue;\n \n                                 case NEED_WRAP:\n                                     if (_flushState == FlushState.IDLE && flush(BufferUtil.EMPTY_BUFFER))\n                                     {\n                                         Throwable failure = _failure;\n                                         if (failure != null)\n                                             rethrow(failure);\n                                         if (_sslEngine.isInboundDone())\n                                             return filled = -1;\n                                         continue;\n                                     }\n                                     return filled = 0;\n \n                                 default:\n                                     throw new IllegalStateException(\"Unexpected HandshakeStatus \" + status);\n                             }\n \n                             acquireEncryptedInput();\n \n                             ByteBuffer appIn;\n                             int appBufferSize = getApplicationBufferSize();\n                             if (_decryptedInput == null)\n                             {\n                                 if (BufferUtil.space(buffer) > appBufferSize)\n                                     appIn = buffer;\n                                 else\n                                     appIn = _decryptedInput = _bufferPool.acquire(appBufferSize, _decryptedDirectBuffers);\n                             }\n                             else\n                             {\n                                 appIn = _decryptedInput;\n                                 BufferUtil.compact(_encryptedInput);\n                             }\n \n                             int netFilled = networkFill(_encryptedInput);\n                             if (LOG.isDebugEnabled())\n                                 LOG.debug(\"net filled={}\", netFilled);\n \n                             if (netFilled < 0 && isHandshakeInitial() && BufferUtil.isEmpty(_encryptedInput))\n                                 closeInbound();\n \n                             if (netFilled > 0 && !isHandshakeComplete() && isOutboundDone())\n                                 throw new SSLHandshakeException(\"Closed during handshake\");\n \n                             if (_handshake.compareAndSet(HandshakeState.INITIAL, HandshakeState.HANDSHAKE))\n                             {\n                                 if (LOG.isDebugEnabled())\n                                     LOG.debug(\"fill starting handshake {}\", SslConnection.this);\n                             }\n \n                             int pos = BufferUtil.flipToFill(appIn);\n                             SSLEngineResult unwrapResult;\n                             try\n                             {\n                                 _underflown = false;\n                                 unwrapResult = unwrap(_sslEngine, _encryptedInput, appIn);\n                             }\n                             finally\n                             {\n                                 BufferUtil.flipToFlush(appIn, pos);\n                             }\n                             if (LOG.isDebugEnabled())\n                                 LOG.debug(\"unwrap net_filled={} {} encryptedBuffer={} unwrapBuffer={} appBuffer={}\",\n                                     netFilled,\n                                     StringUtil.replace(unwrapResult.toString(), '\\n', ' '),\n                                     BufferUtil.toSummaryString(_encryptedInput),\n                                     BufferUtil.toDetailString(appIn),\n                                     BufferUtil.toDetailString(buffer));\n \n                             SSLEngineResult.Status unwrap = unwrapResult.getStatus();\n \n                             if (unwrap == Status.OK && unwrapResult.bytesConsumed() == 0 && unwrapResult.bytesProduced() == 0)\n                                 unwrap = Status.BUFFER_UNDERFLOW;\n \n                             switch (unwrap)\n                             {\n                                 case CLOSED:\n                                     Throwable failure = _failure;\n                                     if (failure != null)\n                                         rethrow(failure);\n                                     return filled = -1;\n \n                                 case BUFFER_UNDERFLOW:\n                                     if (netFilled > 0)\n// bug_start\n                                        continue;\n// bug_end\n                                     _underflown = true;\n                                     if (netFilled < 0 && _sslEngine.getUseClientMode())\n                                     {\n                                         Throwable closeFailure = closeInbound();\n                                         if (_flushState == FlushState.WAIT_FOR_FILL)\n                                         {\n                                             Throwable handshakeFailure = new SSLHandshakeException(\"Abruptly closed by peer\");\n                                             if (closeFailure != null)\n// bug_start\n                                                handshakeFailure.initCause(closeFailure);\n// bug_end\n                                             throw handshakeFailure;\n                                         }\n                                         return filled = -1;\n                                     }\n                                     return filled = netFilled;\n \n                                 case BUFFER_OVERFLOW:\n                                     if (BufferUtil.isEmpty(_decryptedInput) && appBufferSize < getApplicationBufferSize())\n                                     {\n                                         releaseDecryptedInputBuffer();\n                                         continue;\n                                     }\n                                     throw new IllegalStateException(\"Unexpected unwrap result \" + unwrap);\n \n                                 case OK:\n                                     if (unwrapResult.getHandshakeStatus() == HandshakeStatus.FINISHED)\n                                         handshakeSucceeded();\n \n                                     if (isRenegotiating() && !allowRenegotiate())\n                                         return filled = -1;\n \n                                     if (unwrapResult.bytesProduced() > 0)\n                                     {\n                                         if (appIn == buffer)\n                                             return filled = unwrapResult.bytesProduced();\n                                         return filled = BufferUtil.append(buffer, _decryptedInput);\n                                     }\n \n                                     break;\n \n                                 default:\n                                     throw new IllegalStateException(\"Unexpected unwrap result \" + unwrap);\n                             }\n                         }\n                     }\n                     catch (Throwable x)\n                     {\n                         Throwable f = handleException(x, \"fill\");\n                         Throwable failure = handshakeFailed(f);\n                         if (_flushState == FlushState.WAIT_FOR_FILL)\n                         {\n                             _flushState = FlushState.IDLE;\n                             getExecutor().execute(() -> _decryptedEndPoint.getWriteFlusher().onFail(failure));\n                         }\n                         throw failure;\n                     }\n                     finally\n                     {\n                         releaseEncryptedInputBuffer();\n                         releaseDecryptedInputBuffer();\n \n                         if (_flushState == FlushState.WAIT_FOR_FILL)\n                         {\n                             _flushState = FlushState.IDLE;\n                             getExecutor().execute(() -> _decryptedEndPoint.getWriteFlusher().completeWrite());\n                         }\n \n                         if (LOG.isDebugEnabled())\n                             LOG.debug(\"<fill f={} uf={} {}\", filled, _underflown, SslConnection.this);\n                     }\n                 }\n             }\n             catch (Throwable x)\n             {\n                 close(x);\n                 rethrow(x);\n                 throw new AssertionError();\n             }\n         }\n \n", "target": "// fix_start\n                                    {\n                                        if (BufferUtil.space(_encryptedInput) > 0)\n                                            continue;\n                                        BufferUtil.clear(_encryptedInput);\n                                        throw new SSLHandshakeException(\"Encrypted buffer max length exceeded\");\n                                    }\n// fix_end\n// fix_start\n                                                handshakeFailure.addSuppressed(closeFailure);\n// fix_end\n", "cwe": "CWE-59", "cwe_name": "Improper Link Resolution Before File Access ('Link Following')", "idx": 65105}
{"source": "// bug_start\npublic User getUser(String id) {\n        return User.getById(id, true);\n// bug_end\n     }\n \n", "target": "// fix_start\n@Restricted(NoExternalUse.class)\n    public User getUser(String id) {\n        return User.getById(id, User.ALLOW_USER_CREATION_VIA_URL && hasPermission(Jenkins.ADMINISTER));\n// fix_end\n", "cwe": "NVD-CWE-noinfo", "cwe_name": "", "idx": 98175}
{"source": "// bug_start\npublic Object instantiate(Class type, Configuration conf, boolean fatal) {\n        Object obj = newInstance(_name, type, conf, fatal);\n// bug_end\n \n// bug_start\n        if (obj != null && !type.isAssignableFrom(obj.getClass())) {\n            Log log = (conf == null) ? null : conf.getConfigurationLog();\n            String msg = getIncompatiblePluginMessage(obj, type);\n            if (log != null && log.isErrorEnabled()) {\n            \tlog.error(msg);\n            }\n            if (fatal) {\n            \tthrow new ParseException(msg);\n            }\n            return null;\n        }\n// bug_end\n \n// bug_start\n        Configurations.configureInstance(obj, conf, _props,\n            (fatal) ? getProperty() : null);\n        if (_singleton)\n            set(obj, true);\n        return obj;\n// bug_end\n     }\n \n", "target": "// fix_start\nprotected Object readResolve()\n        throws ObjectStreamException {\n        AbstractBrokerFactory factory = getPooledFactory(_conf);\n        if (factory != null)\n            return factory;\n// fix_end\n// fix_start\n        _transactional = new ConcurrentHashMap();\n        _brokers = new ConcurrentReferenceHashSet(\n                ConcurrentReferenceHashSet.WEAK);\n// fix_end\n// fix_start\n        String saveLogConfig = _conf.getLog();\n        _conf.setLog(\"none\");\n        makeReadOnly();\n        _conf.setLog(saveLogConfig);\n\n        return this;\n// fix_end\n", "cwe": "CWE-264", "cwe_name": "Permissions, Privileges, and Access Controls", "idx": 33008}
{"source": "// bug_start\npublic Object instantiate(Class type, Configuration conf, boolean fatal) {\n        Object obj = newInstance(_name, type, conf, fatal);\n        Configurations.configureInstance(obj, conf, _props,\n            (fatal) ? getProperty() : null);\n        if (_singleton)\n            set(obj, true);\n        return obj;\n// bug_end\n     }\n \n", "target": "// fix_start\nprotected Object readResolve()\n        throws ObjectStreamException {\n        AbstractBrokerFactory factory = getPooledFactory(_conf);\n        if (factory != null)\n            return factory;\n\n        _transactional = new ConcurrentHashMap();\n        _brokers = new ConcurrentReferenceHashSet(\n                ConcurrentReferenceHashSet.WEAK);\n\n        makeReadOnly();\n        return this;\n// fix_end\n", "cwe": "CWE-264", "cwe_name": "Permissions, Privileges, and Access Controls", "idx": 33399}
{"source": " public DIHConfiguration loadDataConfig(InputSource configFile) {\n \n     DIHConfiguration dihcfg = null;\n     try {\n       DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();\n// bug_start\n// bug_end\n \n       if (core != null && configFile.getSystemId() != null) {\n         try {\n           dbf.setXIncludeAware(true);\n           dbf.setNamespaceAware(true);\n         } catch( UnsupportedOperationException e ) {\n           LOG.warn( \"XML parser doesn't support XInclude option\" );\n         }\n       }\n \n       DocumentBuilder builder = dbf.newDocumentBuilder();\n// bug_start\n      if (core != null)\n// bug_end\n         builder.setEntityResolver(new SystemIdResolver(core.getResourceLoader()));\n// bug_start\n// bug_end\n       builder.setErrorHandler(XMLLOG);\n       Document document;\n       try {\n         document = builder.parse(configFile);\n       } finally {\n         IOUtils.closeQuietly(configFile.getByteStream());\n       }\n \n       dihcfg = readFromXml(document);\n       LOG.info(\"Data Configuration loaded successfully\");\n     } catch (Exception e) {\n       throw new DataImportHandlerException(SEVERE,\n               \"Data Config problem: \" + e.getMessage(), e);\n     }\n     for (Entity e : dihcfg.getEntities()) {\n       if (e.getAllAttributes().containsKey(SqlEntityProcessor.DELTA_QUERY)) {\n         isDeltaImportSupported = true;\n         break;\n       }\n     }\n     return dihcfg;\n   }\n \n", "target": "// fix_start\n      dbf.setValidating(false);\n// fix_end\n// fix_start\n      if (core != null && configFile.getSystemId() != null) {\n// fix_end\n// fix_start\n      } else {\n        builder.setEntityResolver(EmptyEntityResolver.SAX_INSTANCE);\n      }\n// fix_end\n", "cwe": "CWE-611", "cwe_name": "Improper Restriction of XML External Entity Reference ('XXE')", "idx": 68711}
{"source": " public Map<String, ResultTypeConfig> getResultTypesByExtension(PackageConfig packageConfig) {\n         Map<String, ResultTypeConfig> results = packageConfig.getAllResultTypeConfigs();\n \n// bug_start\n// bug_end\n         Map<String, ResultTypeConfig> resultsByExtension = new HashMap<String, ResultTypeConfig>();\n// bug_start\n        resultsByExtension.put(\"jsp\", results.get(\"dispatcher\"));\n        resultsByExtension.put(\"jspf\", results.get(\"dispatcher\"));\n        resultsByExtension.put(\"jspx\", results.get(\"dispatcher\"));\n        resultsByExtension.put(\"vm\", results.get(\"velocity\"));\n        resultsByExtension.put(\"ftl\", results.get(\"freemarker\"));\n        resultsByExtension.put(\"html\", results.get(\"dispatcher\"));\n        resultsByExtension.put(\"htm\", results.get(\"dispatcher\"));\n// bug_end\n         return resultsByExtension;\n     }\n \n", "target": "// fix_start\n        ResultTypeConfig dispatcher = disableParse(results.get(\"dispatcher\"));\n        ResultTypeConfig velocity = disableParse(results.get(\"velocity\"));\n        ResultTypeConfig freemarker = disableParse(results.get(\"freemarker\"));\n\n// fix_end\n// fix_start\n        resultsByExtension.put(\"jsp\", dispatcher);\n        resultsByExtension.put(\"jspf\", dispatcher);\n        resultsByExtension.put(\"jspx\", dispatcher);\n        resultsByExtension.put(\"vm\", velocity);\n        resultsByExtension.put(\"ftl\", freemarker);\n        resultsByExtension.put(\"html\", dispatcher);\n        resultsByExtension.put(\"htm\", dispatcher);\n// fix_end\n", "cwe": "CWE-22", "cwe_name": "Path Traversal", "idx": 25794}
{"source": " @Override\n         public boolean check(Object credentials)\n         {\n// bug_start\n// bug_end\n             String password = (credentials instanceof String) ? (String) credentials : credentials.toString();\n \n             try\n             {\n                 MessageDigest md = MessageDigest.getInstance(\"MD5\");\n                 byte[] ha1;\n                 if (credentials instanceof Credential.MD5)\n                 {\n                     ha1 = ((Credential.MD5) credentials).getDigest();\n                 }\n                 else\n                 {\n                     md.update(username.getBytes(StandardCharsets.ISO_8859_1));\n                     md.update((byte) ':');\n                     md.update(realm.getBytes(StandardCharsets.ISO_8859_1));\n                     md.update((byte) ':');\n                     md.update(password.getBytes(StandardCharsets.ISO_8859_1));\n                     ha1 = md.digest();\n                 }\n                 md.reset();\n                 md.update(method.getBytes(StandardCharsets.ISO_8859_1));\n                 md.update((byte) ':');\n                 md.update(uri.getBytes(StandardCharsets.ISO_8859_1));\n                 byte[] ha2 = md.digest();\n \n \n                 md.update(TypeUtil.toString(ha1, 16).getBytes(StandardCharsets.ISO_8859_1));\n                 md.update((byte) ':');\n                 md.update(nonce.getBytes(StandardCharsets.ISO_8859_1));\n                 md.update((byte) ':');\n                 md.update(nc.getBytes(StandardCharsets.ISO_8859_1));\n                 md.update((byte) ':');\n                 md.update(cnonce.getBytes(StandardCharsets.ISO_8859_1));\n                 md.update((byte) ':');\n                 md.update(qop.getBytes(StandardCharsets.ISO_8859_1));\n                 md.update((byte) ':');\n                 md.update(TypeUtil.toString(ha2, 16).getBytes(StandardCharsets.ISO_8859_1));\n                 byte[] digest = md.digest();\n \n// bug_start\n                return (TypeUtil.toString(digest, 16).equalsIgnoreCase(response));\n// bug_end\n             }\n             catch (Exception e)\n             {\n                 LOG.warn(e);\n             }\n \n             return false;\n         }\n \n", "target": "// fix_start\n            if (credentials instanceof char[])\n                credentials=new String((char[])credentials);\n// fix_end\n// fix_start\n                return stringEquals(TypeUtil.toString(digest, 16).toLowerCase(), response == null ? null : response.toLowerCase());\n// fix_end\n", "cwe": "CWE-203", "cwe_name": "Information Exposure Through Discrepancy", "idx": 20336}
{"source": " @Override\n         public boolean check(Object credentials)\n         {\n// bug_start\n            if (credentials instanceof char[])\n                credentials=new String((char[])credentials);\n// bug_end\n             String password = (credentials instanceof String) ? (String) credentials : credentials.toString();\n \n             try\n             {\n                 MessageDigest md = MessageDigest.getInstance(\"MD5\");\n                 byte[] ha1;\n                 if (credentials instanceof Credential.MD5)\n                 {\n                     ha1 = ((Credential.MD5) credentials).getDigest();\n                 }\n                 else\n                 {\n                     md.update(username.getBytes(StandardCharsets.ISO_8859_1));\n                     md.update((byte) ':');\n                     md.update(realm.getBytes(StandardCharsets.ISO_8859_1));\n                     md.update((byte) ':');\n                     md.update(password.getBytes(StandardCharsets.ISO_8859_1));\n                     ha1 = md.digest();\n                 }\n                 md.reset();\n                 md.update(method.getBytes(StandardCharsets.ISO_8859_1));\n                 md.update((byte) ':');\n                 md.update(uri.getBytes(StandardCharsets.ISO_8859_1));\n                 byte[] ha2 = md.digest();\n \n \n                 md.update(TypeUtil.toString(ha1, 16).getBytes(StandardCharsets.ISO_8859_1));\n                 md.update((byte) ':');\n                 md.update(nonce.getBytes(StandardCharsets.ISO_8859_1));\n                 md.update((byte) ':');\n                 md.update(nc.getBytes(StandardCharsets.ISO_8859_1));\n                 md.update((byte) ':');\n                 md.update(cnonce.getBytes(StandardCharsets.ISO_8859_1));\n                 md.update((byte) ':');\n                 md.update(qop.getBytes(StandardCharsets.ISO_8859_1));\n                 md.update((byte) ':');\n                 md.update(TypeUtil.toString(ha2, 16).getBytes(StandardCharsets.ISO_8859_1));\n                 byte[] digest = md.digest();\n \n// bug_start\n                return (TypeUtil.toString(digest, 16).equalsIgnoreCase(response));\n// bug_end\n             }\n             catch (Exception e)\n             {\n                 LOG.warn(e);\n             }\n \n             return false;\n         }\n \n", "target": "// fix_start\n// fix_end\n// fix_start\n                return stringEquals(TypeUtil.toString(digest, 16).toLowerCase(), response == null ? null : response.toLowerCase());\n// fix_end\n", "cwe": "CWE-203", "cwe_name": "Information Exposure Through Discrepancy", "idx": 20335}
{"source": " @WebMethod(name=\"heapdump.hprof\")\n         public void doHeapDump(StaplerRequest req, StaplerResponse rsp) throws IOException, InterruptedException {\n// bug_start\n            owner.checkPermission(Jenkins.ADMINISTER);\n// bug_end\n             rsp.setContentType(\"application/octet-stream\");\n \n             FilePath dump = obtain();\n             try {\n                 dump.copyTo(rsp.getCompressedOutputStream(req));\n             } finally {\n                 dump.delete();\n             }\n         }\n \n", "target": "// fix_start\n            owner.checkPermission(Jenkins.RUN_SCRIPTS);\n// fix_end\n", "cwe": "CWE-264", "cwe_name": "Permissions, Privileges, and Access Controls", "idx": 30122}
{"source": " @Override\n     public AbstractBuild<?,?> resolveChild(Child child) {\n         MatrixBuild b = (MatrixBuild)owner;\n// bug_start\n        return b.getRun(Combination.fromString(child.name));\n// bug_end\n     }\n \n", "target": "// fix_start\n        return b.getProject().getItem(Combination.fromString(child.name)).getBuildByNumber(child.build);\n// fix_end\n", "cwe": "NVD-CWE-Other", "cwe_name": "Other", "idx": 110384}
{"source": " public Socket connectSocket(\n             final Socket socket,\n             final InetSocketAddress remoteAddress,\n             final InetSocketAddress localAddress,\n             final HttpParams params) throws IOException, UnknownHostException, ConnectTimeoutException {\n         Args.notNull(remoteAddress, \"Remote address\");\n         Args.notNull(params, \"HTTP parameters\");\n         final HttpHost host;\n         if (remoteAddress instanceof HttpInetSocketAddress) {\n             host = ((HttpInetSocketAddress) remoteAddress).getHttpHost();\n         } else {\n             host = new HttpHost(remoteAddress.getHostName(), remoteAddress.getPort(), \"https\");\n         }\n// bug_start\n// bug_end\n         final int connectTimeout = HttpConnectionParams.getConnectionTimeout(params);\n// bug_start\n// bug_end\n         return connectSocket(connectTimeout, socket, host, remoteAddress, localAddress, null);\n     }\n \n", "target": "// fix_start\n        final int socketTimeout = HttpConnectionParams.getSoTimeout(params);\n// fix_end\n// fix_start\n        socket.setSoTimeout(socketTimeout);\n// fix_end\n", "cwe": "CWE-399", "cwe_name": "Resource Management Errors", "idx": 51175}
{"source": " @Exported(name=\"jobs\")\n     public List<TopLevelItem> getItems() {\n// bug_start\n        if (authorizationStrategy instanceof AuthorizationStrategy.Unsecured ||\n            authorizationStrategy instanceof FullControlOnceLoggedInAuthorizationStrategy) {\n            return new ArrayList(items.values());\n        }\n\n// bug_end\n         List<TopLevelItem> viewableItems = new ArrayList<TopLevelItem>();\n         for (TopLevelItem item : items.values()) {\n             if (item.hasPermission(Item.READ))\n                 viewableItems.add(item);\n         }\n \n         return viewableItems;\n     }\n \n", "target": "// fix_start\n// fix_end\n", "cwe": "CWE-200", "cwe_name": "Exposure of Sensitive Information to an Unauthorized Actor", "idx": 12693}
{"source": "\n", "target": "\n", "cwe": "CWE-862", "cwe_name": "Missing Authorization", "idx": 83907}
{"source": " private CoderResult decodeHasArray(ByteBuffer in, CharBuffer out) {\n         int outRemaining = out.remaining();\n         int pos = in.position();\n         int limit = in.limit();\n         final byte[] bArr = in.array();\n         final char[] cArr = out.array();\n         final int inIndexLimit = limit + in.arrayOffset();\n         int inIndex = pos + in.arrayOffset();\n         int outIndex = out.position() + out.arrayOffset();\n         for (; inIndex < inIndexLimit && outRemaining > 0; inIndex++) {\n             int jchar = bArr[inIndex];\n             if (jchar < 0) {\n                 jchar = jchar & 0x7F;\n                 int tail = remainingBytes[jchar];\n                 if (tail == -1) {\n                     in.position(inIndex - in.arrayOffset());\n                     out.position(outIndex - out.arrayOffset());\n                     return CoderResult.malformedForLength(1);\n                 }\n                 if (inIndexLimit - inIndex < 1 + tail) {\n                     if (jchar == 0x74 && inIndexLimit > inIndex + 1) {\n                         if ((bArr[inIndex + 1] & 0xFF) > 0x8F) {\n                             return CoderResult.unmappableForLength(4);\n// bug_start\n// bug_end\n                         }\n                     }\n                     break;\n                 }\n                 for (int i = 0; i < tail; i++) {\n                     int nextByte = bArr[inIndex + i + 1] & 0xFF;\n                     if ((nextByte & 0xC0) != 0x80) {\n                         in.position(inIndex - in.arrayOffset());\n                         out.position(outIndex - out.arrayOffset());\n                         return CoderResult.malformedForLength(1 + i);\n                     }\n                     jchar = (jchar << 6) + nextByte;\n                 }\n                 jchar -= remainingNumbers[tail];\n                 if (jchar < lowerEncodingLimit[tail]) {\n                     in.position(inIndex - in.arrayOffset());\n                     out.position(outIndex - out.arrayOffset());\n                     return CoderResult.malformedForLength(1);\n                 }\n                 inIndex += tail;\n             }\n             if (jchar >= 0xD800 && jchar <= 0xDFFF) {\n                 return CoderResult.unmappableForLength(3);\n             }\n             if (jchar > 0x10FFFF) {\n                 return CoderResult.unmappableForLength(4);\n             }\n             if (jchar <= 0xffff) {\n                 cArr[outIndex++] = (char) jchar;\n                 outRemaining--;\n             } else {\n                 if (outRemaining < 2) {\n                     return CoderResult.OVERFLOW;\n                 }\n                 cArr[outIndex++] = (char) ((jchar >> 0xA) + 0xD7C0);\n                 cArr[outIndex++] = (char) ((jchar & 0x3FF) + 0xDC00);\n                 outRemaining -= 2;\n             }\n         }\n         in.position(inIndex - in.arrayOffset());\n         out.position(outIndex - out.arrayOffset());\n         return (outRemaining == 0 && inIndex < inIndexLimit) ? CoderResult.OVERFLOW\n                 : CoderResult.UNDERFLOW;\n     }\n \n", "target": "// fix_start\n                        }\n                    }\n                    if (jchar == 0x60 && inIndexLimit > inIndex +1) {\n                        if ((bArr[inIndex + 1] & 0x7F) == 0) {\n                            return CoderResult.malformedForLength(3);\n                        }\n                    }\n                    if (jchar == 0x70 && inIndexLimit > inIndex +1) {\n                        if ((bArr[inIndex + 1] & 0x7F) < 0x10) {\n                            return CoderResult.malformedForLength(4);\n// fix_end\n", "cwe": "CWE-22", "cwe_name": "Path Traversal", "idx": 23579}
{"source": " private void addInputFilter(InputFilter[] inputFilters, String encodingName) {\n// bug_start\n\n// bug_end\n \n         if (encodingName.equals(\"chunked\")) {\n             inputBuffer.addActiveFilter(inputFilters[Constants.CHUNKED_FILTER]);\n             contentDelimitation = true;\n         } else {\n             for (int i = pluggableFilterIndex; i < inputFilters.length; i++) {\n                 if (inputFilters[i].getEncodingName().toString().equals(encodingName)) {\n                     inputBuffer.addActiveFilter(inputFilters[i]);\n                     return;\n                 }\n             }\n             response.setStatus(501);\n             setErrorState(ErrorState.CLOSE_CLEAN, null);\n             if (log.isDebugEnabled()) {\n                 log.debug(sm.getString(\"http11processor.request.prepare\") +\n                           \" Unsupported transfer encoding [\" + encodingName + \"]\");\n             }\n         }\n     }\n \n", "target": "// fix_start\n        if (contentDelimitation) {\n            response.setStatus(400);\n            setErrorState(ErrorState.CLOSE_CLEAN, null);\n            if (log.isDebugEnabled()) {\n                log.debug(sm.getString(\"http11processor.request.prepare\") +\n                          \" Tranfer encoding lists chunked before [\" + encodingName + \"]\");\n            }\n            return;\n        }\n// fix_end\n", "cwe": "CWE-444", "cwe_name": "Inconsistent Interpretation of HTTP Requests ('HTTP Request Smuggling')", "idx": 54485}
{"source": "// bug_start\n@GET\n    @Path(\"/purge/{date}\")\n    public void purge(@PathParam(\"date\") String date) {\n        try {\n            clusterService.purge(new SimpleDateFormat(\"yyyy-MM-dd\").parse(date));\n        } catch (ParseException e) {\n            logger.error(\"Cannot purge\",e);\n// bug_end\n         }\n// bug_start\n// bug_end\n     }\n \n", "target": "// fix_start\npublic String filter(String expression) {\n        if (forbiddenExpressionPatterns != null && expressionMatches(expression, forbiddenExpressionPatterns)) {\n            logger.warn(\"Expression filtered because forbidden. See debug log level for more information\");\n            if (logger.isDebugEnabled()) {\n                logger.debug(\"Expression {} is forbidden by expression filter\", expression);\n            }\n\n            return null;\n// fix_end\n// fix_start\n        if (allowedExpressionPatterns != null && !expressionMatches(expression, allowedExpressionPatterns)) {\n            logger.warn(\"Expression filtered because not allowed. See debug log level for more information\");\n            if (logger.isDebugEnabled()) {\n                logger.debug(\"Expression {} is not allowed by expression filter\", expression);\n            }\n\n            return null;\n        }\n        return expression;\n// fix_end\n", "cwe": "CWE-74", "cwe_name": "Improper Neutralization of Special Elements in Output Used by a Downstream Component ('Injection')", "idx": 73775}
{"source": "// bug_start\npublic String filter(String expression) {\n        if (forbiddenExpressionPatterns != null && expressionMatches(expression, forbiddenExpressionPatterns)) {\n            logger.warn(\"Expression {} is forbidden by expression filter\", expression);\n            return null;\n// bug_end\n         }\n// bug_start\n        if (allowedExpressionPatterns != null && !expressionMatches(expression, allowedExpressionPatterns)) {\n            logger.warn(\"Expression {} is not allowed by expression filter\", expression);\n            return null;\n        }\n        return expression;\n// bug_end\n     }\n \n", "target": "// fix_start\n@GET\n    @Path(\"/purge/{date}\")\n    public void purge(@PathParam(\"date\") String date) {\n        try {\n            clusterService.purge(new SimpleDateFormat(\"yyyy-MM-dd\").parse(date));\n        } catch (ParseException e) {\n            logger.error(\"Cannot parse date, expected format is: yyyy-MM-dd. See debug log level for more information\");\n            if (logger.isDebugEnabled()) {\n                logger.debug(\"Cannot parse date: {}\", date, e);\n            }\n// fix_end\n// fix_start\n// fix_end\n", "cwe": "CWE-74", "cwe_name": "Improper Neutralization of Special Elements in Output Used by a Downstream Component ('Injection')", "idx": 73774}
{"source": " protected void configureSnakeDataFormat(DataFormat dataFormat, CamelContext camelContext) {\n         Class<?> yamlUnmarshalType =  unmarshalType;\n         if (yamlUnmarshalType == null && unmarshalTypeName != null) {\n             try {\n                 yamlUnmarshalType = camelContext.getClassResolver().resolveMandatoryClass(unmarshalTypeName);\n             } catch (ClassNotFoundException e) {\n                 throw ObjectHelper.wrapRuntimeCamelException(e);\n             }\n         }\n \n         setProperty(dataFormat, camelContext, \"unmarshalType\", yamlUnmarshalType);\n         setProperty(dataFormat, camelContext, \"classLoader\", classLoader);\n         setProperty(dataFormat, camelContext, \"useApplicationContextClassLoader\", useApplicationContextClassLoader);\n         setProperty(dataFormat, camelContext, \"prettyFlow\", prettyFlow);\n// bug_start\n// bug_end\n \n         setPropertyRef(dataFormat, camelContext, \"constructor\", constructor);\n         setPropertyRef(dataFormat, camelContext, \"representer\", representer);\n         setPropertyRef(dataFormat, camelContext, \"dumperOptions\", dumperOptions);\n         setPropertyRef(dataFormat, camelContext, \"resolver\", resolver);\n     }\n \n", "target": "// fix_start\n        setProperty(dataFormat, camelContext, \"allowAnyType\", allowAnyType);\n\n        if (typeFilters != null && !typeFilters.isEmpty()) {\n            List<String> typeFilterDefinitions = new ArrayList<>(typeFilters.size());\n            for (YAMLTypeFilterDefinition definition : typeFilters) {\n                String value = definition.getValue();\n\n                if (!value.startsWith(\"type\") && !value.startsWith(\"regexp\")) {\n                    YAMLTypeFilterType type = definition.getType();\n                    if (type == null) {\n                        type = YAMLTypeFilterType.type;\n                    }\n\n                    value = type.name() + \":\" + value;\n                }\n\n                typeFilterDefinitions.add(value);\n            }\n\n            setProperty(dataFormat, camelContext, \"typeFilterDefinitions\", typeFilterDefinitions);\n        }\n// fix_end\n", "cwe": "CWE-502", "cwe_name": "Deserialization of Untrusted Data", "idx": 57294}
{"source": " @Override\n     public JsonDeserializer<Object> createBeanDeserializer(DeserializationContext ctxt,\n             JavaType type, BeanDescription beanDesc)\n         throws JsonMappingException\n     {\n         final DeserializationConfig config = ctxt.getConfig();\n         JsonDeserializer<Object> custom = _findCustomBeanDeserializer(type, config, beanDesc);\n         if (custom != null) {\n             return custom;\n         }\n         if (type.isThrowable()) {\n             return buildThrowableDeserializer(ctxt, type, beanDesc);\n         }\n         if (type.isAbstract() && !type.isPrimitive()) {\n             JavaType concreteType = materializeAbstractType(ctxt, type, beanDesc);\n             if (concreteType != null) {\n                 beanDesc = config.introspect(concreteType);\n                 return buildBeanDeserializer(ctxt, concreteType, beanDesc);\n             }\n         }\n \n         @SuppressWarnings(\"unchecked\")\n         JsonDeserializer<Object> deser = (JsonDeserializer<Object>) findStdDeserializer(ctxt, type, beanDesc);\n         if (deser != null) {\n             return deser;\n         }\n \n         if (!isPotentialBeanType(type.getRawClass())) {\n             return null;\n         }\n// bug_start\n        checkIllegalTypes(ctxt, type, beanDesc);\n// bug_end\n         return buildBeanDeserializer(ctxt, type, beanDesc);\n     }\n \n", "target": "// fix_start\n        _validateSubType(ctxt, type, beanDesc);\n// fix_end\n", "cwe": "CWE-502", "cwe_name": "Deserialization of Untrusted Data", "idx": 61867}
{"source": " protected Configuration createConfiguration(ServletContext servletContext) throws TemplateException {\n         Configuration configuration = new Configuration(Configuration.VERSION_2_3_0);\n \n         configuration.setTemplateExceptionHandler(TemplateExceptionHandler.HTML_DEBUG_HANDLER);\n \n         if (mruMaxStrongSize > 0) {\n             configuration.setSetting(Configuration.CACHE_STORAGE_KEY, \"strong:\" + mruMaxStrongSize);\n         }\n         if (templateUpdateDelay != null) {\n             configuration.setSetting(Configuration.TEMPLATE_UPDATE_DELAY_KEY, templateUpdateDelay);\n         }\n         if (encoding != null) {\n             configuration.setDefaultEncoding(encoding);\n         }\n         configuration.setLocalizedLookup(false);\n         configuration.setWhitespaceStripping(true);\n \n// bug_start\n// bug_end\n         return configuration;\n     }\n \n", "target": "// fix_start\n        LOG.debug(\"Sets NewBuiltinClassResolver to TemplateClassResolver.SAFER_RESOLVER\");\n        configuration.setNewBuiltinClassResolver(TemplateClassResolver.SAFER_RESOLVER);\n\n// fix_end\n", "cwe": "CWE-20", "cwe_name": "Improper Input Validation", "idx": 6218}
{"source": " @Override\n     public void testIsXXEVulnerable() throws Exception {\n         try {\n             super.testIsXXEVulnerable();\n             fail(\"Thrown \" + XStreamException.class.getName() + \" expected\");\n         } catch (final XStreamException e) {\n// bug_start\n            final String message = e.getMessage().toLowerCase();\n            if (message.contains(\"Package\")) {\n// bug_end\n                 throw e;\n             }\n         }\n     }\n \n", "target": "// fix_start\n            final String message = e.getMessage();\n            if (!message.contains(\"DOCTYPE\")) {\n// fix_end\n", "cwe": "CWE-200", "cwe_name": "Exposure of Sensitive Information to an Unauthorized Actor", "idx": 19841}
{"source": " @Override\n     protected void service(HttpServletRequest req, HttpServletResponse resp)\n         throws ServletException, IOException {\n \n         final String path = getRelativePath(req);\n \n         if (isSpecialPath(path)) {\n             resp.sendError(WebdavStatus.SC_NOT_FOUND);\n// bug_start\n// bug_end\n             return;\n         }\n \n         final String method = req.getMethod();\n \n         if (debug > 0) {\n             log(\"[\" + method + \"] \" + path);\n         }\n \n         if (method.equals(METHOD_PROPFIND)) {\n             doPropfind(req, resp);\n         } else if (method.equals(METHOD_PROPPATCH)) {\n             doProppatch(req, resp);\n         } else if (method.equals(METHOD_MKCOL)) {\n             doMkcol(req, resp);\n         } else if (method.equals(METHOD_COPY)) {\n             doCopy(req, resp);\n         } else if (method.equals(METHOD_MOVE)) {\n             doMove(req, resp);\n         } else if (method.equals(METHOD_LOCK)) {\n             doLock(req, resp);\n         } else if (method.equals(METHOD_UNLOCK)) {\n             doUnlock(req, resp);\n         } else {\n             super.service(req, resp);\n         }\n \n     }\n \n", "target": "// fix_start\n            return;\n        }\n\n        if (req.getDispatcherType() == DispatcherType.ERROR) {\n            doGet(req, resp);\n// fix_end\n", "cwe": "CWE-755", "cwe_name": "Improper Handling of Exceptional Conditions", "idx": 74324}
{"source": " @Override\n     public Object unmarshal(final Exchange exchange, final InputStream inputStream) throws Exception {\n// bug_start\n        final Hessian2Input in = new Hessian2Input(inputStream);\n// bug_end\n         try {\n             in.startMessage();\n             final Object obj = in.readObject();\n             in.completeMessage();\n             return obj;\n         } finally {\n             try {\n                 in.close();\n             } catch (IOException e) {\n             }\n         }\n     }\n \n", "target": "// fix_start\n        final Hessian2Input in;\n        if (!whitelistEnabled) {\n            in = new Hessian2Input(inputStream);\n        } else {\n            HessianFactory factory = new HessianFactory();\n            if (ObjectHelper.isNotEmpty(allowedUnmarshallObjects)) {\n                factory.allow(allowedUnmarshallObjects);\n            }\n            if (ObjectHelper.isNotEmpty(deniedUnmarshallObjects)) {\n                factory.deny(deniedUnmarshallObjects);\n            }\n            in = factory.createHessian2Input(inputStream);\n        }\n// fix_end\n", "cwe": "CWE-502", "cwe_name": "Deserialization of Untrusted Data", "idx": 57652}
{"source": "// bug_start\nprotected void createWebXmlDigester(boolean namespaceAware,\n// bug_end\n             boolean validation) {\n \n         if (!namespaceAware && !validation) {\n// bug_start\n// bug_end\n             webDigester = webDigesters[0];\n             webFragmentDigester = webFragmentDigesters[0];\n \n         } else if (!namespaceAware && validation) {\n// bug_start\n// bug_end\n             webDigester = webDigesters[1];\n             webFragmentDigester = webFragmentDigesters[1];\n \n         } else if (namespaceAware && !validation) {\n// bug_start\n// bug_end\n             webDigester = webDigesters[2];\n             webFragmentDigester = webFragmentDigesters[2];\n \n         } else {\n// bug_start\n// bug_end\n             webDigester = webDigesters[3];\n             webFragmentDigester = webFragmentDigesters[3];\n         }\n     }\n \n", "target": "// fix_start\npublic void createWebXmlDigester(boolean namespaceAware,\n// fix_end\n// fix_start\n            if (webDigesters[0] == null) {\n                webDigesters[0] = DigesterFactory.newDigester(validation,\n                        namespaceAware, webRuleSet);\n                webFragmentDigesters[0] = DigesterFactory.newDigester(validation,\n                        namespaceAware, webFragmentRuleSet);\n            }\n// fix_end\n// fix_start\n            if (webDigesters[1] == null) {\n                webDigesters[1] = DigesterFactory.newDigester(validation,\n                        namespaceAware, webRuleSet);\n                webFragmentDigesters[1] = DigesterFactory.newDigester(validation,\n                        namespaceAware, webFragmentRuleSet);\n            }\n// fix_end\n// fix_start\n            if (webDigesters[2] == null) {\n                webDigesters[2] = DigesterFactory.newDigester(validation,\n                        namespaceAware, webRuleSet);\n                webFragmentDigesters[2] = DigesterFactory.newDigester(validation,\n                        namespaceAware, webFragmentRuleSet);\n            }\n// fix_end\n// fix_start\n            if (webDigesters[3] == null) {\n                webDigesters[3] = DigesterFactory.newDigester(validation,\n                        namespaceAware, webRuleSet);\n                webFragmentDigesters[3] = DigesterFactory.newDigester(validation,\n                        namespaceAware, webFragmentRuleSet);\n            }\n// fix_end\n", "cwe": "NVD-CWE-Other", "cwe_name": "Other", "idx": 111220}
{"source": "// bug_start\npublic static JMXConnectorServer createJMXServer(int port, boolean local)\n// bug_end\n     throws IOException\n     {\n         Map<String, Object> env = new HashMap<>();\n \n         InetAddress serverAddress = null;\n         if (local)\n         {\n             serverAddress = InetAddress.getLoopbackAddress();\n             System.setProperty(\"java.rmi.server.hostname\", serverAddress.getHostAddress());\n         }\n \n         env.putAll(configureJmxSocketFactories(serverAddress, local));\n \n// bug_start\n// bug_end\n \n         env.putAll(configureJmxAuthentication());\n \n         MBeanServerForwarder authzProxy = configureJmxAuthorization(env);\n \n// bug_start\n        env.put(RMIExporter.EXPORTER_ATTRIBUTE, new Exporter());\n\n// bug_end\n \n         int rmiPort = Integer.getInteger(\"com.sun.management.jmxremote.rmi.port\", 0);\n// bug_start\n        JMXConnectorServer jmxServer =\n            JMXConnectorServerFactory.newJMXConnectorServer(new JMXServiceURL(\"rmi\", null, rmiPort),\n                                                            env,\n                                                            ManagementFactory.getPlatformMBeanServer());\n// bug_end\n \n         if (authzProxy != null)\n             jmxServer.setMBeanServerForwarder(authzProxy);\n// bug_start\n\n// bug_end\n         jmxServer.start();\n \n// bug_start\n        configureRMIRegistry(port, env);\n\n// bug_end\n         logJmxServiceUrl(serverAddress, port);\n         return jmxServer;\n     }\n \n", "target": "// fix_start\n@SuppressWarnings(\"resource\")\n    public static JMXConnectorServer createJMXServer(int port, boolean local)\n// fix_end\n// fix_start\n        Registry registry = LocateRegistry.createRegistry(port,\n                                                          (RMIClientSocketFactory) env.get(RMIConnectorServer.RMI_CLIENT_SOCKET_FACTORY_ATTRIBUTE),\n                                                          (RMIServerSocketFactory) env.get(RMIConnectorServer.RMI_SERVER_SOCKET_FACTORY_ATTRIBUTE));\n// fix_end\n// fix_start\n        env.put(\"jmx.remote.x.daemon\", \"true\");\n// fix_end\n// fix_start\n\n        RMIJRMPServerImpl server = new RMIJRMPServerImpl(rmiPort,\n                                                         (RMIClientSocketFactory) env.get(RMIConnectorServer.RMI_CLIENT_SOCKET_FACTORY_ATTRIBUTE),\n                                                         (RMIServerSocketFactory) env.get(RMIConnectorServer.RMI_SERVER_SOCKET_FACTORY_ATTRIBUTE),\n                                                         env);\n        JMXServiceURL serviceURL = new JMXServiceURL(\"rmi\", null, rmiPort);\n        RMIConnectorServer jmxServer = new RMIConnectorServer(serviceURL, env, server, ManagementFactory.getPlatformMBeanServer());\n// fix_end\n// fix_start\n// fix_end\n// fix_start\n        registry.rebind(\"jmxrmi\", server);\n// fix_end\n", "cwe": "CWE-306", "cwe_name": "", "idx": 41210}
{"source": " private String getBodyContentAsString() {\n \t\tif (this.body == null) {\n \t\t\treturn null;\n \t\t}\n \t\ttry {\n \t\t\tString contentType = (this.messageProperties != null) ? this.messageProperties.getContentType() : null;\n \t\t\tif (MessageProperties.CONTENT_TYPE_SERIALIZED_OBJECT.equals(contentType)) {\n// bug_start\n\t\t\t\treturn SerializationUtils.deserialize(this.body).toString();\n// bug_end\n \t\t\t}\n \t\t\tif (MessageProperties.CONTENT_TYPE_TEXT_PLAIN.equals(contentType)\n \t\t\t\t\t|| MessageProperties.CONTENT_TYPE_JSON.equals(contentType)\n \t\t\t\t\t|| MessageProperties.CONTENT_TYPE_JSON_ALT.equals(contentType)\n \t\t\t\t\t|| MessageProperties.CONTENT_TYPE_XML.equals(contentType)) {\n \t\t\t\treturn new String(this.body, ENCODING);\n \t\t\t}\n \t\t}\n \t\tcatch (Exception e) {\n \t\t}\n \t\treturn this.body.toString() + \"(byte[\" + this.body.length + \"])\";\n \t}\n \n", "target": "// fix_start\n\t\t\t\treturn SERIALIZER_MESSAGE_CONVERTER.fromMessage(this).toString();\n// fix_end\n", "cwe": "CWE-502", "cwe_name": "Deserialization of Untrusted Data", "idx": 61671}
{"source": " @Override\n     public void servletSecurityAnnotationScan() throws ServletException {\n         if (getServlet() == null) {\n             Class<?> clazz = null;\n             try {\n// bug_start\n                clazz = getParentClassLoader().loadClass(getServletClass());\n// bug_end\n                 processServletSecurityAnnotation(clazz);\n             } catch (ClassNotFoundException e) {\n             }\n         } else {\n             if (servletSecurityAnnotationScanRequired) {\n                 processServletSecurityAnnotation(getServlet().getClass());\n             }\n         }\n     }\n \n", "target": "// fix_start\n                clazz = getParent().getLoader().getClassLoader().loadClass(\n                        getServletClass());\n// fix_end\n", "cwe": "CWE-264", "cwe_name": "Permissions, Privileges, and Access Controls", "idx": 31612}
{"source": " protected SchemaFactory createSchemaFactory() {\n         SchemaFactory factory = SchemaFactory.newInstance(schemaLanguage);\n         if (getResourceResolver() != null) {\n             factory.setResourceResolver(getResourceResolver());\n         }\n// bug_start\n        if (!Boolean.parseBoolean(camelContext.getGlobalOptions().get(ACCESS_EXTERNAL_DTD))) {\n// bug_end\n             try {\n                 factory.setProperty(XMLConstants.ACCESS_EXTERNAL_DTD, \"\");\n             } catch (SAXException e) {\n                 LOG.error(e.getMessage(), e);\n                 throw new IllegalStateException(e);\n             }\n         }\n         return factory;\n     }\n \n", "target": "// fix_start\n        if (camelContext != null && !Boolean.parseBoolean(camelContext.getGlobalOptions().get(ACCESS_EXTERNAL_DTD))) {\n// fix_end\n", "cwe": "CWE-611", "cwe_name": "Improper Restriction of XML External Entity Reference ('XXE')", "idx": 66970}
{"source": " PublicKey getRemotePublicKey(String nodename) {\n// bug_start\n// bug_end\n     String url = cores.getZkController().getZkStateReader().getBaseUrlForNodeName(nodename);\n     try {\n       String uri = url + PATH + \"?wt=json&omitHeader=true\";\n       log.debug(\"Fetching fresh public key from : {}\",uri);\n       HttpResponse rsp = cores.getUpdateShardHandler().getHttpClient().execute(new HttpGet(uri));\n       byte[] bytes = EntityUtils.toByteArray(rsp.getEntity());\n       Map m = (Map) Utils.fromJSON(bytes);\n       String key = (String) m.get(\"key\");\n       if (key == null) {\n         log.error(\"No key available from \" + url + PATH);\n         return null;\n       } else {\n         log.info(\"New Key obtained from  node: {} / {}\", nodename, key);\n       }\n       PublicKey pubKey = CryptoKeys.deserializeX509PublicKey(key);\n       keyCache.put(nodename, pubKey);\n       return pubKey;\n     } catch (Exception e) {\n       log.error(\"Exception trying to get public key from : \" + url, e);\n       return null;\n     }\n \n   }\n \n", "target": "// fix_start\n    if (!cores.getZkController().getZkStateReader().getClusterState().getLiveNodes().contains(nodename)) return null;\n// fix_end\n", "cwe": "CWE-287", "cwe_name": "Improper Authentication", "idx": 39298}
{"source": " private ChannelBuffer unwrap(\n             ChannelHandlerContext ctx, Channel channel,\n             ChannelBuffer nettyInNetBuf, ByteBuffer nioInNetBuf,\n             int initialNettyOutAppBufCapacity) throws SSLException {\n \n         final int nettyInNetBufStartOffset = nettyInNetBuf.readerIndex();\n         final int nioInNetBufStartOffset = nioInNetBuf.position();\n         final ByteBuffer nioOutAppBuf = bufferPool.acquireBuffer();\n \n         ChannelBuffer nettyOutAppBuf = null;\n \n         try {\n             boolean needsWrap = false;\n             for (;;) {\n                 SSLEngineResult result;\n                 boolean needsHandshake = false;\n                 synchronized (handshakeLock) {\n                     if (!handshaken && !handshaking &&\n                         !engine.getUseClientMode() &&\n                         !engine.isInboundDone() && !engine.isOutboundDone()) {\n                         needsHandshake = true;\n                     }\n                 }\n \n                 if (needsHandshake) {\n                     handshake();\n                 }\n \n                 synchronized (handshakeLock) {\n                     for (;;) {\n// bug_start\n// bug_end\n                         try {\n// bug_start\n                            result = engine.unwrap(nioInNetBuf, nioOutAppBuf);\n// bug_end\n                             switch (result.getStatus()) {\n                                 case CLOSED:\n                                     sslEngineCloseFuture.setClosed();\n                                     break;\n                                 case BUFFER_OVERFLOW:\n                                     continue;\n                             }\n \n                             break;\n                         } finally {\n// bug_start\n                            nioOutAppBuf.flip();\n// bug_end\n \n                             nettyInNetBuf.readerIndex(\n                                     nettyInNetBufStartOffset + nioInNetBuf.position() - nioInNetBufStartOffset);\n \n// bug_start\n                            if (nioOutAppBuf.hasRemaining()) {\n// bug_end\n                                 if (nettyOutAppBuf == null) {\n                                     ChannelBufferFactory factory = ctx.getChannel().getConfig().getBufferFactory();\n                                     nettyOutAppBuf = factory.getBuffer(initialNettyOutAppBufCapacity);\n                                 }\n// bug_start\n                                nettyOutAppBuf.writeBytes(nioOutAppBuf);\n// bug_end\n                             }\n// bug_start\n                            nioOutAppBuf.clear();\n// bug_end\n                         }\n                     }\n \n                     final HandshakeStatus handshakeStatus = result.getHandshakeStatus();\n                     handleRenegotiation(handshakeStatus);\n                     switch (handshakeStatus) {\n                     case NEED_UNWRAP:\n                         break;\n                     case NEED_WRAP:\n                         wrapNonAppData(ctx, channel);\n                         break;\n                     case NEED_TASK:\n                         runDelegatedTasks();\n                         break;\n                     case FINISHED:\n                         setHandshakeSuccess(channel);\n                         needsWrap = true;\n                         continue;\n                     case NOT_HANDSHAKING:\n                         if (setHandshakeSuccessIfStillHandshaking(channel)) {\n                             needsWrap = true;\n                             continue;\n                         }\n                         if (writeBeforeHandshakeDone) {\n                             writeBeforeHandshakeDone = false;\n                             needsWrap = true;\n                         }\n                         break;\n                     default:\n                         throw new IllegalStateException(\n                                 \"Unknown handshake status: \" + handshakeStatus);\n                     }\n \n                     if (result.getStatus() == Status.BUFFER_UNDERFLOW ||\n                         result.bytesConsumed() == 0 && result.bytesProduced() == 0) {\n                         break;\n                     }\n                 }\n             }\n \n             if (needsWrap) {\n                 if (!Thread.holdsLock(handshakeLock) && !pendingEncryptedWritesLock.isHeldByCurrentThread()) {\n                     wrap(ctx, channel);\n                 }\n             }\n         } catch (SSLException e) {\n             setHandshakeFailure(channel, e);\n             throw e;\n         } finally {\n             bufferPool.releaseBuffer(nioOutAppBuf);\n         }\n \n         if (nettyOutAppBuf != null && nettyOutAppBuf.readable()) {\n             return nettyOutAppBuf;\n         } else {\n             return null;\n         }\n     }\n \n", "target": "// fix_start\n                        final int outAppBufSize = engine.getSession().getApplicationBufferSize();\n                        final ByteBuffer outAppBuf;\n                        if (nioOutAppBuf.capacity() < outAppBufSize) {\n                            outAppBuf = ByteBuffer.allocate(outAppBufSize);\n                        } else {\n                            outAppBuf = nioOutAppBuf;\n                        }\n\n// fix_end\n// fix_start\n                            result = engine.unwrap(nioInNetBuf, outAppBuf);\n// fix_end\n// fix_start\n                            outAppBuf.flip();\n// fix_end\n// fix_start\n                            if (outAppBuf.hasRemaining()) {\n// fix_end\n// fix_start\n                                nettyOutAppBuf.writeBytes(outAppBuf);\n// fix_end\n// fix_start\n                            outAppBuf.clear();\n// fix_end\n", "cwe": "CWE-119", "cwe_name": "Improper Restriction of Operations within the Bounds of a Memory Buffer", "idx": 2110}
{"source": " public static String normalize(String path, boolean replaceBackSlash) {\n \n// bug_start\n        if (path == null)\n// bug_end\n             return null;\n// bug_start\n// bug_end\n \n         String normalized = path;\n \n         if (replaceBackSlash && normalized.indexOf('\\\\') >= 0)\n             normalized = normalized.replace('\\\\', '/');\n \n// bug_start\n        if (normalized.equals(\"/.\"))\n            return \"/\";\n\n// bug_end\n         if (!normalized.startsWith(\"/\"))\n             normalized = \"/\" + normalized;\n \n// bug_start\n// bug_end\n         while (true) {\n             int index = normalized.indexOf(\"//\");\n// bug_start\n            if (index < 0)\n// bug_end\n                 break;\n// bug_start\n            normalized = normalized.substring(0, index) +\n                normalized.substring(index + 1);\n// bug_end\n         }\n \n         while (true) {\n             int index = normalized.indexOf(\"/./\");\n// bug_start\n            if (index < 0)\n// bug_end\n                 break;\n// bug_start\n            normalized = normalized.substring(0, index) +\n                normalized.substring(index + 2);\n// bug_end\n         }\n \n         while (true) {\n             int index = normalized.indexOf(\"/../\");\n// bug_start\n            if (index < 0)\n// bug_end\n                 break;\n// bug_start\n            if (index == 0)\n                return (null);\n// bug_end\n             int index2 = normalized.lastIndexOf('/', index - 1);\n// bug_start\n            normalized = normalized.substring(0, index2) +\n                normalized.substring(index + 3);\n// bug_end\n         }\n \n// bug_start\n        return (normalized);\n// bug_end\n     }\n \n", "target": "// fix_start\n        if (path == null) {\n// fix_end\n// fix_start\n        }\n// fix_end\n// fix_start\n// fix_end\n// fix_start\n        if (normalized.equals(\"/.\")) {\n            return \"/\";\n        }\n\n        if (normalized.equals(\"/..\")) {\n            return null;\n        }\n\n// fix_end\n// fix_start\n            if (index < 0) {\n// fix_end\n// fix_start\n            }\n            normalized = normalized.substring(0, index) + normalized.substring(index + 1);\n// fix_end\n// fix_start\n            if (index < 0) {\n// fix_end\n// fix_start\n            }\n            normalized = normalized.substring(0, index) + normalized.substring(index + 2);\n// fix_end\n// fix_start\n            if (index < 0) {\n// fix_end\n// fix_start\n            }\n            if (index == 0) {\n                return null;\n            }\n// fix_end\n// fix_start\n            normalized = normalized.substring(0, index2) + normalized.substring(index + 3);\n// fix_end\n// fix_start\n        return normalized;\n// fix_end\n", "cwe": "CWE-22", "cwe_name": "Path Traversal", "idx": 23756}
{"source": " public static long readUE7(InputStream stream) throws IOException {\n         int i;\n         long v = 0;\n         while ((i = stream.read()) >= 0) {\n             v = v << 7;\n             if ((i & 128) == 128) {\n                 v += (i & 127);\n             } else {\n                 v += i;\n                 break;\n             }\n         }\n// bug_start\n// bug_end\n         return v;\n     }\n \n", "target": "// fix_start\n        if (i < 0) {\n            throw new IOException(\"Buffer underun; expected one more byte\");\n        }\n// fix_end\n", "cwe": "NVD-CWE-noinfo", "cwe_name": "", "idx": 108861}
{"source": " private void configureJwtProxySecureProvisioner(String infrastructure) {\n// bug_start\n    install(new FactoryModuleBuilder().build(JwtProxyConfigBuilderFactory.class));\n// bug_end\n     install(new FactoryModuleBuilder().build(JwtProxyProvisionerFactory.class));\n     if (KubernetesInfrastructure.NAME.equals(infrastructure)) {\n       install(\n           new FactoryModuleBuilder()\n               .build(\n                   new TypeLiteral<JwtProxySecureServerExposerFactory<KubernetesEnvironment>>() {}));\n       MapBinder.newMapBinder(\n               binder(),\n               new TypeLiteral<String>() {},\n               new TypeLiteral<SecureServerExposerFactory<KubernetesEnvironment>>() {})\n           .addBinding(\"jwtproxy\")\n           .to(new TypeLiteral<JwtProxySecureServerExposerFactory<KubernetesEnvironment>>() {});\n     } else {\n       install(\n           new FactoryModuleBuilder()\n               .build(\n                   new TypeLiteral<JwtProxySecureServerExposerFactory<OpenShiftEnvironment>>() {}));\n       MapBinder.newMapBinder(\n               binder(),\n               new TypeLiteral<String>() {},\n               new TypeLiteral<SecureServerExposerFactory<OpenShiftEnvironment>>() {})\n           .addBinding(\"jwtproxy\")\n           .to(new TypeLiteral<JwtProxySecureServerExposerFactory<OpenShiftEnvironment>>() {});\n     }\n   }\n \n", "target": "// fix_start\n// fix_end\n", "cwe": "NVD-CWE-Other", "cwe_name": "Other", "idx": 110108}
{"source": " @Override\n     public void onCommand(final Object o) {\n         final Command command = (Command)o;\n         if (!closed.get() && command != null) {\n             try {\n                 command.visit(new CommandVisitorAdapter() {\n                     @Override\n                     public Response processMessageDispatch(MessageDispatch md) throws Exception {\n                         waitForTransportInterruptionProcessingToComplete();\n                         ActiveMQDispatcher dispatcher = dispatchers.get(md.getConsumerId());\n                         if (dispatcher != null) {\n                             Message msg = md.getMessage();\n                             if (msg != null) {\n                                 msg = msg.copy();\n                                 msg.setReadOnlyBody(true);\n                                 msg.setReadOnlyProperties(true);\n                                 msg.setRedeliveryCounter(md.getRedeliveryCounter());\n                                 msg.setConnection(ActiveMQConnection.this);\n                                 msg.setMemoryUsage(null);\n                                 md.setMessage(msg);\n                             }\n                             dispatcher.dispatch(md);\n                         } else {\n                             LOG.debug(\"{} no dispatcher for {} in {}\", this, md, dispatchers);\n                         }\n                         return null;\n                     }\n \n                     @Override\n                     public Response processProducerAck(ProducerAck pa) throws Exception {\n                         if (pa != null && pa.getProducerId() != null) {\n                             ActiveMQMessageProducer producer = producers.get(pa.getProducerId());\n                             if (producer != null) {\n                                 producer.onProducerAck(pa);\n                             }\n                         }\n                         return null;\n                     }\n \n                     @Override\n                     public Response processBrokerInfo(BrokerInfo info) throws Exception {\n                         brokerInfo = info;\n                         brokerInfoReceived.countDown();\n                         optimizeAcknowledge &= !brokerInfo.isFaultTolerantConfiguration();\n                         getBlobTransferPolicy().setBrokerUploadUrl(info.getBrokerUploadUrl());\n                         return null;\n                     }\n \n                     @Override\n                     public Response processConnectionError(final ConnectionError error) throws Exception {\n                         executor.execute(new Runnable() {\n                             @Override\n                             public void run() {\n                                 onAsyncException(error.getException());\n                             }\n                         });\n                         return null;\n                     }\n \n                     @Override\n                     public Response processControlCommand(ControlCommand command) throws Exception {\n// bug_start\n                        onControlCommand(command);\n// bug_end\n                         return null;\n                     }\n \n                     @Override\n                     public Response processConnectionControl(ConnectionControl control) throws Exception {\n                         onConnectionControl((ConnectionControl)command);\n                         return null;\n                     }\n \n                     @Override\n                     public Response processConsumerControl(ConsumerControl control) throws Exception {\n                         onConsumerControl((ConsumerControl)command);\n                         return null;\n                     }\n \n                     @Override\n                     public Response processWireFormat(WireFormatInfo info) throws Exception {\n                         onWireFormatInfo((WireFormatInfo)command);\n                         return null;\n                     }\n                 });\n             } catch (Exception e) {\n                 onClientInternalException(e);\n             }\n         }\n \n         for (Iterator<TransportListener> iter = transportListeners.iterator(); iter.hasNext();) {\n             TransportListener listener = iter.next();\n             listener.onCommand(command);\n         }\n     }\n \n", "target": "// fix_start\n// fix_end\n", "cwe": "CWE-20", "cwe_name": "Improper Input Validation", "idx": 5059}
{"source": "// bug_start\nprivate void cacheInput(Message outMessage) {\n        if (outMessage.getExchange() == null) {\n// bug_end\n             return;\n         }\n// bug_start\n        Message inMessage = outMessage.getExchange().getInMessage();\n        if (inMessage == null) {\n            return;\n        }\n        Object o = inMessage.get(\"cxf.io.cacheinput\");\n        DelegatingInputStream in = inMessage.getContent(DelegatingInputStream.class);\n        if (MessageUtils.isTrue(o)) {\n            Collection<Attachment> atts = inMessage.getAttachments();\n            if (atts != null) {\n                for (Attachment a : atts) {\n                    if (a.getDataHandler().getDataSource() instanceof AttachmentDataSource) {\n                        try {\n                            ((AttachmentDataSource)a.getDataHandler().getDataSource()).cache(inMessage);\n                        } catch (IOException e) {\n                            throw new Fault(e);\n                        }\n                    }\n                }\n// bug_end\n             }\n// bug_start\n            if (in != null) {\n                in.cacheInput();\n// bug_end\n             }\n// bug_start\n        } else if (in != null) {\n            try {\n                IOUtils.consume(in, 16 * 1024 * 1024);\n            } catch (IOException ioe) {\n            }\n// bug_end\n         }\n     }\n \n", "target": "// fix_start\npublic void handleMessage(Message message) {\n        Exchange ex = message.getExchange();\n        BindingOperationInfo binding = ex.get(BindingOperationInfo.class);\n        message.put(\"cxf.io.cacheinput\", Boolean.TRUE);\n        if (null != binding && null != binding.getOperationInfo() && binding.getOperationInfo().isOneWay()) {\n            closeInput(message);\n// fix_end\n// fix_start\n        Message out = ex.getOutMessage();\n        if (out != null) {\n            getBackChannelConduit(message);\n            if (binding != null) {\n                out.put(MessageInfo.class, binding.getOperationInfo().getOutput());\n                out.put(BindingMessageInfo.class, binding.getOutput());\n// fix_end\n// fix_start\n\n            InterceptorChain outChain = out.getInterceptorChain();\n            if (outChain == null) {\n                outChain = OutgoingChainInterceptor.getChain(ex, chainCache);\n                out.setInterceptorChain(outChain);\n// fix_end\n// fix_start\n            outChain.doIntercept(out);\n// fix_end\n", "cwe": "CWE-399", "cwe_name": "Resource Management Errors", "idx": 51124}
{"source": "// bug_start\nprivate void cacheInput(Message outMessage) {\n        if (outMessage.getExchange() == null) {\n// bug_end\n             return;\n         }\n// bug_start\n        Message inMessage = outMessage.getExchange().getInMessage();\n        if (inMessage == null) {\n            return;\n        }\n        Collection<Attachment> atts = inMessage.getAttachments();\n        if (atts != null) {\n            for (Attachment a : atts) {\n                if (a.getDataHandler().getDataSource() instanceof AttachmentDataSource) {\n                    try {\n                        ((AttachmentDataSource)a.getDataHandler().getDataSource()).cache(inMessage);\n                    } catch (IOException e) {\n                        throw new Fault(e);\n                    }\n                }\n// bug_end\n             }\n// bug_start\n        }\n        DelegatingInputStream in = inMessage.getContent(DelegatingInputStream.class);\n        if (in != null) {\n            in.cacheInput();\n// bug_end\n         }\n     }\n \n", "target": "// fix_start\npublic void handleMessage(Message message) {\n        Exchange ex = message.getExchange();\n        BindingOperationInfo binding = ex.get(BindingOperationInfo.class);\n        if (null != binding && null != binding.getOperationInfo() && binding.getOperationInfo().isOneWay()) {\n            closeInput(message);\n// fix_end\n// fix_start\n        Message out = ex.getOutMessage();\n        if (out != null) {\n            getBackChannelConduit(message);\n            if (binding != null) {\n                out.put(MessageInfo.class, binding.getOperationInfo().getOutput());\n                out.put(BindingMessageInfo.class, binding.getOutput());\n// fix_end\n// fix_start\n\n            InterceptorChain outChain = out.getInterceptorChain();\n            if (outChain == null) {\n                outChain = OutgoingChainInterceptor.getChain(ex, chainCache);\n                out.setInterceptorChain(outChain);\n            }\n            outChain.doIntercept(out);\n// fix_end\n", "cwe": "CWE-399", "cwe_name": "Resource Management Errors", "idx": 52026}
{"source": " private void createIdentityZoneHelper(String id) throws Exception {\n         String identityClientWriteToken = testClient.getClientCredentialsOAuthAccessToken(\n             \"identity\",\n             \"identitysecret\",\n             \"zones.write\");\n \n         IdentityZone identityZone = new IdentityZone();\n         SamlConfig samlConfig = new SamlConfig();\n         samlConfig.setCertificate(SERVICE_PROVIDER_CERTIFICATE);\n         samlConfig.setPrivateKey(SERVICE_PROVIDER_KEY);\n         samlConfig.setPrivateKeyPassword(SERVICE_PROVIDER_KEY_PASSWORD);\n         samlConfig.setEntityID(SERVICE_PROVIDER_ID);\n         identityZone.getConfig().setSamlConfig(samlConfig);\n         identityZone.getConfig().setIssuer(DEFAULT_ISSUER_URI);\n// bug_start\n// bug_end\n         identityZone.setId(id);\n         identityZone.setSubdomain(StringUtils.hasText(id) ? id : new RandomValueStringGenerator().generate());\n         identityZone.setName(\"The Twiglet Zone\");\n \n         IdentityZoneConfiguration brandingConfig = setBranding(identityZone.getConfig());\n         identityZone.setConfig(brandingConfig);\n \n \n         getMockMvc().perform(\n             post(\"/identity-zones\")\n                 .header(\"Authorization\", \"Bearer \" + identityClientWriteToken)\n                 .contentType(APPLICATION_JSON)\n                 .content(JsonUtils.writeValueAsString(identityZone)))\n             .andExpect(status().is(HttpStatus.CREATED.value()));\n     }\n \n", "target": "// fix_start\n\n        TokenPolicy tokenPolicy = new TokenPolicy(3600, 7200);\n        tokenPolicy.setActiveKeyId(\"active-key-1\");\n        tokenPolicy.setKeys(new HashMap<>(Collections.singletonMap(\"active-key-1\", \"key\")));\n        identityZone.getConfig().setTokenPolicy(tokenPolicy);\n\n// fix_end\n", "cwe": "NVD-CWE-noinfo", "cwe_name": "", "idx": 109252}
{"source": " public void check(String hostname, List<Certificate> peerCertificates)\n       throws SSLPeerUnverifiedException {\n// bug_start\n// bug_end\n     if (trustRootIndex != null) {\n       peerCertificates = new CertificateChainCleaner(trustRootIndex).clean(peerCertificates);\n     }\n// bug_start\n\n    Set<ByteString> pins = findMatchingPins(hostname);\n\n    if (pins == null) return;\n// bug_end\n \n     for (int i = 0, size = peerCertificates.size(); i < size; i++) {\n       X509Certificate x509Certificate = (X509Certificate) peerCertificates.get(i);\n       if (pins.contains(sha1(x509Certificate))) return;\n     }\n \n     StringBuilder message = new StringBuilder()\n         .append(\"Certificate pinning failure!\")\n         .append(\"\\n  Peer certificate chain:\");\n     for (int i = 0, size = peerCertificates.size(); i < size; i++) {\n       X509Certificate x509Certificate = (X509Certificate) peerCertificates.get(i);\n       message.append(\"\\n    \").append(pin(x509Certificate))\n           .append(\": \").append(x509Certificate.getSubjectDN().getName());\n     }\n     message.append(\"\\n  Pinned certificates for \").append(hostname).append(\":\");\n     for (ByteString pin : pins) {\n       message.append(\"\\n    sha1/\").append(pin.base64());\n     }\n     throw new SSLPeerUnverifiedException(message.toString());\n   }\n \n", "target": "// fix_start\n    Set<ByteString> pins = findMatchingPins(hostname);\n\n    if (pins == null) return;\n\n// fix_end\n// fix_start\n// fix_end\n", "cwe": "CWE-295", "cwe_name": "Improper Certificate Validation", "idx": 40161}
{"source": " @GetMapping(\"/callback/{serverId}\")\n     @ApiOperation(value = \"OAuth2.0\u6388\u6743\u5b8c\u6210\u540e\u56de\u8c03\", hidden = true)\n     public RedirectView callback(@RequestParam(defaultValue = \"/\") String redirect,\n                                  @PathVariable String serverId,\n                                  @RequestParam String code,\n                                  @RequestParam String state,\n                                  HttpServletRequest request,\n                                  HttpSession session) throws UnsupportedEncodingException {\n         try {\n             String cachedState = (String) session.getAttribute(STATE_SESSION_KEY);\n// bug_start\n// bug_end\n             oAuth2RequestService.doEvent(serverId, new OAuth2CodeAuthBeforeEvent(code, state, request::getParameter));\n             return new RedirectView(URLDecoder.decode(redirect, \"UTF-8\"));\n         } finally {\n             session.removeAttribute(STATE_SESSION_KEY);\n         }\n     }\n \n", "target": "// fix_start\n            if (!state.equals(cachedState)) {\n                throw new BusinessException(ErrorType.STATE_ERROR.name());\n            }\n// fix_end\n", "cwe": "CWE-352", "cwe_name": "Cross-Site Request Forgery (CSRF)", "idx": 44793}
{"source": " public static View create(StaplerRequest req, StaplerResponse rsp, ViewGroup owner)\n             throws FormException, IOException, ServletException {\n         String mode = req.getParameter(\"mode\");\n \n         String requestContentType = req.getContentType();\n         if (requestContentType == null\n                 && !(mode != null && mode.equals(\"copy\")))\n             throw new Failure(\"No Content-Type header set\");\n \n         boolean isXmlSubmission = requestContentType != null\n                 && (requestContentType.startsWith(\"application/xml\")\n                         || requestContentType.startsWith(\"text/xml\"));\n \n         String name = req.getParameter(\"name\");\n         Jenkins.checkGoodName(name);\n         if(owner.getView(name)!=null)\n             throw new Failure(Messages.Hudson_ViewAlreadyExists(name));\n \n         if (mode==null || mode.length()==0) {\n             if(isXmlSubmission) {\n                 View v = createViewFromXML(name, req.getInputStream());\n                 owner.getACL().checkCreatePermission(owner, v.getDescriptor());\n                 v.owner = owner;\n                 rsp.setStatus(HttpServletResponse.SC_OK);\n                 return v;\n             } else\n                 throw new Failure(Messages.View_MissingMode());\n         }\n \n         View v;\n         if (\"copy\".equals(mode)) {\n             v = copy(req, owner, name);\n         } else {\n             ViewDescriptor descriptor = all().findByName(mode);\n             if (descriptor == null) {\n                 throw new Failure(\"No view type \u2018\" + mode + \"\u2019 is known\");\n             }\n \n// bug_start\n            v = descriptor.newInstance(req,req.getSubmittedForm());\n// bug_end\n         }\n         owner.getACL().checkCreatePermission(owner, v.getDescriptor());\n         v.owner = owner;\n \n         rsp.sendRedirect2(req.getContextPath()+'/'+v.getUrl()+v.getPostConstructLandingPage());\n \n         return v;\n     }\n \n", "target": "// fix_start\n            JSONObject submittedForm = req.getSubmittedForm();\n            submittedForm.put(\"name\", name);\n            v = descriptor.newInstance(req, submittedForm);\n// fix_end\n", "cwe": "CWE-240", "cwe_name": "", "idx": 28983}
{"source": " public static HttpURLConnection getURLConnection(String url)\n       throws IOException {\n// bug_start\n    URLConnection conn = new URL(url).openConnection();\n    final HttpURLConnection httpConn = (HttpURLConnection) conn;\n\n    if (httpConn instanceof HttpsURLConnection) {\n      HttpsURLConnection httpsConn = (HttpsURLConnection) httpConn;\n      httpsConn.setSSLSocketFactory(\n          TrustAllSslSocketFactory.createSSLSocketFactory());\n      httpsConn.setHostnameVerifier((arg0, arg1) -> true);\n    }\n\n    return httpConn;\n// bug_end\n   }\n \n", "target": "// fix_start\n    return (HttpURLConnection) new URL(url).openConnection();\n// fix_end\n", "cwe": "CWE-295", "cwe_name": "Improper Certificate Validation", "idx": 40030}
{"source": " public static Path getDataFilePath(String pi, String dataFolderName, String altDataFolderName, String fileName)\n             throws PresentationException, IndexUnreachableException {\n// bug_start\n// bug_end\n         java.nio.file.Path dataFolderPath = getDataFolder(pi, dataFolderName);\n         if (StringUtils.isNotBlank(fileName)) {\n             dataFolderPath = dataFolderPath.resolve(fileName);\n         }\n         if (StringUtils.isNotBlank(altDataFolderName) && !Files.exists(dataFolderPath)) {\n             return getDataFilePath(pi, altDataFolderName, null, fileName);\n         }\n \n         return dataFolderPath;\n     }\n \n", "target": "// fix_start\n        fileName = Paths.get(fileName).getFileName().toString();\n// fix_end\n", "cwe": "CWE-22", "cwe_name": "Path Traversal", "idx": 21853}
{"source": "// bug_start\npublic Stream<CompilerInput> finalize(URI remoteURI, PackageID moduleID) {\n        try {\n            Matcher matcher = semVerPatchPattern.matcher(moduleID.version.value);\n            if (\"\".equals(moduleID.version.value) || \"*\".equals(moduleID.version.value) || matcher.matches()) {\n                HttpURLConnection conn;\n                if (null == this.proxy) {\n                    conn = (HttpURLConnection) remoteURI.toURL().openConnection();\n// bug_end\n                 } else {\n// bug_start\n                    conn = (HttpURLConnection) remoteURI.toURL().openConnection(this.proxy);\n// bug_end\n                 }\n// bug_start\n                conn.setInstanceFollowRedirects(false);\n                conn.setRequestMethod(\"GET\");\n\n                int statusCode = conn.getResponseCode();\n                if (statusCode == 200) {\n                    try (BufferedReader reader = new BufferedReader(new InputStreamReader(conn.getInputStream(),\n                            Charset.defaultCharset()))) {\n                        StringBuilder result = new StringBuilder();\n                        String line;\n                        while ((line = reader.readLine()) != null) {\n                            result.append(line);\n                        }\n                        Object payload = JSONParser.parse(result.toString());\n                        if (payload instanceof MapValue) {\n                            MapValue moduleInfo = ((MapValue) payload).getMapValue(\"module\");\n                            String version = moduleInfo.getStringValue(\"version\");\n                            moduleID.version = new Name(version);\n                        }\n                    }\n                } else if (statusCode == 400 && !loggedError) {\n                    try (BufferedReader errorStream = new BufferedReader(\n                            new InputStreamReader(conn.getInputStream(), Charset.defaultCharset()))) {\n                        String errorContent = errorStream.lines().collect(Collectors.joining(\"\\n\"));\n                        this.errStream.println(\"error: could not connect to remote repository to find the latest \" +\n                                \"version of module: \" + moduleID.toString() + \". use '--offline' \" +\n                                \"flag to build in offline mode. reason: \" + errorContent);\n                        setErrorLoggedStatusAsTrue();\n                    }\n                } else if (statusCode == 500 && !loggedError) {\n                    this.errStream.println(\"error: could not connect to remote repository to find the latest \" +\n                            \"version of module: \" + moduleID.toString() + \". use '--offline' \" +\n                            \"flag to build in offline mode.\");\n                    setErrorLoggedStatusAsTrue();\n                }\n                conn.disconnect();\n                Authenticator.setDefault(null);\n// bug_end\n             }\n// bug_start\n        } catch (IOException e) {\n// bug_end\n         }\n// bug_start\n\n        return Stream.empty();\n// bug_end\n     }\n \n", "target": "// fix_start\n@Test(description = \"Test pullCount of a package from central\", dependsOnMethods = \"testPull\", enabled = false)\n    public void testPullCount() throws IOException {\n        String url = RepoUtils.getRemoteRepoURL() + \"/modules/info/\" + orgName + \"/\" + moduleName + \"/*/\";\n        HttpsURLConnection conn = createHttpsUrlConnection(convertToUrl(url), \"\", 0, \"\", \"\");\n        conn.setInstanceFollowRedirects(false);\n        setRequestMethod(conn, Utils.RequestMethod.GET);\n\n        int statusCode = conn.getResponseCode();\n        if (statusCode == 200) {\n            try (BufferedReader reader = new BufferedReader(new InputStreamReader(conn.getInputStream(),\n                    Charset.defaultCharset()))) {\n                StringBuilder result = new StringBuilder();\n                String line;\n                while ((line = reader.readLine()) != null) {\n                    result.append(line);\n                }\n                Object payload = JSONParser.parse(result.toString());\n                if (payload instanceof MapValue) {\n                    long pullCount = ((MapValue) payload).getIntValue(\"totalPullCount\");\n                    Assert.assertEquals(pullCount, totalPullCount);\n// fix_end\n// fix_start\n                    Assert.fail(\"error: invalid response received\");\n// fix_end\n// fix_start\n// fix_end\n// fix_start\n        } else {\n            Assert.fail(\"error: could not connect to remote repository to find the latest version of module\");\n// fix_end\n// fix_start\n// fix_end\n", "cwe": "CWE-306", "cwe_name": "", "idx": 41164}
{"source": "// bug_start\n@Test(description = \"Test pullCount of a package from central\", dependsOnMethods = \"testPull\", enabled = false)\n    public void testPullCount() throws IOException {\n        initializeSsl();\n        String url = RepoUtils.getRemoteRepoURL() + \"/modules/info/\" + orgName + \"/\" + moduleName + \"/*/\";\n        HttpURLConnection conn = createHttpUrlConnection(convertToUrl(url), \"\", 0, \"\", \"\");\n        conn.setInstanceFollowRedirects(false);\n        setRequestMethod(conn, Utils.RequestMethod.GET);\n// bug_end\n \n// bug_start\n        int statusCode = conn.getResponseCode();\n        if (statusCode == 200) {\n            try (BufferedReader reader = new BufferedReader(new InputStreamReader(conn.getInputStream(),\n                    Charset.defaultCharset()))) {\n                StringBuilder result = new StringBuilder();\n                String line;\n                while ((line = reader.readLine()) != null) {\n                    result.append(line);\n// bug_end\n                 }\n// bug_start\n                Object payload = JSONParser.parse(result.toString());\n                if (payload instanceof MapValue) {\n                    long pullCount = ((MapValue) payload).getIntValue(\"totalPullCount\");\n                    Assert.assertEquals(pullCount, totalPullCount);\n                } else {\n                    Assert.fail(\"error: invalid response received\");\n                }\n// bug_end\n             }\n// bug_start\n        } else {\n            Assert.fail(\"error: could not connect to remote repository to find the latest version of module\");\n// bug_end\n         }\n// bug_start\n// bug_end\n     }\n \n", "target": "// fix_start\npublic Stream<CompilerInput> finalize(URI remoteURI, PackageID moduleID) {\n        try {\n            Matcher matcher = semVerPatchPattern.matcher(moduleID.version.value);\n            if (\"\".equals(moduleID.version.value) || \"*\".equals(moduleID.version.value) || matcher.matches()) {\n                HttpsURLConnection conn;\n                if (null == this.proxy) {\n                    conn = (HttpsURLConnection) remoteURI.toURL().openConnection();\n                } else {\n                    conn = (HttpsURLConnection) remoteURI.toURL().openConnection(this.proxy);\n                }\n                conn.setInstanceFollowRedirects(false);\n                conn.setRequestMethod(\"GET\");\n// fix_end\n// fix_start\n                int statusCode = conn.getResponseCode();\n                if (statusCode == 200) {\n                    try (BufferedReader reader = new BufferedReader(new InputStreamReader(conn.getInputStream(),\n                            Charset.defaultCharset()))) {\n                        StringBuilder result = new StringBuilder();\n                        String line;\n                        while ((line = reader.readLine()) != null) {\n                            result.append(line);\n                        }\n                        Object payload = JSONParser.parse(result.toString());\n                        if (payload instanceof MapValue) {\n                            MapValue moduleInfo = ((MapValue) payload).getMapValue(\"module\");\n                            String version = moduleInfo.getStringValue(\"version\");\n                            moduleID.version = new Name(version);\n                        }\n                    }\n                } else if (statusCode == 400 && !loggedError) {\n                    try (BufferedReader errorStream = new BufferedReader(\n                            new InputStreamReader(conn.getInputStream(), Charset.defaultCharset()))) {\n                        String errorContent = errorStream.lines().collect(Collectors.joining(\"\\n\"));\n                        this.errStream.println(\"error: could not connect to remote repository to find the latest \" +\n                                \"version of module: \" + moduleID.toString() + \". use '--offline' \" +\n                                \"flag to build in offline mode. reason: \" + errorContent);\n                        setErrorLoggedStatusAsTrue();\n                    }\n                } else if (statusCode == 500 && !loggedError) {\n                    this.errStream.println(\"error: could not connect to remote repository to find the latest \" +\n                            \"version of module: \" + moduleID.toString() + \". use '--offline' \" +\n                            \"flag to build in offline mode.\");\n                    setErrorLoggedStatusAsTrue();\n// fix_end\n// fix_start\n                conn.disconnect();\n                Authenticator.setDefault(null);\n// fix_end\n// fix_start\n        } catch (IOException e) {\n// fix_end\n// fix_start\n\n        return Stream.empty();\n// fix_end\n", "cwe": "CWE-306", "cwe_name": "", "idx": 41223}
{"source": " @Override\n     public Collection<FileAnnotation> parse(final InputStream file, final String moduleName)\n             throws InvocationTargetException {\n         try {\n// bug_start\n            Digester digester = new Digester();\n            digester.setValidating(false);\n            digester.setClassLoader(LintParser.class.getClassLoader());\n// bug_end\n \n             List<LintIssue> issues = new ArrayList<LintIssue>();\n             digester.push(issues);\n \n             String issueXPath = \"issues/issue\";\n             digester.addObjectCreate(issueXPath, LintIssue.class);\n             digester.addSetProperties(issueXPath);\n             digester.addSetNext(issueXPath, \"add\");\n \n             String locationXPath = issueXPath + \"/location\";\n             digester.addObjectCreate(locationXPath, Location.class);\n             digester.addSetProperties(locationXPath);\n             digester.addSetNext(locationXPath, \"addLocation\", Location.class.getName());\n \n             digester.parse(file);\n \n             return convert(issues, moduleName);\n// bug_start\n        } catch (IOException exception) {\n            throw new InvocationTargetException(exception);\n        } catch (SAXException exception) {\n// bug_end\n             throw new InvocationTargetException(exception);\n         }\n     }\n \n", "target": "// fix_start\n            SecureDigester digester = new SecureDigester(LintParser.class);\n// fix_end\n// fix_start\n        } catch (IOException | SAXException exception) {\n// fix_end\n", "cwe": "CWE-611", "cwe_name": "Improper Restriction of XML External Entity Reference ('XXE')", "idx": 69583}
{"source": " private static void processHeaderConfig(MultivaluedMap<String, String> httpHeaders, Object object, String key, String prefix) {\n \n         try {\n             String property = StringUtils.removeStart(key, prefix);\n// bug_start\n// bug_end\n             String setter = property;\n             setter = \"set\"+setter.substring(0,1).toUpperCase(Locale.US)+setter.substring(1);\n// bug_start\n            Field field = object.getClass().getDeclaredField(StringUtils.uncapitalize(property));\n// bug_end\n             Class clazz = String.class;\n// bug_start\n\n            if (field.getType() == int.class) {\n                clazz = int.class;\n            } else if (field.getType() == double.class) {\n                clazz = double.class;\n            } else if (field.getType() == boolean.class) {\n                clazz = boolean.class;\n// bug_end\n             }\n \n             Method m = tryToGetMethod(object, setter, clazz);\n             if (m == null && clazz != String.class) {\n                 m = tryToGetMethod(object, setter, String.class);\n             }\n \n             if (m != null) {\n                 String val = httpHeaders.getFirst(key);\n                 val = val.trim();\n                 if (clazz == String.class) {\n                     checkTrustWorthy(setter, val);\n                     m.invoke(object, val);\n                 } else if (clazz == int.class) {\n                     m.invoke(object, Integer.parseInt(val));\n                 } else if (clazz == double.class) {\n                     m.invoke(object, Double.parseDouble(val));\n                 } else if (clazz == boolean.class) {\n                     m.invoke(object, Boolean.parseBoolean(val));\n                 } else {\n                     throw new IllegalArgumentException(\"setter must be String, int, double or boolean...for now\");\n                 }\n             } else {\n                 throw new NoSuchMethodException(\"Couldn't find: \"+setter);\n             }\n \n         } catch (Throwable ex) {\n             throw new WebApplicationException(String.format(Locale.ROOT,\n                     \"%s is an invalid %s header\", key, X_TIKA_OCR_HEADER_PREFIX));\n         }\n     }\n \n", "target": "// fix_start\n            Field field = null;\n            try {\n                object.getClass().getDeclaredField(StringUtils.uncapitalize(property));\n            } catch (NoSuchFieldException e) {\n            }\n// fix_end\n// fix_start\n// fix_end\n// fix_start\n            if (field != null) {\n                if (field.getType() == int.class) {\n                    clazz = int.class;\n                } else if (field.getType() == double.class) {\n                    clazz = double.class;\n                } else if (field.getType() == boolean.class) {\n                    clazz = boolean.class;\n                }\n// fix_end\n", "cwe": "NVD-CWE-noinfo", "cwe_name": "", "idx": 109068}
{"source": " @SuppressWarnings(\"ACL.impersonate\")\n     private void loginAndTakeBack(StaplerRequest req, StaplerResponse rsp, User u) throws ServletException, IOException {\n// bug_start\n// bug_end\n         Authentication a = new UsernamePasswordAuthenticationToken(u.getId(),req.getParameter(\"password1\"));\n         a = this.getSecurityComponents().manager.authenticate(a);\n         SecurityContextHolder.getContext().setAuthentication(a);\n \n         req.getView(this,\"success.jelly\").forward(req,rsp);\n     }\n \n", "target": "// fix_start\n        HttpSession session = req.getSession(false);\n        if (session != null) {\n            session.invalidate();\n        }\n        req.getSession(true);\n\n// fix_end\n", "cwe": "CWE-384", "cwe_name": "", "idx": 50103}
{"source": " public static String[] getCNs(final X509Certificate cert) {\n// bug_start\n        final LinkedList<String> cnList = new LinkedList<String>();\n\n// bug_end\n         final String subjectPrincipal = cert.getSubjectX500Principal().toString();\n// bug_start\n        final StringTokenizer st = new StringTokenizer(subjectPrincipal, \",+\");\n        while(st.hasMoreTokens()) {\n            final String tok = st.nextToken().trim();\n            if (tok.length() > 3) {\n                if (tok.substring(0, 3).equalsIgnoreCase(\"CN=\")) {\n                    cnList.add(tok.substring(3));\n                }\n            }\n        }\n        if(!cnList.isEmpty()) {\n            final String[] cns = new String[cnList.size()];\n            cnList.toArray(cns);\n            return cns;\n        } else {\n// bug_end\n             return null;\n         }\n     }\n \n", "target": "// fix_start\n// fix_end\n// fix_start\n        try {\n            return extractCNs(subjectPrincipal);\n        } catch (SSLException ex) {\n// fix_end\n", "cwe": "NVD-CWE-Other", "cwe_name": "Other", "idx": 110851}
{"source": "// bug_start\npublic void list(HttpServletRequest request,\n                     HttpServletResponse response,\n                     String message) throws IOException {\n// bug_end\n \n// bug_start\n        PrintWriter writer = response.getWriter();\n// bug_end\n \n// bug_start\n        writer.print(Constants.HTML_HEADER_SECTION);\n// bug_end\n \n// bug_start\n        Object[] args = new Object[2];\n        args[0] = request.getContextPath();\n        args[1] = sm.getString(\"htmlHostManagerServlet.title\");\n        writer.print(MessageFormat.format\n                     (Constants.BODY_HEADER_SECTION, args));\n// bug_end\n \n// bug_start\n        args = new Object[3];\n        args[0] = sm.getString(\"htmlHostManagerServlet.messageLabel\");\n        if (message == null || message.length() == 0) {\n            args[1] = \"OK\";\n        } else {\n            args[1] = RequestUtil.filter(message);\n        }\n        writer.print(MessageFormat.format(Constants.MESSAGE_SECTION, args));\n// bug_end\n \n// bug_start\n        args = new Object[9];\n        args[0] = sm.getString(\"htmlHostManagerServlet.manager\");\n        args[1] = response.encodeURL(request.getContextPath() + \"/html/list\");\n        args[2] = sm.getString(\"htmlHostManagerServlet.list\");\n        args[3] = response.encodeURL\n            (request.getContextPath() + \"/\" +\n             sm.getString(\"htmlHostManagerServlet.helpHtmlManagerFile\"));\n        args[4] = sm.getString(\"htmlHostManagerServlet.helpHtmlManager\");\n        args[5] = response.encodeURL\n            (request.getContextPath() + \"/\" +\n             sm.getString(\"htmlHostManagerServlet.helpManagerFile\"));\n        args[6] = sm.getString(\"htmlHostManagerServlet.helpManager\");\n        args[7] = response.encodeURL(\"/manager/status\");\n        args[8] = sm.getString(\"statusServlet.title\");\n        writer.print(MessageFormat.format(Constants.MANAGER_SECTION, args));\n\n        args = new Object[3];\n        args[0] = sm.getString(\"htmlHostManagerServlet.hostName\");\n        args[1] = sm.getString(\"htmlHostManagerServlet.hostAliases\");\n        args[2] = sm.getString(\"htmlHostManagerServlet.hostTasks\");\n        writer.print(MessageFormat.format(HOSTS_HEADER_SECTION, args));\n\n        Container[] children = engine.findChildren();\n        String hostNames[] = new String[children.length];\n        for (int i = 0; i < children.length; i++)\n            hostNames[i] = children[i].getName();\n\n        TreeMap sortedHostNamesMap = new TreeMap();\n\n        for (int i = 0; i < hostNames.length; i++) {\n            String displayPath = hostNames[i];\n            sortedHostNamesMap.put(displayPath, hostNames[i]);\n        }\n\n        String hostsStart = sm.getString(\"htmlHostManagerServlet.hostsStart\");\n        String hostsStop = sm.getString(\"htmlHostManagerServlet.hostsStop\");\n        String hostsRemove = sm.getString(\"htmlHostManagerServlet.hostsRemove\");\n\n        Iterator iterator = sortedHostNamesMap.entrySet().iterator();\n        while (iterator.hasNext()) {\n            Map.Entry entry = (Map.Entry) iterator.next();\n            String hostName = (String) entry.getKey();\n            Host host = (Host) engine.findChild(hostName);\n\n            if (host != null ) {\n                args = new Object[2];\n                args[0] = hostName;\n                String[] aliases = host.findAliases();\n                StringBuffer buf = new StringBuffer();\n                if (aliases.length > 0) {\n                    buf.append(aliases[0]);\n                    for (int j = 1; j < aliases.length; j++) {\n                        buf.append(\", \").append(aliases[j]);\n                    }\n                }\n\n                if (buf.length() == 0) {\n                    buf.append(\"&nbsp;\");\n                }\n\n                args[1] = buf.toString();\n                writer.print\n                    (MessageFormat.format(HOSTS_ROW_DETAILS_SECTION, args));\n\n                args = new Object[7];\n                args[0] = response.encodeURL\n                    (request.getContextPath() +\n                     \"/html/start?name=\" + hostName);\n                args[1] = hostsStart;\n                args[2] = response.encodeURL\n                    (request.getContextPath() +\n                     \"/html/stop?name=\" + hostName);\n                args[3] = hostsStop;\n                args[4] = response.encodeURL\n                    (request.getContextPath() +\n                     \"/html/remove?name=\" + hostName);\n                args[5] = hostsRemove;\n                args[6] = hostName;\n                if (host == this.host) {\n                    writer.print(MessageFormat.format(\n                        MANAGER_HOST_ROW_BUTTON_SECTION, args));\n                } else {\n                    writer.print(MessageFormat.format(\n                        HOSTS_ROW_BUTTON_SECTION, args));\n                }\n\n// bug_end\n             }\n         }\n// bug_start\n\n        args = new Object[6];\n        args[0] = sm.getString(\"htmlHostManagerServlet.addTitle\");\n        args[1] = sm.getString(\"htmlHostManagerServlet.addHost\");\n        args[2] = response.encodeURL(request.getContextPath() + \"/html/add\");\n        args[3] = sm.getString(\"htmlHostManagerServlet.addName\");\n        args[4] = sm.getString(\"htmlHostManagerServlet.addAliases\");\n        args[5] = sm.getString(\"htmlHostManagerServlet.addAppBase\");\n        writer.print(MessageFormat.format(ADD_SECTION_START, args));\n\n        args = new Object[3];\n        args[0] = sm.getString(\"htmlHostManagerServlet.addAutoDeploy\");\n        args[1] = \"autoDeploy\";\n        args[2] = \"checked\";\n        writer.print(MessageFormat.format(ADD_SECTION_BOOLEAN, args));\n        args[0] = sm.getString(\"htmlHostManagerServlet.addDeployOnStartup\");\n        args[1] = \"deployOnStartup\";\n        args[2] = \"checked\";\n        writer.print(MessageFormat.format(ADD_SECTION_BOOLEAN, args));\n        args[0] = sm.getString(\"htmlHostManagerServlet.addDeployXML\");\n        args[1] = \"deployXML\";\n        args[2] = \"checked\";\n        writer.print(MessageFormat.format(ADD_SECTION_BOOLEAN, args));\n        args[0] = sm.getString(\"htmlHostManagerServlet.addUnpackWARs\");\n        args[1] = \"unpackWARs\";\n        args[2] = \"checked\";\n        writer.print(MessageFormat.format(ADD_SECTION_BOOLEAN, args));\n        args[0] = sm.getString(\"htmlHostManagerServlet.addXmlNamespaceAware\");\n        args[1] = \"xmlNamespaceAware\";\n        args[2] = \"\";\n        writer.print(MessageFormat.format(ADD_SECTION_BOOLEAN, args));\n        args[0] = sm.getString(\"htmlHostManagerServlet.addXmlValidation\");\n        args[1] = \"xmlValidation\";\n        args[2] = \"\";\n        writer.print(MessageFormat.format(ADD_SECTION_BOOLEAN, args));\n\n        args[0] = sm.getString(\"htmlHostManagerServlet.addManager\");\n        args[1] = \"manager\";\n        args[2] = \"checked\";\n        writer.print(MessageFormat.format(ADD_SECTION_BOOLEAN, args));\n\n        args = new Object[1];\n        args[0] = sm.getString(\"htmlHostManagerServlet.addButton\");\n        writer.print(MessageFormat.format(ADD_SECTION_END, args));\n\n        args = new Object[7];\n        args[0] = sm.getString(\"htmlHostManagerServlet.serverTitle\");\n        args[1] = sm.getString(\"htmlHostManagerServlet.serverVersion\");\n        args[2] = sm.getString(\"htmlHostManagerServlet.serverJVMVersion\");\n        args[3] = sm.getString(\"htmlHostManagerServlet.serverJVMVendor\");\n        args[4] = sm.getString(\"htmlHostManagerServlet.serverOSName\");\n        args[5] = sm.getString(\"htmlHostManagerServlet.serverOSVersion\");\n        args[6] = sm.getString(\"htmlHostManagerServlet.serverOSArch\");\n        writer.print(MessageFormat.format\n                     (Constants.SERVER_HEADER_SECTION, args));\n\n        args = new Object[6];\n        args[0] = ServerInfo.getServerInfo();\n        args[1] = System.getProperty(\"java.runtime.version\");\n        args[2] = System.getProperty(\"java.vm.vendor\");\n        args[3] = System.getProperty(\"os.name\");\n        args[4] = System.getProperty(\"os.version\");\n        args[5] = System.getProperty(\"os.arch\");\n        writer.print(MessageFormat.format(Constants.SERVER_ROW_SECTION, args));\n\n        writer.print(Constants.HTML_TAIL_SECTION);\n\n        writer.flush();\n        writer.close();\n// bug_end\n     }\n \n", "target": "// fix_start\nprotected void sendWindowHandlerHtml(ExternalContext externalContext, String windowId)\n    {\n        HttpServletResponse httpResponse = (HttpServletResponse) externalContext.getResponse();\n// fix_end\n// fix_start\n        try\n        {\n            httpResponse.setStatus(HttpServletResponse.SC_OK);\n            httpResponse.setContentType(\"text/html\");\n// fix_end\n// fix_start\n            String windowHandlerHtml = clientWindowConfig.getClientWindowHtml();\n// fix_end\n// fix_start\n            if (windowId == null)\n            {\n                windowId = UNINITIALIZED_WINDOW_ID_VALUE;\n            }\n// fix_end\n// fix_start\n            windowHandlerHtml = windowHandlerHtml.replace(WINDOW_ID_REPLACE_PATTERN,\n                    windowId);\n            windowHandlerHtml = windowHandlerHtml.replace(REQUEST_URL_REPLACE_PATTERN,\n                    ClientWindowHelper.constructRequestUrl(externalContext));\n            windowHandlerHtml =\n                    windowHandlerHtml.replace(NOSCRIPT_URL_REPLACE_PATTERN, getNoscriptUrl(externalContext));\n// fix_end\n// fix_start\n            OutputStream os = httpResponse.getOutputStream();\n            try\n            {\n                os.write(windowHandlerHtml.getBytes());\n            }\n            finally\n            {\n                os.close();\n// fix_end\n// fix_start\n        catch (IOException ioe)\n        {\n            throw new FacesException(ioe);\n        }\n// fix_end\n", "cwe": "CWE-79", "cwe_name": "Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')", "idx": 79274}
{"source": "// bug_start\npublic URL getURL() throws MalformedURLException {\n            String name = fileName;\n            if (name.equals(\"hudson-cli.jar\"))  name=\"jenkins-cli.jar\";\n// bug_end\n \n// bug_start\n            if (name.contains(\"..\")) {\n                throw new MalformedURLException(\"The specified file path \" + fileName + \" contains '..'. \"\n                        + \"The path is not allowed due to security reasons\");\n// bug_end\n             }\n \n// bug_start\n            URL res = Jenkins.getInstance().servletContext.getResource(\"/WEB-INF/\" + name);\n            if(res==null) {\n                res = new URL(new File(\".\").getAbsoluteFile().toURI().toURL(),\"target/jenkins/WEB-INF/\"+name);\n// bug_end\n             }\n// bug_start\n            return res;\n// bug_end\n         }\n// bug_start\n// bug_end\n \n", "target": "// fix_start\nprotected void sendWindowHandlerHtml(ExternalContext externalContext, String windowId)\n    {\n        HttpServletResponse httpResponse = (HttpServletResponse) externalContext.getResponse();\n// fix_end\n// fix_start\n        try\n        {\n            httpResponse.setStatus(HttpServletResponse.SC_OK);\n            httpResponse.setContentType(\"text/html\");\n\n            String windowHandlerHtml = clientWindowConfig.getClientWindowHtml();\n\n            if (windowId == null)\n            {\n                windowId = UNINITIALIZED_WINDOW_ID_VALUE;\n// fix_end\n// fix_start\n            windowHandlerHtml = windowHandlerHtml.replace(WINDOW_ID_REPLACE_PATTERN,\n                                                          org.owasp.encoder.Encode.forJavaScriptBlock(windowId));\n            windowHandlerHtml = windowHandlerHtml.replace(REQUEST_URL_REPLACE_PATTERN,\n                                                          org.owasp.encoder.Encode.forJavaScriptBlock(\n                                                              ClientWindowHelper.constructRequestUrl(externalContext)));\n            windowHandlerHtml =\n                windowHandlerHtml.replace(NOSCRIPT_URL_REPLACE_PATTERN,\n                                          org.owasp.encoder.Encode.forHtmlAttribute(getNoscriptUrl(externalContext)));\n\n            OutputStream os = httpResponse.getOutputStream();\n            try\n            {\n                os.write(windowHandlerHtml.getBytes());\n// fix_end\n// fix_start\n            finally\n            {\n                os.close();\n            }\n// fix_end\n// fix_start\n        catch (IOException ioe)\n        {\n            throw new FacesException(ioe);\n        }\n    }\n// fix_end\n", "cwe": "CWE-74", "cwe_name": "Improper Neutralization of Special Elements in Output Used by a Downstream Component ('Injection')", "idx": 73319}
{"source": "// bug_start\npublic URL getURL() throws MalformedURLException {\n            String name = fileName;\n            if (name.equals(\"hudson-cli.jar\"))  name=\"jenkins-cli.jar\";\n            URL res = Jenkins.getInstance().servletContext.getResource(\"/WEB-INF/\" + name);\n            if(res==null) {\n                res = new URL(new File(\".\").getAbsoluteFile().toURI().toURL(),\"target/jenkins/WEB-INF/\"+name);\n// bug_end\n             }\n// bug_start\n            return res;\n// bug_end\n         }\n \n", "target": "// fix_start\n@RequirePOST\n        public FormValidation doCheckCredentialsId(StaplerRequest req, @AncestorInPath Item context, @QueryParameter String remoteBase, @QueryParameter String value) {\n            if (context == null && !Jenkins.get().hasPermission(Jenkins.ADMINISTER) ||\n                context != null && !context.hasPermission(CredentialsProvider.USE_ITEM)) {\n                return FormValidation.ok();\n// fix_end\n// fix_start\n\n            String url = Util.fixEmptyAndTrim(remoteBase);\n            if (url == null)\n                return FormValidation.ok();\n\n            if(!URL_PATTERN.matcher(url).matches())\n                return FormValidation.ok();\n\n            try {\n                String urlWithoutRevision = SvnHelper.getUrlWithoutRevision(url);\n\n                SVNURL repoURL = SVNURL.parseURIDecoded(urlWithoutRevision);\n\n                StandardCredentials credentials = value == null ? null :\n                        CredentialsMatchers.firstOrNull(CredentialsProvider\n                                .lookupCredentials(StandardCredentials.class, context, ACL.SYSTEM,\n                                        URIRequirementBuilder.fromUri(repoURL.toString()).build()),\n                                CredentialsMatchers.withId(value));\n                if (checkRepositoryPath(repoURL, credentials)!=SVNNodeKind.NONE) {\n\n                    SVNRevision revision = getRevisionFromRemoteUrl(url);\n                    if (revision != null && !revision.isValid()) {\n                        return FormValidation.errorWithMarkup(\n                                hudson.scm.subversion.Messages.SubversionSCM_doCheckRemote_invalidRevision());\n                    }\n\n                    return FormValidation.ok();\n                }\n\n                SVNRepository repository = null;\n                try {\n                    repository = getRepository(repoURL, credentials,\n                            Collections.emptyMap(), null);\n                    long rev = repository.getLatestRevision();\n                    String repoPath = getRelativePath(repoURL, repository);\n                    String p = repoPath;\n                    while(p.length()>0) {\n                        p = SVNPathUtil.removeTail(p);\n                        if(repository.checkPath(p,rev)==SVNNodeKind.DIR) {\n                            List<SVNDirEntry> entries = new ArrayList<>();\n                            repository.getDir(p,rev,false,entries);\n\n                            List<String> paths = new ArrayList<>();\n                            for (SVNDirEntry e : entries)\n                                if(e.getKind()==SVNNodeKind.DIR)\n                                    paths.add(e.getName());\n\n                            String head = SVNPathUtil.head(repoPath.substring(p.length() + 1));\n                            String candidate = EditDistance.findNearest(head, paths);\n\n                            return FormValidation.error(\n                                hudson.scm.subversion.Messages.SubversionSCM_doCheckRemote_badPathSuggest(p, head,\n                                        candidate != null ? \"/\" + candidate : \"\"));\n                        }\n                    }\n\n                    return FormValidation.error(\n                        hudson.scm.subversion.Messages.SubversionSCM_doCheckRemote_badPath(repoPath));\n                } finally {\n                    if (repository != null)\n                        repository.closeSession();\n                }\n            } catch (SVNException e) {\n                LOGGER.log(Level.INFO, \"Failed to access subversion repository \"+url,e);\n                String message = hudson.scm.subversion.Messages.SubversionSCM_doCheckRemote_exceptionMsg1(\n                        Util.escape(url), Util.escape(e.getErrorMessage().getFullMessage()),\n                        \"javascript:document.getElementById('svnerror').style.display='block';\"\n                                + \"document.getElementById('svnerrorlink').style.display='none';\"\n                                + \"return false;\")\n                  + \"<br/><pre id=\\\"svnerror\\\" style=\\\"display:none\\\">\"\n                  + Functions.printThrowable(e) + \"</pre>\";\n                return FormValidation.errorWithMarkup(message);\n            }\n// fix_end\n", "cwe": "CWE-22", "cwe_name": "Path Traversal", "idx": 21445}
{"source": "// bug_start\nprivate void close() {\n        connectionState.set(ConnectionState.CLOSED);\n        for (Stream stream : streams.values()) {\n            stream.receiveReset(Http2Error.CANCEL.getCode());\n// bug_end\n         }\n// bug_start\n        try {\n            socketWrapper.close();\n        } catch (IOException ioe) {\n            log.debug(sm.getString(\"upgradeHandler.socketCloseFailed\"), ioe);\n        }\n    }\n// bug_end\n \n", "target": "// fix_start\n@RequirePOST\n        public FormValidation doCheckCredentialsId(StaplerRequest req, @AncestorInPath Item context, @QueryParameter String remoteBase, @QueryParameter String value) {\n            if (context == null && !Jenkins.get().hasPermission(Jenkins.ADMINISTER) ||\n                context != null && !context.hasPermission(CredentialsProvider.USE_ITEM)) {\n                return FormValidation.ok();\n            }\n\n            String url = Util.fixEmptyAndTrim(remoteBase);\n            if (url == null)\n                return FormValidation.ok();\n\n            if(!URL_PATTERN.matcher(url).matches())\n                return FormValidation.ok();\n\n            try {\n                String urlWithoutRevision = SvnHelper.getUrlWithoutRevision(url);\n\n                SVNURL repoURL = SVNURL.parseURIDecoded(urlWithoutRevision);\n\n                StandardCredentials credentials = value == null ? null :\n                        CredentialsMatchers.firstOrNull(CredentialsProvider\n                                .lookupCredentials(StandardCredentials.class, context, ACL.SYSTEM,\n                                        URIRequirementBuilder.fromUri(repoURL.toString()).build()),\n                                CredentialsMatchers.withId(value));\n                if (checkRepositoryPath(repoURL, credentials)!=SVNNodeKind.NONE) {\n\n                    SVNRevision revision = getRevisionFromRemoteUrl(url);\n                    if (revision != null && !revision.isValid()) {\n                        return FormValidation.errorWithMarkup(\n                                hudson.scm.subversion.Messages.SubversionSCM_doCheckRemote_invalidRevision());\n                    }\n\n                    return FormValidation.ok();\n                }\n\n                SVNRepository repository = null;\n                try {\n                    repository = getRepository(repoURL, credentials,\n                            Collections.emptyMap(), null);\n                    long rev = repository.getLatestRevision();\n                    String repoPath = getRelativePath(repoURL, repository);\n                    String p = repoPath;\n                    while(p.length()>0) {\n                        p = SVNPathUtil.removeTail(p);\n                        if(repository.checkPath(p,rev)==SVNNodeKind.DIR) {\n                            List<SVNDirEntry> entries = new ArrayList<>();\n                            repository.getDir(p,rev,false,entries);\n\n                            List<String> paths = new ArrayList<>();\n                            for (SVNDirEntry e : entries)\n                                if(e.getKind()==SVNNodeKind.DIR)\n                                    paths.add(e.getName());\n\n                            String head = SVNPathUtil.head(repoPath.substring(p.length() + 1));\n                            String candidate = EditDistance.findNearest(head, paths);\n\n                            return FormValidation.error(\n                                hudson.scm.subversion.Messages.SubversionSCM_doCheckRemote_badPathSuggest(p, head,\n                                        candidate != null ? \"/\" + candidate : \"\"));\n                        }\n                    }\n\n                    return FormValidation.error(\n                        hudson.scm.subversion.Messages.SubversionSCM_doCheckRemote_badPath(repoPath));\n                } finally {\n                    if (repository != null)\n                        repository.closeSession();\n                }\n            } catch (SVNException e) {\n                LOGGER.log(Level.INFO, \"Failed to access subversion repository \"+url,e);\n                String message = hudson.scm.subversion.Messages.SubversionSCM_doCheckRemote_exceptionMsg1(\n                        Util.escape(url), Util.escape(e.getErrorMessage().getFullMessage()),\n                        \"javascript:document.getElementById('svnerror').style.display='block';\"\n                                + \"document.getElementById('svnerrorlink').style.display='none';\"\n                                + \"return false;\")\n                  + \"<br/><pre id=\\\"svnerror\\\" style=\\\"display:none\\\">\"\n                  + Util.xmlEscape(Functions.printThrowable(e)) + \"</pre>\";\n                return FormValidation.errorWithMarkup(message);\n            }\n// fix_end\n// fix_start\n// fix_end\n", "cwe": "CWE-79", "cwe_name": "Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')", "idx": 80692}
{"source": "// bug_start\nprivate void close() {\n        connectionState.set(ConnectionState.CLOSED);\n// bug_end\n         try {\n// bug_start\n            socketWrapper.close();\n// bug_end\n         } catch (IOException ioe) {\n// bug_start\n            log.debug(sm.getString(\"upgradeHandler.socketCloseFailed\"), ioe);\n// bug_end\n         }\n// bug_start\n    }\n// bug_end\n \n", "target": "// fix_start\n@Override\n      public boolean process(final TProtocol inProt, final TProtocol outProt) throws TException {\n        TTransport trans = inProt.getTransport();\n        if (!(trans instanceof TSaslServerTransport)) {\n          throw new TException(\"Unexpected non-SASL transport \" + trans.getClass());\n        }\n        TSaslServerTransport saslTrans = (TSaslServerTransport)trans;\n        SaslServer saslServer = saslTrans.getSaslServer();\n        String authId = saslServer.getAuthorizationID();\n        authenticationMethod.set(AuthenticationMethod.KERBEROS);\n        LOG.debug(\"AUTH ID ======>\" + authId);\n        String endUser = authId;\n\n        if(saslServer.getMechanismName().equals(\"DIGEST-MD5\")) {\n          try {\n            TokenIdentifier tokenId = SaslRpcServer.getIdentifier(authId,\n                secretManager);\n            endUser = tokenId.getUser().getUserName();\n            authenticationMethod.set(AuthenticationMethod.TOKEN);\n          } catch (InvalidToken e) {\n            throw new TException(e.getMessage());\n          }\n        }\n        Socket socket = ((TSocket)(saslTrans.getUnderlyingTransport())).getSocket();\n        remoteAddress.set(socket.getInetAddress());\n        UserGroupInformation clientUgi = null;\n// fix_end\n// fix_start\n          if (useProxy) {\n            clientUgi = UserGroupInformation.createProxyUser(\n                endUser, UserGroupInformation.getLoginUser());\n            remoteUser.set(clientUgi.getShortUserName());\n            LOG.debug(\"Set remoteUser :\" + remoteUser.get());\n            return clientUgi.doAs(new PrivilegedExceptionAction<Boolean>() {\n              @Override\n              public Boolean run() {\n                try {\n                  return wrapped.process(inProt, outProt);\n                } catch (TException te) {\n                  throw new RuntimeException(te);\n                }\n              }\n            });\n          } else {\n            UserGroupInformation endUserUgi = UserGroupInformation.createRemoteUser(endUser);\n            remoteUser.set(endUserUgi.getShortUserName());\n            LOG.debug(\"Set remoteUser :\" + remoteUser.get() + \", from endUser :\" + endUser);\n            return wrapped.process(inProt, outProt);\n          }\n        } catch (RuntimeException rte) {\n          if (rte.getCause() instanceof TException) {\n            throw (TException)rte.getCause();\n          }\n          throw rte;\n        } catch (InterruptedException ie) {\n          throw new RuntimeException(ie);\n// fix_end\n// fix_start\n          throw new RuntimeException(ioe);\n// fix_end\n// fix_start\n        finally {\n          if (clientUgi != null) {\n            try { FileSystem.closeAllForUGI(clientUgi); }\n            catch(IOException exception) {\n              LOG.error(\"Could not clean up file-system handles for UGI: \" + clientUgi, exception);\n            }\n          }\n        }\n      }\n// fix_end\n", "cwe": "CWE-404", "cwe_name": "Improper Resource Shutdown or Release", "idx": 53638}
{"source": "// bug_start\n@Override\n      public boolean process(final TProtocol inProt, final TProtocol outProt) throws TException {\n        TTransport trans = inProt.getTransport();\n        if (!(trans instanceof TSaslServerTransport)) {\n          throw new TException(\"Unexpected non-SASL transport \" + trans.getClass());\n        }\n        TSaslServerTransport saslTrans = (TSaslServerTransport)trans;\n        SaslServer saslServer = saslTrans.getSaslServer();\n        String authId = saslServer.getAuthorizationID();\n        authenticationMethod.set(AuthenticationMethod.KERBEROS);\n        LOG.debug(\"AUTH ID ======>\" + authId);\n        String endUser = authId;\n// bug_end\n \n// bug_start\n        if(saslServer.getMechanismName().equals(\"DIGEST-MD5\")) {\n          try {\n            TokenIdentifier tokenId = SaslRpcServer.getIdentifier(authId,\n                secretManager);\n            endUser = tokenId.getUser().getUserName();\n            authenticationMethod.set(AuthenticationMethod.TOKEN);\n          } catch (InvalidToken e) {\n            throw new TException(e.getMessage());\n          }\n        }\n        Socket socket = ((TSocket)(saslTrans.getUnderlyingTransport())).getSocket();\n        remoteAddress.set(socket.getInetAddress());\n        UserGroupInformation clientUgi = null;\n        try {\n          if (useProxy) {\n            clientUgi = UserGroupInformation.createProxyUser(\n                endUser, UserGroupInformation.getLoginUser());\n            remoteUser.set(clientUgi.getShortUserName());\n            return clientUgi.doAs(new PrivilegedExceptionAction<Boolean>() {\n              @Override\n              public Boolean run() {\n                try {\n                  return wrapped.process(inProt, outProt);\n                } catch (TException te) {\n                  throw new RuntimeException(te);\n                }\n              }\n            });\n          } else {\n            remoteUser.set(endUser);\n            return wrapped.process(inProt, outProt);\n          }\n        } catch (RuntimeException rte) {\n          if (rte.getCause() instanceof TException) {\n            throw (TException)rte.getCause();\n          }\n          throw rte;\n        } catch (InterruptedException ie) {\n          throw new RuntimeException(ie);\n        } catch (IOException ioe) {\n          throw new RuntimeException(ioe);\n        }\n        finally {\n          if (clientUgi != null) {\n            try { FileSystem.closeAllForUGI(clientUgi); }\n            catch(IOException exception) {\n              LOG.error(\"Could not clean up file-system handles for UGI: \" + clientUgi, exception);\n            }\n          }\n        }\n// bug_end\n       }\n// bug_start\n// bug_end\n \n", "target": "// fix_start\npublic void parseDmozFile(File dmozFile, int subsetDenom,\n      boolean includeAdult, int skew, Pattern topicPattern)\n              throws IOException, SAXException, ParserConfigurationException {\n// fix_end\n// fix_start\n    SAXParserFactory parserFactory = SAXParserFactory.newInstance();\n    parserFactory.setFeature(\"http://xml.org/sax/features/external-general-entities\", false);\n    parserFactory.setFeature(\"http://apache.org/xml/features/disallow-doctype-decl\", true);\n    SAXParser parser = parserFactory.newSAXParser();\n    XMLReader reader = parser.getXMLReader();\n    reader.setFeature(\"http://xml.org/sax/features/external-general-entities\", false);\n\n    RDFProcessor rp = new RDFProcessor(reader, subsetDenom, includeAdult, skew,\n        topicPattern);\n    reader.setContentHandler(rp);\n    reader.setErrorHandler(rp);\n    LOG.info(\"skew = \" + rp.hashSkew);\n\n    try (XMLCharFilter in = new XMLCharFilter(new BufferedReader(\n        new InputStreamReader(new BufferedInputStream(new FileInputStream(\n            dmozFile)), \"UTF-8\")))) {\n      InputSource is = new InputSource(in);\n      reader.parse(is);\n    } catch (Exception e) {\n      if (LOG.isErrorEnabled()) {\n        LOG.error(e.toString());\n// fix_end\n// fix_start\n      System.exit(0);\n    }\n  }\n// fix_end\n", "cwe": "CWE-284", "cwe_name": "Improper Access Control", "idx": 37960}
{"source": "// bug_start\npublic void parseDmozFile(File dmozFile, int subsetDenom,\n      boolean includeAdult, int skew, Pattern topicPattern)\n              throws IOException, SAXException, ParserConfigurationException {\n\n    SAXParserFactory parserFactory = SAXParserFactory.newInstance();\n    SAXParser parser = parserFactory.newSAXParser();\n    XMLReader reader = parser.getXMLReader();\n\n    RDFProcessor rp = new RDFProcessor(reader, subsetDenom, includeAdult, skew,\n        topicPattern);\n    reader.setContentHandler(rp);\n    reader.setErrorHandler(rp);\n    LOG.info(\"skew = \" + rp.hashSkew);\n\n    try (XMLCharFilter in = new XMLCharFilter(new BufferedReader(\n        new InputStreamReader(new BufferedInputStream(new FileInputStream(\n            dmozFile)), \"UTF-8\")))) {\n      InputSource is = new InputSource(in);\n      reader.parse(is);\n    } catch (Exception e) {\n      if (LOG.isErrorEnabled()) {\n        LOG.error(e.toString());\n      }\n      System.exit(0);\n// bug_end\n     }\n// bug_start\n  }\n\n// bug_end\n", "target": "// fix_start\nprivate void prepareRequest() {\n\n        byte methodCode = requestHeaderMessage.getByte();\n        if (methodCode != Constants.SC_M_JK_STORED) {\n            String methodName = Constants.getMethodForCode(methodCode - 1);\n            request.method().setString(methodName);\n        }\n\n        requestHeaderMessage.getBytes(request.protocol());\n        requestHeaderMessage.getBytes(request.requestURI());\n\n        requestHeaderMessage.getBytes(request.remoteAddr());\n        requestHeaderMessage.getBytes(request.remoteHost());\n        requestHeaderMessage.getBytes(request.localName());\n        request.setLocalPort(requestHeaderMessage.getInt());\n\n        boolean isSSL = requestHeaderMessage.getByte() != 0;\n        if (isSSL) {\n            request.scheme().setString(\"https\");\n        }\n\n        MimeHeaders headers = request.getMimeHeaders();\n\n        headers.setLimit(endpoint.getMaxHeaderCount());\n\n        boolean contentLengthSet = false;\n        int hCount = requestHeaderMessage.getInt();\n        for(int i = 0 ; i < hCount ; i++) {\n            String hName = null;\n\n            int isc = requestHeaderMessage.peekInt();\n            int hId = isc & 0xFF;\n\n            MessageBytes vMB = null;\n            isc &= 0xFF00;\n            if(0xA000 == isc) {\n                requestHeaderMessage.getInt();\n                hName = Constants.getHeaderForCode(hId - 1);\n                vMB = headers.addValue(hName);\n            } else {\n                hId = -1;\n                requestHeaderMessage.getBytes(tmpMB);\n                ByteChunk bc = tmpMB.getByteChunk();\n                vMB = headers.addValue(bc.getBuffer(),\n                        bc.getStart(), bc.getLength());\n            }\n\n            requestHeaderMessage.getBytes(vMB);\n\n            if (hId == Constants.SC_REQ_CONTENT_LENGTH ||\n                    (hId == -1 && tmpMB.equalsIgnoreCase(\"Content-Length\"))) {\n                long cl = vMB.getLong();\n                if (contentLengthSet) {\n                    response.setStatus(HttpServletResponse.SC_BAD_REQUEST);\n                    setErrorState(ErrorState.CLOSE_CLEAN, null);\n                } else {\n                    contentLengthSet = true;\n                    request.setContentLength(cl);\n                }\n            } else if (hId == Constants.SC_REQ_CONTENT_TYPE ||\n                    (hId == -1 && tmpMB.equalsIgnoreCase(\"Content-Type\"))) {\n                ByteChunk bchunk = vMB.getByteChunk();\n                request.contentType().setBytes(bchunk.getBytes(),\n                        bchunk.getOffset(),\n                        bchunk.getLength());\n            }\n        }\n\n        boolean secretPresentInRequest = false;\n        byte attributeCode;\n        while ((attributeCode = requestHeaderMessage.getByte())\n                != Constants.SC_A_ARE_DONE) {\n\n            switch (attributeCode) {\n\n            case Constants.SC_A_REQ_ATTRIBUTE :\n                requestHeaderMessage.getBytes(tmpMB);\n                String n = tmpMB.toString();\n                requestHeaderMessage.getBytes(tmpMB);\n                String v = tmpMB.toString();\n                if(n.equals(Constants.SC_A_REQ_LOCAL_ADDR)) {\n                    request.localAddr().setString(v);\n                } else if(n.equals(Constants.SC_A_REQ_REMOTE_PORT)) {\n                    try {\n                        request.setRemotePort(Integer.parseInt(v));\n                    } catch (NumberFormatException nfe) {\n                    }\n                } else if(n.equals(Constants.SC_A_SSL_PROTOCOL)) {\n                    request.setAttribute(SSLSupport.PROTOCOL_VERSION_KEY, v);\n                } else {\n                    request.setAttribute(n, v );\n                }\n                break;\n\n            case Constants.SC_A_CONTEXT :\n                requestHeaderMessage.getBytes(tmpMB);\n                break;\n\n            case Constants.SC_A_SERVLET_PATH :\n                requestHeaderMessage.getBytes(tmpMB);\n                break;\n\n            case Constants.SC_A_REMOTE_USER :\n                if (tomcatAuthorization || !tomcatAuthentication) {\n                    requestHeaderMessage.getBytes(request.getRemoteUser());\n                    request.setRemoteUserNeedsAuthorization(tomcatAuthorization);\n                } else {\n                    requestHeaderMessage.getBytes(tmpMB);\n                }\n                break;\n\n            case Constants.SC_A_AUTH_TYPE :\n                if (tomcatAuthentication) {\n                    requestHeaderMessage.getBytes(tmpMB);\n                } else {\n                    requestHeaderMessage.getBytes(request.getAuthType());\n                }\n                break;\n\n            case Constants.SC_A_QUERY_STRING :\n                requestHeaderMessage.getBytes(request.queryString());\n                break;\n\n            case Constants.SC_A_JVM_ROUTE :\n                requestHeaderMessage.getBytes(tmpMB);\n                break;\n\n            case Constants.SC_A_SSL_CERT :\n                requestHeaderMessage.getBytes(certificates);\n                break;\n\n            case Constants.SC_A_SSL_CIPHER :\n                requestHeaderMessage.getBytes(tmpMB);\n                request.setAttribute(SSLSupport.CIPHER_SUITE_KEY,\n                        tmpMB.toString());\n                break;\n\n            case Constants.SC_A_SSL_SESSION :\n                requestHeaderMessage.getBytes(tmpMB);\n                request.setAttribute(SSLSupport.SESSION_ID_KEY,\n                        tmpMB.toString());\n                break;\n\n            case Constants.SC_A_SSL_KEY_SIZE :\n                request.setAttribute(SSLSupport.KEY_SIZE_KEY,\n                        Integer.valueOf(requestHeaderMessage.getInt()));\n                break;\n\n            case Constants.SC_A_STORED_METHOD:\n                requestHeaderMessage.getBytes(request.method());\n                break;\n\n            case Constants.SC_A_SECRET:\n                requestHeaderMessage.getBytes(tmpMB);\n                if (secret != null) {\n                    secretPresentInRequest = true;\n                    if (!tmpMB.equals(secret)) {\n                        response.setStatus(403);\n                        setErrorState(ErrorState.CLOSE_CLEAN, null);\n                    }\n                }\n                break;\n\n            default:\n                break;\n\n            }\n\n        }\n\n        if ((secret != null) && !secretPresentInRequest) {\n            response.setStatus(403);\n            setErrorState(ErrorState.CLOSE_CLEAN, null);\n        }\n\n        ByteChunk uriBC = request.requestURI().getByteChunk();\n        if (uriBC.startsWithIgnoreCase(\"http\", 0)) {\n\n            int pos = uriBC.indexOf(\"://\", 0, 3, 4);\n            int uriBCStart = uriBC.getStart();\n            int slashPos = -1;\n            if (pos != -1) {\n                byte[] uriB = uriBC.getBytes();\n                slashPos = uriBC.indexOf('/', pos + 3);\n                if (slashPos == -1) {\n                    slashPos = uriBC.getLength();\n                    request.requestURI().setBytes\n                    (uriB, uriBCStart + pos + 1, 1);\n                } else {\n                    request.requestURI().setBytes\n                    (uriB, uriBCStart + slashPos,\n                            uriBC.getLength() - slashPos);\n                }\n                MessageBytes hostMB = headers.setValue(\"host\");\n                hostMB.setBytes(uriB, uriBCStart + pos + 3,\n                        slashPos - pos - 3);\n            }\n\n        }\n\n        MessageBytes valueMB = request.getMimeHeaders().getValue(\"host\");\n        parseHost(valueMB);\n\n        if (!getErrorState().isIoAllowed()) {\n            getAdapter().log(request, response, 0);\n        }\n// fix_end\n// fix_start\n\n// fix_end\n", "cwe": "CWE-611", "cwe_name": "Improper Restriction of XML External Entity Reference ('XXE')", "idx": 69587}
{"source": "// bug_start\nprivate String escapeString(final String string)\n  {\n    if (string == null || string.length() == 0) {\n      return \"\\\"\\\"\";\n// bug_end\n     }\n// bug_start\n    char c = 0;\n    int i;\n    final int len = string.length();\n    final StringBuilder sb = new StringBuilder(len + 4);\n    String t;\n    sb.append('\"');\n    for (i = 0; i < len; i += 1) {\n      c = string.charAt(i);\n      switch (c) {\n        case '\\\\':\n        case '\"':\n          sb.append('\\\\');\n          sb.append(c);\n          break;\n        case '/':\n          sb.append('\\\\');\n          sb.append(c);\n          break;\n        case '\\b':\n          sb.append(\"\\\\b\");\n          break;\n        case '\\t':\n          sb.append(\"\\\\t\");\n          break;\n        case '\\n':\n          sb.append(\"\\\\n\");\n          break;\n        case '\\f':\n          sb.append(\"\\\\f\");\n          break;\n        case '\\r':\n          sb.append(\"\\\\r\");\n          break;\n        default:\n          if (c < ' ') {\n            t = \"000\" + Integer.toHexString(c);\n            sb.append(\"\\\\u\" + t.substring(t.length() - 4));\n          } else {\n            if (escapeHtml == true) {\n              switch (c) {\n                case '<':\n                  sb.append(\"&lt;\");\n                  break;\n                case '>':\n                  sb.append(\"&gt;\");\n                  break;\n                case '&':\n                  sb.append(\"&amp;\");\n                  break;\n                case '\"':\n                  sb.append(\"&quot;\");\n                  break;\n                case '\\'':\n                  sb.append(\"&#x27;\");\n                  break;\n                case '/':\n                  sb.append(\"&#x2F;\");\n                  break;\n                default:\n                  sb.append(c);\n              }\n            } else {\n              sb.append(c);\n            }\n          }\n      }\n    }\n    sb.append('\"');\n    return sb.toString();\n  }\n\n// bug_end\n", "target": "// fix_start\nprivate void prepareRequest() {\n\n        byte methodCode = requestHeaderMessage.getByte();\n        if (methodCode != Constants.SC_M_JK_STORED) {\n            String methodName = Constants.getMethodForCode(methodCode - 1);\n            request.method().setString(methodName);\n        }\n\n        requestHeaderMessage.getBytes(request.protocol());\n        requestHeaderMessage.getBytes(request.requestURI());\n\n        requestHeaderMessage.getBytes(request.remoteAddr());\n        requestHeaderMessage.getBytes(request.remoteHost());\n        requestHeaderMessage.getBytes(request.localName());\n        request.setLocalPort(requestHeaderMessage.getInt());\n\n        boolean isSSL = requestHeaderMessage.getByte() != 0;\n        if (isSSL) {\n            request.scheme().setString(\"https\");\n        }\n\n        MimeHeaders headers = request.getMimeHeaders();\n\n        headers.setLimit(endpoint.getMaxHeaderCount());\n\n        boolean contentLengthSet = false;\n        int hCount = requestHeaderMessage.getInt();\n        for(int i = 0 ; i < hCount ; i++) {\n            String hName = null;\n\n            int isc = requestHeaderMessage.peekInt();\n            int hId = isc & 0xFF;\n\n            MessageBytes vMB = null;\n            isc &= 0xFF00;\n            if(0xA000 == isc) {\n                requestHeaderMessage.getInt();\n                hName = Constants.getHeaderForCode(hId - 1);\n                vMB = headers.addValue(hName);\n            } else {\n                hId = -1;\n                requestHeaderMessage.getBytes(tmpMB);\n                ByteChunk bc = tmpMB.getByteChunk();\n                vMB = headers.addValue(bc.getBuffer(),\n                        bc.getStart(), bc.getLength());\n            }\n\n            requestHeaderMessage.getBytes(vMB);\n\n            if (hId == Constants.SC_REQ_CONTENT_LENGTH ||\n                    (hId == -1 && tmpMB.equalsIgnoreCase(\"Content-Length\"))) {\n                long cl = vMB.getLong();\n                if (contentLengthSet) {\n                    response.setStatus(HttpServletResponse.SC_BAD_REQUEST);\n                    setErrorState(ErrorState.CLOSE_CLEAN, null);\n                } else {\n                    contentLengthSet = true;\n                    request.setContentLength(cl);\n                }\n            } else if (hId == Constants.SC_REQ_CONTENT_TYPE ||\n                    (hId == -1 && tmpMB.equalsIgnoreCase(\"Content-Type\"))) {\n                ByteChunk bchunk = vMB.getByteChunk();\n                request.contentType().setBytes(bchunk.getBytes(),\n                        bchunk.getOffset(),\n                        bchunk.getLength());\n            }\n        }\n\n        boolean secretPresentInRequest = false;\n        byte attributeCode;\n        while ((attributeCode = requestHeaderMessage.getByte())\n                != Constants.SC_A_ARE_DONE) {\n\n            switch (attributeCode) {\n\n            case Constants.SC_A_REQ_ATTRIBUTE :\n                requestHeaderMessage.getBytes(tmpMB);\n                String n = tmpMB.toString();\n                requestHeaderMessage.getBytes(tmpMB);\n                String v = tmpMB.toString();\n                if(n.equals(Constants.SC_A_REQ_LOCAL_ADDR)) {\n                    request.localAddr().setString(v);\n                } else if(n.equals(Constants.SC_A_REQ_REMOTE_PORT)) {\n                    try {\n                        request.setRemotePort(Integer.parseInt(v));\n                    } catch (NumberFormatException nfe) {\n                    }\n                } else if(n.equals(Constants.SC_A_SSL_PROTOCOL)) {\n                    request.setAttribute(SSLSupport.PROTOCOL_VERSION_KEY, v);\n                } else if (n.equals(\"JK_LB_ACTIVATION\")) {\n                    request.setAttribute(n, v);\n                } else if (javaxAttributes.contains(n)) {\n                    request.setAttribute(n, v);\n                } else {\n                    Pattern pattern = protocol.getAllowedArbitraryRequestAttributesPattern();\n                    if (pattern == null) {\n                        response.setStatus(403);\n                        setErrorState(ErrorState.CLOSE_CLEAN, null);\n                    } else {\n                        Matcher m = pattern.matcher(n);\n                        if (m.matches()) {\n                            request.setAttribute(n, v);\n                        } else {\n                            response.setStatus(403);\n                            setErrorState(ErrorState.CLOSE_CLEAN, null);\n                        }\n                    }\n                }\n                break;\n\n            case Constants.SC_A_CONTEXT :\n                requestHeaderMessage.getBytes(tmpMB);\n                break;\n\n            case Constants.SC_A_SERVLET_PATH :\n                requestHeaderMessage.getBytes(tmpMB);\n                break;\n\n            case Constants.SC_A_REMOTE_USER :\n                if (tomcatAuthorization || !tomcatAuthentication) {\n                    requestHeaderMessage.getBytes(request.getRemoteUser());\n                    request.setRemoteUserNeedsAuthorization(tomcatAuthorization);\n                } else {\n                    requestHeaderMessage.getBytes(tmpMB);\n                }\n                break;\n\n            case Constants.SC_A_AUTH_TYPE :\n                if (tomcatAuthentication) {\n                    requestHeaderMessage.getBytes(tmpMB);\n                } else {\n                    requestHeaderMessage.getBytes(request.getAuthType());\n                }\n                break;\n\n            case Constants.SC_A_QUERY_STRING :\n                requestHeaderMessage.getBytes(request.queryString());\n                break;\n\n            case Constants.SC_A_JVM_ROUTE :\n                requestHeaderMessage.getBytes(tmpMB);\n                break;\n\n            case Constants.SC_A_SSL_CERT :\n                requestHeaderMessage.getBytes(certificates);\n                break;\n\n            case Constants.SC_A_SSL_CIPHER :\n                requestHeaderMessage.getBytes(tmpMB);\n                request.setAttribute(SSLSupport.CIPHER_SUITE_KEY,\n                        tmpMB.toString());\n                break;\n\n            case Constants.SC_A_SSL_SESSION :\n                requestHeaderMessage.getBytes(tmpMB);\n                request.setAttribute(SSLSupport.SESSION_ID_KEY,\n                        tmpMB.toString());\n                break;\n\n            case Constants.SC_A_SSL_KEY_SIZE :\n                request.setAttribute(SSLSupport.KEY_SIZE_KEY,\n                        Integer.valueOf(requestHeaderMessage.getInt()));\n                break;\n\n            case Constants.SC_A_STORED_METHOD:\n                requestHeaderMessage.getBytes(request.method());\n                break;\n\n            case Constants.SC_A_SECRET:\n                requestHeaderMessage.getBytes(tmpMB);\n                if (secret != null) {\n                    secretPresentInRequest = true;\n                    if (!tmpMB.equals(secret)) {\n                        response.setStatus(403);\n                        setErrorState(ErrorState.CLOSE_CLEAN, null);\n                    }\n                }\n                break;\n\n            default:\n                break;\n\n            }\n\n        }\n\n        if ((secret != null) && !secretPresentInRequest) {\n            response.setStatus(403);\n            setErrorState(ErrorState.CLOSE_CLEAN, null);\n        }\n\n        ByteChunk uriBC = request.requestURI().getByteChunk();\n        if (uriBC.startsWithIgnoreCase(\"http\", 0)) {\n\n            int pos = uriBC.indexOf(\"://\", 0, 3, 4);\n            int uriBCStart = uriBC.getStart();\n            int slashPos = -1;\n            if (pos != -1) {\n                byte[] uriB = uriBC.getBytes();\n                slashPos = uriBC.indexOf('/', pos + 3);\n                if (slashPos == -1) {\n                    slashPos = uriBC.getLength();\n                    request.requestURI().setBytes\n                    (uriB, uriBCStart + pos + 1, 1);\n                } else {\n                    request.requestURI().setBytes\n                    (uriB, uriBCStart + slashPos,\n                            uriBC.getLength() - slashPos);\n                }\n                MessageBytes hostMB = headers.setValue(\"host\");\n                hostMB.setBytes(uriB, uriBCStart + pos + 3,\n                        slashPos - pos - 3);\n            }\n\n        }\n\n        MessageBytes valueMB = request.getMimeHeaders().getValue(\"host\");\n        parseHost(valueMB);\n\n        if (!getErrorState().isIoAllowed()) {\n            getAdapter().log(request, response, 0);\n        }\n// fix_end\n// fix_start\n\n// fix_end\n", "cwe": "NVD-CWE-Other", "cwe_name": "Other", "idx": 111913}
{"source": "// bug_start\nprivate String escapeString(final String string)\n  {\n    if (string == null || string.length() == 0) {\n      return \"\\\"\\\"\";\n// bug_end\n     }\n// bug_start\n    char c = 0;\n    int i;\n    final int len = string.length();\n    final StringBuilder sb = new StringBuilder(len + 4);\n    String t;\n    sb.append('\"');\n    for (i = 0; i < len; i += 1) {\n      c = string.charAt(i);\n      switch (c) {\n        case '\\\\':\n        case '\"':\n          sb.append('\\\\');\n          sb.append(c);\n          break;\n        case '/':\n          sb.append('\\\\');\n          sb.append(c);\n          break;\n        case '\\b':\n          sb.append(\"\\\\b\");\n          break;\n        case '\\t':\n          sb.append(\"\\\\t\");\n          break;\n        case '\\n':\n          sb.append(\"\\\\n\");\n          break;\n        case '\\f':\n          sb.append(\"\\\\f\");\n          break;\n        case '\\r':\n          sb.append(\"\\\\r\");\n          break;\n        default:\n          if (c < ' ') {\n            t = \"000\" + Integer.toHexString(c);\n            sb.append(\"\\\\u\" + t.substring(t.length() - 4));\n          } else {\n            sb.append(c);\n          }\n      }\n    }\n    sb.append('\"');\n    return sb.toString();\n  }\n// bug_end\n \n", "target": "// fix_start\nprivate void enumerateChmDirectoryListingList(ChmItsfHeader chmItsHeader,\n            ChmItspHeader chmItspHeader) throws TikaException {\n        try {\n            int startPmgl = chmItspHeader.getIndex_head();\n            int stopPmgl = chmItspHeader.getUnknown_0024();\n            int dir_offset = (int) (chmItsHeader.getDirOffset() + chmItspHeader\n                    .getHeader_len());\n            setDataOffset(chmItsHeader.getDataOffset());\n\n            byte[] dir_chunk = null;\n            Set<Integer> processed = new HashSet<>();\n            for (int i = startPmgl; i>=0; ) {\n                dir_chunk = new byte[(int) chmItspHeader.getBlock_len()];\n                int start = i * (int) chmItspHeader.getBlock_len() + dir_offset;\n                dir_chunk = ChmCommons\n                        .copyOfRange(getData(), start,\n                                start +(int) chmItspHeader.getBlock_len());\n\n                PMGLheader = new ChmPmglHeader();\n                PMGLheader.parse(dir_chunk, PMGLheader);\n                enumerateOneSegment(dir_chunk);\n                int nextBlock = PMGLheader.getBlockNext();\n                processed.add(i);\n                if (processed.contains(nextBlock)) {\n                    throw new ChmParsingException(\"already processed block; avoiding cycle\");\n                }\n                i=nextBlock;\n                dir_chunk = null;\n            }\n\n        } catch (ChmParsingException e) {\n            LOG.warn(\"Chm parse exception\", e);\n        } finally {\n            setData(null);\n        }\n// fix_end\n// fix_start\n// fix_end\n", "cwe": "CWE-79", "cwe_name": "Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')", "idx": 80703}
{"source": "// bug_start\nprivate void enumerateChmDirectoryListingList(ChmItsfHeader chmItsHeader,\n            ChmItspHeader chmItspHeader) throws TikaException {\n// bug_end\n         try {\n// bug_start\n            int startPmgl = chmItspHeader.getIndex_head();\n            int stopPmgl = chmItspHeader.getUnknown_0024();\n            int dir_offset = (int) (chmItsHeader.getDirOffset() + chmItspHeader\n                    .getHeader_len());\n            setDataOffset(chmItsHeader.getDataOffset());\n// bug_end\n \n// bug_start\n            byte[] dir_chunk = null;\n            Set<Integer> processed = new HashSet<>();\n            for (int i = startPmgl; i>=0; ) {\n                dir_chunk = new byte[(int) chmItspHeader.getBlock_len()];\n                int start = i * (int) chmItspHeader.getBlock_len() + dir_offset;\n                dir_chunk = ChmCommons\n                        .copyOfRange(getData(), start,\n                                start +(int) chmItspHeader.getBlock_len());\n\n                PMGLheader = new ChmPmglHeader();\n                PMGLheader.parse(dir_chunk, PMGLheader);\n                enumerateOneSegment(dir_chunk);\n                int nextBlock = PMGLheader.getBlockNext();\n                processed.add(i);\n                if (processed.contains(nextBlock)) {\n                    throw new ChmParsingException(\"already processed block; avoiding cycle\");\n                }\n                i=nextBlock;\n                dir_chunk = null;\n            }\n            System.out.println(\"done\");\n        } catch (ChmParsingException e) {\n            LOG.warn(\"Chm parse exception\", e);\n        } finally {\n            setData(null);\n        }\n// bug_end\n     }\n \n", "target": "// fix_start\npublic WireFormat createWireFormat() {\n        WireFormatInfo info = new WireFormatInfo();\n        info.setVersion(version);\n\n// fix_end\n// fix_start\n            info.setStackTraceEnabled(stackTraceEnabled);\n            info.setCacheEnabled(cacheEnabled);\n            info.setTcpNoDelayEnabled(tcpNoDelayEnabled);\n            info.setTightEncodingEnabled(tightEncodingEnabled);\n            info.setSizePrefixDisabled(sizePrefixDisabled);\n            info.setMaxInactivityDuration(maxInactivityDuration);\n            info.setMaxInactivityDurationInitalDelay(maxInactivityDurationInitalDelay);\n            info.setCacheSize(cacheSize);\n            info.setMaxFrameSize(maxFrameSize);\n            if( host!=null ) {\n                info.setHost(host);\n            }\n            info.setProviderName(providerName);\n            info.setProviderVersion(providerVersion);\n            info.setPlatformDetails(platformDetails);\n        } catch (Exception e) {\n            IllegalStateException ise = new IllegalStateException(\"Could not configure WireFormatInfo\");\n            ise.initCause(e);\n            throw ise;\n        }\n// fix_end\n// fix_start\n        OpenWireFormat f = new OpenWireFormat(version);\n        f.setMaxFrameSize(maxFrameSize);\n        f.setPreferedWireFormatInfo(info);\n        return f;\n// fix_end\n", "cwe": "NVD-CWE-noinfo", "cwe_name": "", "idx": 108887}
{"source": " @Override\n// bug_start\n    public JsonDeserializer<Object> createBeanDeserializer(DeserializationContext ctxt,\n            JavaType type, BeanDescription beanDesc)\n        throws JsonMappingException\n    {\n        final DeserializationConfig config = ctxt.getConfig();\n        JsonDeserializer<Object> custom = _findCustomBeanDeserializer(type, config, beanDesc);\n        if (custom != null) {\n            return custom;\n        }\n        if (type.isThrowable()) {\n            return buildThrowableDeserializer(ctxt, type, beanDesc);\n        }\n        if (type.isAbstract() && !type.isPrimitive() && !type.isEnumType()) {\n            JavaType concreteType = materializeAbstractType(ctxt, type, beanDesc);\n            if (concreteType != null) {\n                beanDesc = config.introspect(concreteType);\n                return buildBeanDeserializer(ctxt, concreteType, beanDesc);\n// bug_end\n             }\n// bug_start\n        }\n        @SuppressWarnings(\"unchecked\")\n        JsonDeserializer<Object> deser = (JsonDeserializer<Object>) findStdDeserializer(ctxt, type, beanDesc);\n        if (deser != null) {\n            return deser;\n// bug_end\n         }\n \n// bug_start\n        if (!isPotentialBeanType(type.getRawClass())) {\n            return null;\n        }\n        return buildBeanDeserializer(ctxt, type, beanDesc);\n// bug_end\n     }\n \n", "target": "// fix_start\n    public WireFormat createWireFormat() {\n        WireFormatInfo info = new WireFormatInfo();\n        info.setVersion(version);\n\n        try {\n            info.setStackTraceEnabled(stackTraceEnabled);\n            info.setCacheEnabled(cacheEnabled);\n            info.setTcpNoDelayEnabled(tcpNoDelayEnabled);\n            info.setTightEncodingEnabled(tightEncodingEnabled);\n            info.setSizePrefixDisabled(sizePrefixDisabled);\n            info.setMaxInactivityDuration(maxInactivityDuration);\n            info.setMaxInactivityDurationInitalDelay(maxInactivityDurationInitalDelay);\n            info.setCacheSize(cacheSize);\n            info.setMaxFrameSize(maxFrameSize);\n            if( host!=null ) {\n                info.setHost(host);\n// fix_end\n// fix_start\n            info.setProviderName(providerName);\n            info.setProviderVersion(providerVersion);\n            if (includePlatformDetails) {\n                platformDetails = ActiveMQConnectionMetaData.PLATFORM_DETAILS;\n            }\n            info.setPlatformDetails(platformDetails);\n        } catch (Exception e) {\n            IllegalStateException ise = new IllegalStateException(\"Could not configure WireFormatInfo\");\n            ise.initCause(e);\n            throw ise;\n// fix_end\n// fix_start\n        OpenWireFormat f = new OpenWireFormat(version);\n        f.setMaxFrameSize(maxFrameSize);\n        f.setPreferedWireFormatInfo(info);\n        return f;\n// fix_end\n", "cwe": "CWE-200", "cwe_name": "Exposure of Sensitive Information to an Unauthorized Actor", "idx": 12413}
{"source": "// bug_start\npublic InputStream stream(final String host, final ByteBuffer message) throws IOException {\n        ServerAddress serverAddress = host.contains(\":\") ? new ServerAddress(host) : new ServerAddress(host, defaultPort);\n        SSLSocket socket = (SSLSocket) sslContext.getSocketFactory().createSocket();\n\n        try {\n            enableHostNameVerification(socket);\n            socket.setSoTimeout(timeoutMillis);\n            socket.connect(serverAddress.getSocketAddress(), timeoutMillis);\n        } catch (IOException e) {\n            closeSocket(socket);\n            throw e;\n// bug_end\n         }\n \n// bug_start\n        try {\n            OutputStream outputStream = socket.getOutputStream();\n\n            byte[] bytes = new byte[message.remaining()];\n\n            message.get(bytes);\n            outputStream.write(bytes);\n        } catch (IOException e) {\n            closeSocket(socket);\n            throw e;\n// bug_end\n         }\n// bug_start\n\n        try {\n            return socket.getInputStream();\n        } catch (IOException e) {\n            closeSocket(socket);\n            throw e;\n        }\n// bug_end\n     }\n \n", "target": "// fix_start\n@Override\n    public JsonDeserializer<Object> createBeanDeserializer(DeserializationContext ctxt,\n            JavaType type, BeanDescription beanDesc)\n        throws JsonMappingException\n    {\n        final DeserializationConfig config = ctxt.getConfig();\n        JsonDeserializer<Object> custom = _findCustomBeanDeserializer(type, config, beanDesc);\n        if (custom != null) {\n            return custom;\n        }\n        if (type.isThrowable()) {\n            return buildThrowableDeserializer(ctxt, type, beanDesc);\n        }\n        if (type.isAbstract() && !type.isPrimitive() && !type.isEnumType()) {\n            JavaType concreteType = materializeAbstractType(ctxt, type, beanDesc);\n            if (concreteType != null) {\n                beanDesc = config.introspect(concreteType);\n                return buildBeanDeserializer(ctxt, concreteType, beanDesc);\n            }\n        }\n        @SuppressWarnings(\"unchecked\")\n        JsonDeserializer<Object> deser = (JsonDeserializer<Object>) findStdDeserializer(ctxt, type, beanDesc);\n        if (deser != null) {\n            return deser;\n// fix_end\n// fix_start\n        if (!isPotentialBeanType(type.getRawClass())) {\n            return null;\n// fix_end\n// fix_start\n        checkIllegalTypes(ctxt, type, beanDesc);\n        return buildBeanDeserializer(ctxt, type, beanDesc);\n// fix_end\n", "cwe": "CWE-184", "cwe_name": "", "idx": 2534}
{"source": "// bug_start\npublic InputStream stream(final String host, final ByteBuffer message) throws IOException {\n        ServerAddress serverAddress = host.contains(\":\") ? new ServerAddress(host) : new ServerAddress(host, defaultPort);\n        Socket socket = sslContext.getSocketFactory().createSocket();\n// bug_end\n \n// bug_start\n        try {\n            socket.setSoTimeout(timeoutMillis);\n            socket.connect(serverAddress.getSocketAddress(), timeoutMillis);\n        } catch (IOException e) {\n            closeSocket(socket);\n            throw e;\n// bug_end\n         }\n \n// bug_start\n        try {\n            OutputStream outputStream = socket.getOutputStream();\n\n            byte[] bytes = new byte[message.remaining()];\n\n            message.get(bytes);\n            outputStream.write(bytes);\n        } catch (IOException e) {\n            closeSocket(socket);\n            throw e;\n// bug_end\n         }\n \n// bug_start\n        try {\n            return socket.getInputStream();\n        } catch (IOException e) {\n            closeSocket(socket);\n            throw e;\n        }\n// bug_end\n     }\n \n", "target": "// fix_start\n@RequestMapping(method = {RequestMethod.GET, RequestMethod.POST})\n    public ModelAndView recover(HttpServletRequest request, HttpServletResponse response) throws Exception {\n// fix_end\n// fix_start\n        Map<String, Object> map = new HashMap<String, Object>();\n        String usernameOrEmail = StringUtils.trimToNull(request.getParameter(\"usernameOrEmail\"));\n\n        if (usernameOrEmail != null) {\n\n            map.put(\"usernameOrEmail\", usernameOrEmail);\n            User user = getUserByUsernameOrEmail(usernameOrEmail);\n\n            boolean captchaOk;\n            if (settingsService.isCaptchaEnabled()) {\n                String recaptchaResponse = request.getParameter(\"g-recaptcha-response\");\n                ReCaptcha captcha = new ReCaptcha(settingsService.getRecaptchaSecretKey());\n                captchaOk = recaptchaResponse != null && captcha.isValid(recaptchaResponse);\n            } else {\n                captchaOk = true;\n            }\n\n            if (!captchaOk) {\n                map.put(\"error\", \"recover.error.invalidcaptcha\");\n            } else if (user == null) {\n                map.put(\"error\", \"recover.error.usernotfound\");\n            } else if (user.getEmail() == null) {\n                map.put(\"error\", \"recover.error.noemail\");\n            } else {\n                String password = RandomStringUtils.randomAlphanumeric(8);\n                if (emailPassword(password, user.getUsername(), user.getEmail())) {\n                    map.put(\"sentTo\", user.getEmail());\n                    user.setLdapAuthenticated(false);\n                    user.setPassword(password);\n                    securityService.updateUser(user);\n                } else {\n                    map.put(\"error\", \"recover.error.sendfailed\");\n                }\n            }\n// fix_end\n// fix_start\n        if (settingsService.isCaptchaEnabled()) {\n            map.put(\"recaptchaSiteKey\", settingsService.getRecaptchaSiteKey());\n// fix_end\n// fix_start\n        return new ModelAndView(\"recover\", \"model\", map);\n// fix_end\n", "cwe": "CWE-295", "cwe_name": "Improper Certificate Validation", "idx": 40036}
{"source": "// bug_start\nprivate Document getXmlDoc() {\n    if (this.xmlDoc != null) {\n      return this.xmlDoc;\n// bug_end\n     }\n \n// bug_start\n    try {\n      this.xmlDoc = DocumentBuilderFactory\n        .newInstance()\n        .newDocumentBuilder()\n        .parse(new ByteArrayInputStream(this.xmlString.getBytes(StandardCharsets.UTF_8)));\n      return xmlDoc;\n    } catch (SAXException | IOException | ParserConfigurationException e) {\n      throw new RuntimeException(\"\u975e\u6cd5\u7684xml\u6587\u672c\u5185\u5bb9\uff1a\" + this.xmlString);\n    }\n\n  }\n\n// bug_end\n", "target": "// fix_start\n@RequestMapping(method = {RequestMethod.GET, RequestMethod.POST})\n    public ModelAndView recover(HttpServletRequest request, HttpServletResponse response) throws Exception {\n\n        Map<String, Object> map = new HashMap<String, Object>();\n        String usernameOrEmail = StringUtils.trimToNull(request.getParameter(\"usernameOrEmail\"));\n\n        if (usernameOrEmail != null) {\n\n            map.put(\"usernameOrEmail\", usernameOrEmail);\n            User user = getUserByUsernameOrEmail(usernameOrEmail);\n\n            boolean captchaOk;\n            if (settingsService.isCaptchaEnabled()) {\n                String recaptchaResponse = request.getParameter(\"g-recaptcha-response\");\n                ReCaptcha captcha = new ReCaptcha(settingsService.getRecaptchaSecretKey());\n                captchaOk = recaptchaResponse != null && captcha.isValid(recaptchaResponse);\n            } else {\n                captchaOk = true;\n            }\n\n            if (!captchaOk) {\n                map.put(\"error\", \"recover.error.invalidcaptcha\");\n            } else if (user == null) {\n                map.put(\"error\", \"recover.error.usernotfound\");\n            } else if (user.getEmail() == null) {\n                map.put(\"error\", \"recover.error.noemail\");\n            } else {\n                StringBuilder sb = new StringBuilder(PASSWORD_LENGTH);\n                for(int i=0; i<PASSWORD_LENGTH; i++) {\n                  int index = random.nextInt(SYMBOLS.length());\n                  sb.append(SYMBOLS.charAt(index));\n                }\n                String password = sb.toString();\n\n                if (emailPassword(password, user.getUsername(), user.getEmail())) {\n                    map.put(\"sentTo\", user.getEmail());\n                    user.setLdapAuthenticated(false);\n                    user.setPassword(password);\n                    securityService.updateUser(user);\n                } else {\n                    map.put(\"error\", \"recover.error.sendfailed\");\n                }\n            }\n        }\n\n        if (settingsService.isCaptchaEnabled()) {\n            map.put(\"recaptchaSiteKey\", settingsService.getRecaptchaSiteKey());\n        }\n\n        return new ModelAndView(\"recover\", \"model\", map);\n// fix_end\n", "cwe": "CWE-335", "cwe_name": "", "idx": 42645}
{"source": "// bug_start\n@GET\n    @Produces({\"application/json\", \"application/jwt\" })\n    public Response getUserInfo() {\n        OAuthContext oauth = OAuthContextUtils.getContext(mc);\n        UserInfo userInfo = null;\n        if (userInfoProvider != null) {\n            userInfo = userInfoProvider.getUserInfo(oauth.getClientId(), oauth.getSubject(),\n                OAuthUtils.convertPermissionsToScopeList(oauth.getPermissions()));\n        } else if (oauth.getSubject() instanceof OidcUserSubject) {\n            OidcUserSubject oidcUserSubject = (OidcUserSubject)oauth.getSubject();\n            userInfo = oidcUserSubject.getUserInfo();\n            if (userInfo == null) {\n                userInfo = createFromIdToken(oidcUserSubject.getIdToken());\n            }\n        }\n        if (userInfo == null) {\n            return Response.serverError().build();\n        }\n\n        Object responseEntity = null;\n        if (super.isJwsRequired() || super.isJweRequired()) {\n            Client client = null;\n            if (oauthDataProvider != null) {\n                client = oauthDataProvider.getClient(oauth.getClientId());\n            }\n            responseEntity = super.processJwt(new JwtToken(userInfo), client);\n        } else {\n            responseEntity = convertUserInfoToResponseEntity(userInfo);\n        }\n        return Response.ok(responseEntity).build();\n\n// bug_end\n     }\n \n", "target": "// fix_start\nprivate Document getXmlDoc() {\n    if (this.xmlDoc != null) {\n      return this.xmlDoc;\n// fix_end\n// fix_start\n    try {\n      final DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();\n      factory.setExpandEntityReferences(false);\n      this.xmlDoc = factory.newDocumentBuilder()\n        .parse(new ByteArrayInputStream(this.xmlString.getBytes(StandardCharsets.UTF_8)));\n      return xmlDoc;\n    } catch (SAXException | IOException | ParserConfigurationException e) {\n      throw new RuntimeException(\"\u975e\u6cd5\u7684xml\u6587\u672c\u5185\u5bb9\uff1a\" + this.xmlString);\n    }\n\n  }\n\n// fix_end\n", "cwe": "CWE-611", "cwe_name": "Improper Restriction of XML External Entity Reference ('XXE')", "idx": 70826}
{"source": "// bug_start\n@Before\n    public void createCaptor() throws Exception {\n        applicationEventPublisher = mock(ApplicationEventPublisher.class);\n        ClientAdminEventPublisher eventPublisher = (ClientAdminEventPublisher) getWebApplicationContext().getBean(\"clientAdminEventPublisher\");\n        originalApplicationEventPublisher = eventPublisher.getPublisher();\n        eventPublisher.setApplicationEventPublisher(applicationEventPublisher);\n        captor = ArgumentCaptor.forClass(AbstractUaaEvent.class);\n        scimUserEndpoints = getWebApplicationContext().getBean(ScimUserEndpoints.class);\n        scimGroupEndpoints = getWebApplicationContext().getBean(ScimGroupEndpoints.class);\n// bug_end\n \n// bug_start\n        testClient = new TestClient(getMockMvc());\n        testAccounts = UaaTestAccounts.standard(null);\n        adminToken = testClient.getClientCredentialsOAuthAccessToken(\n                testAccounts.getAdminClientId(),\n                testAccounts.getAdminClientSecret(),\n                \"clients.admin clients.read clients.write clients.secret scim.read scim.write\");\n// bug_end\n \n// bug_start\n        testPassword = \"password\";\n        String username = new RandomValueStringGenerator().generate() + \"@test.org\";\n        testUser = new ScimUser(null, username, \"givenname\",\"familyname\");\n        testUser.setPrimaryEmail(username);\n        testUser.setPassword(testPassword);\n        testUser = MockMvcUtils.utils().createUser(getMockMvc(), adminToken, testUser);\n        testUser.setPassword(testPassword);\n// bug_end\n \n// bug_start\n        applicationEventPublisher = mock(ApplicationEventPublisher.class);\n        eventPublisher.setApplicationEventPublisher(applicationEventPublisher);\n        captor = ArgumentCaptor.forClass(AbstractUaaEvent.class);\n// bug_end\n     }\n \n", "target": "// fix_start\n@GET\n    @Produces({\"application/json\", \"application/jwt\" })\n    public Response getUserInfo() {\n        OAuthContext oauth = OAuthContextUtils.getContext(mc);\n// fix_end\n// fix_start\n        if (!oauth.getPermissions().stream()\n            .map(OAuthPermission::getPermission)\n            .anyMatch(OidcUtils.OPENID_SCOPE::equals)) {\n            Response.status(401);\n        }\n// fix_end\n// fix_start\n        UserInfo userInfo = null;\n        if (userInfoProvider != null) {\n            userInfo = userInfoProvider.getUserInfo(oauth.getClientId(), oauth.getSubject(),\n                OAuthUtils.convertPermissionsToScopeList(oauth.getPermissions()));\n        } else if (oauth.getSubject() instanceof OidcUserSubject) {\n            OidcUserSubject oidcUserSubject = (OidcUserSubject)oauth.getSubject();\n            userInfo = oidcUserSubject.getUserInfo();\n            if (userInfo == null) {\n                userInfo = createFromIdToken(oidcUserSubject.getIdToken());\n            }\n        }\n        if (userInfo == null) {\n            return Response.serverError().build();\n        }\n// fix_end\n// fix_start\n        Object responseEntity = null;\n        if (super.isJwsRequired() || super.isJweRequired()) {\n            Client client = null;\n            if (oauthDataProvider != null) {\n                client = oauthDataProvider.getClient(oauth.getClientId());\n            }\n            responseEntity = super.processJwt(new JwtToken(userInfo), client);\n        } else {\n            responseEntity = convertUserInfoToResponseEntity(userInfo);\n        }\n        return Response.ok(responseEntity).build();\n\n// fix_end\n", "cwe": "CWE-863", "cwe_name": "Incorrect Authorization", "idx": 88925}
{"source": "// bug_start\nprivate boolean isSensitiveValue(ModelNode value) {\n            if (value.getType() == ModelType.EXPRESSION\n                    || value.getType() == ModelType.STRING) {\n                String valueString = value.asString();\n                return VAULT_EXPRESSION_PATTERN.matcher(valueString).matches();\n            }\n            return false;\n        }\n// bug_end\n \n", "target": "// fix_start\n@Before\n    public void createCaptor() throws Exception {\n        applicationEventPublisher = mock(ApplicationEventPublisher.class);\n        ClientAdminEventPublisher eventPublisher = (ClientAdminEventPublisher) getWebApplicationContext().getBean(\"clientAdminEventPublisher\");\n        originalApplicationEventPublisher = eventPublisher.getPublisher();\n        eventPublisher.setApplicationEventPublisher(applicationEventPublisher);\n        captor = ArgumentCaptor.forClass(AbstractUaaEvent.class);\n        scimUserEndpoints = getWebApplicationContext().getBean(ScimUserEndpoints.class);\n        scimGroupEndpoints = getWebApplicationContext().getBean(ScimGroupEndpoints.class);\n// fix_end\n// fix_start\n        testClient = new TestClient(getMockMvc());\n        testAccounts = org.cloudfoundry.identity.uaa.test.UaaTestAccounts.standard(null);\n        adminToken = testClient.getClientCredentialsOAuthAccessToken(\n                testAccounts.getAdminClientId(),\n                testAccounts.getAdminClientSecret(),\n                \"clients.admin clients.read clients.write clients.secret scim.read scim.write\");\n\n        testPassword = \"password\";\n        String username = new RandomValueStringGenerator().generate() + \"@test.org\";\n        testUser = new ScimUser(null, username, \"givenname\",\"familyname\");\n        testUser.setPrimaryEmail(username);\n        testUser.setPassword(testPassword);\n        testUser = MockMvcUtils.utils().createUser(getMockMvc(), adminToken, testUser);\n        testUser.setPassword(testPassword);\n\n        applicationEventPublisher = mock(ApplicationEventPublisher.class);\n        eventPublisher.setApplicationEventPublisher(applicationEventPublisher);\n        captor = ArgumentCaptor.forClass(AbstractUaaEvent.class);\n    }\n\n// fix_end\n", "cwe": "CWE-89", "cwe_name": "Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection')", "idx": 92767}
{"source": "// bug_start\nprivate boolean isSensitiveValue(ModelNode value) {\n            if (value.getType() == ModelType.EXPRESSION\n                    || value.getType() == ModelType.STRING) {\n                String valueString = value.asString();\n                if (ExpressionResolver.EXPRESSION_PATTERN.matcher(valueString).matches()) {\n                    int start = valueString.indexOf(\"${\") + 2;\n                    int end = valueString.indexOf(\"}\", start);\n                    valueString = valueString.substring(start, end);\n                    return VaultReader.STANDARD_VAULT_PATTERN.matcher(valueString).matches();\n// bug_end\n                 }\n             }\n// bug_start\n            return false;\n        }\n// bug_end\n \n", "target": "// fix_start\npublic void execute(ActionInvocation invocation) throws Exception {\n\t\tactionName = conditionalParse(actionName, invocation);\n\t\tString portletNamespace = (String)invocation.getInvocationContext().get(PortletConstants.PORTLET_NAMESPACE);\n\t\tif (portletMode != null) {\n\t\t\tMap<PortletMode, String> namespaceMap = getNamespaceMap(invocation);\n\t\t\tnamespace = namespaceMap.get(portletMode);\n\t\t}\n\t\tif (namespace == null) {\n\t\t\tnamespace = invocation.getProxy().getNamespace();\n\t\t\tparseLocation = false;\n\t\t} else {\n\t\t\tnamespace = conditionalParse(namespace, invocation);\n\t\t}\n\t\tif (method == null) {\n\t\t\tmethod = \"\";\n\t\t} else {\n\t\t\tmethod = conditionalParse(method, invocation);\n\t\t}\n\n\t\tString resultCode = invocation.getResultCode();\n\t\tif (resultCode != null) {\n\t\t\tResultConfig resultConfig = invocation.getProxy().getConfig().getResults().get(resultCode);\n\t\t\tMap<String, String> resultConfigParams = resultConfig.getParams();\n            for (Map.Entry<String, String> e : resultConfigParams.entrySet()) {\n                if (!prohibitedResultParam.contains(e.getKey())) {\n                    requestParameters.put(e.getKey(), e.getValue() == null ? \"\" : conditionalParse(e.getValue(), invocation));\n// fix_end\n// fix_start\n\t\t}\n// fix_end\n// fix_start\n\t\tStringBuilder tmpLocation = new StringBuilder(actionMapper.getUriFromActionMapping(new ActionMapping(actionName,\n\t\t\t\t(portletNamespace == null ? namespace : portletNamespace + namespace), method, null)));\n\t\turlHelper.buildParametersString(requestParameters, tmpLocation, \"&\");\n\n\t\tsetLocation(tmpLocation.toString());\n\n\t\tsuper.execute(invocation);\n\t}\n\n// fix_end\n", "cwe": "NVD-CWE-noinfo", "cwe_name": "", "idx": 98145}
{"source": " public static XMLReader createXmlReader() throws SAXException, ParserConfigurationException {\n \t\tSAXParserFactory spf = SAXParserFactory.newInstance();\n// bug_start\n// bug_end\n \n \t\tSAXParser saxParser = spf.newSAXParser();\n \n// bug_start\n\t\tXMLReader reader = saxParser.getXMLReader();\n\n\t\treader.setFeature(\"http://xml.org/sax/features/namespaces\", true);\n\n\t\treturn reader;\n// bug_end\n \t}\n \n", "target": "// fix_start\n\t\tspf.setFeature(\"http://apache.org/xml/features/disallow-doctype-decl\", true);\n\t\tspf.setFeature(\"http://xml.org/sax/features/external-general-entities\", false);\n\t\tspf.setFeature(\"http://xml.org/sax/features/external-parameter-entities\", false);\n\t\tspf.setFeature(\"http://xml.org/sax/features/namespaces\", true);\n// fix_end\n// fix_start\n\t\treturn saxParser.getXMLReader();\n// fix_end\n", "cwe": "CWE-611", "cwe_name": "Improper Restriction of XML External Entity Reference ('XXE')", "idx": 67183}
{"source": " private void init() {\n         authMap = new HashMap<Pair<String, String>, String>();\n \n// bug_start\n        DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();\n        dbf.setNamespaceAware(true);\n// bug_end\n         try {\n// bug_start\n            DocumentBuilder db = dbf.newDocumentBuilder();\n            Document doc = db.parse(getClass().getResource(\"/\" + authorizations).openStream());\n// bug_end\n             doc.getDocumentElement().normalize();\n \n             Node authNode = null;\n             NodeList root = doc.getChildNodes();\n             for (int i = 0; i < root.getLength() && authNode == null; i++) {\n                 if (\"auth\".equals(root.item(i).getNodeName())) {\n                     authNode = root.item(i);\n                 }\n             }\n             if (authNode == null) {\n                 throw new IllegalArgumentException(\"Could not find root <auth> node\");\n             }\n \n             NodeList pages = authNode.getChildNodes();\n             for (int i = 0; i < pages.getLength(); i++) {\n                 if (\"page\".equals(pages.item(i).getNodeName())) {\n                     String page = pages.item(i).getAttributes().getNamedItem(\"id\").getTextContent();\n \n                     NodeList actions = pages.item(i).getChildNodes();\n                     for (int j = 0; j < actions.getLength(); j++) {\n                         if (\"action\".equals(actions.item(j).getNodeName())) {\n                             String action = actions.item(j).getAttributes().getNamedItem(\"id\").getTextContent();\n \n                             NodeList entitlements = actions.item(j).getChildNodes();\n                             for (int k = 0; k < entitlements.getLength(); k++) {\n                                 if (\"entitlement\".equals(entitlements.item(k).getNodeName())) {\n                                     String entitlement = entitlements.item(k).getTextContent();\n                                     authMap.put(new ImmutablePair<String, String>(page, action), entitlement);\n                                 }\n                             }\n                         }\n                     }\n                 }\n             }\n         } catch (Exception e) {\n             LOG.error(\"While initializing parsing of {}\", authorizations, e);\n         }\n     }\n \n", "target": "// fix_start\n// fix_end\n// fix_start\n            Document doc = StaxUtils.read(getClass().getResource(\"/\" + authorizations).openStream());\n// fix_end\n", "cwe": "CWE-20", "cwe_name": "Improper Input Validation", "idx": 6083}
{"source": " public static String resolvePath(String uri) {\n// bug_start\n\t\tString path = URI.create(uri).getPath();\n// bug_end\n \t\tif (!path.isEmpty()) {\n \t\t\tif(path.charAt(0) == '/'){\n \t\t\t\tpath = path.substring(1);\n \t\t\t\tif(path.length() <= 1){\n \t\t\t\t\treturn path;\n \t\t\t\t}\n \t\t\t}\n \t\t\tif(path.charAt(path.length() - 1) == '/'){\n \t\t\t\treturn path.substring(0, path.length() - 1);\n \t\t\t}\n \t\t}\n \t\treturn path;\n \t}\n \n", "target": "// fix_start\n\t\tif (uri.isEmpty()) {\n\t\t\treturn uri;\n\t\t}\n\n\t\tString path;\n\t\tif (uri.charAt(0) == '/') {\n\t\t\tpath = uri;\n\t\t\tfor (int i = 0; i < path.length(); i++) {\n\t\t\t\tchar c = path.charAt(i);\n\t\t\t\tif (c == '?' || c == '#') {\n\t\t\t\t\tpath = path.substring(0, i);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tpath = URI.create(uri).getPath();\n\t\t}\n// fix_end\n", "cwe": "CWE-755", "cwe_name": "Improper Handling of Exceptional Conditions", "idx": 74840}
{"source": " public void testInsecureParameters() throws Exception {\n         loadConfigurationProviders(new XWorkConfigurationProvider(), new XmlConfigurationProvider(\"xwork-param-test.xml\"));\n         final Map<String, Object> params = new HashMap<String, Object>() {\n             {\n                 put(\"name\", \"(#context[\\\"xwork.MethodAccessor.denyMethodExecution\\\"]= new \" +\n                         \"java.lang.Boolean(false), #_memberAccess[\\\"allowStaticMethodAccess\\\"]= new java.lang.Boolean(true), \" +\n                         \"@java.lang.Runtime@getRuntime().exec('mkdir /tmp/PWNAGE'))(meh)\");\n                 put(\"top['name'](0)\", \"true\");\n// bug_start\n// bug_end\n             }\n         };\n \n         ParametersInterceptor pi = new ParametersInterceptor();\n         container.inject(pi);\n         ValueStack vs = ActionContext.getContext().getValueStack();\n \n         ValidateAction action = new ValidateAction();\n         pi.setParameters(action, vs, params);\n \n// bug_start\n        assertEquals(2, action.getActionMessages().size());\n// bug_end\n \n         String msg1 = action.getActionMessage(0);\n         String msg2 = action.getActionMessage(1);\n// bug_start\n// bug_end\n \n// bug_start\n        assertEquals(\"Error setting expression 'name' with value '(#context[\\\"xwork.MethodAccessor.denyMethodExecution\\\"]= new java.lang.Boolean(false), #_memberAccess[\\\"allowStaticMethodAccess\\\"]= new java.lang.Boolean(true), @java.lang.Runtime@getRuntime().exec('mkdir /tmp/PWNAGE'))(meh)'\", msg1);\n        assertEquals(\"Error setting expression 'top['name'](0)' with value 'true'\", msg2);\n// bug_end\n         assertNull(action.getName());\n     }\n \n", "target": "// fix_start\n                put(\"expression\", \"#f=#_memberAccess.getClass().getDeclaredField('allowStaticMethodAccess'),#f.setAccessible(true),#f.set(#_memberAccess,true),#req=@org.apache.struts2.ServletActionContext@getRequest(),#resp=@org.apache.struts2.ServletActionContext@getResponse().getWriter(),#resp.println(#req.getRealPath('/')),#resp.close()\");\n// fix_end\n// fix_start\n        assertEquals(3, action.getActionMessages().size());\n// fix_end\n// fix_start\n        String msg3 = action.getActionMessage(2);\n// fix_end\n// fix_start\n        assertEquals(\"Error setting expression 'expression' with value '#f=#_memberAccess.getClass().getDeclaredField('allowStaticMethodAccess'),#f.setAccessible(true),#f.set(#_memberAccess,true),#req=@org.apache.struts2.ServletActionContext@getRequest(),#resp=@org.apache.struts2.ServletActionContext@getResponse().getWriter(),#resp.println(#req.getRealPath('/')),#resp.close()'\", msg1);\n        assertEquals(\"Error setting expression 'name' with value '(#context[\\\"xwork.MethodAccessor.denyMethodExecution\\\"]= new java.lang.Boolean(false), #_memberAccess[\\\"allowStaticMethodAccess\\\"]= new java.lang.Boolean(true), @java.lang.Runtime@getRuntime().exec('mkdir /tmp/PWNAGE'))(meh)'\", msg2);\n        assertEquals(\"Error setting expression 'top['name'](0)' with value 'true'\", msg3);\n// fix_end\n", "cwe": "CWE-264", "cwe_name": "Permissions, Privileges, and Access Controls", "idx": 30652}
{"source": " Augmentations handleStartElement(QName element, XMLAttributes attributes, Augmentations augs) {\n \n         if (DEBUG) {\n             System.out.println(\"==>handleStartElement: \" + element);\n         }\n \n         if (fElementDepth == -1 && fValidationManager.isGrammarFound()) {\n// bug_start\n            if (fSchemaType == null) {\n// bug_end\n                 fSchemaDynamicValidation = true;\n             } else {\n             }\n \n         }\n \n         if (!fUseGrammarPoolOnly) {\n             String sLocation =\n                 attributes.getValue(SchemaSymbols.URI_XSI, SchemaSymbols.XSI_SCHEMALOCATION);\n             String nsLocation =\n                 attributes.getValue(SchemaSymbols.URI_XSI, SchemaSymbols.XSI_NONAMESPACESCHEMALOCATION);\n             storeLocations(sLocation, nsLocation);\n         }\n \n         if (fSkipValidationDepth >= 0) {\n             fElementDepth++;\n             if (fAugPSVI)\n             \taugs = getEmptyAugs(augs);\n             return augs;\n         }\n \n         Object decl = null;\n         if (fCurrentCM != null) {\n             decl = fCurrentCM.oneTransition(element, fCurrCMState, fSubGroupHandler);\n             if (fCurrCMState[0] == XSCMValidator.FIRST_ERROR) {\n                 XSComplexTypeDecl ctype = (XSComplexTypeDecl) fCurrentType;\n                 Vector next;\n                 if (ctype.fParticle != null\n                     && (next = fCurrentCM.whatCanGoHere(fCurrCMState)).size() > 0) {\n                     String expected = expectedStr(next);\n                     final int[] occurenceInfo = fCurrentCM.occurenceInfo(fCurrCMState);\n                     String elemExpandedQname = (element.uri != null) ? \"{\"+'\"'+element.uri+'\"'+\":\"+element.localpart+\"}\" : element.localpart;\n                     if (occurenceInfo != null) {\n                         final int minOccurs = occurenceInfo[0];\n                         final int maxOccurs = occurenceInfo[1];\n                         final int count = occurenceInfo[2];\n                         if (count < minOccurs) {\n                             final int required = minOccurs - count;\n                             if (required > 1) {\n                                 reportSchemaError(\"cvc-complex-type.2.4.h\", new Object[] { element.rawname,\n                                         fCurrentCM.getTermName(occurenceInfo[3]), Integer.toString(minOccurs), Integer.toString(required) });\n                             }\n                             else {\n                                 reportSchemaError(\"cvc-complex-type.2.4.g\", new Object[] { element.rawname,\n                                         fCurrentCM.getTermName(occurenceInfo[3]), Integer.toString(minOccurs) });\n                             }\n                         }\n                         else if (count >= maxOccurs && maxOccurs != SchemaSymbols.OCCURRENCE_UNBOUNDED) {\n                             reportSchemaError(\"cvc-complex-type.2.4.e\", new Object[] { element.rawname,\n                                     expected, Integer.toString(maxOccurs) });\n                         }\n                         else {\n                             reportSchemaError(\"cvc-complex-type.2.4.a\", new Object[] { elemExpandedQname, expected });\n                         }\n                     }\n                     else {\n                         reportSchemaError(\"cvc-complex-type.2.4.a\", new Object[] { elemExpandedQname, expected });\n                     }\n                 }\n                 else {\n                     final int[] occurenceInfo = fCurrentCM.occurenceInfo(fCurrCMState);\n                     if (occurenceInfo != null) {\n                         final int maxOccurs = occurenceInfo[1];\n                         final int count = occurenceInfo[2];\n                         if (count >= maxOccurs && maxOccurs != SchemaSymbols.OCCURRENCE_UNBOUNDED) {\n                             reportSchemaError(\"cvc-complex-type.2.4.f\", new Object[] { fCurrentCM.getTermName(occurenceInfo[3]), Integer.toString(maxOccurs) });\n                         }\n                         else {\n                             reportSchemaError(\"cvc-complex-type.2.4.d\", new Object[] { element.rawname });\n                         }\n                     }\n                     else {\n                         reportSchemaError(\"cvc-complex-type.2.4.d\", new Object[] { element.rawname });\n                     }\n                 }\n             }\n         }\n \n         if (fElementDepth != -1) {\n             ensureStackCapacity();\n             fSubElementStack[fElementDepth] = true;\n             fSubElement = false;\n             fElemDeclStack[fElementDepth] = fCurrentElemDecl;\n             fNilStack[fElementDepth] = fNil;\n             fNotationStack[fElementDepth] = fNotation;\n             fTypeStack[fElementDepth] = fCurrentType;\n             fStrictAssessStack[fElementDepth] = fStrictAssess;\n             fCMStack[fElementDepth] = fCurrentCM;\n             fCMStateStack[fElementDepth] = fCurrCMState;\n             fSawTextStack[fElementDepth] = fSawText;\n             fStringContent[fElementDepth] = fSawCharacters;\n         }\n \n         fElementDepth++;\n         fCurrentElemDecl = null;\n         XSWildcardDecl wildcard = null;\n         fCurrentType = null;\n         fStrictAssess = true;\n         fNil = false;\n         fNotation = null;\n \n         fBuffer.setLength(0);\n         fSawText = false;\n         fSawCharacters = false;\n \n         if (decl != null) {\n             if (decl instanceof XSElementDecl) {\n                 fCurrentElemDecl = (XSElementDecl) decl;\n             } else {\n                 wildcard = (XSWildcardDecl) decl;\n             }\n         }\n \n         if (wildcard != null && wildcard.fProcessContents == XSWildcardDecl.PC_SKIP) {\n             fSkipValidationDepth = fElementDepth;\n             if (fAugPSVI)\n                 augs = getEmptyAugs(augs);\n             return augs;\n         }\n \n         if (fElementDepth == 0) {\n             if (fRootElementDeclaration != null) {\n                 fCurrentElemDecl = fRootElementDeclaration;\n                 checkElementMatchesRootElementDecl(fCurrentElemDecl, element);\n             }\n             else if (fRootElementDeclQName != null) {\n                 processRootElementDeclQName(fRootElementDeclQName, element);\n             }\n             else if (fRootTypeDefinition != null) {\n                 fCurrentType = fRootTypeDefinition;\n             }\n             else if (fRootTypeQName != null) {\n                 processRootTypeQName(fRootTypeQName);\n             }\n         }\n \n         if (fCurrentType == null) {\n             if (fCurrentElemDecl == null) {\n                 SchemaGrammar sGrammar =\n                     findSchemaGrammar(\n                         XSDDescription.CONTEXT_ELEMENT,\n                         element.uri,\n                         null,\n                         element,\n                         attributes);\n                 if (sGrammar != null) {\n                     fCurrentElemDecl = sGrammar.getGlobalElementDecl(element.localpart);\n                 }\n             }\n \n             if (fCurrentElemDecl != null) {\n                 fCurrentType = fCurrentElemDecl.fType;\n             }\n         }\n \n         if (fElementDepth == fIgnoreXSITypeDepth && fCurrentElemDecl == null) {\n             fIgnoreXSITypeDepth++;\n         }\n \n         String xsiType = null;\n         if (fElementDepth >= fIgnoreXSITypeDepth) {\n             xsiType = attributes.getValue(SchemaSymbols.URI_XSI, SchemaSymbols.XSI_TYPE);\n         }\n \n         if (fCurrentType == null && xsiType == null) {\n             if (fElementDepth == 0) {\n                 if (fDynamicValidation || fSchemaDynamicValidation) {\n                     if (fDocumentSource != null) {\n                         fDocumentSource.setDocumentHandler(fDocumentHandler);\n                         if (fDocumentHandler != null)\n                             fDocumentHandler.setDocumentSource(fDocumentSource);\n                         fElementDepth = -2;\n                         return augs;\n                     }\n \n                     fSkipValidationDepth = fElementDepth;\n                     if (fAugPSVI)\n                         augs = getEmptyAugs(augs);\n                     return augs;\n                 }\n                 fXSIErrorReporter.fErrorReporter.reportError(\n                     XSMessageFormatter.SCHEMA_DOMAIN,\n                     \"cvc-elt.1.a\",\n                     new Object[] { element.rawname },\n                     XMLErrorReporter.SEVERITY_ERROR);\n             }\n             else if (wildcard != null && wildcard.fProcessContents == XSWildcardDecl.PC_STRICT) {\n                 reportSchemaError(\"cvc-complex-type.2.4.c\", new Object[] { element.rawname });\n             }\n             fCurrentType = SchemaGrammar.fAnyType;\n             fStrictAssess = false;\n             fNFullValidationDepth = fElementDepth;\n             fAppendBuffer = false;\n \n             fXSIErrorReporter.pushContext();\n         } else {\n             fXSIErrorReporter.pushContext();\n \n             if (xsiType != null) {\n                 XSTypeDefinition oldType = fCurrentType;\n                 fCurrentType = getAndCheckXsiType(element, xsiType, attributes);\n                 if (fCurrentType == null) {\n                     if (oldType == null)\n                         fCurrentType = SchemaGrammar.fAnyType;\n                     else\n                         fCurrentType = oldType;\n                 }\n             }\n \n             fNNoneValidationDepth = fElementDepth;\n             if (fCurrentElemDecl != null\n                 && fCurrentElemDecl.getConstraintType() == XSConstants.VC_FIXED) {\n                 fAppendBuffer = true;\n             }\n             else if (fCurrentType.getTypeCategory() == XSTypeDefinition.SIMPLE_TYPE) {\n                 fAppendBuffer = true;\n             } else {\n                 XSComplexTypeDecl ctype = (XSComplexTypeDecl) fCurrentType;\n                 fAppendBuffer = (ctype.fContentType == XSComplexTypeDecl.CONTENTTYPE_SIMPLE);\n             }\n         }\n \n         if (fCurrentElemDecl != null && fCurrentElemDecl.getAbstract())\n             reportSchemaError(\"cvc-elt.2\", new Object[] { element.rawname });\n \n         if (fElementDepth == 0) {\n             fValidationRoot = element.rawname;\n         }\n \n         if (fNormalizeData) {\n             fFirstChunk = true;\n             fTrailing = false;\n             fUnionType = false;\n             fWhiteSpace = -1;\n         }\n \n         if (fCurrentType.getTypeCategory() == XSTypeDefinition.COMPLEX_TYPE) {\n             XSComplexTypeDecl ctype = (XSComplexTypeDecl) fCurrentType;\n             if (ctype.getAbstract()) {\n                 reportSchemaError(\"cvc-type.2\", new Object[] { element.rawname });\n             }\n             if (fNormalizeData) {\n                 if (ctype.fContentType == XSComplexTypeDecl.CONTENTTYPE_SIMPLE) {\n                     if (ctype.fXSSimpleType.getVariety() == XSSimpleType.VARIETY_UNION) {\n                         fUnionType = true;\n                     } else {\n                         try {\n                             fWhiteSpace = ctype.fXSSimpleType.getWhitespace();\n                         } catch (DatatypeException e) {\n                         }\n                     }\n                 }\n             }\n         }\n         else if (fNormalizeData) {\n             XSSimpleType dv = (XSSimpleType) fCurrentType;\n             if (dv.getVariety() == XSSimpleType.VARIETY_UNION) {\n                 fUnionType = true;\n             } else {\n                 try {\n                     fWhiteSpace = dv.getWhitespace();\n                 } catch (DatatypeException e) {\n                 }\n             }\n         }\n \n         fCurrentCM = null;\n         if (fCurrentType.getTypeCategory() == XSTypeDefinition.COMPLEX_TYPE) {\n             fCurrentCM = ((XSComplexTypeDecl) fCurrentType).getContentModel(fCMBuilder);\n         }\n \n         fCurrCMState = null;\n         if (fCurrentCM != null)\n             fCurrCMState = fCurrentCM.startContentModel();\n \n         String xsiNil = attributes.getValue(SchemaSymbols.URI_XSI, SchemaSymbols.XSI_NIL);\n         if (xsiNil != null && fCurrentElemDecl != null)\n             fNil = getXsiNil(element, xsiNil);\n \n         XSAttributeGroupDecl attrGrp = null;\n         if (fCurrentType.getTypeCategory() == XSTypeDefinition.COMPLEX_TYPE) {\n             XSComplexTypeDecl ctype = (XSComplexTypeDecl) fCurrentType;\n             attrGrp = ctype.getAttrGrp();\n         }\n \n         if (fIDCChecking) {\n             fValueStoreCache.startElement();\n             fMatcherStack.pushContext();\n             if (fCurrentElemDecl != null && fCurrentElemDecl.fIDCPos > 0) {\n                 fIdConstraint = true;\n                 fValueStoreCache.initValueStoresFor(fCurrentElemDecl, this);\n             }\n         }\n         processAttributes(element, attributes, attrGrp);\n \n         if (attrGrp != null) {\n             addDefaultAttributes(element, attributes, attrGrp);\n         }\n \n         int count = fMatcherStack.getMatcherCount();\n         for (int i = 0; i < count; i++) {\n             XPathMatcher matcher = fMatcherStack.getMatcherAt(i);\n             matcher.startElement( element, attributes);\n         }\n \n         if (fAugPSVI) {\n             augs = getEmptyAugs(augs);\n \n             fCurrentPSVI.fValidationContext = fValidationRoot;\n             fCurrentPSVI.fDeclaration = fCurrentElemDecl;\n             fCurrentPSVI.fTypeDecl = fCurrentType;\n             fCurrentPSVI.fNotation = fNotation;\n             fCurrentPSVI.fNil = fNil;\n         }\n \n         return augs;\n \n     }\n \n", "target": "// fix_start\n            if (fSchemaType == null && !fUseGrammarPoolOnly) {\n// fix_end\n", "cwe": "CWE-20", "cwe_name": "Improper Input Validation", "idx": 11596}
{"source": " private void handleDynamicMethodInvocation(ActionMapping mapping, String name) {\n         int exclamation = name.lastIndexOf(\"!\");\n         if (exclamation != -1) {\n             String actionName = name.substring(0, exclamation);\n             String actionMethod = name.substring(exclamation + 1);\n \n             int scPos = actionMethod.indexOf(';');\n             if (scPos != -1) {\n                 actionName = actionName + actionMethod.substring(scPos);\n                 actionMethod = actionMethod.substring(0, scPos);\n             }\n \n             mapping.setName(actionName);\n             if (allowDynamicMethodCalls) {\n// bug_start\n                mapping.setMethod(actionMethod);\n// bug_end\n             } else {\n                 mapping.setMethod(null);\n             }\n         }\n     }\n \n", "target": "// fix_start\n                mapping.setMethod(cleanupActionName(actionMethod));\n// fix_end\n", "cwe": "CWE-20", "cwe_name": "Improper Input Validation", "idx": 10610}
{"source": "// bug_start\npublic Document readFrom(Class<Document> clazz, Type type,\n                            Annotation[] annotations, MediaType mediaType,\n                            MultivaluedMap<String, String> headers, InputStream input)\n           throws IOException, WebApplicationException\n// bug_end\n    {\n// bug_start\n      try\n// bug_end\n       {\n// bug_start\n         documentBuilder.setExpandEntityReferences(expandEntityReferences);\n         documentBuilder.setFeature(XMLConstants.FEATURE_SECURE_PROCESSING, enableSecureProcessingFeature);\n         documentBuilder.setFeature(\"http://apache.org/xml/features/disallow-doctype-decl\", disableDTDs);\n         return documentBuilder.newDocumentBuilder().parse(input);\n// bug_end\n       }\n// bug_start\n      catch (Exception e)\n      {\n         throw new ReaderException(e);\n      }\n// bug_end\n    }\n \n", "target": "// fix_start\nvoid doMaxAttributesFails() throws Exception\n// fix_end\n// fix_start\n      DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();\n      System.out.println(\"dbf.getClass(): \" + dbf.getClass());\n      if (\"org.apache.xerces.jaxp.DocumentBuilderFactoryImpl\".equals(dbf.getClass().getName()))\n// fix_end\n// fix_start\n         System.out.println(\"Testing with Red Hat version of Xerces, skipping max attributes test\");\n         return;\n// fix_end\n// fix_start\n      System.out.println(\"entering doMaxAttributesFails()\");\n      ClientRequest request = new ClientRequest(generateURL(\"/test\"));\n      request.body(\"application/xml\", bigAttributeDoc);\n      ClientResponse<?> response = request.post();\n      System.out.println(\"doMaxAttributesFails() status: \" + response.getStatus());\n      String entity = response.getEntity(String.class);\n      System.out.println(\"doMaxAttributesFails() result: \" + entity);\n      Assert.assertEquals(400, response.getStatus());\n      Assert.assertTrue(entity.contains(\"org.xml.sax.SAXParseException\"));\n      Assert.assertTrue(entity.contains(\"has more than \\\"10,00\"));\n      int pos = entity.indexOf(\"has more than \\\"10,00\");\n      Assert.assertTrue(entity.substring(pos).contains(\"attributes\"));\n// fix_end\n", "cwe": "CWE-20", "cwe_name": "Improper Input Validation", "idx": 10774}
{"source": "// bug_start\nvoid doMaxAttributesFails() throws Exception\n// bug_end\n    {\n// bug_start\n      System.out.println(\"entering doMaxAttributesFails()\");\n      ClientRequest request = new ClientRequest(generateURL(\"/test\"));\n      request.body(\"application/xml\", bigAttributeDoc);\n      ClientResponse<?> response = request.post();\n      System.out.println(\"doMaxAttributesFails() status: \" + response.getStatus());\n      String entity = response.getEntity(String.class);\n      System.out.println(\"doMaxAttributesFails() result: \" + entity);\n      Assert.assertEquals(400, response.getStatus());\n      Assert.assertTrue(entity.contains(\"org.xml.sax.SAXParseException\"));\n      Assert.assertTrue(entity.contains(\"has more than \\\"10,00\"));\n      int pos = entity.indexOf(\"has more than \\\"10,00\");\n      Assert.assertTrue(entity.substring(pos).contains(\"attributes\"));\n// bug_end\n    }\n \n", "target": "// fix_start\npublic Document readFrom(Class<Document> clazz, Type type,\n                            Annotation[] annotations, MediaType mediaType,\n                            MultivaluedMap<String, String> headers, InputStream input)\n           throws IOException, WebApplicationException\n// fix_end\n// fix_start\n      try\n      {\n         documentBuilder.setExpandEntityReferences(expandEntityReferences);\n         documentBuilder.setFeature(\"http://xml.org/sax/features/external-general-entities\", expandEntityReferences);\n         documentBuilder.setFeature(\"http://xml.org/sax/features/external-parameter-entities\", expandEntityReferences);\n         documentBuilder.setFeature(XMLConstants.FEATURE_SECURE_PROCESSING, enableSecureProcessingFeature);\n         documentBuilder.setFeature(\"http://apache.org/xml/features/disallow-doctype-decl\", disableDTDs);\n         return documentBuilder.newDocumentBuilder().parse(input);\n      }\n      catch (Exception e)\n      {\n         throw new ReaderException(e);\n      }\n// fix_end\n", "cwe": "CWE-20", "cwe_name": "Improper Input Validation", "idx": 10788}
{"source": "// bug_start\nprivate void openConnection() {\n        if (!connectionOpened) {\n            connectionOpened = true;\n            URLConnection connection = null;\n            try {\n                try {\n                    connection = url.openConnection();\n                } catch (IOException e) {\n                    lastModified = null;\n                    contentLength = null;\n                    return;\n                }\n                lastModified =  new Date(connection.getLastModified());\n                contentLength = connection.getContentLengthLong();\n            } finally {\n                if (connection != null) {\n// bug_end\n                     try {\n// bug_start\n                        IoUtils.safeClose(connection.getInputStream());\n                    } catch (IOException e) {\n// bug_end\n                     }\n// bug_start\n                }\n            }\n// bug_end\n         }\n     }\n \n", "target": "// fix_start\nprivate void prepareRequest() {\n\n        byte methodCode = requestHeaderMessage.getByte();\n        if (methodCode != Constants.SC_M_JK_STORED) {\n            String methodName = Constants.getMethodForCode(methodCode - 1);\n            request.method().setString(methodName);\n        }\n\n        requestHeaderMessage.getBytes(request.protocol());\n        requestHeaderMessage.getBytes(request.requestURI());\n\n        requestHeaderMessage.getBytes(request.remoteAddr());\n        requestHeaderMessage.getBytes(request.remoteHost());\n        requestHeaderMessage.getBytes(request.localName());\n        request.setLocalPort(requestHeaderMessage.getInt());\n\n        boolean isSSL = requestHeaderMessage.getByte() != 0;\n        if (isSSL) {\n            request.scheme().setString(\"https\");\n        }\n\n        MimeHeaders headers = request.getMimeHeaders();\n\n        headers.setLimit(protocol.getMaxHeaderCount());\n\n        boolean contentLengthSet = false;\n        int hCount = requestHeaderMessage.getInt();\n        for(int i = 0 ; i < hCount ; i++) {\n            String hName = null;\n\n            int isc = requestHeaderMessage.peekInt();\n            int hId = isc & 0xFF;\n\n            MessageBytes vMB = null;\n            isc &= 0xFF00;\n            if(0xA000 == isc) {\n                requestHeaderMessage.getInt();\n                hName = Constants.getHeaderForCode(hId - 1);\n                vMB = headers.addValue(hName);\n            } else {\n                hId = -1;\n                requestHeaderMessage.getBytes(tmpMB);\n                ByteChunk bc = tmpMB.getByteChunk();\n                vMB = headers.addValue(bc.getBuffer(),\n                        bc.getStart(), bc.getLength());\n            }\n\n            requestHeaderMessage.getBytes(vMB);\n\n            if (hId == Constants.SC_REQ_CONTENT_LENGTH ||\n                    (hId == -1 && tmpMB.equalsIgnoreCase(\"Content-Length\"))) {\n                long cl = vMB.getLong();\n                if (contentLengthSet) {\n                    response.setStatus(HttpServletResponse.SC_BAD_REQUEST);\n                    setErrorState(ErrorState.CLOSE_CLEAN, null);\n                } else {\n                    contentLengthSet = true;\n                    request.setContentLength(cl);\n                }\n            } else if (hId == Constants.SC_REQ_CONTENT_TYPE ||\n                    (hId == -1 && tmpMB.equalsIgnoreCase(\"Content-Type\"))) {\n                ByteChunk bchunk = vMB.getByteChunk();\n                request.contentType().setBytes(bchunk.getBytes(),\n                        bchunk.getOffset(),\n                        bchunk.getLength());\n            }\n        }\n\n        String secret = protocol.getSecret();\n        boolean secretPresentInRequest = false;\n        byte attributeCode;\n        while ((attributeCode = requestHeaderMessage.getByte())\n                != Constants.SC_A_ARE_DONE) {\n\n            switch (attributeCode) {\n\n            case Constants.SC_A_REQ_ATTRIBUTE :\n                requestHeaderMessage.getBytes(tmpMB);\n                String n = tmpMB.toString();\n                requestHeaderMessage.getBytes(tmpMB);\n                String v = tmpMB.toString();\n                if(n.equals(Constants.SC_A_REQ_LOCAL_ADDR)) {\n                    request.localAddr().setString(v);\n                } else if(n.equals(Constants.SC_A_REQ_REMOTE_PORT)) {\n// fix_end\n// fix_start\n                        request.setRemotePort(Integer.parseInt(v));\n                    } catch (NumberFormatException nfe) {\n// fix_end\n// fix_start\n                } else if(n.equals(Constants.SC_A_SSL_PROTOCOL)) {\n                    request.setAttribute(SSLSupport.PROTOCOL_VERSION_KEY, v);\n                } else if (n.equals(\"JK_LB_ACTIVATION\")) {\n                    request.setAttribute(n, v);\n                } else if (javaxAttributes.contains(n)) {\n                    request.setAttribute(n, v);\n                } else {\n                    Pattern pattern = protocol.getAllowedRequestAttributesPatternInternal();\n                    if (pattern == null) {\n                        response.setStatus(403);\n                        setErrorState(ErrorState.CLOSE_CLEAN, null);\n                    } else {\n                        Matcher m = pattern.matcher(n);\n                        if (m.matches()) {\n                            request.setAttribute(n, v);\n                        } else {\n                            response.setStatus(403);\n                            setErrorState(ErrorState.CLOSE_CLEAN, null);\n                        }\n                    }\n                }\n                break;\n\n            case Constants.SC_A_CONTEXT :\n                requestHeaderMessage.getBytes(tmpMB);\n                break;\n\n            case Constants.SC_A_SERVLET_PATH :\n                requestHeaderMessage.getBytes(tmpMB);\n                break;\n\n            case Constants.SC_A_REMOTE_USER :\n                boolean tomcatAuthorization  = protocol.getTomcatAuthorization();\n                if (tomcatAuthorization || !protocol.getTomcatAuthentication()) {\n                    requestHeaderMessage.getBytes(request.getRemoteUser());\n                    request.setRemoteUserNeedsAuthorization(tomcatAuthorization);\n                } else {\n                    requestHeaderMessage.getBytes(tmpMB);\n                }\n                break;\n\n            case Constants.SC_A_AUTH_TYPE :\n                if (protocol.getTomcatAuthentication()) {\n                    requestHeaderMessage.getBytes(tmpMB);\n                } else {\n                    requestHeaderMessage.getBytes(request.getAuthType());\n                }\n                break;\n\n            case Constants.SC_A_QUERY_STRING :\n                requestHeaderMessage.getBytes(request.queryString());\n                break;\n\n            case Constants.SC_A_JVM_ROUTE :\n                requestHeaderMessage.getBytes(tmpMB);\n                break;\n\n            case Constants.SC_A_SSL_CERT :\n                requestHeaderMessage.getBytes(certificates);\n                break;\n\n            case Constants.SC_A_SSL_CIPHER :\n                requestHeaderMessage.getBytes(tmpMB);\n                request.setAttribute(SSLSupport.CIPHER_SUITE_KEY,\n                        tmpMB.toString());\n                break;\n\n            case Constants.SC_A_SSL_SESSION :\n                requestHeaderMessage.getBytes(tmpMB);\n                request.setAttribute(SSLSupport.SESSION_ID_KEY,\n                        tmpMB.toString());\n                break;\n\n            case Constants.SC_A_SSL_KEY_SIZE :\n                request.setAttribute(SSLSupport.KEY_SIZE_KEY,\n                        Integer.valueOf(requestHeaderMessage.getInt()));\n                break;\n\n            case Constants.SC_A_STORED_METHOD:\n                requestHeaderMessage.getBytes(request.method());\n                break;\n\n            case Constants.SC_A_SECRET:\n                requestHeaderMessage.getBytes(tmpMB);\n                if (secret != null) {\n                    secretPresentInRequest = true;\n                    if (!tmpMB.equals(secret)) {\n                        response.setStatus(403);\n                        setErrorState(ErrorState.CLOSE_CLEAN, null);\n                    }\n                }\n                break;\n\n            default:\n                break;\n\n            }\n\n        }\n\n        if ((secret != null) && !secretPresentInRequest) {\n            response.setStatus(403);\n            setErrorState(ErrorState.CLOSE_CLEAN, null);\n        }\n\n        ByteChunk uriBC = request.requestURI().getByteChunk();\n        if (uriBC.startsWithIgnoreCase(\"http\", 0)) {\n\n            int pos = uriBC.indexOf(\"://\", 0, 3, 4);\n            int uriBCStart = uriBC.getStart();\n            int slashPos = -1;\n            if (pos != -1) {\n                byte[] uriB = uriBC.getBytes();\n                slashPos = uriBC.indexOf('/', pos + 3);\n                if (slashPos == -1) {\n                    slashPos = uriBC.getLength();\n                    request.requestURI().setBytes\n                    (uriB, uriBCStart + pos + 1, 1);\n                } else {\n                    request.requestURI().setBytes\n                    (uriB, uriBCStart + slashPos,\n                            uriBC.getLength() - slashPos);\n                }\n                MessageBytes hostMB = headers.setValue(\"host\");\n                hostMB.setBytes(uriB, uriBCStart + pos + 3,\n                        slashPos - pos - 3);\n            }\n\n        }\n\n        MessageBytes valueMB = request.getMimeHeaders().getValue(\"host\");\n        parseHost(valueMB);\n\n        if (!getErrorState().isIoAllowed()) {\n            getAdapter().log(request, response, 0);\n// fix_end\n", "cwe": "NVD-CWE-Other", "cwe_name": "Other", "idx": 112580}
{"source": "// bug_start\nprotected List<String> getRoles(JNDIConnection connection, User user) throws NamingException {\n\n        if (user == null) {\n            return null;\n        }\n\n        String dn = user.getDN();\n        String username = user.getUserName();\n        String userRoleId = user.getUserRoleId();\n\n        if (dn == null || username == null) {\n            return null;\n        }\n\n        if (containerLog.isTraceEnabled()) {\n            containerLog.trace(\"  getRoles(\" + dn + \")\");\n        }\n\n        List<String> list = new ArrayList<>();\n        List<String> userRoles = user.getRoles();\n        if (userRoles != null) {\n            list.addAll(userRoles);\n        }\n        if (commonRole != null) {\n            list.add(commonRole);\n        }\n\n        if (containerLog.isTraceEnabled()) {\n            containerLog.trace(\"  Found \" + list.size() + \" user internal roles\");\n            containerLog.trace(\"  Found user internal roles \" + list.toString());\n        }\n\n        if ((connection.roleFormat == null) || (roleName == null)) {\n            return list;\n        }\n\n        String filter = connection.roleFormat.format(new String[] {\n                doFilterEscaping(dn),\n                doFilterEscaping(doAttributeValueEscaping(username)),\n                doFilterEscaping(doAttributeValueEscaping(userRoleId)) });\n        SearchControls controls = new SearchControls();\n        if (roleSubtree) {\n            controls.setSearchScope(SearchControls.SUBTREE_SCOPE);\n        } else {\n            controls.setSearchScope(SearchControls.ONELEVEL_SCOPE);\n        }\n        controls.setReturningAttributes(new String[] {roleName});\n\n        String base = null;\n        if (connection.roleBaseFormat != null) {\n            NameParser np = connection.context.getNameParser(\"\");\n            Name name = np.parse(dn);\n            String nameParts[] = new String[name.size()];\n            for (int i = 0; i < name.size(); i++) {\n                nameParts[i] = name.get(i);\n            }\n            base = connection.roleBaseFormat.format(nameParts);\n        } else {\n            base = \"\";\n        }\n\n        NamingEnumeration<SearchResult> results = searchAsUser(connection.context, user, base, filter, controls,\n                isRoleSearchAsUser());\n\n        if (results == null) {\n            return list;\n        }\n\n        Map<String, String> groupMap = new HashMap<>();\n        try {\n            while (results.hasMore()) {\n                SearchResult result = results.next();\n                Attributes attrs = result.getAttributes();\n                if (attrs == null) {\n                    continue;\n// bug_end\n                 }\n// bug_start\n                String dname = getDistinguishedName(connection.context, base, result);\n                String name = getAttributeValue(roleName, attrs);\n                if (name != null && dname != null) {\n                    groupMap.put(dname, name);\n// bug_end\n                 }\n             }\n// bug_start\n        } catch (PartialResultException ex) {\n            if (!adCompat) {\n                throw ex;\n            }\n        } finally {\n            results.close();\n// bug_end\n         }\n// bug_start\n\n        if (containerLog.isTraceEnabled()) {\n            Set<Entry<String, String>> entries = groupMap.entrySet();\n            containerLog.trace(\"  Found \" + entries.size() + \" direct roles\");\n            for (Entry<String, String> entry : entries) {\n                containerLog.trace(  \"  Found direct role \" + entry.getKey() + \" -> \" + entry.getValue());\n            }\n        }\n\n        if (getRoleNested()) {\n\n\n            Map<String, String> newGroups = new HashMap<>(groupMap);\n            while (!newGroups.isEmpty()) {\n                Map<String, String> newThisRound = new HashMap<>();\n\n                for (Entry<String, String> group : newGroups.entrySet()) {\n                    filter = connection.roleFormat.format(new String[] {\n                            doFilterEscaping(group.getKey()),\n                            doFilterEscaping(doAttributeValueEscaping(group.getValue())),\n                            doFilterEscaping(doAttributeValueEscaping(group.getValue())) });\n\n                    if (containerLog.isTraceEnabled()) {\n                        containerLog.trace(\"Perform a nested group search with base \"+ roleBase +\n                                \" and filter \" + filter);\n                    }\n\n                    results = searchAsUser(connection.context, user, base, filter, controls, isRoleSearchAsUser());\n\n                    try {\n                        while (results.hasMore()) {\n                            SearchResult result = results.next();\n                            Attributes attrs = result.getAttributes();\n                            if (attrs == null) {\n                                continue;\n                            }\n                            String dname = getDistinguishedName(connection.context, roleBase, result);\n                            String name = getAttributeValue(roleName, attrs);\n                            if (name != null && dname != null && !groupMap.keySet().contains(dname)) {\n                                groupMap.put(dname, name);\n                                newThisRound.put(dname, name);\n\n                                if (containerLog.isTraceEnabled()) {\n                                    containerLog.trace(\"  Found nested role \" + dname + \" -> \" + name);\n                                }\n                            }\n                        }\n                    } catch (PartialResultException ex) {\n                        if (!adCompat) {\n                            throw ex;\n                        }\n                    } finally {\n                        results.close();\n                    }\n                }\n\n                newGroups = newThisRound;\n            }\n        }\n\n        list.addAll(groupMap.values());\n        return list;\n// bug_end\n     }\n \n", "target": "// fix_start\nprivate void openConnection() {\n        if (!connectionOpened) {\n            connectionOpened = true;\n            URLConnection connection = null;\n            try {\n                try {\n                    connection = url.openConnection();\n                } catch (IOException e) {\n                    lastModified = null;\n                    contentLength = null;\n                    return;\n// fix_end\n// fix_start\n                if (url.getProtocol().equals(\"jar\")) {\n                    connection.setUseCaches(false);\n                    URL jar = ((JarURLConnection) connection).getJarFileURL();\n                    lastModified = new Date(new File(jar.getFile()).lastModified());\n                } else {\n                    lastModified = new Date(connection.getLastModified());\n                }\n                contentLength = connection.getContentLengthLong();\n            } finally {\n                if (connection != null) {\n                    try {\n                        IoUtils.safeClose(connection.getInputStream());\n                    } catch (IOException e) {\n                    }\n// fix_end\n// fix_start\n// fix_end\n// fix_start\n// fix_end\n", "cwe": "CWE-400", "cwe_name": "Uncontrolled Resource Consumption", "idx": 52392}
{"source": "// bug_start\nprotected List<String> getRoles(JNDIConnection connection, User user) throws NamingException {\n\n        if (user == null) {\n            return null;\n// bug_end\n         }\n// bug_start\n\n        String dn = user.getDN();\n        String username = user.getUserName();\n        String userRoleId = user.getUserRoleId();\n\n        if (dn == null || username == null) {\n            return null;\n        }\n\n        if (containerLog.isTraceEnabled()) {\n            containerLog.trace(\"  getRoles(\" + dn + \")\");\n        }\n\n        List<String> list = new ArrayList<>();\n        List<String> userRoles = user.getRoles();\n        if (userRoles != null) {\n            list.addAll(userRoles);\n        }\n        if (commonRole != null) {\n            list.add(commonRole);\n        }\n\n        if (containerLog.isTraceEnabled()) {\n            containerLog.trace(\"  Found \" + list.size() + \" user internal roles\");\n            containerLog.trace(\"  Found user internal roles \" + list.toString());\n        }\n\n        if ((connection.roleFormat == null) || (roleName == null)) {\n            return list;\n        }\n\n        String filter = connection.roleFormat.format(new String[] {\n                doFilterEscaping(dn),\n                doFilterEscaping(doAttributeValueEscaping(username)),\n                doFilterEscaping(doAttributeValueEscaping(userRoleId)) });\n        SearchControls controls = new SearchControls();\n        if (roleSubtree) {\n            controls.setSearchScope(SearchControls.SUBTREE_SCOPE);\n        } else {\n            controls.setSearchScope(SearchControls.ONELEVEL_SCOPE);\n        }\n        controls.setReturningAttributes(new String[] {roleName});\n\n        String base = null;\n        if (connection.roleBaseFormat != null) {\n            NameParser np = connection.context.getNameParser(\"\");\n            Name name = np.parse(dn);\n            String nameParts[] = new String[name.size()];\n            for (int i = 0; i < name.size(); i++) {\n                nameParts[i] = name.get(i);\n            }\n            base = connection.roleBaseFormat.format(nameParts);\n        } else {\n            base = \"\";\n        }\n\n        NamingEnumeration<SearchResult> results = searchAsUser(connection.context, user, base, filter, controls,\n                isRoleSearchAsUser());\n\n        if (results == null) {\n            return list;\n        }\n\n        Map<String, String> groupMap = new HashMap<>();\n        try {\n            while (results.hasMore()) {\n                SearchResult result = results.next();\n                Attributes attrs = result.getAttributes();\n                if (attrs == null) {\n                    continue;\n                }\n                String dname = getDistinguishedName(connection.context, roleBase, result);\n                String name = getAttributeValue(roleName, attrs);\n                if (name != null && dname != null) {\n                    groupMap.put(dname, name);\n                }\n            }\n        } catch (PartialResultException ex) {\n            if (!adCompat) {\n                throw ex;\n            }\n        } finally {\n            results.close();\n        }\n\n        if (containerLog.isTraceEnabled()) {\n            Set<Entry<String, String>> entries = groupMap.entrySet();\n            containerLog.trace(\"  Found \" + entries.size() + \" direct roles\");\n            for (Entry<String, String> entry : entries) {\n                containerLog.trace(  \"  Found direct role \" + entry.getKey() + \" -> \" + entry.getValue());\n            }\n        }\n\n        if (getRoleNested()) {\n\n\n            Map<String, String> newGroups = new HashMap<>(groupMap);\n            while (!newGroups.isEmpty()) {\n                Map<String, String> newThisRound = new HashMap<>();\n\n                for (Entry<String, String> group : newGroups.entrySet()) {\n                    filter = connection.roleFormat.format(new String[] {\n                            doFilterEscaping(group.getKey()),\n                            doFilterEscaping(doAttributeValueEscaping(group.getValue())),\n                            doFilterEscaping(doAttributeValueEscaping(group.getValue())) });\n\n                    if (containerLog.isTraceEnabled()) {\n                        containerLog.trace(\"Perform a nested group search with base \"+ roleBase +\n                                \" and filter \" + filter);\n                    }\n\n                    results = searchAsUser(connection.context, user, roleBase, filter, controls, isRoleSearchAsUser());\n\n                    try {\n                        while (results.hasMore()) {\n                            SearchResult result = results.next();\n                            Attributes attrs = result.getAttributes();\n                            if (attrs == null) {\n                                continue;\n                            }\n                            String dname = getDistinguishedName(connection.context, roleBase, result);\n                            String name = getAttributeValue(roleName, attrs);\n                            if (name != null && dname != null && !groupMap.keySet().contains(dname)) {\n                                groupMap.put(dname, name);\n                                newThisRound.put(dname, name);\n\n                                if (containerLog.isTraceEnabled()) {\n                                    containerLog.trace(\"  Found nested role \" + dname + \" -> \" + name);\n                                }\n                            }\n                        }\n                    } catch (PartialResultException ex) {\n                        if (!adCompat) {\n                            throw ex;\n                        }\n                    } finally {\n                        results.close();\n                    }\n                }\n\n                newGroups = newThisRound;\n            }\n        }\n\n        list.addAll(groupMap.values());\n        return list;\n// bug_end\n     }\n \n", "target": "// fix_start\npublic String getPasswordValue(Object o) {\n        if (o==null)    return null;\n        if (o instanceof Secret)    return ((Secret)o).getEncryptedValue();\n        if (getIsUnitTest()) {\n            throw new SecurityException(\"attempted to render plaintext \u2018\" + o + \"\u2019 in password field; use a getter of type Secret instead\");\n// fix_end\n// fix_start\n        return o.toString();\n// fix_end\n", "cwe": "CWE-116", "cwe_name": "Improper Encoding or Escaping of Output", "idx": 419}
{"source": "// bug_start\npublic void updateByXml(final InputStream source) throws IOException, ServletException {\n        checkPermission(CONFIGURE);\n        Node previous = getNode();\n        if (previous == null) {\n            throw HttpResponses.notFound();\n// bug_end\n         }\n// bug_start\n        Node result = (Node)Jenkins.XSTREAM2.fromXML(source);\n        if (previous.getClass() != result.getClass()) {\n            throw HttpResponses.errorWithoutStack(SC_BAD_REQUEST, \"Node types do not match\");\n// bug_end\n         }\n// bug_start\n        Jenkins.get().getNodesObject().replaceNode(previous, result);\n// bug_end\n     }\n \n", "target": "// fix_start\npublic String getPasswordValue(Object o) {\n        if (o==null)    return null;\n        if (o instanceof Secret) {\n            StaplerRequest req = Stapler.getCurrentRequest();\n            if (req != null) {\n                Item item = req.findAncestorObject(Item.class);\n                if (item != null && !item.hasPermission(Item.CONFIGURE)) {\n                    return \"<some secret>\";\n                }\n            }\n            return ((Secret) o).getEncryptedValue();\n// fix_end\n// fix_start\n        if (getIsUnitTest()) {\n            throw new SecurityException(\"attempted to render plaintext \u2018\" + o + \"\u2019 in password field; use a getter of type Secret instead\");\n// fix_end\n// fix_start\n        return o.toString();\n// fix_end\n", "cwe": "CWE-200", "cwe_name": "Exposure of Sensitive Information to an Unauthorized Actor", "idx": 15029}
{"source": "// bug_start\npublic void updateByXml(final InputStream source) throws IOException, ServletException {\n        checkPermission(CONFIGURE);\n        Node result = (Node)Jenkins.XSTREAM2.fromXML(source);\n        Jenkins.get().getNodesObject().replaceNode(this.getNode(), result);\n// bug_end\n     }\n \n", "target": "// fix_start\npublic void performTest()\n        throws Exception\n    {\n        byte[]  testIv = { 1, 2, 3, 4, 5, 6, 7, 8 };\n\n        ASN1Encodable[]     values = {\n            new CAST5CBCParameters(testIv, 128),\n            new NetscapeCertType(NetscapeCertType.smime),\n            new VerisignCzagExtension(new DERIA5String(\"hello\")),\n            new IDEACBCPar(testIv),\n            new NetscapeRevocationURL(new DERIA5String(\"http://test\"))\n        };\n\n        byte[] data = Base64.decode(\"MA4ECAECAwQFBgcIAgIAgAMCBSAWBWhlbGxvMAoECAECAwQFBgcIFgtodHRwOi8vdGVzdA==\");\n\n        ByteArrayOutputStream bOut = new ByteArrayOutputStream();\n        ASN1OutputStream aOut = new ASN1OutputStream(bOut);\n\n        for (int i = 0; i != values.length; i++)\n        {\n            aOut.writeObject(values[i]);\n        }\n\n        ASN1Primitive[] readValues = new ASN1Primitive[values.length];\n\n        if (!isSameAs(bOut.toByteArray(), data))\n        {\n            fail(\"Failed data check\");\n        }\n\n        ByteArrayInputStream bIn = new ByteArrayInputStream(bOut.toByteArray());\n        ASN1InputStream aIn = new ASN1InputStream(bIn);\n\n        for (int i = 0; i != values.length; i++)\n        {\n            ASN1Primitive o = aIn.readObject();\n            if (!values[i].equals(o))\n            {\n                fail(\"Failed equality test for \" + o);\n            }\n\n            if (o.hashCode() != values[i].hashCode())\n            {\n                fail(\"Failed hashCode test for \" + o);\n            }\n        }\n\n        shouldFailOnExtraData();\n// fix_end\n", "cwe": "CWE-20", "cwe_name": "Improper Input Validation", "idx": 6876}
{"source": "// bug_start\nprotected String getRemoteAddr(RequestCycle requestCycle)\n\t{\n\t\tServletWebRequest request = (ServletWebRequest)requestCycle.getRequest();\n\t\treturn request.getContainerRequest().getRemoteAddr();\n\t}\n// bug_end\n \n", "target": "// fix_start\npublic void performTest()\n        throws Exception\n    {\n        byte[]  testIv = { 1, 2, 3, 4, 5, 6, 7, 8 };\n// fix_end\n// fix_start\n        ASN1Encodable[]     values = {\n            new CAST5CBCParameters(testIv, 128),\n            new NetscapeCertType(NetscapeCertType.smime),\n            new VerisignCzagExtension(new DERIA5String(\"hello\")),\n            new IDEACBCPar(testIv),\n            new NetscapeRevocationURL(new DERIA5String(\"http://test\"))\n        };\n\n        byte[] data = Base64.decode(\"MA4ECAECAwQFBgcIAgIAgAMCBSAWBWhlbGxvMAoECAECAwQFBgcIFgtodHRwOi8vdGVzdA==\");\n\n        ByteArrayOutputStream bOut = new ByteArrayOutputStream();\n        ASN1OutputStream aOut = new ASN1OutputStream(bOut);\n\n        for (int i = 0; i != values.length; i++)\n        {\n            aOut.writeObject(values[i]);\n        }\n\n        ASN1Primitive[] readValues = new ASN1Primitive[values.length];\n\n        if (!isSameAs(bOut.toByteArray(), data))\n        {\n            fail(\"Failed data check\");\n        }\n\n        ByteArrayInputStream bIn = new ByteArrayInputStream(bOut.toByteArray());\n        ASN1InputStream aIn = new ASN1InputStream(bIn);\n\n        for (int i = 0; i != values.length; i++)\n        {\n            ASN1Primitive o = aIn.readObject();\n            if (!values[i].equals(o))\n            {\n                fail(\"Failed equality test for \" + o);\n            }\n\n            if (o.hashCode() != values[i].hashCode())\n            {\n                fail(\"Failed hashCode test for \" + o);\n            }\n        }\n\n        shouldFailOnExtraData();\n        derIntegerTest();\n    }\n\n// fix_end\n", "cwe": "CWE-347", "cwe_name": "Improper Verification of Cryptographic Signature", "idx": 43474}
{"source": "// bug_start\nprotected String getRemoteAddr(RequestCycle requestCycle)\n\t{\n\t\tServletWebRequest request = (ServletWebRequest)requestCycle.getRequest();\n\t\tHttpServletRequest req = request.getContainerRequest();\n\t\tString remoteAddr = request.getHeader(\"X-Forwarded-For\");\n// bug_end\n \n// bug_start\n\t\tif (remoteAddr != null)\n\t\t{\n\t\t\tif (remoteAddr.contains(\",\"))\n\t\t\t{\n\t\t\t\tremoteAddr = Strings.split(remoteAddr, ',')[0].trim();\n\t\t\t}\n\t\t\ttry\n\t\t\t{\n\t\t\t\tInetAddress.getByName(remoteAddr);\n\t\t\t}\n\t\t\tcatch (UnknownHostException e)\n\t\t\t{\n\t\t\t\tremoteAddr = req.getRemoteAddr();\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tremoteAddr = req.getRemoteAddr();\n\t\t}\n\t\treturn remoteAddr;\n\t}\n// bug_end\n \n", "target": "// fix_start\nprivate synchronized File initCacheDir() {\n        if (cacheDir != null) {\n            return cacheDir;\n        }\n// fix_end\n// fix_start\n        File cacheRoot = new File(System.getProperty(\"java.io.tmpdir\"), \"kc-gzip-cache\");\n        File cacheDir = new File(cacheRoot, Version.RESOURCES_VERSION);\n// fix_end\n// fix_start\n        if (cacheRoot.isDirectory()) {\n            for (File f : cacheRoot.listFiles()) {\n                if (!f.getName().equals(Version.RESOURCES_VERSION)) {\n                    try {\n                        FileUtils.deleteDirectory(f);\n                    } catch (IOException e) {\n                        logger.warn(\"Failed to delete old gzip cache directory\", e);\n                    }\n                }\n            }\n        }\n\n        if (!cacheDir.isDirectory() && !cacheDir.mkdirs()) {\n            logger.warn(\"Failed to create gzip cache directory\");\n            return null;\n        }\n\n        return cacheDir;\n    }\n\n// fix_end\n", "cwe": "CWE-20", "cwe_name": "Improper Input Validation", "idx": 12071}
{"source": "// bug_start\npublic static String detectDataDirectory() {\n\n        String dataPath = System.getProperty(JBOSS_SERVER_DATA_DIR);\n\n        if (dataPath != null){\n            File dataDir = new File(dataPath);\n            if (!dataDir.exists() || !dataDir.isDirectory()) {\n                throw new RuntimeException(\"Invalid \" + JBOSS_SERVER_DATA_DIR + \" resources directory: \" + dataPath);\n            }\n\n            return dataPath;\n// bug_end\n         }\n \n// bug_start\n        try {\n          File tempKeycloakFolder = Files.createTempDirectory(\"keycloak-server-\").toFile();\n          File tmpDataDir = new File(tempKeycloakFolder, \"/data\");\n// bug_end\n \n// bug_start\n          if (tmpDataDir.mkdirs()) {\n            tmpDataDir.deleteOnExit();\n          } else {\n            throw new IOException(\"Could not create directory \" + tmpDataDir);\n          }\n\n          dataPath = tmpDataDir.getAbsolutePath();\n        } catch (IOException ioe){\n          throw new RuntimeException(\"Could not create temporary \" + JBOSS_SERVER_DATA_DIR, ioe);\n// bug_end\n         }\n \n// bug_start\n        return dataPath;\n// bug_end\n     }\n \n", "target": "// fix_start\nprivate synchronized File initCacheDir() {\n        if (cacheDir != null) {\n            return cacheDir;\n// fix_end\n// fix_start\n        File cacheRoot = new File(Platform.getPlatform().getTmpDirectory(), \"kc-gzip-cache\");\n        File cacheDir = new File(cacheRoot, Version.RESOURCES_VERSION);\n// fix_end\n// fix_start\n        if (cacheRoot.isDirectory()) {\n            for (File f : cacheRoot.listFiles()) {\n                if (!f.getName().equals(Version.RESOURCES_VERSION)) {\n                    try {\n                        FileUtils.deleteDirectory(f);\n                    } catch (IOException e) {\n                        logger.warn(\"Failed to delete old gzip cache directory\", e);\n                    }\n                }\n            }\n// fix_end\n// fix_start\n        if (!cacheDir.isDirectory() && !cacheDir.mkdirs()) {\n            logger.warn(\"Failed to create gzip cache directory\");\n            return null;\n        }\n\n        return cacheDir;\n// fix_end\n", "cwe": "CWE-377", "cwe_name": "", "idx": 49469}
{"source": " public static Path getPersistedConfigFile() {\n         String homeDir = Environment.getHomeDir();\n \n         if (homeDir == null) {\n// bug_start\n            return Paths.get(System.getProperty(\"java.io.tmpdir\"), PersistedConfigSource.KEYCLOAK_PROPERTIES);\n// bug_end\n         }\n \n         return Paths.get(homeDir, \"conf\", PersistedConfigSource.KEYCLOAK_PROPERTIES);\n     }\n \n", "target": "// fix_start\n            return Paths.get(Platform.getPlatform().getTmpDirectory().toString(), PersistedConfigSource.KEYCLOAK_PROPERTIES);\n// fix_end\n", "cwe": "CWE-377", "cwe_name": "", "idx": 49451}
{"source": "// bug_start\npublic TimelineEventList doData(StaplerRequest req, @QueryParameter long min, @QueryParameter long max) throws IOException {\n        TimelineEventList result = new TimelineEventList();\n        for (Run r : builds.byTimestamp(min,max)) {\n            Event e = new Event();\n            e.start = new Date(r.getStartTimeInMillis());\n            e.end   = new Date(r.getStartTimeInMillis()+r.getDuration());\n            e.title = Util.escape(r.getFullDisplayName()).replace(\"&lt;\", \"&#60;\");\n            e.link = req.getContextPath()+'/'+r.getUrl();\n            BallColor c = r.getIconColor();\n            e.color = String.format(\"#%06X\",c.getBaseColor().darker().getRGB()&0xFFFFFF);\n            e.classname = \"event-\"+c.noAnime().toString()+\" \" + (c.isAnimated()?\"animated\":\"\");\n            result.add(e);\n// bug_end\n         }\n// bug_start\n        return result;\n// bug_end\n     }\n \n", "target": "// fix_start\npublic static String detectDataDirectory() {\n\n        String dataPath = System.getProperty(JBOSS_SERVER_DATA_DIR);\n\n        if (dataPath != null){\n            File dataDir = new File(dataPath);\n            if (!dataDir.exists() || !dataDir.isDirectory()) {\n                throw new RuntimeException(\"Invalid \" + JBOSS_SERVER_DATA_DIR + \" resources directory: \" + dataPath);\n            }\n\n            return dataPath;\n// fix_end\n// fix_start\n\n        try {\n          File tempKeycloakFolder = Platform.getPlatform().getTmpDirectory();\n          File tmpDataDir = new File(tempKeycloakFolder, \"/data\");\n\n          if (tmpDataDir.mkdirs()) {\n            tmpDataDir.deleteOnExit();\n          } else {\n            throw new IOException(\"Could not create directory \" + tmpDataDir);\n          }\n\n          dataPath = tmpDataDir.getAbsolutePath();\n        } catch (IOException ioe){\n          throw new RuntimeException(\"Could not create temporary \" + JBOSS_SERVER_DATA_DIR, ioe);\n        }\n\n        return dataPath;\n// fix_end\n", "cwe": "CWE-377", "cwe_name": "", "idx": 49485}
{"source": "// bug_start\npublic TimelineEventList doData(StaplerRequest req, @QueryParameter long min, @QueryParameter long max) throws IOException {\n        TimelineEventList result = new TimelineEventList();\n        for (Run r : builds.byTimestamp(min,max)) {\n            Event e = new Event();\n            e.start = new Date(r.getStartTimeInMillis());\n            e.end   = new Date(r.getStartTimeInMillis()+r.getDuration());\n            e.title = r.getFullDisplayName();\n            e.link = req.getContextPath()+'/'+r.getUrl();\n            BallColor c = r.getIconColor();\n            e.color = String.format(\"#%06X\",c.getBaseColor().darker().getRGB()&0xFFFFFF);\n            e.classname = \"event-\"+c.noAnime().toString()+\" \" + (c.isAnimated()?\"animated\":\"\");\n            result.add(e);\n// bug_end\n         }\n         return result;\n     }\n \n", "target": "// fix_start\npublic File createTempFile(final Project project, String prefix, String suffix,\n            final File parentDir, final boolean deleteOnExit, final boolean createFile) {\n        File result;\n        final String parent;\n        if (parentDir != null) {\n            parent = parentDir.getPath();\n        } else if (project != null && project.getProperty(MagicNames.TMPDIR) != null) {\n            parent = project.getProperty(MagicNames.TMPDIR);\n        } else {\n            parent = System.getProperty(\"java.io.tmpdir\");\n        }\n        if (prefix == null) {\n            prefix = NULL_PLACEHOLDER;\n        }\n        if (suffix == null) {\n            suffix = NULL_PLACEHOLDER;\n        }\n\n        if (createFile) {\n            try {\n                final Path parentPath = new File(parent).toPath();\n                final PosixFileAttributeView parentPosixAttributes =\n                    Files.getFileAttributeView(parentPath, PosixFileAttributeView.class);\n                result = Files.createTempFile(parentPath, prefix, suffix,\n                    parentPosixAttributes != null ? TMPFILE_ATTRIBUTES : NO_TMPFILE_ATTRIBUTES)\n                    .toFile();\n            } catch (IOException e) {\n                throw new BuildException(\"Could not create tempfile in \"\n                        + parent, e);\n            }\n        } else {\n            DecimalFormat fmt = new DecimalFormat(\"#####\");\n            synchronized (rand) {\n                do {\n                    result = new File(parent, prefix\n                            + fmt.format(rand.nextInt(Integer.MAX_VALUE)) + suffix);\n                } while (result.exists());\n            }\n        }\n\n        if (deleteOnExit) {\n            result.deleteOnExit();\n// fix_end\n", "cwe": "CWE-79", "cwe_name": "Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')", "idx": 77816}
{"source": "// bug_start\nprivate AuthenticationMechanismOutcome handleDigestHeader(HttpServerExchange exchange, final SecurityContext securityContext) {\n        DigestContext context = exchange.getAttachment(DigestContext.ATTACHMENT_KEY);\n        Map<DigestAuthorizationToken, String> parsedHeader = context.getParsedHeader();\n        Set<DigestAuthorizationToken> mandatoryTokens = EnumSet.copyOf(MANDATORY_REQUEST_TOKENS);\n        if (!supportedAlgorithms.contains(DigestAlgorithm.MD5)) {\n            mandatoryTokens.add(DigestAuthorizationToken.ALGORITHM);\n// bug_end\n         }\n// bug_start\n        if (!supportedQops.isEmpty() && !supportedQops.contains(DigestQop.AUTH)) {\n            mandatoryTokens.add(DigestAuthorizationToken.MESSAGE_QOP);\n// bug_end\n         }\n \n// bug_start\n        DigestQop qop = null;\n        if (parsedHeader.containsKey(DigestAuthorizationToken.MESSAGE_QOP)) {\n            qop = DigestQop.forName(parsedHeader.get(DigestAuthorizationToken.MESSAGE_QOP));\n            if (qop == null || !supportedQops.contains(qop)) {\n                REQUEST_LOGGER.invalidTokenReceived(DigestAuthorizationToken.MESSAGE_QOP.getName(),\n                        parsedHeader.get(DigestAuthorizationToken.MESSAGE_QOP));\n                return AuthenticationMechanismOutcome.NOT_AUTHENTICATED;\n            }\n            context.setQop(qop);\n            mandatoryTokens.add(DigestAuthorizationToken.CNONCE);\n            mandatoryTokens.add(DigestAuthorizationToken.NONCE_COUNT);\n        }\n\n        mandatoryTokens.removeAll(parsedHeader.keySet());\n        if (mandatoryTokens.size() > 0) {\n            for (DigestAuthorizationToken currentToken : mandatoryTokens) {\n                REQUEST_LOGGER.missingAuthorizationToken(currentToken.getName());\n            }\n            return AuthenticationMechanismOutcome.NOT_AUTHENTICATED;\n        }\n\n        if (!realmName.equals(parsedHeader.get(DigestAuthorizationToken.REALM))) {\n            REQUEST_LOGGER.invalidTokenReceived(DigestAuthorizationToken.REALM.getName(),\n                    parsedHeader.get(DigestAuthorizationToken.REALM));\n            return AuthenticationMechanismOutcome.NOT_AUTHENTICATED;\n        }\n\n        if(parsedHeader.containsKey(DigestAuthorizationToken.DIGEST_URI)) {\n            String uri = parsedHeader.get(DigestAuthorizationToken.DIGEST_URI);\n            String requestURI = exchange.getRequestURI();\n            if(!exchange.getQueryString().isEmpty()) {\n                requestURI = requestURI + \"?\" + exchange.getQueryString();\n            }\n            if(!uri.equals(requestURI)) {\n                requestURI = exchange.getRequestURL();\n                if(!exchange.getQueryString().isEmpty()) {\n                    requestURI = requestURI + \"?\" + exchange.getQueryString();\n                }\n                if(!uri.equals(requestURI)) {\n                    exchange.setStatusCode(StatusCodes.BAD_REQUEST);\n                    exchange.endExchange();\n                    return AuthenticationMechanismOutcome.NOT_AUTHENTICATED;\n                }\n// bug_end\n             }\n         } else {\n// bug_start\n            return AuthenticationMechanismOutcome.NOT_AUTHENTICATED;\n        }\n\n        if (parsedHeader.containsKey(DigestAuthorizationToken.OPAQUE)) {\n            if (!OPAQUE_VALUE.equals(parsedHeader.get(DigestAuthorizationToken.OPAQUE))) {\n                REQUEST_LOGGER.invalidTokenReceived(DigestAuthorizationToken.OPAQUE.getName(),\n                        parsedHeader.get(DigestAuthorizationToken.OPAQUE));\n                return AuthenticationMechanismOutcome.NOT_AUTHENTICATED;\n// bug_end\n             }\n         }\n \n// bug_start\n        DigestAlgorithm algorithm;\n        if (parsedHeader.containsKey(DigestAuthorizationToken.ALGORITHM)) {\n            algorithm = DigestAlgorithm.forName(parsedHeader.get(DigestAuthorizationToken.ALGORITHM));\n            if (algorithm == null || !supportedAlgorithms.contains(algorithm)) {\n                REQUEST_LOGGER.invalidTokenReceived(DigestAuthorizationToken.ALGORITHM.getName(),\n                        parsedHeader.get(DigestAuthorizationToken.ALGORITHM));\n                return AuthenticationMechanismOutcome.NOT_AUTHENTICATED;\n            }\n        } else {\n            algorithm = DigestAlgorithm.MD5;\n// bug_end\n         }\n// bug_start\n\n        try {\n            context.setAlgorithm(algorithm);\n        } catch (NoSuchAlgorithmException e) {\n            REQUEST_LOGGER.exceptionProcessingRequest(e);\n            return AuthenticationMechanismOutcome.NOT_AUTHENTICATED;\n        }\n\n        final String userName = parsedHeader.get(DigestAuthorizationToken.USERNAME);\n        final IdentityManager identityManager = getIdentityManager(securityContext);\n        final Account account;\n\n        if (algorithm.isSession()) {\n            throw new IllegalStateException(\"Not yet implemented.\");\n        } else {\n            final DigestCredential credential = new DigestCredentialImpl(context);\n            account = identityManager.verify(userName, credential);\n        }\n\n        if (account == null) {\n            securityContext.authenticationFailed(MESSAGES.authenticationFailed(userName), mechanismName);\n            return AuthenticationMechanismOutcome.NOT_AUTHENTICATED;\n        }\n\n        if (!validateNonceUse(context, parsedHeader, exchange)) {\n            context.markStale();\n            return AuthenticationMechanismOutcome.NOT_AUTHENTICATED;\n        }\n\n\n        sendAuthenticationInfoHeader(exchange);\n        securityContext.authenticationComplete(account, mechanismName, false);\n        return AuthenticationMechanismOutcome.AUTHENTICATED;\n\n\n// bug_end\n     }\n \n", "target": "// fix_start\npublic File createTempFile(final Project project, String prefix, String suffix,\n            final File parentDir, final boolean deleteOnExit, final boolean createFile) {\n        File result;\n        String p = null;\n        if (parentDir != null) {\n            p = parentDir.getPath();\n        } else if (project != null && project.getProperty(MagicNames.TMPDIR) != null) {\n            p = project.getProperty(MagicNames.TMPDIR);\n        } else if (project != null && deleteOnExit) {\n            if (project.getProperty(MagicNames.AUTO_TMPDIR) != null) {\n                p = project.getProperty(MagicNames.AUTO_TMPDIR);\n            } else {\n                final Path systemTempDirPath =\n                    new File(System.getProperty(\"java.io.tmpdir\")).toPath();\n                final PosixFileAttributeView systemTempDirPosixAttributes =\n                    Files.getFileAttributeView(systemTempDirPath, PosixFileAttributeView.class);\n                if (systemTempDirPosixAttributes != null) {\n                    try {\n                        final File projectTempDir = Files.createTempDirectory(systemTempDirPath,\n                            \"ant\", TMPDIR_ATTRIBUTES)\n                            .toFile();\n                        projectTempDir.deleteOnExit();\n                        p = projectTempDir.getAbsolutePath();\n                        project.setProperty(MagicNames.AUTO_TMPDIR, p);\n                    } catch (IOException ex) {\n                    }\n                }\n            }\n// fix_end\n// fix_start\n        final String parent = p != null ? p : System.getProperty(\"java.io.tmpdir\");\n        if (prefix == null) {\n            prefix = NULL_PLACEHOLDER;\n        }\n        if (suffix == null) {\n            suffix = NULL_PLACEHOLDER;\n// fix_end\n// fix_start\n        if (createFile) {\n            try {\n                final Path parentPath = new File(parent).toPath();\n                final PosixFileAttributeView parentPosixAttributes =\n                    Files.getFileAttributeView(parentPath, PosixFileAttributeView.class);\n                result = Files.createTempFile(parentPath, prefix, suffix,\n                    parentPosixAttributes != null ? TMPFILE_ATTRIBUTES : NO_TMPFILE_ATTRIBUTES)\n                    .toFile();\n            } catch (IOException e) {\n                throw new BuildException(\"Could not create tempfile in \"\n                        + parent, e);\n// fix_end\n// fix_start\n            DecimalFormat fmt = new DecimalFormat(\"#####\");\n            synchronized (rand) {\n                do {\n                    result = new File(parent, prefix\n                            + fmt.format(rand.nextInt(Integer.MAX_VALUE)) + suffix);\n                } while (result.exists());\n// fix_end\n// fix_start\n        if (deleteOnExit) {\n            result.deleteOnExit();\n// fix_end\n// fix_start\n        return result;\n// fix_end\n", "cwe": "NVD-CWE-Other", "cwe_name": "Other", "idx": 115682}
{"source": "// bug_start\nprivate AuthenticationMechanismOutcome handleDigestHeader(HttpServerExchange exchange, final SecurityContext securityContext) {\n        DigestContext context = exchange.getAttachment(DigestContext.ATTACHMENT_KEY);\n        Map<DigestAuthorizationToken, String> parsedHeader = context.getParsedHeader();\n        Set<DigestAuthorizationToken> mandatoryTokens = EnumSet.copyOf(MANDATORY_REQUEST_TOKENS);\n        if (!supportedAlgorithms.contains(DigestAlgorithm.MD5)) {\n            mandatoryTokens.add(DigestAuthorizationToken.ALGORITHM);\n        }\n        if (!supportedQops.isEmpty() && !supportedQops.contains(DigestQop.AUTH)) {\n            mandatoryTokens.add(DigestAuthorizationToken.MESSAGE_QOP);\n// bug_end\n         }\n \n// bug_start\n        DigestQop qop = null;\n        if (parsedHeader.containsKey(DigestAuthorizationToken.MESSAGE_QOP)) {\n            qop = DigestQop.forName(parsedHeader.get(DigestAuthorizationToken.MESSAGE_QOP));\n            if (qop == null || !supportedQops.contains(qop)) {\n                REQUEST_LOGGER.invalidTokenReceived(DigestAuthorizationToken.MESSAGE_QOP.getName(),\n                        parsedHeader.get(DigestAuthorizationToken.MESSAGE_QOP));\n                return AuthenticationMechanismOutcome.NOT_AUTHENTICATED;\n            }\n            context.setQop(qop);\n            mandatoryTokens.add(DigestAuthorizationToken.CNONCE);\n            mandatoryTokens.add(DigestAuthorizationToken.NONCE_COUNT);\n        }\n\n        mandatoryTokens.removeAll(parsedHeader.keySet());\n        if (mandatoryTokens.size() > 0) {\n            for (DigestAuthorizationToken currentToken : mandatoryTokens) {\n                REQUEST_LOGGER.missingAuthorizationToken(currentToken.getName());\n            }\n            return AuthenticationMechanismOutcome.NOT_AUTHENTICATED;\n        }\n\n        if (!realmName.equals(parsedHeader.get(DigestAuthorizationToken.REALM))) {\n            REQUEST_LOGGER.invalidTokenReceived(DigestAuthorizationToken.REALM.getName(),\n                    parsedHeader.get(DigestAuthorizationToken.REALM));\n            return AuthenticationMechanismOutcome.NOT_AUTHENTICATED;\n        }\n\n        if(parsedHeader.containsKey(DigestAuthorizationToken.DIGEST_URI)) {\n            String uri = parsedHeader.get(DigestAuthorizationToken.DIGEST_URI);\n            String requestURI = exchange.getRequestURI();\n            if(!exchange.getQueryString().isEmpty()) {\n                requestURI = requestURI + \"?\" + exchange.getQueryString();\n            }\n            if(!uri.equals(requestURI)) {\n                exchange.setStatusCode(StatusCodes.BAD_REQUEST);\n                exchange.endExchange();\n                return AuthenticationMechanismOutcome.NOT_AUTHENTICATED;\n            }\n        } else {\n            return AuthenticationMechanismOutcome.NOT_AUTHENTICATED;\n        }\n\n        if (parsedHeader.containsKey(DigestAuthorizationToken.OPAQUE)) {\n            if (!OPAQUE_VALUE.equals(parsedHeader.get(DigestAuthorizationToken.OPAQUE))) {\n                REQUEST_LOGGER.invalidTokenReceived(DigestAuthorizationToken.OPAQUE.getName(),\n                        parsedHeader.get(DigestAuthorizationToken.OPAQUE));\n                return AuthenticationMechanismOutcome.NOT_AUTHENTICATED;\n// bug_end\n             }\n         }\n \n// bug_start\n        DigestAlgorithm algorithm;\n        if (parsedHeader.containsKey(DigestAuthorizationToken.ALGORITHM)) {\n            algorithm = DigestAlgorithm.forName(parsedHeader.get(DigestAuthorizationToken.ALGORITHM));\n            if (algorithm == null || !supportedAlgorithms.contains(algorithm)) {\n                REQUEST_LOGGER.invalidTokenReceived(DigestAuthorizationToken.ALGORITHM.getName(),\n                        parsedHeader.get(DigestAuthorizationToken.ALGORITHM));\n                return AuthenticationMechanismOutcome.NOT_AUTHENTICATED;\n            }\n        } else {\n            algorithm = DigestAlgorithm.MD5;\n        }\n\n        try {\n            context.setAlgorithm(algorithm);\n        } catch (NoSuchAlgorithmException e) {\n            REQUEST_LOGGER.exceptionProcessingRequest(e);\n            return AuthenticationMechanismOutcome.NOT_AUTHENTICATED;\n        }\n\n        final String userName = parsedHeader.get(DigestAuthorizationToken.USERNAME);\n        final IdentityManager identityManager = getIdentityManager(securityContext);\n        final Account account;\n\n        if (algorithm.isSession()) {\n            throw new IllegalStateException(\"Not yet implemented.\");\n        } else {\n            final DigestCredential credential = new DigestCredentialImpl(context);\n            account = identityManager.verify(userName, credential);\n        }\n\n        if (account == null) {\n            securityContext.authenticationFailed(MESSAGES.authenticationFailed(userName), mechanismName);\n            return AuthenticationMechanismOutcome.NOT_AUTHENTICATED;\n        }\n\n        if (!validateNonceUse(context, parsedHeader, exchange)) {\n            context.markStale();\n            return AuthenticationMechanismOutcome.NOT_AUTHENTICATED;\n        }\n\n\n        sendAuthenticationInfoHeader(exchange);\n        securityContext.authenticationComplete(account, mechanismName, false);\n        return AuthenticationMechanismOutcome.AUTHENTICATED;\n\n\n// bug_end\n     }\n \n", "target": "// fix_start\npublic static long parseLong(byte[] b, int off, int len)\n        throws NumberFormatException\n    {\n        int c;\n\n        if (b == null || len <= 0 || !isDigit(c = b[off++])) {\n            throw new NumberFormatException();\n// fix_end\n// fix_start\n        long n = c - '0';\n        while (--len > 0) {\n            if (isDigit(c = b[off++]) &&\n                    (n < OVERFLOW_LIMIT || (n == OVERFLOW_LIMIT && (c - '0') < 8))) {\n                n = n * 10 + c - '0';\n            } else {\n                throw new NumberFormatException();\n// fix_end\n// fix_start\n        return n;\n// fix_end\n", "cwe": "CWE-863", "cwe_name": "Incorrect Authorization", "idx": 86556}
{"source": "// bug_start\npublic static long parseLong(byte[] b, int off, int len)\n        throws NumberFormatException\n    {\n        int c;\n\n        if (b == null || len <= 0 || !isDigit(c = b[off++])) {\n            throw new NumberFormatException();\n// bug_end\n         }\n// bug_start\n\n        long n = c - '0';\n        long m;\n\n        while (--len > 0) {\n            if (!isDigit(c = b[off++])) {\n                throw new NumberFormatException();\n            }\n            m = n * 10 + c - '0';\n\n            if (m < n) {\n                throw new NumberFormatException();\n            } else {\n                n = m;\n            }\n        }\n\n        return n;\n// bug_end\n     }\n \n", "target": "// fix_start\nprotected String cleanupActionName(final String rawActionName) {\n        if (rawActionName.matches(allowedActionNames)) {\n            return rawActionName;\n        } else {\n            if (LOG.isDebugEnabled()) {\n                LOG.debug(\"Action [#0] do not match allowed action names pattern [#1], cleaning it up!\",\n                        rawActionName, allowedActionNames);\n            }\n            String cleanActionName = rawActionName;\n            for(String chunk : rawActionName.split(allowedActionNames)) {\n                cleanActionName = cleanActionName.replace(chunk, \"\");\n            }\n            if (LOG.isDebugEnabled()) {\n                LOG.debug(\"Cleaned action name [#0]\", cleanActionName);\n            }\n            return cleanActionName;\n// fix_end\n// fix_start\n// fix_end\n", "cwe": "CWE-189", "cwe_name": "Numeric Errors", "idx": 3079}
{"source": "// bug_start\nprotected String cleanupActionName(final String rawActionName) {\n        if (rawActionName.matches(allowedActionNames)) {\n            return rawActionName;\n// bug_end\n         } else {\n// bug_start\n            String cleanActionName = rawActionName;\n            for(String chunk : rawActionName.split(allowedActionNames)) {\n                cleanActionName = cleanActionName.replace(chunk, \"\");\n            }\n            return cleanActionName;\n// bug_end\n         }\n// bug_start\n// bug_end\n     }\n// bug_start\n// bug_end\n \n", "target": "// fix_start\nprotected URI addContentToRepo(MediaPackage mp, String elementId, URI uri) throws IOException {\n    InputStream in = null;\n    HttpResponse response = null;\n    CloseableHttpClient externalHttpClient = null;\n    try {\n      if (uri.toString().startsWith(\"http\")) {\n        HttpGet get = new HttpGet(uri);\n        List<String> clusterUrls = new LinkedList<>();\n        try {\n          clusterUrls = organizationDirectoryService.getOrganization(uri.toURL()).getServers()\n                          .keySet()\n                          .stream()\n                          .collect(Collectors.toUnmodifiableList());\n        } catch (NotFoundException e) {\n          logger.warn(\"Unable to determine cluster members, will not be able to authenticate any downloads from them\", e);\n        }\n\n        if (uri.toString().matches(downloadSource)) {\n          externalHttpClient = getAuthedHttpClient();\n          response = externalHttpClient.execute(get);\n        } else if (clusterUrls.contains(uri.getScheme() + \"://\" + uri.getHost())) {\n          response = httpClient.execute(get);\n// fix_end\n// fix_start\n          externalHttpClient = getNoAuthHttpClient();\n          response = externalHttpClient.execute(get);\n// fix_end\n// fix_start\n\n        if (null == response) {\n          throw new IOException(\"Null response object from the http client, refer to code for explanation\");\n        }\n\n        int httpStatusCode = response.getStatusLine().getStatusCode();\n        if (httpStatusCode != 200) {\n          throw new IOException(uri + \" returns http \" + httpStatusCode);\n        }\n        in = response.getEntity().getContent();\n      } else if (!uri.toString().startsWith(\"file\") || testMode) {\n        in = uri.toURL().openStream();\n      } else {\n        throw new IOException(\"Refusing to fetch files from the local filesystem\");\n      }\n      String fileName = FilenameUtils.getName(uri.getPath());\n      if (isBlank(FilenameUtils.getExtension(fileName)))\n        fileName = getContentDispositionFileName(response);\n\n      if (isBlank(FilenameUtils.getExtension(fileName)))\n        throw new IOException(\"No filename extension found: \" + fileName);\n      return addContentToRepo(mp, elementId, fileName, in);\n    } finally {\n      if (in != null) {\n        in.close();\n      }\n      if (externalHttpClient != null) {\n        externalHttpClient.close();\n      }\n      httpClient.close(response);\n// fix_end\n// fix_start\n  }\n// fix_end\n", "cwe": "CWE-94", "cwe_name": "Improper Control of Generation of Code ('Code Injection')", "idx": 95049}
{"source": "// bug_start\npublic boolean matches(final byte[] message, final byte[] digest) {\n// bug_end\n \n// bug_start\n        if (message == null) {\n            return (digest == null);\n        } else if (digest == null) {\n            return false;\n// bug_end\n         }\n \n// bug_start\n        if (!isInitialized()) {\n            initialize();\n// bug_end\n         }\n \n// bug_start\n        try {\n// bug_end\n \n// bug_start\n            byte[] salt = null;\n            if (this.useSalt) {\n                if (this.saltGenerator.includePlainSaltInEncryptionResults()) {\n// bug_end\n \n// bug_start\n                    int digestSaltSize = this.saltSizeBytes;\n                    if (this.digestLengthBytes > 0) {\n                        if (this.useLenientSaltSizeCheck) {\n                            if (digest.length < this.digestLengthBytes) {\n                                throw new EncryptionOperationNotPossibleException();\n                            }\n                            digestSaltSize = digest.length - this.digestLengthBytes;\n                        } else {\n                            if (digest.length != (this.digestLengthBytes + this.saltSizeBytes)) {\n                                throw new EncryptionOperationNotPossibleException();\n                            }\n                        }\n                    } else {\n                        if (digest.length < this.saltSizeBytes) {\n                            throw new EncryptionOperationNotPossibleException();\n                        }\n                    }\n\n                    if (!this.invertPositionOfPlainSaltInEncryptionResults) {\n                        salt = new byte[digestSaltSize];\n                        System.arraycopy(digest, 0, salt, 0, digestSaltSize);\n                    } else {\n                        salt = new byte[digestSaltSize];\n                        System.arraycopy(digest, digest.length - digestSaltSize, salt, 0, digestSaltSize);\n                    }\n\n                } else {\n                    salt = this.saltGenerator.generateSalt(this.saltSizeBytes);\n                }\n            }\n\n            final byte[] encryptedMessage = digest(message, salt);\n\n            return (Arrays.equals(encryptedMessage, digest));\n\n        } catch (Exception e) {\n            throw new EncryptionOperationNotPossibleException();\n        }\n\n    }\n\n// bug_end\n", "target": "// fix_start\nprotected URI addContentToRepo(MediaPackage mp, String elementId, URI uri) throws IOException {\n    InputStream in = null;\n    HttpResponse response = null;\n    CloseableHttpClient externalHttpClient = null;\n    try {\n      if (uri.toString().startsWith(\"http\")) {\n        HttpGet get = new HttpGet(uri);\n        var clusterUrls = securityService.getOrganization().getServers().keySet();\n// fix_end\n// fix_start\n        if (uri.toString().matches(downloadSource)) {\n          externalHttpClient = getAuthedHttpClient();\n          response = externalHttpClient.execute(get);\n        } else if (clusterUrls.contains(uri.getScheme() + \"://\" + uri.getHost())) {\n          response = httpClient.execute(get);\n        } else {\n          externalHttpClient = getNoAuthHttpClient();\n          response = externalHttpClient.execute(get);\n// fix_end\n// fix_start\n        if (null == response) {\n          throw new IOException(\"Null response object from the http client, refer to code for explanation\");\n// fix_end\n// fix_start\n        int httpStatusCode = response.getStatusLine().getStatusCode();\n        if (httpStatusCode != 200) {\n          throw new IOException(uri + \" returns http \" + httpStatusCode);\n        }\n        in = response.getEntity().getContent();\n      } else if (!uri.toString().startsWith(\"file\") || testMode) {\n        in = uri.toURL().openStream();\n      } else {\n        throw new IOException(\"Refusing to fetch files from the local filesystem\");\n      }\n      String fileName = FilenameUtils.getName(uri.getPath());\n      if (isBlank(FilenameUtils.getExtension(fileName)))\n        fileName = getContentDispositionFileName(response);\n// fix_end\n// fix_start\n      if (isBlank(FilenameUtils.getExtension(fileName)))\n        throw new IOException(\"No filename extension found: \" + fileName);\n      return addContentToRepo(mp, elementId, fileName, in);\n    } finally {\n      if (in != null) {\n        in.close();\n      }\n      if (externalHttpClient != null) {\n        externalHttpClient.close();\n      }\n      httpClient.close(response);\n    }\n  }\n// fix_end\n", "cwe": "CWE-287", "cwe_name": "Improper Authentication", "idx": 38967}
{"source": "// bug_start\nprotected Result findResult(String path, String resultCode, String ext, ActionContext actionContext,\n                                Map<String, ResultTypeConfig> resultsByExtension) {\n// bug_end\n         try {\n// bug_start\n            boolean traceEnabled = LOG.isTraceEnabled();\n            if (traceEnabled) {\n                LOG.trace(\"Checking ServletContext for [#0]\", path);\n// bug_end\n             }\n \n// bug_start\n            URL resource = servletContext.getResource(path);\n            if (resource != null && resource.getPath().endsWith(path)) {\n                if (traceEnabled) {\n                    LOG.trace(\"Found resource #0\", resource);\n                }\n                return buildResult(path, resultCode, resultsByExtension.get(ext), actionContext);\n            }\n// bug_end\n \n// bug_start\n            if (traceEnabled) {\n                LOG.trace(\"Checking ClassLoader for #0\", path);\n            }\n// bug_end\n \n// bug_start\n            String classLoaderPath = path.startsWith(\"/\") ? path.substring(1, path.length()) : path;\n            resource = ClassLoaderUtil.getResource(classLoaderPath, getClass());\n            if (resource != null && resource.getPath().endsWith(classLoaderPath)) {\n                if (traceEnabled) {\n                    LOG.trace(\"Found resource #0\", resource);\n                }\n                return buildResult(path, resultCode, resultsByExtension.get(ext), actionContext);\n            }\n        } catch (MalformedURLException e) {\n            if (LOG.isErrorEnabled()) {\n                LOG.error(\"Unable to parse template path: [#0] skipping...\", path);\n            }\n// bug_end\n         }\n \n// bug_start\n        return null;\n// bug_end\n     }\n \n", "target": "// fix_start\npublic boolean matches(final byte[] message, final byte[] digest) {\n\n        if (message == null) {\n            return (digest == null);\n        } else if (digest == null) {\n            return false;\n        }\n\n        if (!isInitialized()) {\n            initialize();\n        }\n\n// fix_end\n// fix_start\n\n            byte[] salt = null;\n            if (this.useSalt) {\n                if (this.saltGenerator.includePlainSaltInEncryptionResults()) {\n\n                    int digestSaltSize = this.saltSizeBytes;\n                    if (this.digestLengthBytes > 0) {\n                        if (this.useLenientSaltSizeCheck) {\n                            if (digest.length < this.digestLengthBytes) {\n                                throw new EncryptionOperationNotPossibleException();\n                            }\n                            digestSaltSize = digest.length - this.digestLengthBytes;\n                        } else {\n                            if (digest.length != (this.digestLengthBytes + this.saltSizeBytes)) {\n                                throw new EncryptionOperationNotPossibleException();\n                            }\n                        }\n                    } else {\n                        if (digest.length < this.saltSizeBytes) {\n                            throw new EncryptionOperationNotPossibleException();\n                        }\n                    }\n\n                    if (!this.invertPositionOfPlainSaltInEncryptionResults) {\n                        salt = new byte[digestSaltSize];\n                        System.arraycopy(digest, 0, salt, 0, digestSaltSize);\n                    } else {\n                        salt = new byte[digestSaltSize];\n                        System.arraycopy(digest, digest.length - digestSaltSize, salt, 0, digestSaltSize);\n                    }\n\n                } else {\n                    salt = this.saltGenerator.generateSalt(this.saltSizeBytes);\n                }\n// fix_end\n// fix_start\n            final byte[] encryptedMessage = digest(message, salt);\n// fix_end\n// fix_start\n            return (digestsAreEqual(encryptedMessage, digest));\n// fix_end\n// fix_start\n        } catch (Exception e) {\n            throw new EncryptionOperationNotPossibleException();\n// fix_end\n// fix_start\n// fix_end\n", "cwe": "CWE-200", "cwe_name": "Exposure of Sensitive Information to an Unauthorized Actor", "idx": 19226}
{"source": "// bug_start\nprotected Result findResult(String path, String resultCode, String ext, ActionContext actionContext,\n                                Map<String, ResultTypeConfig> resultsByExtension) {\n        try {\n            boolean traceEnabled = LOG.isTraceEnabled();\n            if (traceEnabled)\n                LOG.trace(\"Checking ServletContext for [#0]\", path);\n// bug_end\n \n// bug_start\n            if (servletContext.getResource(path) != null) {\n                if (traceEnabled)\n                    LOG.trace(\"Found\");\n                return buildResult(path, resultCode, resultsByExtension.get(ext), actionContext);\n            }\n// bug_end\n \n// bug_start\n            if (traceEnabled)\n                LOG.trace(\"Checking ClasLoader for #0\", path);\n\n            String classLoaderPath = path.startsWith(\"/\") ? path.substring(1, path.length()) : path;\n            if (ClassLoaderUtil.getResource(classLoaderPath, getClass()) != null) {\n                if (traceEnabled)\n                    LOG.trace(\"Found\");\n                return buildResult(path, resultCode, resultsByExtension.get(ext), actionContext);\n            }\n        } catch (MalformedURLException e) {\n            if (LOG.isErrorEnabled())\n                LOG.error(\"Unable to parse template path: [#0] skipping...\", path);\n// bug_end\n         }\n// bug_start\n\n        return null;\n// bug_end\n     }\n \n", "target": "// fix_start\nprivate void initialize() throws TransformerFactoryConfigurationError, TransformerConfigurationException,\n            ParserConfigurationException {\n        if (!xslIsInitialized) {\n            TransformerFactory transformerFactory = TransformerFactory.newInstance();\n            nunitTransformer = transformerFactory.newTransformer(new StreamSource(this.getClass().getResourceAsStream(NUNIT_TO_JUNIT_XSLFILE_STR)));\n            writerTransformer = transformerFactory.newTransformer();\n// fix_end\n// fix_start\n            DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();\n            xmlDocumentBuilder = factory.newDocumentBuilder();\n// fix_end\n// fix_start\n            xslIsInitialized = true;\n// fix_end\n// fix_start\n// fix_end\n", "cwe": "CWE-22", "cwe_name": "Path Traversal", "idx": 25802}
{"source": "// bug_start\nprivate boolean exractAndLoad(ArrayList<String> errors, String version, String customPath, String resourcePath) {\n        URL resource = classLoader.getResource(resourcePath);\n        if( resource !=null ) {\n// bug_end\n \n// bug_start\n            String libName = name + \"-\" + getBitModel();\n            if( version !=null) {\n                libName += \"-\" + version;\n            }\n            String []libNameParts = map(libName).split(\"\\\\.\");\n            String prefix = libNameParts[0]+\"-\";\n            String suffix = \".\"+libNameParts[1];\n// bug_end\n \n// bug_start\n            if( customPath!=null ) {\n                File target = extract(errors, resource, prefix, suffix, file(customPath));\n                if( target!=null ) {\n                    if( load(errors, target) ) {\n                        return true;\n                    }\n                }\n            }\n// bug_end\n \n// bug_start\n            customPath = System.getProperty(\"java.io.tmpdir\");\n            File target = extract(errors, resource, prefix, suffix, file(customPath));\n            if( target!=null ) {\n                if( load(errors, target) ) {\n                    return true;\n                }\n            }\n// bug_end\n         }\n// bug_start\n        return false;\n// bug_end\n     }\n \n", "target": "// fix_start\nprivate void initialize() throws TransformerFactoryConfigurationError, TransformerConfigurationException,\n            ParserConfigurationException {\n        if (!xslIsInitialized) {\n            TransformerFactory transformerFactory = createTransformer();\n// fix_end\n// fix_start\n            nunitTransformer = transformerFactory.newTransformer(new StreamSource(this.getClass().getResourceAsStream(NUNIT_TO_JUNIT_XSLFILE_STR)));\n            writerTransformer = transformerFactory.newTransformer();\n// fix_end\n// fix_start\n            DocumentBuilderFactory factory = createDocumentBuilderFactory();\n            xmlDocumentBuilder = factory.newDocumentBuilder();\n// fix_end\n// fix_start\n            xslIsInitialized = true;\n// fix_end\n// fix_start\n// fix_end\n", "cwe": "CWE-611", "cwe_name": "Improper Restriction of XML External Entity Reference ('XXE')", "idx": 69782}
{"source": "// bug_start\nprivate boolean exractAndLoad(ArrayList<String> errors, String version, String customPath, String resourcePath) {\n        URL resource = classLoader.getResource(resourcePath);\n        if( resource !=null ) {\n\n            String libName = name + \"-\" + getBitModel();\n            if( version !=null) {\n                libName += \"-\" + version;\n// bug_end\n             }\n \n// bug_start\n            if( customPath!=null ) {\n                File target = file(customPath, map(libName));\n                if( extract(errors, resource, target) ) {\n                    if( load(errors, target) ) {\n                        return true;\n// bug_end\n                     }\n                 }\n// bug_start\n// bug_end\n             }\n// bug_start\n\n            customPath = System.getProperty(\"java.io.tmpdir\");\n            File target = file(customPath, map(libName));\n            if( extract(errors, resource, target) ) {\n                if( load(errors, target) ) {\n                    return true;\n                }\n            }\n// bug_end\n         }\n// bug_start\n        return false;\n// bug_end\n     }\n \n", "target": "// fix_start\n@Override\n    public void deactivate() {\n        if (isActive()) {\n            if (!isAssociated()) {\n                throw ConversationLogger.LOG.mustCallAssociateBeforeDeactivate();\n// fix_end\n// fix_start\n            try {\n                if (getCurrentConversation().isTransient() && getRequestAttribute(getRequest(), ConversationNamingScheme.PARAMETER_NAME) != null) {\n                    destroy();\n                } else {\n                    getCurrentConversation().touch();\n                    if (!getBeanStore().isAttached()) {\n                        if (!(getRequestAttribute(getRequest(), ConversationNamingScheme.PARAMETER_NAME) instanceof ConversationNamingScheme)) {\n                            throw ConversationLogger.LOG.conversationNamingSchemeNotFound();\n                        }\n                        ((ConversationNamingScheme) getRequestAttribute(getRequest(), ConversationNamingScheme.PARAMETER_NAME)).setCid(getCurrentConversation()\n                                .getId());\n\n                        getBeanStore().attach();\n                        getConversationMap().put(getCurrentConversation().getId(), getCurrentConversation());\n// fix_end\n// fix_start\n            } finally {\n                getCurrentConversation().unlock();\n// fix_end\n// fix_start\n            setBeanStore(null);\n            cleanUpConversationMap();\n            super.setActive(false);\n        } else {\n            throw ConversationLogger.LOG.contextNotActive();\n// fix_end\n// fix_start\n// fix_end\n", "cwe": "CWE-94", "cwe_name": "Improper Control of Generation of Code ('Code Injection')", "idx": 95296}
{"source": "\n", "target": "\n", "cwe": "CWE-502", "cwe_name": "Deserialization of Untrusted Data", "idx": 62592}
{"source": " public static boolean isSpringJspExpressionSupportActive(PageContext pageContext) {\n \t\tServletContext sc = pageContext.getServletContext();\n \t\tString springJspExpressionSupport = sc.getInitParameter(EXPRESSION_SUPPORT_CONTEXT_PARAM);\n \t\tif (springJspExpressionSupport != null) {\n \t\t\treturn Boolean.valueOf(springJspExpressionSupport);\n \t\t}\n \t\tif (sc.getMajorVersion() >= 3) {\n// bug_start\n\t\t\tif (sc.getEffectiveMajorVersion() > 2 || sc.getEffectiveMinorVersion() > 3) {\n\t\t\t\treturn false;\n// bug_end\n \t\t\t}\n \t\t}\n// bug_start\n\t\treturn true;\n// bug_end\n \t}\n \n", "target": "// fix_start\n\t\t\tif (sc.getEffectiveMajorVersion() == 2 && sc.getEffectiveMinorVersion() < 4) {\n\t\t\t\treturn true;\n// fix_end\n// fix_start\n\t\treturn false;\n// fix_end\n", "cwe": "CWE-16", "cwe_name": "Configuration", "idx": 2498}
{"source": " @Override\n     public boolean check(String uri, Resource resource)\n     {\n         if (!(resource instanceof PathResource))\n             return false;\n \n         PathResource pathResource = (PathResource)resource;\n \n         try\n         {\n             Path path = pathResource.getPath();\n             Path alias = pathResource.getAliasPath();\n// bug_start\n// bug_end\n \n             if (Files.isSymbolicLink(path))\n             {\n                 alias = path.getParent().resolve(alias);\n                 if (LOG.isDebugEnabled())\n                 {\n                     LOG.debug(\"path ={}\",path);\n                     LOG.debug(\"alias={}\",alias);\n                 }\n                 if (Files.isSameFile(path,alias))\n                 {\n                     if (LOG.isDebugEnabled())\n                         LOG.debug(\"Allow symlink {} --> {}\",resource,pathResource.getAliasPath());\n                     return true;\n                 }\n             }\n \n             boolean linked=true;\n             Path target=path;\n             int loops=0;\n             while (linked)\n             {\n                 if (++loops>100)\n                 {\n                     if (LOG.isDebugEnabled())\n                         LOG.debug(\"Too many symlinks {} --> {}\",resource,target);\n                     return false;\n                 }\n                 linked=false;\n                 Path d = target.getRoot();\n                 for (Path e:target)\n                 {\n                     Path r=d.resolve(e);\n                     d=r;\n \n                     while (Files.exists(d) && Files.isSymbolicLink(d))\n                     {\n                         Path link=Files.readSymbolicLink(d);\n                         if (!link.isAbsolute())\n                             link=d.getParent().resolve(link);\n                         d=link;\n                         linked=true;\n                     }\n                 }\n                 target=d;\n             }\n \n             if (pathResource.getAliasPath().equals(target))\n             {\n                 if (LOG.isDebugEnabled())\n                     LOG.debug(\"Allow path symlink {} --> {}\",resource,target);\n                 return true;\n             }\n         }\n         catch(Exception e)\n         {\n             LOG.ignore(e);\n         }\n \n         return false;\n     }\n \n", "target": "// fix_start\n\n            if (path.equals(alias))\n                return false;\n// fix_end\n", "cwe": "CWE-284", "cwe_name": "Improper Access Control", "idx": 37291}
{"source": " private boolean isInvalidEncodedPath(String resourcePath) {\n \t\tif (resourcePath.contains(\"%\")) {\n \t\t\ttry {\n \t\t\t\tString decodedPath = URLDecoder.decode(resourcePath, \"UTF-8\");\n// bug_start\n\t\t\t\treturn (decodedPath.contains(\"../\") || decodedPath.contains(\"..\\\\\"));\n// bug_end\n \t\t\t}\n \t\t\tcatch (UnsupportedEncodingException ex) {\n \t\t\t}\n \t\t}\n \t\treturn false;\n \t}\n \n", "target": "// fix_start\n\t\t\t\tif (decodedPath.contains(\"../\") || decodedPath.contains(\"..\\\\\")) {\n\t\t\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\t\t\tlogger.trace(\"Ignoring invalid resource path with escape sequences [\" + resourcePath + \"]\");\n\t\t\t\t\t}\n\t\t\t\t\treturn true;\n\t\t\t\t}\n// fix_end\n", "cwe": "CWE-22", "cwe_name": "Path Traversal", "idx": 26706}
{"source": " @Before\n     public void setUp() throws Exception {\n         if (originalDatabaseExternalMembers==null) {\n             originalDefaultExternalMembers = (List<String>) getWebApplicationContext().getBean(\"defaultExternalMembers\");\n             originalDatabaseExternalMembers = getWebApplicationContext().getBean(JdbcScimGroupExternalMembershipManager.class).query(\"\");\n         }\n \n         if(bootstrap == null){\n             bootstrap = getWebApplicationContext().getBean(ScimExternalGroupBootstrap.class);\n         }\n \n         if(template == null) {\n             template = getWebApplicationContext().getBean(JdbcTemplate.class);\n         }\n \n         template.update(\"delete from external_group_mapping\");\n         bootstrap.afterPropertiesSet();\n \n         String adminToken = testClient.getClientCredentialsOAuthAccessToken(\"admin\", \"adminsecret\",\n                 \"clients.read clients.write clients.secret clients.admin\");\n         clientId = generator.generate().toLowerCase();\n         clientSecret = generator.generate().toLowerCase();\n// bug_start\n        String authorities = \"scim.read,scim.write,password.write,oauth.approvals,scim.create\";\n// bug_end\n         utils().createClient(this.getMockMvc(), adminToken, clientId, clientSecret, Collections.singleton(\"oauth\"), Arrays.asList(\"foo\",\"bar\",\"scim.read\"), Arrays.asList(\"client_credentials\", \"password\"), authorities);\n         scimReadToken = testClient.getClientCredentialsOAuthAccessToken(clientId, clientSecret,\"scim.read password.write\");\n         scimWriteToken = testClient.getClientCredentialsOAuthAccessToken(clientId, clientSecret,\"scim.write password.write\");\n \n         defaultExternalMembers = new LinkedList<>(originalDefaultExternalMembers);\n         databaseExternalMembers = new LinkedList<>(originalDatabaseExternalMembers);\n \n         scimUser = createUserAndAddToGroups(IdentityZone.getUaa(), new HashSet(Arrays.asList(\"scim.read\", \"scim.write\", \"scim.me\")));\n         scimReadUserToken = testClient.getUserOAuthAccessToken(\"cf\",\"\", scimUser.getUserName(), \"password\", \"scim.read\");\n         identityClientToken = testClient.getClientCredentialsOAuthAccessToken(\"identity\",\"identitysecret\",\"\");\n     }\n \n", "target": "// fix_start\n        String authorities = \"scim.read,scim.write,password.write,oauth.approvals,scim.create,other.scope\";\n// fix_end\n", "cwe": "CWE-269", "cwe_name": "Improper Privilege Management", "idx": 36082}
{"source": "// bug_start\nprivate String guard(String filename) {\n            String guarded = filename.replace(\":\", \"_\");\n            if (LOG.isDebugEnabled()) {\n                LOG.debug(\"guarded \" + filename + \" to \" + guarded);\n// bug_end\n             }\n// bug_start\n            return guarded;\n// bug_end\n         }\n// bug_start\n// bug_end\n \n", "target": "// fix_start\npublic String getRepoPassword() {\n        if (repoPassword != null) {\n            String plainText = repoPassword.getPlainText();\n            if (!plainText.isEmpty()) {\n                return plainText;\n// fix_end\n// fix_start\n// fix_end\n// fix_start\n        return \"admin\";\n    }\n// fix_end\n", "cwe": "CWE-22", "cwe_name": "Path Traversal", "idx": 20900}
{"source": "// bug_start\npublic String getRepoPassword() {\n        return repoPassword == null ? \"admin\" : repoPassword;\n// bug_end\n     }\n \n", "target": "// fix_start\nprivate int readStored(final byte[] buffer, final int offset, final int length) throws IOException {\n\n        if (current.hasDataDescriptor) {\n            if (lastStoredEntry == null) {\n                readStoredEntry();\n            }\n            return lastStoredEntry.read(buffer, offset, length);\n        }\n\n        final long csize = current.entry.getSize();\n        if (current.bytesRead >= csize) {\n            return -1;\n        }\n\n        if (buf.position() >= buf.limit()) {\n            buf.position(0);\n            final int l = in.read(buf.array());\n            if (l == -1) {\n                buf.limit(0);\n                throw new IOException(\"Truncated ZIP file\");\n            }\n            buf.limit(l);\n\n            count(l);\n            current.bytesReadFromStream += l;\n        }\n\n        int toRead = Math.min(buf.remaining(), length);\n        if ((csize - current.bytesRead) < toRead) {\n            toRead = (int) (csize - current.bytesRead);\n        }\n        buf.get(buffer, offset, toRead);\n        current.bytesRead += toRead;\n        return toRead;\n// fix_end\n", "cwe": "CWE-522", "cwe_name": "Insufficiently Protected Credentials", "idx": 63886}
{"source": "// bug_start\nprivate int readStored(final byte[] buffer, final int offset, final int length) throws IOException {\n\n        if (current.hasDataDescriptor) {\n            if (lastStoredEntry == null) {\n                readStoredEntry();\n            }\n            return lastStoredEntry.read(buffer, offset, length);\n// bug_end\n         }\n \n// bug_start\n        final long csize = current.entry.getSize();\n        if (current.bytesRead >= csize) {\n            return -1;\n// bug_end\n         }\n \n// bug_start\n        if (buf.position() >= buf.limit()) {\n            buf.position(0);\n            final int l = in.read(buf.array());\n            if (l == -1) {\n                return -1;\n            }\n            buf.limit(l);\n\n            count(l);\n            current.bytesReadFromStream += l;\n// bug_end\n         }\n \n// bug_start\n        int toRead = Math.min(buf.remaining(), length);\n        if ((csize - current.bytesRead) < toRead) {\n            toRead = (int) (csize - current.bytesRead);\n// bug_end\n         }\n// bug_start\n        buf.get(buffer, offset, toRead);\n        current.bytesRead += toRead;\n        return toRead;\n// bug_end\n     }\n \n", "target": "// fix_start\n@SuppressWarnings(\"deprecation\")\n    public void process(final HttpRequest request, final HttpContext context)\n            throws HttpException, IOException {\n        if (request == null) {\n            throw new IllegalArgumentException(\"HTTP request may not be null\");\n        }\n        if (context == null) {\n            throw new IllegalArgumentException(\"HTTP context may not be null\");\n// fix_end\n// fix_start\n        if (request.containsHeader(AUTH.PROXY_AUTH_RESP)) {\n            return;\n// fix_end\n// fix_start\n        HttpRoutedConnection conn = (HttpRoutedConnection) context.getAttribute(\n                ExecutionContext.HTTP_CONNECTION);\n        HttpRoute route = conn.getRoute();\n        if (route.isTunnelled()) {\n            return;\n// fix_end\n// fix_start\n        AuthState authState = (AuthState) context.getAttribute(\n                ClientContext.PROXY_AUTH_STATE);\n        if (authState == null) {\n            return;\n// fix_end\n// fix_start\n\n        AuthScheme authScheme = authState.getAuthScheme();\n        if (authScheme == null) {\n            return;\n        }\n\n        Credentials creds = authState.getCredentials();\n        if (creds == null) {\n            this.log.debug(\"User credentials not available\");\n            return;\n        }\n        if (authState.getAuthScope() != null || !authScheme.isConnectionBased()) {\n            try {\n                Header header;\n                if (authScheme instanceof ContextAwareAuthScheme) {\n                    header = ((ContextAwareAuthScheme) authScheme).authenticate(\n                            creds, request, context);\n                } else {\n                    header = authScheme.authenticate(creds, request);\n                }\n                request.addHeader(header);\n            } catch (AuthenticationException ex) {\n                if (this.log.isErrorEnabled()) {\n                    this.log.error(\"Proxy authentication error: \" + ex.getMessage());\n                }\n            }\n        }\n// fix_end\n", "cwe": "CWE-835", "cwe_name": "Loop with Unreachable Exit Condition ('Infinite Loop')", "idx": 82770}
{"source": "// bug_start\n@SuppressWarnings(\"deprecation\")\n    public void process(final HttpRequest request, final HttpContext context)\n            throws HttpException, IOException {\n        if (request == null) {\n            throw new IllegalArgumentException(\"HTTP request may not be null\");\n        }\n        if (context == null) {\n            throw new IllegalArgumentException(\"HTTP context may not be null\");\n// bug_end\n         }\n \n// bug_start\n        if (request.containsHeader(AUTH.PROXY_AUTH_RESP)) {\n            return;\n// bug_end\n         }\n \n// bug_start\n        AuthState authState = (AuthState) context.getAttribute(\n                ClientContext.PROXY_AUTH_STATE);\n        if (authState == null) {\n            return;\n// bug_end\n         }\n \n// bug_start\n        AuthScheme authScheme = authState.getAuthScheme();\n        if (authScheme == null) {\n            return;\n        }\n\n        Credentials creds = authState.getCredentials();\n        if (creds == null) {\n            this.log.debug(\"User credentials not available\");\n            return;\n        }\n        if (authState.getAuthScope() != null || !authScheme.isConnectionBased()) {\n            try {\n                Header header;\n                if (authScheme instanceof ContextAwareAuthScheme) {\n                    header = ((ContextAwareAuthScheme) authScheme).authenticate(\n                            creds, request, context);\n                } else {\n                    header = authScheme.authenticate(creds, request);\n                }\n                request.addHeader(header);\n            } catch (AuthenticationException ex) {\n                if (this.log.isErrorEnabled()) {\n                    this.log.error(\"Proxy authentication error: \" + ex.getMessage());\n                }\n            }\n// bug_end\n         }\n     }\n \n", "target": "// fix_start\nprivate void splitHeader(AppendableCharSequence sb) {\n        final int length = sb.length();\n        int nameStart;\n        int nameEnd;\n        int colonEnd;\n        int valueStart;\n        int valueEnd;\n\n        nameStart = findNonWhitespace(sb, 0);\n        for (nameEnd = nameStart; nameEnd < length; nameEnd ++) {\n            char ch = sb.charAtUnsafe(nameEnd);\n            if (ch == ':' ||\n                    (!isDecodingRequest() && Character.isWhitespace(ch))) {\n                break;\n            }\n// fix_end\n// fix_start\n        if (nameEnd == length) {\n            throw new IllegalArgumentException(\"No colon found\");\n// fix_end\n// fix_start\n        for (colonEnd = nameEnd; colonEnd < length; colonEnd ++) {\n            if (sb.charAtUnsafe(colonEnd) == ':') {\n                colonEnd ++;\n                break;\n            }\n// fix_end\n// fix_start\n        name = sb.subStringUnsafe(nameStart, nameEnd);\n        valueStart = findNonWhitespace(sb, colonEnd);\n        if (valueStart == length) {\n            value = EMPTY_VALUE;\n        } else {\n            valueEnd = findEndOfString(sb);\n            value = sb.subStringUnsafe(valueStart, valueEnd);\n// fix_end\n", "cwe": "CWE-200", "cwe_name": "Exposure of Sensitive Information to an Unauthorized Actor", "idx": 16099}
{"source": "// bug_start\nprivate void splitHeader(AppendableCharSequence sb) {\n        final int length = sb.length();\n        int nameStart;\n        int nameEnd;\n        int colonEnd;\n        int valueStart;\n        int valueEnd;\n// bug_end\n \n// bug_start\n        nameStart = findNonWhitespace(sb, 0);\n        for (nameEnd = nameStart; nameEnd < length; nameEnd ++) {\n            char ch = sb.charAtUnsafe(nameEnd);\n            if (ch == ':' ||\n                    (!isDecodingRequest() && Character.isWhitespace(ch))) {\n                break;\n            }\n        }\n// bug_end\n \n// bug_start\n        for (colonEnd = nameEnd; colonEnd < length; colonEnd ++) {\n            if (sb.charAtUnsafe(colonEnd) == ':') {\n                colonEnd ++;\n                break;\n            }\n        }\n\n        name = sb.subStringUnsafe(nameStart, nameEnd);\n        valueStart = findNonWhitespace(sb, colonEnd);\n        if (valueStart == length) {\n            value = EMPTY_VALUE;\n        } else {\n            valueEnd = findEndOfString(sb);\n            value = sb.subStringUnsafe(valueStart, valueEnd);\n        }\n    }\n\n// bug_end\n", "target": "// fix_start\nprivate void doInclude(HttpServletRequest request, HttpServletResponse response, String resourceUrl)\n\t\tthrows ServletException, IOException {\n// fix_end\n// fix_start\n\t\tif (this.contentType != null) {\n\t\t\tresponse.setContentType(this.contentType);\n\t\t}\n\t\tString[] resourceUrls =\n\t\t\tStringUtils.tokenizeToStringArray(resourceUrl, RESOURCE_URL_DELIMITERS);\n\t\tfor (int i = 0; i < resourceUrls.length; i++) {\n\t\t\tif (this.allowedResources != null && !this.pathMatcher.match(this.allowedResources, resourceUrls[i])) {\n\t\t\t\tthrow new ServletException(\"Resource [\" + resourceUrls[i] +\n\t\t\t\t\t\t\"] does not match allowed pattern [\" + this.allowedResources + \"]\");\n\t\t\t}\n\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\tlogger.debug(\"Including resource [\" + resourceUrls[i] + \"]\");\n\t\t\t}\n\t\t\tRequestDispatcher rd = request.getRequestDispatcher(resourceUrls[i]);\n\t\t\trd.include(request, response);\n\t\t}\n\t}\n// fix_end\n", "cwe": "CWE-444", "cwe_name": "Inconsistent Interpretation of HTTP Requests ('HTTP Request Smuggling')", "idx": 54060}
{"source": "// bug_start\nprotected void scanPI() throws IOException {\n            if (DEBUG_BUFFER) {\n                fCurrentEntity.debugBufferIfNeeded(\"(scanPI: \");\n            }\n            if (fReportErrors) {\n                fErrorReporter.reportWarning(\"HTML1008\", null);\n            }\n// bug_end\n \n// bug_start\n            String target = scanName(true);\n            if (target != null && !target.equalsIgnoreCase(\"xml\")) {\n                while (true) {\n                    int c = fCurrentEntity.read();\n                    if (c == '\\r' || c == '\\n') {\n                        if (c == '\\r') {\n                            c = fCurrentEntity.read();\n                            if (c != '\\n') {\n                                fCurrentEntity.offset--;\n                                fCurrentEntity.characterOffset_--;\n                            }\n                        }\n                        fCurrentEntity.incLine();\n                        continue;\n                    }\n                    if (c == -1) {\n                        break;\n                    }\n                    if (c != ' ' && c != '\\t') {\n                    \tfCurrentEntity.rewind();\n                        break;\n                    }\n                }\n                fStringBuffer.clear();\n                while (true) {\n                    int c = fCurrentEntity.read();\n                    if (c == '?' || c == '/') {\n                        char c0 = (char)c;\n                        c = fCurrentEntity.read();\n                        if (c == '>') {\n                            break;\n                        }\n                        fStringBuffer.append(c0);\n                        fCurrentEntity.rewind();\n                        continue;\n                    }\n                    else if (c == '\\r' || c == '\\n') {\n                        fStringBuffer.append('\\n');\n                        if (c == '\\r') {\n                            c = fCurrentEntity.read();\n                            if (c != '\\n') {\n                                fCurrentEntity.offset--;\n                                fCurrentEntity.characterOffset_--;\n                            }\n                        }\n                        fCurrentEntity.incLine();\n                        continue;\n                    }\n                    else if (c == -1) {\n                        break;\n                    }\n                    else {\n                        appendChar(fStringBuffer, c);\n                    }\n                }\n                XMLString data = fStringBuffer;\n                if (fDocumentHandler != null) {\n                    fEndLineNumber = fCurrentEntity.getLineNumber();\n                    fEndColumnNumber = fCurrentEntity.getColumnNumber();\n                    fEndCharacterOffset = fCurrentEntity.getCharacterOffset();\n                    fDocumentHandler.processingInstruction(target, data, locationAugs());\n                }\n            }\n// bug_end\n \n// bug_start\n            else {\n                int beginLineNumber = fBeginLineNumber;\n                int beginColumnNumber = fBeginColumnNumber;\n                int beginCharacterOffset = fBeginCharacterOffset;\n                fAttributes.removeAllAttributes();\n                int aindex = 0;\n                while (scanPseudoAttribute(fAttributes)) {\n                \tif (fAttributes.getValue(aindex).length() == 0) {\n                \t\tfAttributes.removeAttributeAt(aindex);\n                \t}\n                \telse {\n\t                    fAttributes.getName(aindex,fQName);\n\t                    fQName.rawname = fQName.rawname.toLowerCase();\n\t                    fAttributes.setName(aindex,fQName);\n\t                    aindex++;\n                \t}\n                }\n                if (fDocumentHandler != null) {\n                    String version = fAttributes.getValue(\"version\");\n                    String encoding = fAttributes.getValue(\"encoding\");\n                    String standalone = fAttributes.getValue(\"standalone\");\n\n                    final boolean xmlDeclNow = fIgnoreSpecifiedCharset || !changeEncoding(encoding);\n                    if (xmlDeclNow) {\n\t                    fBeginLineNumber = beginLineNumber;\n\t                    fBeginColumnNumber = beginColumnNumber;\n\t                    fBeginCharacterOffset = beginCharacterOffset;\n\t                    fEndLineNumber = fCurrentEntity.getLineNumber();\n\t                    fEndColumnNumber = fCurrentEntity.getColumnNumber();\n\t                    fEndCharacterOffset = fCurrentEntity.getCharacterOffset();\n\t                    fDocumentHandler.xmlDecl(version, encoding, standalone,\n\t                                             locationAugs());\n                    }\n                }\n            }\n\n            if (DEBUG_BUFFER) {\n                fCurrentEntity.debugBufferIfNeeded(\")scanPI: \");\n            }\n        }\n\n// bug_end\n", "target": "// fix_start\nprivate void doInclude(HttpServletRequest request, HttpServletResponse response, String resourceUrl)\n\t\tthrows ServletException, IOException {\n// fix_end\n// fix_start\n\t\tif (this.contentType != null) {\n\t\t\tresponse.setContentType(this.contentType);\n\t\t}\n\t\tString[] resourceUrls = StringUtils.tokenizeToStringArray(resourceUrl, RESOURCE_URL_DELIMITERS);\n\t\tfor (String url : resourceUrls) {\n\t\t\tString path = StringUtils.cleanPath(url);\n\t\t\tif (this.allowedResources != null && !this.pathMatcher.match(this.allowedResources, path)) {\n\t\t\t\tthrow new ServletException(\"Resource [\" + path +\n\t\t\t\t\t\t\"] does not match allowed pattern [\" + this.allowedResources + \"]\");\n\t\t\t}\n\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\tlogger.debug(\"Including resource [\" + path + \"]\");\n\t\t\t}\n\t\t\tRequestDispatcher rd = request.getRequestDispatcher(path);\n\t\t\trd.include(request, response);\n\t\t}\n\t}\n// fix_end\n", "cwe": "CWE-22", "cwe_name": "Path Traversal", "idx": 26922}
{"source": "// bug_start\n@Override\n    public void showWebPage(String url, boolean openExternal, boolean clearHistory, Map<String, Object> params) {\n        LOG.d(TAG, \"showWebPage(%s, %b, %b, HashMap)\", url, openExternal, clearHistory);\n// bug_end\n \n// bug_start\n        if (clearHistory) {\n            engine.clearHistory();\n// bug_end\n         }\n \n// bug_start\n        if (!openExternal) {\n            if (pluginManager.shouldAllowNavigation(url)) {\n                loadUrlIntoView(url, true);\n            } else {\n                LOG.w(TAG, \"showWebPage: Refusing to load URL into webview since it is not in the <allow-navigation> whitelist. URL=\" + url);\n            }\n        }\n        if (!pluginManager.shouldOpenExternalUrl(url)) {\n            LOG.w(TAG, \"showWebPage: Refusing to send intent for URL since it is not in the <allow-intent> whitelist. URL=\" + url);\n            return;\n        }\n        try {\n            Intent intent = new Intent(Intent.ACTION_VIEW);\n            Uri uri = Uri.parse(url);\n            if (\"file\".equals(uri.getScheme())) {\n                intent.setDataAndType(uri, resourceApi.getMimeType(uri));\n            } else {\n                intent.setData(uri);\n            }\n            cordova.getActivity().startActivity(intent);\n        } catch (android.content.ActivityNotFoundException e) {\n            LOG.e(TAG, \"Error loading url \" + url, e);\n        }\n    }\n\n// bug_end\n", "target": "// fix_start\nprotected void scanPI() throws IOException {\n            if (DEBUG_BUFFER) {\n                fCurrentEntity.debugBufferIfNeeded(\"(scanPI: \");\n            }\n            if (fReportErrors) {\n                fErrorReporter.reportWarning(\"HTML1008\", null);\n            }\n// fix_end\n// fix_start\n            String target = scanName(true);\n            if (target != null && !target.equalsIgnoreCase(\"xml\")) {\n                while (true) {\n                    int c = fCurrentEntity.read();\n                    if (c == '\\r' || c == '\\n') {\n                        if (c == '\\r') {\n                            c = fCurrentEntity.read();\n                            if (c != '\\n') {\n                                fCurrentEntity.offset--;\n                                fCurrentEntity.characterOffset_--;\n                            }\n                        }\n                        fCurrentEntity.incLine();\n                        continue;\n                    }\n                    if (c == -1) {\n                        break;\n                    }\n                    if (c != ' ' && c != '\\t') {\n                    \tfCurrentEntity.rewind();\n                        break;\n                    }\n                }\n                fStringBuffer.clear();\n                while (true) {\n                    int c = fCurrentEntity.read();\n                    if (c == '?' || c == '/') {\n                        char c0 = (char)c;\n                        c = fCurrentEntity.read();\n                        if (c == '>' || c == -1) {\n                            break;\n                        }\n                        fStringBuffer.append(c0);\n                        fCurrentEntity.rewind();\n                        continue;\n                    }\n                    else if (c == '\\r' || c == '\\n') {\n                        fStringBuffer.append('\\n');\n                        if (c == '\\r') {\n                            c = fCurrentEntity.read();\n                            if (c != '\\n') {\n                                fCurrentEntity.offset--;\n                                fCurrentEntity.characterOffset_--;\n                            }\n                        }\n                        fCurrentEntity.incLine();\n                        continue;\n                    }\n                    else if (c == -1) {\n                        break;\n                    }\n                    else {\n                        appendChar(fStringBuffer, c);\n                    }\n                }\n                XMLString data = fStringBuffer;\n                if (fDocumentHandler != null) {\n                    fEndLineNumber = fCurrentEntity.getLineNumber();\n                    fEndColumnNumber = fCurrentEntity.getColumnNumber();\n                    fEndCharacterOffset = fCurrentEntity.getCharacterOffset();\n                    fDocumentHandler.processingInstruction(target, data, locationAugs());\n                }\n            }\n\n            else {\n                int beginLineNumber = fBeginLineNumber;\n                int beginColumnNumber = fBeginColumnNumber;\n                int beginCharacterOffset = fBeginCharacterOffset;\n                fAttributes.removeAllAttributes();\n                int aindex = 0;\n                while (scanPseudoAttribute(fAttributes)) {\n                \tif (fAttributes.getValue(aindex).length() == 0) {\n                \t\tfAttributes.removeAttributeAt(aindex);\n                \t}\n                \telse {\n\t                    fAttributes.getName(aindex,fQName);\n\t                    fQName.rawname = fQName.rawname.toLowerCase();\n\t                    fAttributes.setName(aindex,fQName);\n\t                    aindex++;\n                \t}\n                }\n                if (fDocumentHandler != null) {\n                    String version = fAttributes.getValue(\"version\");\n                    String encoding = fAttributes.getValue(\"encoding\");\n                    String standalone = fAttributes.getValue(\"standalone\");\n\n                    final boolean xmlDeclNow = fIgnoreSpecifiedCharset || !changeEncoding(encoding);\n                    if (xmlDeclNow) {\n\t                    fBeginLineNumber = beginLineNumber;\n\t                    fBeginColumnNumber = beginColumnNumber;\n\t                    fBeginCharacterOffset = beginCharacterOffset;\n\t                    fEndLineNumber = fCurrentEntity.getLineNumber();\n\t                    fEndColumnNumber = fCurrentEntity.getColumnNumber();\n\t                    fEndCharacterOffset = fCurrentEntity.getCharacterOffset();\n\t                    fDocumentHandler.xmlDecl(version, encoding, standalone,\n\t                                             locationAugs());\n                    }\n                }\n            }\n\n            if (DEBUG_BUFFER) {\n                fCurrentEntity.debugBufferIfNeeded(\")scanPI: \");\n            }\n// fix_end\n", "cwe": "CWE-400", "cwe_name": "Uncontrolled Resource Consumption", "idx": 52763}
{"source": " @Override\n// bug_start\n    public void showWebPage(String url, boolean openExternal, boolean clearHistory, Map<String, Object> params) {\n        LOG.d(TAG, \"showWebPage(%s, %b, %b, HashMap\", url, openExternal, clearHistory);\n// bug_end\n \n// bug_start\n        if (clearHistory) {\n            engine.clearHistory();\n// bug_end\n         }\n \n// bug_start\n        if (!openExternal) {\n            if (pluginManager.shouldAllowNavigation(url)) {\n                loadUrlIntoView(url, true);\n                return;\n            }\n            LOG.w(TAG, \"showWebPage: Cannot load URL into webview since it is not in white list.  Loading into browser instead. (URL=\" + url + \")\");\n// bug_end\n         }\n// bug_start\n        try {\n            Intent intent = new Intent(Intent.ACTION_VIEW);\n            Uri uri = Uri.parse(url);\n            if (\"file\".equals(uri.getScheme())) {\n                intent.setDataAndType(uri, resourceApi.getMimeType(uri));\n            } else {\n                intent.setData(uri);\n            }\n            cordova.getActivity().startActivity(intent);\n        } catch (android.content.ActivityNotFoundException e) {\n            LOG.e(TAG, \"Error loading url \" + url, e);\n// bug_end\n         }\n// bug_start\n// bug_end\n     }\n \n", "target": "// fix_start\n  public User getUser() throws IllegalStateException {\n    Organization org = getOrganization();\n    if (org == null)\n      throw new IllegalStateException(\"No organization is set in security context\");\n// fix_end\n// fix_start\n    User delegatedUser = delegatedUserHolder.get();\n\n    if (delegatedUser != null) {\n      return delegatedUser;\n    }\n\n    Authentication auth = SecurityContextHolder.getContext().getAuthentication();\n    JaxbOrganization jaxbOrganization = JaxbOrganization.fromOrganization(org);\n    if (auth != null) {\n      Object principal = auth.getPrincipal();\n      if ((principal != null) && (principal instanceof UserDetails)) {\n        UserDetails userDetails = (UserDetails) principal;\n\n        User user = null;\n\n        if (userDirectory != null) {\n          user = userDirectory.loadUser(userDetails.getUsername());\n          if (user == null) {\n            logger.debug(\n                    \"Authenticated user '{}' could not be found in any of the current UserProviders. Continuing anyway...\",\n                    userDetails.getUsername());\n          }\n        } else {\n          logger.debug(\"No UserDirectory was found when trying to search for user '{}'\", userDetails.getUsername());\n// fix_end\n// fix_start\n        Set<JaxbRole> roles = new HashSet<JaxbRole>();\n        Collection<? extends GrantedAuthority> authorities = auth.getAuthorities();\n        if (authorities != null) {\n          for (GrantedAuthority ga : authorities) {\n            roles.add(new JaxbRole(ga.getAuthority(), jaxbOrganization));\n          }\n// fix_end\n// fix_start\n\n        if (user == null) {\n          user = new JaxbUser(userDetails.getUsername(), null, jaxbOrganization, roles);\n        } else {\n          user = JaxbUser.fromUser(user, roles);\n// fix_end\n// fix_start\n\n        delegatedUserHolder.set(user);\n\n        return user;\n      }\n// fix_end\n// fix_start\n    return SecurityUtil.createAnonymousUser(jaxbOrganization);\n  }\n\n// fix_end\n", "cwe": "CWE-264", "cwe_name": "Permissions, Privileges, and Access Controls", "idx": 31533}
{"source": " @Override\n// bug_start\n    public String getWhyKeepLog() {\n        OUTER:\n        for (AbstractProject<?,?> p : getParent().getDownstreamProjects()) {\n            if (!p.isKeepDependencies()) continue;\n// bug_end\n \n// bug_start\n            AbstractBuild<?,?> fb = p.getFirstBuild();\n            if (fb==null)        continue;\n// bug_end\n \n// bug_start\n            for (int i : getDownstreamRelationship(p).listNumbersReverse()) {\n// bug_end\n \n// bug_start\n                if (i<fb.getNumber())\n                    continue OUTER;\n// bug_end\n \n// bug_start\n                AbstractBuild<?,?> b = p.getBuildByNumber(i);\n                if (b!=null)\n                    return Messages.AbstractBuild_KeptBecause(p.hasPermission(Item.READ) ? b.toString() : \"?\");\n            }\n// bug_end\n         }\n \n// bug_start\n        return super.getWhyKeepLog();\n// bug_end\n     }\n \n", "target": "// fix_start\n  public User getUser() throws IllegalStateException {\n    Organization org = getOrganization();\n    if (org == null)\n      throw new IllegalStateException(\"No organization is set in security context\");\n// fix_end\n// fix_start\n    User delegatedUser = delegatedUserHolder.get();\n// fix_end\n// fix_start\n    Authentication auth = SecurityContextHolder.getContext().getAuthentication();\n    if (auth instanceof AnonymousAuthenticationToken) {\n      return SecurityUtil.createAnonymousUser(org);\n    }\n// fix_end\n// fix_start\n    if (delegatedUser != null) {\n      return delegatedUser;\n    }\n// fix_end\n// fix_start\n    JaxbOrganization jaxbOrganization = JaxbOrganization.fromOrganization(org);\n    if (auth != null) {\n      Object principal = auth.getPrincipal();\n      if ((principal instanceof UserDetails)) {\n        UserDetails userDetails = (UserDetails) principal;\n\n        User user = null;\n\n        if (userDirectory != null) {\n          user = userDirectory.loadUser(userDetails.getUsername());\n          if (user == null) {\n            logger.debug(\"Authenticated user '{}' could not be found in any of the current UserProviders. \"\n                + \"Continuing anyway...\", userDetails.getUsername());\n          }\n        } else {\n          logger.debug(\"No UserDirectory was found when trying to search for user '{}'\", userDetails.getUsername());\n// fix_end\n// fix_start\n        Set<JaxbRole> roles = new HashSet<>();\n        Collection<? extends GrantedAuthority> authorities = auth.getAuthorities();\n        if (authorities != null) {\n          for (GrantedAuthority ga : authorities) {\n            roles.add(new JaxbRole(ga.getAuthority(), jaxbOrganization));\n          }\n        }\n\n        if (user == null) {\n          user = new JaxbUser(userDetails.getUsername(), null, jaxbOrganization, roles);\n        } else {\n          user = JaxbUser.fromUser(user, roles);\n        }\n\n        delegatedUserHolder.set(user);\n\n        return user;\n      }\n// fix_end\n// fix_start\n    return SecurityUtil.createAnonymousUser(jaxbOrganization);\n  }\n\n// fix_end\n", "cwe": "CWE-287", "cwe_name": "Improper Authentication", "idx": 38996}
{"source": "// bug_start\n@Override\n    public String getWhyKeepLog() {\n        OUTER:\n        for (AbstractProject<?,?> p : getParent().getDownstreamProjects()) {\n            if (!p.isKeepDependencies()) continue;\n// bug_end\n \n// bug_start\n            AbstractBuild<?,?> fb = p.getFirstBuild();\n            if (fb==null)        continue;\n// bug_end\n \n// bug_start\n            for (int i : getDownstreamRelationship(p).listNumbersReverse()) {\n\n                if (i<fb.getNumber())\n                    continue OUTER;\n\n                AbstractBuild<?,?> b = p.getBuildByNumber(i);\n                if (b!=null)\n                    return Messages.AbstractBuild_KeptBecause(b);\n            }\n// bug_end\n         }\n \n// bug_start\n        return super.getWhyKeepLog();\n// bug_end\n     }\n \n", "target": "// fix_start\npublic TokenValidatorResponse validateToken(TokenValidatorParameters tokenParameters) {\n        LOG.fine(\"Validating SAML Token\");\n        STSPropertiesMBean stsProperties = tokenParameters.getStsProperties();\n        Crypto sigCrypto = stsProperties.getSignatureCrypto();\n        CallbackHandler callbackHandler = stsProperties.getCallbackHandler();\n// fix_end\n// fix_start\n        TokenValidatorResponse response = new TokenValidatorResponse();\n        ReceivedToken validateTarget = tokenParameters.getToken();\n        validateTarget.setState(STATE.INVALID);\n        response.setToken(validateTarget);\n// fix_end\n// fix_start\n        if (!validateTarget.isDOMElement()) {\n            return response;\n// fix_end\n// fix_start\n        try {\n            Element validateTargetElement = (Element)validateTarget.getToken();\n            SamlAssertionWrapper assertion = new SamlAssertionWrapper(validateTargetElement);\n\n            SAMLTokenPrincipal samlPrincipal = new SAMLTokenPrincipalImpl(assertion);\n            response.setPrincipal(samlPrincipal);\n\n            SecurityToken secToken = null;\n            byte[] signatureValue = assertion.getSignatureValue();\n            if (tokenParameters.getTokenStore() != null && signatureValue != null\n                && signatureValue.length > 0) {\n                int hash = Arrays.hashCode(signatureValue);\n                secToken = tokenParameters.getTokenStore().getToken(Integer.toString(hash));\n                if (secToken != null && secToken.getTokenHash() != hash) {\n                    secToken = null;\n                }\n            }\n            if (secToken != null && secToken.isExpired()) {\n                LOG.fine(\"Token: \" + secToken.getId() + \" is in the cache but expired - revalidating\");\n                secToken = null;\n            }\n\n            if (secToken == null) {\n                if (!assertion.isSigned()) {\n                    LOG.log(Level.WARNING, \"The received assertion is not signed, and therefore not trusted\");\n                    return response;\n                }\n\n                RequestData requestData = new RequestData();\n                requestData.setSigVerCrypto(sigCrypto);\n                WSSConfig wssConfig = WSSConfig.getNewInstance();\n                requestData.setWssConfig(wssConfig);\n                requestData.setCallbackHandler(callbackHandler);\n                requestData.setMsgContext(tokenParameters.getWebServiceContext().getMessageContext());\n\n                WSDocInfo docInfo = new WSDocInfo(validateTargetElement.getOwnerDocument());\n\n                Signature sig = assertion.getSignature();\n                KeyInfo keyInfo = sig.getKeyInfo();\n                SAMLKeyInfo samlKeyInfo =\n                    SAMLUtil.getCredentialFromKeyInfo(\n                        keyInfo.getDOM(), new WSSSAMLKeyInfoProcessor(requestData, docInfo), sigCrypto\n                    );\n                assertion.verifySignature(samlKeyInfo);\n\n                validateAssertion(assertion);\n\n                Credential trustCredential = new Credential();\n                trustCredential.setPublicKey(samlKeyInfo.getPublicKey());\n                trustCredential.setCertificates(samlKeyInfo.getCerts());\n\n                trustCredential = validator.validate(trustCredential, requestData);\n\n                X509Certificate cert = null;\n                if (trustCredential.getCertificates() != null) {\n                    cert = trustCredential.getCertificates()[0];\n                }\n\n                if (!certConstraints.matches(cert)) {\n                    return response;\n                }\n\n            }\n\n            if (samlRoleParser != null) {\n                Set<Principal> roles =\n                    samlRoleParser.parseRolesFromAssertion(samlPrincipal, null, assertion);\n                response.setRoles(roles);\n            }\n\n            String tokenRealm = null;\n            if (samlRealmCodec != null) {\n                tokenRealm = samlRealmCodec.getRealmFromToken(assertion);\n                if (secToken != null) {\n                    Properties props = secToken.getProperties();\n                    if (props != null) {\n                        String cachedRealm = props.getProperty(STSConstants.TOKEN_REALM);\n                        if (cachedRealm != null && !tokenRealm.equals(cachedRealm)) {\n                            return response;\n                        }\n                    }\n                }\n            }\n            response.setTokenRealm(tokenRealm);\n\n            if (!validateConditions(assertion, validateTarget)) {\n                return response;\n            }\n\n            if (secToken == null) {\n                storeTokenInCache(\n                    tokenParameters.getTokenStore(), assertion, tokenParameters.getPrincipal(), tokenRealm\n                );\n            }\n\n            Map<String, Object> addProps = new HashMap<String, Object>();\n            addProps.put(SamlAssertionWrapper.class.getName(), assertion);\n            response.setAdditionalProperties(addProps);\n\n            validateTarget.setState(STATE.VALID);\n        } catch (WSSecurityException ex) {\n            LOG.log(Level.WARNING, \"\", ex);\n        }\n\n        return response;\n// fix_end\n", "cwe": "CWE-862", "cwe_name": "Missing Authorization", "idx": 84492}
{"source": "// bug_start\ndefault Argument<?> getErrorType(MediaType mediaType) {\n        if (mediaType.equals(MediaType.APPLICATION_JSON_TYPE)) {\n            return Argument.of(JsonError.class);\n        } else if (mediaType.equals(MediaType.APPLICATION_VND_ERROR_TYPE)) {\n            return Argument.of(VndError.class);\n        } else {\n            return Argument.STRING;\n// bug_end\n         }\n// bug_start\n// bug_end\n     }\n \n", "target": "// fix_start\npublic TokenValidatorResponse validateToken(TokenValidatorParameters tokenParameters) {\n        LOG.fine(\"Validating SAML Token\");\n        STSPropertiesMBean stsProperties = tokenParameters.getStsProperties();\n        Crypto sigCrypto = stsProperties.getSignatureCrypto();\n        CallbackHandler callbackHandler = stsProperties.getCallbackHandler();\n\n        TokenValidatorResponse response = new TokenValidatorResponse();\n        ReceivedToken validateTarget = tokenParameters.getToken();\n        validateTarget.setState(STATE.INVALID);\n        response.setToken(validateTarget);\n\n        if (!validateTarget.isDOMElement()) {\n            return response;\n// fix_end\n// fix_start\n\n        try {\n            Element validateTargetElement = (Element)validateTarget.getToken();\n            SamlAssertionWrapper assertion = new SamlAssertionWrapper(validateTargetElement);\n\n            SAMLTokenPrincipal samlPrincipal = new SAMLTokenPrincipalImpl(assertion);\n            response.setPrincipal(samlPrincipal);\n\n            if (!assertion.isSigned()) {\n                LOG.log(Level.WARNING, \"The received assertion is not signed, and therefore not trusted\");\n                return response;\n            }\n\n            RequestData requestData = new RequestData();\n            requestData.setSigVerCrypto(sigCrypto);\n            WSSConfig wssConfig = WSSConfig.getNewInstance();\n            requestData.setWssConfig(wssConfig);\n            requestData.setCallbackHandler(callbackHandler);\n            requestData.setMsgContext(tokenParameters.getWebServiceContext().getMessageContext());\n\n            WSDocInfo docInfo = new WSDocInfo(validateTargetElement.getOwnerDocument());\n\n            Signature sig = assertion.getSignature();\n            KeyInfo keyInfo = sig.getKeyInfo();\n            SAMLKeyInfo samlKeyInfo =\n                SAMLUtil.getCredentialFromKeyInfo(\n                    keyInfo.getDOM(), new WSSSAMLKeyInfoProcessor(requestData, docInfo), sigCrypto\n                );\n            assertion.verifySignature(samlKeyInfo);\n\n            SecurityToken secToken = null;\n            byte[] signatureValue = assertion.getSignatureValue();\n            if (tokenParameters.getTokenStore() != null && signatureValue != null\n                && signatureValue.length > 0) {\n                int hash = Arrays.hashCode(signatureValue);\n                secToken = tokenParameters.getTokenStore().getToken(Integer.toString(hash));\n                if (secToken != null && secToken.getTokenHash() != hash) {\n                    secToken = null;\n                }\n            }\n            if (secToken != null && secToken.isExpired()) {\n                LOG.fine(\"Token: \" + secToken.getId() + \" is in the cache but expired - revalidating\");\n                secToken = null;\n            }\n\n            if (secToken == null) {\n                validateAssertion(assertion);\n\n                Credential trustCredential = new Credential();\n                trustCredential.setPublicKey(samlKeyInfo.getPublicKey());\n                trustCredential.setCertificates(samlKeyInfo.getCerts());\n\n                trustCredential = validator.validate(trustCredential, requestData);\n\n                X509Certificate cert = null;\n                if (trustCredential.getCertificates() != null) {\n                    cert = trustCredential.getCertificates()[0];\n                }\n\n                if (!certConstraints.matches(cert)) {\n                    return response;\n                }\n            }\n\n            if (samlRoleParser != null) {\n                Set<Principal> roles =\n                    samlRoleParser.parseRolesFromAssertion(samlPrincipal, null, assertion);\n                response.setRoles(roles);\n            }\n\n            String tokenRealm = null;\n            if (samlRealmCodec != null) {\n                tokenRealm = samlRealmCodec.getRealmFromToken(assertion);\n                if (secToken != null) {\n                    Properties props = secToken.getProperties();\n                    if (props != null) {\n                        String cachedRealm = props.getProperty(STSConstants.TOKEN_REALM);\n                        if (cachedRealm != null && !tokenRealm.equals(cachedRealm)) {\n                            return response;\n                        }\n                    }\n                }\n            }\n            response.setTokenRealm(tokenRealm);\n\n            if (!validateConditions(assertion, validateTarget)) {\n                return response;\n            }\n\n            if (secToken == null) {\n                storeTokenInCache(\n                    tokenParameters.getTokenStore(), assertion, tokenParameters.getPrincipal(), tokenRealm\n                );\n            }\n\n            Map<String, Object> addProps = new HashMap<String, Object>();\n            addProps.put(SamlAssertionWrapper.class.getName(), assertion);\n            response.setAdditionalProperties(addProps);\n\n            validateTarget.setState(STATE.VALID);\n        } catch (WSSecurityException ex) {\n            LOG.log(Level.WARNING, \"\", ex);\n        }\n\n        return response;\n// fix_end\n", "cwe": "CWE-20", "cwe_name": "Improper Input Validation", "idx": 10857}
{"source": " @Override\n     public Argument<Session> argumentType() {\n// bug_start\n        return Argument.of(Session.class);\n// bug_end\n     }\n \n", "target": "// fix_start\n        return TYPE;\n// fix_end\n", "cwe": "CWE-400", "cwe_name": "Uncontrolled Resource Consumption", "idx": 52665}
{"source": "// bug_start\ndefault Argument<?> getErrorType(MediaType mediaType) {\n        if (mediaType.equals(MediaType.APPLICATION_JSON_TYPE)) {\n            return Argument.of(JsonError.class);\n        } else if (mediaType.equals(MediaType.APPLICATION_VND_ERROR_TYPE)) {\n            return Argument.of(VndError.class);\n        } else {\n            return Argument.of(String.class);\n        }\n// bug_end\n     }\n \n", "target": "// fix_start\ndefault boolean contains(String name) {\n        return get(name, Argument.OBJECT_ARGUMENT).isPresent();\n// fix_end\n", "cwe": "CWE-400", "cwe_name": "Uncontrolled Resource Consumption", "idx": 52463}
{"source": "// bug_start\ndefault boolean contains(String name) {\n        return get(name, Object.class).isPresent();\n// bug_end\n     }\n \n", "target": "// fix_start\n@Before\n    @Override\n    public void setUp() throws Exception {\n        super.setUp();\n\n        Connector c = getTomcatInstance().getConnector();\n        c.setProperty(\"secretRequired\", \"false\");\n// fix_end\n", "cwe": "CWE-400", "cwe_name": "Uncontrolled Resource Consumption", "idx": 52462}
{"source": " protected void configureParser(final XMLReader parser, final SAXHandler contentHandler)\n \t\t\tthrows JDOMException {\n \n \n \t\tparser.setContentHandler(contentHandler);\n \n \t\tif (saxEntityResolver != null) {\n \t\t\tparser.setEntityResolver(saxEntityResolver);\n \t\t}\n \n \t\tif (saxDTDHandler != null) {\n \t\t\tparser.setDTDHandler(saxDTDHandler);\n \t\t} else {\n \t\t\tparser.setDTDHandler(contentHandler);\n \t\t}\n \n \t\tif (saxErrorHandler != null) {\n \t\t\tparser.setErrorHandler(saxErrorHandler);\n \t\t} else {\n \t\t\tparser.setErrorHandler(new BuilderErrorHandler());\n \t\t}\n \n \t\tboolean success = false;\n \n \t\ttry {\n \t\t\tparser.setProperty(SAX_PROPERTY_LEXICAL_HANDLER,\n \t\t\t\t\tcontentHandler);\n \t\t\tsuccess = true;\n \t\t} catch (final SAXNotSupportedException e) {\n \t\t} catch (final SAXNotRecognizedException e) {\n \t\t}\n \n \t\tif (!success) {\n \t\t\ttry {\n \t\t\t\tparser.setProperty(SAX_PROPERTY_LEXICAL_HANDLER_ALT,\n \t\t\t\t\t\tcontentHandler);\n \t\t\t\tsuccess = true;\n \t\t\t} catch (final SAXNotSupportedException e) {\n \t\t\t} catch (final SAXNotRecognizedException e) {\n \t\t\t}\n \t\t}\n \n// bug_start\n\t\tfor (final Map.Entry<String, Boolean> me : features.entrySet()) {\n\t\t\tinternalSetFeature(parser, me.getKey(), me.getValue().booleanValue(), me.getKey());\n\t\t}\n\n// bug_end\n \t\tfor (final Map.Entry<String, Object> me : properties.entrySet()) {\n \t\t\tinternalSetProperty(parser, me.getKey(), me.getValue(), me.getKey());\n \t\t}\n \n \t\ttry {\n \t\t\tif (parser.getFeature(SAX_FEATURE_EXTERNAL_ENT) != expand) {\n \t\t\t\tparser.setFeature(SAX_FEATURE_EXTERNAL_ENT, expand);\n \t\t\t}\n \t\t} catch (final SAXException e) {\n \t\t}\n \n \t\tif (!expand) {\n \t\t\ttry {\n \t\t\t\tparser.setProperty(SAX_PROPERTY_DECLARATION_HANDLER,\n \t\t\t\t\t\tcontentHandler);\n \t\t\t\tsuccess = true;\n \t\t\t} catch (final SAXNotSupportedException e) {\n \t\t\t} catch (final SAXNotRecognizedException e) {\n \t\t\t}\n \t\t}\n// bug_start\n\n// bug_end\n \t}\n \n", "target": "// fix_start\n// fix_end\n// fix_start\n\t\tfor (final Map.Entry<String, Boolean> me : features.entrySet()) {\n\t\t\tinternalSetFeature(parser, me.getKey(), me.getValue().booleanValue(), me.getKey());\n\t\t}\n// fix_end\n", "cwe": "CWE-611", "cwe_name": "Improper Restriction of XML External Entity Reference ('XXE')", "idx": 67327}
{"source": "// bug_start\nprivate JMXConnectorServer createServer(String serverName,\n            String bindAddress, int theRmiRegistryPort, int theRmiServerPort,\n            HashMap<String,Object> theEnv,\n            RMIClientSocketFactory registryCsf, RMIServerSocketFactory registrySsf,\n            RMIClientSocketFactory serverCsf, RMIServerSocketFactory serverSsf) {\n\n        Registry registry;\n        try {\n            registry = LocateRegistry.createRegistry(\n                    theRmiRegistryPort, registryCsf, registrySsf);\n        } catch (RemoteException e) {\n            log.error(sm.getString(\n                    \"jmxRemoteLifecycleListener.createRegistryFailed\",\n                    serverName, Integer.toString(theRmiRegistryPort)), e);\n            return null;\n        }\n\n        if (bindAddress == null) {\n            bindAddress = \"localhost\";\n        }\n\n        String url = \"service:jmx:rmi://\" + bindAddress;\n        JMXServiceURL serviceUrl;\n        try {\n            serviceUrl = new JMXServiceURL(url);\n        } catch (MalformedURLException e) {\n            log.error(sm.getString(\"jmxRemoteLifecycleListener.invalidURL\", serverName, url), e);\n            return null;\n        }\n\n        RMIConnectorServer cs = null;\n        try {\n            RMIJRMPServerImpl server = new RMIJRMPServerImpl(\n                    rmiServerPortPlatform, serverCsf, serverSsf, theEnv);\n            cs = new RMIConnectorServer(serviceUrl, theEnv, server,\n                    ManagementFactory.getPlatformMBeanServer());\n            cs.start();\n            registry.bind(\"jmxrmi\", server.toStub());\n            log.info(sm.getString(\"jmxRemoteLifecycleListener.start\",\n                    Integer.toString(theRmiRegistryPort),\n                    Integer.toString(theRmiServerPort), serverName));\n        } catch (IOException e) {\n            log.error(sm.getString(\n                    \"jmxRemoteLifecycleListener.createServerFailed\",\n                    serverName), e);\n        } catch (AlreadyBoundException e) {\n            log.error(sm.getString(\n                    \"jmxRemoteLifecycleListener.createServerFailed\",\n                    serverName), e);\n        }\n        return cs;\n// bug_end\n     }\n \n", "target": "// fix_start\npublic String getPasswordValue(Object o) {\n        if (o==null)    return null;\n        if (o instanceof Secret)    return ((Secret)o).getEncryptedValue();\n        return o.toString();\n// fix_end\n", "cwe": "NVD-CWE-noinfo", "cwe_name": "", "idx": 101476}
{"source": " public void testEncryptHeader() throws Exception {\n         ENCRYPT.EncryptHeader hdr=new ENCRYPT.EncryptHeader((short)1, null);\n         _testSize(hdr);\n         hdr=new ENCRYPT.EncryptHeader((short)2, \"Hello world\");\n         _testSize(hdr);\n// bug_start\n// bug_end\n     }\n \n", "target": "// fix_start\n        EncryptHeader hdr2=new EncryptHeader((byte)1, new byte[]{'b','e', 'l', 'a'});\n        _testSize(hdr2);\n        hdr2=new EncryptHeader((byte)2, \"Hello world\".getBytes());\n        _testSize(hdr2);\n// fix_end\n", "cwe": "NVD-CWE-noinfo", "cwe_name": "", "idx": 108721}
{"source": " private MockHttpServletRequestBuilder createChangePasswordRequest(ScimUser user, ExpiringCode code, boolean useCSRF, String password, String passwordConfirmation) throws Exception {\n// bug_start\n        MockHttpServletRequestBuilder post = post(\"/reset_password.do\");\n        if (useCSRF) {\n            post.with(csrf());\n        }\n        post.param(\"code\", code.getCode())\n            .param(\"email\", user.getPrimaryEmail())\n            .param(\"password\", password)\n            .param(\"password_confirmation\", passwordConfirmation);\n        return post;\n// bug_end\n     }\n \n", "target": "// fix_start\n        return createChangePasswordRequest(user,code.getCode(),useCSRF, password,passwordConfirmation);\n// fix_end\n", "cwe": "CWE-640", "cwe_name": "", "idx": 71335}
{"source": " static void securityClassLoad(ClassLoader loader, boolean requireSecurityManager)\n             throws Exception {\n \n         if (requireSecurityManager && System.getSecurityManager() == null) {\n             return;\n         }\n \n         loadCorePackage(loader);\n         loadCoyotePackage(loader);\n         loadLoaderPackage(loader);\n         loadRealmPackage(loader);\n// bug_start\n// bug_end\n         loadSessionPackage(loader);\n         loadUtilPackage(loader);\n         loadValvesPackage(loader);\n         loadJavaxPackage(loader);\n         loadConnectorPackage(loader);\n         loadTomcatPackage(loader);\n     }\n \n", "target": "// fix_start\n        loadServletsPackage(loader);\n// fix_end\n", "cwe": "CWE-264", "cwe_name": "Permissions, Privileges, and Access Controls", "idx": 32740}
{"source": " private ServerWebExchange mapExchange(ServerWebExchange exchange, String methodParamValue) {\n \t\tHttpMethod httpMethod = HttpMethod.resolve(methodParamValue.toUpperCase(Locale.ENGLISH));\n \t\tAssert.notNull(httpMethod, () -> \"HttpMethod '\" + methodParamValue + \"' not supported\");\n// bug_start\n\t\treturn exchange.mutate().request(builder -> builder.method(httpMethod)).build();\n// bug_end\n \t}\n \n", "target": "// fix_start\n\t\tif (ALLOWED_METHODS.contains(httpMethod)) {\n\t\t\treturn exchange.mutate().request(builder -> builder.method(httpMethod)).build();\n\t\t}\n\t\telse {\n\t\t\treturn exchange;\n\t\t}\n// fix_end\n", "cwe": "NVD-CWE-noinfo", "cwe_name": "", "idx": 103420}
{"source": "// bug_start\npublic void handleMessage(SoapMessage msg) throws Fault {\n        if (msg.containsKey(SECURITY_PROCESSED) || isGET(msg)) {\n// bug_end\n             return;\n         }\n// bug_start\n        msg.put(SECURITY_PROCESSED, Boolean.TRUE);\n// bug_end\n \n// bug_start\n        boolean utWithCallbacks =\n            MessageUtils.getContextualBoolean(msg, SecurityConstants.VALIDATE_TOKEN, true);\n        translateProperties(msg);\n// bug_end\n \n// bug_start\n        RequestData reqData = new CXFRequestData();\n// bug_end\n \n// bug_start\n        WSSConfig config = (WSSConfig)msg.getContextualProperty(WSSConfig.class.getName());\n        WSSecurityEngine engine;\n        if (config != null) {\n            engine = new WSSecurityEngine();\n            engine.setWssConfig(config);\n// bug_end\n         } else {\n// bug_start\n            engine = getSecurityEngine(utWithCallbacks);\n            if (engine == null) {\n                engine = new WSSecurityEngine();\n            }\n            config = engine.getWssConfig();\n        }\n        reqData.setWssConfig(config);\n\n\n        SOAPMessage doc = getSOAPMessage(msg);\n\n        boolean doDebug = LOG.isLoggable(Level.FINE);\n        boolean doTimeLog = TIME_LOG.isLoggable(Level.FINE);\n\n        SoapVersion version = msg.getVersion();\n        if (doDebug) {\n            LOG.fine(\"WSS4JInInterceptor: enter handleMessage()\");\n        }\n\n        long t0 = 0;\n        long t1 = 0;\n        long t2 = 0;\n        long t3 = 0;\n\n        if (doTimeLog) {\n            t0 = System.currentTimeMillis();\n        }\n\n        try {\n            reqData.setMsgContext(msg);\n            computeAction(msg, reqData);\n            List<Integer> actions = new ArrayList<Integer>();\n            String action = getAction(msg, version);\n\n            int doAction = WSSecurityUtil.decodeAction(action, actions);\n\n            String actor = (String)getOption(WSHandlerConstants.ACTOR);\n\n            reqData.setCallbackHandler(getCallback(reqData, doAction, utWithCallbacks));\n\n            String passwordTypeStrict = (String)getOption(WSHandlerConstants.PASSWORD_TYPE_STRICT);\n            if (passwordTypeStrict == null) {\n                setProperty(WSHandlerConstants.PASSWORD_TYPE_STRICT, \"true\");\n            }\n\n            ReplayCache nonceCache =\n                getReplayCache(\n                    msg, SecurityConstants.ENABLE_NONCE_CACHE, SecurityConstants.NONCE_CACHE_INSTANCE\n                );\n            reqData.setNonceReplayCache(nonceCache);\n            ReplayCache timestampCache =\n                getReplayCache(\n                    msg, SecurityConstants.ENABLE_TIMESTAMP_CACHE, SecurityConstants.TIMESTAMP_CACHE_INSTANCE\n                );\n            reqData.setTimestampReplayCache(timestampCache);\n\n            doReceiverAction(doAction, reqData);\n\n            boolean enableRevocation = reqData.isRevocationEnabled()\n                || MessageUtils.isTrue(msg.getContextualProperty(SecurityConstants.ENABLE_REVOCATION));\n            reqData.setEnableRevocation(enableRevocation);\n\n            if (doTimeLog) {\n                t1 = System.currentTimeMillis();\n            }\n            Element elem = WSSecurityUtil.getSecurityHeader(doc.getSOAPPart(), actor);\n\n            List<WSSecurityEngineResult> wsResult = engine.processSecurityHeader(\n                elem, reqData\n            );\n\n            if (doTimeLog) {\n                t2 = System.currentTimeMillis();\n            }\n\n            if (wsResult != null && !wsResult.isEmpty()) {\n                if (reqData.getWssConfig().isEnableSignatureConfirmation()) {\n                    checkSignatureConfirmation(reqData, wsResult);\n                }\n\n                storeSignature(msg, reqData, wsResult);\n                storeTimestamp(msg, reqData, wsResult);\n                checkActions(msg, reqData, wsResult, actions);\n                doResults(\n                    msg, actor,\n                    SAAJUtils.getHeader(doc),\n                    SAAJUtils.getBody(doc),\n                    wsResult, utWithCallbacks\n                );\n            } else {\n                wsResult = new ArrayList<WSSecurityEngineResult>();\n                if (doc.getSOAPPart().getEnvelope().getBody().hasFault()) {\n                    LOG.warning(\"Request does not contain Security header, \"\n                                + \"but it's a fault.\");\n                    doResults(msg, actor,\n                              SAAJUtils.getHeader(doc),\n                              SAAJUtils.getBody(doc),\n                              wsResult);\n                } else {\n                    checkActions(msg, reqData, wsResult, actions);\n                    doResults(msg, actor,\n                              SAAJUtils.getHeader(doc),\n                              SAAJUtils.getBody(doc),\n                              wsResult);\n                }\n            }\n            advanceBody(msg, SAAJUtils.getBody(doc));\n            SAAJInInterceptor.replaceHeaders(doc, msg);\n\n            if (doTimeLog) {\n                t3 = System.currentTimeMillis();\n                TIME_LOG.fine(\"Receive request: total= \" + (t3 - t0)\n                        + \" request preparation= \" + (t1 - t0)\n                        + \" request processing= \" + (t2 - t1)\n                        + \" header, cert verify, timestamp= \" + (t3 - t2) + \"\\n\");\n            }\n\n            if (doDebug) {\n                LOG.fine(\"WSS4JInInterceptor: exit handleMessage()\");\n            }\n\n        } catch (WSSecurityException e) {\n            LOG.log(Level.WARNING, \"\", e);\n            SoapFault fault = createSoapFault(version, e);\n            throw fault;\n        } catch (XMLStreamException e) {\n            throw new SoapFault(new Message(\"STAX_EX\", LOG), e, version.getSender());\n        } catch (SOAPException e) {\n            throw new SoapFault(new Message(\"SAAJ_EX\", LOG), e, version.getSender());\n        } finally {\n            reqData.clear();\n            reqData = null;\n// bug_end\n         }\n     }\n \n", "target": "// fix_start\npublic void handleMessage(Message message) throws Fault {\n        String method = (String)message.get(Message.HTTP_REQUEST_METHOD);\n        if (LOG.isLoggable(Level.FINE)) {\n            LOG.fine(\"Invoking HTTP method \" + method);\n        }\n        if (!isGET(message)) {\n            if (LOG.isLoggable(Level.FINE)) {\n                LOG.log(Level.FINE, \"URIMappingInterceptor can only handle HTTP GET, not HTTP \" + method);\n            }\n// fix_end\n// fix_start\n// fix_end\n// fix_start\n        String opName = getOperationName(message);\n        if (LOG.isLoggable(Level.FINE)) {\n            LOG.fine(\"URIMappingInterceptor get operation: \" + opName);\n        }\n        BindingOperationInfo op = ServiceModelUtil.getOperation(message.getExchange(), opName);\n// fix_end\n// fix_start\n        if (op == null || opName == null || op.getName() == null\n            || StringUtils.isEmpty(op.getName().getLocalPart())\n            || !opName.equals(op.getName().getLocalPart())) {\n// fix_end\n// fix_start\n            if (!Boolean.TRUE.equals(message.getContextualProperty(NO_VALIDATE_PARTS))) {\n                throw new Fault(new org.apache.cxf.common.i18n.Message(\"NO_OPERATION_PATH\", LOG, opName,\n                                                                       message.get(Message.PATH_INFO)));\n            }\n            MessageContentsList params = new MessageContentsList();\n            params.add(null);\n            message.setContent(List.class, params);\n            if (op == null) {\n                op = findAnyOp(message.getExchange());\n            }\n            if (op != null) {\n                message.getExchange().put(BindingOperationInfo.class, op);\n            }\n// fix_end\n// fix_start\n            message.getExchange().put(BindingOperationInfo.class, op);\n            MessageContentsList params = getParameters(message, op);\n            message.setContent(List.class, params);\n// fix_end\n", "cwe": "CWE-287", "cwe_name": "Improper Authentication", "idx": 39139}
{"source": "// bug_start\npublic void handleMessage(Message message) throws Fault {\n        String method = (String)message.get(Message.HTTP_REQUEST_METHOD);\n        if (LOG.isLoggable(Level.FINE)) {\n            LOG.fine(\"Invoking HTTP method \" + method);\n        }\n        if (!isGET(message)) {\n            if (LOG.isLoggable(Level.FINE)) {\n                LOG.log(Level.FINE, \"URIMappingInterceptor can only handle HTTP GET, not HTTP \" + method);\n            }\n// bug_end\n             return;\n         }\n// bug_start\n        if (MessageUtils.getContextualBoolean(message, URIMAPPING_SKIP, false)) {\n            return;\n// bug_end\n         }\n \n// bug_start\n        String opName = getOperationName(message);\n        if (LOG.isLoggable(Level.FINE)) {\n            LOG.fine(\"URIMappingInterceptor get operation: \" + opName);\n// bug_end\n         }\n// bug_start\n        BindingOperationInfo op = ServiceModelUtil.getOperation(message.getExchange(), opName);\n// bug_end\n \n// bug_start\n        if (op == null || opName == null || op.getName() == null\n            || StringUtils.isEmpty(op.getName().getLocalPart())\n            || !opName.equals(op.getName().getLocalPart())) {\n// bug_end\n \n// bug_start\n            if (!Boolean.TRUE.equals(message.getContextualProperty(NO_VALIDATE_PARTS))) {\n                throw new Fault(new org.apache.cxf.common.i18n.Message(\"NO_OPERATION_PATH\", LOG, opName,\n                                                                       message.get(Message.PATH_INFO)));\n// bug_end\n             }\n// bug_start\n            MessageContentsList params = new MessageContentsList();\n            params.add(null);\n            message.setContent(List.class, params);\n            if (op == null) {\n                op = findAnyOp(message.getExchange());\n// bug_end\n             }\n// bug_start\n            if (op != null) {\n                message.getExchange().put(BindingOperationInfo.class, op);\n// bug_end\n             }\n// bug_start\n        } else {\n            message.getExchange().put(BindingOperationInfo.class, op);\n            MessageContentsList params = getParameters(message, op);\n            message.setContent(List.class, params);\n// bug_end\n         }\n     }\n \n", "target": "// fix_start\npublic void handleMessage(SoapMessage msg) throws Fault {\n        if (msg.containsKey(SECURITY_PROCESSED) || isGET(msg)) {\n// fix_end\n// fix_start\n        msg.put(URIMappingInterceptor.URIMAPPING_SKIP, Boolean.TRUE);\n        msg.put(SECURITY_PROCESSED, Boolean.TRUE);\n\n        boolean utWithCallbacks =\n            MessageUtils.getContextualBoolean(msg, SecurityConstants.VALIDATE_TOKEN, true);\n        translateProperties(msg);\n\n        RequestData reqData = new CXFRequestData();\n\n        WSSConfig config = (WSSConfig)msg.getContextualProperty(WSSConfig.class.getName());\n        WSSecurityEngine engine;\n        if (config != null) {\n            engine = new WSSecurityEngine();\n            engine.setWssConfig(config);\n        } else {\n            engine = getSecurityEngine(utWithCallbacks);\n            if (engine == null) {\n                engine = new WSSecurityEngine();\n            }\n            config = engine.getWssConfig();\n        }\n        reqData.setWssConfig(config);\n\n\n        SOAPMessage doc = getSOAPMessage(msg);\n\n        boolean doDebug = LOG.isLoggable(Level.FINE);\n        boolean doTimeLog = TIME_LOG.isLoggable(Level.FINE);\n\n        SoapVersion version = msg.getVersion();\n        if (doDebug) {\n            LOG.fine(\"WSS4JInInterceptor: enter handleMessage()\");\n// fix_end\n// fix_start\n        long t0 = 0;\n        long t1 = 0;\n        long t2 = 0;\n        long t3 = 0;\n\n        if (doTimeLog) {\n            t0 = System.currentTimeMillis();\n// fix_end\n// fix_start\n// fix_end\n// fix_start\n        try {\n            reqData.setMsgContext(msg);\n            computeAction(msg, reqData);\n            List<Integer> actions = new ArrayList<Integer>();\n            String action = getAction(msg, version);\n// fix_end\n// fix_start\n            int doAction = WSSecurityUtil.decodeAction(action, actions);\n\n            String actor = (String)getOption(WSHandlerConstants.ACTOR);\n\n            reqData.setCallbackHandler(getCallback(reqData, doAction, utWithCallbacks));\n\n            String passwordTypeStrict = (String)getOption(WSHandlerConstants.PASSWORD_TYPE_STRICT);\n            if (passwordTypeStrict == null) {\n                setProperty(WSHandlerConstants.PASSWORD_TYPE_STRICT, \"true\");\n// fix_end\n// fix_start\n\n            ReplayCache nonceCache =\n                getReplayCache(\n                    msg, SecurityConstants.ENABLE_NONCE_CACHE, SecurityConstants.NONCE_CACHE_INSTANCE\n                );\n            reqData.setNonceReplayCache(nonceCache);\n            ReplayCache timestampCache =\n                getReplayCache(\n                    msg, SecurityConstants.ENABLE_TIMESTAMP_CACHE, SecurityConstants.TIMESTAMP_CACHE_INSTANCE\n                );\n            reqData.setTimestampReplayCache(timestampCache);\n\n            doReceiverAction(doAction, reqData);\n\n            boolean enableRevocation = reqData.isRevocationEnabled()\n                || MessageUtils.isTrue(msg.getContextualProperty(SecurityConstants.ENABLE_REVOCATION));\n            reqData.setEnableRevocation(enableRevocation);\n\n            if (doTimeLog) {\n                t1 = System.currentTimeMillis();\n// fix_end\n// fix_start\n            Element elem = WSSecurityUtil.getSecurityHeader(doc.getSOAPPart(), actor);\n\n            List<WSSecurityEngineResult> wsResult = engine.processSecurityHeader(\n                elem, reqData\n            );\n\n            if (doTimeLog) {\n                t2 = System.currentTimeMillis();\n// fix_end\n// fix_start\n\n            if (wsResult != null && !wsResult.isEmpty()) {\n                if (reqData.getWssConfig().isEnableSignatureConfirmation()) {\n                    checkSignatureConfirmation(reqData, wsResult);\n                }\n\n                storeSignature(msg, reqData, wsResult);\n                storeTimestamp(msg, reqData, wsResult);\n                checkActions(msg, reqData, wsResult, actions);\n                doResults(\n                    msg, actor,\n                    SAAJUtils.getHeader(doc),\n                    SAAJUtils.getBody(doc),\n                    wsResult, utWithCallbacks\n                );\n            } else {\n                wsResult = new ArrayList<WSSecurityEngineResult>();\n                if (doc.getSOAPPart().getEnvelope().getBody().hasFault()) {\n                    LOG.warning(\"Request does not contain Security header, \"\n                                + \"but it's a fault.\");\n                    doResults(msg, actor,\n                              SAAJUtils.getHeader(doc),\n                              SAAJUtils.getBody(doc),\n                              wsResult);\n                } else {\n                    checkActions(msg, reqData, wsResult, actions);\n                    doResults(msg, actor,\n                              SAAJUtils.getHeader(doc),\n                              SAAJUtils.getBody(doc),\n                              wsResult);\n                }\n            }\n            advanceBody(msg, SAAJUtils.getBody(doc));\n            SAAJInInterceptor.replaceHeaders(doc, msg);\n\n            if (doTimeLog) {\n                t3 = System.currentTimeMillis();\n                TIME_LOG.fine(\"Receive request: total= \" + (t3 - t0)\n                        + \" request preparation= \" + (t1 - t0)\n                        + \" request processing= \" + (t2 - t1)\n                        + \" header, cert verify, timestamp= \" + (t3 - t2) + \"\\n\");\n            }\n\n            if (doDebug) {\n                LOG.fine(\"WSS4JInInterceptor: exit handleMessage()\");\n            }\n\n        } catch (WSSecurityException e) {\n            LOG.log(Level.WARNING, \"\", e);\n            SoapFault fault = createSoapFault(version, e);\n            throw fault;\n        } catch (XMLStreamException e) {\n            throw new SoapFault(new Message(\"STAX_EX\", LOG), e, version.getSender());\n        } catch (SOAPException e) {\n            throw new SoapFault(new Message(\"SAAJ_EX\", LOG), e, version.getSender());\n        } finally {\n            reqData.clear();\n            reqData = null;\n// fix_end\n", "cwe": "CWE-287", "cwe_name": "Improper Authentication", "idx": 39140}
{"source": " @Override\n     protected Settings nodeSettings(int nodeOrdinal) {\n         return ImmutableSettings.builder()\n// bug_start\n// bug_end\n                 .put(InternalNode.HTTP_ENABLED, true)\n                 .put(super.nodeSettings(nodeOrdinal)).build();\n     }\n \n", "target": "// fix_start\n                .putArray(URLRepository.ALLOWED_URLS_SETTING, \"http://snapshot.test*\")\n// fix_end\n", "cwe": "CWE-22", "cwe_name": "Path Traversal", "idx": 27468}
{"source": " PublicKey getRemotePublicKey(String nodename) {\n// bug_start\n// bug_end\n     String url = cores.getZkController().getZkStateReader().getBaseUrlForNodeName(nodename);\n     try {\n       String uri = url + PATH + \"?wt=json&omitHeader=true\";\n       log.debug(\"Fetching fresh public key from : {}\",uri);\n       HttpResponse rsp = cores.getUpdateShardHandler().getHttpClient()\n           .execute(new HttpGet(uri), HttpClientUtil.createNewHttpClientRequestContext());\n       byte[] bytes = EntityUtils.toByteArray(rsp.getEntity());\n       Map m = (Map) Utils.fromJSON(bytes);\n       String key = (String) m.get(\"key\");\n       if (key == null) {\n         log.error(\"No key available from \" + url + PATH);\n         return null;\n       } else {\n         log.info(\"New Key obtained from  node: {} / {}\", nodename, key);\n       }\n       PublicKey pubKey = CryptoKeys.deserializeX509PublicKey(key);\n       keyCache.put(nodename, pubKey);\n       return pubKey;\n     } catch (Exception e) {\n       log.error(\"Exception trying to get public key from : \" + url, e);\n       return null;\n     }\n \n   }\n \n", "target": "// fix_start\n    if (!cores.getZkController().getZkStateReader().getClusterState().getLiveNodes().contains(nodename)) return null;\n// fix_end\n", "cwe": "CWE-287", "cwe_name": "Improper Authentication", "idx": 39392}
{"source": " @Override\n     protected boolean op(String name, File path) throws SecurityException {\n         if (SystemProperties.getBoolean(SKIP_PROPERTY)) {\n             LOGGER.log(Level.FINE, () -> \"Skipping check for '\" + name + \"' on '\" + path + \"'\");\n             return false;\n         }\n// bug_start\n        if (!(context instanceof Computer)) {\n            LOGGER.log(Level.FINE, \"No context provided for path access: \" + path);\n            return false;\n        }\n        Computer c = (Computer) context;\n// bug_end\n \n         final Jenkins jenkins = Jenkins.get();\n \n         String patternString;\n         try {\n             patternString = Jenkins.expandVariablesForDirectory(jenkins.getRawBuildsDir(), \"(.+)\", \"\\\\Q\" + Jenkins.get().getRootDir().getCanonicalPath().replace('\\\\', '/') + \"\\\\E/jobs/(.+)\") + \"/[0-9]+(/.*)?\";\n         } catch (IOException e) {\n             LOGGER.log(Level.WARNING, \"Failed to obtain canonical path to Jenkins home directory\", e);\n             throw new SecurityException(\"Failed to obtain canonical path\");\n         }\n         final Pattern pattern = Pattern.compile(patternString);\n \n         String absolutePath;\n         try {\n             absolutePath = path.getCanonicalPath().replace('\\\\', '/');\n         } catch (IOException e) {\n             LOGGER.log(Level.WARNING, \"Failed to obtain canonical path to '\" + path + \"'\", e);\n             throw new SecurityException(\"Failed to obtain canonical path\");\n         }\n         if (!pattern.matcher(absolutePath).matches()) {\n             LOGGER.log(Level.FINE, \"Not a build directory, so skipping: \" + absolutePath);\n             return false;\n         }\n \n// bug_start\n// bug_end\n         final Path thePath = path.getAbsoluteFile().toPath();\n         for (Executor executor : c.getExecutors()) {\n             Run<?, ?> build = findRun(executor.getCurrentExecutable());\n             if (build == null) {\n                 continue;\n             }\n             final Path buildDir = build.getRootDir().getAbsoluteFile().toPath();\n             if (thePath.startsWith(buildDir)) {\n                 return false;\n             }\n         }\n \n         final String computerName = c.getName();\n         if (SystemProperties.getBoolean(FAIL_PROPERTY, true)) {\n             LOGGER.log(Level.WARNING, \"Rejecting unexpected agent-to-controller file path access: Agent '\" + computerName + \"' is attempting to access '\" + absolutePath + \"' using operation '\" + name + \"'. Learn more: https://www.jenkins.io/redirect/security-144/\");\n             throw new SecurityException(\"Agent tried to access build directory of a build not currently running on this system. Learn more: https://www.jenkins.io/redirect/security-144/\");\n         } else {\n             LOGGER.log(Level.WARNING, \"Unexpected agent-to-controller file path access: Agent '\" + computerName + \"' is accessing '\" + absolutePath + \"' using operation '\" + name + \"'. Learn more: https://www.jenkins.io/redirect/security-144/\");\n             return false;\n         }\n     }\n \n", "target": "// fix_start\n// fix_end\n// fix_start\n        if (!(context instanceof Computer)) {\n            LOGGER.warning(() -> \"Unrecognized context \" + context + \" rejected for \" + name + \" on \" + path);\n            throw new SecurityException(\"Failed to discover context of access to build directory\");\n        }\n        Computer c = (Computer) context;\n// fix_end\n", "cwe": "CWE-184", "cwe_name": "", "idx": 2526}
{"source": " @PresetData(DataSet.NO_ANONYMOUS_READACCESS)\n     @SuppressWarnings(\"SleepWhileInLoop\")\n     public void testServiceUsingDirectSecret() throws Exception {\n         Slave slave = createNewJnlpSlave(\"test\");\n         jenkins.setNodes(Collections.singletonList(slave));\n         new WebClient().goTo(\"computer/test/slave-agent.jnlp?encrypt=true\", \"application/octet-stream\");\n         String secret = slave.getComputer().getJnlpMac();\n         ProcessBuilder pb = new ProcessBuilder(JavaEnvUtils.getJreExecutable(\"java\"), \"-jar\", Which.jarFile(Launcher.class).getAbsolutePath(), \"-jnlpUrl\", getURL() + \"computer/test/slave-agent.jnlp\", \"-secret\", secret);\n         try {\n             pb = (ProcessBuilder) ProcessBuilder.class.getMethod(\"inheritIO\").invoke(pb);\n         } catch (NoSuchMethodException x) {\n         }\n         System.err.println(\"Running: \" + pb.command());\n         Process p = pb.start();\n         try {\n             for (int i = 0; i < 600; i++) {\n                 if (slave.getComputer().isOnline()) {\n                     System.err.println(\"JNLP slave successfully connected\");\n// bug_start\n// bug_end\n                     return;\n                 }\n                 Thread.sleep(100);\n             }\n             fail(\"JNLP slave agent failed to connect\");\n         } finally {\n             p.destroy();\n         }\n     }\n \n", "target": "// fix_start\n                    Channel channel = slave.getComputer().getChannel();\n                    assertFalse(\"SECURITY-206\", channel.isRemoteClassLoadingAllowed());\n                    jenkins.getExtensionList(AdminWhitelistRule.class).get(AdminWhitelistRule.class).setMasterKillSwitch(false);\n                    final File f = new File(jenkins.getRootDir(), \"config.xml\");\n                    assertTrue(f.exists());\n                    try {\n                        fail(\"SECURITY-206: \" + channel.call(new Attack(f.getAbsolutePath())));\n                    } catch (SecurityException x) {\n                        System.out.println(\"expected: \" + x);\n                        assertTrue(x.getMessage().contains(\"http://jenkins-ci.org/security-144\"));\n                    }\n// fix_end\n", "cwe": "CWE-284", "cwe_name": "Improper Access Control", "idx": 38190}
{"source": " protected Channel jnlpConnect(SlaveComputer computer) throws InterruptedException, IOException {\n             final String nodeName = computer.getName();\n             final OutputStream log = computer.openLogFile();\n             PrintWriter logw = new PrintWriter(log,true);\n             logw.println(\"JNLP agent connected from \"+ socket.getInetAddress());\n \n             try {\n                 ChannelBuilder cb = createChannelBuilder(nodeName);\n// bug_start\n// bug_end\n \n                 computer.setChannel(cb.withHeaderStream(log).build(socket), log,\n                     new Listener() {\n                         @Override\n                         public void onClosed(Channel channel, IOException cause) {\n                             if(cause!=null)\n                                 LOGGER.log(Level.WARNING, Thread.currentThread().getName()+\" for + \" + nodeName + \" terminated\",cause);\n                             try {\n                                 socket.close();\n                             } catch (IOException e) {\n                             }\n                         }\n                     });\n                 return computer.getChannel();\n             } catch (AbortException e) {\n                 logw.println(e.getMessage());\n                 logw.println(\"Failed to establish the connection with the slave\");\n                 throw e;\n             } catch (IOException e) {\n                 logw.println(\"Failed to establish the connection with the slave \" + nodeName);\n                 e.printStackTrace(logw);\n                 throw e;\n             }\n         }\n \n", "target": "// fix_start\n\n                for (ChannelConfigurator cc : ChannelConfigurator.all()) {\n                    cc.onChannelBuilding(cb, computer);\n                }\n// fix_end\n", "cwe": "CWE-284", "cwe_name": "Improper Access Control", "idx": 36901}
{"source": " public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {\n         CrumbIssuer crumbIssuer = getCrumbIssuer();\n         if (crumbIssuer == null || !(request instanceof HttpServletRequest)) {\n             chain.doFilter(request, response);\n             return;\n         }\n \n         HttpServletRequest httpRequest = (HttpServletRequest) request;\n         HttpServletResponse httpResponse = (HttpServletResponse) response;\n \n         if (\"POST\".equals(httpRequest.getMethod())) {\n             for (CrumbExclusion e : CrumbExclusion.all()) {\n                 if (e.process(httpRequest,httpResponse,chain))\n                     return;\n             }\n \n             String crumbFieldName = crumbIssuer.getDescriptor().getCrumbRequestField();\n             String crumbSalt = crumbIssuer.getDescriptor().getCrumbSalt();\n \n             String crumb = httpRequest.getHeader(crumbFieldName);\n             boolean valid = false;\n             if (crumb == null) {\n                 Enumeration<?> paramNames = request.getParameterNames();\n                 while (paramNames.hasMoreElements()) {\n                     String paramName = (String) paramNames.nextElement();\n                     if (crumbFieldName.equals(paramName)) {\n                         crumb = request.getParameter(paramName);\n                         break;\n                     }\n                 }\n             }\n             if (crumb != null) {\n                 if (crumbIssuer.validateCrumb(httpRequest, crumbSalt, crumb)) {\n                     valid = true;\n                 } else {\n                     LOGGER.log(Level.WARNING, \"Found invalid crumb {0}.  Will check remaining parameters for a valid one...\", crumb);\n                 }\n             }\n// bug_start\n            if (valid || isMultipart(httpRequest)) {\n// bug_end\n                 chain.doFilter(request, response);\n             } else {\n                 LOGGER.log(Level.WARNING, \"No valid crumb was included in request for {0}. Returning {1}.\", new Object[] {httpRequest.getRequestURI(), HttpServletResponse.SC_FORBIDDEN});\n                 httpResponse.sendError(HttpServletResponse.SC_FORBIDDEN,\"No valid crumb was included in the request\");\n             }\n         } else {\n             chain.doFilter(request, response);\n         }\n     }\n \n", "target": "// fix_start\n\n            if (valid) {\n// fix_end\n", "cwe": "NVD-CWE-noinfo", "cwe_name": "", "idx": 99446}
{"source": " @Override\n \tpublic void doFilter(ServletRequest request, ServletResponse response, FilterChain chain)\n \t\t\tthrows IOException, ServletException {\n \t\tif (!(request instanceof HttpServletRequest) || !(response instanceof HttpServletResponse)\n \t\t\t\t|| getNodesCollector().isMonitoringDisabled()) {\n \t\t\tsuper.doFilter(request, response, chain);\n \t\t\treturn;\n \t\t}\n \t\tfinal HttpServletRequest httpRequest = (HttpServletRequest) request;\n \n \t\tfinal String requestURI = httpRequest.getRequestURI();\n \t\tfinal String monitoringUrl = getMonitoringUrl(httpRequest);\n \t\tfinal String monitoringSlavesUrl = monitoringUrl + \"/nodes\";\n \t\tif (!PLUGIN_AUTHENTICATION_DISABLED\n// bug_start\n\t\t\t\t&& (requestURI.equals(monitoringUrl) || requestURI.equals(monitoringSlavesUrl))) {\n// bug_end\n \t\t\tJenkins.getInstance().checkPermission(Jenkins.ADMINISTER);\n// bug_start\n// bug_end\n \t\t}\n \n \t\tif (requestURI.startsWith(monitoringSlavesUrl)) {\n \t\t\tfinal String nodeName;\n \t\t\tif (requestURI.equals(monitoringSlavesUrl)) {\n \t\t\t\tnodeName = null;\n \t\t\t} else {\n \t\t\t\tnodeName = requestURI.substring(monitoringSlavesUrl.length()).replace(\"/\", \"\");\n \t\t\t}\n \t\t\tfinal HttpServletResponse httpResponse = (HttpServletResponse) response;\n \t\t\tdoMonitoring(httpRequest, httpResponse, nodeName);\n \t\t\treturn;\n \t\t}\n \n \t\tsuper.doFilter(request, response, chain);\n \t}\n \n", "target": "// fix_start\n\t\t\t\t&& (requestURI.equals(monitoringUrl) || requestURI.startsWith(monitoringSlavesUrl))) {\n// fix_end\n// fix_start\n            Enumeration<?> parameterNames = request.getParameterNames();\n            while (parameterNames.hasMoreElements()) {\n                String parameterName = (String) parameterNames.nextElement();\n                for (String value : request.getParameterValues(parameterName)) {\n                    if (value.indexOf('\"') != -1 || value.indexOf('\\'') != -1 || value.indexOf('<') != -1 || value.indexOf('&') != -1) {\n                        ((HttpServletResponse) response).sendError(HttpServletResponse.SC_BAD_REQUEST);\n                        return;\n                    }\n                }\n            }\n// fix_end\n", "cwe": "CWE-79", "cwe_name": "Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')", "idx": 80986}
{"source": " public void doDynamic(StaplerRequest req, StaplerResponse rsp) throws IOException, ServletException {\n         String path = req.getRestOfPath();\n \n         String pathUC = path.toUpperCase(Locale.ENGLISH);\n// bug_start\n        if (path.isEmpty() || path.contains(\"..\") || path.startsWith(\".\") || path.contains(\"%\") || pathUC.contains(\"META-INF\") || pathUC.contains(\"WEB-INF\")) {\n// bug_end\n             LOGGER.warning(\"rejecting possibly malicious \" + req.getRequestURIWithQueryString());\n             rsp.sendError(HttpServletResponse.SC_BAD_REQUEST);\n             return;\n         }\n \n         String requestPath = req.getRequestURI().substring(req.getContextPath().length());\n         boolean staticLink = requestPath.startsWith(\"/static/\");\n \n         long expires = staticLink ? TimeUnit2.DAYS.toMillis(365) : -1;\n \n         rsp.serveLocalizedFile(req, new URL(wrapper.baseResourceURL, '.' + path), expires);\n     }\n \n", "target": "// fix_start\n        if (path.isEmpty() || path.contains(\"..\") || path.startsWith(\".\") || path.contains(\"%\")\n                || pathUC.contains(\"META-INF\") || pathUC.contains(\"WEB-INF\")\n                || pathUC.equals(\"/.TIMESTAMP2\")\n        ) {\n// fix_end\n", "cwe": "CWE-200", "cwe_name": "Exposure of Sensitive Information to an Unauthorized Actor", "idx": 15682}
{"source": " public Map<String, Object> loadExport(Owner owner, File exportFile,\n         ConflictOverrides overrides)\n         throws ImporterException {\n         File tmpDir = null;\n         InputStream exportStream = null;\n         Map<String, Object> result = new HashMap<String, Object>();\n         try {\n             tmpDir = new SyncUtils(config).makeTempDir(\"import\");\n             extractArchive(tmpDir, exportFile);\n \n// bug_start\n\n\n// bug_end\n             File signature = new File(tmpDir, \"signature\");\n             if (signature.length() == 0) {\n                 throw new ImportExtractionException(i18n.tr(\"The archive does not \" +\n                                           \"contain the required signature file\"));\n// bug_start\n// bug_end\n             }\n \n             File consumerExport = new File(tmpDir, \"consumer_export.zip\");\n             File exportDir = extractArchive(tmpDir, consumerExport);\n \n             Map<String, File> importFiles = new HashMap<String, File>();\n             File[] listFiles = exportDir.listFiles();\n             if (listFiles == null || listFiles.length == 0) {\n                 throw new ImportExtractionException(i18n.tr(\"The consumer_export \" +\n                     \"archive has no contents\"));\n             }\n             for (File file : listFiles) {\n                 importFiles.put(file.getName(), file);\n             }\n \n             ConsumerDto consumer = importObjects(owner, importFiles, overrides);\n             Meta m = mapper.readValue(importFiles.get(ImportFile.META.fileName()),\n                 Meta.class);\n             result.put(\"consumer\", consumer);\n             result.put(\"meta\", m);\n             return result;\n         }\n         catch (FileNotFoundException fnfe) {\n             log.error(\"Archive file does not contain consumer_export.zip\", fnfe);\n             throw new ImportExtractionException(i18n.tr(\"The archive does not contain \" +\n                                            \"the required consumer_export.zip file\"));\n         }\n         catch (ConstraintViolationException cve) {\n             log.error(\"Failed to import archive\", cve);\n             throw new ImporterException(i18n.tr(\"Failed to import archive\"),\n                 cve);\n         }\n         catch (PersistenceException pe) {\n             log.error(\"Failed to import archive\", pe);\n             throw new ImporterException(i18n.tr(\"Failed to import archive\"),\n                 pe);\n         }\n         catch (IOException e) {\n             log.error(\"Exception caught importing archive\", e);\n             throw new ImportExtractionException(\"unable to extract export archive\", e);\n         }\n// bug_start\n// bug_end\n         finally {\n             if (tmpDir != null) {\n                 try {\n                     FileUtils.deleteDirectory(tmpDir);\n                 }\n                 catch (IOException e) {\n                     log.error(\"Failed to delete extracted export\", e);\n                 }\n             }\n             if (exportStream != null) {\n                 try {\n                     exportStream.close();\n                 }\n                 catch (Exception e) {\n                 }\n             }\n         }\n     }\n \n", "target": "// fix_start\n// fix_end\n// fix_start\n            }\n\n            exportStream = new FileInputStream(new File(tmpDir, \"consumer_export.zip\"));\n            boolean verifiedSignature = pki.verifySHA256WithRSAHashWithUpstreamCACert(\n                exportStream,\n                loadSignature(new File(tmpDir, \"signature\")));\n            if (!verifiedSignature) {\n                log.warn(\"Archive signature check failed.\");\n                if (!overrides\n                    .isForced(Conflict.SIGNATURE_CONFLICT)) {\n\n                    throw new ImportConflictException(\n                        i18n.tr(\"Archive failed signature check\"),\n                        Conflict.SIGNATURE_CONFLICT);\n                }\n                else {\n                    log.warn(\"Ignoring signature check failure.\");\n                }\n// fix_end\n// fix_start\n        catch (CertificateException e) {\n            log.error(\"Certificate exception checking archive signature\", e);\n            throw new ImportExtractionException(\n                \"Certificate exception checking archive signature\", e);\n        }\n// fix_end\n", "cwe": "CWE-264", "cwe_name": "Permissions, Privileges, and Access Controls", "idx": 34526}
{"source": " private void parse(State state, final String uri)\n         {\n             int mark = 0;\n             int pathMark = 0;\n             int segment = 0;\n             boolean encoded = false;\n             boolean dot = false;\n// bug_start\n            int escapedSlash = 0;\n// bug_end\n             int end = uri.length();\n             for (int i = 0; i < end; i++)\n             {\n                 char c = uri.charAt(i);\n \n                 switch (state)\n                 {\n                     case START:\n                     {\n                         switch (c)\n                         {\n                             case '/':\n                                 mark = i;\n                                 state = State.HOST_OR_PATH;\n                                 break;\n                             case ';':\n                                 mark = i + 1;\n                                 state = State.PARAM;\n                                 break;\n                             case '?':\n                                 _path = \"\";\n                                 mark = i + 1;\n                                 state = State.QUERY;\n                                 break;\n                             case '#':\n                                 mark = i + 1;\n                                 state = State.FRAGMENT;\n                                 break;\n                             case '*':\n                                 _path = \"*\";\n                                 state = State.ASTERISK;\n                                 break;\n                             case '%':\n                                 encoded = true;\n// bug_start\n                                escapedSlash = 1;\n// bug_end\n                                 mark = pathMark = segment = i;\n                                 state = State.PATH;\n                                 break;\n                             case '.':\n                                 dot = true;\n                                 pathMark = segment = i;\n                                 state = State.PATH;\n                                 break;\n                             default:\n                                 mark = i;\n                                 if (_scheme == null)\n                                     state = State.SCHEME_OR_PATH;\n                                 else\n                                 {\n                                     pathMark = segment = i;\n                                     state = State.PATH;\n                                 }\n                                 break;\n                         }\n                         continue;\n                     }\n \n                     case SCHEME_OR_PATH:\n                     {\n                         switch (c)\n                         {\n                             case ':':\n                                 _scheme = uri.substring(mark, i);\n                                 state = State.START;\n                                 break;\n                             case '/':\n                                 segment = i + 1;\n                                 state = State.PATH;\n                                 break;\n                             case ';':\n                                 mark = i + 1;\n                                 state = State.PARAM;\n                                 break;\n                             case '?':\n                                 _path = uri.substring(mark, i);\n                                 mark = i + 1;\n                                 state = State.QUERY;\n                                 break;\n                             case '%':\n                                 encoded = true;\n// bug_start\n                                escapedSlash = 1;\n// bug_end\n                                 state = State.PATH;\n                                 break;\n                             case '#':\n                                 _path = uri.substring(mark, i);\n                                 state = State.FRAGMENT;\n                                 break;\n                             default:\n                                 break;\n                         }\n                         continue;\n                     }\n                     case HOST_OR_PATH:\n                     {\n                         switch (c)\n                         {\n                             case '/':\n                                 _host = \"\";\n                                 mark = i + 1;\n                                 state = State.HOST;\n                                 break;\n                             case '%':\n                             case '@':\n                             case ';':\n                             case '?':\n                             case '#':\n                             case '.':\n                                 i--;\n                                 pathMark = mark;\n                                 segment = mark + 1;\n                                 state = State.PATH;\n                                 break;\n                             default:\n                                 pathMark = mark;\n                                 segment = mark + 1;\n                                 state = State.PATH;\n                         }\n                         continue;\n                     }\n \n                     case HOST:\n                     {\n                         switch (c)\n                         {\n                             case '/':\n                                 _host = uri.substring(mark, i);\n                                 pathMark = mark = i;\n                                 segment = mark + 1;\n                                 state = State.PATH;\n                                 break;\n                             case ':':\n                                 if (i > mark)\n                                     _host = uri.substring(mark, i);\n                                 mark = i + 1;\n                                 state = State.PORT;\n                                 break;\n                             case '@':\n                                 if (_user != null)\n                                     throw new IllegalArgumentException(\"Bad authority\");\n                                 _user = uri.substring(mark, i);\n                                 mark = i + 1;\n                                 break;\n                             case '[':\n                                 state = State.IPV6;\n                                 break;\n                             default:\n                                 break;\n                         }\n                         break;\n                     }\n                     case IPV6:\n                     {\n                         switch (c)\n                         {\n                             case '/':\n                                 throw new IllegalArgumentException(\"No closing ']' for ipv6 in \" + uri);\n                             case ']':\n                                 c = uri.charAt(++i);\n                                 _host = uri.substring(mark, i);\n                                 if (c == ':')\n                                 {\n                                     mark = i + 1;\n                                     state = State.PORT;\n                                 }\n                                 else\n                                 {\n                                     pathMark = mark = i;\n                                     state = State.PATH;\n                                 }\n                                 break;\n                             default:\n                                 break;\n                         }\n                         break;\n                     }\n                     case PORT:\n                     {\n                         if (c == '@')\n                         {\n                             if (_user != null)\n                                 throw new IllegalArgumentException(\"Bad authority\");\n                             _user = _host + \":\" + uri.substring(mark, i);\n                             mark = i + 1;\n                             state = State.HOST;\n                         }\n                         else if (c == '/')\n                         {\n                             _port = TypeUtil.parseInt(uri, mark, i - mark, 10);\n                             pathMark = mark = i;\n                             segment = i + 1;\n                             state = State.PATH;\n                         }\n                         break;\n                     }\n                     case PATH:\n                     {\n                         switch (c)\n                         {\n                             case ';':\n                                 checkSegment(uri, segment, i, true);\n                                 mark = i + 1;\n                                 state = State.PARAM;\n                                 break;\n                             case '?':\n                                 checkSegment(uri, segment, i, false);\n                                 _path = uri.substring(pathMark, i);\n                                 mark = i + 1;\n                                 state = State.QUERY;\n                                 break;\n                             case '#':\n                                 checkSegment(uri, segment, i, false);\n                                 _path = uri.substring(pathMark, i);\n                                 mark = i + 1;\n                                 state = State.FRAGMENT;\n                                 break;\n                             case '/':\n                                 checkSegment(uri, segment, i, false);\n                                 segment = i + 1;\n                                 break;\n                             case '.':\n                                 dot |= segment == i;\n                                 break;\n                             case '%':\n                                 encoded = true;\n// bug_start\n                                escapedSlash = 1;\n// bug_end\n                                 break;\n                             case '2':\n// bug_start\n                                escapedSlash = escapedSlash == 1 ? 2 : 0;\n// bug_end\n                                 break;\n                             case 'f':\n                             case 'F':\n// bug_start\n                                if (escapedSlash == 2)\n// bug_end\n                                     _ambiguous.add(Ambiguous.SEPARATOR);\n// bug_start\n                                escapedSlash = 0;\n                                break;\n                            default:\n                                escapedSlash = 0;\n// bug_end\n                                 break;\n                         }\n                         break;\n                     }\n                     case PARAM:\n                     {\n                         switch (c)\n                         {\n                             case '?':\n                                 _path = uri.substring(pathMark, i);\n                                 _param = uri.substring(mark, i);\n                                 mark = i + 1;\n                                 state = State.QUERY;\n                                 break;\n                             case '#':\n                                 _path = uri.substring(pathMark, i);\n                                 _param = uri.substring(mark, i);\n                                 mark = i + 1;\n                                 state = State.FRAGMENT;\n                                 break;\n                             case '/':\n                                 encoded = true;\n                                 segment = i + 1;\n                                 state = State.PATH;\n                                 break;\n                             case ';':\n                                 mark = i + 1;\n                                 break;\n                             default:\n                                 break;\n                         }\n                         break;\n                     }\n                     case QUERY:\n                     {\n                         if (c == '#')\n                         {\n                             _query = uri.substring(mark, i);\n                             mark = i + 1;\n                             state = State.FRAGMENT;\n                         }\n                         break;\n                     }\n                     case ASTERISK:\n                     {\n                         throw new IllegalArgumentException(\"Bad character '*'\");\n                     }\n                     case FRAGMENT:\n                     {\n                         _fragment = uri.substring(mark, end);\n                         i = end;\n                         break;\n                     }\n                     default:\n                         throw new IllegalStateException(state.toString());\n                 }\n             }\n \n             switch (state)\n             {\n                 case START:\n                 case ASTERISK:\n                     break;\n                 case SCHEME_OR_PATH:\n                 case HOST_OR_PATH:\n                     _path = uri.substring(mark, end);\n                     break;\n                 case HOST:\n                     if (end > mark)\n                         _host = uri.substring(mark, end);\n                     break;\n                 case IPV6:\n                     throw new IllegalArgumentException(\"No closing ']' for ipv6 in \" + uri);\n                 case PORT:\n                     _port = TypeUtil.parseInt(uri, mark, end - mark, 10);\n                     break;\n                 case PARAM:\n                     _path = uri.substring(pathMark, end);\n                     _param = uri.substring(mark, end);\n                     break;\n                 case PATH:\n                     checkSegment(uri, segment, end, false);\n                     _path = uri.substring(pathMark, end);\n                     break;\n                 case QUERY:\n                     _query = uri.substring(mark, end);\n                     break;\n                 case FRAGMENT:\n                     _fragment = uri.substring(mark, end);\n                     break;\n                 default:\n                     throw new IllegalStateException(state.toString());\n             }\n \n             if (!encoded && !dot)\n             {\n                 if (_param == null)\n                     _decodedPath = _path;\n                 else\n                     _decodedPath = _path.substring(0, _path.length() - _param.length() - 1);\n             }\n             else if (_path != null)\n             {\n                 String canonical = URIUtil.canonicalPath(_path);\n                 if (canonical == null)\n                     throw new BadMessageException(\"Bad URI\");\n                 _decodedPath = URIUtil.decodePath(canonical);\n             }\n         }\n \n", "target": "// fix_start\n            int escapedTwo = 0;\n// fix_end\n// fix_start\n                                escapedTwo = 1;\n// fix_end\n// fix_start\n                                escapedTwo = 1;\n// fix_end\n// fix_start\n                                escapedTwo = 1;\n// fix_end\n// fix_start\n                                escapedTwo = escapedTwo == 1 ? 2 : 0;\n// fix_end\n// fix_start\n                                if (escapedTwo == 2)\n// fix_end\n// fix_start\n                                escapedTwo = 0;\n                                break;\n                            case '5':\n                                if (escapedTwo == 2)\n                                    _ambiguous.add(Ambiguous.ENCODING);\n                                escapedTwo = 0;\n                                break;\n                            default:\n                                escapedTwo = 0;\n// fix_end\n", "cwe": "NVD-CWE-Other", "cwe_name": "Other", "idx": 114640}
{"source": "// bug_start\nprivate boolean isInvalidEncodedPath(String resourcePath) {\n\t\tif (resourcePath.contains(\"%\")) {\n\t\t\ttry {\n\t\t\t\tString decodedPath = URLDecoder.decode(resourcePath, \"UTF-8\");\n\t\t\t\tint separatorIndex = decodedPath.indexOf(\"..\") + 2;\n\t\t\t\tif (separatorIndex > 1 && separatorIndex < decodedPath.length()) {\n\t\t\t\t\tchar separator = decodedPath.charAt(separatorIndex);\n\t\t\t\t\tif (separator == '/' || separator == '\\\\') {\n\t\t\t\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\t\t\t\tlogger.trace(\"Resolved resource path contains \\\"../\\\" after decoding: \" + resourcePath);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (UnsupportedEncodingException ex) {\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n// bug_end\n \n", "target": "// fix_start\npublic void parse(\n            InputStream stream, ContentHandler handler,\n            Metadata metadata, ParseContext context)\n            throws IOException, SAXException, TikaException {\n        byte[] header = new byte[4];\n        IOUtils.readFully(stream, header, 0, 4);\n        if (header[0] == (byte) 'i' && header[1] == (byte) 'c'\n                && header[2] == (byte) 'n' && header[3] == (byte) 's') {\n        } else {\n            throw new TikaException(\"ICNS magic signature invalid\");\n        }\n        IOUtils.readFully(stream, header, 0, 4);\n        int image_length = java.nio.ByteBuffer.wrap(header).getInt();\n        if (image_length > MAX_IMAGE_LENGTH_BYTES) {\n            throw new TikaMemoryLimitException(image_length, MAX_IMAGE_LENGTH_BYTES);\n        }\n        byte[] full_file = new byte[image_length];\n        IOUtils.readFully(stream, full_file);\n        ArrayList<ICNSType> icons = new ArrayList<>();\n        ArrayList<ICNSType> icon_masks = new ArrayList<>();\n        byte[] tempByteArray = new byte[4];\n        for (int offset = 0; offset < image_length - 8;) {\n            tempByteArray[0] = full_file[offset];\n            tempByteArray[1] = full_file[offset + 1];\n            tempByteArray[2] = full_file[offset + 2];\n            tempByteArray[3] = full_file[offset + 3];\n            ICNSType icnstype = findIconType(tempByteArray);\n// fix_end\n// fix_start\n            if (icnstype == null) {\n                break;\n            } else if (icnstype.hasMask() == true) {\n                icon_masks.add(findIconType(tempByteArray));\n            } else {\n                icons.add(findIconType(tempByteArray));\n\n            }\n            tempByteArray[0] = full_file[offset + 4];\n            tempByteArray[1] = full_file[offset + 5];\n            tempByteArray[2] = full_file[offset + 6];\n            tempByteArray[3] = full_file[offset + 7];\n            int icon_length = java.nio.ByteBuffer.wrap(tempByteArray).getInt();\n            if (icon_length <= 0) {\n                break;\n            }\n            offset = offset + icon_length;\n        }\n        String icon_details = \"\", iconmask_details = \"\", bitsPerPixel,dimensions;\n        for (ICNSType icon : icons) {\n             bitsPerPixel = (icon.getBitsPerPixel()!=0)?icon.getBitsPerPixel() + \" bpp\":\"JPEG 2000 or PNG format\";\n             dimensions = (!icon.hasRetinaDisplay())?(icon.getHeight() + \"x\" + icon.getWidth()):(icon.getHeight() + \"x\" + icon.getWidth() + \"@2X\");\n             icon_details = icon_details + \", \" + dimensions + \" (\" + bitsPerPixel + \")\";\n        }\n        for (ICNSType icon : icon_masks) {\n            iconmask_details = iconmask_details + \", \" + icon.getHeight() + \"x\" + icon.getWidth() + \" (\" + icon.getBitsPerPixel() + \" bpp\" + \")\";\n        }\n\n        metadata.set(Metadata.CONTENT_TYPE, ICNS_MIME_TYPE);\n        if (!icon_details.equals(\"\")) {\n            metadata.set(\"Icon count\", String.valueOf(icons.size()));\n            icon_details = icon_details.substring(2);\n            metadata.set(\"Icon details\", icon_details);\n        }\n        if (!iconmask_details.equals(\"\")) {\n            metadata.set(\"Masked icon count\", String.valueOf(icon_masks.size()));\n            iconmask_details = iconmask_details.substring(2);\n            metadata.set(\"Masked icon details\", iconmask_details);\n        }\n        XHTMLContentHandler xhtml = new XHTMLContentHandler(handler, metadata);\n        xhtml.startDocument();\n        xhtml.endDocument();\n    }\n\n// fix_end\n", "cwe": "CWE-22", "cwe_name": "Path Traversal", "idx": 27009}
{"source": "// bug_start\npublic void parse(\n            InputStream stream, ContentHandler handler,\n            Metadata metadata, ParseContext context)\n            throws IOException, SAXException, TikaException {\n        byte[] header = new byte[4];\n        IOUtils.readFully(stream, header, 0, 4);\n        if (header[0] == (byte) 'i' && header[1] == (byte) 'c'\n                && header[2] == (byte) 'n' && header[3] == (byte) 's') {\n// bug_end\n         } else {\n// bug_start\n            throw new TikaException(\"ICNS magic signature invalid\");\n// bug_end\n         }\n// bug_start\n        IOUtils.readFully(stream, header, 0, 4);\n        int image_length = java.nio.ByteBuffer.wrap(header).getInt();\n        if (image_length > MAX_IMAGE_LENGTH_BYTES) {\n            throw new TikaMemoryLimitException(image_length, MAX_IMAGE_LENGTH_BYTES);\n        }\n        byte[] full_file = new byte[image_length];\n        IOUtils.readFully(stream, full_file);\n        ArrayList<ICNSType> icons = new ArrayList<>();\n        ArrayList<ICNSType> icon_masks = new ArrayList<>();\n        byte[] tempByteArray = new byte[4];\n        for (int offset = 0; offset < image_length - 8;) {\n            tempByteArray[0] = full_file[offset];\n            tempByteArray[1] = full_file[offset + 1];\n            tempByteArray[2] = full_file[offset + 2];\n            tempByteArray[3] = full_file[offset + 3];\n            ICNSType icnstype = findIconType(tempByteArray);\n\n            if (icnstype == null) {\n                break;\n            } else if (icnstype.hasMask() == true) {\n                icon_masks.add(findIconType(tempByteArray));\n            } else {\n                icons.add(findIconType(tempByteArray));\n\n            }\n            tempByteArray[0] = full_file[offset + 4];\n            tempByteArray[1] = full_file[offset + 5];\n            tempByteArray[2] = full_file[offset + 6];\n            tempByteArray[3] = full_file[offset + 7];\n            int icon_length = java.nio.ByteBuffer.wrap(tempByteArray).getInt();\n            offset = offset + icon_length;\n        }\n        String icon_details = \"\", iconmask_details = \"\", bitsPerPixel,dimensions;\n        for (ICNSType icon : icons) {\n             bitsPerPixel = (icon.getBitsPerPixel()!=0)?icon.getBitsPerPixel() + \" bpp\":\"JPEG 2000 or PNG format\";\n             dimensions = (!icon.hasRetinaDisplay())?(icon.getHeight() + \"x\" + icon.getWidth()):(icon.getHeight() + \"x\" + icon.getWidth() + \"@2X\");\n             icon_details = icon_details + \", \" + dimensions + \" (\" + bitsPerPixel + \")\";\n        }\n        for (ICNSType icon : icon_masks) {\n            iconmask_details = iconmask_details + \", \" + icon.getHeight() + \"x\" + icon.getWidth() + \" (\" + icon.getBitsPerPixel() + \" bpp\" + \")\";\n        }\n\n        metadata.set(Metadata.CONTENT_TYPE, ICNS_MIME_TYPE);\n        if (!icon_details.equals(\"\")) {\n            metadata.set(\"Icon count\", String.valueOf(icons.size()));\n            icon_details = icon_details.substring(2);\n            metadata.set(\"Icon details\", icon_details);\n        }\n        if (!iconmask_details.equals(\"\")) {\n            metadata.set(\"Masked icon count\", String.valueOf(icon_masks.size()));\n            iconmask_details = iconmask_details.substring(2);\n            metadata.set(\"Masked icon details\", iconmask_details);\n        }\n        XHTMLContentHandler xhtml = new XHTMLContentHandler(handler, metadata);\n        xhtml.startDocument();\n        xhtml.endDocument();\n// bug_end\n     }\n \n", "target": "// fix_start\nprotected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        PrintWriter out = response.getWriter();\n        String[] stocks = request.getParameterValues(\"stocks\");\n        if (stocks == null || stocks.length == 0) {\n            out.println(\"<html><body>No <b>stocks</b> query parameter specified. Cannot publish market data</body></html>\");\n// fix_end\n// fix_start\n            Integer total = (Integer)request.getSession(true).getAttribute(\"total\");\n            if (total == null) {\n                total = Integer.valueOf(0);\n            }\n\n            int count = getNumberOfMessages(request);\n            total = Integer.valueOf(total.intValue() + count);\n            request.getSession().setAttribute(\"total\", total);\n\n            try {\n                WebClient client = WebClient.getWebClient(request);\n                for (int i = 0; i < count; i++) {\n                    sendMessage(client, stocks);\n                }\n                out.print(\"<html><head><meta http-equiv='refresh' content='\");\n                String refreshRate = request.getParameter(\"refresh\");\n                if (refreshRate == null || refreshRate.length() == 0) {\n                    refreshRate = \"1\";\n                }\n                out.print(escape(refreshRate));\n                out.println(\"'/></head>\");\n                out.println(\"<body>Published <b>\" + escape(Integer.toString(count)) + \"</b> of \" + escape(Integer.toString(total))\n                        + \" price messages.  Refresh = \" + escape(refreshRate) + \"s\");\n                out.println(\"</body></html>\");\n\n            } catch (JMSException e) {\n                out.println(\"<html><body>Failed sending price messages due to <b>\" + e + \"</b></body></html>\");\n                log(\"Failed to send message: \" + e, e);\n            }\n// fix_end\n// fix_start\n// fix_end\n", "cwe": "CWE-835", "cwe_name": "Loop with Unreachable Exit Condition ('Infinite Loop')", "idx": 83412}
{"source": "// bug_start\npublic static ClassLoader getContextClassLoader() {\n        return AccessController.doPrivileged((PrivilegedAction<ClassLoader>) () -> {\n            ClassLoader tccl = null;\n            try {\n                tccl = Thread.currentThread().getContextClassLoader();\n            } catch (SecurityException ex) {\n                LOG.warn(\"Unable to get context classloader instance.\", ex);\n            }\n            return tccl;\n        });\n// bug_end\n     }\n \n", "target": "// fix_start\nstatic ClassLoader getContextClassLoader() {\n        if (System.getSecurityManager() == null) {\n            return Thread.currentThread().getContextClassLoader();\n        } else {\n            return AccessController.doPrivileged((PrivilegedAction<ClassLoader>) () -> {\n                ClassLoader tccl = null;\n                try {\n                    tccl = Thread.currentThread().getContextClassLoader();\n                } catch (SecurityException ex) {\n                    LOG.warn(\"Unable to get context classloader instance.\", ex);\n                }\n                return tccl;\n            });\n        }\n// fix_end\n", "cwe": "CWE-863", "cwe_name": "Incorrect Authorization", "idx": 88702}
{"source": " private RootBeanDefinition registerMessageBroker(Element brokerElement,\n \t\t\tRuntimeBeanReference inChannel, RuntimeBeanReference outChannel, RuntimeBeanReference brokerChannel,\n \t\t\tObject userDestHandler, RuntimeBeanReference brokerTemplate, RuntimeBeanReference userRegistry,\n \t\t\tParserContext context, @Nullable Object source) {\n \n \t\tElement simpleBrokerElem = DomUtils.getChildElementByTagName(brokerElement, \"simple-broker\");\n \t\tElement brokerRelayElem = DomUtils.getChildElementByTagName(brokerElement, \"stomp-broker-relay\");\n \n \t\tConstructorArgumentValues cargs = new ConstructorArgumentValues();\n \t\tcargs.addIndexedArgumentValue(0, inChannel);\n \t\tcargs.addIndexedArgumentValue(1, outChannel);\n \t\tcargs.addIndexedArgumentValue(2, brokerChannel);\n \n \t\tRootBeanDefinition brokerDef;\n \t\tif (simpleBrokerElem != null) {\n \t\t\tString prefix = simpleBrokerElem.getAttribute(\"prefix\");\n \t\t\tcargs.addIndexedArgumentValue(3, Arrays.asList(StringUtils.tokenizeToStringArray(prefix, \",\")));\n \t\t\tbrokerDef = new RootBeanDefinition(SimpleBrokerMessageHandler.class, cargs, null);\n \t\t\tif (brokerElement.hasAttribute(\"path-matcher\")) {\n \t\t\t\tString pathMatcherRef = brokerElement.getAttribute(\"path-matcher\");\n \t\t\t\tbrokerDef.getPropertyValues().add(\"pathMatcher\", new RuntimeBeanReference(pathMatcherRef));\n \t\t\t}\n \t\t\tif (simpleBrokerElem.hasAttribute(\"scheduler\")) {\n \t\t\t\tString scheduler = simpleBrokerElem.getAttribute(\"scheduler\");\n \t\t\t\tbrokerDef.getPropertyValues().add(\"taskScheduler\", new RuntimeBeanReference(scheduler));\n \t\t\t}\n \t\t\tif (simpleBrokerElem.hasAttribute(\"heartbeat\")) {\n \t\t\t\tString heartbeatValue = simpleBrokerElem.getAttribute(\"heartbeat\");\n \t\t\t\tbrokerDef.getPropertyValues().add(\"heartbeatValue\", heartbeatValue);\n// bug_start\n// bug_end\n \t\t\t}\n \t\t}\n \t\telse if (brokerRelayElem != null) {\n \t\t\tString prefix = brokerRelayElem.getAttribute(\"prefix\");\n \t\t\tcargs.addIndexedArgumentValue(3, Arrays.asList(StringUtils.tokenizeToStringArray(prefix, \",\")));\n \n \t\t\tMutablePropertyValues values = new MutablePropertyValues();\n \t\t\tif (brokerRelayElem.hasAttribute(\"relay-host\")) {\n \t\t\t\tvalues.add(\"relayHost\", brokerRelayElem.getAttribute(\"relay-host\"));\n \t\t\t}\n \t\t\tif (brokerRelayElem.hasAttribute(\"relay-port\")) {\n \t\t\t\tvalues.add(\"relayPort\", brokerRelayElem.getAttribute(\"relay-port\"));\n \t\t\t}\n \t\t\tif (brokerRelayElem.hasAttribute(\"client-login\")) {\n \t\t\t\tvalues.add(\"clientLogin\", brokerRelayElem.getAttribute(\"client-login\"));\n \t\t\t}\n \t\t\tif (brokerRelayElem.hasAttribute(\"client-passcode\")) {\n \t\t\t\tvalues.add(\"clientPasscode\", brokerRelayElem.getAttribute(\"client-passcode\"));\n \t\t\t}\n \t\t\tif (brokerRelayElem.hasAttribute(\"system-login\")) {\n \t\t\t\tvalues.add(\"systemLogin\", brokerRelayElem.getAttribute(\"system-login\"));\n \t\t\t}\n \t\t\tif (brokerRelayElem.hasAttribute(\"system-passcode\")) {\n \t\t\t\tvalues.add(\"systemPasscode\", brokerRelayElem.getAttribute(\"system-passcode\"));\n \t\t\t}\n \t\t\tif (brokerRelayElem.hasAttribute(\"heartbeat-send-interval\")) {\n \t\t\t\tvalues.add(\"systemHeartbeatSendInterval\", brokerRelayElem.getAttribute(\"heartbeat-send-interval\"));\n \t\t\t}\n \t\t\tif (brokerRelayElem.hasAttribute(\"heartbeat-receive-interval\")) {\n \t\t\t\tvalues.add(\"systemHeartbeatReceiveInterval\", brokerRelayElem.getAttribute(\"heartbeat-receive-interval\"));\n \t\t\t}\n \t\t\tif (brokerRelayElem.hasAttribute(\"virtual-host\")) {\n \t\t\t\tvalues.add(\"virtualHost\", brokerRelayElem.getAttribute(\"virtual-host\"));\n \t\t\t}\n \t\t\tManagedMap<String, Object> map = new ManagedMap<>();\n \t\t\tmap.setSource(source);\n \t\t\tif (brokerRelayElem.hasAttribute(\"user-destination-broadcast\")) {\n \t\t\t\tString destination = brokerRelayElem.getAttribute(\"user-destination-broadcast\");\n \t\t\t\tmap.put(destination, userDestHandler);\n \t\t\t}\n \t\t\tif (brokerRelayElem.hasAttribute(\"user-registry-broadcast\")) {\n \t\t\t\tString destination = brokerRelayElem.getAttribute(\"user-registry-broadcast\");\n \t\t\t\tmap.put(destination, registerUserRegistryMessageHandler(userRegistry,\n \t\t\t\t\t\tbrokerTemplate, destination, context, source));\n \t\t\t}\n \t\t\tif (!map.isEmpty()) {\n \t\t\t\tvalues.add(\"systemSubscriptions\", map);\n \t\t\t}\n \t\t\tClass<?> handlerType = StompBrokerRelayMessageHandler.class;\n \t\t\tbrokerDef = new RootBeanDefinition(handlerType, cargs, values);\n \t\t}\n \t\telse {\n \t\t\tthrow new IllegalStateException(\"Neither <simple-broker> nor <stomp-broker-relay> elements found.\");\n \t\t}\n \t\tregisterBeanDef(brokerDef, context, source);\n \t\treturn brokerDef;\n \t}\n \n", "target": "// fix_start\n\t\t\t}\n\t\t\tif (simpleBrokerElem.hasAttribute(\"selector-header\")) {\n\t\t\t\tString headerName = simpleBrokerElem.getAttribute(\"selector-header\");\n\t\t\t\tbrokerDef.getPropertyValues().add(\"selectorHeaderName\", headerName);\n// fix_end\n", "cwe": "NVD-CWE-noinfo", "cwe_name": "", "idx": 103471}
