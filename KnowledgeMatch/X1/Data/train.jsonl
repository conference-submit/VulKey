{"source": " @Override\n     public Response processControlCommand(ControlCommand command) throws Exception {\n// bug_start\n        String control = command.getCommand();\n        if (control != null && control.equals(\"shutdown\")) {\n            System.exit(0);\n        }\n// bug_end\n         return null;\n     }\n \n", "target": "// fix_start\n// fix_end\n", "cwe": "CWE-264", "cwe_name": "Permissions, Privileges, and Access Controls", "idx": 29558}
{"source": " private void checkPrivileges(HiveOperationType hiveOpType, List<HivePrivilegeObject> hiveObjects,\n                                String userName, Operation2Privilege.IOType ioType, List<String> deniedMessages) {\n \n     if (hiveObjects == null) {\n       return;\n     }\n// bug_start\n    if (admins != null && Arrays.stream(admins).parallel().anyMatch(n -> n.equals(userName))) {\n// bug_end\n       return;\n     }\n \n     if (Operation2Privilege.isAdminPrivOperation(hiveOpType)) {\n       deniedMessages.add(SQLPrivTypeGrant.ADMIN_PRIV.toString() + \" on \" + ioType);\n       return;\n     }\n \n     boolean needAdmin = false;\n     for (HivePrivilegeObject hiveObj : hiveObjects) {\n       if (hiveObj.getType() == HivePrivilegeObject.HivePrivilegeObjectType.LOCAL_URI) {\n         needAdmin = true;\n         break;\n       }\n     }\n     if (!needAdmin) {\n       switch (hiveOpType) {\n         case ADD:\n         case DFS:\n         case COMPILE:\n           needAdmin = true;\n           break;\n         default:\n           break;\n       }\n     }\n     if (needAdmin) {\n       deniedMessages.add(\"ADMIN\");\n     }\n   }\n \n", "target": "// fix_start\n\n    boolean isAdmin = false;\n    if (admins != null && admins.length > 0) {\n      isAdmin = Arrays.asList(admins).contains(userName);\n    }\n\n    if (isAdmin) {\n// fix_end\n", "cwe": "NVD-CWE-noinfo", "cwe_name": "", "idx": 102455}
{"source": " private HttpServletRequest createMockRequest(String path) {\n         HttpServletRequest request = createNiceMock(HttpServletRequest.class);\n \n// bug_start\n        expect(request.getAttribute(WebUtils.INCLUDE_CONTEXT_PATH_ATTRIBUTE)).andReturn(null).anyTimes();\n        expect(request.getContextPath()).andReturn(\"\");\n// bug_end\n         expect(request.getPathInfo()).andReturn(path);\n         replay(request);\n         return request;\n     }\n \n", "target": "// fix_start\n        expect(request.getServletPath()).andReturn(\"\");\n// fix_end\n", "cwe": "NVD-CWE-noinfo", "cwe_name": "", "idx": 107932}
{"source": " private User createAccount(StaplerRequest req, StaplerResponse rsp, boolean selfRegistration, String formView) throws ServletException, IOException {\n         SignupInfo si = new SignupInfo(req);\n \n         if(selfRegistration && !validateCaptcha(si.captcha))\n             si.errorMessage = Messages.HudsonPrivateSecurityRealm_CreateAccount_TextNotMatchWordInImage();\n \n         if(si.password1 != null && !si.password1.equals(si.password2))\n             si.errorMessage = Messages.HudsonPrivateSecurityRealm_CreateAccount_PasswordNotMatch();\n \n         if(!(si.password1 != null && si.password1.length() != 0))\n             si.errorMessage = Messages.HudsonPrivateSecurityRealm_CreateAccount_PasswordRequired();\n \n         if(si.username==null || si.username.length()==0)\n             si.errorMessage = Messages.HudsonPrivateSecurityRealm_CreateAccount_UserNameRequired();\n         else {\n             User user = User.get(si.username, false);\n             if (null != user)\n                 if (user.getProperty(Details.class) != null)\n                     si.errorMessage = Messages.HudsonPrivateSecurityRealm_CreateAccount_UserNameAlreadyTaken();\n         }\n \n         if(si.fullname==null || si.fullname.length()==0)\n             si.fullname = si.username;\n \n         if(si.email==null || !si.email.contains(\"@\"))\n             si.errorMessage = Messages.HudsonPrivateSecurityRealm_CreateAccount_InvalidEmailAddress();\n \n// bug_start\n// bug_end\n         if(si.errorMessage!=null) {\n             req.setAttribute(\"data\",si);\n             req.getView(this, formView).forward(req,rsp);\n             return null;\n         }\n \n         User user = createAccount(si.username,si.password1);\n         user.setFullName(si.fullname);\n         try {\n             Class<?> up = Jenkins.getInstance().pluginManager.uberClassLoader.loadClass(\"hudson.tasks.Mailer$UserProperty\");\n             Constructor<?> c = up.getDeclaredConstructor(String.class);\n             user.addProperty((UserProperty)c.newInstance(si.email));\n         } catch (RuntimeException e) {\n             throw e;\n         } catch (Exception e) {\n             LOGGER.log(Level.WARNING, \"Failed to set the e-mail address\",e);\n         }\n         user.save();\n         return user;\n     }\n \n", "target": "// fix_start\n        if (! User.isIdOrFullnameAllowed(si.username)) {\n            si.errorMessage = hudson.model.Messages.User_IllegalUsername(si.username);\n        }\n\n        if (! User.isIdOrFullnameAllowed(si.fullname)) {\n            si.errorMessage = hudson.model.Messages.User_IllegalFullname(si.fullname);\n        }\n\n// fix_end\n", "cwe": "CWE-264", "cwe_name": "Permissions, Privileges, and Access Controls", "idx": 30073}
{"source": " protected void parseInputStream(InputStream stream) {\n \t\tSAXParserFactory pf = SAXParserFactory.newInstance();\n \t\ttry {\n// bug_start\n// bug_end\n \t\t\tSAXParser parser = pf.newSAXParser();\n \t\t\tparser.parse(stream, new SAXHandler());\n \t\t} catch (ParserConfigurationException e) {\n \t\t\te.printStackTrace();\n \t\t} catch (SAXException e) {\n \t\t\te.printStackTrace();\n \t\t} catch (IOException e) {\n \t\t\te.printStackTrace();\n \t\t}\n \n \t\tbuildSourceSinkLists();\n \t}\n \n", "target": "// fix_start\n\t\t\tpf.setFeature(\"http://apache.org/xml/features/disallow-doctype-decl\", true);\n\t\t\tpf.setFeature(\"http://xml.org/sax/features/external-general-entities\", false);\n\t\t\tpf.setFeature(\"http://xml.org/sax/features/external-parameter-entities\", false);\n\n// fix_end\n", "cwe": "CWE-611", "cwe_name": "Improper Restriction of XML External Entity Reference ('XXE')", "idx": 69032}
{"source": " @Override\n     protected void configureDataFormat(DataFormat dataFormat, CamelContext camelContext) {\n         if (objectMapper != null) {\n             String ref = objectMapper.startsWith(\"#\") ? objectMapper : \"#\" + objectMapper;\n             setProperty(camelContext, dataFormat, \"objectMapper\", ref);\n         }\n         if (unmarshalType != null) {\n             setProperty(camelContext, dataFormat, \"unmarshalType\", unmarshalType);\n         }\n         if (prettyPrint != null) {\n             setProperty(camelContext, dataFormat, \"prettyPrint\", prettyPrint);\n         }\n         if (jsonView != null) {\n             setProperty(camelContext, dataFormat, \"jsonView\", jsonView);\n         }\n         if (include != null) {\n             setProperty(camelContext, dataFormat, \"include\", include);\n         }\n         if (allowJmsType != null) {\n             setProperty(camelContext, dataFormat, \"allowJmsType\", allowJmsType);\n         }\n         if (collectionType != null) {\n             setProperty(camelContext, dataFormat, \"collectionType\", collectionType);\n         }\n         if (useList != null) {\n             setProperty(camelContext, dataFormat, \"useList\", useList);\n         }\n         if (enableJaxbAnnotationModule != null) {\n             setProperty(camelContext, dataFormat, \"enableJaxbAnnotationModule\", enableJaxbAnnotationModule);\n         }\n         if (moduleClassNames != null) {\n             setProperty(camelContext, dataFormat, \"moduleClassNames\", moduleClassNames);\n         }\n         if (moduleRefs != null) {\n             setProperty(camelContext, dataFormat, \"moduleRefs\", moduleRefs);\n         }\n         if (enableFeatures != null) {\n             setProperty(camelContext, dataFormat, \"enableFeatures\", enableFeatures);\n         }\n         if (disableFeatures != null) {\n             setProperty(camelContext, dataFormat, \"disableFeatures\", disableFeatures);\n         }\n         if (permissions != null) {\n             setProperty(camelContext, dataFormat, \"permissions\", permissions);\n         }\n// bug_start\n// bug_end\n         if (permissions == null && unmarshalType != null) {\n             String allow = \"+\" + unmarshalType.getName();\n             setProperty(camelContext, dataFormat, \"permissions\", allow);\n         }\n     }\n \n", "target": "// fix_start\n        if (allowUnmarshallType != null) {\n            setProperty(camelContext, dataFormat, \"allowUnmarshallType\", allowUnmarshallType);\n        }\n// fix_end\n", "cwe": "CWE-502", "cwe_name": "Deserialization of Untrusted Data", "idx": 57271}
{"source": " @Override\n     public void receiveMessageHeader(final BasicContentHeaderProperties properties, final long bodySize)\n     {\n         if(LOGGER.isDebugEnabled())\n         {\n             LOGGER.debug(\"RECV[\" + _channelId + \"] MessageHeader[ properties: {\" + properties + \"} bodySize: \" + bodySize + \" ]\");\n         }\n \n         if(hasCurrentMessage())\n         {\n             if(bodySize > _connection.getMaxMessageSize())\n             {\n                 properties.dispose();\n                 closeChannel(ErrorCodes.MESSAGE_TOO_LARGE,\n                              \"Message size of \" + bodySize + \" greater than allowed maximum of \" + _connection.getMaxMessageSize());\n             }\n// bug_start\n            publishContentHeader(new ContentHeaderBody(properties, bodySize));\n// bug_end\n         }\n         else\n         {\n             properties.dispose();\n             _connection.sendConnectionClose(ErrorCodes.COMMAND_INVALID,\n                                             \"Attempt to send a content header without first sending a publish frame\",\n                                             _channelId);\n         }\n     }\n \n", "target": "// fix_start\n            else\n            {\n                publishContentHeader(new ContentHeaderBody(properties, bodySize));\n            }\n// fix_end\n", "cwe": "CWE-20", "cwe_name": "Improper Input Validation", "idx": 5664}
{"source": " @Override\n   public void launchContainer(ContainerRuntimeContext ctx)\n       throws ContainerExecutionException {\n     Container container = ctx.getContainer();\n     Map<String, String> environment = container.getLaunchContext()\n         .getEnvironment();\n     String imageName = environment.get(ENV_DOCKER_CONTAINER_IMAGE);\n     String network = environment.get(ENV_DOCKER_CONTAINER_NETWORK);\n \n     if(network == null || network.isEmpty()) {\n       network = defaultNetwork;\n     }\n \n     validateContainerNetworkType(network);\n \n// bug_start\n    if (imageName == null) {\n      throw new ContainerExecutionException(ENV_DOCKER_CONTAINER_IMAGE\n          + \" not set!\");\n    }\n// bug_end\n \n     String containerIdStr = container.getContainerId().toString();\n     String runAsUser = ctx.getExecutionAttribute(RUN_AS_USER);\n     Path containerWorkDir = ctx.getExecutionAttribute(CONTAINER_WORK_DIR);\n     @SuppressWarnings(\"unchecked\")\n     List<String> localDirs = ctx.getExecutionAttribute(LOCAL_DIRS);\n     @SuppressWarnings(\"unchecked\")\n     List<String> logDirs = ctx.getExecutionAttribute(LOG_DIRS);\n     @SuppressWarnings(\"unchecked\")\n     List<String> filecacheDirs = ctx.getExecutionAttribute(FILECACHE_DIRS);\n     @SuppressWarnings(\"unchecked\")\n     List<String> containerLocalDirs = ctx.getExecutionAttribute(\n         CONTAINER_LOCAL_DIRS);\n     @SuppressWarnings(\"unchecked\")\n     List<String> containerLogDirs = ctx.getExecutionAttribute(\n         CONTAINER_LOG_DIRS);\n     @SuppressWarnings(\"unchecked\")\n     Map<Path, List<String>> localizedResources = ctx.getExecutionAttribute(\n         LOCALIZED_RESOURCES);\n     @SuppressWarnings(\"unchecked\")\n     List<String> userLocalDirs = ctx.getExecutionAttribute(USER_LOCAL_DIRS);\n     Set<String> capabilities = new HashSet<>(Arrays.asList(\n         conf.getTrimmedStrings(\n             YarnConfiguration.NM_DOCKER_CONTAINER_CAPABILITIES,\n             YarnConfiguration.DEFAULT_NM_DOCKER_CONTAINER_CAPABILITIES)));\n \n     @SuppressWarnings(\"unchecked\")\n     DockerRunCommand runCommand = new DockerRunCommand(containerIdStr,\n         runAsUser, imageName)\n         .detachOnRun()\n         .setContainerWorkDir(containerWorkDir.toString())\n         .setNetworkType(network)\n         .setCapabilities(capabilities)\n         .addMountLocation(CGROUPS_ROOT_DIRECTORY,\n             CGROUPS_ROOT_DIRECTORY + \":ro\", false);\n     List<String> allDirs = new ArrayList<>(containerLocalDirs);\n \n     allDirs.addAll(filecacheDirs);\n     allDirs.add(containerWorkDir.toString());\n     allDirs.addAll(containerLogDirs);\n     allDirs.addAll(userLocalDirs);\n     for (String dir: allDirs) {\n       runCommand.addMountLocation(dir, dir, true);\n     }\n \n     if (environment.containsKey(ENV_DOCKER_CONTAINER_LOCAL_RESOURCE_MOUNTS)) {\n       String mounts = environment.get(\n           ENV_DOCKER_CONTAINER_LOCAL_RESOURCE_MOUNTS);\n       if (!mounts.isEmpty()) {\n         for (String mount : StringUtils.split(mounts)) {\n           String[] dir = StringUtils.split(mount, ':');\n           if (dir.length != 2) {\n             throw new ContainerExecutionException(\"Invalid mount : \" +\n                 mount);\n           }\n           String src = validateMount(dir[0], localizedResources);\n           String dst = dir[1];\n           runCommand.addMountLocation(src, dst + \":ro\", true);\n         }\n       }\n     }\n \n     if (allowPrivilegedContainerExecution(container)) {\n       runCommand.setPrivileged();\n     }\n \n     String resourcesOpts = ctx.getExecutionAttribute(RESOURCES_OPTIONS);\n \n     addCGroupParentIfRequired(resourcesOpts, containerIdStr, runCommand);\n \n     Path nmPrivateContainerScriptPath = ctx.getExecutionAttribute(\n         NM_PRIVATE_CONTAINER_SCRIPT_PATH);\n \n     String disableOverride = environment.get(\n         ENV_DOCKER_CONTAINER_RUN_OVERRIDE_DISABLE);\n \n     if (disableOverride != null && disableOverride.equals(\"true\")) {\n       if (LOG.isInfoEnabled()) {\n         LOG.info(\"command override disabled\");\n       }\n     } else {\n       List<String> overrideCommands = new ArrayList<>();\n       Path launchDst =\n           new Path(containerWorkDir, ContainerLaunch.CONTAINER_SCRIPT);\n \n       overrideCommands.add(\"bash\");\n       overrideCommands.add(launchDst.toUri().getPath());\n       runCommand.setOverrideCommandWithArgs(overrideCommands);\n     }\n \n     String commandFile = dockerClient.writeCommandToTempFile(runCommand,\n         containerIdStr);\n     PrivilegedOperation launchOp = new PrivilegedOperation(\n         PrivilegedOperation.OperationType.LAUNCH_DOCKER_CONTAINER);\n \n     launchOp.appendArgs(runAsUser, ctx.getExecutionAttribute(USER),\n         Integer.toString(PrivilegedOperation\n             .RunAsUserCommand.LAUNCH_DOCKER_CONTAINER.getValue()),\n         ctx.getExecutionAttribute(APPID),\n         containerIdStr, containerWorkDir.toString(),\n         nmPrivateContainerScriptPath.toUri().getPath(),\n         ctx.getExecutionAttribute(NM_PRIVATE_TOKENS_PATH).toUri().getPath(),\n         ctx.getExecutionAttribute(PID_FILE_PATH).toString(),\n         StringUtils.join(PrivilegedOperation.LINUX_FILE_PATH_SEPARATOR,\n             localDirs),\n         StringUtils.join(PrivilegedOperation.LINUX_FILE_PATH_SEPARATOR,\n             logDirs),\n         commandFile,\n         resourcesOpts);\n \n     String tcCommandFile = ctx.getExecutionAttribute(TC_COMMAND_FILE);\n \n     if (tcCommandFile != null) {\n       launchOp.appendArgs(tcCommandFile);\n     }\n     if (LOG.isDebugEnabled()) {\n       LOG.debug(\"Launching container with cmd: \" + runCommand\n           .getCommandWithArguments());\n     }\n \n     try {\n       privilegedOperationExecutor.executePrivilegedOperation(null,\n           launchOp, null, container.getLaunchContext().getEnvironment(),\n           false, false);\n     } catch (PrivilegedOperationException e) {\n       LOG.warn(\"Launch container failed. Exception: \", e);\n       LOG.info(\"Docker command used: \" + runCommand.getCommandWithArguments());\n \n       throw new ContainerExecutionException(\"Launch container failed\", e\n           .getExitCode(), e.getOutput(), e.getErrorOutput());\n     }\n   }\n \n", "target": "// fix_start\n    validateImageName(imageName);\n// fix_end\n", "cwe": "CWE-20", "cwe_name": "Improper Input Validation", "idx": 7739}
{"source": " private boolean verifySecret(String action, int bridgeSecret) throws IllegalAccessException {\n         if (!jsMessageQueue.isBridgeEnabled()) {\n             if (bridgeSecret == -1) {\n                 Log.d(LOG_TAG, action + \" call made before bridge was enabled.\");\n             } else {\n                 Log.d(LOG_TAG, \"Ignoring \" + action + \" from previous page load.\");\n             }\n             return false;\n         }\n         if (expectedBridgeSecret < 0 || bridgeSecret != expectedBridgeSecret) {\n// bug_start\n// bug_end\n             throw new IllegalAccessException();\n         }\n         return true;\n     }\n \n", "target": "// fix_start\n            Log.e(LOG_TAG, \"Bridge access attempt with wrong secret token, possibly from malicious code. Disabling exec() bridge!\");\n            clearBridgeSecret();\n// fix_end\n", "cwe": "NVD-CWE-Other", "cwe_name": "Other", "idx": 110838}
{"source": " public static Connection connectSync(final ProtocolConnectionConfiguration configuration) throws IOException {\n         long timeoutMillis = configuration.getConnectionTimeout();\n         CallbackHandler handler = configuration.getCallbackHandler();\n         final CallbackHandler actualHandler;\n         ProtocolTimeoutHandler timeoutHandler = configuration.getTimeoutHandler();\n         if (timeoutHandler == null) {\n             GeneralTimeoutHandler defaultTimeoutHandler = new GeneralTimeoutHandler();\n             actualHandler = handler != null ? new WrapperCallbackHandler(defaultTimeoutHandler, handler) : null;\n             timeoutHandler = defaultTimeoutHandler;\n         } else {\n             actualHandler = handler;\n         }\n \n         final IoFuture<Connection> future = connect(actualHandler, configuration);\n \n         IoFuture.Status status = timeoutHandler.await(future, timeoutMillis);\n \n// bug_start\n        if (status == IoFuture.Status.DONE) {\n            return future.get();\n// bug_end\n         }\n// bug_start\n        if (status == IoFuture.Status.FAILED) {\n            throw ProtocolLogger.ROOT_LOGGER.failedToConnect(configuration.getUri(), future.getException());\n        }\n        throw ProtocolLogger.ROOT_LOGGER.couldNotConnect(configuration.getUri());\n// bug_end\n     }\n \n", "target": "// fix_start\n        Connection result = checkFuture(status, future, configuration);\n        if (result == null) {\n            future.cancel();\n            Connection toClose = checkFuture(future.getStatus(), future, configuration);\n            StreamUtils.safeClose(toClose);\n\n            throw ProtocolLogger.ROOT_LOGGER.couldNotConnect(configuration.getUri());\n// fix_end\n// fix_start\n        return result;\n// fix_end\n", "cwe": "CWE-401", "cwe_name": "Missing Release of Memory after Effective Lifetime", "idx": 52880}
{"source": " public static String canonicalPath(String path)\n     {\n         if (path==null || path.length()==0)\n             return path;\n \n         int end=path.length();\n// bug_start\n\n        int queryIdx=path.indexOf('?');\n        int start = path.lastIndexOf('/', (queryIdx > 0 ? queryIdx : end));\n// bug_end\n \n     search:\n         while (end>0)\n         {\n             switch(end-start)\n             {\n               case 2:\n                   if (path.charAt(start+1)!='.')\n                       break;\n                   break search;\n               case 3:\n                   if (path.charAt(start+1)!='.' || path.charAt(start+2)!='.')\n                       break;\n                   break search;\n             }\n \n             end=start;\n             start=path.lastIndexOf('/',end-1);\n         }\n \n         if (start>=end)\n             return path;\n \n         StringBuffer buf = new StringBuffer(path);\n         int delStart=-1;\n         int delEnd=-1;\n         int skip=0;\n \n         while (end>0)\n         {\n             switch(end-start)\n             {\n               case 2:\n                   if (buf.charAt(start+1)!='.')\n                   {\n                       if (skip>0 && --skip==0)\n                       {\n                           delStart=start>=0?start:0;\n                           if(delStart>0 && delEnd==buf.length() && buf.charAt(delEnd-1)=='.')\n                               delStart++;\n                       }\n                       break;\n                   }\n \n                   if(start<0 && buf.length()>2 && buf.charAt(1)=='/' && buf.charAt(2)=='/')\n                       break;\n \n                   if(delEnd<0)\n                       delEnd=end;\n                   delStart=start;\n                   if (delStart<0 || delStart==0&&buf.charAt(delStart)=='/')\n                   {\n                       delStart++;\n                       if (delEnd<buf.length() && buf.charAt(delEnd)=='/')\n                           delEnd++;\n                       break;\n                   }\n                   if (end==buf.length())\n                       delStart++;\n \n                   end=start--;\n                   while (start>=0 && buf.charAt(start)!='/')\n                       start--;\n                   continue;\n \n               case 3:\n                   if (buf.charAt(start+1)!='.' || buf.charAt(start+2)!='.')\n                   {\n                       if (skip>0 && --skip==0)\n                       {   delStart=start>=0?start:0;\n                           if(delStart>0 && delEnd==buf.length() && buf.charAt(delEnd-1)=='.')\n                               delStart++;\n                       }\n                       break;\n                   }\n \n                   delStart=start;\n                   if (delEnd<0)\n                       delEnd=end;\n \n                   skip++;\n                   end=start--;\n                   while (start>=0 && buf.charAt(start)!='/')\n                       start--;\n                   continue;\n \n               default:\n                   if (skip>0 && --skip==0)\n                   {\n                       delStart=start>=0?start:0;\n                       if(delEnd==buf.length() && buf.charAt(delEnd-1)=='.')\n                           delStart++;\n                   }\n             }\n \n             if (skip<=0 && delStart>=0 && delStart>=0)\n             {\n                 buf.delete(delStart,delEnd);\n                 delStart=delEnd=-1;\n                 if (skip>0)\n                     delEnd=end;\n             }\n \n             end=start--;\n             while (start>=0 && buf.charAt(start)!='/')\n                 start--;\n         }\n \n         if (skip>0)\n             return null;\n \n         if (delEnd>=0)\n             buf.delete(delStart,delEnd);\n \n         return buf.toString();\n     }\n \n", "target": "// fix_start\n        int start = path.lastIndexOf('/', end);\n// fix_end\n", "cwe": "CWE-22", "cwe_name": "Path Traversal", "idx": 20939}
{"source": " @SuppressWarnings(\"unchecked\")\n \tprotected <T> void writeWithMessageConverters(T returnValue, MethodParameter returnType,\n \t\t\tServletServerHttpRequest inputMessage, ServletServerHttpResponse outputMessage)\n \t\t\tthrows IOException, HttpMediaTypeNotAcceptableException {\n \n \t\tClass<?> returnValueClass = returnValue.getClass();\n \t\tHttpServletRequest servletRequest = inputMessage.getServletRequest();\n \t\tList<MediaType> requestedMediaTypes = getAcceptableMediaTypes(servletRequest);\n \t\tList<MediaType> producibleMediaTypes = getProducibleMediaTypes(servletRequest, returnValueClass);\n \n \t\tSet<MediaType> compatibleMediaTypes = new LinkedHashSet<MediaType>();\n \t\tfor (MediaType requestedType : requestedMediaTypes) {\n \t\t\tfor (MediaType producibleType : producibleMediaTypes) {\n \t\t\t\tif (requestedType.isCompatibleWith(producibleType)) {\n \t\t\t\t\tcompatibleMediaTypes.add(getMostSpecificMediaType(requestedType, producibleType));\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \t\tif (compatibleMediaTypes.isEmpty()) {\n \t\t\tthrow new HttpMediaTypeNotAcceptableException(producibleMediaTypes);\n \t\t}\n \n \t\tList<MediaType> mediaTypes = new ArrayList<MediaType>(compatibleMediaTypes);\n \t\tMediaType.sortBySpecificityAndQuality(mediaTypes);\n \n \t\tMediaType selectedMediaType = null;\n \t\tfor (MediaType mediaType : mediaTypes) {\n \t\t\tif (mediaType.isConcrete()) {\n \t\t\t\tselectedMediaType = mediaType;\n \t\t\t\tbreak;\n \t\t\t}\n \t\t\telse if (mediaType.equals(MediaType.ALL) || mediaType.equals(MEDIA_TYPE_APPLICATION)) {\n \t\t\t\tselectedMediaType = MediaType.APPLICATION_OCTET_STREAM;\n \t\t\t\tbreak;\n \t\t\t}\n \t\t}\n \n \t\tif (selectedMediaType != null) {\n \t\t\tselectedMediaType = selectedMediaType.removeQualityValue();\n \t\t\tfor (HttpMessageConverter<?> messageConverter : this.messageConverters) {\n \t\t\t\tif (messageConverter.canWrite(returnValueClass, selectedMediaType)) {\n// bug_start\n// bug_end\n \t\t\t\t\t((HttpMessageConverter<T>) messageConverter).write(returnValue, selectedMediaType, outputMessage);\n \t\t\t\t\tif (logger.isDebugEnabled()) {\n \t\t\t\t\t\tlogger.debug(\"Written [\" + returnValue + \"] as \\\"\" + selectedMediaType + \"\\\" using [\" +\n \t\t\t\t\t\t\t\tmessageConverter + \"]\");\n \t\t\t\t\t}\n \t\t\t\t\treturn;\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \t\tthrow new HttpMediaTypeNotAcceptableException(this.allSupportedMediaTypes);\n \t}\n \n", "target": "// fix_start\n\t\t\t\t\taddContentDispositionHeader(inputMessage, outputMessage);\n// fix_end\n", "cwe": "CWE-552", "cwe_name": "Files or Directories Accessible to External Parties", "idx": 64798}
{"source": " public static void setGlobalContext(Context newGlobalContext) {\n// bug_start\n// bug_end\n         globalContext = newGlobalContext;\n     }\n \n", "target": "// fix_start\n        SecurityManager sm = System.getSecurityManager();\n        if (sm != null) {\n            sm.checkPermission(new RuntimePermission(\n                   ResourceLinkFactory.class.getName() + \".setGlobalContext\"));\n        }\n// fix_end\n", "cwe": "CWE-264", "cwe_name": "Permissions, Privileges, and Access Controls", "idx": 31569}
{"source": " private static String normalizePath(final String path) {\n         String s = path;\n         if (s == null) {\n// bug_start\n            return null;\n// bug_end\n         }\n         int n = 0;\n         for (; n < s.length(); n++) {\n             if (s.charAt(n) != '/') {\n                 break;\n             }\n         }\n         if (n > 1) {\n             s = s.substring(n - 1);\n         }\n// bug_start\n// bug_end\n         return s;\n     }\n \n", "target": "// fix_start\n            return \"/\";\n// fix_end\n// fix_start\n        if (!s.startsWith(\"/\")) {\n            s = \"/\" + s;\n        }\n// fix_end\n", "cwe": "CWE-611", "cwe_name": "Improper Restriction of XML External Entity Reference ('XXE')", "idx": 67474}
{"source": " @Override\n     protected void connectInternal() throws SmackException, IOException, XMPPException {\n         connectUsingConfiguration();\n \n         socketClosed = false;\n         initConnection();\n \n         saslFeatureReceived.checkIfSuccessOrWaitOrThrow();\n// bug_start\n// bug_end\n \n         connected = true;\n         callConnectionConnectedListener();\n \n         if (wasAuthenticated) {\n             login();\n             notifyReconnection();\n         }\n     }\n \n", "target": "// fix_start\n\n        if (!isSecureConnection() && getConfiguration().getSecurityMode() == SecurityMode.required) {\n            shutdown();\n            throw new SecurityRequiredByClientException();\n        }\n// fix_end\n", "cwe": "CWE-362", "cwe_name": "Concurrent Execution using Shared Resource with Improper Synchronization ('Race Condition')", "idx": 49380}
{"source": " @Before\n     public void init() {\n// bug_start\n        parser = new TldParser(true, true);\n// bug_end\n     }\n \n", "target": "// fix_start\n        parser = new TldParser(true, true, null, true);\n// fix_end\n", "cwe": "CWE-200", "cwe_name": "Exposure of Sensitive Information to an Unauthorized Actor", "idx": 19697}
{"source": " private void prepareRequest() throws IOException {\n \n         contentDelimitation = false;\n \n         if (protocol.isSSLEnabled()) {\n             request.scheme().setString(\"https\");\n         }\n \n         MimeHeaders headers = request.getMimeHeaders();\n \n         MessageBytes connectionValueMB = headers.getValue(Constants.CONNECTION);\n         if (connectionValueMB != null && !connectionValueMB.isNull()) {\n             Set<String> tokens = new HashSet<>();\n             TokenList.parseTokenList(headers.values(Constants.CONNECTION), tokens);\n             if (tokens.contains(Constants.CLOSE)) {\n                 keepAlive = false;\n             } else if (tokens.contains(Constants.KEEP_ALIVE_HEADER_VALUE_TOKEN)) {\n                 keepAlive = true;\n             }\n         }\n \n         if (http11) {\n             MessageBytes expectMB = headers.getValue(\"expect\");\n             if (expectMB != null && !expectMB.isNull()) {\n                 if (expectMB.toString().trim().equalsIgnoreCase(\"100-continue\")) {\n                     inputBuffer.setSwallowInput(false);\n                     request.setExpectation(true);\n                 } else {\n                     response.setStatus(HttpServletResponse.SC_EXPECTATION_FAILED);\n                     setErrorState(ErrorState.CLOSE_CLEAN, null);\n                 }\n             }\n         }\n \n         Pattern restrictedUserAgents = protocol.getRestrictedUserAgentsPattern();\n         if (restrictedUserAgents != null && (http11 || keepAlive)) {\n             MessageBytes userAgentValueMB = headers.getValue(\"user-agent\");\n             if(userAgentValueMB != null && !userAgentValueMB.isNull()) {\n                 String userAgentValue = userAgentValueMB.toString();\n                 if (restrictedUserAgents.matcher(userAgentValue).matches()) {\n                     http11 = false;\n                     keepAlive = false;\n                 }\n             }\n         }\n \n \n         MessageBytes hostValueMB = null;\n         try {\n             hostValueMB = headers.getUniqueValue(\"host\");\n         } catch (IllegalArgumentException iae) {\n             badRequest(\"http11processor.request.multipleHosts\");\n         }\n         if (http11 && hostValueMB == null) {\n             badRequest(\"http11processor.request.noHostHeader\");\n         }\n \n         ByteChunk uriBC = request.requestURI().getByteChunk();\n         byte[] uriB = uriBC.getBytes();\n         if (uriBC.startsWithIgnoreCase(\"http\", 0)) {\n             int pos = 4;\n             if (uriBC.startsWithIgnoreCase(\"s\", pos)) {\n                 pos++;\n             }\n             if (uriBC.startsWith(\"://\", pos)) {\n                 pos += 3;\n                 int uriBCStart = uriBC.getStart();\n \n                 int slashPos = uriBC.indexOf('/', pos);\n                 int atPos = uriBC.indexOf('@', pos);\n                 if (slashPos > -1 && atPos > slashPos) {\n                     atPos = -1;\n                 }\n \n                 if (slashPos == -1) {\n                     slashPos = uriBC.getLength();\n                     request.requestURI().setBytes(uriB, uriBCStart + 6, 1);\n                 } else {\n                     request.requestURI().setBytes(uriB, uriBCStart + slashPos, uriBC.getLength() - slashPos);\n                 }\n \n                 if (atPos != -1) {\n                     for (; pos < atPos; pos++) {\n                         byte c = uriB[uriBCStart + pos];\n                         if (!HttpParser.isUserInfo(c)) {\n                             badRequest(\"http11processor.request.invalidUserInfo\");\n                             break;\n                         }\n                     }\n                     pos = atPos + 1;\n                 }\n \n                 if (http11) {\n                     if (hostValueMB != null) {\n                         if (!hostValueMB.getByteChunk().equals(\n                                 uriB, uriBCStart + pos, slashPos - pos)) {\n                             if (protocol.getAllowHostHeaderMismatch()) {\n                                 hostValueMB = headers.setValue(\"host\");\n                                 hostValueMB.setBytes(uriB, uriBCStart + pos, slashPos - pos);\n                             } else {\n                                 badRequest(\"http11processor.request.inconsistentHosts\");\n                             }\n                         }\n                     }\n                 } else {\n                     try {\n                         hostValueMB = headers.setValue(\"host\");\n                         hostValueMB.setBytes(uriB, uriBCStart + pos, slashPos - pos);\n                     } catch (IllegalStateException e) {\n                     }\n                 }\n             } else {\n                 badRequest(\"http11processor.request.invalidScheme\");\n             }\n         }\n \n         for (int i = uriBC.getStart(); i < uriBC.getEnd(); i++) {\n             if (!httpParser.isAbsolutePathRelaxed(uriB[i])) {\n                 badRequest(\"http11processor.request.invalidUri\");\n                 break;\n             }\n         }\n \n         InputFilter[] inputFilters = inputBuffer.getFilters();\n \n// bug_start\n        if (http11) {\n// bug_end\n             MessageBytes transferEncodingValueMB = headers.getValue(\"transfer-encoding\");\n             if (transferEncodingValueMB != null) {\n                 List<String> encodingNames = new ArrayList<>();\n                 if (TokenList.parseTokenList(headers.values(\"transfer-encoding\"), encodingNames)) {\n                     for (String encodingName : encodingNames) {\n                         addInputFilter(inputFilters, encodingName);\n                     }\n                 } else {\n                     badRequest(\"http11processor.request.invalidTransferEncoding\");\n                 }\n             }\n         }\n \n         long contentLength = -1;\n         try {\n             contentLength = request.getContentLengthLong();\n         } catch (NumberFormatException e) {\n             badRequest(\"http11processor.request.nonNumericContentLength\");\n         } catch (IllegalArgumentException e) {\n             badRequest(\"http11processor.request.multipleContentLength\");\n         }\n         if (contentLength >= 0) {\n             if (contentDelimitation) {\n                 headers.removeHeader(\"content-length\");\n                 request.setContentLength(-1);\n                 keepAlive = false;\n             } else {\n                 inputBuffer.addActiveFilter(inputFilters[Constants.IDENTITY_FILTER]);\n                 contentDelimitation = true;\n             }\n         }\n \n         parseHost(hostValueMB);\n \n         if (!contentDelimitation) {\n             inputBuffer.addActiveFilter(inputFilters[Constants.VOID_FILTER]);\n             contentDelimitation = true;\n         }\n \n         if (!getErrorState().isIoAllowed()) {\n             getAdapter().log(request, response, 0);\n         }\n     }\n \n", "target": "// fix_start\n        if (!http09) {\n// fix_end\n", "cwe": "CWE-444", "cwe_name": "Inconsistent Interpretation of HTTP Requests ('HTTP Request Smuggling')", "idx": 54414}
{"source": " private void prepareRequest() throws IOException {\n \n         http11 = true;\n         http09 = false;\n         contentDelimitation = false;\n \n         if (protocol.isSSLEnabled()) {\n             request.scheme().setString(\"https\");\n         }\n         MessageBytes protocolMB = request.protocol();\n         if (protocolMB.equals(Constants.HTTP_11)) {\n             protocolMB.setString(Constants.HTTP_11);\n         } else if (protocolMB.equals(Constants.HTTP_10)) {\n             http11 = false;\n             keepAlive = false;\n             protocolMB.setString(Constants.HTTP_10);\n         } else if (protocolMB.equals(\"\")) {\n             http09 = true;\n             http11 = false;\n             keepAlive = false;\n         } else {\n             http11 = false;\n             response.setStatus(505);\n             setErrorState(ErrorState.CLOSE_CLEAN, null);\n             if (log.isDebugEnabled()) {\n                 log.debug(sm.getString(\"http11processor.request.prepare\")+\n                           \" Unsupported HTTP version \\\"\"+protocolMB+\"\\\"\");\n             }\n         }\n \n         MimeHeaders headers = request.getMimeHeaders();\n \n         MessageBytes connectionValueMB = headers.getValue(Constants.CONNECTION);\n         if (connectionValueMB != null && !connectionValueMB.isNull()) {\n             Set<String> tokens = new HashSet<>();\n             TokenList.parseTokenList(headers.values(Constants.CONNECTION), tokens);\n             if (tokens.contains(Constants.CLOSE)) {\n                 keepAlive = false;\n             } else if (tokens.contains(Constants.KEEP_ALIVE_HEADER_VALUE_TOKEN)) {\n                 keepAlive = true;\n             }\n         }\n \n         if (http11) {\n             MessageBytes expectMB = headers.getValue(\"expect\");\n             if (expectMB != null && !expectMB.isNull()) {\n                 if (expectMB.toString().trim().equalsIgnoreCase(\"100-continue\")) {\n                     inputBuffer.setSwallowInput(false);\n                     request.setExpectation(true);\n                 } else {\n                     response.setStatus(HttpServletResponse.SC_EXPECTATION_FAILED);\n                     setErrorState(ErrorState.CLOSE_CLEAN, null);\n                 }\n             }\n         }\n \n         Pattern restrictedUserAgents = protocol.getRestrictedUserAgentsPattern();\n         if (restrictedUserAgents != null && (http11 || keepAlive)) {\n             MessageBytes userAgentValueMB = headers.getValue(\"user-agent\");\n             if(userAgentValueMB != null && !userAgentValueMB.isNull()) {\n                 String userAgentValue = userAgentValueMB.toString();\n                 if (restrictedUserAgents.matcher(userAgentValue).matches()) {\n                     http11 = false;\n                     keepAlive = false;\n                 }\n             }\n         }\n \n \n         MessageBytes hostValueMB = null;\n         try {\n             hostValueMB = headers.getUniqueValue(\"host\");\n         } catch (IllegalArgumentException iae) {\n             badRequest(\"http11processor.request.multipleHosts\");\n         }\n         if (http11 && hostValueMB == null) {\n             badRequest(\"http11processor.request.noHostHeader\");\n         }\n \n         ByteChunk uriBC = request.requestURI().getByteChunk();\n         byte[] uriB = uriBC.getBytes();\n         if (uriBC.startsWithIgnoreCase(\"http\", 0)) {\n             int pos = 4;\n             if (uriBC.startsWithIgnoreCase(\"s\", pos)) {\n                 pos++;\n             }\n             if (uriBC.startsWith(\"://\", pos)) {\n                 pos += 3;\n                 int uriBCStart = uriBC.getStart();\n \n                 int slashPos = uriBC.indexOf('/', pos);\n                 int atPos = uriBC.indexOf('@', pos);\n                 if (slashPos > -1 && atPos > slashPos) {\n                     atPos = -1;\n                 }\n \n                 if (slashPos == -1) {\n                     slashPos = uriBC.getLength();\n                     request.requestURI().setBytes(uriB, uriBCStart + 6, 1);\n                 } else {\n                     request.requestURI().setBytes(uriB, uriBCStart + slashPos, uriBC.getLength() - slashPos);\n                 }\n \n                 if (atPos != -1) {\n                     for (; pos < atPos; pos++) {\n                         byte c = uriB[uriBCStart + pos];\n                         if (!HttpParser.isUserInfo(c)) {\n                             badRequest(\"http11processor.request.invalidUserInfo\");\n                             break;\n                         }\n                     }\n                     pos = atPos + 1;\n                 }\n \n                 if (http11) {\n                     if (hostValueMB != null) {\n                         if (!hostValueMB.getByteChunk().equals(\n                                 uriB, uriBCStart + pos, slashPos - pos)) {\n                             if (protocol.getAllowHostHeaderMismatch()) {\n                                 hostValueMB = headers.setValue(\"host\");\n                                 hostValueMB.setBytes(uriB, uriBCStart + pos, slashPos - pos);\n                             } else {\n                                 badRequest(\"http11processor.request.inconsistentHosts\");\n                             }\n                         }\n                     }\n                 } else {\n                     try {\n                         hostValueMB = headers.setValue(\"host\");\n                         hostValueMB.setBytes(uriB, uriBCStart + pos, slashPos - pos);\n                     } catch (IllegalStateException e) {\n                     }\n                 }\n             } else {\n                 badRequest(\"http11processor.request.invalidScheme\");\n             }\n         }\n \n         for (int i = uriBC.getStart(); i < uriBC.getEnd(); i++) {\n             if (!httpParser.isAbsolutePathRelaxed(uriB[i])) {\n                 badRequest(\"http11processor.request.invalidUri\");\n                 break;\n             }\n         }\n \n         InputFilter[] inputFilters = inputBuffer.getFilters();\n \n         if (http11) {\n             MessageBytes transferEncodingValueMB = headers.getValue(\"transfer-encoding\");\n             if (transferEncodingValueMB != null) {\n                 List<String> encodingNames = new ArrayList<>();\n// bug_start\n                TokenList.parseTokenList(headers.values(\"transfer-encoding\"), encodingNames);\n                for (String encodingName : encodingNames) {\n                    addInputFilter(inputFilters, encodingName);\n// bug_end\n                 }\n             }\n         }\n \n         long contentLength = -1;\n         try {\n             contentLength = request.getContentLengthLong();\n         } catch (NumberFormatException e) {\n             badRequest(\"http11processor.request.nonNumericContentLength\");\n         } catch (IllegalArgumentException e) {\n             badRequest(\"http11processor.request.multipleContentLength\");\n         }\n         if (contentLength >= 0) {\n             if (contentDelimitation) {\n                 headers.removeHeader(\"content-length\");\n                 request.setContentLength(-1);\n             } else {\n                 inputBuffer.addActiveFilter(inputFilters[Constants.IDENTITY_FILTER]);\n                 contentDelimitation = true;\n             }\n         }\n \n         parseHost(hostValueMB);\n \n         if (!contentDelimitation) {\n             inputBuffer.addActiveFilter(inputFilters[Constants.VOID_FILTER]);\n             contentDelimitation = true;\n         }\n \n         if (!getErrorState().isIoAllowed()) {\n             getAdapter().log(request, response, 0);\n         }\n     }\n \n", "target": "// fix_start\n                if (TokenList.parseTokenList(headers.values(\"transfer-encoding\"), encodingNames)) {\n                    for (String encodingName : encodingNames) {\n                        addInputFilter(inputFilters, encodingName);\n                    }\n                } else {\n                    badRequest(\"http11processor.request.invalidTransferEncoding\");\n// fix_end\n", "cwe": "CWE-444", "cwe_name": "Inconsistent Interpretation of HTTP Requests ('HTTP Request Smuggling')", "idx": 54453}
{"source": " private Ccm parseCCMXmlFile(InputStream ccmXmlFile) throws IOException, SAXException {\n// bug_start\n\t\tDigester digester = new Digester();\n\t\tdigester.setValidating(false);\n\t\tdigester.setClassLoader(CcmParser.class.getClassLoader());\n// bug_end\n \n \t\tString rootXPath = \"ccm\";\n \t\tdigester.addObjectCreate(rootXPath, Ccm.class);\n \t\tdigester.addSetProperties(rootXPath);\n \n \t\tString fileMetric = \"ccm/metric\";\n \t\tdigester.addObjectCreate(fileMetric, Metric.class);\n \t\tdigester.addSetProperties(fileMetric);\n \t\tdigester.addBeanPropertySetter(\"ccm/metric/complexity\");\n \t\tdigester.addBeanPropertySetter(\"ccm/metric/unit\");\n \t\tdigester.addBeanPropertySetter(\"ccm/metric/classification\");\n \t\tdigester.addBeanPropertySetter(\"ccm/metric/file\");\n \t\tdigester.addBeanPropertySetter(\"ccm/metric/startLineNumber\");\n \t\tdigester.addBeanPropertySetter(\"ccm/metric/endLineNumber\");\n \t\tdigester.addSetNext(fileMetric, \"addMetric\", Metric.class.getName());\n \n \t\treturn (Ccm)digester.parse(ccmXmlFile);\n \t}\n \n", "target": "// fix_start\n\t\tSecureDigester digester = new SecureDigester(CcmParser.class);\n// fix_end\n", "cwe": "CWE-611", "cwe_name": "Improper Restriction of XML External Entity Reference ('XXE')", "idx": 69280}
{"source": " protected void addDefaultMapping(DefaultMapper mapper, String parameter, Object model) {\n \t\tExpression source = new RequestParameterExpression(parameter);\n \t\tParserContext parserContext = new FluentParserContext().evaluate(model.getClass());\n// bug_start\n\t\tExpression target = expressionParser.parseExpression(parameter, parserContext);\n\t\tDefaultMapping mapping = new DefaultMapping(source, target);\n\t\tif (logger.isDebugEnabled()) {\n\t\t\tlogger.debug(\"Adding default mapping for parameter '\" + parameter + \"'\");\n// bug_end\n \t\t}\n// bug_start\n\t\tmapper.addMapping(mapping);\n// bug_end\n \t}\n \n", "target": "// fix_start\n\t\tif (expressionParser instanceof BeanWrapperExpressionParser || checkModelProperty(parameter, model)) {\n\t\t\tExpression target = expressionParser.parseExpression(parameter, parserContext);\n\t\t\tDefaultMapping mapping = new DefaultMapping(source, target);\n\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\tlogger.debug(\"Adding default mapping for parameter '\" + parameter + \"'\");\n\t\t\t}\n\t\t\tmapper.addMapping(mapping);\n// fix_end\n// fix_start\n// fix_end\n", "cwe": "CWE-1188", "cwe_name": "", "idx": 1273}
{"source": "// bug_start\npublic static String checkParameter(String commandParameter) {\n        String repaired = commandParameter.replaceAll(COMMAND_INJECT_REX, \"\");\n        if (repaired.length() != commandParameter.length()) {\n            logger.info(\"Detected illegal character in command {}, replace it to {}.\", commandParameter, repaired);\n// bug_end\n         }\n// bug_start\n        return repaired;\n// bug_end\n     }\n \n", "target": "// fix_start\n@PreAuthorize(Constant.ACCESS_HAS_ROLE_ADMIN\n            + \" or hasPermission(#cube, 'ADMINISTRATION') or hasPermission(#cube, 'MANAGEMENT')\")\n    public void migrateCube(CubeInstance cube, String projectName) {\n        KylinConfig config = KylinConfig.getInstanceFromEnv();\n        if (!config.isAllowAutoMigrateCube()) {\n            throw new InternalErrorException(\"One click migration is disabled, please contact your ADMIN\");\n// fix_end\n// fix_start\n\n        for (CubeSegment segment : cube.getSegments()) {\n            if (segment.getStatus() != SegmentStatusEnum.READY) {\n                throw new InternalErrorException(\n                        \"At least one segment is not in READY state. Please check whether there are Running or Error jobs.\");\n            }\n        }\n\n        String srcCfgUri = config.getAutoMigrateCubeSrcConfig();\n        String dstCfgUri = config.getAutoMigrateCubeDestConfig();\n\n        Preconditions.checkArgument(StringUtils.isNotEmpty(srcCfgUri), \"Source configuration should not be empty.\");\n        Preconditions.checkArgument(StringUtils.isNotEmpty(dstCfgUri),\n                \"Destination configuration should not be empty.\");\n\n        String stringBuilder = (\"%s/bin/kylin.sh org.apache.kylin.tool.CubeMigrationCLI %s %s %s %s %s %s true true\");\n        String cmd = String.format(Locale.ROOT,\n                stringBuilder,\n                KylinConfig.getKylinHome(),\n                CliCommandExecutor.checkParameterWhiteList(srcCfgUri),\n                CliCommandExecutor.checkParameterWhiteList(dstCfgUri),\n                cube.getName(),\n                CliCommandExecutor.checkParameterWhiteList(projectName),\n                config.isAutoMigrateCubeCopyAcl(),\n                config.isAutoMigrateCubePurge());\n\n        logger.info(\"One click migration cmd: \" + cmd);\n\n        CliCommandExecutor exec = new CliCommandExecutor();\n        PatternedLogger patternedLogger = new PatternedLogger(logger);\n\n        try {\n            exec.execute(cmd, patternedLogger);\n        } catch (IOException e) {\n            throw new InternalErrorException(\"Failed to perform one-click migrating\", e);\n        }\n// fix_end\n", "cwe": "CWE-78", "cwe_name": "Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')", "idx": 76734}
{"source": "// bug_start\n@PreAuthorize(Constant.ACCESS_HAS_ROLE_ADMIN\n            + \" or hasPermission(#cube, 'ADMINISTRATION') or hasPermission(#cube, 'MANAGEMENT')\")\n    public void migrateCube(CubeInstance cube, String projectName) {\n        KylinConfig config = KylinConfig.getInstanceFromEnv();\n        if (!config.isAllowAutoMigrateCube()) {\n            throw new InternalErrorException(\"One click migration is disabled, please contact your ADMIN\");\n        }\n\n        for (CubeSegment segment : cube.getSegments()) {\n            if (segment.getStatus() != SegmentStatusEnum.READY) {\n                throw new InternalErrorException(\n                        \"At least one segment is not in READY state. Please check whether there are Running or Error jobs.\");\n            }\n        }\n\n        String srcCfgUri = config.getAutoMigrateCubeSrcConfig();\n        String dstCfgUri = config.getAutoMigrateCubeDestConfig();\n\n        Preconditions.checkArgument(StringUtils.isNotEmpty(srcCfgUri), \"Source configuration should not be empty.\");\n        Preconditions.checkArgument(StringUtils.isNotEmpty(dstCfgUri),\n                \"Destination configuration should not be empty.\");\n\n        String stringBuilder = (\"%s/bin/kylin.sh org.apache.kylin.tool.CubeMigrationCLI %s %s %s %s %s %s true true\");\n        String cmd = String.format(Locale.ROOT, stringBuilder, KylinConfig.getKylinHome(), srcCfgUri, dstCfgUri,\n                cube.getName(), projectName, config.isAutoMigrateCubeCopyAcl(), config.isAutoMigrateCubePurge());\n\n        logger.info(\"One click migration cmd: \" + cmd);\n\n        CliCommandExecutor exec = new CliCommandExecutor();\n        PatternedLogger patternedLogger = new PatternedLogger(logger);\n\n        try {\n            exec.execute(cmd, patternedLogger);\n        } catch (IOException e) {\n            throw new InternalErrorException(\"Failed to perform one-click migrating\", e);\n        }\n// bug_end\n     }\n \n", "target": "// fix_start\npublic static String checkParameter(String commandParameter) {\n        return checkParameter(commandParameter, COMMAND_INJECT_REX);\n// fix_end\n", "cwe": "CWE-78", "cwe_name": "Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')", "idx": 76688}
{"source": "// bug_start\n@Programming\n    public void resetAuthenticationFailureCounter(String username)\n// bug_end\n     {\n// bug_start\n        this.authenticationFailureManager.resetAuthenticationFailureCounter(username);\n// bug_end\n     }\n \n", "target": "// fix_start\npublic void resetAuthenticationFailureCounter(String username)\n// fix_end\n// fix_start\n        if (this.authorizationManager.hasAccess(Right.PROGRAM)) {\n            this.authenticationFailureManager.resetAuthenticationFailureCounter(username);\n        }\n// fix_end\n", "cwe": "CWE-732", "cwe_name": "Incorrect Permission Assignment for Critical Resource", "idx": 72826}
{"source": " @Override\n     protected void service(final HttpServletRequest request, final HttpServletResponse response) throws ServletException, IOException {\n         log.trace(\"Service: {}\", request);\n \n         HttpConsumer consumer = getServletResolveConsumerStrategy().resolve(request, getConsumers());\n         if (consumer == null) {\n             response.sendError(HttpServletResponse.SC_NOT_FOUND);\n             return;\n         }\n \n         if (consumer.getEndpoint().getHttpMethodRestrict() != null) {\n             Iterator it = ObjectHelper.createIterable(consumer.getEndpoint().getHttpMethodRestrict()).iterator();\n             boolean match = false;\n             while (it.hasNext()) {\n                 String method = it.next().toString();\n                 if (method.equalsIgnoreCase(request.getMethod())) {\n                     match = true;\n                     break;\n                 }\n             }\n             if (!match) {\n                 response.sendError(HttpServletResponse.SC_METHOD_NOT_ALLOWED);\n                 return;\n             }\n         }\n \n         if (\"TRACE\".equals(request.getMethod()) && !consumer.isTraceEnabled()) {\n             response.sendError(HttpServletResponse.SC_METHOD_NOT_ALLOWED);\n             return;\n         }\n \n         String contentType = request.getContentType();\n         if (HttpConstants.CONTENT_TYPE_JAVA_SERIALIZED_OBJECT.equals(contentType) && !consumer.getEndpoint().getComponent().isAllowJavaSerializedObject()) {\n// bug_start\n            System.out.println(\"415 miser !!!\");\n// bug_end\n             response.sendError(HttpServletResponse.SC_UNSUPPORTED_MEDIA_TYPE);\n             return;\n         }\n \n         final Exchange result = (Exchange) request.getAttribute(EXCHANGE_ATTRIBUTE_NAME);\n         if (result == null) {\n             final Continuation continuation = ContinuationSupport.getContinuation(request);\n             if (continuation.isInitial() && continuationTimeout != null) {\n                 continuation.setTimeout(continuationTimeout);\n             }\n \n             if (consumer.isSuspended() && continuation.isInitial()) {\n                 response.sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE);\n                 return;\n             }\n \n             if (continuation.isExpired()) {\n                 String id = (String) continuation.getAttribute(EXCHANGE_ATTRIBUTE_ID);\n                 expiredExchanges.put(id, id);\n                 log.warn(\"Continuation expired of exchangeId: {}\", id);\n                 response.sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE);\n                 return;\n             }\n \n             final Exchange exchange = new DefaultExchange(consumer.getEndpoint(), ExchangePattern.InOut);\n \n             if (consumer.getEndpoint().isBridgeEndpoint()) {\n                 exchange.setProperty(Exchange.SKIP_GZIP_ENCODING, Boolean.TRUE);\n                 exchange.setProperty(Exchange.SKIP_WWW_FORM_URLENCODED, Boolean.TRUE);\n             }\n             if (consumer.getEndpoint().isDisableStreamCache()) {\n                 exchange.setProperty(Exchange.DISABLE_HTTP_STREAM_CACHE, Boolean.TRUE);\n             }\n \n             HttpHelper.setCharsetFromContentType(request.getContentType(), exchange);\n \n             exchange.setIn(new HttpMessage(exchange, request, response));\n             String contextPath = consumer.getEndpoint().getPath();\n             exchange.getIn().setHeader(\"CamelServletContextPath\", contextPath);\n \n             String httpPath = (String)exchange.getIn().getHeader(Exchange.HTTP_PATH);\n             if (contextPath != null\n                 && httpPath.startsWith(contextPath)) {\n                 exchange.getIn().setHeader(Exchange.HTTP_PATH,\n                         httpPath.substring(contextPath.length()));\n             }\n \n             if (log.isTraceEnabled()) {\n                 log.trace(\"Suspending continuation of exchangeId: {}\", exchange.getExchangeId());\n             }\n             continuation.setAttribute(EXCHANGE_ATTRIBUTE_ID, exchange.getExchangeId());\n \n             try {\n                 consumer.createUoW(exchange);\n             } catch (Exception e) {\n                 log.error(\"Error processing request\", e);\n                 throw new ServletException(e);\n             }\n \n             continuation.suspend();\n \n             ClassLoader oldTccl = overrideTccl(exchange);\n \n             if (log.isTraceEnabled()) {\n                 log.trace(\"Processing request for exchangeId: {}\", exchange.getExchangeId());\n             }\n \n             consumer.getAsyncProcessor().process(exchange, new AsyncCallback() {\n                 public void done(boolean doneSync) {\n                     boolean expired = expiredExchanges.remove(exchange.getExchangeId()) != null;\n                     if (!expired) {\n                         if (log.isTraceEnabled()) {\n                             log.trace(\"Resuming continuation of exchangeId: {}\", exchange.getExchangeId());\n                         }\n                         continuation.setAttribute(EXCHANGE_ATTRIBUTE_NAME, exchange);\n                         continuation.resume();\n                     } else {\n                         log.warn(\"Cannot resume expired continuation of exchangeId: {}\", exchange.getExchangeId());\n                     }\n                 }\n             });\n \n             if (oldTccl != null) {\n                 restoreTccl(exchange, oldTccl);\n             }\n \n             return;\n         }\n \n         try {\n             if (log.isTraceEnabled()) {\n                 log.trace(\"Resumed continuation and writing response for exchangeId: {}\", result.getExchangeId());\n             }\n             Integer bs = consumer.getEndpoint().getResponseBufferSize();\n             if (bs != null) {\n                 log.trace(\"Using response buffer size: {}\", bs);\n                 response.setBufferSize(bs);\n             }\n             consumer.getBinding().writeResponse(result, response);\n         } catch (IOException e) {\n             log.error(\"Error processing request\", e);\n             throw e;\n         } catch (Exception e) {\n             log.error(\"Error processing request\", e);\n             throw new ServletException(e);\n         } finally {\n             consumer.doneUoW(result);\n         }\n     }\n \n", "target": "// fix_start\n// fix_end\n", "cwe": "CWE-19", "cwe_name": "Data Handling", "idx": 3332}
{"source": " private Changes handleRequest(ContextRequest contextRequest, Session session, Profile profile, ContextResponse data,\n                                   ServletRequest request, ServletResponse response, Date timestamp) {\n         Changes changes = ServletCommon.handleEvents(contextRequest.getEvents(), session, profile, request, response, timestamp,\n                 privacyService, eventService);\n         data.setProcessedEvents(changes.getProcessedItems());\n \n         profile = changes.getProfile();\n \n         if (contextRequest.isRequireSegments()) {\n             data.setProfileSegments(profile.getSegments());\n         }\n \n         if (contextRequest.getRequiredProfileProperties() != null) {\n             Map<String, Object> profileProperties = new HashMap<>(profile.getProperties());\n             if (!contextRequest.getRequiredProfileProperties().contains(\"*\")) {\n                 profileProperties.keySet().retainAll(contextRequest.getRequiredProfileProperties());\n             }\n             data.setProfileProperties(profileProperties);\n         }\n \n         if (session != null) {\n             data.setSessionId(session.getItemId());\n             if (contextRequest.getRequiredSessionProperties() != null) {\n                 Map<String, Object> sessionProperties = new HashMap<>(session.getProperties());\n                 if (!contextRequest.getRequiredSessionProperties().contains(\"*\")) {\n                     sessionProperties.keySet().retainAll(contextRequest.getRequiredSessionProperties());\n                 }\n                 data.setSessionProperties(sessionProperties);\n             }\n         }\n \n         processOverrides(contextRequest, profile, session);\n \n         List<PersonalizationService.PersonalizedContent> filterNodes = contextRequest.getFilters();\n         if (filterNodes != null) {\n             data.setFilteringResults(new HashMap<>());\n// bug_start\n            for (PersonalizationService.PersonalizedContent personalizedContent : filterNodes) {\n// bug_end\n                 data.getFilteringResults().put(personalizedContent.getId(), personalizationService.filter(profile,\n                         session, personalizedContent));\n             }\n         }\n \n         List<PersonalizationService.PersonalizationRequest> personalizations = contextRequest.getPersonalizations();\n         if (personalizations != null) {\n             data.setPersonalizations(new HashMap<>());\n// bug_start\n            for (PersonalizationService.PersonalizationRequest personalization : personalizations) {\n// bug_end\n                 data.getPersonalizations().put(personalization.getId(), personalizationService.personalizeList(profile,\n                         session, personalization));\n             }\n         }\n \n         if (!(profile instanceof Persona)) {\n             data.setTrackedConditions(rulesService.getTrackedConditions(contextRequest.getSource()));\n         } else {\n             data.setTrackedConditions(Collections.emptySet());\n         }\n \n         data.setAnonymousBrowsing(privacyService.isRequireAnonymousBrowsing(profile));\n         data.setConsents(profile.getConsents());\n \n         return changes;\n     }\n \n", "target": "// fix_start\n            for (PersonalizationService.PersonalizedContent personalizedContent : sanitizePersonalizedContentObjects(filterNodes)) {\n// fix_end\n// fix_start\n            for (PersonalizationService.PersonalizationRequest personalization : sanitizePersonalizations(personalizations)) {\n// fix_end\n", "cwe": "CWE-74", "cwe_name": "Improper Neutralization of Special Elements in Output Used by a Downstream Component ('Injection')", "idx": 73884}
{"source": " protected void scanExternalID(String[] identifiers,\n                                   boolean optionalSystemId)\n         throws IOException, XNIException {\n \n         String systemId = null;\n         String publicId = null;\n         if (fEntityScanner.skipString(\"PUBLIC\")) {\n             if (!fEntityScanner.skipSpaces()) {\n                 reportFatalError(\"SpaceRequiredAfterPUBLIC\", null);\n             }\n             scanPubidLiteral(fString);\n             publicId = fString.toString();\n \n             if (!fEntityScanner.skipSpaces() && !optionalSystemId) {\n                 reportFatalError(\"SpaceRequiredBetweenPublicAndSystem\", null);\n             }\n         }\n \n         if (publicId != null || fEntityScanner.skipString(\"SYSTEM\")) {\n             if (publicId == null && !fEntityScanner.skipSpaces()) {\n                 reportFatalError(\"SpaceRequiredAfterSYSTEM\", null);\n             }\n             int quote = fEntityScanner.peekChar();\n             if (quote != '\\'' && quote != '\"') {\n                 if (publicId != null && optionalSystemId) {\n                     identifiers[0] = null;\n                     identifiers[1] = publicId;\n                     return;\n                 }\n                 reportFatalError(\"QuoteRequiredInSystemID\", null);\n             }\n             fEntityScanner.scanChar();\n             XMLString ident = fString;\n             if (fEntityScanner.scanLiteral(quote, ident) != quote) {\n                 fStringBuffer.clear();\n                 do {\n                     fStringBuffer.append(ident);\n                     int c = fEntityScanner.peekChar();\n                     if (XMLChar.isMarkup(c) || c == ']') {\n                         fStringBuffer.append((char)fEntityScanner.scanChar());\n                     }\n// bug_start\n// bug_end\n                 } while (fEntityScanner.scanLiteral(quote, ident) != quote);\n                 fStringBuffer.append(ident);\n                 ident = fStringBuffer;\n             }\n             systemId = ident.toString();\n             if (!fEntityScanner.skipChar(quote)) {\n                 reportFatalError(\"SystemIDUnterminated\", null);\n             }\n         }\n \n         identifiers[0] = systemId;\n         identifiers[1] = publicId;\n     }\n \n", "target": "// fix_start\n                    else if (XMLChar.isHighSurrogate(c)) {\n                        scanSurrogates(fStringBuffer);\n                    }\n                    else if (isInvalidLiteral(c)) {\n                        reportFatalError(\"InvalidCharInSystemID\",\n                                new Object[] { Integer.toHexString(c) });\n                        fEntityScanner.scanChar();\n                    }\n// fix_end\n", "cwe": "NVD-CWE-Other", "cwe_name": "Other", "idx": 115350}
{"source": " @Override\n   protected void doPost(HttpServletRequest request, HttpServletResponse response)\n       throws ServletException, IOException {\n     String effectiveUser = request.getRemoteUser();\n     if (securityEnabled) {\n       try {\n// bug_start\n        effectiveUser = doKerberosAuth(request);\n        response.addHeader(WWW_AUTHENTICATE,  NEGOTIATE + \" \" + outToken);\n// bug_end\n       } catch (HttpAuthenticationException e) {\n         LOG.error(\"Kerberos Authentication failed\", e);\n         response.setStatus(HttpServletResponse.SC_UNAUTHORIZED);\n         response.addHeader(WWW_AUTHENTICATE, NEGOTIATE);\n         response.getWriter().println(\"Authentication Error: \" + e.getMessage());\n         return;\n       }\n     }\n     String doAsUserFromQuery = request.getHeader(\"doAs\");\n     if(effectiveUser == null) {\n       effectiveUser = realUser.getShortUserName();\n     }\n     if (doAsUserFromQuery != null) {\n       if (!doAsEnabled) {\n         throw new ServletException(\"Support for proxyuser is not configured\");\n       }\n       UserGroupInformation remoteUser = UserGroupInformation.createRemoteUser(effectiveUser);\n       UserGroupInformation ugi = UserGroupInformation.createProxyUser(doAsUserFromQuery,\n           remoteUser);\n       try {\n         ProxyUsers.authorize(ugi, request.getRemoteAddr(), conf);\n       } catch (AuthorizationException e) {\n         throw new ServletException(e.getMessage());\n       }\n       effectiveUser = doAsUserFromQuery;\n     }\n     hbaseHandler.setEffectiveUser(effectiveUser);\n     super.doPost(request, response);\n   }\n \n", "target": "// fix_start\n        final RemoteUserIdentity identity = doKerberosAuth(request);\n        effectiveUser = identity.principal;\n        response.addHeader(WWW_AUTHENTICATE,  NEGOTIATE + \" \" + identity.outToken);\n// fix_end\n", "cwe": "CWE-362", "cwe_name": "Concurrent Execution using Shared Resource with Improper Synchronization ('Race Condition')", "idx": 48964}
{"source": " protected void traceLdapEnv(Properties env)\n    {\n       if (trace)\n       {\n          Properties tmp = new Properties();\n          tmp.putAll(env);\n          String credentials = tmp.getProperty(Context.SECURITY_CREDENTIALS);\n          String bindCredential = tmp.getProperty(BIND_CREDENTIAL);\n// bug_start\n         if (credentials != null && credentials.length() > 0)\n            tmp.setProperty(Context.SECURITY_CREDENTIALS, \"***\");\n// bug_end\n \n// bug_start\n         if (bindCredential != null && bindCredential.length() > 0)\n             tmp.setProperty(BIND_CREDENTIAL, \"***\");\n// bug_end\n \n          log.trace(\"Logging into LDAP server, env=\" + tmp.toString());\n       }\n    }\n \n", "target": "// fix_start\n// fix_end\n// fix_start\n         if (credentials != null && credentials.length() > 0) {\n        \t tmp.setProperty(Context.SECURITY_CREDENTIALS, \"***\");\n         }\n\n         if (bindCredential != null && bindCredential.length() > 0) {\n        \t tmp.setProperty(BIND_CREDENTIAL, \"***\");\n         }\n// fix_end\n", "cwe": "CWE-200", "cwe_name": "Exposure of Sensitive Information to an Unauthorized Actor", "idx": 18066}
{"source": " public static Response getErrorResponse(Throwable e, Response.Status status) {\n         String message = e.getMessage() == null ? \"Failed with \" + e.getClass().getName() : e.getMessage();\n         Response response = getErrorResponse(message, status);\n// bug_start\n        JSONObject responseJson = (JSONObject) response.getEntity();\n        try {\n            responseJson.put(AtlasClient.STACKTRACE, printStackTrace(e));\n        } catch (JSONException e1) {\n            LOG.warn(\"Could not construct error Json rensponse\", e1);\n        }\n// bug_end\n         return response;\n     }\n \n", "target": "// fix_start\n\n// fix_end\n", "cwe": "CWE-200", "cwe_name": "Exposure of Sensitive Information to an Unauthorized Actor", "idx": 19800}
{"source": " public String findFilter( String url_suffix )\n     {\n         if( url_suffix == null )\n         {\n             throw new IllegalArgumentException( \"The url_suffix must not be null.\" );\n         }\n \n         CaptureType type = em.find( CaptureType.class, url_suffix );\n \n// bug_start\n        if( type != null )\n// bug_end\n         {\n// bug_start\n            return type.getCaptureFilter();\n// bug_end\n         }\n \n// bug_start\n        return null;\n// bug_end\n     }\n \n", "target": "// fix_start\n        if( type == null )\n// fix_end\n// fix_start\n            throw new IllegalArgumentException( \"The url_suffix must exist in the database.\" );\n// fix_end\n// fix_start\n\n        return type.getCaptureFilter();\n// fix_end\n", "cwe": "CWE-754", "cwe_name": "Improper Check for Unusual or Exceptional Conditions", "idx": 74269}
{"source": " @Exported(inline=true)\n     public Map<String,Object> getMonitorData() {\n         Map<String,Object> r = new HashMap<String, Object>();\n// bug_start\n        for (NodeMonitor monitor : NodeMonitor.getAll())\n            r.put(monitor.getClass().getName(),monitor.data(this));\n// bug_end\n         return r;\n     }\n \n", "target": "// fix_start\n        if (hasPermission(CONNECT)) {\n            for (NodeMonitor monitor : NodeMonitor.getAll())\n                r.put(monitor.getClass().getName(), monitor.data(this));\n        }\n// fix_end\n", "cwe": "CWE-200", "cwe_name": "Exposure of Sensitive Information to an Unauthorized Actor", "idx": 13015}
{"source": " protected Response handleLoginResponse(String samlResponse, SAMLDocumentHolder holder, ResponseType responseType, String relayState, String clientId) {\n \n             try {\n                 KeyManager.ActiveRsaKey keys = session.keys().getActiveRsaKey(realm);\n                 if (! isSuccessfulSamlResponse(responseType)) {\n                     String statusMessage = responseType.getStatus() == null ? Messages.IDENTITY_PROVIDER_UNEXPECTED_ERROR : responseType.getStatus().getStatusMessage();\n                     return callback.error(relayState, statusMessage);\n                 }\n                 if (responseType.getAssertions() == null || responseType.getAssertions().isEmpty()) {\n                     return callback.error(relayState, Messages.IDENTITY_PROVIDER_UNEXPECTED_ERROR);\n                 }\n \n                 boolean assertionIsEncrypted = AssertionUtil.isAssertionEncrypted(responseType);\n \n                 if (config.isWantAssertionsEncrypted() && !assertionIsEncrypted) {\n                     logger.error(\"The assertion is not encrypted, which is required.\");\n                     event.event(EventType.IDENTITY_PROVIDER_RESPONSE);\n                     event.error(Errors.INVALID_SAML_RESPONSE);\n                     return ErrorPage.error(session, null, Response.Status.BAD_REQUEST, Messages.INVALID_REQUESTER);\n                 }\n \n                 Element assertionElement;\n \n                 if (assertionIsEncrypted) {\n                     assertionElement = AssertionUtil.decryptAssertion(holder, responseType, keys.getPrivateKey());\n                 } else {\n                     assertionElement = DocumentUtil.getElement(holder.getSamlDocument(), new QName(JBossSAMLConstants.ASSERTION.get()));\n                 }\n \n                 boolean signed = AssertionUtil.isSignedElement(assertionElement);\n                 if ((config.isWantAssertionsSigned() && !signed)\n                         || (signed && config.isValidateSignature() && !AssertionUtil.isSignatureValid(assertionElement, getIDPKeyLocator()))) {\n                     logger.error(\"validation failed\");\n                     event.event(EventType.IDENTITY_PROVIDER_RESPONSE);\n                     event.error(Errors.INVALID_SIGNATURE);\n                     return ErrorPage.error(session, null, Response.Status.BAD_REQUEST, Messages.INVALID_REQUESTER);\n                 }\n \n                 AssertionType assertion = responseType.getAssertions().get(0).getAssertion();\n \n                 SubjectType subject = assertion.getSubject();\n                 SubjectType.STSubType subType = subject.getSubType();\n                 NameIDType subjectNameID = (NameIDType) subType.getBaseID();\n                 BrokeredIdentityContext identity = new BrokeredIdentityContext(subjectNameID.getValue());\n                 identity.getContextData().put(SAML_LOGIN_RESPONSE, responseType);\n                 identity.getContextData().put(SAML_ASSERTION, assertion);\n                 if (clientId != null && ! clientId.trim().isEmpty()) {\n                     identity.getContextData().put(SAML_IDP_INITIATED_CLIENT_ID, clientId);\n                 }\n \n                 identity.setUsername(subjectNameID.getValue());\n \n                 if (subjectNameID.getFormat() != null && subjectNameID.getFormat().toString().equals(JBossSAMLURIConstants.NAMEID_FORMAT_EMAIL.get())) {\n                     identity.setEmail(subjectNameID.getValue());\n                 }\n \n                 if (config.isStoreToken()) {\n                     identity.setToken(samlResponse);\n                 }\n \n// bug_start\n// bug_end\n                 AuthnStatementType authn = null;\n                 for (Object statement : assertion.getStatements()) {\n                     if (statement instanceof AuthnStatementType) {\n                         authn = (AuthnStatementType)statement;\n                         identity.getContextData().put(SAML_AUTHN_STATEMENT, authn);\n                         break;\n                     }\n                 }\n                 if (assertion.getAttributeStatements() != null ) {\n                     for (AttributeStatementType attrStatement : assertion.getAttributeStatements()) {\n                         for (AttributeStatementType.ASTChoiceType choice : attrStatement.getAttributes()) {\n                             AttributeType attribute = choice.getAttribute();\n                             if (X500SAMLProfileConstants.EMAIL.getFriendlyName().equals(attribute.getFriendlyName())\n                                     || X500SAMLProfileConstants.EMAIL.get().equals(attribute.getName())) {\n                                 if (!attribute.getAttributeValue().isEmpty()) identity.setEmail(attribute.getAttributeValue().get(0).toString());\n                             }\n                         }\n \n                     }\n \n                 }\n                 String brokerUserId = config.getAlias() + \".\" + subjectNameID.getValue();\n                 identity.setBrokerUserId(brokerUserId);\n                 identity.setIdpConfig(config);\n                 identity.setIdp(provider);\n                 if (authn != null && authn.getSessionIndex() != null) {\n                     identity.setBrokerSessionId(identity.getBrokerUserId() + \".\" + authn.getSessionIndex());\n                  }\n                 identity.setCode(relayState);\n \n \n                 return callback.authenticated(identity);\n             } catch (WebApplicationException e) {\n                 return e.getResponse();\n             } catch (Exception e) {\n                 throw new IdentityBrokerException(\"Could not process response from SAML identity provider.\", e);\n             }\n         }\n \n", "target": "// fix_start\n                ConditionsValidator.Builder cvb = new ConditionsValidator.Builder(assertion.getID(), assertion.getConditions(), destinationValidator);\n                try {\n                    String issuerURL = getEntityId(session.getContext().getUri(), realm);\n                    cvb.addAllowedAudience(URI.create(issuerURL));\n                    cvb.addAllowedAudience(URI.create(responseType.getDestination()));\n                } catch (IllegalArgumentException ex) {\n                }\n                if (! cvb.build().isValid()) {\n                    logger.error(\"Assertion expired.\");\n                    event.event(EventType.IDENTITY_PROVIDER_RESPONSE);\n                    event.error(Errors.INVALID_SAML_RESPONSE);\n                    return ErrorPage.error(session, null, Response.Status.BAD_REQUEST, Messages.EXPIRED_CODE);\n                }\n\n// fix_end\n", "cwe": "CWE-287", "cwe_name": "Improper Authentication", "idx": 39205}
{"source": " @SuppressWarnings(\"unchecked\")\n     public This transformObject(Saml2ObjectTransformer<T> tr) {\n         final StringTransformer original = this.transformer;\n         this.transformer = s -> {\n             final String originalTransformed = original.transform(s);\n \n             if (originalTransformed == null) {\n                 return null;\n             }\n \n             final ByteArrayInputStream baos = new ByteArrayInputStream(originalTransformed.getBytes());\n             final T saml2Object = (T) new SAML2Response().getSAML2ObjectFromStream(baos);\n             final T transformed = tr.transform(saml2Object);\n \n             if (transformed == null) {\n                 return null;\n             }\n \n             ByteArrayOutputStream bos = new ByteArrayOutputStream();\n             XMLStreamWriter xmlStreamWriter = StaxUtil.getXMLStreamWriter(bos);\n \n             if (transformed instanceof AuthnRequestType) {\n                 new SAMLRequestWriter(xmlStreamWriter).write((AuthnRequestType) transformed);\n             } else if (transformed instanceof LogoutRequestType) {\n                 new SAMLRequestWriter(xmlStreamWriter).write((LogoutRequestType) transformed);\n             } else if (transformed instanceof ArtifactResolveType) {\n                 new SAMLRequestWriter(xmlStreamWriter).write((ArtifactResolveType) transformed);\n             } else if (transformed instanceof AttributeQueryType) {\n                 new SAMLRequestWriter(xmlStreamWriter).write((AttributeQueryType) transformed);\n             } else if (transformed instanceof ResponseType) {\n                 new SAMLResponseWriter(xmlStreamWriter).write((ResponseType) transformed);\n             } else if (transformed instanceof ArtifactResponseType) {\n                 new SAMLResponseWriter(xmlStreamWriter).write((ArtifactResponseType) transformed);\n             } else if (transformed instanceof StatusResponseType) {\n                 new SAMLResponseWriter(xmlStreamWriter).write((StatusResponseType) transformed, SAMLProtocolQNames.LOGOUT_RESPONSE.getQName(\"samlp\"));\n             } else {\n                 Assert.assertNotNull(\"Unknown type: <null>\", transformed);\n                 Assert.fail(\"Unknown type: \" + transformed.getClass().getName());\n             }\n// bug_start\n            return new String(bos.toByteArray(), GeneralConstants.SAML_CHARSET);\n// bug_end\n         };\n         return (This) this;\n     }\n \n", "target": "// fix_start\n            String res = new String(bos.toByteArray(), GeneralConstants.SAML_CHARSET);\n            LOG.debugf(\"  ---> %s\", res);\n            return res;\n// fix_end\n", "cwe": "CWE-287", "cwe_name": "Improper Authentication", "idx": 39593}
{"source": " protected synchronized void authenticatorConfig() {\n \n// bug_start\n        SecurityConstraint constraints[] = context.findConstraints();\n        if ((constraints == null) || (constraints.length == 0))\n            return;\n// bug_end\n         LoginConfig loginConfig = context.getLoginConfig();\n         if (loginConfig == null) {\n             loginConfig = DUMMY_LOGIN_CONFIG;\n             context.setLoginConfig(loginConfig);\n         }\n \n         if (context.getAuthenticator() != null)\n             return;\n \n         if (!(context instanceof ContainerBase)) {\n             return;\n         }\n \n         if (context.getRealm() == null) {\n             log.error(sm.getString(\"contextConfig.missingRealm\"));\n             ok = false;\n             return;\n         }\n \n         Valve authenticator = null;\n         if (customAuthenticators != null) {\n             authenticator = (Valve)\n                 customAuthenticators.get(loginConfig.getAuthMethod());\n         }\n         if (authenticator == null) {\n             if (authenticators == null) {\n                 try {\n                     InputStream is=this.getClass().getClassLoader().getResourceAsStream(\"org/apache/catalina/startup/Authenticators.properties\");\n                     if( is!=null ) {\n                         authenticators = new Properties();\n                         authenticators.load(is);\n                     } else {\n                         log.error(sm.getString(\n                                 \"contextConfig.authenticatorResources\"));\n                         ok=false;\n                         return;\n                     }\n                 } catch (IOException e) {\n                     log.error(sm.getString(\n                                 \"contextConfig.authenticatorResources\"), e);\n                     ok = false;\n                     return;\n                 }\n             }\n \n             String authenticatorName = null;\n             authenticatorName =\n                     authenticators.getProperty(loginConfig.getAuthMethod());\n             if (authenticatorName == null) {\n                 log.error(sm.getString(\"contextConfig.authenticatorMissing\",\n                                  loginConfig.getAuthMethod()));\n                 ok = false;\n                 return;\n             }\n \n             try {\n                 Class<?> authenticatorClass = Class.forName(authenticatorName);\n                 authenticator = (Valve) authenticatorClass.newInstance();\n             } catch (Throwable t) {\n                 ExceptionUtils.handleThrowable(t);\n                 log.error(sm.getString(\n                                     \"contextConfig.authenticatorInstantiate\",\n                                     authenticatorName),\n                           t);\n                 ok = false;\n             }\n         }\n \n         if (authenticator != null && context instanceof ContainerBase) {\n             Pipeline pipeline = ((ContainerBase) context).getPipeline();\n             if (pipeline != null) {\n                 ((ContainerBase) context).getPipeline().addValve(authenticator);\n                 if (log.isDebugEnabled()) {\n                     log.debug(sm.getString(\n                                     \"contextConfig.authenticatorConfigured\",\n                                     loginConfig.getAuthMethod()));\n                 }\n             }\n         }\n \n     }\n \n", "target": "// fix_start\n// fix_end\n", "cwe": "NVD-CWE-Other", "cwe_name": "Other", "idx": 111167}
{"source": " private Document getFragmentAsDocument(CharSequence value) {\n \t\tDocument fragment = Jsoup.parse( value.toString(), baseURI, Parser.xmlParser() );\n \t\tDocument document = Document.createShell( baseURI );\n \n// bug_start\n\t\tIterator<Element> nodes = fragment.children().iterator();\n\t\twhile ( nodes.hasNext() ) {\n\t\t\tdocument.body().appendChild( nodes.next() );\n// bug_end\n \t\t}\n \n \t\treturn document;\n \t}\n \n", "target": "// fix_start\n\t\tList<Node> childNodes = fragment.childNodes();\n\t\tfor ( Node node : childNodes ) {\n\t\t\tdocument.body().appendChild( node.clone() );\n// fix_end\n", "cwe": "CWE-79", "cwe_name": "Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')", "idx": 79126}
{"source": " private boolean processRemainingHeader() throws IOException {\n         int headerLength;\n         if (isMasked()) {\n             headerLength = 4;\n         } else {\n             headerLength = 0;\n         }\n         if (payloadLength == 126) {\n             headerLength += 2;\n         } else if (payloadLength == 127) {\n             headerLength += 8;\n         }\n         if (inputBuffer.remaining() < headerLength) {\n             return false;\n         }\n         if (payloadLength == 126) {\n             payloadLength = byteArrayToLong(inputBuffer.array(),\n                     inputBuffer.arrayOffset() + inputBuffer.position(), 2);\n             inputBuffer.position(inputBuffer.position() + 2);\n         } else if (payloadLength == 127) {\n             payloadLength = byteArrayToLong(inputBuffer.array(),\n                     inputBuffer.arrayOffset() + inputBuffer.position(), 8);\n// bug_start\n// bug_end\n             inputBuffer.position(inputBuffer.position() + 8);\n         }\n         if (Util.isControl(opCode)) {\n             if (payloadLength > 125) {\n                 throw new WsIOException(new CloseReason(\n                         CloseCodes.PROTOCOL_ERROR,\n                         sm.getString(\"wsFrame.controlPayloadTooBig\", Long.valueOf(payloadLength))));\n             }\n             if (!fin) {\n                 throw new WsIOException(new CloseReason(\n                         CloseCodes.PROTOCOL_ERROR,\n                         sm.getString(\"wsFrame.controlNoFin\")));\n             }\n         }\n         if (isMasked()) {\n             inputBuffer.get(mask, 0, 4);\n         }\n         state = State.DATA;\n         return true;\n     }\n \n", "target": "// fix_start\n            if (payloadLength < 0) {\n                throw new WsIOException(\n                        new CloseReason(CloseCodes.PROTOCOL_ERROR, sm.getString(\"wsFrame.payloadMsbInvalid\")));\n            }\n// fix_end\n", "cwe": "CWE-835", "cwe_name": "Loop with Unreachable Exit Condition ('Infinite Loop')", "idx": 82446}
{"source": " private String resolveToken(HttpServletRequest request) {\n// bug_start\n        String bearerToken = request.getHeader(WebSecurityConfig.AUTHORIZATION_HEADER);\n        if (StringUtils.hasText(bearerToken) && bearerToken.startsWith(TOKEN_PREFIX)) {\n            return bearerToken.substring(7, bearerToken.length());\n// bug_end\n         }\n// bug_start\n        String jwt = request.getParameter(WebSecurityConfig.AUTHORIZATION_TOKEN);\n        if (StringUtils.hasText(jwt)) {\n// bug_end\n             return jwt;\n         }\n         return null;\n     }\n \n", "target": "// fix_start\n        String bearerToken = request.getHeader(NacosAuthConfig.AUTHORIZATION_HEADER);\n        if (StringUtils.isNotBlank(bearerToken) && bearerToken.startsWith(TOKEN_PREFIX)) {\n            return bearerToken.substring(7);\n// fix_end\n// fix_start\n        String jwt = request.getParameter(Constants.ACCESS_TOKEN);\n        if (StringUtils.isNotBlank(jwt)) {\n// fix_end\n", "cwe": "NVD-CWE-noinfo", "cwe_name": "", "idx": 98064}
{"source": " private void signIn(String userName, String password) {\n// bug_start\n        webDriver.get(baseUrl + \"/logout.do\");\n        webDriver.get(baseUrl + \"/login\");\n// bug_end\n         webDriver.findElement(By.name(\"username\")).sendKeys(userName);\n         webDriver.findElement(By.name(\"password\")).sendKeys(password);\n         webDriver.findElement(By.xpath(\"//input[@value='Sign in']\")).click();\n// bug_start\n        assertThat(webDriver.findElement(By.cssSelector(\"h1\")).getText(), containsString(\"Where to?\"));\n// bug_end\n     }\n \n", "target": "// fix_start\n// fix_end\n// fix_start\n// fix_end\n", "cwe": "CWE-264", "cwe_name": "Permissions, Privileges, and Access Controls", "idx": 35173}
{"source": " public static long getNextScheduledTime(final String cronEntry, long currentTime) throws MessageFormatException {\n \n         long result = 0;\n \n         if (cronEntry == null || cronEntry.length() == 0) {\n             return result;\n         }\n \n// bug_start\n        if (cronEntry.startsWith(\"* * * * *\")) {\n// bug_end\n             result = currentTime + 60 * 1000;\n             result = result / 1000 * 1000;\n             return result;\n         }\n \n         List<String> list = tokenize(cronEntry);\n         List<CronEntry> entries = buildCronEntries(list);\n         Calendar working = Calendar.getInstance();\n         working.setTimeInMillis(currentTime);\n         working.set(Calendar.SECOND, 0);\n \n         CronEntry minutes = entries.get(MINUTES);\n         CronEntry hours = entries.get(HOURS);\n         CronEntry dayOfMonth = entries.get(DAY_OF_MONTH);\n         CronEntry month = entries.get(MONTH);\n         CronEntry dayOfWeek = entries.get(DAY_OF_WEEK);\n \n         int timeToNextMinute = 60 - working.get(Calendar.SECOND);\n         working.add(Calendar.SECOND, timeToNextMinute);\n \n         int currentMinutes = working.get(Calendar.MINUTE);\n         if (!isCurrent(minutes, currentMinutes)) {\n             int nextMinutes = getNext(minutes, currentMinutes);\n             working.add(Calendar.MINUTE, nextMinutes);\n         }\n \n         int currentHours = working.get(Calendar.HOUR_OF_DAY);\n         if (!isCurrent(hours, currentHours)) {\n             int nextHour = getNext(hours, currentHours);\n             working.add(Calendar.HOUR_OF_DAY, nextHour);\n         }\n \n         doUpdateCurrentDay(working, dayOfMonth, dayOfWeek);\n \n         doUpdateCurrentMonth(working, month);\n \n         doUpdateCurrentDay(working, dayOfMonth, dayOfWeek);\n \n \n         currentHours = working.get(Calendar.HOUR_OF_DAY);\n         if (!isCurrent(hours, currentHours)) {\n             int nextHour = getNext(hours, currentHours);\n             working.add(Calendar.HOUR_OF_DAY, nextHour);\n         }\n \n         currentMinutes = working.get(Calendar.MINUTE);\n         if (!isCurrent(minutes, currentMinutes)) {\n             int nextMinutes = getNext(minutes, currentMinutes);\n             working.add(Calendar.MINUTE, nextMinutes);\n         }\n \n         result = working.getTimeInMillis();\n \n         if (result <= currentTime) {\n             throw new ArithmeticException(\"Unable to compute next scheduled exection time.\");\n         }\n \n         return result;\n     }\n \n", "target": "// fix_start\n        if (cronEntry.equals(\"* * * * *\")) {\n// fix_end\n", "cwe": "CWE-79", "cwe_name": "Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')", "idx": 77465}
{"source": " private IdentityZone createZone(String id, HttpStatus expect, String token, IdentityZoneConfiguration zoneConfiguration) throws Exception {\n// bug_start\n        IdentityZone identityZone = getIdentityZone(id);\n        identityZone.setConfig(zoneConfiguration);\n        identityZone.getConfig().getSamlConfig().setPrivateKey(serviceProviderKey);\n        identityZone.getConfig().getSamlConfig().setPrivateKeyPassword(serviceProviderKeyPassword);\n        identityZone.getConfig().getSamlConfig().setCertificate(serviceProviderCertificate);\n// bug_end\n         Map<String, String> keys = new HashMap<>();\n         keys.put(\"kid\", \"key\");\n// bug_start\n        identityZone.getConfig().getTokenPolicy().setKeys(keys);\n        identityZone.getConfig().getTokenPolicy().setActiveKeyId(\"kid\");\n// bug_end\n \n// bug_start\n        MvcResult result = getMockMvc().perform(\n            post(\"/identity-zones\")\n                .header(\"Authorization\", \"Bearer \" + token)\n                .contentType(APPLICATION_JSON)\n                .content(JsonUtils.writeValueAsString(identityZone)))\n            .andExpect(status().is(expect.value()))\n            .andReturn();\n\n        if (expect.is2xxSuccessful()) {\n            return JsonUtils.readValue(result.getResponse().getContentAsString(), IdentityZone.class);\n        }\n        return null;\n// bug_end\n     }\n \n", "target": "// fix_start\n// fix_end\n// fix_start\n        zoneConfiguration.getTokenPolicy().setKeys(keys);\n        zoneConfiguration.getTokenPolicy().setActiveKeyId(\"kid\");\n        zoneConfiguration.getTokenPolicy().setKeys(keys);\n// fix_end\n// fix_start\n        return createZone(id, expect, \"\" , token, zoneConfiguration);\n// fix_end\n", "cwe": "NVD-CWE-noinfo", "cwe_name": "", "idx": 109184}
{"source": " @Override\n     public IdentityZoneConfiguration validate(IdentityZone zone, IdentityZoneValidator.Mode mode) throws InvalidIdentityZoneConfigurationException {\n         IdentityZoneConfiguration config = zone.getConfig();\n         if (mode == IdentityZoneValidator.Mode.CREATE || mode == IdentityZoneValidator.Mode.MODIFY) {\n             String currentKeyId = null;\n             try {\n                 SamlConfig samlConfig;\n                 if ((samlConfig = config.getSamlConfig()) != null && samlConfig.getKeys().size()>0) {\n                     String activeKeyId = samlConfig.getActiveKeyId();\n                     if ( (activeKeyId == null || samlConfig.getKeys().get(activeKeyId) == null)) {\n \n                         throw new InvalidIdentityZoneConfigurationException(String.format(\"Invalid SAML active key ID: '%s'. Couldn't find any matching keys.\", activeKeyId));\n                     }\n \n                     for (Map.Entry<String, SamlKey> entry : samlConfig.getKeys().entrySet()) {\n                         currentKeyId = entry.getKey();\n                         String samlSpCert = entry.getValue().getCertificate();\n                         String samlSpKey = entry.getValue().getKey();\n                         String samlSpkeyPassphrase = entry.getValue().getPassphrase();\n                         if (samlSpKey != null && samlSpCert != null) {\n                             new KeyWithCert(samlSpKey, samlSpkeyPassphrase, samlSpCert);\n                         }\n                         failIfPartialCertKeyInfo(samlSpCert, samlSpKey, samlSpkeyPassphrase);\n                     }\n                 }\n             } catch (GeneralSecurityException ex) {\n                 throw new InvalidIdentityZoneConfigurationException(String.format(\"There is a security problem with the SAML SP Key configuration for key '%s'.\", currentKeyId), ex);\n             }\n \n             TokenPolicy tokenPolicy = config.getTokenPolicy();\n             if (tokenPolicy != null) {\n                 String activeKeyId = tokenPolicy.getActiveKeyId();\n                 if (StringUtils.hasText(activeKeyId)) {\n                     Map<String, String> jwtKeys = tokenPolicy.getKeys();\n \n                     if (jwtKeys == null || jwtKeys.isEmpty()) {\n                         throw new InvalidIdentityZoneConfigurationException(\"Identity zone cannot specify an active key ID with no keys configured for the zone.\", null);\n                     } else {\n                         if (!jwtKeys.containsKey(activeKeyId)) {\n                             throw new InvalidIdentityZoneConfigurationException(\"The specified active key ID is not present in the configured keys: \" + activeKeyId, null);\n                         }\n                     }\n                 }\n             }\n// bug_start\n// bug_end\n         }\n \n         if(config.getBranding() != null && config.getBranding().getBanner() != null) {\n            BannerValidator.validate(config.getBranding().getBanner());\n         }\n \n         if(config.getMfaConfig() != null) {\n             mfaConfigValidator.validate(config.getMfaConfig(), zone.getId());\n         }\n \n         return config;\n     }\n \n", "target": "// fix_start\n            if (!StringUtils.isEmpty(config.getIssuer())) {\n                if (tokenPolicy == null || StringUtils.isEmpty(tokenPolicy.getActiveKeyId())) {\n                    throw new InvalidIdentityZoneConfigurationException(\"You cannot set issuer value unless you have set your own signing key for this identity zone.\");\n                }\n            }\n// fix_end\n", "cwe": "NVD-CWE-noinfo", "cwe_name": "", "idx": 102681}
{"source": " private CoderResult decodeHasArray(ByteBuffer in, CharBuffer out) {\n         int outRemaining = out.remaining();\n         int pos = in.position();\n         int limit = in.limit();\n         final byte[] bArr = in.array();\n         final char[] cArr = out.array();\n         final int inIndexLimit = limit + in.arrayOffset();\n         int inIndex = pos + in.arrayOffset();\n         int outIndex = out.position() + out.arrayOffset();\n         for (; inIndex < inIndexLimit && outRemaining > 0; inIndex++) {\n             int jchar = bArr[inIndex];\n             if (jchar < 0) {\n                 jchar = jchar & 0x7F;\n                 int tail = remainingBytes[jchar];\n                 if (tail == -1) {\n                     in.position(inIndex - in.arrayOffset());\n                     out.position(outIndex - out.arrayOffset());\n                     return CoderResult.malformedForLength(1);\n                 }\n                 int tailAvailable = inIndexLimit - inIndex - 1;\n                 if (tailAvailable > 0) {\n                     if (jchar > 0x41 && jchar < 0x60 &&\n                             (bArr[inIndex + 1] & 0xC0) != 0x80) {\n                         in.position(inIndex - in.arrayOffset());\n                         out.position(outIndex - out.arrayOffset());\n                         return CoderResult.malformedForLength(1);\n                     }\n                     if (jchar == 0x60 && (bArr[inIndex + 1] & 0xE0) != 0xA0) {\n                         in.position(inIndex - in.arrayOffset());\n                         out.position(outIndex - out.arrayOffset());\n                         return CoderResult.malformedForLength(1);\n                     }\n                     if (jchar > 0x60 && jchar < 0x6D &&\n                             (bArr[inIndex + 1] & 0xC0) != 0x80) {\n                         in.position(inIndex - in.arrayOffset());\n                         out.position(outIndex - out.arrayOffset());\n                         return CoderResult.malformedForLength(1);\n                     }\n                     if (jchar == 0x6D && (bArr[inIndex + 1] & 0xE0) != 0x80) {\n                         in.position(inIndex - in.arrayOffset());\n                         out.position(outIndex - out.arrayOffset());\n                         return CoderResult.malformedForLength(1);\n                     }\n                     if (jchar > 0x6D && jchar < 0x70 &&\n                             (bArr[inIndex + 1] & 0xC0) != 0x80) {\n                         in.position(inIndex - in.arrayOffset());\n                         out.position(outIndex - out.arrayOffset());\n                         return CoderResult.malformedForLength(1);\n                     }\n                     if (jchar == 0x70 &&\n                             ((bArr[inIndex + 1] & 0xFF) < 0x90 ||\n                             (bArr[inIndex + 1] & 0xFF) > 0xBF)) {\n                         in.position(inIndex - in.arrayOffset());\n                         out.position(outIndex - out.arrayOffset());\n                         return CoderResult.malformedForLength(1);\n                     }\n                     if (jchar > 0x70 && jchar < 0x74 &&\n                             (bArr[inIndex + 1] & 0xC0) != 0x80) {\n                         in.position(inIndex - in.arrayOffset());\n                         out.position(outIndex - out.arrayOffset());\n                         return CoderResult.malformedForLength(1);\n                     }\n                     if (jchar == 0x74 &&\n                             (bArr[inIndex + 1] & 0xF0) != 0x80) {\n                         in.position(inIndex - in.arrayOffset());\n                         out.position(outIndex - out.arrayOffset());\n                         return CoderResult.malformedForLength(1);\n                     }\n                 }\n                 if (tailAvailable > 1 && tail > 1) {\n                     if ((bArr[inIndex + 2] & 0xC0) != 0x80) {\n                         in.position(inIndex - in.arrayOffset());\n                         out.position(outIndex - out.arrayOffset());\n                         return CoderResult.malformedForLength(2);\n                     }\n                 }\n                 if (tailAvailable > 2 && tail > 2) {\n                     if ((bArr[inIndex + 3] & 0xC0) != 0x80) {\n                         in.position(inIndex - in.arrayOffset());\n                         out.position(outIndex - out.arrayOffset());\n                         return CoderResult.malformedForLength(3);\n                     }\n                 }\n                 if (tailAvailable < tail) {\n                     break;\n                 }\n                 for (int i = 0; i < tail; i++) {\n                     int nextByte = bArr[inIndex + i + 1] & 0xFF;\n                     if ((nextByte & 0xC0) != 0x80) {\n                         in.position(inIndex - in.arrayOffset());\n                         out.position(outIndex - out.arrayOffset());\n                         return CoderResult.malformedForLength(1 + i);\n                     }\n                     jchar = (jchar << 6) + nextByte;\n                 }\n                 jchar -= remainingNumbers[tail];\n                 if (jchar < lowerEncodingLimit[tail]) {\n                     in.position(inIndex - in.arrayOffset());\n                     out.position(outIndex - out.arrayOffset());\n                     return CoderResult.malformedForLength(1);\n                 }\n                 inIndex += tail;\n             }\n             if (jchar >= 0xD800 && jchar <= 0xDFFF) {\n                 return CoderResult.unmappableForLength(3);\n             }\n             if (jchar > 0x10FFFF) {\n                 return CoderResult.unmappableForLength(4);\n             }\n             if (jchar <= 0xffff) {\n                 cArr[outIndex++] = (char) jchar;\n                 outRemaining--;\n             } else {\n                 if (outRemaining < 2) {\n// bug_start\n// bug_end\n                     return CoderResult.OVERFLOW;\n                 }\n                 cArr[outIndex++] = (char) ((jchar >> 0xA) + 0xD7C0);\n                 cArr[outIndex++] = (char) ((jchar & 0x3FF) + 0xDC00);\n                 outRemaining -= 2;\n             }\n         }\n         in.position(inIndex - in.arrayOffset());\n         out.position(outIndex - out.arrayOffset());\n         return (outRemaining == 0 && inIndex < inIndexLimit) ?\n                 CoderResult.OVERFLOW :\n                 CoderResult.UNDERFLOW;\n     }\n \n", "target": "// fix_start\n                    inIndex -= 3;\n                    in.position(inIndex - in.arrayOffset());\n                    out.position(outIndex - out.arrayOffset());\n// fix_end\n", "cwe": "CWE-835", "cwe_name": "Loop with Unreachable Exit Condition ('Infinite Loop')", "idx": 82482}
{"source": " public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {\n         LOGGER.entering(HudsonFilter.class.getName(), \"doFilter\");\n// bug_start\n// bug_end\n \n         Filter f = filter;\n \n         if(f==null) {\n             chain.doFilter(request,response);\n         } else {\n             f.doFilter(request,response,chain);\n         }\n     }\n \n", "target": "// fix_start\n\n        ((HttpServletResponse)response).setHeader(\"X-Content-Type-Options\", \"nosniff\");\n// fix_end\n", "cwe": "CWE-79", "cwe_name": "Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')", "idx": 77698}
{"source": " @Override\n         public SocketState process(SocketWrapperBase<S> wrapper, SocketEvent status) {\n             if (getLog().isDebugEnabled()) {\n                 getLog().debug(sm.getString(\"abstractConnectionHandler.process\",\n                         wrapper.getSocket(), status));\n             }\n             if (wrapper == null) {\n                 return SocketState.CLOSED;\n             }\n \n             S socket = wrapper.getSocket();\n \n             Processor processor = (Processor) wrapper.getCurrentProcessor();\n             if (getLog().isDebugEnabled()) {\n                 getLog().debug(sm.getString(\"abstractConnectionHandler.connectionsGet\",\n                         processor, socket));\n             }\n \n             if (SocketEvent.TIMEOUT == status &&\n                     (processor == null ||\n                     !processor.isAsync() && !processor.isUpgrade() ||\n                     processor.isAsync() && !processor.checkAsyncTimeoutGeneration())) {\n                 return SocketState.OPEN;\n             }\n \n             if (processor != null) {\n                 getProtocol().removeWaitingProcessor(processor);\n             } else if (status == SocketEvent.DISCONNECT || status == SocketEvent.ERROR) {\n                 return SocketState.CLOSED;\n             }\n \n             ContainerThreadMarker.set();\n \n             try {\n                 if (processor == null) {\n                     String negotiatedProtocol = wrapper.getNegotiatedProtocol();\n                     if (negotiatedProtocol != null && negotiatedProtocol.length() > 0) {\n                         UpgradeProtocol upgradeProtocol = getProtocol().getNegotiatedProtocol(negotiatedProtocol);\n                         if (upgradeProtocol != null) {\n                             processor = upgradeProtocol.getProcessor(wrapper, getProtocol().getAdapter());\n                             if (getLog().isDebugEnabled()) {\n                                 getLog().debug(sm.getString(\"abstractConnectionHandler.processorCreate\", processor));\n                             }\n                         } else if (negotiatedProtocol.equals(\"http/1.1\")) {\n                         } else {\n                             if (getLog().isDebugEnabled()) {\n                                 getLog().debug(sm.getString(\"abstractConnectionHandler.negotiatedProcessor.fail\",\n                                         negotiatedProtocol));\n                             }\n                             return SocketState.CLOSED;\n                         }\n                     }\n                 }\n                 if (processor == null) {\n                     processor = recycledProcessors.pop();\n                     if (getLog().isDebugEnabled()) {\n                         getLog().debug(sm.getString(\"abstractConnectionHandler.processorPop\", processor));\n                     }\n                 }\n                 if (processor == null) {\n                     processor = getProtocol().createProcessor();\n                     register(processor);\n                     if (getLog().isDebugEnabled()) {\n                         getLog().debug(sm.getString(\"abstractConnectionHandler.processorCreate\", processor));\n                     }\n                 }\n \n                 processor.setSslSupport(\n                         wrapper.getSslSupport(getProtocol().getClientCertProvider()));\n \n                 wrapper.setCurrentProcessor(processor);\n \n                 SocketState state = SocketState.CLOSED;\n                 do {\n                     state = processor.process(wrapper, status);\n \n                     if (state == SocketState.UPGRADING) {\n                         UpgradeToken upgradeToken = processor.getUpgradeToken();\n                         ByteBuffer leftOverInput = processor.getLeftoverInput();\n                         if (upgradeToken == null) {\n                             UpgradeProtocol upgradeProtocol = getProtocol().getUpgradeProtocol(\"h2c\");\n                             if (upgradeProtocol != null) {\n// bug_start\n                                processor = upgradeProtocol.getProcessor(\n                                        wrapper, getProtocol().getAdapter());\n// bug_end\n                                 wrapper.unRead(leftOverInput);\n                                 wrapper.setCurrentProcessor(processor);\n                             } else {\n                                 if (getLog().isDebugEnabled()) {\n                                     getLog().debug(sm.getString(\n                                         \"abstractConnectionHandler.negotiatedProcessor.fail\",\n                                         \"h2c\"));\n                                 }\n// bug_start\n                                return SocketState.CLOSED;\n// bug_end\n                             }\n                         } else {\n                             HttpUpgradeHandler httpUpgradeHandler = upgradeToken.getHttpUpgradeHandler();\n                             release(processor);\n                             processor = getProtocol().createUpgradeProcessor(wrapper, upgradeToken);\n                             if (getLog().isDebugEnabled()) {\n                                 getLog().debug(sm.getString(\"abstractConnectionHandler.upgradeCreate\",\n                                         processor, wrapper));\n                             }\n                             wrapper.unRead(leftOverInput);\n                             wrapper.setUpgraded(true);\n                             wrapper.setCurrentProcessor(processor);\n                             if (upgradeToken.getInstanceManager() == null) {\n                                 httpUpgradeHandler.init((WebConnection) processor);\n                             } else {\n                                 ClassLoader oldCL = upgradeToken.getContextBind().bind(false, null);\n                                 try {\n                                     httpUpgradeHandler.init((WebConnection) processor);\n                                 } finally {\n                                     upgradeToken.getContextBind().unbind(false, oldCL);\n                                 }\n                             }\n                             if (httpUpgradeHandler instanceof InternalHttpUpgradeHandler) {\n                                 if (((InternalHttpUpgradeHandler) httpUpgradeHandler).hasAsyncIO()) {\n                                     state = SocketState.LONG;\n                                 }\n                             }\n                         }\n                     }\n                 } while ( state == SocketState.UPGRADING);\n \n                 if (state == SocketState.LONG) {\n                     longPoll(wrapper, processor);\n                     if (processor.isAsync()) {\n                         getProtocol().addWaitingProcessor(processor);\n                     }\n                 } else if (state == SocketState.OPEN) {\n                     wrapper.setCurrentProcessor(null);\n                     release(processor);\n                     wrapper.registerReadInterest();\n                 } else if (state == SocketState.SENDFILE) {\n                 } else if (state == SocketState.UPGRADED) {\n                     if (status != SocketEvent.OPEN_WRITE) {\n                         longPoll(wrapper, processor);\n                         getProtocol().addWaitingProcessor(processor);\n                     }\n                 } else if (state == SocketState.SUSPENDED) {\n                 } else {\n                     wrapper.setCurrentProcessor(null);\n                     if (processor.isUpgrade()) {\n                         UpgradeToken upgradeToken = processor.getUpgradeToken();\n                         HttpUpgradeHandler httpUpgradeHandler = upgradeToken.getHttpUpgradeHandler();\n                         InstanceManager instanceManager = upgradeToken.getInstanceManager();\n                         if (instanceManager == null) {\n                             httpUpgradeHandler.destroy();\n                         } else {\n                             ClassLoader oldCL = upgradeToken.getContextBind().bind(false, null);\n                             try {\n                                 httpUpgradeHandler.destroy();\n                             } finally {\n                                 try {\n                                     instanceManager.destroyInstance(httpUpgradeHandler);\n                                 } catch (Throwable e) {\n                                     ExceptionUtils.handleThrowable(e);\n                                     getLog().error(sm.getString(\"abstractConnectionHandler.error\"), e);\n                                 }\n                                 upgradeToken.getContextBind().unbind(false, oldCL);\n                             }\n                         }\n                     }\n                     release(processor);\n                 }\n                 return state;\n             } catch(java.net.SocketException e) {\n                 getLog().debug(sm.getString(\n                         \"abstractConnectionHandler.socketexception.debug\"), e);\n             } catch (java.io.IOException e) {\n                 getLog().debug(sm.getString(\n                         \"abstractConnectionHandler.ioexception.debug\"), e);\n             } catch (ProtocolException e) {\n                 getLog().debug(sm.getString(\n                         \"abstractConnectionHandler.protocolexception.debug\"), e);\n             }\n             catch (OutOfMemoryError oome) {\n                 getLog().error(sm.getString(\"abstractConnectionHandler.oome\"), oome);\n             } catch (Throwable e) {\n                 ExceptionUtils.handleThrowable(e);\n                 getLog().error(sm.getString(\"abstractConnectionHandler.error\"), e);\n             } finally {\n                 ContainerThreadMarker.clear();\n             }\n \n             wrapper.setCurrentProcessor(null);\n             release(processor);\n             return SocketState.CLOSED;\n         }\n \n", "target": "// fix_start\n                                release(processor);\n                                processor = upgradeProtocol.getProcessor(wrapper, getProtocol().getAdapter());\n// fix_end\n// fix_start\n                                state = SocketState.CLOSED;\n// fix_end\n", "cwe": "CWE-476", "cwe_name": "NULL Pointer Dereference", "idx": 56813}
{"source": " @SuppressJava6Requirement(reason = \"Guarded by version check\")\n     public static File createTempFile(String prefix, String suffix, File directory) throws IOException {\n         if (javaVersion() >= 7) {\n             if (directory == null) {\n                 return Files.createTempFile(prefix, suffix).toFile();\n             }\n             return Files.createTempFile(directory.toPath(), prefix, suffix).toFile();\n         }\n// bug_start\n// bug_end\n         if (directory == null) {\n// bug_start\n            return File.createTempFile(prefix, suffix);\n// bug_end\n         }\n// bug_start\n        File file = File.createTempFile(prefix, suffix, directory);\n        file.setReadable(false, false);\n        file.setReadable(true, true);\n// bug_end\n         return file;\n     }\n \n", "target": "// fix_start\n        final File file;\n// fix_end\n// fix_start\n            file = File.createTempFile(prefix, suffix);\n        } else {\n            file = File.createTempFile(prefix, suffix, directory);\n// fix_end\n// fix_start\n\n        if (!file.setReadable(false, false)) {\n            throw new IOException(\"Failed to set permissions on temporary file \" + file);\n        }\n        if (!file.setReadable(true, true)) {\n            throw new IOException(\"Failed to set permissions on temporary file \" + file);\n        }\n// fix_end\n", "cwe": "CWE-668", "cwe_name": "Exposure of Resource to Wrong Sphere", "idx": 71506}
{"source": " @Override\n     public BuildWrapper createBuildWrapper(AbstractBuild<?,?> build) {\n         return new BuildWrapper() {\n             @Override\n             public Environment setUp(AbstractBuild build, Launcher launcher, BuildListener listener) throws IOException, InterruptedException {\n             \tif (!StringUtils.isEmpty(location) && !StringUtils.isEmpty(file.getName())) {\n             \t    listener.getLogger().println(\"Copying file to \"+location);\n                     FilePath ws = build.getWorkspace();\n                     if (ws == null) {\n                         throw new IllegalStateException(\"The workspace should be created when setUp method is called\");\n                     }\n// bug_start\n                    if (!ALLOW_FOLDER_TRAVERSAL_OUTSIDE_WORKSPACE && !ws.isDescendant(location)) {\n// bug_end\n                         listener.error(\"Rejecting file path escaping base directory with relative path: \" + location);\n                         return null;\n                     }\n                     FilePath locationFilePath = ws.child(location);\n                     locationFilePath.getParent().mkdirs();\n             \t    locationFilePath.copyFrom(file);\n                     locationFilePath.copyTo(new FilePath(getLocationUnderBuild(build)));\n             \t}\n                 return new Environment() {};\n             }\n         };\n     }\n \n", "target": "// fix_start\n                    if (!ALLOW_FOLDER_TRAVERSAL_OUTSIDE_WORKSPACE && (PROHIBITED_DOUBLE_DOT.matcher(location).matches() || !ws.isDescendant(location))) {\n// fix_end\n", "cwe": "CWE-22", "cwe_name": "Path Traversal", "idx": 21308}
{"source": " public static void setHiveConfWhiteList(HiveConf hiveConf) throws HiveAuthzPluginException {\n \n     String whiteListParamsStr = hiveConf\n         .getVar(ConfVars.HIVE_AUTHORIZATION_SQL_STD_AUTH_CONFIG_WHITELIST);\n \n     if(whiteListParamsStr == null || whiteListParamsStr.trim().isEmpty()) {\n       throw new HiveAuthzPluginException(\"Configuration parameter \"\n           + ConfVars.HIVE_AUTHORIZATION_SQL_STD_AUTH_CONFIG_WHITELIST.varname\n           + \" is not initialized.\");\n     }\n \n     String whiteListAppend = hiveConf\n         .getVar(ConfVars.HIVE_AUTHORIZATION_SQL_STD_AUTH_CONFIG_WHITELIST_APPEND);\n     if (whiteListAppend != null && !whiteListAppend.trim().equals(\"\")) {\n       whiteListParamsStr = whiteListParamsStr + \"|\" + whiteListAppend;\n     }\n \n     hiveConf.setModifiableWhiteListRegex(whiteListParamsStr);\n \n     String curBlackList = hiveConf.getVar(ConfVars.HIVE_SERVER2_BUILTIN_UDF_BLACKLIST);\n     if (curBlackList == null || curBlackList.trim().isEmpty()) {\n// bug_start\n      hiveConf.setVar(ConfVars.HIVE_SERVER2_BUILTIN_UDF_BLACKLIST, \"reflect,reflect2,java_method\");\n// bug_end\n     }\n   }\n \n", "target": "// fix_start\n      hiveConf.setVar(ConfVars.HIVE_SERVER2_BUILTIN_UDF_BLACKLIST, \"reflect,reflect2,java_method,in_file\");\n// fix_end\n", "cwe": "NVD-CWE-noinfo", "cwe_name": "", "idx": 102474}
{"source": " public static int versionCompare(String fromVersion, String toVersion) {\n// bug_start\n// bug_end\n         String[] fromArr = fromVersion.split(\"\\\\.\");\n         String[] toArr = toVersion.split(\"\\\\.\");\n// bug_start\n        int fromFirst = Integer.parseInt(fromArr[0]);\n        int fromMiddle = Integer.parseInt(fromArr[1]);\n        int fromEnd = Integer.parseInt(fromArr[2]);\n        int toFirst = Integer.parseInt(toArr[0]);\n        int toMiddle = Integer.parseInt(toArr[1]);\n        int toEnd = Integer.parseInt(toArr[2]);\n        if (fromFirst - toFirst != 0) {\n            return fromFirst - toFirst;\n        } else if (fromMiddle - toMiddle != 0) {\n            return fromMiddle - toMiddle;\n        } else {\n            return fromEnd - toEnd;\n// bug_end\n         }\n     }\n \n", "target": "// fix_start\n        if (fromVersion == null || toVersion == null) {\n            return -1;\n        }\n// fix_end\n// fix_start\n        if (fromArr.length != 3 || toArr.length != 3) {\n            return -1;\n        }\n        try {\n            int fromFirst = Integer.parseInt(fromArr[0]);\n            int fromMiddle = Integer.parseInt(fromArr[1]);\n            int fromEnd = Integer.parseInt(fromArr[2]);\n            int toFirst = Integer.parseInt(toArr[0]);\n            int toMiddle = Integer.parseInt(toArr[1]);\n            int toEnd = Integer.parseInt(toArr[2]);\n            if (fromFirst - toFirst != 0) {\n                return fromFirst - toFirst;\n            } else if (fromMiddle - toMiddle != 0) {\n                return fromMiddle - toMiddle;\n            } else {\n                return fromEnd - toEnd;\n            }\n        } catch (NumberFormatException nfe) {\n            return -1;\n// fix_end\n", "cwe": "NVD-CWE-noinfo", "cwe_name": "", "idx": 102441}
{"source": " @Override\n         public String toString() {\n             int fc = failureCount();\n             if(fc>0)\n// bug_start\n                return Util.wrapToErrorSpan(Messages.ResponseTimeMonitor_TimeOut(fc));\n// bug_end\n             return getAverage()+\"ms\";\n         }\n \n", "target": "// fix_start\n                return Messages.ResponseTimeMonitor_TimeOut(fc);\n// fix_end\n", "cwe": "CWE-79", "cwe_name": "Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')", "idx": 77708}
{"source": " protected boolean isRestrictedClass(Object o) {\n     if (o == null) {\n       return false;\n     }\n \n     return (\n       (\n         o.getClass().getPackage() != null &&\n         o.getClass().getPackage().getName().startsWith(\"java.lang.reflect\")\n       ) ||\n       o instanceof Class ||\n       o instanceof ClassLoader ||\n       o instanceof Thread ||\n       o instanceof Method ||\n       o instanceof Field ||\n// bug_start\n      o instanceof Constructor\n// bug_end\n     );\n   }\n \n", "target": "// fix_start\n      o instanceof Constructor ||\n      o instanceof JinjavaInterpreter\n// fix_end\n", "cwe": "CWE-863", "cwe_name": "Incorrect Authorization", "idx": 89713}
{"source": " @Override\n     public HeaderEmitter headersStart(int streamId, boolean headersEndStream)\n             throws Http2Exception, IOException {\n \n         checkPauseState();\n \n         if (connectionState.get().isNewStreamAllowed()) {\n             Stream stream = getStream(streamId, false);\n             if (stream == null) {\n                 stream = createRemoteStream(streamId);\n             }\n             if (streamId < maxActiveRemoteStreamId) {\n                 throw new ConnectionException(sm.getString(\"upgradeHandler.stream.old\",\n                         Integer.valueOf(streamId), Integer.valueOf(maxActiveRemoteStreamId)),\n                         Http2Error.PROTOCOL_ERROR);\n             }\n             stream.checkState(FrameType.HEADERS);\n             stream.receivedStartOfHeaders(headersEndStream);\n             closeIdleStreams(streamId);\n// bug_start\n            if (localSettings.getMaxConcurrentStreams() < activeRemoteStreamCount.incrementAndGet()) {\n                setConnectionTimeoutForStreamCount(activeRemoteStreamCount.decrementAndGet());\n                increaseOverheadCount();\n                throw new StreamException(sm.getString(\"upgradeHandler.tooManyRemoteStreams\",\n                        Long.toString(localSettings.getMaxConcurrentStreams())),\n                        Http2Error.REFUSED_STREAM, streamId);\n            }\n            reduceOverheadCount();\n// bug_end\n             return stream;\n         } else {\n             if (log.isDebugEnabled()) {\n                 log.debug(sm.getString(\"upgradeHandler.noNewStreams\",\n                         connectionId, Integer.toString(streamId)));\n             }\n             reduceOverheadCount();\n             return HEADER_SINK;\n         }\n     }\n \n", "target": "// fix_start\n// fix_end\n", "cwe": "NVD-CWE-noinfo", "cwe_name": "", "idx": 99693}
{"source": " @Override\n     public Element handle(Element request, Map<String, Object> context) throws ServiceException {\n         ZimbraSoapContext zsc = getZimbraSoapContext(context);\n         Account account = getRequestedAccount(getZimbraSoapContext(context));\n \n         if (!canAccessAccount(zsc, account))\n             throw ServiceException.PERM_DENIED(\"can not access account\");\n \n         String name = request.getAttribute(AccountConstants.E_NAME);\n         String typeStr = request.getAttribute(AccountConstants.A_TYPE, \"account\");\n         GalSearchType type = GalSearchType.fromString(typeStr);\n \n         boolean needCanExpand = request.getAttributeBool(AccountConstants.A_NEED_EXP, false);\n \n         String galAcctId = request.getAttribute(AccountConstants.A_GAL_ACCOUNT_ID, null);\n \n         GalSearchParams params = new GalSearchParams(account, zsc);\n         params.setType(type);\n         params.setRequest(request);\n         params.setQuery(name);\n         params.setLimit(account.getContactAutoCompleteMaxResults());\n         params.setNeedCanExpand(needCanExpand);\n         params.setResponseName(AccountConstants.AUTO_COMPLETE_GAL_RESPONSE);\n// bug_start\n        if (galAcctId != null)\n            params.setGalSyncAccount(Provisioning.getInstance().getAccountById(galAcctId));\n// bug_end\n         GalSearchControl gal = new GalSearchControl(params);\n         gal.autocomplete();\n         return params.getResultCallback().getResponse();\n     }\n \n", "target": "// fix_start\n        if (galAcctId != null) {\n            Account galAccount = Provisioning.getInstance().getAccountById(galAcctId);\n            if (galAccount != null && (!account.getDomainId().equals(galAccount.getDomainId()))) {\n                throw ServiceException\n                    .PERM_DENIED(\"can not access galsync account of different domain\");\n            }\n            params.setGalSyncAccount(galAccount);\n        }\n// fix_end\n", "cwe": "CWE-862", "cwe_name": "Missing Authorization", "idx": 85457}
{"source": " private void sendEntityMessage(Object message) throws Exception {\n \n         MockEndpoint endpoint = getMockEndpoint(\"mock:result\");\n         endpoint.reset();\n         endpoint.expectedMessageCount(1);\n \n         template.sendBody(\"direct:start1\", message);\n \n         assertMockEndpointsSatisfied();\n \n         List<Exchange> list = endpoint.getReceivedExchanges();\n         Exchange exchange = list.get(0);\n         String xml = exchange.getIn().getBody(String.class);\n         assertTrue(\"Get a wrong transformed message\", xml.indexOf(\"<transformed subject=\\\"\\\">\") > 0);\n \n// bug_start\n\n// bug_end\n \n         try {\n             template.sendBody(\"direct:start2\", message);\n// bug_start\n            fail(\"Expect an exception here\");\n// bug_end\n         } catch (Exception ex) {\n             assertTrue(\"Get a wrong exception\", ex instanceof CamelExecutionException);\n             assertTrue(\"Get a wrong exception cause\", ex.getCause() instanceof TransformerException);\n         }\n// bug_start\n\n// bug_end\n     }\n \n", "target": "// fix_start\n        endpoint.reset();\n        endpoint.expectedMessageCount(1);\n// fix_end\n// fix_start\n            list = endpoint.getReceivedExchanges();\n            exchange = list.get(0);\n            xml = exchange.getIn().getBody(String.class);\n            assertTrue(\"Get a wrong transformed message\", xml.indexOf(\"<transformed subject=\\\"\\\">\") > 0);\n// fix_end\n// fix_start\n// fix_end\n", "cwe": "NVD-CWE-Other", "cwe_name": "Other", "idx": 110303}
{"source": " @RequestMapping(\"/oauth/token/revoke/client/{clientId}\")\n     public ResponseEntity<Void> revokeTokensForClient(@PathVariable String clientId) {\n         logger.debug(\"Revoking tokens for client: \" + clientId);\n// bug_start\n// bug_end\n         BaseClientDetails client = (BaseClientDetails)clientDetailsService.loadClientByClientId(clientId);\n         client.addAdditionalInformation(ClientConstants.TOKEN_SALT,generator.generate());\n         clientDetailsService.updateClientDetails(client);\n         logger.debug(\"Tokens revoked for client: \" + clientId);\n// bug_start\n// bug_end\n         return new ResponseEntity<>(OK);\n     }\n \n", "target": "// fix_start\n        String zoneId = IdentityZoneHolder.get().getId();\n// fix_end\n// fix_start\n        tokenProvisioning.deleteByClient(clientId, zoneId);\n// fix_end\n", "cwe": "NVD-CWE-noinfo", "cwe_name": "", "idx": 102685}
{"source": "// bug_start\nprotected Document getDocument(URL url) throws StageException {\n// bug_end\n \t\ttry {\n \t\t\tHttpURLConnection conn = (HttpURLConnection) url.openConnection();\n \t\t\taddAuthHeader(conn);\n \t\t\tconn.setRequestProperty(\"Accept\", \"application/xml\");\n \t\t\tint status = conn.getResponseCode();\n \t\t\tif (status == HttpURLConnection.HTTP_OK) {\n// bug_start\n\t\t\t\tDocumentBuilder builder = DocumentBuilderFactory.newInstance().newDocumentBuilder();\n\t\t\t\tDocument doc = builder.parse(conn.getInputStream());\n\t\t\t\tconn.disconnect();\n\t\t\t\treturn doc;\n// bug_end\n \t\t\t}\n \t\t\telse {\n \t\t\t\tdrainOutput(conn);\n \t\t\t\tif (status == HttpURLConnection.HTTP_UNAUTHORIZED) {\n \t\t\t\t\tthrow new IOException(\"Incorrect username / password supplied.\");\n \t\t\t\t}\n \t\t\t\telse if (status == HttpURLConnection.HTTP_NOT_FOUND) {\n \t\t\t\t\tthrow new IOException(\"Document not found - is this a Nexus server?\");\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\tthrow new IOException(\"Server returned error code \" + status + \" for \" + url.toString());\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \t\tcatch (IOException ex) {\n \t\t\tthrow createStageExceptionForIOException(nexusURL, ex);\n \t\t}\n// bug_start\n\t\tcatch (ParserConfigurationException ex) {\n\t\t\tthrow new StageException(ex);\n\t\t}\n// bug_end\n \t\tcatch (SAXException ex) {\n \t\t\tthrow new StageException(ex);\n \t\t}\n \n \t}\n \n", "target": "// fix_start\n@SuppressRestrictedWarnings(XMLUtils.class)\n\tprotected Document getDocument(URL url) throws StageException {\n// fix_end\n// fix_start\n\t\t\t\ttry (InputStream is = conn.getInputStream(); InputStreamReader isr = new InputStreamReader(is, StandardCharsets.UTF_8)) {\n\t\t\t\t\tDocument doc = XMLUtils.parse(isr);\n\t\t\t\t\tconn.disconnect();\n\t\t\t\t\treturn doc;\n\t\t\t\t}\n// fix_end\n// fix_start\n// fix_end\n", "cwe": "CWE-611", "cwe_name": "Improper Restriction of XML External Entity Reference ('XXE')", "idx": 69554}
{"source": " public static void unzipFilesToPath(String jarPath, String destinationDir) throws IOException {\n// bug_start\n// bug_end\n         File file = new File(jarPath);\n         try (JarFile jar = new JarFile(file)) {\n \n \n             for (Enumeration<JarEntry> enums = jar.entries(); enums.hasMoreElements(); ) {\n                 JarEntry entry = enums.nextElement();\n \n                 String fileName = destinationDir + File.separator + entry.getName();\n                 File f = new File(fileName);\n \n// bug_start\n                if (!f.getCanonicalPath().startsWith(destinationDir)) {\n// bug_end\n                     System.out.println(\"Zip Slip exploit detected. Skipping entry \" + entry.getName());\n                     continue;\n                 }\n \n                 File parent = f.getParentFile();\n                 if (!parent.exists()) {\n                     parent.mkdirs();\n                 }\n \n                 if (!fileName.endsWith(\"/\")) {\n                     try (InputStream is = jar.getInputStream(entry);\n                          FileOutputStream fos = new FileOutputStream(f)) {\n                         while (is.available() > 0) {\n                             fos.write(is.read());\n                         }\n                     }\n                 }\n             }\n         }\n     }\n \n", "target": "// fix_start\n        String canonicalDestDir = new File(destinationDir).getCanonicalPath();\n        if (!canonicalDestDir.endsWith(File.separator)) {\n            canonicalDestDir += File.separator;\n        }\n\n// fix_end\n// fix_start\n                if (!f.getCanonicalPath().startsWith(canonicalDestDir)) {\n// fix_end\n", "cwe": "CWE-22", "cwe_name": "Path Traversal", "idx": 27025}
{"source": " protected Object getHandlerInternal(HttpServletRequest request) throws Exception {\n         Object object = super.getHandlerInternal(request);\n \n         if (object instanceof String) {\n             String handlerName = (String) object;\n             object = getApplicationContext().getBean(handlerName);\n         }\n         if (object instanceof HandlerExecutionChain) {\n             HandlerExecutionChain handlerExecutionChain = (HandlerExecutionChain) object;\n             object = handlerExecutionChain.getHandler();\n         }\n \n         if (object != null) {\n// bug_start\n// bug_end\n             ServletRequestDataBinder binder = new ServletRequestDataBinder(object, \"request\");\n             try {\n                 binder.bind(request);\n                 binder.setIgnoreUnknownFields(true);\n                 if (LOG.isDebugEnabled()) {\n                     LOG.debug(\"Bound POJO is now: \" + object);\n                 }\n             }\n             catch (Exception e) {\n                 LOG.warn(\"Caught: \" + e, e);\n                 throw e;\n             }\n         }\n// bug_start\n// bug_end\n         return object;\n     }\n \n", "target": "// fix_start\n        \tif (object instanceof DestinationFacade) {\n        \t\tif (!Arrays.asList(((DestinationFacade)object).getSupportedHttpMethods()).contains(request.getMethod())) {\n        \t\t\tthrow new UnsupportedOperationException(\"Unsupported method \" + request.getMethod() + \" for path \" + request.getRequestURI());\n        \t\t}\n        \t\tif (!request.getSession().getAttribute(\"secret\").equals(request.getParameter(\"secret\"))) {\n        \t\t\tthrow new UnsupportedOperationException(\"Possible CSRF attack\");\n        \t\t}\n        \t}\n\n\n// fix_end\n// fix_start\n\n// fix_end\n", "cwe": "CWE-352", "cwe_name": "Cross-Site Request Forgery (CSRF)", "idx": 43807}
{"source": " @Bean\n     public Server rsServer() {\n         JAXRSServerFactoryBean endpoint = new JAXRSServerFactoryBean();\n         endpoint.setBus(bus);\n         endpoint.setServiceBeans(Arrays.<Object>asList(new HelloServiceImpl1(), new HelloServiceImpl2()));\n// bug_start\n        endpoint.setAddress(\"/\");\n// bug_end\n         endpoint.setFeatures(Arrays.asList(new Swagger2Feature()));\n         return endpoint.create();\n     }\n \n", "target": "// fix_start\n        endpoint.setAddress(\"/a\");\n// fix_end\n", "cwe": "CWE-79", "cwe_name": "Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')", "idx": 79118}
{"source": " private JMXConnectorServer createServer(String serverName,\n             String bindAddress, int theRmiRegistryPort, int theRmiServerPort,\n             Map<String,Object> theEnv,\n             RMIClientSocketFactory registryCsf, RMIServerSocketFactory registrySsf,\n             RMIClientSocketFactory serverCsf, RMIServerSocketFactory serverSsf) {\n// bug_start\n\n        Registry registry;\n        try {\n            registry = LocateRegistry.createRegistry(\n                    theRmiRegistryPort, registryCsf, registrySsf);\n        } catch (RemoteException e) {\n            log.error(sm.getString(\n                    \"jmxRemoteLifecycleListener.createRegistryFailed\",\n                    serverName, Integer.toString(theRmiRegistryPort)), e);\n            return null;\n        }\n// bug_end\n \n         if (bindAddress == null) {\n             bindAddress = \"localhost\";\n         }\n \n         String url = \"service:jmx:rmi://\" + bindAddress;\n         JMXServiceURL serviceUrl;\n         try {\n             serviceUrl = new JMXServiceURL(url);\n         } catch (MalformedURLException e) {\n             log.error(sm.getString(\"jmxRemoteLifecycleListener.invalidURL\", serverName, url), e);\n             return null;\n         }\n \n         RMIConnectorServer cs = null;\n         try {\n             RMIJRMPServerImpl server = new RMIJRMPServerImpl(\n                     rmiServerPortPlatform, serverCsf, serverSsf, theEnv);\n             cs = new RMIConnectorServer(serviceUrl, theEnv, server,\n                     ManagementFactory.getPlatformMBeanServer());\n             cs.start();\n// bug_start\n            registry.bind(\"jmxrmi\", server.toStub());\n// bug_end\n             log.info(sm.getString(\"jmxRemoteLifecycleListener.start\",\n                     Integer.toString(theRmiRegistryPort),\n                     Integer.toString(theRmiServerPort), serverName));\n// bug_start\n        } catch (IOException | AlreadyBoundException e) {\n// bug_end\n             log.error(sm.getString(\n                     \"jmxRemoteLifecycleListener.createServerFailed\",\n                     serverName), e);\n         }\n         return cs;\n     }\n \n", "target": "// fix_start\n// fix_end\n// fix_start\n            Remote jmxServer = server.toStub();\n            try {\n                new JmxRegistry(theRmiRegistryPort, registryCsf, registrySsf, \"jmxrmi\", jmxServer);\n            } catch (RemoteException e) {\n                log.error(sm.getString(\n                        \"jmxRemoteLifecycleListener.createRegistryFailed\",\n                        serverName, Integer.toString(theRmiRegistryPort)), e);\n                return null;\n            }\n// fix_end\n// fix_start\n        } catch (IOException e) {\n// fix_end\n", "cwe": "NVD-CWE-noinfo", "cwe_name": "", "idx": 99746}
{"source": " @RequestMapping(\"/oauth/token/revoke/client/{clientId}\")\n     public ResponseEntity<Void> revokeTokensForClient(@PathVariable String clientId) {\n         logger.debug(\"Revoking tokens for client: \" + clientId);\n// bug_start\n        BaseClientDetails client = (BaseClientDetails)clientDetailsService.loadClientByClientId(clientId, IdentityZoneHolder.get().getId());\n// bug_end\n         client.addAdditionalInformation(ClientConstants.TOKEN_SALT,generator.generate());\n// bug_start\n        clientDetailsService.updateClientDetails(client, IdentityZoneHolder.get().getId());\n// bug_end\n         logger.debug(\"Tokens revoked for client: \" + clientId);\n// bug_start\n// bug_end\n         return new ResponseEntity<>(OK);\n     }\n \n", "target": "// fix_start\n        String zoneId = IdentityZoneHolder.get().getId();\n        BaseClientDetails client = (BaseClientDetails)clientDetailsService.loadClientByClientId(clientId, zoneId);\n// fix_end\n// fix_start\n        clientDetailsService.updateClientDetails(client, zoneId);\n// fix_end\n// fix_start\n        ((SystemDeletable)tokenProvisioning).deleteByClient(clientId, zoneId);\n// fix_end\n", "cwe": "NVD-CWE-noinfo", "cwe_name": "", "idx": 102711}
{"source": " @Override\n     public boolean checkObjectExecutePermission(Class clazz, String methodName)\n     {\n// bug_start\n        if (Class.class.isAssignableFrom(clazz) && methodName != null && this.secureClassMethods.contains(methodName)) {\n            return true;\n        } else {\n            return super.checkObjectExecutePermission(clazz, methodName);\n// bug_end\n         }\n// bug_start\n// bug_end\n     }\n \n", "target": "// fix_start\n        Boolean result = null;\n        if (methodName != null) {\n            for (Map.Entry<Class, Set<String>> classSetEntry : this.whitelistedMethods.entrySet()) {\n                if (classSetEntry.getKey().isAssignableFrom(clazz)) {\n                    result = classSetEntry.getValue().contains(methodName.toLowerCase());\n                    break;\n                }\n            }\n// fix_end\n// fix_start\n\n        if (result == null) {\n            result = super.checkObjectExecutePermission(clazz, methodName);\n        }\n        return result;\n// fix_end\n", "cwe": "CWE-668", "cwe_name": "Exposure of Resource to Wrong Sphere", "idx": 72464}
{"source": " private byte[] decryptBlock(\n         byte[] in_enc,\n         int inOff,\n         int inLen)\n         throws InvalidCipherTextException\n     {\n// bug_start\n        byte[] M = null, K = null, K1 = null, K2 = null;\n        int len;\n// bug_end\n \n         if (inLen < V.length + mac.getMacSize())\n         {\n             throw new InvalidCipherTextException(\"Length of input must be greater than the MAC and V combined\");\n         }\n \n         if (cipher == null)\n         {\n             K1 = new byte[inLen - V.length - mac.getMacSize()];\n             K2 = new byte[param.getMacKeySize() / 8];\n             K = new byte[K1.length + K2.length];\n \n             kdf.generateBytes(K, 0, K.length);\n \n             if (V.length != 0)\n             {\n                 System.arraycopy(K, 0, K2, 0, K2.length);\n                 System.arraycopy(K, K2.length, K1, 0, K1.length);\n             }\n             else\n             {\n                 System.arraycopy(K, 0, K1, 0, K1.length);\n                 System.arraycopy(K, K1.length, K2, 0, K2.length);\n             }\n \n             M = new byte[K1.length];\n \n             for (int i = 0; i != K1.length; i++)\n             {\n                 M[i] = (byte)(in_enc[inOff + V.length + i] ^ K1[i]);\n             }\n// bug_start\n\n            len = K1.length;\n// bug_end\n         }\n         else\n         {\n             K1 = new byte[((IESWithCipherParameters)param).getCipherKeySize() / 8];\n             K2 = new byte[param.getMacKeySize() / 8];\n             K = new byte[K1.length + K2.length];\n \n             kdf.generateBytes(K, 0, K.length);\n             System.arraycopy(K, 0, K1, 0, K1.length);\n             System.arraycopy(K, K1.length, K2, 0, K2.length);\n \n             if (IV != null)\n             {\n                 cipher.init(false, new ParametersWithIV(new KeyParameter(K1), IV));\n             }\n             else\n             {\n                 cipher.init(false, new KeyParameter(K1));\n             }\n \n             M = new byte[cipher.getOutputSize(inLen - V.length - mac.getMacSize())];\n// bug_start\n// bug_end\n             len = cipher.processBytes(in_enc, inOff + V.length, inLen - V.length - mac.getMacSize(), M, 0);\n// bug_start\n            len += cipher.doFinal(M, len);\n// bug_end\n         }\n// bug_start\n\n// bug_end\n \n         byte[] P2 = param.getEncodingV();\n         byte[] L2 = null;\n         if (V.length != 0)\n         {\n             L2 = getLengthTag(P2);\n         }\n \n         int end = inOff + inLen;\n         byte[] T1 = Arrays.copyOfRange(in_enc, end - mac.getMacSize(), end);\n \n         byte[] T2 = new byte[T1.length];\n         mac.init(new KeyParameter(K2));\n         mac.update(in_enc, inOff + V.length, inLen - V.length - T2.length);\n \n         if (P2 != null)\n         {\n             mac.update(P2, 0, P2.length);\n         }\n         if (V.length != 0)\n         {\n             mac.update(L2, 0, L2.length);\n         }\n         mac.doFinal(T2, 0);\n \n         if (!Arrays.constantTimeAreEqual(T1, T2))\n         {\n// bug_start\n            throw new InvalidCipherTextException(\"Invalid MAC.\");\n// bug_end\n         }\n \n// bug_start\n        return Arrays.copyOfRange(M, 0, len);\n// bug_end\n     }\n \n", "target": "// fix_start\n        byte[] M, K, K1, K2;\n        int len = 0;\n// fix_end\n// fix_start\n// fix_end\n// fix_start\n\n// fix_end\n// fix_start\n// fix_end\n// fix_start\n// fix_end\n// fix_start\n            throw new InvalidCipherTextException(\"invalid MAC\");\n// fix_end\n// fix_start\n        if (cipher == null)\n        {\n            return M;\n        }\n        else\n        {\n            len += cipher.doFinal(M, len);\n\n            return Arrays.copyOfRange(M, 0, len);\n        }\n// fix_end\n", "cwe": "CWE-361", "cwe_name": "Time and State", "idx": 48126}
{"source": " protected BigInteger chooseRandomPrime(int bitlength, BigInteger e, BigInteger sqrdBound)\n     {\n// bug_start\n        int iterations = getNumberOfIterations(bitlength, param.getCertainty());\n\n// bug_end\n         for (int i = 0; i != 5 * bitlength; i++)\n         {\n             BigInteger p = new BigInteger(bitlength, 1, param.getRandom());\n \n             if (p.mod(e).equals(ONE))\n             {\n                 continue;\n             }\n \n             if (p.multiply(p).compareTo(sqrdBound) < 0)\n             {\n                 continue;\n             }\n \n// bug_start\n            if (!isProbablePrime(p, iterations))\n// bug_end\n             {\n                 continue;\n             }\n \n             if (!e.gcd(p.subtract(ONE)).equals(ONE))\n             {\n                 continue;\n             }\n \n             return p;\n         }\n \n         throw new IllegalStateException(\"unable to generate prime number for RSA key\");\n     }\n \n", "target": "// fix_start\n// fix_end\n// fix_start\n            if (!isProbablePrime(p))\n// fix_end\n", "cwe": "CWE-327", "cwe_name": "Use of a Broken or Risky Cryptographic Algorithm", "idx": 42145}
{"source": " public void sendFile(String url, Object body, String fileName) {\n// bug_start\n        template.sendBodyAndHeader(url, body, Exchange.FILE_NAME, fileName);\n// bug_end\n     }\n \n", "target": "// fix_start\n        template.sendBodyAndHeader(url, body, Exchange.FILE_NAME, simple(fileName));\n// fix_end\n", "cwe": "CWE-94", "cwe_name": "Improper Control of Generation of Code ('Code Injection')", "idx": 94836}
{"source": " protected SchemaFactory createSchemaFactory() {\n         SchemaFactory factory = SchemaFactory.newInstance(schemaLanguage);\n         if (getResourceResolver() != null) {\n             factory.setResourceResolver(getResourceResolver());\n         }\n// bug_start\n        if (!Boolean.parseBoolean(camelContext.getProperty(ACCESS_EXTERNAL_DTD))) {\n// bug_end\n             try {\n                 factory.setProperty(XMLConstants.ACCESS_EXTERNAL_DTD, \"\");\n             } catch (SAXException e) {\n                 LOG.error(e.getMessage(), e);\n                 throw new IllegalStateException(e);\n             }\n         }\n         return factory;\n     }\n \n", "target": "// fix_start\n        if (camelContext != null && !Boolean.parseBoolean(camelContext.getProperty(ACCESS_EXTERNAL_DTD))) {\n// fix_end\n", "cwe": "CWE-611", "cwe_name": "Improper Restriction of XML External Entity Reference ('XXE')", "idx": 66864}
{"source": " @Override\n \tprotected void onInitialize()\n \t{\n \t\tsuper.onInitialize();\n \n// bug_start\n\t\tthis.textarea = new TextArea<String>(\"textarea\", this.getModel());\n// bug_end\n \t\tthis.textarea.setEscapeModelStrings(false);\n// bug_start\n\t\tthis.add(this.textarea.setOutputMarkupId(true));\n// bug_end\n \n \t\tthis.add(JQueryWidget.newWidgetBehavior(this, this.container));\n \t}\n \n", "target": "// fix_start\n\t\tthis.textarea = new HiddenField<String>(\"textarea\", this.getModel());\n\t\tthis.textarea.setOutputMarkupId(true);\n// fix_end\n// fix_start\n\t\tthis.add(this.textarea);\n// fix_end\n", "cwe": "CWE-79", "cwe_name": "Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')", "idx": 81626}
{"source": "// bug_start\npublic String getIconFileName() {\n\t\treturn \"plugin/jenkins-multijob-plugin/tool32.png\";\n\t}\n// bug_end\n \n", "target": "// fix_start\npublic static boolean isCsrfTokenValid(VaadinSession session,\n            String requestToken) {\n// fix_end\n// fix_start\n        if (session.getService().getDeploymentConfiguration()\n                .isXsrfProtectionEnabled()) {\n            String sessionToken = session.getCsrfToken();\n\n            if (sessionToken == null || !MessageDigest.isEqual(\n                    sessionToken.getBytes(StandardCharsets.UTF_8),\n                    requestToken.getBytes(StandardCharsets.UTF_8))) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n// fix_end\n", "cwe": "CWE-203", "cwe_name": "Information Exposure Through Discrepancy", "idx": 20424}
{"source": "// bug_start\n@Override\n    public SearchIndexBuilder makeSearchIndex() {\n        return super.makeSearchIndex()\n            .add(\"configure\", \"config\",\"configure\")\n            .add(\"manage\")\n            .add(\"log\")\n            .add(new CollectionSearchIndex<TopLevelItem>() {\n                protected SearchItem get(String key) { return getItemByFullName(key, TopLevelItem.class); }\n                protected Collection<TopLevelItem> all() { return getAllItems(TopLevelItem.class); }\n            })\n            .add(getPrimaryView().makeSearchIndex())\n            .add(new CollectionSearchIndex() {\n                protected Computer get(String key) { return getComputer(key); }\n                protected Collection<Computer> all() { return computers.values(); }\n            })\n            .add(new CollectionSearchIndex() {\n                protected User get(String key) { return User.get(key,false); }\n                protected Collection<User> all() { return User.getAll(); }\n            })\n            .add(new CollectionSearchIndex() {\n                protected View get(String key) { return getView(key); }\n                protected Collection<View> all() { return viewGroupMixIn.getViews(); }\n            });\n    }\n// bug_end\n \n", "target": "// fix_start\npublic String getIconFileName() {\n        return Jenkins.getInstance().hasPermission(Jenkins.ADMINISTER) ? \"plugin/jenkins-multijob-plugin/tool32.png\" : null;\n\t}\n// fix_end\n", "cwe": "CWE-862", "cwe_name": "Missing Authorization", "idx": 85141}
{"source": "// bug_start\n@Override\n    public SearchIndexBuilder makeSearchIndex() {\n        return super.makeSearchIndex()\n            .add(\"configure\", \"config\",\"configure\")\n            .add(\"manage\")\n            .add(\"log\")\n            .add(new CollectionSearchIndex<TopLevelItem>() {\n                protected SearchItem get(String key) { return getItemByFullName(key, TopLevelItem.class); }\n                protected Collection<TopLevelItem> all() { return getAllItems(TopLevelItem.class); }\n            })\n            .add(getPrimaryView().makeSearchIndex())\n            .add(new CollectionSearchIndex() {\n                protected Computer get(String key) { return getComputer(key); }\n                protected Collection<Computer> all() { return computers.values(); }\n            })\n            .add(new CollectionSearchIndex() {\n                protected User get(String key) { return User.get(key,false); }\n                protected Collection<User> all() { return User.getAll(); }\n            })\n            .add(new CollectionSearchIndex() {\n                protected View get(String key) { return getView(key); }\n                protected Collection<View> all() { return views; }\n            });\n    }\n// bug_end\n \n", "target": "// fix_start\nprivate RootBeanDefinition registerMessageBroker(Element brokerElement,\n\t\t\tRuntimeBeanReference inChannel, RuntimeBeanReference outChannel, RuntimeBeanReference brokerChannel,\n\t\t\tObject userDestHandler, RuntimeBeanReference brokerTemplate,\n\t\t\tRuntimeBeanReference userRegistry, ParserContext context, Object source) {\n// fix_end\n// fix_start\n\t\tElement simpleBrokerElem = DomUtils.getChildElementByTagName(brokerElement, \"simple-broker\");\n\t\tElement brokerRelayElem = DomUtils.getChildElementByTagName(brokerElement, \"stomp-broker-relay\");\n\n\t\tConstructorArgumentValues cavs = new ConstructorArgumentValues();\n\t\tcavs.addIndexedArgumentValue(0, inChannel);\n\t\tcavs.addIndexedArgumentValue(1, outChannel);\n\t\tcavs.addIndexedArgumentValue(2, brokerChannel);\n\n\t\tRootBeanDefinition brokerDef;\n\t\tif (simpleBrokerElem != null) {\n\t\t\tString prefix = simpleBrokerElem.getAttribute(\"prefix\");\n\t\t\tcavs.addIndexedArgumentValue(3, Arrays.asList(StringUtils.tokenizeToStringArray(prefix, \",\")));\n\t\t\tbrokerDef = new RootBeanDefinition(SimpleBrokerMessageHandler.class, cavs, null);\n\t\t\tif (brokerElement.hasAttribute(\"path-matcher\")) {\n\t\t\t\tString pathMatcherRef = brokerElement.getAttribute(\"path-matcher\");\n\t\t\t\tbrokerDef.getPropertyValues().add(\"pathMatcher\", new RuntimeBeanReference(pathMatcherRef));\n\t\t\t}\n\t\t\tif (simpleBrokerElem.hasAttribute(\"scheduler\")) {\n\t\t\t\tString scheduler = simpleBrokerElem.getAttribute(\"scheduler\");\n\t\t\t\tbrokerDef.getPropertyValues().add(\"taskScheduler\", new RuntimeBeanReference(scheduler));\n\t\t\t}\n\t\t\tif (simpleBrokerElem.hasAttribute(\"heartbeat\")) {\n\t\t\t\tString heartbeatValue = simpleBrokerElem.getAttribute(\"heartbeat\");\n\t\t\t\tbrokerDef.getPropertyValues().add(\"heartbeatValue\", heartbeatValue);\n\t\t\t}\n\t\t}\n\t\telse if (brokerRelayElem != null) {\n\t\t\tString prefix = brokerRelayElem.getAttribute(\"prefix\");\n\t\t\tcavs.addIndexedArgumentValue(3, Arrays.asList(StringUtils.tokenizeToStringArray(prefix, \",\")));\n\n\t\t\tMutablePropertyValues values = new MutablePropertyValues();\n\t\t\tif (brokerRelayElem.hasAttribute(\"relay-host\")) {\n\t\t\t\tvalues.add(\"relayHost\", brokerRelayElem.getAttribute(\"relay-host\"));\n\t\t\t}\n\t\t\tif (brokerRelayElem.hasAttribute(\"relay-port\")) {\n\t\t\t\tvalues.add(\"relayPort\", brokerRelayElem.getAttribute(\"relay-port\"));\n\t\t\t}\n\t\t\tif (brokerRelayElem.hasAttribute(\"client-login\")) {\n\t\t\t\tvalues.add(\"clientLogin\", brokerRelayElem.getAttribute(\"client-login\"));\n\t\t\t}\n\t\t\tif (brokerRelayElem.hasAttribute(\"client-passcode\")) {\n\t\t\t\tvalues.add(\"clientPasscode\", brokerRelayElem.getAttribute(\"client-passcode\"));\n\t\t\t}\n\t\t\tif (brokerRelayElem.hasAttribute(\"system-login\")) {\n\t\t\t\tvalues.add(\"systemLogin\", brokerRelayElem.getAttribute(\"system-login\"));\n\t\t\t}\n\t\t\tif (brokerRelayElem.hasAttribute(\"system-passcode\")) {\n\t\t\t\tvalues.add(\"systemPasscode\", brokerRelayElem.getAttribute(\"system-passcode\"));\n\t\t\t}\n\t\t\tif (brokerRelayElem.hasAttribute(\"heartbeat-send-interval\")) {\n\t\t\t\tvalues.add(\"systemHeartbeatSendInterval\", brokerRelayElem.getAttribute(\"heartbeat-send-interval\"));\n\t\t\t}\n\t\t\tif (brokerRelayElem.hasAttribute(\"heartbeat-receive-interval\")) {\n\t\t\t\tvalues.add(\"systemHeartbeatReceiveInterval\", brokerRelayElem.getAttribute(\"heartbeat-receive-interval\"));\n\t\t\t}\n\t\t\tif (brokerRelayElem.hasAttribute(\"virtual-host\")) {\n\t\t\t\tvalues.add(\"virtualHost\", brokerRelayElem.getAttribute(\"virtual-host\"));\n\t\t\t}\n\t\t\tManagedMap<String, Object> map = new ManagedMap<String, Object>();\n\t\t\tmap.setSource(source);\n\t\t\tif (brokerRelayElem.hasAttribute(\"user-destination-broadcast\")) {\n\t\t\t\tString destination = brokerRelayElem.getAttribute(\"user-destination-broadcast\");\n\t\t\t\tmap.put(destination, userDestHandler);\n\t\t\t}\n\t\t\tif (brokerRelayElem.hasAttribute(\"user-registry-broadcast\")) {\n\t\t\t\tString destination = brokerRelayElem.getAttribute(\"user-registry-broadcast\");\n\t\t\t\tmap.put(destination, registerUserRegistryMessageHandler(userRegistry,\n\t\t\t\t\t\tbrokerTemplate, destination, context, source));\n\t\t\t}\n\t\t\tif (!map.isEmpty()) {\n\t\t\t\tvalues.add(\"systemSubscriptions\", map);\n\t\t\t}\n\t\t\tClass<?> handlerType = StompBrokerRelayMessageHandler.class;\n\t\t\tbrokerDef = new RootBeanDefinition(handlerType, cavs, values);\n\t\t}\n\t\telse {\n\t\t\tthrow new IllegalStateException(\"Neither <simple-broker> nor <stomp-broker-relay> elements found.\");\n\t\t}\n\t\tregisterBeanDef(brokerDef, context, source);\n\t\treturn brokerDef;\n\t}\n\n// fix_end\n", "cwe": "CWE-200", "cwe_name": "Exposure of Sensitive Information to an Unauthorized Actor", "idx": 13364}
{"source": "// bug_start\n@Override\n    protected void configure(HttpSecurity http) throws Exception {\n        http\n                .rememberMe().disable()\n                .authorizeRequests()\n                    .anyRequest().fullyAuthenticated()\n                    .and()\n                .sessionManagement()\n                    .sessionCreationPolicy(SessionCreationPolicy.STATELESS);\n// bug_end\n \n// bug_start\n        http.addFilterBefore(x509FilterBean(), AnonymousAuthenticationFilter.class);\n// bug_end\n \n// bug_start\n        http.addFilterBefore(jwtFilterBean(), AnonymousAuthenticationFilter.class);\n// bug_end\n \n// bug_start\n        http.addFilterBefore(otpFilterBean(), AnonymousAuthenticationFilter.class);\n// bug_end\n \n// bug_start\n        http.addFilterBefore(knoxFilterBean(), AnonymousAuthenticationFilter.class);\n// bug_end\n \n// bug_start\n        http.anonymous().authenticationFilter(anonymousFilterBean());\n    }\n\n// bug_end\n", "target": "// fix_start\nprivate RootBeanDefinition registerMessageBroker(Element brokerElement,\n\t\t\tRuntimeBeanReference inChannel, RuntimeBeanReference outChannel, RuntimeBeanReference brokerChannel,\n\t\t\tObject userDestHandler, RuntimeBeanReference brokerTemplate,\n\t\t\tRuntimeBeanReference userRegistry, ParserContext context, Object source) {\n// fix_end\n// fix_start\n\t\tElement simpleBrokerElem = DomUtils.getChildElementByTagName(brokerElement, \"simple-broker\");\n\t\tElement brokerRelayElem = DomUtils.getChildElementByTagName(brokerElement, \"stomp-broker-relay\");\n// fix_end\n// fix_start\n\t\tConstructorArgumentValues cavs = new ConstructorArgumentValues();\n\t\tcavs.addIndexedArgumentValue(0, inChannel);\n\t\tcavs.addIndexedArgumentValue(1, outChannel);\n\t\tcavs.addIndexedArgumentValue(2, brokerChannel);\n// fix_end\n// fix_start\n\t\tRootBeanDefinition brokerDef;\n\t\tif (simpleBrokerElem != null) {\n\t\t\tString prefix = simpleBrokerElem.getAttribute(\"prefix\");\n\t\t\tcavs.addIndexedArgumentValue(3, Arrays.asList(StringUtils.tokenizeToStringArray(prefix, \",\")));\n\t\t\tbrokerDef = new RootBeanDefinition(SimpleBrokerMessageHandler.class, cavs, null);\n\t\t\tif (brokerElement.hasAttribute(\"path-matcher\")) {\n\t\t\t\tString pathMatcherRef = brokerElement.getAttribute(\"path-matcher\");\n\t\t\t\tbrokerDef.getPropertyValues().add(\"pathMatcher\", new RuntimeBeanReference(pathMatcherRef));\n\t\t\t}\n\t\t\tif (simpleBrokerElem.hasAttribute(\"scheduler\")) {\n\t\t\t\tString scheduler = simpleBrokerElem.getAttribute(\"scheduler\");\n\t\t\t\tbrokerDef.getPropertyValues().add(\"taskScheduler\", new RuntimeBeanReference(scheduler));\n\t\t\t}\n\t\t\tif (simpleBrokerElem.hasAttribute(\"heartbeat\")) {\n\t\t\t\tString heartbeatValue = simpleBrokerElem.getAttribute(\"heartbeat\");\n\t\t\t\tbrokerDef.getPropertyValues().add(\"heartbeatValue\", heartbeatValue);\n\t\t\t}\n\t\t\tif (simpleBrokerElem.hasAttribute(\"selector-header\")) {\n\t\t\t\tString headerName = simpleBrokerElem.getAttribute(\"selector-header\");\n\t\t\t\tbrokerDef.getPropertyValues().add(\"selectorHeaderName\", headerName);\n\t\t\t}\n\t\t}\n\t\telse if (brokerRelayElem != null) {\n\t\t\tString prefix = brokerRelayElem.getAttribute(\"prefix\");\n\t\t\tcavs.addIndexedArgumentValue(3, Arrays.asList(StringUtils.tokenizeToStringArray(prefix, \",\")));\n// fix_end\n// fix_start\n\t\t\tMutablePropertyValues values = new MutablePropertyValues();\n\t\t\tif (brokerRelayElem.hasAttribute(\"relay-host\")) {\n\t\t\t\tvalues.add(\"relayHost\", brokerRelayElem.getAttribute(\"relay-host\"));\n\t\t\t}\n\t\t\tif (brokerRelayElem.hasAttribute(\"relay-port\")) {\n\t\t\t\tvalues.add(\"relayPort\", brokerRelayElem.getAttribute(\"relay-port\"));\n\t\t\t}\n\t\t\tif (brokerRelayElem.hasAttribute(\"client-login\")) {\n\t\t\t\tvalues.add(\"clientLogin\", brokerRelayElem.getAttribute(\"client-login\"));\n\t\t\t}\n\t\t\tif (brokerRelayElem.hasAttribute(\"client-passcode\")) {\n\t\t\t\tvalues.add(\"clientPasscode\", brokerRelayElem.getAttribute(\"client-passcode\"));\n\t\t\t}\n\t\t\tif (brokerRelayElem.hasAttribute(\"system-login\")) {\n\t\t\t\tvalues.add(\"systemLogin\", brokerRelayElem.getAttribute(\"system-login\"));\n\t\t\t}\n\t\t\tif (brokerRelayElem.hasAttribute(\"system-passcode\")) {\n\t\t\t\tvalues.add(\"systemPasscode\", brokerRelayElem.getAttribute(\"system-passcode\"));\n\t\t\t}\n\t\t\tif (brokerRelayElem.hasAttribute(\"heartbeat-send-interval\")) {\n\t\t\t\tvalues.add(\"systemHeartbeatSendInterval\", brokerRelayElem.getAttribute(\"heartbeat-send-interval\"));\n\t\t\t}\n\t\t\tif (brokerRelayElem.hasAttribute(\"heartbeat-receive-interval\")) {\n\t\t\t\tvalues.add(\"systemHeartbeatReceiveInterval\", brokerRelayElem.getAttribute(\"heartbeat-receive-interval\"));\n\t\t\t}\n\t\t\tif (brokerRelayElem.hasAttribute(\"virtual-host\")) {\n\t\t\t\tvalues.add(\"virtualHost\", brokerRelayElem.getAttribute(\"virtual-host\"));\n\t\t\t}\n\t\t\tManagedMap<String, Object> map = new ManagedMap<String, Object>();\n\t\t\tmap.setSource(source);\n\t\t\tif (brokerRelayElem.hasAttribute(\"user-destination-broadcast\")) {\n\t\t\t\tString destination = brokerRelayElem.getAttribute(\"user-destination-broadcast\");\n\t\t\t\tmap.put(destination, userDestHandler);\n\t\t\t}\n\t\t\tif (brokerRelayElem.hasAttribute(\"user-registry-broadcast\")) {\n\t\t\t\tString destination = brokerRelayElem.getAttribute(\"user-registry-broadcast\");\n\t\t\t\tmap.put(destination, registerUserRegistryMessageHandler(userRegistry,\n\t\t\t\t\t\tbrokerTemplate, destination, context, source));\n\t\t\t}\n\t\t\tif (!map.isEmpty()) {\n\t\t\t\tvalues.add(\"systemSubscriptions\", map);\n\t\t\t}\n\t\t\tClass<?> handlerType = StompBrokerRelayMessageHandler.class;\n\t\t\tbrokerDef = new RootBeanDefinition(handlerType, cavs, values);\n\t\t}\n\t\telse {\n\t\t\tthrow new IllegalStateException(\"Neither <simple-broker> nor <stomp-broker-relay> elements found.\");\n\t\t}\n\t\tregisterBeanDef(brokerDef, context, source);\n\t\treturn brokerDef;\n\t}\n// fix_end\n", "cwe": "NVD-CWE-noinfo", "cwe_name": "", "idx": 103437}
{"source": "// bug_start\n@Before\n    public void setUp() throws Exception {\n        SecurityContextHolder.clearContext();\n        mockMvc = MockMvcBuilders.webAppContextSetup(webApplicationContext).build();\n// bug_end\n \n// bug_start\n        Map<String, List<DescribedApproval>> approvalsByClientId = new HashMap<String, List<DescribedApproval>>();\n// bug_end\n \n// bug_start\n        DescribedApproval readApproval = new DescribedApproval();\n        readApproval.setUserId(\"userId\");\n        readApproval.setClientId(\"app\");\n        readApproval.setScope(\"thing.read\");\n        readApproval.setStatus(APPROVED);\n        readApproval.setDescription(\"Read your thing resources\");\n// bug_end\n \n// bug_start\n        DescribedApproval writeApproval = new DescribedApproval();\n        writeApproval.setUserId(\"userId\");\n        writeApproval.setClientId(\"app\");\n        writeApproval.setScope(\"thing.write\");\n        writeApproval.setStatus(APPROVED);\n        writeApproval.setDescription(\"Write to your thing resources\");\n// bug_end\n \n// bug_start\n        approvalsByClientId.put(\"app\", Arrays.asList(readApproval, writeApproval));\n// bug_end\n \n// bug_start\n        Mockito.when(approvalsService.getCurrentApprovalsByClientId()).thenReturn(approvalsByClientId);\n\n        BaseClientDetails appClient = new BaseClientDetails(\"app\",\"thing\",\"thing.read,thing.write\",\"authorization_code\", \"\");\n        appClient.addAdditionalInformation(ClientConstants.CLIENT_NAME, THE_ULTIMATE_APP);\n        Mockito.when(clientDetailsService.loadClientByClientId(\"app\")).thenReturn(appClient);\n// bug_end\n     }\n \n", "target": "// fix_start\n@Override\n    protected void configure(HttpSecurity http) throws Exception {\n        http\n                .cors().and()\n                .rememberMe().disable()\n                .authorizeRequests()\n                    .anyRequest().fullyAuthenticated()\n                    .and()\n                .sessionManagement()\n                    .sessionCreationPolicy(SessionCreationPolicy.STATELESS);\n// fix_end\n// fix_start\n        http.addFilterBefore(x509FilterBean(), AnonymousAuthenticationFilter.class);\n// fix_end\n// fix_start\n        http.addFilterBefore(jwtFilterBean(), AnonymousAuthenticationFilter.class);\n// fix_end\n// fix_start\n        http.addFilterBefore(otpFilterBean(), AnonymousAuthenticationFilter.class);\n// fix_end\n// fix_start\n        http.addFilterBefore(knoxFilterBean(), AnonymousAuthenticationFilter.class);\n// fix_end\n// fix_start\n        http.anonymous().authenticationFilter(anonymousFilterBean());\n// fix_end\n", "cwe": "CWE-319", "cwe_name": "", "idx": 41940}
{"source": "// bug_start\nprivate Page<TaskExecution> queryForPageableResults(Pageable pageable,\n\t\t\tString selectClause, String fromClause, String whereClause,\n\t\t\tMapSqlParameterSource queryParameters, long totalCount) {\n\t\tSqlPagingQueryProviderFactoryBean factoryBean = new SqlPagingQueryProviderFactoryBean();\n\t\tfactoryBean.setSelectClause(selectClause);\n\t\tfactoryBean.setFromClause(fromClause);\n\t\tif (StringUtils.hasText(whereClause)) {\n\t\t\tfactoryBean.setWhereClause(whereClause);\n\t\t}\n\t\tfinal Sort sort = pageable.getSort();\n\t\tfinal LinkedHashMap<String, Order> sortOrderMap = new LinkedHashMap<>();\n// bug_end\n \n// bug_start\n\t\tif (sort != null) {\n\t\t\tfor (Sort.Order sortOrder : sort) {\n\t\t\t\tsortOrderMap.put(sortOrder.getProperty(),\n\t\t\t\t\t\tsortOrder.isAscending() ? Order.ASCENDING : Order.DESCENDING);\n\t\t\t}\n\t\t}\n// bug_end\n \n// bug_start\n\t\tif (!CollectionUtils.isEmpty(sortOrderMap)) {\n\t\t\tfactoryBean.setSortKeys(sortOrderMap);\n\t\t}\n\t\telse {\n\t\t\tfactoryBean.setSortKeys(this.orderMap);\n\t\t}\n// bug_end\n \n// bug_start\n\t\tfactoryBean.setDataSource(this.dataSource);\n\t\tPagingQueryProvider pagingQueryProvider;\n\t\ttry {\n\t\t\tpagingQueryProvider = factoryBean.getObject();\n\t\t\tpagingQueryProvider.init(this.dataSource);\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tthrow new IllegalStateException(e);\n\t\t}\n\t\tString query = pagingQueryProvider.getPageQuery(pageable);\n\t\tList<TaskExecution> resultList = this.jdbcTemplate.query(getQuery(query),\n\t\t\t\tqueryParameters, new TaskExecutionRowMapper());\n\t\treturn new PageImpl<>(resultList, pageable, totalCount);\n\t}\n// bug_end\n \n", "target": "// fix_start\n@Before\n    public void setUp() throws Exception {\n        SecurityContextHolder.clearContext();\n        mockMvc = MockMvcBuilders.webAppContextSetup(webApplicationContext).build();\n// fix_end\n// fix_start\n        Map<String, List<DescribedApproval>> approvalsByClientId = new HashMap<String, List<DescribedApproval>>();\n// fix_end\n// fix_start\n        DescribedApproval readApproval = new DescribedApproval();\n        readApproval.setUserId(\"userId\");\n        readApproval.setClientId(\"app\");\n        readApproval.setScope(\"thing.read\");\n        readApproval.setStatus(APPROVED);\n        readApproval.setDescription(\"Read your thing resources\");\n// fix_end\n// fix_start\n        DescribedApproval writeApproval = new DescribedApproval();\n        writeApproval.setUserId(\"userId\");\n        writeApproval.setClientId(\"app\");\n        writeApproval.setScope(\"thing.write\");\n        writeApproval.setStatus(APPROVED);\n        writeApproval.setDescription(\"Write to your thing resources\");\n// fix_end\n// fix_start\n        approvalsByClientId.put(\"app\", Arrays.asList(readApproval, writeApproval));\n\n        Mockito.when(approvalsService.getCurrentApprovalsByClientId()).thenReturn(approvalsByClientId);\n        Mockito.doThrow(new NoSuchClientException(\"invalidId\")).when(approvalsService).deleteApprovalsForClient(\"invalidId\");\n\n        BaseClientDetails appClient = new BaseClientDetails(\"app\",\"thing\",\"thing.read,thing.write\",\"authorization_code\", \"\");\n        appClient.addAdditionalInformation(ClientConstants.CLIENT_NAME, THE_ULTIMATE_APP);\n        Mockito.when(clientDetailsService.loadClientByClientId(\"app\")).thenReturn(appClient);\n    }\n\n// fix_end\n", "cwe": "CWE-269", "cwe_name": "Improper Privilege Management", "idx": 35397}
{"source": "// bug_start\n@RequirePOST\n    public void doNotifyCommit(StaplerRequest req, StaplerResponse rsp) throws ServletException, IOException {\n        Set<String> affectedPath = new HashSet<String>();\n        String line;\n        BufferedReader r = new BufferedReader(req.getReader());\n// bug_end\n \n// bug_start\n        try {\n\t        while((line=r.readLine())!=null) {\n\t        \tif (LOGGER.isLoggable(FINER)) {\n\t        \t\tLOGGER.finer(\"Reading line: \"+line);\n\t        \t}\n\t            affectedPath.add(line.substring(4));\n\t            if (line.startsWith(\"svnlook changed --revision \")) {\n\t                String msg = \"Expecting the output from the svnlook command but instead you just sent me the svnlook invocation command line: \" + line;\n\t                LOGGER.warning(msg);\n\t                throw new IllegalArgumentException(msg);\n\t            }\n\t        }\n        } finally {\n        \tIOUtils.closeQuietly(r);\n        }\n// bug_end\n \n// bug_start\n        if(LOGGER.isLoggable(FINE))\n            LOGGER.fine(\"Change reported to Subversion repository \"+uuid+\" on \"+affectedPath);\n// bug_end\n \n// bug_start\n        QueryParameterMap query = new QueryParameterMap(req);\n        String revParam = query.get(\"rev\");\n        if (revParam == null) {\n            revParam = req.getHeader(\"X-Hudson-Subversion-Revision\");\n        }\n// bug_end\n \n// bug_start\n        long rev = -1;\n        if (revParam != null) {\n            rev = Long.parseLong(revParam);\n        }\n\n        boolean listenerDidSomething = false;\n        for (Listener listener : ExtensionList.lookup(Listener.class)) {\n            try {\n                if (listener.onNotify(uuid, rev, affectedPath)) {\n                    listenerDidSomething = true;\n                }\n            } catch (Throwable t) {\n                LOGGER.log(WARNING, \"Listener \" + listener.getClass().getName() + \" threw an uncaught exception\", t);\n            }\n        }\n\n        if (!listenerDidSomething) LOGGER.log(Level.WARNING, \"No interest in change to repository UUID {0} found\", uuid);\n\n        rsp.setStatus(SC_OK);\n    }\n\n// bug_end\n", "target": "// fix_start\nprivate Page<TaskExecution> queryForPageableResults(Pageable pageable,\n\t\t\tString selectClause, String fromClause, String whereClause,\n\t\t\tMapSqlParameterSource queryParameters, long totalCount) {\n\t\tSqlPagingQueryProviderFactoryBean factoryBean = new SqlPagingQueryProviderFactoryBean();\n\t\tfactoryBean.setSelectClause(selectClause);\n\t\tfactoryBean.setFromClause(fromClause);\n\t\tif (StringUtils.hasText(whereClause)) {\n\t\t\tfactoryBean.setWhereClause(whereClause);\n\t\t}\n\t\tfinal Sort sort = pageable.getSort();\n\t\tfinal LinkedHashMap<String, Order> sortOrderMap = new LinkedHashMap<>();\n// fix_end\n// fix_start\n\t\tif (sort != null) {\n\t\t\tfor (Sort.Order sortOrder : sort) {\n\t\t\t\tif (validSortColumns.contains(sortOrder.getProperty().toUpperCase())) {\n\t\t\t\t\tsortOrderMap.put(sortOrder.getProperty(),\n\t\t\t\t\t\t\tsortOrder.isAscending() ? Order.ASCENDING : Order.DESCENDING);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tthrow new IllegalArgumentException(String.format(\n\t\t\t\t\t\t\t\"Invalid sort option selected: %s\", sortOrder.getProperty()));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n// fix_end\n// fix_start\n\t\tif (!CollectionUtils.isEmpty(sortOrderMap)) {\n\t\t\tfactoryBean.setSortKeys(sortOrderMap);\n\t\t}\n\t\telse {\n\t\t\tfactoryBean.setSortKeys(this.orderMap);\n\t\t}\n// fix_end\n// fix_start\n\t\tfactoryBean.setDataSource(this.dataSource);\n\t\tPagingQueryProvider pagingQueryProvider;\n\t\ttry {\n\t\t\tpagingQueryProvider = factoryBean.getObject();\n\t\t\tpagingQueryProvider.init(this.dataSource);\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tthrow new IllegalStateException(e);\n\t\t}\n\t\tString query = pagingQueryProvider.getPageQuery(pageable);\n\t\tList<TaskExecution> resultList = this.jdbcTemplate.query(getQuery(query),\n\t\t\t\tqueryParameters, new TaskExecutionRowMapper());\n\t\treturn new PageImpl<>(resultList, pageable, totalCount);\n\t}\n// fix_end\n", "cwe": "CWE-89", "cwe_name": "Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection')", "idx": 92635}
{"source": "// bug_start\npublic void doNotifyCommit(StaplerRequest req, StaplerResponse rsp) throws ServletException, IOException {\n        requirePOST();\n// bug_end\n \n// bug_start\n        Set<String> affectedPath = new HashSet<String>();\n        String line;\n        BufferedReader r = new BufferedReader(req.getReader());\n\n        try {\n\t        while((line=r.readLine())!=null) {\n\t        \tif (LOGGER.isLoggable(FINER)) {\n\t        \t\tLOGGER.finer(\"Reading line: \"+line);\n\t        \t}\n\t            affectedPath.add(line.substring(4));\n\t            if (line.startsWith(\"svnlook changed --revision \")) {\n\t                String msg = \"Expecting the output from the svnlook command but instead you just sent me the svnlook invocation command line: \" + line;\n\t                LOGGER.warning(msg);\n\t                throw new IllegalArgumentException(msg);\n\t            }\n\t        }\n        } finally {\n        \tIOUtils.closeQuietly(r);\n// bug_end\n         }\n \n// bug_start\n        if(LOGGER.isLoggable(FINE))\n            LOGGER.fine(\"Change reported to Subversion repository \"+uuid+\" on \"+affectedPath);\n// bug_end\n \n// bug_start\n        QueryParameterMap query = new QueryParameterMap(req);\n        String revParam = query.get(\"rev\");\n        if (revParam == null) {\n            revParam = req.getHeader(\"X-Hudson-Subversion-Revision\");\n        }\n\n        long rev = -1;\n        if (revParam != null) {\n            rev = Long.parseLong(revParam);\n        }\n\n        boolean listenerDidSomething = false;\n        for (Listener listener : ExtensionList.lookup(Listener.class)) {\n            try {\n                if (listener.onNotify(uuid, rev, affectedPath)) {\n                    listenerDidSomething = true;\n                }\n            } catch (Throwable t) {\n                LOGGER.log(WARNING, \"Listener \" + listener.getClass().getName() + \" threw an uncaught exception\", t);\n            }\n        }\n\n        if (!listenerDidSomething) LOGGER.log(Level.WARNING, \"No interest in change to repository UUID {0} found\", uuid);\n\n        rsp.setStatus(SC_OK);\n// bug_end\n     }\n \n", "target": "// fix_start\npublic String scanPseudoAttribute(boolean scanningTextDecl,\n                                      XMLString value)\n        throws IOException, XNIException {\n// fix_end\n// fix_start\n        String name = fEntityScanner.scanName();\n        XMLEntityManager.print(fEntityManager.getCurrentEntity());\n        if (name == null) {\n            reportFatalError(\"PseudoAttrNameExpected\", null);\n        }\n        fEntityScanner.skipDeclSpaces();\n        if (!fEntityScanner.skipChar('=')) {\n            reportFatalError(scanningTextDecl ? \"EqRequiredInTextDecl\"\n                             : \"EqRequiredInXMLDecl\", new Object[]{name});\n        }\n        fEntityScanner.skipDeclSpaces();\n        int quote = fEntityScanner.peekChar();\n        if (quote != '\\'' && quote != '\"') {\n            reportFatalError(scanningTextDecl ? \"QuoteRequiredInTextDecl\"\n                             : \"QuoteRequiredInXMLDecl\" , new Object[]{name});\n        }\n        fEntityScanner.scanChar();\n        int c = fEntityScanner.scanLiteral(quote, value);\n        if (c != quote) {\n            fStringBuffer2.clear();\n            do {\n                fStringBuffer2.append(value);\n                if (c != -1) {\n                    if (c == '&' || c == '%' || c == '<' || c == ']') {\n                        fStringBuffer2.append((char)fEntityScanner.scanChar());\n                    }\n                    else if (XMLChar.isHighSurrogate(c)) {\n                        scanSurrogates(fStringBuffer2);\n                    }\n                    else if (isInvalidLiteral(c)) {\n                        String key = scanningTextDecl\n                            ? \"InvalidCharInTextDecl\" : \"InvalidCharInXMLDecl\";\n                        reportFatalError(key,\n                                       new Object[] {Integer.toString(c, 16)});\n                        fEntityScanner.scanChar();\n                    }\n                }\n                c = fEntityScanner.scanLiteral(quote, value);\n            } while (c != quote);\n            fStringBuffer2.append(value);\n            value.setValues(fStringBuffer2);\n        }\n        if (!fEntityScanner.skipChar(quote)) {\n            reportFatalError(scanningTextDecl ? \"CloseQuoteMissingInTextDecl\"\n                             : \"CloseQuoteMissingInXMLDecl\",\n                             new Object[]{name});\n// fix_end\n// fix_start\n        return name;\n// fix_end\n// fix_start\n// fix_end\n", "cwe": "CWE-863", "cwe_name": "Incorrect Authorization", "idx": 89716}
{"source": "// bug_start\n@Override\n    protected void handleMessage(Http1xServerConnection conn, ContextImpl context, ChannelHandlerContext chctx, Object msg) throws Exception {\n      Channel ch = chctx.channel();\n      if (msg instanceof HttpRequest) {\n        final HttpRequest request = (HttpRequest) msg;\n// bug_end\n \n// bug_start\n        if (log.isTraceEnabled()) log.trace(\"Server received request: \" + request.getUri());\n// bug_end\n \n// bug_start\n        if (request.headers().contains(io.vertx.core.http.HttpHeaders.UPGRADE, io.vertx.core.http.HttpHeaders.WEBSOCKET, true)) {\n// bug_end\n \n// bug_start\n          String connectionHeader = request.headers().get(io.vertx.core.http.HttpHeaders.CONNECTION);\n          if (connectionHeader == null || !connectionHeader.toLowerCase().contains(\"upgrade\")) {\n            handshakeErrorStatus = BAD_REQUEST;\n            handshakeErrorMsg = \"\\\"Connection\\\" must be \\\"Upgrade\\\".\";\n            return;\n          }\n\n          if (request.getMethod() != HttpMethod.GET) {\n            handshakeErrorStatus = METHOD_NOT_ALLOWED;\n            sendError(null, METHOD_NOT_ALLOWED, ch);\n            return;\n          }\n\n          if (wsRequest == null) {\n            if (request instanceof FullHttpRequest) {\n              handshake(conn, (FullHttpRequest) request, ch, chctx);\n            } else {\n              wsRequest = new DefaultFullHttpRequest(request.getProtocolVersion(), request.getMethod(), request.getUri());\n              wsRequest.headers().set(request.headers());\n            }\n          }\n        } else {\n          conn.handleMessage(msg);\n        }\n      } else if (msg instanceof WebSocketFrameInternal) {\n        WebSocketFrameInternal wsFrame = (WebSocketFrameInternal) msg;\n        switch (wsFrame.type()) {\n          case BINARY:\n          case CONTINUATION:\n          case TEXT:\n          case PONG:\n            conn.handleMessage(msg);\n            break;\n          case PING:\n            conn.channel().writeAndFlush(new PongWebSocketFrame(wsFrame.getBinaryData().copy()));\n            break;\n          case CLOSE:\n            if (!closeFrameSent) {\n              CloseWebSocketFrame closeFrame = new CloseWebSocketFrame(wsFrame.closeStatusCode(), wsFrame.closeReason());\n              ch.writeAndFlush(closeFrame).addListener(ChannelFutureListener.CLOSE);\n              closeFrameSent = true;\n            }\n            conn.handleMessage(msg);\n            break;\n          default:\n            throw new IllegalStateException(\"Invalid type: \" + wsFrame.type());\n        }\n      } else if (msg instanceof HttpContent) {\n        if (wsRequest != null) {\n          ByteBuf content = wsRequest.content();\n          boolean overflow = content.readableBytes() > 8192;\n          content.writeBytes(((HttpContent) msg).content());\n          if (content.readableBytes() > 8192) {\n            if (!overflow) {\n              FullHttpResponse resp = new DefaultFullHttpResponse(\n                io.netty.handler.codec.http.HttpVersion.HTTP_1_1,\n                HttpResponseStatus.REQUEST_ENTITY_TOO_LARGE\n              );\n              chctx.writeAndFlush(resp);\n              chctx.close();\n            }\n            if (msg instanceof LastHttpContent) {\n              wsRequest = null;\n              return;\n            }\n          }\n          if (msg instanceof LastHttpContent) {\n            FullHttpRequest req = wsRequest;\n            wsRequest = null;\n            handshake(conn, req, ch, chctx);\n            return;\n          }\n        } else if (handshakeErrorStatus != null) {\n          if (msg instanceof LastHttpContent) {\n            sendError(handshakeErrorMsg, handshakeErrorStatus, ch);\n            handshakeErrorMsg = null;\n            handshakeErrorMsg = null;\n          }\n          return;\n        }\n        conn.handleMessage(msg);\n      } else {\n        throw new IllegalStateException(\"Invalid message \" + msg);\n      }\n// bug_end\n     }\n \n", "target": "// fix_start\npublic String scanPseudoAttribute(boolean scanningTextDecl,\n                                      XMLString value)\n        throws IOException, XNIException {\n// fix_end\n// fix_start\n        String name = scanPseudoAttributeName();\n        XMLEntityManager.print(fEntityManager.getCurrentEntity());\n        if (name == null) {\n            reportFatalError(\"PseudoAttrNameExpected\", null);\n        }\n        fEntityScanner.skipDeclSpaces();\n        if (!fEntityScanner.skipChar('=')) {\n            reportFatalError(scanningTextDecl ? \"EqRequiredInTextDecl\"\n                             : \"EqRequiredInXMLDecl\", new Object[]{name});\n        }\n        fEntityScanner.skipDeclSpaces();\n        int quote = fEntityScanner.peekChar();\n        if (quote != '\\'' && quote != '\"') {\n            reportFatalError(scanningTextDecl ? \"QuoteRequiredInTextDecl\"\n                             : \"QuoteRequiredInXMLDecl\" , new Object[]{name});\n        }\n        fEntityScanner.scanChar();\n        int c = fEntityScanner.scanLiteral(quote, value);\n        if (c != quote) {\n            fStringBuffer2.clear();\n            do {\n                fStringBuffer2.append(value);\n                if (c != -1) {\n                    if (c == '&' || c == '%' || c == '<' || c == ']') {\n                        fStringBuffer2.append((char)fEntityScanner.scanChar());\n                    }\n                    else if (XMLChar.isHighSurrogate(c)) {\n                        scanSurrogates(fStringBuffer2);\n                    }\n                    else if (isInvalidLiteral(c)) {\n                        String key = scanningTextDecl\n                            ? \"InvalidCharInTextDecl\" : \"InvalidCharInXMLDecl\";\n                        reportFatalError(key,\n                                       new Object[] {Integer.toString(c, 16)});\n                        fEntityScanner.scanChar();\n                    }\n                }\n                c = fEntityScanner.scanLiteral(quote, value);\n            } while (c != quote);\n            fStringBuffer2.append(value);\n            value.setValues(fStringBuffer2);\n        }\n        if (!fEntityScanner.skipChar(quote)) {\n            reportFatalError(scanningTextDecl ? \"CloseQuoteMissingInTextDecl\"\n                             : \"CloseQuoteMissingInXMLDecl\",\n                             new Object[]{name});\n        }\n// fix_end\n// fix_start\n        return name;\n// fix_end\n// fix_start\n// fix_end\n", "cwe": "NVD-CWE-noinfo", "cwe_name": "", "idx": 103677}
{"source": "// bug_start\n@Override\n    protected void handleMessage(Http1xServerConnection conn, ContextImpl context, ChannelHandlerContext chctx, Object msg) throws Exception {\n      Channel ch = chctx.channel();\n      if (msg instanceof HttpRequest) {\n        final HttpRequest request = (HttpRequest) msg;\n// bug_end\n \n// bug_start\n        if (log.isTraceEnabled()) log.trace(\"Server received request: \" + request.getUri());\n\n        if (request.headers().contains(io.vertx.core.http.HttpHeaders.UPGRADE, io.vertx.core.http.HttpHeaders.WEBSOCKET, true)) {\n\n          String connectionHeader = request.headers().get(io.vertx.core.http.HttpHeaders.CONNECTION);\n          if (connectionHeader == null || !connectionHeader.toLowerCase().contains(\"upgrade\")) {\n            handshakeErrorStatus = BAD_REQUEST;\n            handshakeErrorMsg = \"\\\"Connection\\\" must be \\\"Upgrade\\\".\";\n            return;\n          }\n\n          if (request.getMethod() != HttpMethod.GET) {\n            handshakeErrorStatus = METHOD_NOT_ALLOWED;\n            sendError(null, METHOD_NOT_ALLOWED, ch);\n            return;\n          }\n\n          if (wsRequest == null) {\n            if (request instanceof FullHttpRequest) {\n              handshake(conn, (FullHttpRequest) request, ch, chctx);\n            } else {\n              wsRequest = new DefaultFullHttpRequest(request.getProtocolVersion(), request.getMethod(), request.getUri());\n              wsRequest.headers().set(request.headers());\n// bug_end\n             }\n// bug_start\n          }\n// bug_end\n         } else {\n// bug_start\n          conn.handleMessage(msg);\n// bug_end\n         }\n// bug_start\n      } else if (msg instanceof WebSocketFrameInternal) {\n        WebSocketFrameInternal wsFrame = (WebSocketFrameInternal) msg;\n        switch (wsFrame.type()) {\n          case BINARY:\n          case CONTINUATION:\n          case TEXT:\n          case PONG:\n            conn.handleMessage(msg);\n            break;\n          case PING:\n            conn.channel().writeAndFlush(new PongWebSocketFrame(wsFrame.getBinaryData().copy()));\n            break;\n          case CLOSE:\n            if (!closeFrameSent) {\n              CloseWebSocketFrame closeFrame = new CloseWebSocketFrame(wsFrame.closeStatusCode(), wsFrame.closeReason());\n              ch.writeAndFlush(closeFrame).addListener(ChannelFutureListener.CLOSE);\n              closeFrameSent = true;\n            }\n            conn.handleMessage(msg);\n            break;\n          default:\n            throw new IllegalStateException(\"Invalid type: \" + wsFrame.type());\n        }\n      } else if (msg instanceof HttpContent) {\n        if (wsRequest != null) {\n          wsRequest.content().writeBytes(((HttpContent) msg).content());\n          if (msg instanceof LastHttpContent) {\n            FullHttpRequest req = wsRequest;\n            wsRequest = null;\n            handshake(conn, req, ch, chctx);\n            return;\n          }\n        } else if (handshakeErrorStatus != null) {\n          if (msg instanceof LastHttpContent) {\n            sendError(handshakeErrorMsg, handshakeErrorStatus, ch);\n            handshakeErrorMsg = null;\n            handshakeErrorMsg = null;\n          }\n          return;\n        }\n        conn.handleMessage(msg);\n      } else {\n        throw new IllegalStateException(\"Invalid message \" + msg);\n      }\n// bug_end\n     }\n \n", "target": "// fix_start\npublic static int getPrefixLength(final String fileName) {\n        if (fileName == null) {\n            return NOT_FOUND;\n        }\n        final int len = fileName.length();\n        if (len == 0) {\n            return 0;\n        }\n        char ch0 = fileName.charAt(0);\n        if (ch0 == ':') {\n            return NOT_FOUND;\n        }\n        if (len == 1) {\n            if (ch0 == '~') {\n                return 2;\n            }\n            return isSeparator(ch0) ? 1 : 0;\n        }\n        if (ch0 == '~') {\n            int posUnix = fileName.indexOf(UNIX_SEPARATOR, 1);\n            int posWin = fileName.indexOf(WINDOWS_SEPARATOR, 1);\n            if (posUnix == NOT_FOUND && posWin == NOT_FOUND) {\n                return len + 1;\n            }\n            posUnix = posUnix == NOT_FOUND ? posWin : posUnix;\n            posWin = posWin == NOT_FOUND ? posUnix : posWin;\n            return Math.min(posUnix, posWin) + 1;\n        }\n        final char ch1 = fileName.charAt(1);\n        if (ch1 == ':') {\n            ch0 = Character.toUpperCase(ch0);\n            if (ch0 >= 'A' && ch0 <= 'Z') {\n                if (len == 2 || isSeparator(fileName.charAt(2)) == false) {\n                    return 2;\n                }\n                return 3;\n            } else if (ch0 == UNIX_SEPARATOR) {\n                return 1;\n            }\n            return NOT_FOUND;\n// fix_end\n// fix_start\n        } else if (isSeparator(ch0) && isSeparator(ch1)) {\n            int posUnix = fileName.indexOf(UNIX_SEPARATOR, 2);\n            int posWin = fileName.indexOf(WINDOWS_SEPARATOR, 2);\n            if (posUnix == NOT_FOUND && posWin == NOT_FOUND || posUnix == 2 || posWin == 2) {\n                return NOT_FOUND;\n// fix_end\n// fix_start\n            posUnix = posUnix == NOT_FOUND ? posWin : posUnix;\n            posWin = posWin == NOT_FOUND ? posUnix : posWin;\n            int pos = Math.min(posUnix, posWin) + 1;\n            String hostnamePart = fileName.substring(2, pos - 1);\n            return isValidHostName(hostnamePart) ? pos : NOT_FOUND;\n// fix_end\n// fix_start\n            return isSeparator(ch0) ? 1 : 0;\n// fix_end\n// fix_start\n// fix_end\n", "cwe": "CWE-119", "cwe_name": "Improper Restriction of Operations within the Bounds of a Memory Buffer", "idx": 2040}
{"source": "// bug_start\npublic static int getPrefixLength(final String fileName) {\n        if (fileName == null) {\n            return NOT_FOUND;\n        }\n        final int len = fileName.length();\n        if (len == 0) {\n            return 0;\n        }\n        char ch0 = fileName.charAt(0);\n        if (ch0 == ':') {\n            return NOT_FOUND;\n        }\n        if (len == 1) {\n            if (ch0 == '~') {\n                return 2;\n            }\n            return isSeparator(ch0) ? 1 : 0;\n        }\n        if (ch0 == '~') {\n            int posUnix = fileName.indexOf(UNIX_SEPARATOR, 1);\n            int posWin = fileName.indexOf(WINDOWS_SEPARATOR, 1);\n            if (posUnix == NOT_FOUND && posWin == NOT_FOUND) {\n                return len + 1;\n            }\n            posUnix = posUnix == NOT_FOUND ? posWin : posUnix;\n            posWin = posWin == NOT_FOUND ? posUnix : posWin;\n            return Math.min(posUnix, posWin) + 1;\n        }\n        final char ch1 = fileName.charAt(1);\n        if (ch1 == ':') {\n            ch0 = Character.toUpperCase(ch0);\n            if (ch0 >= 'A' && ch0 <= 'Z') {\n                if (len == 2 || isSeparator(fileName.charAt(2)) == false) {\n                    return 2;\n                }\n                return 3;\n            } else if (ch0 == UNIX_SEPARATOR) {\n                return 1;\n            }\n            return NOT_FOUND;\n\n        } else if (isSeparator(ch0) && isSeparator(ch1)) {\n            int posUnix = fileName.indexOf(UNIX_SEPARATOR, 2);\n            int posWin = fileName.indexOf(WINDOWS_SEPARATOR, 2);\n            if (posUnix == NOT_FOUND && posWin == NOT_FOUND || posUnix == 2 || posWin == 2) {\n                return NOT_FOUND;\n            }\n            posUnix = posUnix == NOT_FOUND ? posWin : posUnix;\n            posWin = posWin == NOT_FOUND ? posUnix : posWin;\n            return Math.min(posUnix, posWin) + 1;\n// bug_end\n         } else {\n// bug_start\n            return isSeparator(ch0) ? 1 : 0;\n        }\n// bug_end\n     }\n \n", "target": "// fix_start\nprivate Session connectToServerRecursive(Endpoint endpoint,\n            ClientEndpointConfig clientEndpointConfiguration, URI path,\n            Set<URI> redirectSet)\n            throws DeploymentException {\n\n        boolean secure = false;\n        ByteBuffer proxyConnect = null;\n        URI proxyPath;\n\n        String scheme = path.getScheme();\n        if (\"ws\".equalsIgnoreCase(scheme)) {\n            proxyPath = URI.create(\"http\" + path.toString().substring(2));\n        } else if (\"wss\".equalsIgnoreCase(scheme)) {\n            proxyPath = URI.create(\"https\" + path.toString().substring(3));\n            secure = true;\n// fix_end\n// fix_start\n            throw new DeploymentException(sm.getString(\n                    \"wsWebSocketContainer.pathWrongScheme\", scheme));\n        }\n\n        String host = path.getHost();\n        if (host == null) {\n            throw new DeploymentException(\n                    sm.getString(\"wsWebSocketContainer.pathNoHost\"));\n        }\n        int port = path.getPort();\n\n        SocketAddress sa = null;\n\n        List<Proxy> proxies = ProxySelector.getDefault().select(proxyPath);\n        Proxy selectedProxy = null;\n        for (Proxy proxy : proxies) {\n            if (proxy.type().equals(Proxy.Type.HTTP)) {\n                sa = proxy.address();\n                if (sa instanceof InetSocketAddress) {\n                    InetSocketAddress inet = (InetSocketAddress) sa;\n                    if (inet.isUnresolved()) {\n                        sa = new InetSocketAddress(inet.getHostName(), inet.getPort());\n                    }\n                }\n                selectedProxy = proxy;\n                break;\n            }\n        }\n\n        if (port == -1) {\n            if (\"ws\".equalsIgnoreCase(scheme)) {\n                port = 80;\n            } else {\n                port = 443;\n            }\n        }\n\n        if (sa == null) {\n            sa = new InetSocketAddress(host, port);\n        } else {\n            proxyConnect = createProxyRequest(host, port);\n        }\n\n        Map<String, List<String>> reqHeaders = createRequestHeaders(host, port,\n                clientEndpointConfiguration);\n        clientEndpointConfiguration.getConfigurator().beforeRequest(reqHeaders);\n        if (Constants.DEFAULT_ORIGIN_HEADER_VALUE != null\n                && !reqHeaders.containsKey(Constants.ORIGIN_HEADER_NAME)) {\n            List<String> originValues = new ArrayList<>(1);\n            originValues.add(Constants.DEFAULT_ORIGIN_HEADER_VALUE);\n            reqHeaders.put(Constants.ORIGIN_HEADER_NAME, originValues);\n        }\n        ByteBuffer request = createRequest(path, reqHeaders);\n\n        AsynchronousSocketChannel socketChannel;\n        try {\n            socketChannel = AsynchronousSocketChannel.open(getAsynchronousChannelGroup());\n        } catch (IOException ioe) {\n            throw new DeploymentException(sm.getString(\n                    \"wsWebSocketContainer.asynchronousSocketChannelFail\"), ioe);\n        }\n\n        Map<String,Object> userProperties = clientEndpointConfiguration.getUserProperties();\n\n        long timeout = Constants.IO_TIMEOUT_MS_DEFAULT;\n        String timeoutValue = (String) userProperties.get(Constants.IO_TIMEOUT_MS_PROPERTY);\n        if (timeoutValue != null) {\n            timeout = Long.valueOf(timeoutValue).intValue();\n        }\n\n        ByteBuffer response = ByteBuffer.allocate(getDefaultMaxBinaryMessageBufferSize());\n        String subProtocol;\n        boolean success = false;\n        List<Extension> extensionsAgreed = new ArrayList<>();\n        Transformation transformation = null;\n\n        Future<Void> fConnect = socketChannel.connect(sa);\n        AsyncChannelWrapper channel = null;\n\n        if (proxyConnect != null) {\n            try {\n                fConnect.get(timeout, TimeUnit.MILLISECONDS);\n                channel = new AsyncChannelWrapperNonSecure(socketChannel);\n                writeRequest(channel, proxyConnect, timeout);\n                HttpResponse httpResponse = processResponse(response, channel, timeout);\n                if (httpResponse.getStatus() != 200) {\n                    throw new DeploymentException(sm.getString(\n                            \"wsWebSocketContainer.proxyConnectFail\", selectedProxy,\n                            Integer.toString(httpResponse.getStatus())));\n                }\n            } catch (TimeoutException | InterruptedException | ExecutionException |\n                    EOFException e) {\n                if (channel != null) {\n                    channel.close();\n                }\n                throw new DeploymentException(\n                        sm.getString(\"wsWebSocketContainer.httpRequestFailed\"), e);\n            }\n        }\n\n        if (secure) {\n            SSLEngine sslEngine = createSSLEngine(userProperties);\n            channel = new AsyncChannelWrapperSecure(socketChannel, sslEngine);\n        } else if (channel == null) {\n            channel = new AsyncChannelWrapperNonSecure(socketChannel);\n        }\n\n        try {\n            fConnect.get(timeout, TimeUnit.MILLISECONDS);\n\n            Future<Void> fHandshake = channel.handshake();\n            fHandshake.get(timeout, TimeUnit.MILLISECONDS);\n\n            writeRequest(channel, request, timeout);\n\n            HttpResponse httpResponse = processResponse(response, channel, timeout);\n\n            int maxRedirects = Constants.MAX_REDIRECTIONS_DEFAULT;\n            String maxRedirectsValue =\n                    (String) userProperties.get(Constants.MAX_REDIRECTIONS_PROPERTY);\n            if (maxRedirectsValue != null) {\n                maxRedirects = Integer.parseInt(maxRedirectsValue);\n            }\n\n            if (httpResponse.status != 101) {\n                if(isRedirectStatus(httpResponse.status)){\n                    List<String> locationHeader =\n                            httpResponse.getHandshakeResponse().getHeaders().get(\n                                    Constants.LOCATION_HEADER_NAME);\n\n                    if (locationHeader == null || locationHeader.isEmpty() ||\n                            locationHeader.get(0) == null || locationHeader.get(0).isEmpty()) {\n                        throw new DeploymentException(sm.getString(\n                                \"wsWebSocketContainer.missingLocationHeader\",\n                                Integer.toString(httpResponse.status)));\n                    }\n\n                    URI redirectLocation = URI.create(locationHeader.get(0)).normalize();\n\n                    if (!redirectLocation.isAbsolute()) {\n                        redirectLocation = path.resolve(redirectLocation);\n                    }\n\n                    String redirectScheme = redirectLocation.getScheme().toLowerCase();\n\n                    if (redirectScheme.startsWith(\"http\")) {\n                        redirectLocation = new URI(redirectScheme.replace(\"http\", \"ws\"),\n                                redirectLocation.getUserInfo(), redirectLocation.getHost(),\n                                redirectLocation.getPort(), redirectLocation.getPath(),\n                                redirectLocation.getQuery(), redirectLocation.getFragment());\n                    }\n\n                    if (!redirectSet.add(redirectLocation) || redirectSet.size() > maxRedirects) {\n                        throw new DeploymentException(sm.getString(\n                                \"wsWebSocketContainer.redirectThreshold\", redirectLocation,\n                                Integer.toString(redirectSet.size()),\n                                Integer.toString(maxRedirects)));\n                    }\n\n                    return connectToServerRecursive(endpoint, clientEndpointConfiguration, redirectLocation, redirectSet);\n\n                }\n\n                else if (httpResponse.status == 401) {\n\n                    if (userProperties.get(Constants.AUTHORIZATION_HEADER_NAME) != null) {\n                        throw new DeploymentException(sm.getString(\n                                \"wsWebSocketContainer.failedAuthentication\",\n                                Integer.valueOf(httpResponse.status)));\n                    }\n\n                    List<String> wwwAuthenticateHeaders = httpResponse.getHandshakeResponse()\n                            .getHeaders().get(Constants.WWW_AUTHENTICATE_HEADER_NAME);\n\n                    if (wwwAuthenticateHeaders == null || wwwAuthenticateHeaders.isEmpty() ||\n                            wwwAuthenticateHeaders.get(0) == null || wwwAuthenticateHeaders.get(0).isEmpty()) {\n                        throw new DeploymentException(sm.getString(\n                                \"wsWebSocketContainer.missingWWWAuthenticateHeader\",\n                                Integer.toString(httpResponse.status)));\n                    }\n\n                    String authScheme = wwwAuthenticateHeaders.get(0).split(\"\\\\s+\", 2)[0];\n                    String requestUri = new String(request.array(), StandardCharsets.ISO_8859_1)\n                            .split(\"\\\\s\", 3)[1];\n\n                    Authenticator auth = AuthenticatorFactory.getAuthenticator(authScheme);\n\n                    if (auth == null) {\n                        throw new DeploymentException(\n                                sm.getString(\"wsWebSocketContainer.unsupportedAuthScheme\",\n                                        Integer.valueOf(httpResponse.status), authScheme));\n                    }\n\n                    userProperties.put(Constants.AUTHORIZATION_HEADER_NAME, auth.getAuthorization(\n                            requestUri, wwwAuthenticateHeaders.get(0), userProperties));\n\n                    return connectToServerRecursive(endpoint, clientEndpointConfiguration, path, redirectSet);\n\n                }\n\n                else {\n                    throw new DeploymentException(sm.getString(\"wsWebSocketContainer.invalidStatus\",\n                            Integer.toString(httpResponse.status)));\n                }\n            }\n            HandshakeResponse handshakeResponse = httpResponse.getHandshakeResponse();\n            clientEndpointConfiguration.getConfigurator().afterResponse(handshakeResponse);\n\n            List<String> protocolHeaders = handshakeResponse.getHeaders().get(\n                    Constants.WS_PROTOCOL_HEADER_NAME);\n            if (protocolHeaders == null || protocolHeaders.size() == 0) {\n                subProtocol = null;\n            } else if (protocolHeaders.size() == 1) {\n                subProtocol = protocolHeaders.get(0);\n            } else {\n                throw new DeploymentException(\n                        sm.getString(\"wsWebSocketContainer.invalidSubProtocol\"));\n            }\n\n            List<String> extHeaders = handshakeResponse.getHeaders().get(\n                    Constants.WS_EXTENSIONS_HEADER_NAME);\n            if (extHeaders != null) {\n                for (String extHeader : extHeaders) {\n                    Util.parseExtensionHeader(extensionsAgreed, extHeader);\n                }\n            }\n\n            TransformationFactory factory = TransformationFactory.getInstance();\n            for (Extension extension : extensionsAgreed) {\n                List<List<Extension.Parameter>> wrapper = new ArrayList<>(1);\n                wrapper.add(extension.getParameters());\n                Transformation t = factory.create(extension.getName(), wrapper, false);\n                if (t == null) {\n                    throw new DeploymentException(sm.getString(\n                            \"wsWebSocketContainer.invalidExtensionParameters\"));\n                }\n                if (transformation == null) {\n                    transformation = t;\n                } else {\n                    transformation.setNext(t);\n                }\n            }\n\n            success = true;\n        } catch (ExecutionException | InterruptedException | SSLException |\n                EOFException | TimeoutException | URISyntaxException | AuthenticationException e) {\n            throw new DeploymentException(\n                    sm.getString(\"wsWebSocketContainer.httpRequestFailed\"), e);\n        } finally {\n            if (!success) {\n                channel.close();\n            }\n        }\n\n        WsRemoteEndpointImplClient wsRemoteEndpointClient = new WsRemoteEndpointImplClient(channel);\n\n        WsSession wsSession = new WsSession(endpoint, wsRemoteEndpointClient,\n                this, null, null, null, null, null, extensionsAgreed,\n                subProtocol, Collections.<String,String>emptyMap(), secure,\n                clientEndpointConfiguration);\n\n        WsFrameClient wsFrameClient = new WsFrameClient(response, channel,\n                wsSession, transformation);\n        wsRemoteEndpointClient.setTransformation(wsFrameClient.getTransformation());\n\n        endpoint.onOpen(wsSession, clientEndpointConfiguration);\n        registerSession(endpoint, wsSession);\n\n        wsFrameClient.startInputProcessing();\n\n        return wsSession;\n// fix_end\n", "cwe": "CWE-22", "cwe_name": "Path Traversal", "idx": 27045}
{"source": "// bug_start\nstatic protected UTF8Buffer readUTF(DataByteArrayInputStream is) throws ProtocolException {\n        int size = is.readUnsignedShort();\n        Buffer buffer = is.readBuffer(size);\n        if (buffer == null || buffer.length != size) {\n            throw new ProtocolException(\"Invalid message encoding\");\n        }\n        return buffer.utf8();\n// bug_end\n     }\n \n", "target": "// fix_start\nprivate Session connectToServerRecursive(Endpoint endpoint,\n            ClientEndpointConfig clientEndpointConfiguration, URI path,\n            Set<URI> redirectSet)\n            throws DeploymentException {\n\n        boolean secure = false;\n        ByteBuffer proxyConnect = null;\n        URI proxyPath;\n\n        String scheme = path.getScheme();\n        if (\"ws\".equalsIgnoreCase(scheme)) {\n            proxyPath = URI.create(\"http\" + path.toString().substring(2));\n        } else if (\"wss\".equalsIgnoreCase(scheme)) {\n            proxyPath = URI.create(\"https\" + path.toString().substring(3));\n            secure = true;\n        } else {\n            throw new DeploymentException(sm.getString(\n                    \"wsWebSocketContainer.pathWrongScheme\", scheme));\n        }\n\n        String host = path.getHost();\n        if (host == null) {\n            throw new DeploymentException(\n                    sm.getString(\"wsWebSocketContainer.pathNoHost\"));\n        }\n        int port = path.getPort();\n\n        SocketAddress sa = null;\n\n        List<Proxy> proxies = ProxySelector.getDefault().select(proxyPath);\n        Proxy selectedProxy = null;\n        for (Proxy proxy : proxies) {\n            if (proxy.type().equals(Proxy.Type.HTTP)) {\n                sa = proxy.address();\n                if (sa instanceof InetSocketAddress) {\n                    InetSocketAddress inet = (InetSocketAddress) sa;\n                    if (inet.isUnresolved()) {\n                        sa = new InetSocketAddress(inet.getHostName(), inet.getPort());\n                    }\n                }\n                selectedProxy = proxy;\n                break;\n            }\n        }\n\n        if (port == -1) {\n            if (\"ws\".equalsIgnoreCase(scheme)) {\n                port = 80;\n            } else {\n                port = 443;\n            }\n        }\n\n        if (sa == null) {\n            sa = new InetSocketAddress(host, port);\n        } else {\n            proxyConnect = createProxyRequest(host, port);\n        }\n\n        Map<String, List<String>> reqHeaders = createRequestHeaders(host, port,\n                clientEndpointConfiguration);\n        clientEndpointConfiguration.getConfigurator().beforeRequest(reqHeaders);\n        if (Constants.DEFAULT_ORIGIN_HEADER_VALUE != null\n                && !reqHeaders.containsKey(Constants.ORIGIN_HEADER_NAME)) {\n            List<String> originValues = new ArrayList<>(1);\n            originValues.add(Constants.DEFAULT_ORIGIN_HEADER_VALUE);\n            reqHeaders.put(Constants.ORIGIN_HEADER_NAME, originValues);\n        }\n        ByteBuffer request = createRequest(path, reqHeaders);\n\n        AsynchronousSocketChannel socketChannel;\n        try {\n            socketChannel = AsynchronousSocketChannel.open(getAsynchronousChannelGroup());\n        } catch (IOException ioe) {\n            throw new DeploymentException(sm.getString(\n                    \"wsWebSocketContainer.asynchronousSocketChannelFail\"), ioe);\n        }\n\n        Map<String,Object> userProperties = clientEndpointConfiguration.getUserProperties();\n\n        long timeout = Constants.IO_TIMEOUT_MS_DEFAULT;\n        String timeoutValue = (String) userProperties.get(Constants.IO_TIMEOUT_MS_PROPERTY);\n        if (timeoutValue != null) {\n            timeout = Long.valueOf(timeoutValue).intValue();\n        }\n\n        ByteBuffer response = ByteBuffer.allocate(getDefaultMaxBinaryMessageBufferSize());\n        String subProtocol;\n        boolean success = false;\n        List<Extension> extensionsAgreed = new ArrayList<>();\n        Transformation transformation = null;\n\n        Future<Void> fConnect = socketChannel.connect(sa);\n        AsyncChannelWrapper channel = null;\n\n        if (proxyConnect != null) {\n            try {\n                fConnect.get(timeout, TimeUnit.MILLISECONDS);\n                channel = new AsyncChannelWrapperNonSecure(socketChannel);\n                writeRequest(channel, proxyConnect, timeout);\n                HttpResponse httpResponse = processResponse(response, channel, timeout);\n                if (httpResponse.getStatus() != 200) {\n                    throw new DeploymentException(sm.getString(\n                            \"wsWebSocketContainer.proxyConnectFail\", selectedProxy,\n                            Integer.toString(httpResponse.getStatus())));\n                }\n            } catch (TimeoutException | InterruptedException | ExecutionException |\n                    EOFException e) {\n                if (channel != null) {\n                    channel.close();\n                }\n                throw new DeploymentException(\n                        sm.getString(\"wsWebSocketContainer.httpRequestFailed\"), e);\n            }\n        }\n\n        if (secure) {\n            SSLEngine sslEngine = createSSLEngine(userProperties, host, port);\n            channel = new AsyncChannelWrapperSecure(socketChannel, sslEngine);\n        } else if (channel == null) {\n            channel = new AsyncChannelWrapperNonSecure(socketChannel);\n        }\n\n        try {\n            fConnect.get(timeout, TimeUnit.MILLISECONDS);\n\n            Future<Void> fHandshake = channel.handshake();\n            fHandshake.get(timeout, TimeUnit.MILLISECONDS);\n\n            writeRequest(channel, request, timeout);\n\n            HttpResponse httpResponse = processResponse(response, channel, timeout);\n\n            int maxRedirects = Constants.MAX_REDIRECTIONS_DEFAULT;\n            String maxRedirectsValue =\n                    (String) userProperties.get(Constants.MAX_REDIRECTIONS_PROPERTY);\n            if (maxRedirectsValue != null) {\n                maxRedirects = Integer.parseInt(maxRedirectsValue);\n            }\n\n            if (httpResponse.status != 101) {\n                if(isRedirectStatus(httpResponse.status)){\n                    List<String> locationHeader =\n                            httpResponse.getHandshakeResponse().getHeaders().get(\n                                    Constants.LOCATION_HEADER_NAME);\n\n                    if (locationHeader == null || locationHeader.isEmpty() ||\n                            locationHeader.get(0) == null || locationHeader.get(0).isEmpty()) {\n                        throw new DeploymentException(sm.getString(\n                                \"wsWebSocketContainer.missingLocationHeader\",\n                                Integer.toString(httpResponse.status)));\n                    }\n\n                    URI redirectLocation = URI.create(locationHeader.get(0)).normalize();\n\n                    if (!redirectLocation.isAbsolute()) {\n                        redirectLocation = path.resolve(redirectLocation);\n                    }\n\n                    String redirectScheme = redirectLocation.getScheme().toLowerCase();\n\n                    if (redirectScheme.startsWith(\"http\")) {\n                        redirectLocation = new URI(redirectScheme.replace(\"http\", \"ws\"),\n                                redirectLocation.getUserInfo(), redirectLocation.getHost(),\n                                redirectLocation.getPort(), redirectLocation.getPath(),\n                                redirectLocation.getQuery(), redirectLocation.getFragment());\n                    }\n\n                    if (!redirectSet.add(redirectLocation) || redirectSet.size() > maxRedirects) {\n                        throw new DeploymentException(sm.getString(\n                                \"wsWebSocketContainer.redirectThreshold\", redirectLocation,\n                                Integer.toString(redirectSet.size()),\n                                Integer.toString(maxRedirects)));\n                    }\n\n                    return connectToServerRecursive(endpoint, clientEndpointConfiguration, redirectLocation, redirectSet);\n\n                }\n\n                else if (httpResponse.status == 401) {\n\n                    if (userProperties.get(Constants.AUTHORIZATION_HEADER_NAME) != null) {\n                        throw new DeploymentException(sm.getString(\n                                \"wsWebSocketContainer.failedAuthentication\",\n                                Integer.valueOf(httpResponse.status)));\n                    }\n\n                    List<String> wwwAuthenticateHeaders = httpResponse.getHandshakeResponse()\n                            .getHeaders().get(Constants.WWW_AUTHENTICATE_HEADER_NAME);\n\n                    if (wwwAuthenticateHeaders == null || wwwAuthenticateHeaders.isEmpty() ||\n                            wwwAuthenticateHeaders.get(0) == null || wwwAuthenticateHeaders.get(0).isEmpty()) {\n                        throw new DeploymentException(sm.getString(\n                                \"wsWebSocketContainer.missingWWWAuthenticateHeader\",\n                                Integer.toString(httpResponse.status)));\n                    }\n\n                    String authScheme = wwwAuthenticateHeaders.get(0).split(\"\\\\s+\", 2)[0];\n                    String requestUri = new String(request.array(), StandardCharsets.ISO_8859_1)\n                            .split(\"\\\\s\", 3)[1];\n\n                    Authenticator auth = AuthenticatorFactory.getAuthenticator(authScheme);\n\n                    if (auth == null) {\n                        throw new DeploymentException(\n                                sm.getString(\"wsWebSocketContainer.unsupportedAuthScheme\",\n                                        Integer.valueOf(httpResponse.status), authScheme));\n                    }\n\n                    userProperties.put(Constants.AUTHORIZATION_HEADER_NAME, auth.getAuthorization(\n                            requestUri, wwwAuthenticateHeaders.get(0), userProperties));\n\n                    return connectToServerRecursive(endpoint, clientEndpointConfiguration, path, redirectSet);\n\n                }\n\n                else {\n                    throw new DeploymentException(sm.getString(\"wsWebSocketContainer.invalidStatus\",\n                            Integer.toString(httpResponse.status)));\n                }\n            }\n            HandshakeResponse handshakeResponse = httpResponse.getHandshakeResponse();\n            clientEndpointConfiguration.getConfigurator().afterResponse(handshakeResponse);\n\n            List<String> protocolHeaders = handshakeResponse.getHeaders().get(\n                    Constants.WS_PROTOCOL_HEADER_NAME);\n            if (protocolHeaders == null || protocolHeaders.size() == 0) {\n                subProtocol = null;\n            } else if (protocolHeaders.size() == 1) {\n                subProtocol = protocolHeaders.get(0);\n            } else {\n                throw new DeploymentException(\n                        sm.getString(\"wsWebSocketContainer.invalidSubProtocol\"));\n            }\n\n            List<String> extHeaders = handshakeResponse.getHeaders().get(\n                    Constants.WS_EXTENSIONS_HEADER_NAME);\n            if (extHeaders != null) {\n                for (String extHeader : extHeaders) {\n                    Util.parseExtensionHeader(extensionsAgreed, extHeader);\n                }\n            }\n\n            TransformationFactory factory = TransformationFactory.getInstance();\n            for (Extension extension : extensionsAgreed) {\n                List<List<Extension.Parameter>> wrapper = new ArrayList<>(1);\n                wrapper.add(extension.getParameters());\n                Transformation t = factory.create(extension.getName(), wrapper, false);\n                if (t == null) {\n                    throw new DeploymentException(sm.getString(\n                            \"wsWebSocketContainer.invalidExtensionParameters\"));\n                }\n                if (transformation == null) {\n                    transformation = t;\n                } else {\n                    transformation.setNext(t);\n                }\n            }\n\n            success = true;\n        } catch (ExecutionException | InterruptedException | SSLException |\n                EOFException | TimeoutException | URISyntaxException | AuthenticationException e) {\n            throw new DeploymentException(\n                    sm.getString(\"wsWebSocketContainer.httpRequestFailed\"), e);\n        } finally {\n            if (!success) {\n                channel.close();\n            }\n        }\n\n        WsRemoteEndpointImplClient wsRemoteEndpointClient = new WsRemoteEndpointImplClient(channel);\n\n        WsSession wsSession = new WsSession(endpoint, wsRemoteEndpointClient,\n                this, null, null, null, null, null, extensionsAgreed,\n                subProtocol, Collections.<String,String>emptyMap(), secure,\n                clientEndpointConfiguration);\n\n        WsFrameClient wsFrameClient = new WsFrameClient(response, channel,\n                wsSession, transformation);\n        wsRemoteEndpointClient.setTransformation(wsFrameClient.getTransformation());\n\n        endpoint.onOpen(wsSession, clientEndpointConfiguration);\n        registerSession(endpoint, wsSession);\n\n        wsFrameClient.startInputProcessing();\n\n        return wsSession;\n// fix_end\n", "cwe": "CWE-295", "cwe_name": "Improper Certificate Validation", "idx": 40074}
{"source": "// bug_start\n@Override\n        public int fill(ByteBuffer buffer) throws IOException\n        {\n            try\n            {\n                synchronized (_decryptedEndPoint)\n                {\n                    if (LOG.isDebugEnabled())\n                        LOG.debug(\">fill {}\", SslConnection.this);\n// bug_end\n \n// bug_start\n                    int filled = -2;\n                    try\n                    {\n                        if (_fillState != FillState.IDLE)\n                            return filled = 0;\n\n                        if (BufferUtil.hasContent(_decryptedInput))\n                            return filled = BufferUtil.append(buffer, _decryptedInput);\n\n                        while (true)\n                        {\n                            HandshakeStatus status = _sslEngine.getHandshakeStatus();\n                            if (LOG.isDebugEnabled())\n                                LOG.debug(\"fill {}\", status);\n                            switch (status)\n                            {\n                                case NEED_UNWRAP:\n                                case NOT_HANDSHAKING:\n                                    break;\n\n                                case NEED_TASK:\n                                    _sslEngine.getDelegatedTask().run();\n                                    continue;\n\n                                case NEED_WRAP:\n                                    if (_flushState == FlushState.IDLE && flush(BufferUtil.EMPTY_BUFFER))\n                                    {\n                                        Throwable failure = _failure;\n                                        if (failure != null)\n                                            rethrow(failure);\n                                        if (_sslEngine.isInboundDone())\n                                            return filled = -1;\n                                        continue;\n                                    }\n                                    return filled = 0;\n\n                                default:\n                                    throw new IllegalStateException(\"Unexpected HandshakeStatus \" + status);\n                            }\n\n                            acquireEncryptedInput();\n\n                            ByteBuffer appIn;\n                            int appBufferSize = getApplicationBufferSize();\n                            if (_decryptedInput == null)\n                            {\n                                if (BufferUtil.space(buffer) > appBufferSize)\n                                    appIn = buffer;\n                                else\n                                    appIn = _decryptedInput = _bufferPool.acquire(appBufferSize, _decryptedDirectBuffers);\n                            }\n                            else\n                            {\n                                appIn = _decryptedInput;\n                                BufferUtil.compact(_encryptedInput);\n                            }\n\n                            int netFilled = networkFill(_encryptedInput);\n                            if (LOG.isDebugEnabled())\n                                LOG.debug(\"net filled={}\", netFilled);\n\n                            if (netFilled < 0 && isHandshakeInitial() && BufferUtil.isEmpty(_encryptedInput))\n                                closeInbound();\n\n                            if (netFilled > 0 && !isHandshakeComplete() && isOutboundDone())\n                                throw new SSLHandshakeException(\"Closed during handshake\");\n\n                            if (_handshake.compareAndSet(HandshakeState.INITIAL, HandshakeState.HANDSHAKE))\n                            {\n                                if (LOG.isDebugEnabled())\n                                    LOG.debug(\"fill starting handshake {}\", SslConnection.this);\n                            }\n\n                            int pos = BufferUtil.flipToFill(appIn);\n                            SSLEngineResult unwrapResult;\n                            try\n                            {\n                                _underflown = false;\n                                unwrapResult = unwrap(_sslEngine, _encryptedInput, appIn);\n                            }\n                            finally\n                            {\n                                BufferUtil.flipToFlush(appIn, pos);\n                            }\n                            if (LOG.isDebugEnabled())\n                                LOG.debug(\"unwrap net_filled={} {} encryptedBuffer={} unwrapBuffer={} appBuffer={}\",\n                                    netFilled,\n                                    StringUtil.replace(unwrapResult.toString(), '\\n', ' '),\n                                    BufferUtil.toSummaryString(_encryptedInput),\n                                    BufferUtil.toDetailString(appIn),\n                                    BufferUtil.toDetailString(buffer));\n\n                            SSLEngineResult.Status unwrap = unwrapResult.getStatus();\n\n                            if (unwrap == Status.OK && unwrapResult.bytesConsumed() == 0 && unwrapResult.bytesProduced() == 0)\n                                unwrap = Status.BUFFER_UNDERFLOW;\n\n                            switch (unwrap)\n                            {\n                                case CLOSED:\n                                    Throwable failure = _failure;\n                                    if (failure != null)\n                                        rethrow(failure);\n                                    return filled = -1;\n\n                                case BUFFER_UNDERFLOW:\n                                    if (BufferUtil.space(_encryptedInput) == 0)\n                                    {\n                                        BufferUtil.clear(_encryptedInput);\n                                        throw new SSLHandshakeException(\"Encrypted buffer max length exceeded\");\n                                    }\n\n                                    if (netFilled > 0)\n                                        continue;\n\n                                    _underflown = true;\n                                    if (netFilled < 0 && _sslEngine.getUseClientMode())\n                                    {\n                                        Throwable closeFailure = closeInbound();\n                                        if (_flushState == FlushState.WAIT_FOR_FILL)\n                                        {\n                                            Throwable handshakeFailure = new SSLHandshakeException(\"Abruptly closed by peer\");\n                                            if (closeFailure != null)\n                                                handshakeFailure.addSuppressed(closeFailure);\n                                            throw handshakeFailure;\n                                        }\n                                        return filled = -1;\n                                    }\n                                    return filled = netFilled;\n\n                                case BUFFER_OVERFLOW:\n                                    if (BufferUtil.isEmpty(_decryptedInput) && appBufferSize < getApplicationBufferSize())\n                                    {\n                                        releaseDecryptedInputBuffer();\n                                        continue;\n                                    }\n                                    throw new IllegalStateException(\"Unexpected unwrap result \" + unwrap);\n\n                                case OK:\n                                    if (unwrapResult.getHandshakeStatus() == HandshakeStatus.FINISHED)\n                                        handshakeSucceeded();\n\n                                    if (isRenegotiating() && !allowRenegotiate())\n                                        return filled = -1;\n\n                                    if (unwrapResult.bytesProduced() > 0)\n                                    {\n                                        if (appIn == buffer)\n                                            return filled = unwrapResult.bytesProduced();\n                                        return filled = BufferUtil.append(buffer, _decryptedInput);\n                                    }\n\n                                    break;\n\n                                default:\n                                    throw new IllegalStateException(\"Unexpected unwrap result \" + unwrap);\n                            }\n                        }\n                    }\n                    catch (Throwable x)\n                    {\n                        Throwable f = handleException(x, \"fill\");\n                        Throwable failure = handshakeFailed(f);\n                        if (_flushState == FlushState.WAIT_FOR_FILL)\n                        {\n                            _flushState = FlushState.IDLE;\n                            getExecutor().execute(() -> _decryptedEndPoint.getWriteFlusher().onFail(failure));\n                        }\n                        throw failure;\n                    }\n                    finally\n                    {\n                        releaseEncryptedInputBuffer();\n                        releaseDecryptedInputBuffer();\n\n                        if (_flushState == FlushState.WAIT_FOR_FILL)\n                        {\n                            _flushState = FlushState.IDLE;\n                            getExecutor().execute(() -> _decryptedEndPoint.getWriteFlusher().completeWrite());\n                        }\n\n                        if (LOG.isDebugEnabled())\n                            LOG.debug(\"<fill f={} uf={} {}\", filled, _underflown, SslConnection.this);\n                    }\n                }\n            }\n            catch (Throwable x)\n            {\n                close(x);\n                rethrow(x);\n                throw new AssertionError();\n            }\n        }\n\n// bug_end\n", "target": "// fix_start\nstatic protected UTF8Buffer readUTF(DataByteArrayInputStream is) throws ProtocolException {\n        int size = is.readUnsignedShort();\n        if (size < 0) {\n            throw new ProtocolException(\"Invalid message encoding\");\n        }\n        Buffer buffer = is.readBuffer(size);\n        if (buffer == null || buffer.length != size) {\n            throw new ProtocolException(\"Invalid message encoding\");\n        }\n        return buffer.utf8();\n    }\n// fix_end\n", "cwe": "NVD-CWE-noinfo", "cwe_name": "", "idx": 102080}
{"source": " public void parseCentralDirectoryFormat(final byte[] data, final int offset, final int length) {\n         this.format = ZipShort.getValue(data, offset);\n         this.algId = EncryptionAlgorithm.getAlgorithmByCode(ZipShort.getValue(data, offset + 2));\n         this.bitlen = ZipShort.getValue(data, offset + 4);\n         this.flags = ZipShort.getValue(data, offset + 6);\n         this.rcount = ZipLong.getValue(data, offset + 8);\n \n         if (rcount > 0) {\n             this.hashAlg = HashAlgorithm.getAlgorithmByCode(ZipShort.getValue(data, offset + 12));\n             this.hashSize = ZipShort.getValue(data, offset + 14);\n// bug_start\n            for (int i = 0; i < this.rcount; i++) {\n// bug_end\n                 for (int j = 0; j < this.hashSize; j++) {\n                 }\n             }\n         }\n     }\n \n", "target": "// fix_start\n            for (long i = 0; i < this.rcount; i++) {\n// fix_end\n", "cwe": "CWE-835", "cwe_name": "Loop with Unreachable Exit Condition ('Infinite Loop')", "idx": 82758}
{"source": "// bug_start\nprotected SchemaFactory createSchemaFactory() {\n        SchemaFactory factory = SchemaFactory.newInstance(schemaLanguage);\n        if (getResourceResolver() != null) {\n            factory.setResourceResolver(getResourceResolver());\n        }\n        return factory;\n    }\n// bug_end\n \n", "target": "// fix_start\nprivate Schema loadSchema(String schemaResource) {\n\t\tClassLoader loader = run( GetClassLoader.fromClass( XmlParserHelper.class ) );\n// fix_end\n// fix_start\n\t\tURL schemaUrl = run( GetResource.action( loader, schemaResource ) );\n\t\tSchemaFactory sf = SchemaFactory.newInstance( javax.xml.XMLConstants.W3C_XML_SCHEMA_NS_URI );\n\t\tSchema schema = null;\n\t\ttry {\n\t\t\tschema = sf.newSchema( schemaUrl );\n\t\t}\n\t\tcatch ( SAXException e ) {\n\t\t\tlog.unableToCreateSchema( schemaResource, e.getMessage() );\n\t\t}\n\t\treturn schema;\n\t}\n\n// fix_end\n", "cwe": "CWE-611", "cwe_name": "Improper Restriction of XML External Entity Reference ('XXE')", "idx": 66948}
{"source": "// bug_start\nprivate Schema loadSchema(String schemaResource) {\n\t\tClassLoader loader = run( GetClassLoader.fromClass( XmlParserHelper.class ) );\n// bug_end\n \n// bug_start\n\t\tURL schemaUrl = loader.getResource( schemaResource );\n\t\tSchemaFactory sf = SchemaFactory.newInstance( javax.xml.XMLConstants.W3C_XML_SCHEMA_NS_URI );\n\t\tSchema schema = null;\n\t\ttry {\n\t\t\tschema = sf.newSchema( schemaUrl );\n\t\t}\n\t\tcatch ( SAXException e ) {\n\t\t\tlog.unableToCreateSchema( schemaResource, e.getMessage() );\n\t\t}\n\t\treturn schema;\n\t}\n\n// bug_end\n", "target": "// fix_start\n@After\n    public void cleanUpDomainList() throws Exception {\n        IdentityZoneHolder.clear();\n        IdentityProvider<UaaIdentityProviderDefinition> uaaProvider = getWebApplicationContext().getBean(JdbcIdentityProviderProvisioning.class).retrieveByOrigin(UAA, IdentityZone.getUaa().getId());\n        uaaProvider.getConfig().setEmailDomain(null);\n        getWebApplicationContext().getBean(JdbcIdentityProviderProvisioning.class).update(uaaProvider);\n    }\n// fix_end\n", "cwe": "CWE-264", "cwe_name": "Permissions, Privileges, and Access Controls", "idx": 30735}
{"source": "// bug_start\n@After\n    public void cleanUpDomainList() throws Exception {\n        IdentityProvider<UaaIdentityProviderDefinition> uaaProvider = getWebApplicationContext().getBean(JdbcIdentityProviderProvisioning.class).retrieveByOrigin(UAA, IdentityZone.getUaa().getId());\n        uaaProvider.getConfig().setEmailDomain(null);\n        getWebApplicationContext().getBean(JdbcIdentityProviderProvisioning.class).update(uaaProvider);\n    }\n// bug_end\n \n", "target": "// fix_start\n@RequirePOST\n        public FormValidation doValidateProxy(\n                @QueryParameter(\"testUrl\") String testUrl, @QueryParameter(\"name\") String name, @QueryParameter(\"port\") int port,\n                @QueryParameter(\"userName\") String userName, @QueryParameter(\"password\") String password,\n                @QueryParameter(\"noProxyHost\") String noProxyHost) {\n// fix_end\n// fix_start\n            Jenkins.getInstance().checkPermission(Jenkins.ADMINISTER);\n\n            if (Util.fixEmptyAndTrim(testUrl) == null) {\n                return FormValidation.error(Messages.ProxyConfiguration_TestUrlRequired());\n            }\n\n            String host = testUrl;\n            try {\n                URL url = new URL(testUrl);\n                host = url.getHost();\n            } catch (MalformedURLException e) {\n                return FormValidation.error(Messages.ProxyConfiguration_MalformedTestUrl(testUrl));\n            }\n\n            GetMethod method = null;\n            try {\n                method = new GetMethod(testUrl);\n                method.getParams().setParameter(\"http.socket.timeout\", DEFAULT_CONNECT_TIMEOUT_MILLIS > 0 ? DEFAULT_CONNECT_TIMEOUT_MILLIS : new Integer(30 * 1000));\n\n                HttpClient client = new HttpClient();\n                if (Util.fixEmptyAndTrim(name) != null && !isNoProxyHost(host, noProxyHost)) {\n                    client.getHostConfiguration().setProxy(name, port);\n                    Credentials credentials = createCredentials(userName, password);\n                    AuthScope scope = new AuthScope(AuthScope.ANY_HOST, AuthScope.ANY_PORT);\n                    client.getState().setProxyCredentials(scope, credentials);\n                }\n\n                int code = client.executeMethod(method);\n                if (code != HttpURLConnection.HTTP_OK) {\n                    return FormValidation.error(Messages.ProxyConfiguration_FailedToConnect(testUrl, code));\n                }\n            } catch (IOException e) {\n                return FormValidation.error(e, Messages.ProxyConfiguration_FailedToConnectViaProxy(testUrl));\n            } finally {\n                if (method != null) {\n                    method.releaseConnection();\n                }\n            }\n\n            return FormValidation.ok(Messages.ProxyConfiguration_Success());\n        }\n\n// fix_end\n", "cwe": "CWE-269", "cwe_name": "Improper Privilege Management", "idx": 35961}
{"source": "// bug_start\n@RequirePOST\n        public FormValidation doValidateProxy(\n                @QueryParameter(\"testUrl\") String testUrl, @QueryParameter(\"name\") String name, @QueryParameter(\"port\") int port,\n                @QueryParameter(\"userName\") String userName, @QueryParameter(\"password\") String password,\n                @QueryParameter(\"noProxyHost\") String noProxyHost) {\n// bug_end\n \n// bug_start\n            if (Util.fixEmptyAndTrim(testUrl) == null) {\n                return FormValidation.error(Messages.ProxyConfiguration_TestUrlRequired());\n// bug_end\n             }\n \n// bug_start\n            String host = testUrl;\n            try {\n                URL url = new URL(testUrl);\n                host = url.getHost();\n            } catch (MalformedURLException e) {\n                return FormValidation.error(Messages.ProxyConfiguration_MalformedTestUrl(testUrl));\n            }\n\n            GetMethod method = null;\n            try {\n                method = new GetMethod(testUrl);\n                method.getParams().setParameter(\"http.socket.timeout\", DEFAULT_CONNECT_TIMEOUT_MILLIS > 0 ? DEFAULT_CONNECT_TIMEOUT_MILLIS : new Integer(30 * 1000));\n\n                HttpClient client = new HttpClient();\n                if (Util.fixEmptyAndTrim(name) != null && !isNoProxyHost(host, noProxyHost)) {\n                    client.getHostConfiguration().setProxy(name, port);\n                    Credentials credentials = createCredentials(userName, password);\n                    AuthScope scope = new AuthScope(AuthScope.ANY_HOST, AuthScope.ANY_PORT);\n                    client.getState().setProxyCredentials(scope, credentials);\n                }\n\n                int code = client.executeMethod(method);\n                if (code != HttpURLConnection.HTTP_OK) {\n                    return FormValidation.error(Messages.ProxyConfiguration_FailedToConnect(testUrl, code));\n                }\n            } catch (IOException e) {\n                return FormValidation.error(e, Messages.ProxyConfiguration_FailedToConnectViaProxy(testUrl));\n            } finally {\n                if (method != null) {\n                    method.releaseConnection();\n                }\n            }\n\n            return FormValidation.ok(Messages.ProxyConfiguration_Success());\n// bug_end\n         }\n \n", "target": "// fix_start\n@Override\n    public void invoke(Request request, Response response)\n        throws IOException, ServletException {\n// fix_end\n// fix_start\n        if (log.isDebugEnabled())\n            log.debug(\"Security checking request \" +\n                request.getMethod() + \" \" + request.getRequestURI());\n        LoginConfig config = this.context.getLoginConfig();\n\n        if (cache) {\n            Principal principal = request.getUserPrincipal();\n            if (principal == null) {\n                Session session = request.getSessionInternal(false);\n                if (session != null) {\n                    principal = session.getPrincipal();\n                    if (principal != null) {\n                        if (log.isDebugEnabled())\n                            log.debug(\"We have cached auth type \" +\n                                session.getAuthType() +\n                                \" for principal \" +\n                                session.getPrincipal());\n                        request.setAuthType(session.getAuthType());\n                        request.setUserPrincipal(principal);\n                    }\n                }\n            }\n        }\n\n        String contextPath = this.context.getPath();\n        String requestURI = request.getDecodedRequestURI();\n        if (requestURI.startsWith(contextPath) &&\n            requestURI.endsWith(Constants.FORM_ACTION)) {\n            if (!authenticate(request, response, config)) {\n                if (log.isDebugEnabled())\n                    log.debug(\" Failed authenticate() test ??\" + requestURI );\n                return;\n            }\n        }\n\n        Wrapper wrapper = (Wrapper) request.getMappingData().wrapper;\n        if (wrapper.getServlet() != null) {\n            wrapper.load();\n        }\n\n        Realm realm = this.context.getRealm();\n        SecurityConstraint [] constraints\n            = realm.findSecurityConstraints(request, this.context);\n\n        if ((constraints == null)  ) {\n            if (log.isDebugEnabled())\n                log.debug(\" Not subject to any constraint\");\n            getNext().invoke(request, response);\n            return;\n        }\n\n        if (disableProxyCaching &&\n            !\"POST\".equalsIgnoreCase(request.getMethod())) {\n            if (securePagesWithPragma) {\n                response.setHeader(\"Pragma\", \"No-cache\");\n                response.setHeader(\"Cache-Control\", \"no-cache\");\n            } else {\n                response.setHeader(\"Cache-Control\", \"private\");\n            }\n            response.setHeader(\"Expires\", DATE_ONE);\n        }\n\n        int i;\n        if (log.isDebugEnabled()) {\n            log.debug(\" Calling hasUserDataPermission()\");\n        }\n        if (!realm.hasUserDataPermission(request, response,\n                                         constraints)) {\n            if (log.isDebugEnabled()) {\n                log.debug(\" Failed hasUserDataPermission() test\");\n            }\n            return;\n        }\n\n        boolean authRequired = true;\n        for(i=0; i < constraints.length && authRequired; i++) {\n            if(!constraints[i].getAuthConstraint()) {\n                authRequired = false;\n            } else if(!constraints[i].getAllRoles()) {\n                String [] roles = constraints[i].findAuthRoles();\n                if(roles == null || roles.length == 0) {\n                    authRequired = false;\n                }\n            }\n        }\n\n        if(authRequired) {\n            if (log.isDebugEnabled()) {\n                log.debug(\" Calling authenticate()\");\n            }\n            if (!authenticate(request, response, config)) {\n                if (log.isDebugEnabled()) {\n                    log.debug(\" Failed authenticate() test\");\n                }\n                return;\n// fix_end\n// fix_start\n// fix_end\n// fix_start\n        if (log.isDebugEnabled()) {\n            log.debug(\" Calling accessControl()\");\n        }\n        if (!realm.hasResourcePermission(request, response,\n                                         constraints,\n                                         this.context)) {\n            if (log.isDebugEnabled()) {\n                log.debug(\" Failed accessControl() test\");\n            }\n            return;\n        }\n\n        if (log.isDebugEnabled()) {\n            log.debug(\" Successfully passed all security constraints\");\n        }\n        getNext().invoke(request, response);\n\n    }\n\n// fix_end\n", "cwe": "CWE-918", "cwe_name": "Server-Side Request Forgery (SSRF)", "idx": 94362}
{"source": " @Override\n// bug_start\n    public void setAttribute(String name, Object value) {\n// bug_end\n \n// bug_start\n        if (name == null)\n            throw new IllegalArgumentException\n                (sm.getString(\"coyoteRequest.setAttribute.namenull\"));\n// bug_end\n \n// bug_start\n        if (value == null) {\n            removeAttribute(name);\n// bug_end\n             return;\n         }\n \n// bug_start\n        if (name.equals(Globals.DISPATCHER_TYPE_ATTR)) {\n            internalDispatcherType = (DispatcherType)value;\n            return;\n        } else if (name.equals(Globals.DISPATCHER_REQUEST_PATH_ATTR)) {\n            requestDispatcherPath = value;\n// bug_end\n             return;\n         }\n \n// bug_start\n        if (name.equals(Globals.ASYNC_SUPPORTED_ATTR)) {\n            this.asyncSupported = (Boolean)value;\n// bug_end\n         }\n \n// bug_start\n        Object oldValue = null;\n        boolean replaced = false;\n// bug_end\n \n// bug_start\n        if (readOnlyAttributes.containsKey(name)) {\n// bug_end\n             return;\n         }\n \n// bug_start\n        oldValue = attributes.put(name, value);\n        if (oldValue != null) {\n            replaced = true;\n// bug_end\n         }\n// bug_start\n// bug_end\n \n// bug_start\n        if (name.startsWith(\"org.apache.tomcat.\")) {\n            coyoteRequest.setAttribute(name, value);\n        }\n\n        Object listeners[] = context.getApplicationEventListeners();\n        if ((listeners == null) || (listeners.length == 0))\n            return;\n        ServletRequestAttributeEvent event = null;\n        if (replaced)\n            event =\n                new ServletRequestAttributeEvent(context.getServletContext(),\n                                                 getRequest(), name, oldValue);\n        else\n            event =\n                new ServletRequestAttributeEvent(context.getServletContext(),\n                                                 getRequest(), name, value);\n\n        for (int i = 0; i < listeners.length; i++) {\n            if (!(listeners[i] instanceof ServletRequestAttributeListener))\n                continue;\n            ServletRequestAttributeListener listener =\n                (ServletRequestAttributeListener) listeners[i];\n            try {\n                if (replaced) {\n                    listener.attributeReplaced(event);\n                } else {\n                    listener.attributeAdded(event);\n                }\n            } catch (Throwable t) {\n                ExceptionUtils.handleThrowable(t);\n                context.getLogger().error(sm.getString(\"coyoteRequest.attributeEvent\"), t);\n                attributes.put(RequestDispatcher.ERROR_EXCEPTION, t );\n            }\n        }\n// bug_end\n     }\n \n", "target": "// fix_start\n    public void invoke(Request request, Response response)\n        throws IOException, ServletException {\n// fix_end\n// fix_start\n        if (log.isDebugEnabled())\n            log.debug(\"Security checking request \" +\n                request.getMethod() + \" \" + request.getRequestURI());\n        LoginConfig config = this.context.getLoginConfig();\n// fix_end\n// fix_start\n        if (cache) {\n            Principal principal = request.getUserPrincipal();\n            if (principal == null) {\n                Session session = request.getSessionInternal(false);\n                if (session != null) {\n                    principal = session.getPrincipal();\n                    if (principal != null) {\n                        if (log.isDebugEnabled())\n                            log.debug(\"We have cached auth type \" +\n                                session.getAuthType() +\n                                \" for principal \" +\n                                session.getPrincipal());\n                        request.setAuthType(session.getAuthType());\n                        request.setUserPrincipal(principal);\n                    }\n                }\n            }\n        }\n\n        String contextPath = this.context.getPath();\n        String requestURI = request.getDecodedRequestURI();\n        if (requestURI.startsWith(contextPath) &&\n            requestURI.endsWith(Constants.FORM_ACTION)) {\n            if (!authenticate(request, response, config)) {\n                if (log.isDebugEnabled())\n                    log.debug(\" Failed authenticate() test ??\" + requestURI );\n                return;\n            }\n        }\n\n        Wrapper wrapper = (Wrapper) request.getMappingData().wrapper;\n        if (wrapper.getServlet() == null) {\n            wrapper.load();\n        }\n\n        Realm realm = this.context.getRealm();\n        SecurityConstraint [] constraints\n            = realm.findSecurityConstraints(request, this.context);\n\n        if ((constraints == null)  ) {\n            if (log.isDebugEnabled())\n                log.debug(\" Not subject to any constraint\");\n            getNext().invoke(request, response);\n// fix_end\n// fix_start\n        if (disableProxyCaching &&\n            !\"POST\".equalsIgnoreCase(request.getMethod())) {\n            if (securePagesWithPragma) {\n                response.setHeader(\"Pragma\", \"No-cache\");\n                response.setHeader(\"Cache-Control\", \"no-cache\");\n            } else {\n                response.setHeader(\"Cache-Control\", \"private\");\n            }\n            response.setHeader(\"Expires\", DATE_ONE);\n        }\n\n        int i;\n        if (log.isDebugEnabled()) {\n            log.debug(\" Calling hasUserDataPermission()\");\n        }\n        if (!realm.hasUserDataPermission(request, response,\n                                         constraints)) {\n            if (log.isDebugEnabled()) {\n                log.debug(\" Failed hasUserDataPermission() test\");\n            }\n// fix_end\n// fix_start\n        boolean authRequired = true;\n        for(i=0; i < constraints.length && authRequired; i++) {\n            if(!constraints[i].getAuthConstraint()) {\n                authRequired = false;\n            } else if(!constraints[i].getAllRoles()) {\n                String [] roles = constraints[i].findAuthRoles();\n                if(roles == null || roles.length == 0) {\n                    authRequired = false;\n                }\n            }\n// fix_end\n// fix_start\n        if(authRequired) {\n            if (log.isDebugEnabled()) {\n                log.debug(\" Calling authenticate()\");\n            }\n            if (!authenticate(request, response, config)) {\n                if (log.isDebugEnabled()) {\n                    log.debug(\" Failed authenticate() test\");\n                }\n                return;\n            }\n// fix_end\n// fix_start\n        }\n\n        if (log.isDebugEnabled()) {\n            log.debug(\" Calling accessControl()\");\n        }\n        if (!realm.hasResourcePermission(request, response,\n                                         constraints,\n                                         this.context)) {\n            if (log.isDebugEnabled()) {\n                log.debug(\" Failed accessControl() test\");\n            }\n// fix_end\n// fix_start\n        if (log.isDebugEnabled()) {\n            log.debug(\" Successfully passed all security constraints\");\n// fix_end\n// fix_start\n        getNext().invoke(request, response);\n// fix_end\n// fix_start\n// fix_end\n", "cwe": "NVD-CWE-Other", "cwe_name": "Other", "idx": 111284}
{"source": "// bug_start\npublic static C3P0Config extractXmlConfigFromInputStream(InputStream is) throws Exception\n    {\n        DocumentBuilderFactory fact = DocumentBuilderFactory.newInstance();\n        DocumentBuilder db = fact.newDocumentBuilder();\n        Document doc = db.parse( is );\n// bug_end\n \n// bug_start\n        return extractConfigFromXmlDoc(doc);\n// bug_end\n     }\n \n", "target": "// fix_start\n@Override\n    public void setAttribute(String name, Object value) {\n// fix_end\n// fix_start\n        if (name == null)\n            throw new IllegalArgumentException\n                (sm.getString(\"coyoteRequest.setAttribute.namenull\"));\n\n        if (value == null) {\n            removeAttribute(name);\n            return;\n        }\n\n        if (name.equals(Globals.DISPATCHER_TYPE_ATTR)) {\n            internalDispatcherType = (DispatcherType)value;\n            return;\n        } else if (name.equals(Globals.DISPATCHER_REQUEST_PATH_ATTR)) {\n            requestDispatcherPath = value;\n            return;\n        }\n\n        if (name.equals(Globals.ASYNC_SUPPORTED_ATTR)) {\n            this.asyncSupported = (Boolean)value;\n        }\n\n        Object oldValue = null;\n        boolean replaced = false;\n\n        if (readOnlyAttributes.containsKey(name)) {\n            return;\n        }\n\n        if (Globals.IS_SECURITY_ENABLED &&\n                name.equals(\"org.apache.tomcat.sendfile.filename\")) {\n            String canonicalPath;\n            try {\n                canonicalPath = new File(value.toString()).getCanonicalPath();\n            } catch (IOException e) {\n                throw new SecurityException(sm.getString(\n                        \"coyoteRequest.sendfileNotCanonical\", value), e);\n            }\n            System.getSecurityManager().checkRead(canonicalPath);\n            value = canonicalPath;\n        }\n\n        oldValue = attributes.put(name, value);\n        if (oldValue != null) {\n            replaced = true;\n        }\n\n        if (name.startsWith(\"org.apache.tomcat.\")) {\n            coyoteRequest.setAttribute(name, value);\n        }\n\n        Object listeners[] = context.getApplicationEventListeners();\n        if ((listeners == null) || (listeners.length == 0))\n            return;\n        ServletRequestAttributeEvent event = null;\n        if (replaced)\n            event =\n                new ServletRequestAttributeEvent(context.getServletContext(),\n                                                 getRequest(), name, oldValue);\n        else\n            event =\n                new ServletRequestAttributeEvent(context.getServletContext(),\n                                                 getRequest(), name, value);\n\n        for (int i = 0; i < listeners.length; i++) {\n            if (!(listeners[i] instanceof ServletRequestAttributeListener))\n                continue;\n            ServletRequestAttributeListener listener =\n                (ServletRequestAttributeListener) listeners[i];\n            try {\n                if (replaced) {\n                    listener.attributeReplaced(event);\n                } else {\n                    listener.attributeAdded(event);\n                }\n            } catch (Throwable t) {\n                ExceptionUtils.handleThrowable(t);\n                context.getLogger().error(sm.getString(\"coyoteRequest.attributeEvent\"), t);\n                attributes.put(RequestDispatcher.ERROR_EXCEPTION, t );\n            }\n        }\n// fix_end\n", "cwe": "CWE-20", "cwe_name": "Improper Input Validation", "idx": 8101}
{"source": "// bug_start\n@Override\n    protected void onExchange(Exchange exchange) throws Exception {\n// bug_end\n \n// bug_start\n        if (!cacheStylesheet || cacheCleared) {\n            loadResource(resourceUri);\n        }\n        super.onExchange(exchange);\n\n// bug_end\n     }\n \n", "target": "// fix_start\npublic static C3P0Config extractXmlConfigFromInputStream(InputStream is) throws Exception\n    {\n        DocumentBuilderFactory fact = DocumentBuilderFactory.newInstance();\n\tfact.setExpandEntityReferences(false);\n        DocumentBuilder db = fact.newDocumentBuilder();\n        Document doc = db.parse( is );\n// fix_end\n// fix_start\n        return extractConfigFromXmlDoc(doc);\n// fix_end\n", "cwe": "CWE-611", "cwe_name": "Improper Restriction of XML External Entity Reference ('XXE')", "idx": 69567}
{"source": "// bug_start\n@Override\n    protected void onExchange(Exchange exchange) throws Exception {\n        String newResourceUri = exchange.getIn().getHeader(XsltConstants.XSLT_RESOURCE_URI, String.class);\n        if (newResourceUri != null) {\n            exchange.getIn().removeHeader(XsltConstants.XSLT_RESOURCE_URI);\n\n            LOG.trace(\"{} set to {} creating new endpoint to handle exchange\", XsltConstants.XSLT_RESOURCE_URI, newResourceUri);\n            XsltEndpoint newEndpoint = findOrCreateEndpoint(getEndpointUri(), newResourceUri);\n            newEndpoint.onExchange(exchange);\n// bug_end\n         } else {\n// bug_start\n            if (!cacheStylesheet || cacheCleared) {\n                loadResource(resourceUri);\n// bug_end\n             }\n// bug_start\n            super.onExchange(exchange);\n        }\n// bug_end\n     }\n \n", "target": "// fix_start\npublic static Map<String, Object> userLogin(DispatchContext ctx, Map<String, ?> context) {\n        LocalDispatcher dispatcher = ctx.getDispatcher();\n        Locale locale = (Locale) context.get(\"locale\");\n        Delegator delegator = ctx.getDelegator();\n\n        if (!AuthHelper.authenticatorsLoaded()) {\n            AuthHelper.loadAuthenticators(dispatcher);\n        }\n\n        if (\"true\".equals(EntityUtilProperties.getPropertyValue(\"security\", \"security.ldap.enable\", delegator))) {\n            if (!LdapAuthenticationServices.userLogin(ctx, context)) {\n                String errMsg = UtilProperties.getMessage(resource, \"loginservices.ldap_authentication_failed\", locale);\n                if (\"true\".equals(EntityUtilProperties.getPropertyValue(\"security\", \"security.ldap.fail.login\", delegator))) {\n                    return ServiceUtil.returnError(errMsg);\n                }\n                Debug.logInfo(errMsg, module);\n            }\n        }\n\n        Map<String, Object> result =  new LinkedHashMap<>();\n        boolean useEncryption = \"true\".equals(EntityUtilProperties.getPropertyValue(\"security\", \"password.encrypt\", delegator));\n\n        boolean isServiceAuth = context.get(\"isServiceAuth\") != null && ((Boolean) context.get(\"isServiceAuth\")).booleanValue();\n\n        String username = (String) context.get(\"login.username\");\n        if (username == null) {\n            username = (String) context.get(\"username\");\n        }\n        String password = (String) context.get(\"login.password\");\n        if (password == null) {\n            password = (String) context.get(\"password\");\n        }\n\n        String visitId = (String) context.get(\"visitId\");\n\n        String errMsg = \"\";\n        if (UtilValidate.isEmpty(username)) {\n            errMsg = UtilProperties.getMessage(resource,\"loginservices.username_missing\", locale);\n        } else if (UtilValidate.isEmpty(password)) {\n            errMsg = UtilProperties.getMessage(resource,\"loginservices.password_missing\", locale);\n// fix_end\n// fix_start\n\n            if (\"true\".equalsIgnoreCase(EntityUtilProperties.getPropertyValue(\"security\", \"username.lowercase\", delegator))) {\n                username = username.toLowerCase(Locale.getDefault());\n// fix_end\n// fix_start\n            if (\"true\".equalsIgnoreCase(EntityUtilProperties.getPropertyValue(\"security\", \"password.lowercase\", delegator))) {\n                password = password.toLowerCase(Locale.getDefault());\n            }\n\n            boolean repeat = true;\n            int passNumber = 0;\n\n            while (repeat) {\n                repeat = false;\n                passNumber++;\n\n                GenericValue userLogin = null;\n\n                try {\n                    userLogin = EntityQuery.use(delegator).from(\"UserLogin\").where(\"userLoginId\", username).cache(isServiceAuth).queryOne();\n                } catch (GenericEntityException e) {\n                    Debug.logWarning(e, \"\", module);\n                }\n\n\n                if (userLogin == null) {\n                    try {\n                        AuthHelper.syncUser(username);\n                    } catch (AuthenticatorException e) {\n                        Debug.logWarning(e, module);\n                    }\n\n                    try {\n                        userLogin = EntityQuery.use(delegator).from(\"UserLogin\").where(\"userLoginId\", username).cache(isServiceAuth).queryOne();\n                    } catch (GenericEntityException e) {\n                        Debug.logWarning(e, \"\", module);\n                    }\n                }\n\n                if (userLogin != null) {\n                    String ldmStr = EntityUtilProperties.getPropertyValue(\"security\", \"login.disable.minutes\", delegator);\n                    long loginDisableMinutes;\n\n                    try {\n                        loginDisableMinutes = Long.parseLong(ldmStr);\n                    } catch (Exception e) {\n                        loginDisableMinutes = 30;\n                        Debug.logWarning(\"Could not parse login.disable.minutes from security.properties, using default of 30\", module);\n                    }\n\n                    Timestamp disabledDateTime = userLogin.getTimestamp(\"disabledDateTime\");\n                    Timestamp reEnableTime = null;\n\n                    if (loginDisableMinutes > 0 && disabledDateTime != null) {\n                        reEnableTime = new Timestamp(disabledDateTime.getTime() + loginDisableMinutes * 60000);\n                    }\n\n                    boolean doStore = true;\n                    userLogin = GenericValue.create(userLogin);\n\n                    boolean isSystem = (isServiceAuth && userLogin.get(\"isSystem\") != null) ?\n                            \"Y\".equalsIgnoreCase(userLogin.getString(\"isSystem\")) : false;\n\n                    Boolean hasLoggedOut = userLogin.getBoolean(\"hasLoggedOut\");\n\n                    if ((UtilValidate.isEmpty(userLogin.getString(\"enabled\")) || \"Y\".equals(userLogin.getString(\"enabled\")) ||\n                            (reEnableTime != null && reEnableTime.before(UtilDateTime.nowTimestamp())) || (isSystem)) && UtilValidate.isEmpty(userLogin.getString(\"disabledBy\"))) {\n\n                        String successfulLogin;\n\n                        if (!isSystem) {\n                            userLogin.set(\"enabled\", \"Y\");\n                            userLogin.set(\"disabledBy\", null);\n                        }\n\n                        boolean authFatalError = false;\n                        boolean externalAuth = false;\n                        try {\n                            externalAuth = AuthHelper.authenticate(username, password, isServiceAuth);\n                        } catch (AuthenticatorException e) {\n                            Debug.logWarning(e, module);\n                            authFatalError = true;\n\n                        }\n\n                        boolean useTomcatSSO = EntityUtilProperties.propertyValueEquals(\"security\", \"security.login.tomcat.sso\", \"true\");\n                        HttpServletRequest request = (javax.servlet.http.HttpServletRequest) context.get(\"request\");\n                        useTomcatSSO = useTomcatSSO && (request!=null);\n\n                        if ((!authFatalError && externalAuth) || (useTomcatSSO ? TomcatSSOLogin(request, username, password) : checkPassword(userLogin.getString(\"currentPassword\"), useEncryption, password) )) {\n                            Debug.logVerbose(\"[LoginServices.userLogin] : Password Matched\", module);\n\n                            if (hasLoggedOut == null || hasLoggedOut) {\n                                userLogin.set(\"hasLoggedOut\", \"N\");\n                            }\n\n                            Long currentFailedLogins = userLogin.getLong(\"successiveFailedLogins\");\n                            if (currentFailedLogins != null && currentFailedLogins.longValue() > 0) {\n                                userLogin.set(\"successiveFailedLogins\", Long.valueOf(0));\n                            } else if (hasLoggedOut != null && !hasLoggedOut) {\n                                doStore = false;\n                            }\n\n                            successfulLogin = \"Y\";\n\n                            if (!isServiceAuth) {\n                                Map<?, ?> userLoginSessionMap = LoginWorker.getUserLoginSession(userLogin);\n\n                                if (userLoginSessionMap != null) {\n                                    result.put(\"userLoginSession\", userLoginSessionMap);\n                                }\n                            }\n\n                            result.put(\"userLogin\", userLogin);\n                            result.put(ModelService.RESPONSE_MESSAGE, ModelService.RESPOND_SUCCESS);\n                        } else {\n                            if (!authFatalError && isServiceAuth && passNumber <= 1) {\n                                delegator.clearCacheLine(\"UserLogin\", UtilMisc.toMap(\"userLoginId\", username));\n                                repeat = true;\n                                continue;\n                            }\n\n                            Debug.logInfo(\"[LoginServices.userLogin] : Password Incorrect\", module);\n                            errMsg = UtilProperties.getMessage(resource,\"loginservices.password_incorrect\", locale);\n\n                            Long currentFailedLogins = userLogin.getLong(\"successiveFailedLogins\");\n\n                            if (currentFailedLogins == null) {\n                                currentFailedLogins = Long.valueOf(1);\n                            } else {\n                                currentFailedLogins = Long.valueOf(currentFailedLogins.longValue() + 1);\n                            }\n                            userLogin.set(\"successiveFailedLogins\", currentFailedLogins);\n\n                            String mflStr = EntityUtilProperties.getPropertyValue(\"security\", \"max.failed.logins\", delegator);\n                            long maxFailedLogins = 3;\n                            try {\n                                maxFailedLogins = Long.parseLong(mflStr);\n                            } catch (Exception e) {\n                                maxFailedLogins = 3;\n                                Debug.logWarning(\"Could not parse max.failed.logins from security.properties, using default of 3\", module);\n                            }\n\n                            if (maxFailedLogins > 0 && currentFailedLogins.longValue() >= maxFailedLogins) {\n                                userLogin.set(\"enabled\", \"N\");\n                                userLogin.set(\"disabledDateTime\", UtilDateTime.nowTimestamp());\n                            }\n\n                            successfulLogin = \"N\";\n                        }\n\n                        Transaction parentTx = null;\n                        boolean beganTransaction = false;\n\n                        try {\n                            try {\n                                parentTx = TransactionUtil.suspend();\n                            } catch (GenericTransactionException e) {\n                                Debug.logError(e, \"Could not suspend transaction: \" + e.getMessage(), module);\n                            }\n\n                            try {\n                                beganTransaction = TransactionUtil.begin();\n\n                                if (doStore) {\n                                    userLogin.store();\n                                }\n\n                                if (\"true\".equals(EntityUtilProperties.getPropertyValue(\"security\", \"store.login.history\", delegator))) {\n                                    boolean createHistory = true;\n\n                                    if (isServiceAuth && !\"true\".equals(EntityUtilProperties.getPropertyValue(\"security\", \"store.login.history.on.service.auth\", delegator))) {\n                                        createHistory = false;\n                                    }\n\n                                    if (createHistory) {\n                                        Map<String, Object> ulhCreateMap = UtilMisc.toMap(\"userLoginId\", username, \"visitId\", visitId,\n                                                \"fromDate\", UtilDateTime.nowTimestamp(), \"successfulLogin\", successfulLogin);\n\n                                        ModelEntity modelUserLogin = userLogin.getModelEntity();\n                                        if (modelUserLogin.isField(\"partyId\")) {\n                                            ulhCreateMap.put(\"partyId\", userLogin.get(\"partyId\"));\n                                        }\n\n                                        if (\"N\".equals(successfulLogin) && !\"false\".equals(EntityUtilProperties.getPropertyValue(\"security\",\n                                                \"store.login.history.incorrect.password\", delegator))) {\n                                            ulhCreateMap.put(\"passwordUsed\", isGivenPasswordCanBeStored(delegator, password)\n                                                    ? \" TOO LONG FOR STORAGE \"\n                                                    : password);\n                                        }\n\n                                        delegator.create(\"UserLoginHistory\", ulhCreateMap);\n                                    }\n                                }\n                            } catch (GenericEntityException e) {\n                                String geeErrMsg = \"Error saving UserLoginHistory\";\n                                if (doStore) {\n                                    geeErrMsg += \" and updating login status to reset hasLoggedOut, unsuccessful login count, etc.\";\n                                }\n                                try {\n                                    TransactionUtil.rollback(beganTransaction, geeErrMsg, e);\n                                } catch (GenericTransactionException e2) {\n                                    Debug.logError(e2, \"Could not rollback nested transaction: \" + e2.getMessage(), module);\n                                }\n\n                                if (doStore) {\n                                    return ServiceUtil.returnError(geeErrMsg);\n                                }\n                            } finally {\n                                try {\n                                    TransactionUtil.commit(beganTransaction);\n                                } catch (GenericTransactionException e) {\n                                    Debug.logError(e, \"Could not commit nested transaction: \" + e.getMessage(), module);\n                                }\n                            }\n                        } finally {\n                            if (parentTx != null) {\n                                try {\n                                    TransactionUtil.resume(parentTx);\n                                    Debug.logVerbose(\"Resumed the parent transaction.\", module);\n                                } catch (GenericTransactionException e) {\n                                    Debug.logError(e, \"Could not resume parent nested transaction: \" + e.getMessage(), module);\n                                }\n                            }\n                        }\n                    } else {\n                        if (isServiceAuth && passNumber <= 1) {\n                            delegator.clearCacheLine(\"UserLogin\", UtilMisc.toMap(\"userLoginId\", username));\n                            repeat = true;\n                            continue;\n                        }\n\n                        Map<String, Object> messageMap = UtilMisc.<String, Object>toMap(\"username\", username);\n                        errMsg = UtilProperties.getMessage(resource,\"loginservices.account_for_user_login_id_disabled\",messageMap ,locale);\n                        if (disabledDateTime != null) {\n                            messageMap = UtilMisc.<String, Object>toMap(\"disabledDateTime\", disabledDateTime);\n                            errMsg += \" \" + UtilProperties.getMessage(resource,\"loginservices.since_datetime\",messageMap ,locale);\n                        } else {\n                            errMsg += \".\";\n                        }\n\n                        if (loginDisableMinutes > 0 && reEnableTime != null) {\n                            messageMap = UtilMisc.<String, Object>toMap(\"reEnableTime\", reEnableTime);\n                            errMsg += \" \" + UtilProperties.getMessage(resource,\"loginservices.will_be_reenabled\",messageMap ,locale);\n                        } else {\n                            errMsg += \" \" + UtilProperties.getMessage(resource,\"loginservices.not_scheduled_to_be_reenabled\",locale);\n                        }\n                    }\n                } else {\n                    boolean externalAuth = false;\n                    try {\n                        externalAuth = AuthHelper.authenticate(username, password, isServiceAuth);\n                    } catch (AuthenticatorException e) {\n                        errMsg = e.getMessage();\n                        Debug.logError(e, \"External Authenticator had fatal exception : \" + e.getMessage(), module);\n                    }\n                    if (externalAuth) {\n                        userLogin = delegator.makeValue(\"UserLogin\");\n                        userLogin.set(\"userLoginId\", username);\n                        userLogin.set(\"enabled\", \"Y\");\n                        userLogin.set(\"hasLoggedOut\", \"N\");\n                        result.put(\"userLogin\", userLogin);\n                        result.put(ModelService.RESPONSE_MESSAGE, ModelService.RESPOND_SUCCESS);\n                    } else {\n                        errMsg = UtilProperties.getMessage(resource, \"loginservices.user_not_found\", locale);\n                        Debug.logInfo(\"[LoginServices.userLogin] Invalid User : '\" + username + \"'; \" + errMsg, module);\n                    }\n                }\n            }\n        }\n\n        if (errMsg.length() > 0) {\n            result.put(ModelService.RESPONSE_MESSAGE, ModelService.RESPOND_FAIL);\n            result.put(ModelService.ERROR_MESSAGE, errMsg);\n        }\n        return result;\n// fix_end\n", "cwe": "CWE-264", "cwe_name": "Permissions, Privileges, and Access Controls", "idx": 29586}
{"source": "// bug_start\npublic static Map<String, Object> userLogin(DispatchContext ctx, Map<String, ?> context) {\n        LocalDispatcher dispatcher = ctx.getDispatcher();\n        Locale locale = (Locale) context.get(\"locale\");\n        Delegator delegator = ctx.getDelegator();\n\n        if (!AuthHelper.authenticatorsLoaded()) {\n            AuthHelper.loadAuthenticators(dispatcher);\n        }\n\n        if (\"true\".equals(EntityUtilProperties.getPropertyValue(\"security\", \"security.ldap.enable\", delegator))) {\n            if (!LdapAuthenticationServices.userLogin(ctx, context)) {\n                String errMsg = UtilProperties.getMessage(resource, \"loginservices.ldap_authentication_failed\", locale);\n                if (\"true\".equals(EntityUtilProperties.getPropertyValue(\"security\", \"security.ldap.fail.login\", delegator))) {\n                    return ServiceUtil.returnError(errMsg);\n                }\n                Debug.logInfo(errMsg, module);\n            }\n        }\n\n        Map<String, Object> result =  new LinkedHashMap<>();\n        boolean useEncryption = \"true\".equals(EntityUtilProperties.getPropertyValue(\"security\", \"password.encrypt\", delegator));\n\n        boolean isServiceAuth = context.get(\"isServiceAuth\") != null && ((Boolean) context.get(\"isServiceAuth\")).booleanValue();\n\n        String username = (String) context.get(\"login.username\");\n        if (username == null) {\n            username = (String) context.get(\"username\");\n        }\n        String password = (String) context.get(\"login.password\");\n        if (password == null) {\n            password = (String) context.get(\"password\");\n        }\n\n        String visitId = (String) context.get(\"visitId\");\n\n        String errMsg = \"\";\n        if (UtilValidate.isEmpty(username)) {\n            errMsg = UtilProperties.getMessage(resource,\"loginservices.username_missing\", locale);\n        } else if (UtilValidate.isEmpty(password)) {\n            errMsg = UtilProperties.getMessage(resource,\"loginservices.password_missing\", locale);\n        } else {\n\n            if (\"true\".equalsIgnoreCase(EntityUtilProperties.getPropertyValue(\"security\", \"username.lowercase\", delegator))) {\n                username = username.toLowerCase(Locale.getDefault());\n            }\n            if (\"true\".equalsIgnoreCase(EntityUtilProperties.getPropertyValue(\"security\", \"password.lowercase\", delegator))) {\n                password = password.toLowerCase(Locale.getDefault());\n// bug_end\n             }\n \n// bug_start\n            boolean repeat = true;\n            int passNumber = 0;\n// bug_end\n \n// bug_start\n            while (repeat) {\n                repeat = false;\n                passNumber++;\n\n                GenericValue userLogin = null;\n\n                try {\n                    userLogin = EntityQuery.use(delegator).from(\"UserLogin\").where(\"userLoginId\", username).cache(isServiceAuth).queryOne();\n                } catch (GenericEntityException e) {\n                    Debug.logWarning(e, \"\", module);\n                }\n\n\n                if (userLogin == null) {\n                    try {\n                        AuthHelper.syncUser(username);\n                    } catch (AuthenticatorException e) {\n                        Debug.logWarning(e, module);\n                    }\n\n                    try {\n                        userLogin = EntityQuery.use(delegator).from(\"UserLogin\").where(\"userLoginId\", username).cache(isServiceAuth).queryOne();\n                    } catch (GenericEntityException e) {\n                        Debug.logWarning(e, \"\", module);\n// bug_end\n                     }\n                 }\n// bug_start\n\n                if (userLogin != null) {\n                    String ldmStr = EntityUtilProperties.getPropertyValue(\"security\", \"login.disable.minutes\", delegator);\n                    long loginDisableMinutes;\n\n                    try {\n                        loginDisableMinutes = Long.parseLong(ldmStr);\n                    } catch (Exception e) {\n                        loginDisableMinutes = 30;\n                        Debug.logWarning(\"Could not parse login.disable.minutes from security.properties, using default of 30\", module);\n                    }\n\n                    Timestamp disabledDateTime = userLogin.getTimestamp(\"disabledDateTime\");\n                    Timestamp reEnableTime = null;\n\n                    if (loginDisableMinutes > 0 && disabledDateTime != null) {\n                        reEnableTime = new Timestamp(disabledDateTime.getTime() + loginDisableMinutes * 60000);\n                    }\n\n                    boolean doStore = true;\n                    userLogin = GenericValue.create(userLogin);\n\n                    boolean isSystem = (isServiceAuth && userLogin.get(\"isSystem\") != null) ?\n                            \"Y\".equalsIgnoreCase(userLogin.getString(\"isSystem\")) : false;\n\n                    Boolean hasLoggedOut = userLogin.getBoolean(\"hasLoggedOut\");\n\n                    if ((UtilValidate.isEmpty(userLogin.getString(\"enabled\")) || \"Y\".equals(userLogin.getString(\"enabled\")) ||\n                            (reEnableTime != null && reEnableTime.before(UtilDateTime.nowTimestamp())) || (isSystem)) && UtilValidate.isEmpty(userLogin.getString(\"disabledBy\"))) {\n\n                        String successfulLogin;\n\n                        if (!isSystem) {\n                            userLogin.set(\"enabled\", \"Y\");\n                            userLogin.set(\"disabledBy\", null);\n                        }\n\n                        boolean authFatalError = false;\n                        boolean externalAuth = false;\n                        try {\n                            externalAuth = AuthHelper.authenticate(username, password, isServiceAuth);\n                        } catch (AuthenticatorException e) {\n                            Debug.logWarning(e, module);\n                            authFatalError = true;\n\n                        }\n\n                        boolean useTomcatSSO = EntityUtilProperties.propertyValueEquals(\"security\", \"security.login.tomcat.sso\", \"true\");\n                        HttpServletRequest request = (javax.servlet.http.HttpServletRequest) context.get(\"request\");\n                        useTomcatSSO = useTomcatSSO && (request!=null);\n\n                        if ((!authFatalError && externalAuth) || (useTomcatSSO ? TomcatSSOLogin(request, username, password) : checkPassword(userLogin.getString(\"currentPassword\"), useEncryption, password) )) {\n                            Debug.logVerbose(\"[LoginServices.userLogin] : Password Matched\", module);\n\n                            if (hasLoggedOut == null || hasLoggedOut) {\n                                userLogin.set(\"hasLoggedOut\", \"N\");\n                            }\n\n                            Long currentFailedLogins = userLogin.getLong(\"successiveFailedLogins\");\n                            if (currentFailedLogins != null && currentFailedLogins.longValue() > 0) {\n                                userLogin.set(\"successiveFailedLogins\", Long.valueOf(0));\n                            } else if (hasLoggedOut != null && !hasLoggedOut) {\n                                doStore = false;\n                            }\n\n                            successfulLogin = \"Y\";\n\n                            if (!isServiceAuth) {\n                                Map<?, ?> userLoginSessionMap = LoginWorker.getUserLoginSession(userLogin);\n\n                                if (userLoginSessionMap != null) {\n                                    result.put(\"userLoginSession\", userLoginSessionMap);\n                                }\n                            }\n\n                            result.put(\"userLogin\", userLogin);\n                            result.put(ModelService.RESPONSE_MESSAGE, ModelService.RESPOND_SUCCESS);\n                        } else {\n                            if (!authFatalError && isServiceAuth && passNumber <= 1) {\n                                delegator.clearCacheLine(\"UserLogin\", UtilMisc.toMap(\"userLoginId\", username));\n                                repeat = true;\n                                continue;\n                            }\n\n                            Debug.logInfo(\"[LoginServices.userLogin] : Password Incorrect\", module);\n                            errMsg = UtilProperties.getMessage(resource,\"loginservices.password_incorrect\", locale);\n\n                            Long currentFailedLogins = userLogin.getLong(\"successiveFailedLogins\");\n\n                            if (currentFailedLogins == null) {\n                                currentFailedLogins = Long.valueOf(1);\n                            } else {\n                                currentFailedLogins = Long.valueOf(currentFailedLogins.longValue() + 1);\n                            }\n                            userLogin.set(\"successiveFailedLogins\", currentFailedLogins);\n\n                            String mflStr = EntityUtilProperties.getPropertyValue(\"security\", \"max.failed.logins\", delegator);\n                            long maxFailedLogins = 3;\n                            try {\n                                maxFailedLogins = Long.parseLong(mflStr);\n                            } catch (Exception e) {\n                                maxFailedLogins = 3;\n                                Debug.logWarning(\"Could not parse max.failed.logins from security.properties, using default of 3\", module);\n                            }\n\n                            if (maxFailedLogins > 0 && currentFailedLogins.longValue() >= maxFailedLogins) {\n                                userLogin.set(\"enabled\", \"N\");\n                                userLogin.set(\"disabledDateTime\", UtilDateTime.nowTimestamp());\n                            }\n\n                            successfulLogin = \"N\";\n                        }\n\n                        Transaction parentTx = null;\n                        boolean beganTransaction = false;\n\n                        try {\n                            try {\n                                parentTx = TransactionUtil.suspend();\n                            } catch (GenericTransactionException e) {\n                                Debug.logError(e, \"Could not suspend transaction: \" + e.getMessage(), module);\n                            }\n\n                            try {\n                                beganTransaction = TransactionUtil.begin();\n\n                                if (doStore) {\n                                    userLogin.store();\n                                }\n\n                                if (\"true\".equals(EntityUtilProperties.getPropertyValue(\"security\", \"store.login.history\", delegator))) {\n                                    boolean createHistory = true;\n\n                                    if (isServiceAuth && !\"true\".equals(EntityUtilProperties.getPropertyValue(\"security\", \"store.login.history.on.service.auth\", delegator))) {\n                                        createHistory = false;\n                                    }\n\n                                    if (createHistory) {\n                                        Map<String, Object> ulhCreateMap = UtilMisc.toMap(\"userLoginId\", username, \"visitId\", visitId,\n                                                \"fromDate\", UtilDateTime.nowTimestamp(), \"successfulLogin\", successfulLogin);\n\n                                        ModelEntity modelUserLogin = userLogin.getModelEntity();\n                                        if (modelUserLogin.isField(\"partyId\")) {\n                                            ulhCreateMap.put(\"partyId\", userLogin.get(\"partyId\"));\n                                        }\n\n                                        if (\"N\".equals(successfulLogin) && !\"false\".equals(EntityUtilProperties.getPropertyValue(\"security\", \"store.login.history.incorrect.password\", delegator))) {\n                                            ulhCreateMap.put(\"passwordUsed\", password);\n                                        }\n\n                                        delegator.create(\"UserLoginHistory\", ulhCreateMap);\n                                    }\n                                }\n                            } catch (GenericEntityException e) {\n                                String geeErrMsg = \"Error saving UserLoginHistory\";\n                                if (doStore) {\n                                    geeErrMsg += \" and updating login status to reset hasLoggedOut, unsuccessful login count, etc.\";\n                                }\n                                geeErrMsg += \": \" + e.toString();\n                                try {\n                                    TransactionUtil.rollback(beganTransaction, geeErrMsg, e);\n                                } catch (GenericTransactionException e2) {\n                                    Debug.logError(e2, \"Could not rollback nested transaction: \" + e2.getMessage(), module);\n                                }\n\n                                if (doStore) {\n                                    return ServiceUtil.returnError(geeErrMsg);\n                                }\n                            } finally {\n                                try {\n                                    TransactionUtil.commit(beganTransaction);\n                                } catch (GenericTransactionException e) {\n                                    Debug.logError(e, \"Could not commit nested transaction: \" + e.getMessage(), module);\n                                }\n                            }\n                        } finally {\n                            if (parentTx != null) {\n                                try {\n                                    TransactionUtil.resume(parentTx);\n                                    Debug.logVerbose(\"Resumed the parent transaction.\", module);\n                                } catch (GenericTransactionException e) {\n                                    Debug.logError(e, \"Could not resume parent nested transaction: \" + e.getMessage(), module);\n                                }\n                            }\n                        }\n                    } else {\n                        if (isServiceAuth && passNumber <= 1) {\n                            delegator.clearCacheLine(\"UserLogin\", UtilMisc.toMap(\"userLoginId\", username));\n                            repeat = true;\n                            continue;\n                        }\n\n                        Map<String, Object> messageMap = UtilMisc.<String, Object>toMap(\"username\", username);\n                        errMsg = UtilProperties.getMessage(resource,\"loginservices.account_for_user_login_id_disabled\",messageMap ,locale);\n                        if (disabledDateTime != null) {\n                            messageMap = UtilMisc.<String, Object>toMap(\"disabledDateTime\", disabledDateTime);\n                            errMsg += \" \" + UtilProperties.getMessage(resource,\"loginservices.since_datetime\",messageMap ,locale);\n                        } else {\n                            errMsg += \".\";\n                        }\n\n                        if (loginDisableMinutes > 0 && reEnableTime != null) {\n                            messageMap = UtilMisc.<String, Object>toMap(\"reEnableTime\", reEnableTime);\n                            errMsg += \" \" + UtilProperties.getMessage(resource,\"loginservices.will_be_reenabled\",messageMap ,locale);\n                        } else {\n                            errMsg += \" \" + UtilProperties.getMessage(resource,\"loginservices.not_scheduled_to_be_reenabled\",locale);\n                        }\n                    }\n                } else {\n                    boolean externalAuth = false;\n                    try {\n                        externalAuth = AuthHelper.authenticate(username, password, isServiceAuth);\n                    } catch (AuthenticatorException e) {\n                        errMsg = e.getMessage();\n                        Debug.logError(e, \"External Authenticator had fatal exception : \" + e.getMessage(), module);\n                    }\n                    if (externalAuth) {\n                        userLogin = delegator.makeValue(\"UserLogin\");\n                        userLogin.set(\"userLoginId\", username);\n                        userLogin.set(\"enabled\", \"Y\");\n                        userLogin.set(\"hasLoggedOut\", \"N\");\n                        result.put(\"userLogin\", userLogin);\n                        result.put(ModelService.RESPONSE_MESSAGE, ModelService.RESPOND_SUCCESS);\n                    } else {\n                        errMsg = UtilProperties.getMessage(resource, \"loginservices.user_not_found\", locale);\n                        Debug.logInfo(\"[LoginServices.userLogin] Invalid User : '\" + username + \"'; \" + errMsg, module);\n                    }\n                }\n// bug_end\n             }\n// bug_start\n// bug_end\n         }\n// bug_start\n\n        if (errMsg.length() > 0) {\n            result.put(ModelService.RESPONSE_MESSAGE, ModelService.RESPOND_FAIL);\n            result.put(ModelService.ERROR_MESSAGE, errMsg);\n        }\n        return result;\n// bug_end\n     }\n \n", "target": "// fix_start\n@Override\n    public void deactivate() {\n        if (isActive()) {\n            if (!isAssociated()) {\n                throw ConversationLogger.LOG.mustCallAssociateBeforeDeactivate();\n// fix_end\n// fix_start\n            try {\n                if (getCurrentConversation().isTransient() && getRequestAttribute(getRequest(), ConversationNamingScheme.PARAMETER_NAME) != null) {\n                    destroy();\n                } else {\n                    getCurrentConversation().touch();\n                    if (!getBeanStore().isAttached()) {\n                        if (!(getRequestAttribute(getRequest(), ConversationNamingScheme.PARAMETER_NAME) instanceof ConversationNamingScheme)) {\n                            throw ConversationLogger.LOG.conversationNamingSchemeNotFound();\n                        }\n                        ((ConversationNamingScheme) getRequestAttribute(getRequest(), ConversationNamingScheme.PARAMETER_NAME)).setCid(getCurrentConversation()\n                                .getId());\n// fix_end\n// fix_start\n                        try {\n                            getBeanStore().attach();\n                            getConversationMap().put(getCurrentConversation().getId(), getCurrentConversation());\n                        } catch (Exception cause) {\n                            ContextLogger.LOG.destroyingContextAfterBeanStoreAttachError(this, getBeanStore(), cause.getMessage());\n                            ContextLogger.LOG.catchingDebug(cause);\n                            destroy();\n                        }\n// fix_end\n// fix_start\n            } finally {\n                getCurrentConversation().unlock();\n                setBeanStore(null);\n                cleanUpConversationMap();\n                super.setActive(false);\n// fix_end\n// fix_start\n        } else {\n            throw ConversationLogger.LOG.contextNotActive();\n// fix_end\n// fix_start\n// fix_end\n", "cwe": "CWE-209", "cwe_name": "Information Exposure Through an Error Message", "idx": 20526}
{"source": "// bug_start\n@Override\n    public void deactivate() {\n        if (isActive()) {\n            if (!isAssociated()) {\n                throw ConversationLogger.LOG.mustCallAssociateBeforeDeactivate();\n// bug_end\n             }\n \n// bug_start\n            try {\n                if (getCurrentConversation().isTransient() && getRequestAttribute(getRequest(), ConversationNamingScheme.PARAMETER_NAME) != null) {\n                    destroy();\n                } else {\n                    getCurrentConversation().touch();\n                    if (!getBeanStore().isAttached()) {\n                        if (!(getRequestAttribute(getRequest(), ConversationNamingScheme.PARAMETER_NAME) instanceof ConversationNamingScheme)) {\n                            throw ConversationLogger.LOG.conversationNamingSchemeNotFound();\n                        }\n                        ((ConversationNamingScheme) getRequestAttribute(getRequest(), ConversationNamingScheme.PARAMETER_NAME)).setCid(getCurrentConversation()\n                                .getId());\n// bug_end\n \n// bug_start\n                        getBeanStore().attach();\n                        getConversationMap().put(getCurrentConversation().getId(), getCurrentConversation());\n                    }\n                }\n            } finally {\n                getCurrentConversation().unlock();\n                setBeanStore(null);\n                cleanUpConversationMap();\n                super.setActive(false);\n            }\n// bug_end\n         } else {\n// bug_start\n            throw ConversationLogger.LOG.contextNotActive();\n// bug_end\n         }\n// bug_start\n// bug_end\n     }\n \n", "target": "// fix_start\npublic void doFilter(ServletRequest request, ServletResponse res, FilterChain chain)\n          throws IOException, ServletException {\n        HttpServletRequest req = (HttpServletRequest) request;\n        String uri;\n        if (req.getPathInfo() == null) {\n            uri = req.getRequestURI().substring(req.getContextPath().length());\n        } else {\n            uri = req.getPathInfo();\n        }\n        if (uriPattern != null && uriPattern.matcher(uri).matches()) {\n            User user = User.current();\n            String username = user != null ? user.getId() : req.getRemoteAddr();\n            String extra = \"\";\n            if (uri.startsWith(\"/queue/item/\")) {\n                extra = extractInfoFromQueueItem(uri);\n            } else if (uri.startsWith(\"/queue/cancelItem\")) {\n                extra = getFormattedQueueItemUrlFromItemId(Integer.parseInt(req.getParameter(\"id\")));\n                uri += \"?\" + req.getQueryString();\n// fix_end\n// fix_start\n            if (LOGGER.isLoggable(Level.FINE))\n                LOGGER.log(Level.FINE, \"Audit request {0} by user {1}\", new Object[]{uri, username});\n// fix_end\n// fix_start\n            onRequest(uri, extra, username);\n// fix_end\n// fix_start\n            LOGGER.log(Level.FINEST, \"Skip audit for request {0}\", uri);\n// fix_end\n// fix_start\n        chain.doFilter(req, res);\n// fix_end\n", "cwe": "CWE-362", "cwe_name": "Concurrent Execution using Shared Resource with Improper Synchronization ('Race Condition')", "idx": 49000}
{"source": "// bug_start\npublic Script compile() throws CompilationFailedException {\n        Binding binding = new Binding();\n        binding.setVariable(\"falsePositive\", falsePositive);\n        GroovyShell shell = new GroovyShell(WarningsDescriptor.class.getClassLoader(), binding);\n        return shell.parse(script);\n// bug_end\n     }\n \n", "target": "// fix_start\npublic void doFilter(ServletRequest request, ServletResponse res, FilterChain chain)\n          throws IOException, ServletException {\n        HttpServletRequest req = (HttpServletRequest) request;\n        String uri = getPathInfo(req);\n        if (uriPattern != null && uriPattern.matcher(uri).matches()) {\n            User user = User.current();\n            String username = user != null ? user.getId() : req.getRemoteAddr();\n            String extra = \"\";\n            if (uri.startsWith(\"/queue/item/\")) {\n                extra = extractInfoFromQueueItem(uri);\n            } else if (uri.startsWith(\"/queue/cancelItem\")) {\n                extra = getFormattedQueueItemUrlFromItemId(Integer.parseInt(req.getParameter(\"id\")));\n                uri += \"?\" + req.getQueryString();\n            }\n\n            if (LOGGER.isLoggable(Level.FINE))\n                LOGGER.log(Level.FINE, \"Audit request {0} by user {1}\", new Object[]{uri, username});\n\n            onRequest(uri, extra, username);\n        } else {\n            LOGGER.log(Level.FINEST, \"Skip audit for request {0}\", uri);\n        }\n        chain.doFilter(req, res);\n// fix_end\n", "cwe": "CWE-435", "cwe_name": "", "idx": 53818}
{"source": "// bug_start\npublic Script compile() throws CompilationFailedException {\n        Binding binding = new Binding();\n        binding.setVariable(\"falsePositive\", falsePositive);\n        GroovyShell shell = new GroovyShell(GroovySandbox.createSecureClassLoader(WarningsDescriptor.class.getClassLoader()),\n                binding, GroovySandbox.createSecureCompilerConfiguration());\n        return shell.parse(script);\n// bug_end\n     }\n \n", "target": "// fix_start\npublic void parse(\n            InputStream stream, ContentHandler handler,\n            Metadata metadata, ParseContext context)\n            throws IOException, SAXException, TikaException {\n\n        TemporaryResources tmp = new TemporaryResources();\n        TikaInputStream tstream = TikaInputStream.get(stream, tmp);\n\n        try (DataSource dataSource = new DirectFileReadDataSource(tstream.getFile())) {\n            try (IsoFile isoFile = new IsoFile(dataSource)) {\n                tmp.addResource(isoFile);\n\n                FileTypeBox fileType = getOrNull(isoFile, FileTypeBox.class);\n                if (fileType != null) {\n                    MediaType type = MediaType.application(\"mp4\");\n                    for (Map.Entry<MediaType, List<String>> e : typesMap.entrySet()) {\n                        if (e.getValue().contains(fileType.getMajorBrand())) {\n                            type = e.getKey();\n                            break;\n                        }\n                    }\n                    metadata.set(Metadata.CONTENT_TYPE, type.toString());\n\n                    if (type.getType().equals(\"audio\")) {\n                        metadata.set(XMPDM.AUDIO_COMPRESSOR, fileType.getMajorBrand().trim());\n                    }\n                } else {\n                    metadata.set(Metadata.CONTENT_TYPE, \"video/quicktime\");\n                }\n\n\n                MovieBox moov = getOrNull(isoFile, MovieBox.class);\n                if (moov == null) {\n                    return;\n                }\n\n\n                XHTMLContentHandler xhtml = new XHTMLContentHandler(handler, metadata);\n                xhtml.startDocument();\n\n\n                MovieHeaderBox mHeader = getOrNull(moov, MovieHeaderBox.class);\n                if (mHeader != null) {\n                    metadata.set(Metadata.CREATION_DATE, mHeader.getCreationTime());\n                    metadata.set(TikaCoreProperties.MODIFIED, mHeader.getModificationTime());\n\n                    double durationSeconds = ((double) mHeader.getDuration()) / mHeader.getTimescale();\n                    metadata.set(XMPDM.DURATION, DURATION_FORMAT.format(durationSeconds));\n\n                    metadata.set(XMPDM.AUDIO_SAMPLE_RATE, (int) mHeader.getTimescale());\n                }\n\n\n                List<TrackBox> tb = moov.getBoxes(TrackBox.class);\n                if (tb.size() > 0) {\n                    TrackBox track = tb.get(0);\n\n                    TrackHeaderBox header = track.getTrackHeaderBox();\n                    metadata.set(TikaCoreProperties.CREATED, header.getCreationTime());\n                    metadata.set(TikaCoreProperties.MODIFIED, header.getModificationTime());\n\n                    metadata.set(Metadata.IMAGE_WIDTH, (int) header.getWidth());\n                    metadata.set(Metadata.IMAGE_LENGTH, (int) header.getHeight());\n\n                    SampleTableBox samples = track.getSampleTableBox();\n                    if (samples !=  null) {\n                        SampleDescriptionBox sampleDesc = samples.getSampleDescriptionBox();\n                        if (sampleDesc != null) {\n                            AudioSampleEntry sample = getOrNull(sampleDesc, AudioSampleEntry.class);\n                            if (sample != null) {\n                                XMPDM.ChannelTypePropertyConverter.convertAndSet(metadata, sample.getChannelCount());\n                                metadata.set(XMPDM.AUDIO_SAMPLE_RATE, (int) sample.getSampleRate());\n                            }\n                        }\n                    }\n                }\n\n                UserDataBox userData = getOrNull(moov, UserDataBox.class);\n                if (userData != null) {\n                    extractGPS(userData, metadata);\n                    MetaBox meta = getOrNull(userData, MetaBox.class);\n\n                    AppleItemListBox apple = getOrNull(meta, AppleItemListBox.class);\n                    if (apple != null) {\n                        AppleNameBox title = getOrNull(apple, AppleNameBox.class);\n                        addMetadata(TikaCoreProperties.TITLE, metadata, title);\n\n                        AppleArtistBox artist = getOrNull(apple, AppleArtistBox.class);\n                        addMetadata(TikaCoreProperties.CREATOR, metadata, artist);\n                        addMetadata(XMPDM.ARTIST, metadata, artist);\n\n                        AppleArtist2Box artist2 = getOrNull(apple, AppleArtist2Box.class);\n                        addMetadata(XMPDM.ALBUM_ARTIST, metadata, artist2);\n\n                        AppleAlbumBox album = getOrNull(apple, AppleAlbumBox.class);\n                        addMetadata(XMPDM.ALBUM, metadata, album);\n\n                        AppleTrackAuthorBox composer = getOrNull(apple, AppleTrackAuthorBox.class);\n                        addMetadata(XMPDM.COMPOSER, metadata, composer);\n\n                        AppleGenreBox genre = getOrNull(apple, AppleGenreBox.class);\n                        addMetadata(XMPDM.GENRE, metadata, genre);\n\n                        AppleRecordingYear2Box year = getOrNull(apple, AppleRecordingYear2Box.class);\n                        if (year != null) {\n                            metadata.set(XMPDM.RELEASE_DATE, year.getValue());\n                        }\n\n                        AppleTrackNumberBox trackNum = getOrNull(apple, AppleTrackNumberBox.class);\n                        if (trackNum != null) {\n                            metadata.set(XMPDM.TRACK_NUMBER, trackNum.getA());\n                        }\n\n                        AppleDiskNumberBox discNum = getOrNull(apple, AppleDiskNumberBox.class);\n                        if (discNum != null) {\n                            metadata.set(XMPDM.DISC_NUMBER, discNum.getA());\n                        }\n\n                        AppleCompilationBox compilation = getOrNull(apple, AppleCompilationBox.class);\n                        if (compilation != null) {\n                            metadata.set(XMPDM.COMPILATION, (int) compilation.getValue());\n                        }\n\n                        AppleCommentBox comment = getOrNull(apple, AppleCommentBox.class);\n                        addMetadata(XMPDM.LOG_COMMENT, metadata, comment);\n\n                        AppleEncoderBox encoder = getOrNull(apple, AppleEncoderBox.class);\n                        if (encoder != null) {\n                            metadata.set(XMP.CREATOR_TOOL, encoder.getValue());\n                        }\n\n\n                        for (Box box : apple.getBoxes()) {\n                            if (box instanceof Utf8AppleDataBox) {\n                                xhtml.element(\"p\", ((Utf8AppleDataBox) box).getValue());\n                            }\n                        }\n                    }\n\n                }\n\n\n                xhtml.endDocument();\n            }\n        } finally {\n            tmp.dispose();\n        }\n\n// fix_end\n", "cwe": "CWE-352", "cwe_name": "Cross-Site Request Forgery (CSRF)", "idx": 46300}
{"source": "// bug_start\npublic void parse(\n            InputStream stream, ContentHandler handler,\n            Metadata metadata, ParseContext context)\n            throws IOException, SAXException, TikaException {\n\n        TemporaryResources tmp = new TemporaryResources();\n        TikaInputStream tstream = TikaInputStream.get(stream, tmp);\n\n        try (DataSource dataSource = new DirectFileReadDataSource(tstream.getFile())) {\n            try (IsoFile isoFile = new IsoFile(dataSource)) {\n                tmp.addResource(isoFile);\n\n                FileTypeBox fileType = getOrNull(isoFile, FileTypeBox.class);\n                if (fileType != null) {\n                    MediaType type = MediaType.application(\"mp4\");\n                    for (Map.Entry<MediaType, List<String>> e : typesMap.entrySet()) {\n                        if (e.getValue().contains(fileType.getMajorBrand())) {\n                            type = e.getKey();\n                            break;\n                        }\n                    }\n                    metadata.set(Metadata.CONTENT_TYPE, type.toString());\n\n                    if (type.getType().equals(\"audio\")) {\n                        metadata.set(XMPDM.AUDIO_COMPRESSOR, fileType.getMajorBrand().trim());\n                    }\n                } else {\n                    metadata.set(Metadata.CONTENT_TYPE, \"video/quicktime\");\n                }\n\n\n                MovieBox moov = getOrNull(isoFile, MovieBox.class);\n                if (moov == null) {\n                    return;\n                }\n\n\n                XHTMLContentHandler xhtml = new XHTMLContentHandler(handler, metadata);\n                xhtml.startDocument();\n\n\n                MovieHeaderBox mHeader = getOrNull(moov, MovieHeaderBox.class);\n                if (mHeader != null) {\n                    metadata.set(Metadata.CREATION_DATE, mHeader.getCreationTime());\n                    metadata.set(TikaCoreProperties.MODIFIED, mHeader.getModificationTime());\n\n                    double durationSeconds = ((double) mHeader.getDuration()) / mHeader.getTimescale();\n                    metadata.set(XMPDM.DURATION, DURATION_FORMAT.format(durationSeconds));\n\n                    metadata.set(XMPDM.AUDIO_SAMPLE_RATE, (int) mHeader.getTimescale());\n                }\n\n\n                List<TrackBox> tb = moov.getBoxes(TrackBox.class);\n                if (tb.size() > 0) {\n                    TrackBox track = tb.get(0);\n\n                    TrackHeaderBox header = track.getTrackHeaderBox();\n                    metadata.set(TikaCoreProperties.CREATED, header.getCreationTime());\n                    metadata.set(TikaCoreProperties.MODIFIED, header.getModificationTime());\n\n                    metadata.set(Metadata.IMAGE_WIDTH, (int) header.getWidth());\n                    metadata.set(Metadata.IMAGE_LENGTH, (int) header.getHeight());\n\n                    SampleTableBox samples = track.getSampleTableBox();\n                    SampleDescriptionBox sampleDesc = samples.getSampleDescriptionBox();\n                    if (sampleDesc != null) {\n                        AudioSampleEntry sample = getOrNull(sampleDesc, AudioSampleEntry.class);\n                        if (sample != null) {\n                            XMPDM.ChannelTypePropertyConverter.convertAndSet(metadata, sample.getChannelCount());\n                            metadata.set(XMPDM.AUDIO_SAMPLE_RATE, (int) sample.getSampleRate());\n                        }\n                    }\n                }\n\n                UserDataBox userData = getOrNull(moov, UserDataBox.class);\n                if (userData != null) {\n                    extractGPS(userData, metadata);\n                    MetaBox meta = getOrNull(userData, MetaBox.class);\n\n                    AppleItemListBox apple = getOrNull(meta, AppleItemListBox.class);\n                    if (apple != null) {\n                        AppleNameBox title = getOrNull(apple, AppleNameBox.class);\n                        addMetadata(TikaCoreProperties.TITLE, metadata, title);\n\n                        AppleArtistBox artist = getOrNull(apple, AppleArtistBox.class);\n                        addMetadata(TikaCoreProperties.CREATOR, metadata, artist);\n                        addMetadata(XMPDM.ARTIST, metadata, artist);\n\n                        AppleArtist2Box artist2 = getOrNull(apple, AppleArtist2Box.class);\n                        addMetadata(XMPDM.ALBUM_ARTIST, metadata, artist2);\n\n                        AppleAlbumBox album = getOrNull(apple, AppleAlbumBox.class);\n                        addMetadata(XMPDM.ALBUM, metadata, album);\n\n                        AppleTrackAuthorBox composer = getOrNull(apple, AppleTrackAuthorBox.class);\n                        addMetadata(XMPDM.COMPOSER, metadata, composer);\n\n                        AppleGenreBox genre = getOrNull(apple, AppleGenreBox.class);\n                        addMetadata(XMPDM.GENRE, metadata, genre);\n\n                        AppleRecordingYear2Box year = getOrNull(apple, AppleRecordingYear2Box.class);\n                        if (year != null) {\n                            metadata.set(XMPDM.RELEASE_DATE, year.getValue());\n                        }\n\n                        AppleTrackNumberBox trackNum = getOrNull(apple, AppleTrackNumberBox.class);\n                        if (trackNum != null) {\n                            metadata.set(XMPDM.TRACK_NUMBER, trackNum.getA());\n                        }\n\n                        AppleDiskNumberBox discNum = getOrNull(apple, AppleDiskNumberBox.class);\n                        if (discNum != null) {\n                            metadata.set(XMPDM.DISC_NUMBER, discNum.getA());\n                        }\n\n                        AppleCompilationBox compilation = getOrNull(apple, AppleCompilationBox.class);\n                        if (compilation != null) {\n                            metadata.set(XMPDM.COMPILATION, (int) compilation.getValue());\n                        }\n\n                        AppleCommentBox comment = getOrNull(apple, AppleCommentBox.class);\n                        addMetadata(XMPDM.LOG_COMMENT, metadata, comment);\n\n                        AppleEncoderBox encoder = getOrNull(apple, AppleEncoderBox.class);\n                        if (encoder != null) {\n                            metadata.set(XMP.CREATOR_TOOL, encoder.getValue());\n                        }\n\n\n                        for (Box box : apple.getBoxes()) {\n                            if (box instanceof Utf8AppleDataBox) {\n                                xhtml.element(\"p\", ((Utf8AppleDataBox) box).getValue());\n                            }\n                        }\n                    }\n\n                }\n\n\n                xhtml.endDocument();\n// bug_end\n             }\n// bug_start\n        } finally {\n            tmp.dispose();\n// bug_end\n         }\n \n// bug_start\n    }\n\n// bug_end\n", "target": "// fix_start\n@Override\n        public Long next()\n        {\n            if (currentNumber < currentEnd)\n            {\n                return currentNumber++;\n// fix_end\n// fix_start\n            currentNumber = start[++currentRange];\n            currentEnd = end[currentRange];\n            return currentNumber++;\n// fix_end\n", "cwe": "CWE-835", "cwe_name": "Loop with Unreachable Exit Condition ('Infinite Loop')", "idx": 83017}
{"source": "// bug_start\npublic String createPackagesTable(final String serverUrl, final String authenticationToken, final String project) {\n\t\tList<String> packageNames = new ArrayList<String>();\n\t\ttry {\n\t\t\tpackageNames = RapidDeployConnector.invokeRapidDeployListPackages(authenticationToken, serverUrl, project);\n\t\t} catch (final Exception e) {\n\t\t\tlogger.warn(e.getMessage());\n\t\t}\n\t\tif (!packageNames.isEmpty()) {\n\t\t\tfinal StringBuffer sb = new StringBuffer();\n\t\t\tsb.append(\"<table>\");\n\t\t\tint index = 0;\n\t\t\tfinal int limit = 10;\n\t\t\tfor (final String packageName : packageNames) {\n\t\t\t\tif (!\"null\".equals(packageName) && !packageName.startsWith(\"Deployment\")) {\n\t\t\t\t\tsb.append(\"<tr><td class=\\\"setting-main\\\">\");\n\t\t\t\t\tsb.append(packageName);\n\t\t\t\t\tsb.append(\"</td></tr>\");\n\t\t\t\t\tindex++;\n\t\t\t\t\tif (index >= limit) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tsb.append(\"</table>\");\n\t\t\treturn sb.toString();\n\t\t}\n\t\treturn null;\n\t}\n// bug_end\n \n", "target": "// fix_start\n@Override\n        public Long next()\n        {\n            if (currentNumber >= maxValue)\n            {\n                throw new NoSuchElementException();\n            }\n            if (currentNumber < currentEnd)\n            {\n                return currentNumber++;\n            }\n            currentNumber = start[++currentRange];\n            currentEnd = end[currentRange];\n            return currentNumber++;\n        }\n// fix_end\n", "cwe": "NVD-CWE-Other", "cwe_name": "Other", "idx": 115226}
{"source": "// bug_start\nprivate Document parse(String configFile) {\n    Document doc = null;\n    try {\n      SAXParserFactory factory = SAXParserFactory.newInstance();\n      factory.setFeature(\"http://apache.org/xml/features/disallow-doctype-decl\", false);\n      factory.setValidating(false);\n// bug_end\n \n// bug_start\n      SAXParser parser = factory.newSAXParser();\n      parser.parse(configFile, this);\n\n      UIMAFramework.getLogger().log(Level.CONFIG, \"Resource::\" + getResourceSpecifierPath());\n      UIMAFramework.getLogger().log(Level.CONFIG, \"Instance Count::\" + getInstanceCount());\n      UIMAFramework.getLogger().log(Level.CONFIG, \"Service Name::\" + getServiceName());\n      UIMAFramework.getLogger().log(Level.CONFIG, \"Filter String::\" + getFilterString());\n      UIMAFramework.getLogger().log(Level.CONFIG, \"Naming Service Host::\" + getNamingServiceHost());\n      UIMAFramework.getLogger().log(Level.CONFIG,\n              \"Server Socket Timeout::\" + getServerSocketTimeout());\n\n    } catch (Exception ex) {\n      ex.printStackTrace();\n    }\n    return doc;\n  }\n\n// bug_end\n", "target": "// fix_start\npublic String createPackagesTable(final String serverUrl, final String authenticationToken, final String project) {\n\t\tList<String> packageNames = new ArrayList<String>();\n\t\ttry {\n\t\t\tpackageNames = RapidDeployConnector.invokeRapidDeployListPackages(authenticationToken, serverUrl, project);\n\t\t} catch (final Exception e) {\n\t\t\tlogger.warn(e.getMessage());\n\t\t}\n\t\tif (!packageNames.isEmpty()) {\n\t\t\tfinal StringBuffer sb = new StringBuffer();\n\t\t\tsb.append(\"<table>\");\n\t\t\tint index = 0;\n\t\t\tfinal int limit = 10;\n\t\t\tfor (final String packageName : packageNames) {\n\t\t\t\tif (!\"null\".equals(packageName) && !packageName.startsWith(\"Deployment\")) {\n\t\t\t\t\tsb.append(\"<tr><td class=\\\"setting-main\\\">\");\n\t\t\t\t\tsb.append(Util.escape(packageName));\n\t\t\t\t\tsb.append(\"</td></tr>\");\n\t\t\t\t\tindex++;\n\t\t\t\t\tif (index >= limit) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tsb.append(\"</table>\");\n\t\t\treturn sb.toString();\n\t\t}\n\t\treturn null;\n\t}\n// fix_end\n", "cwe": "CWE-79", "cwe_name": "Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')", "idx": 80548}
{"source": " public static DotCorpus parseDotCorpus(InputStream dotCorpusStream) throws CoreException {\n     DocumentBuilderFactory documentBuilderFacoty = DocumentBuilderFactory.newInstance();\n// bug_start\n// bug_end\n \n     DocumentBuilder documentBuilder;\n \n     try {\n       documentBuilder = documentBuilderFacoty.newDocumentBuilder();\n     } catch (ParserConfigurationException e) {\n       String message = \"This should never happen:\" + (e.getMessage() != null ? e.getMessage() : \"\");\n \n       IStatus s = new Status(IStatus.ERROR, CasEditorPlugin.ID, IStatus.OK, message, e);\n \n       throw new CoreException(s);\n     }\n \n     org.w3c.dom.Document dotCorpusDOM;\n \n     try {\n       dotCorpusDOM = documentBuilder.parse(dotCorpusStream);\n     } catch (SAXException e) {\n       String message = e.getMessage() != null ? e.getMessage() : \"\";\n \n       IStatus s = new Status(IStatus.ERROR, CasEditorPlugin.ID, IStatus.OK, message, e);\n \n       throw new CoreException(s);\n     } catch (IOException e) {\n       String message = e.getMessage() != null ? e.getMessage() : \"\";\n \n       IStatus s = new Status(IStatus.ERROR, CasEditorPlugin.ID, IStatus.OK, message, e);\n \n       throw new CoreException(s);\n     }\n \n     DotCorpus dotCorpus = new DotCorpus();\n \n     Element configElement = dotCorpusDOM.getDocumentElement();\n \n     if (CONFIG_ELEMENT.equals(configElement.getNodeName())) {\n     }\n \n     NodeList corporaChildNodes = configElement.getChildNodes();\n \n     for (int i = 0; i < corporaChildNodes.getLength(); i++) {\n       Node corporaChildNode = corporaChildNodes.item(i);\n \n       if (!(corporaChildNode instanceof Element)) {\n         continue;\n       }\n \n       Element corporaChildElement = (Element) corporaChildNode;\n \n \n       if (TYPESYSTEM_ELEMENT.equals(corporaChildElement.getNodeName())) {\n         dotCorpus.setTypeSystemFilename(corporaChildElement.getAttribute(TYPESYTEM_FILE_ATTRIBUTE));\n       } else if (CORPUS_ELEMENT.equals(corporaChildElement.getNodeName())) {\n         String corpusFolderName = corporaChildElement.getAttribute(CORPUS_FOLDER_ATTRIBUTE);\n \n         dotCorpus.addCorpusFolder(corpusFolderName);\n       } else if (STYLE_ELEMENT.equals(corporaChildElement.getNodeName())) {\n         String type = corporaChildElement.getAttribute(STYLE_TYPE_ATTRIBUTE);\n \n         String styleString = corporaChildElement.getAttribute(STYLE_STYLE_ATTRIBUTE);\n \n         int colorInteger = Integer\n                 .parseInt(corporaChildElement.getAttribute(STYLE_COLOR_ATTRIBUTE));\n \n         Color color = new Color(colorInteger);\n \n         String drawingLayerString = corporaChildElement.getAttribute(STYLE_LAYER_ATTRIBUTE);\n \n         String drawingConfigString = corporaChildElement.getAttribute(STYLE_CONFIG_ATTRIBUTE);\n \n         if (drawingConfigString.length() == 0)\n           drawingConfigString = null;\n \n         int drawingLayer;\n \n         try {\n           drawingLayer = Integer.parseInt(drawingLayerString);\n         } catch (NumberFormatException e) {\n           drawingLayer = 0;\n         }\n \n         AnnotationStyle style = new AnnotationStyle(type, AnnotationStyle.Style\n                 .valueOf(styleString), color, drawingLayer, drawingConfigString);\n \n         dotCorpus.setStyle(style);\n       } else if (CAS_PROCESSOR_ELEMENT.equals(corporaChildElement.getNodeName())) {\n         dotCorpus.addCasProcessorFolder(corporaChildElement\n                 .getAttribute(CAS_PROCESSOR_FOLDER_ATTRIBUTE));\n       } else if (EDITOR_ELEMENT.equals(corporaChildElement.getNodeName())) {\n         String lineLengthHintString = corporaChildElement\n                 .getAttribute(EDITOR_LINE_LENGTH_ATTRIBUTE);\n \n         int lineLengthHint = Integer.parseInt(lineLengthHintString);\n \n         dotCorpus.setEditorLineLength(lineLengthHint);\n       } else if (SHOWN_ELEMENT.equals(corporaChildElement.getNodeName())) {\n         String type = corporaChildElement.getAttribute(SHOWN_TYPE_ATTRIBUTE);\n \n         String isVisisbleString = corporaChildElement.getAttribute(SHOWN_IS_VISISBLE_ATTRIBUTE);\n \n         boolean isVisible = Boolean.parseBoolean(isVisisbleString);\n \n         if (isVisible) {\n           dotCorpus.setShownType(type);\n         }\n       }\n       else {\n         String message = \"Unexpected element: \" + corporaChildElement.getNodeName();\n \n         IStatus s = new Status(IStatus.ERROR, CasEditorPlugin.ID, IStatus.OK, message, null);\n \n         throw new CoreException(s);\n       }\n     }\n \n     return dotCorpus;\n   }\n \n", "target": "// fix_start\n    try {\n      documentBuilderFacoty.setFeature(\"http://apache.org/xml/features/disallow-doctype-decl\", true);\n    } catch (ParserConfigurationException e1) {\n      throw new RuntimeException(e1);\n    }\n// fix_end\n", "cwe": "CWE-611", "cwe_name": "Improper Restriction of XML External Entity Reference ('XXE')", "idx": 70515}
{"source": " public void loadXmiFile(File xmiCasFile) {\n     try {\n       setXcasFileOpenDir(xmiCasFile.getParentFile());\n       Timer time = new Timer();\n       time.start();\n// bug_start\n      SAXParser parser = SAXParserFactory.newInstance().newSAXParser();\n// bug_end\n       XmiCasDeserializer xmiCasDeserializer = new XmiCasDeserializer(getCas().getTypeSystem());\n       getCas().reset();\n       parser.parse(xmiCasFile, xmiCasDeserializer.getXmiCasHandler(getCas(), true));\n       time.stop();\n       handleSofas();\n \n       setTitle(\"XMI CAS\");\n       updateIndexTree(true);\n       setRunOnCasEnabled();\n       setEnableCasFileReadingAndWriting();\n       setStatusbarMessage(\"Done loading XMI CAS file in \" + time.getTimeSpan() + \".\");\n     } catch (Exception e) {\n       e.printStackTrace();\n       handleException(e);\n     }\n   }\n \n", "target": "// fix_start\n      SAXParserFactory saxParserFactory = SAXParserFactory.newInstance();\n      saxParserFactory.setFeature(\"http://apache.org/xml/features/disallow-doctype-decl\", true);\n      SAXParser parser = saxParserFactory.newSAXParser();\n// fix_end\n", "cwe": "CWE-611", "cwe_name": "Improper Restriction of XML External Entity Reference ('XXE')", "idx": 70544}
{"source": "// bug_start\nprivate Document parse(String configFile) {\n    Document doc = null;\n    try {\n// bug_end\n \n// bug_start\n      SAXParserFactory factory = SAXParserFactory.newInstance();\n      factory.setValidating(false);\n\n      SAXParser parser = factory.newSAXParser();\n      parser.parse(configFile, this);\n\n      UIMAFramework.getLogger().log(Level.CONFIG, \"Resource::\" + getResourceSpecifierPath());\n      UIMAFramework.getLogger().log(Level.CONFIG, \"Instance Count::\" + getInstanceCount());\n      UIMAFramework.getLogger().log(Level.CONFIG, \"Service Name::\" + getServiceName());\n      UIMAFramework.getLogger().log(Level.CONFIG, \"Filter String::\" + getFilterString());\n      UIMAFramework.getLogger().log(Level.CONFIG, \"Naming Service Host::\" + getNamingServiceHost());\n      UIMAFramework.getLogger().log(Level.CONFIG,\n              \"Server Socket Timeout::\" + getServerSocketTimeout());\n\n    } catch (Exception ex) {\n      ex.printStackTrace();\n    }\n    return doc;\n  }\n\n// bug_end\n", "target": "// fix_start\npublic Thread newThread(final Runnable r) {\n            return doPrivileged(new PrivilegedAction<Thread>() {\n                public Thread run() {\n                    final Thread taskThread = new Thread(threadGroup, r, name + \" task-\" + getNextSeq(), stackSize);\n                    if (markThreadAsDaemon) {\n                        taskThread.setDaemon(true);\n                    }\n                    return taskThread;\n                }\n            });\n        }\n// fix_end\n", "cwe": "CWE-611", "cwe_name": "Improper Restriction of XML External Entity Reference ('XXE')", "idx": 70225}
{"source": "// bug_start\nprivate File file(String id) throws IOException {\n        File storageDir = directory();\n        if (storageDir == null) {\n            return null;\n// bug_end\n         }\n \n// bug_start\n        String filename = id + FILE_EXT;\n        File file = new File(storageDir, filename);\n\n        if (!file.getCanonicalPath().startsWith(storageDir.getCanonicalPath())) {\n            log.warn(sm.getString(\"fileStore.invalid\", file.getPath(), id));\n            return null;\n        }\n\n        return file;\n    }\n\n// bug_end\n", "target": "// fix_start\npublic Thread newThread(final Runnable r) {\n            return doPrivileged(new PrivilegedAction<Thread>() {\n                public Thread run() {\n                    final Thread taskThread = new Thread(threadGroup, new Runnable() {\n                        @Override\n                        public void run() {\n                            try {\n                                r.run();\n                            } finally {\n                                xnio.handleThreadExit();\n                            }\n                        }\n                    }, name + \" task-\" + getNextSeq(), stackSize);\n                    if (markThreadAsDaemon) {\n                        taskThread.setDaemon(true);\n                    }\n                    return taskThread;\n                }\n            });\n// fix_end\n", "cwe": "NVD-CWE-Other", "cwe_name": "Other", "idx": 109836}
{"source": "// bug_start\nprivate File file(String id) throws IOException {\n        if (this.directory == null) {\n            return null;\n// bug_end\n         }\n// bug_start\n        String filename = id + FILE_EXT;\n        File file = new File(directory(), filename);\n        return file;\n// bug_end\n     }\n \n", "target": "// fix_start\nprivate SSLException checkSSLAlerts() {\n        debug(\"JSSEngine: Checking inbound and outbound SSL Alerts. Have \" + ssl_fd.inboundAlerts.size() + \" inbound and \" + ssl_fd.outboundAlerts.size() + \" outbound alerts.\");\n\n        while (ssl_fd.inboundOffset < ssl_fd.inboundAlerts.size()) {\n            SSLAlertEvent event = ssl_fd.inboundAlerts.get(ssl_fd.inboundOffset);\n            ssl_fd.inboundOffset += 1;\n\n            if (event.getLevelEnum() == SSLAlertLevel.WARNING && event.getDescriptionEnum() == SSLAlertDescription.CLOSE_NOTIFY) {\n                debug(\"Got inbound CLOSE_NOTIFY alert\");\n                closeInbound();\n            }\n\n            debug(\"JSSEngine: Got inbound alert: \" + event);\n\n            fireAlertReceived(event);\n\n            SSLException exception = event.toException();\n            if (exception != null) {\n                return exception;\n            }\n// fix_end\n// fix_start\n\n        while (ssl_fd.outboundOffset < ssl_fd.outboundAlerts.size()) {\n            SSLAlertEvent event = ssl_fd.outboundAlerts.get(ssl_fd.outboundOffset);\n            ssl_fd.outboundOffset += 1;\n\n            if (event.getLevelEnum() == SSLAlertLevel.WARNING && event.getDescriptionEnum() == SSLAlertDescription.CLOSE_NOTIFY) {\n                debug(\"Sent outbound CLOSE_NOTIFY alert.\");\n                closeOutbound();\n            }\n\n            debug(\"JSSEngine: Got outbound alert: \" + event);\n\n            fireAlertSent(event);\n\n            SSLException exception = event.toException();\n            if (exception != null) {\n                return exception;\n            }\n        }\n\n        return null;\n// fix_end\n", "cwe": "CWE-502", "cwe_name": "Deserialization of Untrusted Data", "idx": 59369}
{"source": "// bug_start\nprivate SSLException checkSSLAlerts() {\n        debug(\"JSSEngine: Checking inbound and outbound SSL Alerts. Have \" + ssl_fd.inboundAlerts.size() + \" inbound and \" + ssl_fd.outboundAlerts.size() + \" outbound alerts.\");\n// bug_end\n \n// bug_start\n        while (ssl_fd.inboundOffset < ssl_fd.inboundAlerts.size()) {\n            SSLAlertEvent event = ssl_fd.inboundAlerts.get(ssl_fd.inboundOffset);\n            ssl_fd.inboundOffset += 1;\n\t    event.setEngine(this);\n\n            if (event.getLevelEnum() == SSLAlertLevel.WARNING && event.getDescriptionEnum() == SSLAlertDescription.CLOSE_NOTIFY) {\n                debug(\"Got inbound CLOSE_NOTIFY alert\");\n                closeInbound();\n            }\n\n            debug(\"JSSEngine: Got inbound alert: \" + event);\n\n            fireAlertReceived(event);\n\n            SSLException exception = event.toException();\n            if (exception != null) {\n                return exception;\n            }\n// bug_end\n         }\n \n// bug_start\n        while (ssl_fd.outboundOffset < ssl_fd.outboundAlerts.size()) {\n            SSLAlertEvent event = ssl_fd.outboundAlerts.get(ssl_fd.outboundOffset);\n            ssl_fd.outboundOffset += 1;\n            event.setEngine(this);\n// bug_end\n \n// bug_start\n            if (event.getLevelEnum() == SSLAlertLevel.WARNING && event.getDescriptionEnum() == SSLAlertDescription.CLOSE_NOTIFY) {\n                debug(\"Sent outbound CLOSE_NOTIFY alert.\");\n                closeOutbound();\n            }\n// bug_end\n \n// bug_start\n            debug(\"JSSEngine: Got outbound alert: \" + event);\n// bug_end\n \n// bug_start\n            fireAlertSent(event);\n// bug_end\n \n// bug_start\n            SSLException exception = event.toException();\n            if (exception != null) {\n                return exception;\n            }\n// bug_end\n         }\n// bug_start\n\n        return null;\n// bug_end\n     }\n \n", "target": "// fix_start\npublic static void securityClassLoad(ClassLoader loader){\n// fix_end\n// fix_start\n        if( System.getSecurityManager() == null ){\n            return;\n// fix_end\n// fix_start\n        final String basePackage = \"org.apache.jasper.\";\n        try {\n            loader.loadClass( basePackage +\n                \"runtime.JspFactoryImpl$PrivilegedGetPageContext\");\n            loader.loadClass( basePackage +\n                \"runtime.JspFactoryImpl$PrivilegedReleasePageContext\");\n// fix_end\n// fix_start\n            loader.loadClass( basePackage +\n                \"runtime.JspRuntimeLibrary\");\n// fix_end\n// fix_start\n            loader.loadClass( basePackage +\n                \"runtime.ServletResponseWrapperInclude\");\n            loader.loadClass( basePackage +\n                \"runtime.TagHandlerPool\");\n            loader.loadClass( basePackage +\n                \"runtime.JspFragmentHelper\");\n// fix_end\n// fix_start\n            loader.loadClass( basePackage +\n                \"runtime.ProtectedFunctionMapper\");\n// fix_end\n// fix_start\n            loader.loadClass( basePackage +\n                \"runtime.PageContextImpl\");\n            loader.loadClass( basePackage +\n                \"runtime.PageContextImpl$1\");\n            loader.loadClass( basePackage +\n                \"runtime.PageContextImpl$2\");\n            loader.loadClass( basePackage +\n                \"runtime.PageContextImpl$3\");\n            loader.loadClass( basePackage +\n                \"runtime.PageContextImpl$4\");\n            loader.loadClass( basePackage +\n                \"runtime.PageContextImpl$5\");\n            loader.loadClass( basePackage +\n                \"runtime.PageContextImpl$6\");\n            loader.loadClass( basePackage +\n                \"runtime.PageContextImpl$7\");\n            loader.loadClass( basePackage +\n                \"runtime.PageContextImpl$8\");\n            loader.loadClass( basePackage +\n                \"runtime.PageContextImpl$9\");\n            loader.loadClass( basePackage +\n                \"runtime.PageContextImpl$10\");\n            loader.loadClass( basePackage +\n                \"runtime.PageContextImpl$11\");\n            loader.loadClass( basePackage +\n                \"runtime.PageContextImpl$12\");\n\n            loader.loadClass( basePackage +\n                \"runtime.JspContextWrapper\");\n\n            SecurityUtil.isPackageProtectionEnabled();\n\n            loader.loadClass( basePackage +\n                \"servlet.JspServletWrapper\");\n\n            loader.loadClass( basePackage +\n                \"runtime.JspWriterImpl$1\");\n        } catch (ClassNotFoundException ex) {\n            log.error(\"SecurityClassLoad\", ex);\n// fix_end\n// fix_start\n// fix_end\n", "cwe": "CWE-401", "cwe_name": "Missing Release of Memory after Effective Lifetime", "idx": 52917}
{"source": "// bug_start\npublic static void securityClassLoad(ClassLoader loader){\n// bug_end\n \n// bug_start\n        if( System.getSecurityManager() == null ){\n            return;\n        }\n\n        final String basePackage = \"org.apache.jasper.\";\n        try {\n            loader.loadClass( basePackage +\n                \"runtime.JspFactoryImpl$PrivilegedGetPageContext\");\n            loader.loadClass( basePackage +\n                \"runtime.JspFactoryImpl$PrivilegedReleasePageContext\");\n\n            loader.loadClass( basePackage +\n                \"runtime.JspRuntimeLibrary\");\n            loader.loadClass( basePackage +\n                \"runtime.JspRuntimeLibrary$PrivilegedIntrospectHelper\");\n\n            loader.loadClass( basePackage +\n                \"runtime.ServletResponseWrapperInclude\");\n            loader.loadClass( basePackage +\n                \"runtime.TagHandlerPool\");\n            loader.loadClass( basePackage +\n                \"runtime.JspFragmentHelper\");\n\n            loader.loadClass( basePackage +\n                \"runtime.ProtectedFunctionMapper\");\n\n            loader.loadClass( basePackage +\n                \"runtime.PageContextImpl\");\n            loader.loadClass( basePackage +\n                \"runtime.PageContextImpl$1\");\n            loader.loadClass( basePackage +\n                \"runtime.PageContextImpl$2\");\n            loader.loadClass( basePackage +\n                \"runtime.PageContextImpl$3\");\n            loader.loadClass( basePackage +\n                \"runtime.PageContextImpl$4\");\n            loader.loadClass( basePackage +\n                \"runtime.PageContextImpl$5\");\n            loader.loadClass( basePackage +\n                \"runtime.PageContextImpl$6\");\n            loader.loadClass( basePackage +\n                \"runtime.PageContextImpl$7\");\n            loader.loadClass( basePackage +\n                \"runtime.PageContextImpl$8\");\n            loader.loadClass( basePackage +\n                \"runtime.PageContextImpl$9\");\n            loader.loadClass( basePackage +\n                \"runtime.PageContextImpl$10\");\n            loader.loadClass( basePackage +\n                \"runtime.PageContextImpl$11\");\n            loader.loadClass( basePackage +\n                \"runtime.PageContextImpl$12\");\n\n            loader.loadClass( basePackage +\n                \"runtime.JspContextWrapper\");\n\n            SecurityUtil.isPackageProtectionEnabled();\n\n            loader.loadClass( basePackage +\n                \"servlet.JspServletWrapper\");\n\n            loader.loadClass( basePackage +\n                \"runtime.JspWriterImpl$1\");\n        } catch (ClassNotFoundException ex) {\n            log.error(\"SecurityClassLoad\", ex);\n        }\n    }\n\n// bug_end\n", "target": "// fix_start\nprivate Document parseXML(InputStream pXmlFile) throws ParserException {\n    final DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();\n    dbf.setValidating(false);\n    try {\n      dbf.setFeature(XMLConstants.FEATURE_SECURE_PROCESSING, true);\n    } catch (ParserConfigurationException e) {\n    }\n    final DocumentBuilder db;\n    try {\n      db = dbf.newDocumentBuilder();\n    } catch (Exception se) {\n      throw new ParserException(\"XML Parser configuration error.\", se);\n    }\n    try {\n      db.setEntityResolver(getEntityResolver());\n      db.setErrorHandler(getErrorHandler());\n      return db.parse(pXmlFile);\n    } catch (Exception se) {\n      throw new ParserException(\"Error parsing XML stream: \" + se, se);\n    }\n  }\n// fix_end\n", "cwe": "NVD-CWE-noinfo", "cwe_name": "", "idx": 99754}
{"source": "// bug_start\nstatic Document parseXML(InputStream pXmlFile) throws ParserException {\n    DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();\n    DocumentBuilder db = null;\n    try {\n      db = dbf.newDocumentBuilder();\n    }\n    catch (Exception se) {\n      throw new ParserException(\"XML Parser configuration error\", se);\n    }\n    org.w3c.dom.Document doc = null;\n    try {\n      doc = db.parse(pXmlFile);\n    }\n    catch (Exception se) {\n      throw new ParserException(\"Error parsing XML stream:\" + se, se);\n    }\n    return doc;\n  }\n// bug_end\n \n", "target": "// fix_start\nprivate LikeCondition createLike(Type type, String toMatch) {\n\t\tif (notLike) {\n\t\t\treturn new NotLikeCondition(type, selector, toMatch);\n\t\t} else {\n\t\t\treturn new LikeCondition(type, selector, toMatch);\n\t\t}\n\t}\n// fix_end\n", "cwe": "CWE-611", "cwe_name": "Improper Restriction of XML External Entity Reference ('XXE')", "idx": 67654}
{"source": "// bug_start\npublic User getUser() {\n            return user;\n        }\n// bug_end\n \n", "target": "// fix_start\nprivate LikeCondition createLike(Type type, String toMatch) {\n\t\tif (notLike) {\n\t\t\treturn new NotLikeCondition(selector, selector.generateParameter(type.wrap(toMatch)));\n\t\t} else {\n\t\t\treturn new LikeCondition(selector, selector.generateParameter(type.wrap(toMatch)));\n\t\t}\n\t}\n// fix_end\n", "cwe": "NVD-CWE-noinfo", "cwe_name": "", "idx": 104987}
{"source": "// bug_start\nprivate static PropertyPath create(String source, TypeInformation<?> type, String addTail, List<PropertyPath> base) {\n// bug_end\n \n// bug_start\n\t\tif (base.size() > 1000) {\n\t\t\tthrow new IllegalArgumentException(PARSE_DEPTH_EXCEEDED);\n\t\t}\n\n\t\tPropertyReferenceException exception = null;\n\t\tPropertyPath current = null;\n\n\t\ttry {\n\n\t\t\tcurrent = new PropertyPath(source, type, base);\n\n\t\t\tif (!base.isEmpty()) {\n\t\t\t\tbase.get(base.size() - 1).next = current;\n\t\t\t}\n\n\t\t\tList<PropertyPath> newBase = new ArrayList<>(base);\n\t\t\tnewBase.add(current);\n\n\t\t\tif (StringUtils.hasText(addTail)) {\n\t\t\t\tcurrent.next = create(addTail, current.actualTypeInformation, newBase);\n\t\t\t}\n\n\t\t\treturn current;\n\n\t\t} catch (PropertyReferenceException e) {\n\n\t\t\tif (current != null) {\n\t\t\t\tthrow e;\n\t\t\t}\n\n\t\t\texception = e;\n\t\t}\n\n\t\tPattern pattern = Pattern.compile(\"\\\\p{Lu}+\\\\p{Ll}*$\");\n\t\tMatcher matcher = pattern.matcher(source);\n\n\t\tif (matcher.find() && matcher.start() != 0) {\n\n\t\t\tint position = matcher.start();\n\t\t\tString head = source.substring(0, position);\n\t\t\tString tail = source.substring(position);\n\n\t\t\ttry {\n\t\t\t\treturn create(head, type, tail + addTail, base);\n\t\t\t} catch (PropertyReferenceException e) {\n\t\t\t\tthrow e.hasDeeperResolutionDepthThan(exception) ? e : exception;\n\t\t\t}\n\t\t}\n\n\t\tthrow exception;\n\t}\n\n// bug_end\n", "target": "// fix_start\npublic User getUser() {\n            return userId == null\n                    ? User.getUnknown()\n                    : User.getById(userId, true)\n            ;\n        }\n// fix_end\n", "cwe": "CWE-200", "cwe_name": "Exposure of Sensitive Information to an Unauthorized Actor", "idx": 13601}
{"source": "// bug_start\nprivate static PropertyPath create(String source, TypeInformation<?> type, String addTail, List<PropertyPath> base) {\n// bug_end\n \n// bug_start\n\t\tPropertyReferenceException exception = null;\n\t\tPropertyPath current = null;\n// bug_end\n \n// bug_start\n\t\ttry {\n// bug_end\n \n// bug_start\n\t\t\tcurrent = new PropertyPath(source, type, base);\n// bug_end\n \n// bug_start\n\t\t\tif (!base.isEmpty()) {\n\t\t\t\tbase.get(base.size() - 1).next = current;\n\t\t\t}\n// bug_end\n \n// bug_start\n\t\t\tList<PropertyPath> newBase = new ArrayList<>(base);\n\t\t\tnewBase.add(current);\n\n\t\t\tif (StringUtils.hasText(addTail)) {\n\t\t\t\tcurrent.next = create(addTail, current.actualTypeInformation, newBase);\n\t\t\t}\n\n\t\t\treturn current;\n\n\t\t} catch (PropertyReferenceException e) {\n\n\t\t\tif (current != null) {\n\t\t\t\tthrow e;\n\t\t\t}\n\n\t\t\texception = e;\n\t\t}\n\n\t\tPattern pattern = Pattern.compile(\"\\\\p{Lu}+\\\\p{Ll}*$\");\n\t\tMatcher matcher = pattern.matcher(source);\n\n\t\tif (matcher.find() && matcher.start() != 0) {\n\n\t\t\tint position = matcher.start();\n\t\t\tString head = source.substring(0, position);\n\t\t\tString tail = source.substring(position);\n\n\t\t\ttry {\n\t\t\t\treturn create(head, type, tail + addTail, base);\n\t\t\t} catch (PropertyReferenceException e) {\n\t\t\t\tthrow e.hasDeeperResolutionDepthThan(exception) ? e : exception;\n\t\t\t}\n\t\t}\n\n\t\tthrow exception;\n\t}\n\n// bug_end\n", "target": "// fix_start\npublic SendfileState processSendfile(SelectionKey sk, KeyAttachment attachment,\n                boolean calledByProcessor) {\n            NioChannel sc = null;\n            try {\n                unreg(sk, attachment, sk.readyOps());\n                SendfileData sd = attachment.getSendfileData();\n// fix_end\n// fix_start\n                if (log.isTraceEnabled()) {\n                    log.trace(\"Processing send file for: \" + sd.fileName);\n                }\n// fix_end\n// fix_start\n                if (sd.fchannel == null) {\n                    File f = new File(sd.fileName);\n                    if (!f.exists()) {\n                        cancelledKey(sk,SocketStatus.ERROR);\n                        return SendfileState.ERROR;\n                    }\n                    @SuppressWarnings(\"resource\")\n                    FileInputStream fis = new FileInputStream(f);\n                    sd.fchannel = fis.getChannel();\n                }\n// fix_end\n// fix_start\n                sc = attachment.getSocket();\n                WritableByteChannel wc = ((sc instanceof SecureNioChannel)?sc:sc.getIOChannel());\n// fix_end\n// fix_start\n                if (sc.getOutboundRemaining()>0) {\n                    if (sc.flushOutbound()) {\n                        attachment.access();\n                    }\n                } else {\n                    long written = sd.fchannel.transferTo(sd.pos,sd.length,wc);\n                    if (written > 0) {\n                        sd.pos += written;\n                        sd.length -= written;\n                        attachment.access();\n                    } else {\n                        if (sd.fchannel.size() <= sd.pos) {\n                            throw new IOException(\"Sendfile configured to \" +\n                                    \"send more data than was available\");\n                        }\n                    }\n                }\n                if (sd.length <= 0 && sc.getOutboundRemaining()<=0) {\n                    if (log.isDebugEnabled()) {\n                        log.debug(\"Send file complete for: \"+sd.fileName);\n                    }\n                    attachment.setSendfileData(null);\n                    try {\n                        sd.fchannel.close();\n                    } catch (Exception ignore) {\n                    }\n                    if (!calledByProcessor) {\n                        if (sd.keepAlive) {\n                            if (log.isDebugEnabled()) {\n                                log.debug(\"Connection is keep alive, registering back for OP_READ\");\n                            }\n                            reg(sk,attachment,SelectionKey.OP_READ);\n                        } else {\n                            if (log.isDebugEnabled()) {\n                                log.debug(\"Send file connection is being closed\");\n                            }\n                            cancelledKey(sk,SocketStatus.STOP);\n                        }\n                    }\n                    return SendfileState.DONE;\n                } else {\n                    if (log.isDebugEnabled()) {\n                        log.debug(\"OP_WRITE for sendfile: \" + sd.fileName);\n                    }\n                    if (calledByProcessor) {\n                        add(attachment.getSocket(),SelectionKey.OP_WRITE);\n                    } else {\n                        reg(sk,attachment,SelectionKey.OP_WRITE);\n                    }\n                    return SendfileState.PENDING;\n                }\n            }catch ( IOException x ) {\n                if ( log.isDebugEnabled() ) log.debug(\"Unable to complete sendfile request:\", x);\n                cancelledKey(sk,SocketStatus.ERROR);\n                return SendfileState.ERROR;\n            }catch ( Throwable t ) {\n                log.error(\"\",t);\n                cancelledKey(sk, SocketStatus.ERROR);\n                return SendfileState.ERROR;\n            }\n        }\n// fix_end\n", "cwe": "CWE-770", "cwe_name": "Allocation of Resources Without Limits or Throttling", "idx": 76331}
{"source": "// bug_start\n@SuppressWarnings({\"unchecked\", \"rawtypes\"})\n    @Override\n    public boolean start() throws Exception {\n        String job = step.getJob();\n        Item item = Jenkins.getActiveInstance().getItem(job, invokingRun.getParent(), Item.class);\n        if (item == null) {\n            throw new AbortException(\"No item named \" + job + \" found\");\n// bug_end\n         }\n// bug_start\n        item.checkPermission(Item.BUILD);\n        if (step.getWait() && !(item instanceof Job)) {\n            throw new AbortException(\"Waiting for non-job items is not supported\");\n        }\n        if (item instanceof ParameterizedJobMixIn.ParameterizedJob) {\n            final ParameterizedJobMixIn.ParameterizedJob project = (ParameterizedJobMixIn.ParameterizedJob) item;\n            listener.getLogger().println(\"Scheduling project: \" + ModelHyperlinkNote.encodeTo(project));\n// bug_end\n \n// bug_start\n            node.addAction(new LabelAction(Messages.BuildTriggerStepExecution_building_(project.getFullDisplayName())));\n            List<Action> actions = new ArrayList<>();\n            if (step.getWait()) {\n                StepContext context = getContext();\n                actions.add(new BuildTriggerAction(context, step.isPropagate()));\n                LOGGER.log(Level.FINER, \"scheduling a build of {0} from {1}\", new Object[]{project, context});\n            }\n            actions.add(new CauseAction(new Cause.UpstreamCause(invokingRun)));\n            List<ParameterValue> parameters = step.getParameters();\n            if (parameters != null) {\n                parameters = completeDefaultParameters(parameters, (Job) project);\n                actions.add(new ParametersAction(parameters));\n            }\n            Integer quietPeriod = step.getQuietPeriod();\n            if (quietPeriod == null) {\n                quietPeriod = project.getQuietPeriod();\n            }\n            QueueTaskFuture<?> f = new ParameterizedJobMixIn() {\n                @Override\n                protected Job asJob() {\n                    return (Job) project;\n                }\n            }.scheduleBuild2(quietPeriod, actions.toArray(new Action[actions.size()]));\n            if (f == null) {\n                throw new AbortException(\"Failed to trigger build of \" + project.getFullName());\n            }\n        } else if (item instanceof Queue.Task){\n            if (step.getParameters() != null && !step.getParameters().isEmpty()) {\n                throw new AbortException(\"Item type does not support parameters\");\n            }\n            Queue.Task task = (Queue.Task) item;\n            listener.getLogger().println(\"Scheduling item: \" + ModelHyperlinkNote.encodeTo(item));\n            node.addAction(new LabelAction(Messages.BuildTriggerStepExecution_building_(task.getFullDisplayName())));\n            List<Action> actions = new ArrayList<>();\n            if (step.getWait()) {\n                StepContext context = getContext();\n                actions.add(new BuildTriggerAction(context, step.isPropagate()));\n                LOGGER.log(Level.FINER, \"scheduling a build of {0} from {1}\", new Object[]{task, context});\n            }\n            actions.add(new CauseAction(new Cause.UpstreamCause(invokingRun)));\n            Integer quietPeriod = step.getQuietPeriod();\n            if (quietPeriod == null) {\n                try {\n                    Method getQuietPeriod = task.getClass().getMethod(\"getQuietPeriod\");\n                    if (getQuietPeriod.getReturnType().equals(int.class)) {\n                        quietPeriod = (Integer) getQuietPeriod.invoke(task);\n                    }\n                } catch (NoSuchMethodException e) {\n                } catch (IllegalAccessError | IllegalArgumentException | InvocationTargetException e) {\n                    LOGGER.log(Level.WARNING, \"Could not determine quiet period of \" + item.getFullName(), e);\n                }\n            }\n            if (quietPeriod == null) {\n                quietPeriod = Jenkins.getActiveInstance().getQuietPeriod();\n            }\n            ScheduleResult scheduleResult = Jenkins.getActiveInstance().getQueue().schedule2(task, quietPeriod,actions);\n            if (scheduleResult.isRefused()) {\n                throw new AbortException(\"Failed to trigger build of \" + item.getFullName());\n            }\n        } else {\n            throw new AbortException(\"The item named \" + job + \" is a \"\n                    + (item instanceof Describable\n                    ? ((Describable) item).getDescriptor().getDisplayName()\n                    : item.getClass().getName())\n                    + \" which is not something that can be built\");\n        }\n        if (step.getWait()) {\n            return false;\n        } else {\n            getContext().onSuccess(null);\n            return true;\n        }\n    }\n\n// bug_end\n", "target": "// fix_start\npublic SendfileState processSendfile(SelectionKey sk, KeyAttachment attachment,\n                boolean calledByProcessor) {\n            NioChannel sc = null;\n            try {\n                unreg(sk, attachment, sk.readyOps());\n                SendfileData sd = attachment.getSendfileData();\n\n                if (log.isTraceEnabled()) {\n                    log.trace(\"Processing send file for: \" + sd.fileName);\n                }\n\n                if (sd.fchannel == null) {\n                    File f = new File(sd.fileName);\n                    if (!f.exists()) {\n                        cancelledKey(sk,SocketStatus.ERROR);\n                        return SendfileState.ERROR;\n                    }\n                    @SuppressWarnings(\"resource\")\n                    FileInputStream fis = new FileInputStream(f);\n                    sd.fchannel = fis.getChannel();\n                }\n\n                sc = attachment.getSocket();\n                WritableByteChannel wc = ((sc instanceof SecureNioChannel)?sc:sc.getIOChannel());\n\n                if (sc.getOutboundRemaining()>0) {\n                    if (sc.flushOutbound()) {\n                        attachment.access();\n                    }\n                } else {\n                    long written = sd.fchannel.transferTo(sd.pos,sd.length,wc);\n                    if (written > 0) {\n                        sd.pos += written;\n                        sd.length -= written;\n                        attachment.access();\n                    } else {\n                        if (sd.fchannel.size() <= sd.pos) {\n                            throw new IOException(\"Sendfile configured to \" +\n                                    \"send more data than was available\");\n                        }\n                    }\n                }\n                if (sd.length <= 0 && sc.getOutboundRemaining()<=0) {\n                    if (log.isDebugEnabled()) {\n                        log.debug(\"Send file complete for: \"+sd.fileName);\n                    }\n                    attachment.setSendfileData(null);\n                    try {\n                        sd.fchannel.close();\n                    } catch (Exception ignore) {\n                    }\n                    if (!calledByProcessor) {\n                        if (sd.keepAlive) {\n                            if (log.isDebugEnabled()) {\n                                log.debug(\"Connection is keep alive, registering back for OP_READ\");\n                            }\n                            reg(sk,attachment,SelectionKey.OP_READ);\n                        } else {\n                            if (log.isDebugEnabled()) {\n                                log.debug(\"Send file connection is being closed\");\n                            }\n                            cancelledKey(sk,SocketStatus.STOP);\n                        }\n                    }\n                    return SendfileState.DONE;\n                } else {\n                    if (log.isDebugEnabled()) {\n                        log.debug(\"OP_WRITE for sendfile: \" + sd.fileName);\n                    }\n                    if (calledByProcessor) {\n                        add(attachment.getSocket(),SelectionKey.OP_WRITE);\n                    } else {\n                        reg(sk,attachment,SelectionKey.OP_WRITE);\n                    }\n                    return SendfileState.PENDING;\n                }\n            }catch ( IOException x ) {\n                if ( log.isDebugEnabled() ) log.debug(\"Unable to complete sendfile request:\", x);\n                if (!calledByProcessor) {\n                    cancelledKey(sk,SocketStatus.ERROR);\n                }\n                return SendfileState.ERROR;\n            }catch ( Throwable t ) {\n                log.error(\"\",t);\n                if (!calledByProcessor) {\n                    cancelledKey(sk, SocketStatus.ERROR);\n                }\n                return SendfileState.ERROR;\n            }\n// fix_end\n// fix_start\n// fix_end\n", "cwe": "CWE-388", "cwe_name": "Error Handling Issues", "idx": 50717}
{"source": "// bug_start\n@SuppressWarnings({\"unchecked\", \"rawtypes\"})\n    @Override\n    public boolean start() throws Exception {\n        String job = step.getJob();\n        Item item = Jenkins.getActiveInstance().getItem(job, invokingRun.getParent(), Item.class);\n        if (item == null) {\n            throw new AbortException(\"No item named \" + job + \" found\");\n// bug_end\n         }\n// bug_start\n        if (step.getWait() && !(item instanceof Job)) {\n            throw new AbortException(\"Waiting for non-job items is not supported\");\n// bug_end\n         }\n// bug_start\n        if (item instanceof ParameterizedJobMixIn.ParameterizedJob) {\n            final ParameterizedJobMixIn.ParameterizedJob project = (ParameterizedJobMixIn.ParameterizedJob) item;\n            listener.getLogger().println(\"Scheduling project: \" + ModelHyperlinkNote.encodeTo(project));\n// bug_end\n \n// bug_start\n            node.addAction(new LabelAction(Messages.BuildTriggerStepExecution_building_(project.getFullDisplayName())));\n            List<Action> actions = new ArrayList<>();\n            if (step.getWait()) {\n                StepContext context = getContext();\n                actions.add(new BuildTriggerAction(context, step.isPropagate()));\n                LOGGER.log(Level.FINER, \"scheduling a build of {0} from {1}\", new Object[]{project, context});\n            }\n            actions.add(new CauseAction(new Cause.UpstreamCause(invokingRun)));\n            List<ParameterValue> parameters = step.getParameters();\n            if (parameters != null) {\n                parameters = completeDefaultParameters(parameters, (Job) project);\n                actions.add(new ParametersAction(parameters));\n            }\n            Integer quietPeriod = step.getQuietPeriod();\n            if (quietPeriod == null) {\n                quietPeriod = project.getQuietPeriod();\n            }\n            QueueTaskFuture<?> f = new ParameterizedJobMixIn() {\n                @Override\n                protected Job asJob() {\n                    return (Job) project;\n                }\n            }.scheduleBuild2(quietPeriod, actions.toArray(new Action[actions.size()]));\n            if (f == null) {\n                throw new AbortException(\"Failed to trigger build of \" + project.getFullName());\n            }\n        } else if (item instanceof Queue.Task){\n            if (step.getParameters() != null && !step.getParameters().isEmpty()) {\n                throw new AbortException(\"Item type does not support parameters\");\n            }\n            Queue.Task task = (Queue.Task) item;\n            listener.getLogger().println(\"Scheduling item: \" + ModelHyperlinkNote.encodeTo(item));\n            node.addAction(new LabelAction(Messages.BuildTriggerStepExecution_building_(task.getFullDisplayName())));\n            List<Action> actions = new ArrayList<>();\n            if (step.getWait()) {\n                StepContext context = getContext();\n                actions.add(new BuildTriggerAction(context, step.isPropagate()));\n                LOGGER.log(Level.FINER, \"scheduling a build of {0} from {1}\", new Object[]{task, context});\n            }\n            actions.add(new CauseAction(new Cause.UpstreamCause(invokingRun)));\n            Integer quietPeriod = step.getQuietPeriod();\n            if (quietPeriod == null) {\n                try {\n                    Method getQuietPeriod = task.getClass().getMethod(\"getQuietPeriod\");\n                    if (getQuietPeriod.getReturnType().equals(int.class)) {\n                        quietPeriod = (Integer) getQuietPeriod.invoke(task);\n                    }\n                } catch (NoSuchMethodException e) {\n                } catch (IllegalAccessError | IllegalArgumentException | InvocationTargetException e) {\n                    LOGGER.log(Level.WARNING, \"Could not determine quiet period of \" + item.getFullName(), e);\n                }\n            }\n            if (quietPeriod == null) {\n                quietPeriod = Jenkins.getActiveInstance().getQuietPeriod();\n            }\n            ScheduleResult scheduleResult = Jenkins.getActiveInstance().getQueue().schedule2(task, quietPeriod,actions);\n            if (scheduleResult.isRefused()) {\n                throw new AbortException(\"Failed to trigger build of \" + item.getFullName());\n            }\n        } else {\n            throw new AbortException(\"The item named \" + job + \" is a \"\n                    + (item instanceof Describable\n                    ? ((Describable) item).getDescriptor().getDisplayName()\n                    : item.getClass().getName())\n                    + \" which is not something that can be built\");\n// bug_end\n         }\n// bug_start\n        if (step.getWait()) {\n            return false;\n        } else {\n            getContext().onSuccess(null);\n            return true;\n        }\n// bug_end\n     }\n \n", "target": "// fix_start\npublic Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n        if (method.getParameterTypes().length == 0)\n            return null;\n\n        if (!ObjectName.class.isAssignableFrom(method.getParameterTypes()[0]))\n            return null;\n\n        MBeanServer mbs = (MBeanServer) proxy;\n        if (mbs != null && Proxy.getInvocationHandler(mbs) instanceof MBeanInvocationHandler) {\n            mbs = ((MBeanInvocationHandler) Proxy.getInvocationHandler(mbs)).getDelegate();\n// fix_end\n// fix_start\n        if (mbs instanceof EventAdminMBeanServerWrapper) {\n            mbs = ((EventAdminMBeanServerWrapper) mbs).getDelegate();\n// fix_end\n// fix_start\n// fix_end\n// fix_start\n        ObjectName objectName = (ObjectName) args[0];\n        if (\"getAttribute\".equals(method.getName())) {\n            handleGetAttribute(mbs, objectName, (String) args[1]);\n        } else if (\"getAttributes\".equals(method.getName())) {\n            handleGetAttributes(mbs, objectName, (String[]) args[1]);\n        } else if (\"setAttribute\".equals(method.getName())) {\n            handleSetAttribute(mbs, objectName, (Attribute) args[1]);\n        } else if (\"setAttributes\".equals(method.getName())) {\n            handleSetAttributes(mbs, objectName, (AttributeList) args[1]);\n        } else if (\"invoke\".equals(method.getName())) {\n            handleInvoke(mbs, objectName, (String) args[1], (Object[]) args[2], (String[]) args[3]);\n// fix_end\n// fix_start\n\n        return null;\n// fix_end\n", "cwe": "CWE-532", "cwe_name": "Information Exposure Through Log Files", "idx": 64207}
{"source": "// bug_start\npublic Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n        if (method.getParameterTypes().length == 0)\n            return null;\n// bug_end\n \n// bug_start\n        if (!ObjectName.class.isAssignableFrom(method.getParameterTypes()[0]))\n            return null;\n// bug_end\n \n// bug_start\n        MBeanServer mbs = (MBeanServer) proxy;\n        if (mbs != null && Proxy.getInvocationHandler(mbs) instanceof MBeanInvocationHandler) {\n            mbs = ((MBeanInvocationHandler) Proxy.getInvocationHandler(mbs)).getDelegate();\n        }\n        if (mbs instanceof EventAdminMBeanServerWrapper) {\n            mbs = ((EventAdminMBeanServerWrapper) mbs).getDelegate();\n        }\n\n        ObjectName objectName = (ObjectName) args[0];\n        if (\"getAttribute\".equals(method.getName())) {\n            handleGetAttribute(mbs, objectName, (String) args[1]);\n        } else if (\"getAttributes\".equals(method.getName())) {\n            handleGetAttributes(mbs, objectName, (String[]) args[1]);\n        } else if (\"setAttribute\".equals(method.getName())) {\n            handleSetAttribute(mbs, objectName, (Attribute) args[1]);\n        } else if (\"setAttributes\".equals(method.getName())) {\n            handleSetAttributes(mbs, objectName, (AttributeList) args[1]);\n        } else if (\"invoke\".equals(method.getName())) {\n            handleInvoke(objectName, (String) args[1], (Object[]) args[2], (String[]) args[3]);\n        }\n\n        return null;\n    }\n\n// bug_end\n", "target": "// fix_start\nprivate void setupJackson(Injector injector, final ObjectMapper mapper)\n  {\n    final GuiceAnnotationIntrospector guiceIntrospector = new GuiceAnnotationIntrospector();\n// fix_end\n// fix_start\n    mapper.setInjectableValues(new GuiceInjectableValues(injector));\n    mapper.setAnnotationIntrospectors(\n        new AnnotationIntrospectorPair(guiceIntrospector, mapper.getSerializationConfig().getAnnotationIntrospector()),\n        new AnnotationIntrospectorPair(guiceIntrospector, mapper.getDeserializationConfig().getAnnotationIntrospector())\n    );\n  }\n// fix_end\n", "cwe": "CWE-918", "cwe_name": "Server-Side Request Forgery (SSRF)", "idx": 94393}
{"source": "// bug_start\npublic String getUrlRegex() {\n        if (StringUtils.isNotEmpty(urlRegexExpression)) {\n            return (String) parse(urlRegexExpression, String.class);\n        } else if (StringUtils.isNotEmpty(urlRegex)) {\n            return urlRegex;\n        } else {\n            return \"^(https?|ftp):\\\\/\\\\/\" +\n                    \"(([a-z0-9$_\\\\.\\\\+!\\\\*\\\\'\\\\(\\\\),;\\\\?&=\\\\-]|%[0-9a-f]{2})+\" +\n                    \"(:([a-z0-9$_\\\\.\\\\+!\\\\*\\\\'\\\\(\\\\),;\\\\?&=\\\\-]|%[0-9a-f]{2})+)?\" +\n                    \"@)?(#?\" +\n                    \")((([a-z0-9]\\\\.|[a-z0-9][a-z0-9-]*[a-z0-9]\\\\.)*\" +\n                    \"[a-z][a-z0-9-]*[a-z0-9]\" +\n                    \"|((\\\\d|[1-9]\\\\d|1\\\\d{2}|2[0-4][0-9]|25[0-5])\\\\.){3}\" +\n                    \"(\\\\d|[1-9]\\\\d|1\\\\d{2}|2[0-4][0-9]|25[0-5])\" +\n                    \")(:\\\\d+)?\" +\n                    \")(((\\\\/([a-z0-9$_\\\\.\\\\+!\\\\*\\\\'\\\\(\\\\),;:@&=\\\\-]|%[0-9a-f]{2})*)*\" +\n                    \"(\\\\?([a-z0-9$_\\\\.\\\\+!\\\\*\\\\'\\\\(\\\\),;:@&=\\\\-\\\\/\\\\:]|%[0-9a-f]{2})*)\" +\n                    \"?)?)?\" +\n                    \"(#([a-z0-9$_\\\\.\\\\+!\\\\*\\\\'\\\\(\\\\),;:@&=\\\\-]|%[0-9a-f]{2})*)?\" +\n                    \"$\";\n        }\n    }\n// bug_end\n \n", "target": "// fix_start\n@VisibleForTesting\n  public static void setupJackson(Injector injector, final ObjectMapper mapper)\n  {\n    mapper.setInjectableValues(new GuiceInjectableValues(injector));\n    setupAnnotationIntrospector(mapper, new GuiceAnnotationIntrospector());\n  }\n// fix_end\n", "cwe": "NVD-CWE-noinfo", "cwe_name": "", "idx": 98770}
{"source": "// bug_start\n@RequirePOST\n    public void doLaunchSlaveAgent(StaplerRequest req, StaplerResponse rsp) throws IOException, ServletException {\n        if(channel!=null) {\n            req.getView(this,\"already-launched.jelly\").forward(req, rsp);\n            return;\n// bug_end\n         }\n// bug_start\n\n        connect(true);\n\n        rsp.sendRedirect(\"log\");\n// bug_end\n     }\n \n", "target": "// fix_start\npublic String getUrlRegex() {\n        if (StringUtils.isNotEmpty(urlRegexExpression)) {\n            return (String) parse(urlRegexExpression, String.class);\n        } else if (StringUtils.isNotEmpty(urlRegex)) {\n            return urlRegex;\n        } else {\n            return \"^(?:https?|ftp):\\\\/\\\\/\" +\n                    \"(?:(?:[a-z0-9$_.+!*'(),;?&=\\\\-]|%[0-9a-f]{2})+\" +\n                    \"(?::(?:[a-z0-9$_.+!*'(),;?&=\\\\-]|%[0-9a-f]{2})+)?\" +\n                    \"@)?#?\" +\n                    \"(?:(?:(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\\\\.)*\" +\n                    \"[a-z][a-z0-9-]*[a-z0-9]\" +\n                    \"|(?:(?:[1-9]?\\\\d|1\\\\d{2}|2[0-4]\\\\d|25[0-5])\\\\.){3}\" +\n                    \"(?:[1-9]?\\\\d|1\\\\d{2}|2[0-4]\\\\d|25[0-5])\" +\n                    \")(?::\\\\d+)?\" +\n                    \")(?:(?:\\\\/(?:[a-z0-9$_.+!*'(),;:@&=\\\\-]|%[0-9a-f]{2})*)*\" +\n                    \"(?:\\\\?(?:[a-z0-9$_.+!*'(),;:@&=\\\\-\\\\/:]|%[0-9a-f]{2})*)?)?\" +\n                    \"(?:#(?:[a-z0-9$_.+!*'(),;:@&=\\\\-]|%[0-9a-f]{2})*)?\" +\n                    \"$\";\n// fix_end\n// fix_start\n// fix_end\n", "cwe": "CWE-20", "cwe_name": "Improper Input Validation", "idx": 12211}
{"source": "// bug_start\nprotected void parseLocalesHeader(String value) {\n// bug_end\n \n// bug_start\n        TreeMap<Double, ArrayList<Locale>> locales = new TreeMap<Double, ArrayList<Locale>>();\n\n        int white = value.indexOf(' ');\n        if (white < 0)\n            white = value.indexOf('\\t');\n        if (white >= 0) {\n            StringBuilder sb = new StringBuilder();\n            int len = value.length();\n            for (int i = 0; i < len; i++) {\n                char ch = value.charAt(i);\n                if ((ch != ' ') && (ch != '\\t'))\n                    sb.append(ch);\n            }\n            parser.setString(sb.toString());\n        } else {\n            parser.setString(value);\n// bug_end\n         }\n \n// bug_start\n        int length = parser.getLength();\n        while (true) {\n// bug_end\n \n// bug_start\n            int start = parser.getIndex();\n            if (start >= length)\n                break;\n            int end = parser.findChar(',');\n            String entry = parser.extract(start, end).trim();\n            parser.advance();\n\n            double quality = 1.0;\n            int semi = entry.indexOf(\";q=\");\n            if (semi >= 0) {\n                try {\n                    quality = Double.parseDouble(entry.substring(semi + 3));\n                } catch (NumberFormatException e) {\n                    quality = 0.0;\n                }\n                entry = entry.substring(0, semi);\n            }\n\n            if (quality < 0.00005)\n                continue;\n            if (\"*\".equals(entry))\n                continue;\n\n            String language = null;\n            String country = null;\n            String variant = null;\n            int dash = entry.indexOf('-');\n            if (dash < 0) {\n                language = entry;\n                country = \"\";\n                variant = \"\";\n            } else {\n                language = entry.substring(0, dash);\n                country = entry.substring(dash + 1);\n                int vDash = country.indexOf('-');\n                if (vDash > 0) {\n                    String cTemp = country.substring(0, vDash);\n                    variant = country.substring(vDash + 1);\n                    country = cTemp;\n                } else {\n                    variant = \"\";\n                }\n            }\n            if (!isAlpha(language) || !isAlpha(country) || !isAlpha(variant)) {\n                continue;\n            }\n\n            Locale locale = new Locale(language, country, variant);\n            Double key = new Double(-quality);\n            ArrayList<Locale> values = locales.get(key);\n            if (values == null) {\n                values = new ArrayList<Locale>();\n                locales.put(key, values);\n            }\n            values.add(locale);\n\n        }\n\n        for (ArrayList<Locale> list : locales.values()) {\n            for (Locale locale : list) {\n                addLocale(locale);\n            }\n        }\n\n// bug_end\n     }\n \n", "target": "// fix_start\n@RequirePOST\n    public void doLaunchSlaveAgent(StaplerRequest req, StaplerResponse rsp) throws IOException, ServletException {\n        checkPermission(CONNECT);\n// fix_end\n// fix_start\n        if(channel!=null) {\n            req.getView(this,\"already-launched.jelly\").forward(req, rsp);\n            return;\n// fix_end\n// fix_start\n        connect(true);\n// fix_end\n// fix_start\n        rsp.sendRedirect(\"log\");\n// fix_end\n", "cwe": "CWE-863", "cwe_name": "Incorrect Authorization", "idx": 86452}
{"source": "// bug_start\npublic FormValidation doRegexCheck(@QueryParameter final String value)\n            throws IOException, ServletException {\n        try {\n            Pattern.compile(value);\n            return FormValidation.ok();\n        } catch (Exception ex) {\n            return FormValidation.errorWithMarkup(\"Invalid <a href=\\\"\"\n                    + \"http://docs.oracle.com/javase/7/docs/api/java/util/regex/Pattern.html\"\n                    + \"\\\">regular expression</a> (\" + ex.getMessage() + \")\");\n// bug_end\n         }\n// bug_start\n// bug_end\n     }\n \n", "target": "// fix_start\nprotected void parseLocalesHeader(String value) {\n\n        TreeMap<Double, ArrayList<Locale>> locales = new TreeMap<Double, ArrayList<Locale>>();\n\n        int white = value.indexOf(' ');\n        if (white < 0)\n            white = value.indexOf('\\t');\n        if (white >= 0) {\n            StringBuilder sb = new StringBuilder();\n            int len = value.length();\n            for (int i = 0; i < len; i++) {\n                char ch = value.charAt(i);\n                if ((ch != ' ') && (ch != '\\t'))\n                    sb.append(ch);\n            }\n            parser.setString(sb.toString());\n        } else {\n            parser.setString(value);\n// fix_end\n// fix_start\n\n        int length = parser.getLength();\n        while (true) {\n\n            int start = parser.getIndex();\n            if (start >= length)\n                break;\n            int end = parser.findChar(',');\n            String entry = parser.extract(start, end).trim();\n            parser.advance();\n\n            double quality = 1.0;\n            int semi = entry.indexOf(\";q=\");\n            if (semi >= 0) {\n                try {\n                    String strQuality = entry.substring(semi + 3);\n                    if (strQuality.length() <= 5) {\n                        quality = Double.parseDouble(strQuality);\n                    } else {\n                        quality = 0.0;\n                    }\n                } catch (NumberFormatException e) {\n                    quality = 0.0;\n                }\n                entry = entry.substring(0, semi);\n            }\n\n            if (quality < 0.00005)\n                continue;\n            if (\"*\".equals(entry))\n                continue;\n\n            String language = null;\n            String country = null;\n            String variant = null;\n            int dash = entry.indexOf('-');\n            if (dash < 0) {\n                language = entry;\n                country = \"\";\n                variant = \"\";\n            } else {\n                language = entry.substring(0, dash);\n                country = entry.substring(dash + 1);\n                int vDash = country.indexOf('-');\n                if (vDash > 0) {\n                    String cTemp = country.substring(0, vDash);\n                    variant = country.substring(vDash + 1);\n                    country = cTemp;\n                } else {\n                    variant = \"\";\n                }\n            }\n            if (!isAlpha(language) || !isAlpha(country) || !isAlpha(variant)) {\n                continue;\n            }\n\n            Locale locale = new Locale(language, country, variant);\n            Double key = new Double(-quality);\n            ArrayList<Locale> values = locales.get(key);\n            if (values == null) {\n                values = new ArrayList<Locale>();\n                locales.put(key, values);\n            }\n            values.add(locale);\n\n        }\n\n        for (ArrayList<Locale> list : locales.values()) {\n            for (Locale locale : list) {\n                addLocale(locale);\n            }\n        }\n\n// fix_end\n", "cwe": "NVD-CWE-Other", "cwe_name": "Other", "idx": 111584}
{"source": "// bug_start\n@Override\n    public void awaitWritable() throws IOException {\n        if(Thread.currentThread() == getIoThread()) {\n            throw UndertowMessages.MESSAGES.awaitCalledFromIoThread();\n        }\n        synchronized (lock) {\n            if (anyAreSet(state, STATE_CLOSED) || broken) {\n                return;\n            }\n            if (readyForFlush) {\n                try {\n                    waiterCount++;\n                    if(readyForFlush && !anyAreSet(state, STATE_CLOSED) && !broken) {\n                        lock.wait(awaitWritableTimeout);\n                    }\n                } catch (InterruptedException e) {\n                    Thread.currentThread().interrupt();\n                    throw new InterruptedIOException();\n                } finally {\n                    waiterCount--;\n                }\n            }\n// bug_end\n         }\n     }\n \n", "target": "// fix_start\npublic FormValidation doRegexCheck(@QueryParameter final String value)\n            throws IOException, ServletException {\n        try {\n            Pattern.compile(value);\n            return FormValidation.ok();\n        } catch (Exception ex) {\n            return FormValidation.errorWithMarkup(\"Invalid <a href=\\\"\"\n                    + \"https://docs.oracle.com/javase/8/docs/api/java/util/regex/Pattern.html\"\n                    + \"\\\">regular expression</a> (\" + Util.escape(ex.getMessage()) + \")\");\n// fix_end\n", "cwe": "CWE-79", "cwe_name": "Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')", "idx": 80562}
{"source": "// bug_start\n@Override\n    public void awaitWritable() throws IOException {\n        if(Thread.currentThread() == getIoThread()) {\n            throw UndertowMessages.MESSAGES.awaitCalledFromIoThread();\n// bug_end\n         }\n// bug_start\n        synchronized (lock) {\n            if (anyAreSet(state, STATE_CLOSED) || broken) {\n                return;\n            }\n            if (readyForFlush) {\n                try {\n                    waiterCount++;\n// bug_end\n \n// bug_start\n                    if(readyForFlush && !anyAreSet(state, STATE_CLOSED) && !broken) {\n                        lock.wait();\n                    }\n                } catch (InterruptedException e) {\n                    Thread.currentThread().interrupt();\n                    throw new InterruptedIOException();\n                } finally {\n                    waiterCount--;\n                }\n            }\n        }\n// bug_end\n     }\n \n", "target": "// fix_start\npublic void recycle() {\n        bytesRead=0;\n\n        contentLength = -1;\n        contentTypeMB = null;\n        charset = null;\n        characterEncoding = null;\n        expectation = false;\n        headers.recycle();\n        serverNameMB.recycle();\n        serverPort=-1;\n        localAddrMB.recycle();\n        localNameMB.recycle();\n        localPort = -1;\n        peerAddrMB.recycle();\n        remoteAddrMB.recycle();\n        remoteHostMB.recycle();\n        remotePort = -1;\n        available = 0;\n        sendfile = true;\n\n        serverCookies.recycle();\n        parameters.recycle();\n        pathParameters.clear();\n\n        uriMB.recycle();\n        decodedUriMB.recycle();\n        queryMB.recycle();\n        methodMB.recycle();\n        protoMB.recycle();\n\n        schemeMB.recycle();\n\n        remoteUser.recycle();\n        remoteUserNeedsAuthorization = false;\n        authType.recycle();\n        attributes.clear();\n\n        listener = null;\n        synchronized (nonBlockingStateLock) {\n            fireListener = false;\n            registeredForRead = false;\n// fix_end\n// fix_start\n        allDataReadEventSent.set(false);\n// fix_end\n// fix_start\n        startTime = -1;\n// fix_end\n", "cwe": "CWE-400", "cwe_name": "Uncontrolled Resource Consumption", "idx": 52350}
{"source": "// bug_start\n@Override\n  public void handle(RoutingContext ctx) {\n// bug_end\n \n// bug_start\n    if (nagHttps) {\n      String uri = ctx.request().absoluteURI();\n      if (uri != null && !uri.startsWith(\"https:\")) {\n        log.warn(\"Using session cookies without https could make you susceptible to session hijacking: \" + uri);\n      }\n// bug_end\n     }\n \n// bug_start\n    HttpMethod method = ctx.request().method();\n    Session session = ctx.session();\n\n    switch (method.name()) {\n      case \"GET\":\n        String token;\n\n        if (session == null) {\n          token = generateAndStoreToken(ctx);\n        } else {\n          String sessionToken = getTokenFromSession(ctx);\n          if (sessionToken == null) {\n            token = generateAndStoreToken(ctx);\n            session.put(headerName, session.id() + \"/\" + token);\n          } else {\n            String[] parts = sessionToken.split(\"\\\\.\");\n            try {\n              if (!(System.currentTimeMillis() > Long.parseLong(parts[1]) + timeout)) {\n                token = sessionToken;\n              } else {\n                token = generateAndStoreToken(ctx);\n              }\n            } catch (NumberFormatException e) {\n              log.error(\"Invalid Token format\", e);\n              token = generateAndStoreToken(ctx);\n            }\n          }\n        }\n        ctx.put(headerName, token);\n        ctx.next();\n        break;\n      case \"POST\":\n      case \"PUT\":\n      case \"DELETE\":\n      case \"PATCH\":\n        if (validateRequest(ctx)) {\n          token = generateAndStoreToken(ctx);\n          ctx.put(headerName, token);\n          ctx.next();\n        } else {\n          ctx.fail(403);\n        }\n        break;\n      default:\n        ctx.next();\n        break;\n    }\n  }\n\n// bug_end\n", "target": "// fix_start\npublic void recycle() {\n        bytesRead=0;\n// fix_end\n// fix_start\n        contentLength = -1;\n        contentTypeMB = null;\n        charset = null;\n        characterEncoding = null;\n        expectation = false;\n        headers.recycle();\n        serverNameMB.recycle();\n        serverPort=-1;\n        localAddrMB.recycle();\n        localNameMB.recycle();\n        localPort = -1;\n        peerAddrMB.recycle();\n        remoteAddrMB.recycle();\n        remoteHostMB.recycle();\n        remotePort = -1;\n        available = 0;\n        sendfile = true;\n\n        serverCookies.recycle();\n        parameters.recycle();\n        pathParameters.clear();\n\n        uriMB.recycle();\n        decodedUriMB.recycle();\n        queryMB.recycle();\n        methodMB.recycle();\n        protoMB.recycle();\n\n        schemeMB.recycle();\n\n        remoteUser.recycle();\n        remoteUserNeedsAuthorization = false;\n        authType.recycle();\n        attributes.clear();\n\n        errorException = null;\n\n        listener = null;\n        synchronized (nonBlockingStateLock) {\n            fireListener = false;\n            registeredForRead = false;\n        }\n        allDataReadEventSent.set(false);\n\n        startTime = -1;\n// fix_end\n", "cwe": "CWE-755", "cwe_name": "Improper Handling of Exceptional Conditions", "idx": 74435}
{"source": " @Override\n// bug_start\n\tpublic Environment setUp(@SuppressWarnings(\"rawtypes\")AbstractBuild build, Launcher launcher,\n\t\t\tfinal BuildListener listener) throws IOException, InterruptedException\n\t{\n\t\tDescriptorImpl DESCRIPTOR = Hudson.getInstance().getDescriptorByType(DescriptorImpl.class);\n\t\tString vnc2swf = Util.nullify(DESCRIPTOR.getVnc2swf());\n\t\tif(vnc2swf.equals(CANT_FIND_VNC2SWF))\n\t\t{\n\t\t\tlistener.fatalError(\"VNC Recorder: can't find 'vnc2swf' please check your jenkins global settings!\");\n\t\t\treturn null;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tFile vnc2swfFile = new File(vnc2swf);\n\t\t\tif (!vnc2swfFile.exists())\n\t\t\t{\n\t\t\t\tlistener.fatalError(\"VNC Recorder: can't find '\" + vnc2swf + \"' please check your jenkins global settings!\");\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n// bug_end\n \n// bug_start\n\t\tfinal VncRecorder vr = new VncRecorder();\n\t\tvr.setLoggingStream(listener.getLogger());\n\t\tif (!SystemUtils.IS_OS_UNIX)\n\t\t{\n\t\t\tlistener.fatalError(\"Feature \\\"Record VNC session\\\" works only under Unix/Linux!\");\n\t\t\treturn null;\n\t\t}\n\t\tString vncServReplaced = Util.replaceMacro(vncServ,build.getEnvironment(listener));\n\t\tif (vncServReplaced.indexOf(\":\") > 0 && vncServReplaced.split(\":\")[1].length() == 4 && vncServReplaced.split(\":\")[1].startsWith(\"59\") )\n\t\t{\n\t\t\tvncServReplaced = vncServReplaced.replace(\":59\", \":\");\n\t\t}\n// bug_end\n \n// bug_start\n\t\tString vncPasswFilePathReplaced = Util.replaceMacro(vncPasswFilePath,build.getEnvironment(listener));\n\t\tif (outFileName == null || outFileName.equalsIgnoreCase(\"null\"))\n\t\t{\n\t\t\toutFileName = \"${JOB_NAME}_${BUILD_NUMBER}\";\n\t\t}\n\t\tString outFileBase =  Util.replaceMacro(outFileName,build.getEnvironment(listener)) + \".swf\";\n\t\tlistener.getLogger().println(\"Recording from vnc server: \" + vncServReplaced);\n\t\tlistener.getLogger().println(\"Using vnc passwd file: \" + vncPasswFilePathReplaced);\n// bug_end\n \n// bug_start\n// bug_end\n \n// bug_start\n\t\tFile vncPasswFile = new File(vncPasswFilePathReplaced);\n\t\tif (vncPasswFilePathReplaced.isEmpty())\n\t\t{\n\t\t\tlistener.getLogger().println(\"VNC password file is an empty string, trying vnc connection without password\");\n\t\t\tvncPasswFile = null;\n\t\t}\n\t\telse if (!vncPasswFile.exists())\n\t\t{\n\t\t\tlistener.getLogger().println(\"Can't find \" +vncPasswFile  +\", trying vnc connection without password \");\n\t\t\tvncPasswFile = null;\n\t\t}\n// bug_end\n \n// bug_start\n\t\tFile artifactsDir = build.getArtifactsDir();\n\t\tlistener.getLogger().print(build.getUrl());\n\t\tif(!artifactsDir.exists())\n\t\t{\n\t\t\tif (!artifactsDir.mkdir())\n\t\t\t{\n\t\t\t  listener.error(\"Can't create \" + artifactsDir.getAbsolutePath());\n\t\t\t}\n\t\t}\n// bug_end\n \n// bug_start\n\t\tif (outFileBase == null || outFileBase.equalsIgnoreCase(\"null.swf\"))\n\t\t{\n\t\t\toutFileBase = build.getNumber() + \".swf\";\n// bug_end\n \n// bug_start\n\t\t}\n\t\tfinal File outFileSwf = new File(artifactsDir,outFileBase);\n\t\tfinal File outFileHtml = new File(outFileSwf.getAbsolutePath().replace(\".swf\", \".html\"));\n\n\t\tfinal Date from = new Date();\n\t\tfinal Future<Integer> recordState = vr.record(vncServReplaced, outFileSwf.getAbsolutePath(), vncPasswFile,vnc2swf);\n\n\t\treturn new Environment() {\n\t\t\t@Override\n\t\t\tpublic void buildEnvVars(Map<String, String> env) {\n\t\t\t\tif (setDisplay && env != null && vncServ != null)\n\t\t\t\t\tenv.put(\"DISPLAY\",Util.replaceMacro(vncServ,env));\n\t\t\t}\n\t\t\t@Override\n\t\t\tpublic boolean tearDown(AbstractBuild build, BuildListener listener)\n\t\t\t\t\tthrows IOException, InterruptedException {\n\t\t\t\tfinal Date to = new Date();\n\t\t\t\tif (recordState != null)\n\t\t\t\t{\n\t\t\t\t\trecordState.cancel(true);\n\t\t\t\t\tThread.sleep(1000);\n\t\t\t\t}\n\t\t\t\tif (removeIfSuccessful == null)\n\t\t\t\t\tremoveIfSuccessful = false;\n\n\n\t\t\t\tif ((removeIfSuccessful && outFileSwf.exists()) && (build == null || build.getResult() == Result.SUCCESS || build.getResult() == null)  )\n\t\t\t\t{\n\t\t\t\t\tlistener.getLogger().println(\"Build successful: Removing video file \" + outFileSwf.getAbsolutePath() + \" \\n\");\n\n\t\t\t\t\tif(!outFileSwf.delete())\n\t\t\t\t\t listener.error(\"Can't delete \" + outFileSwf.getAbsolutePath());\n\n\t\t\t\t\tif(!outFileHtml.delete())\n\t                     listener.error(\"Can't delete \" + outFileHtml.getAbsolutePath());\n\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\n\t\t\t\tif (!outFileSwf.exists())\n\t\t\t\t{\n\t\t\t\t\tlistener.error(\"File \" + outFileSwf.getAbsolutePath() +\" doesn't exist. \\nFeature \\\"Record VNC session\\\" failed!\");\n\t\t\t\t\tif (failJobIfFailed)\n\t\t\t\t\t    return false;\n\t\t\t\t\telse\n\t\t\t\t\t  return true;\n\t\t\t\t}\n\n\n\t\t\t\tSimpleDateFormat sf = new SimpleDateFormat(\"yyyy-MM-dd 'T' HH:mm:ss\");\n\t\t\t\tlistener.hyperlink(\"artifact/\" + outFileHtml.getName(),\"Video from \" + sf.format(from) + \" to \" + sf.format(to));\n\t\t\t\tlistener.getLogger().print(\"\\n\");\n\t\t\t\treturn true;\n\t\t\t}\n\t\t};\n\n\t}\n\n// bug_end\n", "target": "// fix_start\n  public void handle(RoutingContext ctx) {\n// fix_end\n// fix_start\n    if (nagHttps) {\n      String uri = ctx.request().absoluteURI();\n      if (uri != null && !uri.startsWith(\"https:\")) {\n        log.trace(\"Using session cookies without https could make you susceptible to session hijacking: \" + uri);\n      }\n    }\n// fix_end\n// fix_start\n    HttpMethod method = ctx.request().method();\n    Session session = ctx.session();\n// fix_end\n// fix_start\n    if (!isValidOrigin(ctx)) {\n      ctx.fail(403);\n      return;\n    }\n// fix_end\n// fix_start\n    switch (method.name()) {\n      case \"GET\":\n        final String token;\n// fix_end\n// fix_start\n        if (session == null) {\n          token = generateAndStoreToken(ctx);\n        } else {\n          String sessionToken = getTokenFromSession(ctx);\n          if (sessionToken == null) {\n            token = generateAndStoreToken(ctx);\n            session.put(headerName, session.id() + \"/\" + token);\n          } else {\n            String[] parts = sessionToken.split(\"\\\\.\");\n            final long ts = parseLong(parts[1]);\n// fix_end\n// fix_start\n            if (ts == -1) {\n              token = generateAndStoreToken(ctx);\n            } else {\n              if (!(System.currentTimeMillis() > ts + timeout)) {\n                token = sessionToken;\n              } else {\n                token = generateAndStoreToken(ctx);\n              }\n            }\n          }\n        }\n        ctx.put(headerName, token);\n        ctx.next();\n        break;\n      case \"POST\":\n      case \"PUT\":\n      case \"DELETE\":\n      case \"PATCH\":\n        if (isValidRequest(ctx)) {\n          token = generateAndStoreToken(ctx);\n          ctx.put(headerName, token);\n          ctx.next();\n        } else {\n          ctx.fail(403);\n        }\n        break;\n      default:\n        ctx.next();\n        break;\n    }\n  }\n// fix_end\n", "cwe": "CWE-352", "cwe_name": "Cross-Site Request Forgery (CSRF)", "idx": 48012}
{"source": "// bug_start\nprivate void doInclude(HttpServletRequest request, HttpServletResponse response, String resourceUrl)\n\t\t\tthrows ServletException, IOException {\n\n\t\tif (this.contentType != null) {\n\t\t\tresponse.setContentType(this.contentType);\n// bug_end\n \t\t}\n \n// bug_start\n\t\tString[] resourceUrls = StringUtils.tokenizeToStringArray(resourceUrl, RESOURCE_URL_DELIMITERS);\n\t\tfor (String url : resourceUrls) {\n\t\t\tif (this.allowedResources != null && !this.pathMatcher.match(this.allowedResources, url)) {\n\t\t\t\tthrow new ServletException(\"Resource [\" + url +\n\t\t\t\t\t\t\"] does not match allowed pattern [\" + this.allowedResources + \"]\");\n// bug_end\n \t\t\t}\n// bug_start\n\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\tlogger.debug(\"Including resource [\" + url + \"]\");\n// bug_end\n \t\t\t}\n// bug_start\n\t\t\tRequestDispatcher rd = request.getRequestDispatcher(url);\n\t\t\trd.include(request, response);\n\t\t}\n// bug_end\n \t}\n \n", "target": "// fix_start\n@Override\n\tpublic Environment setUp(@SuppressWarnings(\"rawtypes\")AbstractBuild build, Launcher launcher,\n\t\t\tfinal BuildListener listener) throws IOException, InterruptedException\n\t{\n\t\tDescriptorImpl DESCRIPTOR = Hudson.getInstance().getDescriptorByType(DescriptorImpl.class);\n\t\tString vnc2swf = Util.escape(Util.nullify(DESCRIPTOR.getVnc2swf()));\n\t\tif(vnc2swf.equals(CANT_FIND_VNC2SWF))\n\t\t{\n\t\t\tlistener.fatalError(\"VNC Recorder: can't find 'vnc2swf' please check your jenkins global settings!\");\n\t\t\treturn null;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tFile vnc2swfFile = new File(vnc2swf);\n\t\t\tif (!vnc2swfFile.exists())\n\t\t\t{\n\t\t\t\tlistener.fatalError(\"VNC Recorder: can't find '\" + vnc2swf + \"' please check your jenkins global settings!\");\n\t\t\t\treturn null;\n\t\t\t}\n// fix_end\n// fix_start\n\t\tfinal VncRecorder vr = new VncRecorder();\n\t\tvr.setLoggingStream(listener.getLogger());\n\t\tif (!SystemUtils.IS_OS_UNIX)\n\t\t{\n\t\t\tlistener.fatalError(\"Feature \\\"Record VNC session\\\" works only under Unix/Linux!\");\n\t\t\treturn null;\n\t\t}\n\t\tString vncServReplaced = Util.replaceMacro(vncServ,build.getEnvironment(listener));\n\t\tif (vncServReplaced.indexOf(\":\") > 0 && vncServReplaced.split(\":\")[1].length() == 4 && vncServReplaced.split(\":\")[1].startsWith(\"59\") )\n\t\t{\n\t\t\tvncServReplaced = vncServReplaced.replace(\":59\", \":\");\n\t\t}\n\n\t\tString vncPasswFilePathReplaced = Util.replaceMacro(vncPasswFilePath,build.getEnvironment(listener));\n\t\tif (outFileName == null || outFileName.equalsIgnoreCase(\"null\"))\n\t\t{\n\t\t\toutFileName = \"${JOB_NAME}_${BUILD_NUMBER}\";\n\t\t}\n\t\tString outFileBase =  Util.replaceMacro(outFileName,build.getEnvironment(listener)) + \".swf\";\n\t\tlistener.getLogger().println(\"Recording from vnc server: \" + vncServReplaced);\n\t\tlistener.getLogger().println(\"Using vnc passwd file: \" + vncPasswFilePathReplaced);\n\n\n\t\tFile vncPasswFile = new File(vncPasswFilePathReplaced);\n\t\tif (vncPasswFilePathReplaced.isEmpty())\n\t\t{\n\t\t\tlistener.getLogger().println(\"VNC password file is an empty string, trying vnc connection without password\");\n\t\t\tvncPasswFile = null;\n\t\t}\n\t\telse if (!vncPasswFile.exists())\n\t\t{\n\t\t\tlistener.getLogger().println(\"Can't find \" +vncPasswFile  +\", trying vnc connection without password \");\n\t\t\tvncPasswFile = null;\n\t\t}\n\n\t\tFile artifactsDir = build.getArtifactsDir();\n\t\tlistener.getLogger().print(build.getUrl());\n\t\tif(!artifactsDir.exists())\n\t\t{\n\t\t\tif (!artifactsDir.mkdir())\n\t\t\t{\n\t\t\t  listener.error(\"Can't create \" + artifactsDir.getAbsolutePath());\n// fix_end\n// fix_start\n\t\t}\n\n\t\tif (outFileBase == null || outFileBase.equalsIgnoreCase(\"null.swf\"))\n\t\t{\n\t\t\toutFileBase = build.getNumber() + \".swf\";\n\n\t\t}\n\t\tfinal File outFileSwf = new File(artifactsDir,outFileBase);\n\t\tfinal File outFileHtml = new File(outFileSwf.getAbsolutePath().replace(\".swf\", \".html\"));\n\n\t\tfinal Date from = new Date();\n\t\tfinal Future<Integer> recordState = vr.record(vncServReplaced, outFileSwf.getAbsolutePath(), vncPasswFile,vnc2swf);\n\n\t\treturn new Environment() {\n\t\t\t@Override\n\t\t\tpublic void buildEnvVars(Map<String, String> env) {\n\t\t\t\tif (setDisplay && env != null && vncServ != null)\n\t\t\t\t\tenv.put(\"DISPLAY\",Util.replaceMacro(vncServ,env));\n// fix_end\n// fix_start\n\t\t\t@Override\n\t\t\tpublic boolean tearDown(AbstractBuild build, BuildListener listener)\n\t\t\t\t\tthrows IOException, InterruptedException {\n\t\t\t\tfinal Date to = new Date();\n\t\t\t\tif (recordState != null)\n\t\t\t\t{\n\t\t\t\t\trecordState.cancel(true);\n\t\t\t\t\tThread.sleep(1000);\n\t\t\t\t}\n\t\t\t\tif (removeIfSuccessful == null)\n\t\t\t\t\tremoveIfSuccessful = false;\n\n\n\t\t\t\tif ((removeIfSuccessful && outFileSwf.exists()) && (build == null || build.getResult() == Result.SUCCESS || build.getResult() == null)  )\n\t\t\t\t{\n\t\t\t\t\tlistener.getLogger().println(\"Build successful: Removing video file \" + outFileSwf.getAbsolutePath() + \" \\n\");\n\n\t\t\t\t\tif(!outFileSwf.delete())\n\t\t\t\t\t listener.error(\"Can't delete \" + outFileSwf.getAbsolutePath());\n\n\t\t\t\t\tif(!outFileHtml.delete())\n\t                     listener.error(\"Can't delete \" + outFileHtml.getAbsolutePath());\n\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\n\t\t\t\tif (!outFileSwf.exists())\n\t\t\t\t{\n\t\t\t\t\tlistener.error(\"File \" + outFileSwf.getAbsolutePath() +\" doesn't exist. \\nFeature \\\"Record VNC session\\\" failed!\");\n\t\t\t\t\tif (failJobIfFailed)\n\t\t\t\t\t    return false;\n\t\t\t\t\telse\n\t\t\t\t\t  return true;\n\t\t\t\t}\n\n\n\t\t\t\tSimpleDateFormat sf = new SimpleDateFormat(\"yyyy-MM-dd 'T' HH:mm:ss\");\n\t\t\t\tlistener.hyperlink(\"artifact/\" + outFileHtml.getName(),\"Video from \" + sf.format(from) + \" to \" + sf.format(to));\n\t\t\t\tlistener.getLogger().print(\"\\n\");\n\t\t\t\treturn true;\n\t\t\t}\n\t\t};\n\n// fix_end\n", "cwe": "CWE-79", "cwe_name": "Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')", "idx": 80642}
{"source": "// bug_start\npublic static Map<String, String> getSAMLAttributes() {\n        Map<String, String> attributes = new HashMap<>();\n        attributes.put(SAML_CLIENT_SIGNATURE, \"true\");\n        attributes.put(SAML_AUTHNSTATEMENT, \"true\");\n        attributes.put(SAML_FORCE_POST_BINDING, \"true\");\n        attributes.put(SAML_SERVER_SIGNATURE, \"true\");\n        attributes.put(SAML_SIGNATURE_ALGORITHM, \"RSA_SHA256\");\n        attributes.put(SAML_FORCE_NAME_ID_FORMAT, \"false\");\n        attributes.put(SAML_NAME_ID_FORMAT, \"username\");\n        attributes.put(SAML_ALLOW_ECP_FLOW, \"false\");\n        attributes.put(SamlConfigAttributes.SAML_ARTIFACT_BINDING_IDENTIFIER, ArtifactBindingUtils.computeArtifactBindingIdentifierString(\"saml\"));\n        return attributes;\n    }\n// bug_end\n \n", "target": "// fix_start\nprivate void doInclude(HttpServletRequest request, HttpServletResponse response, String resourceUrl)\n\t\t\tthrows ServletException, IOException {\n// fix_end\n// fix_start\n\t\tif (this.contentType != null) {\n\t\t\tresponse.setContentType(this.contentType);\n\t\t}\n\t\tString[] resourceUrls = StringUtils.tokenizeToStringArray(resourceUrl, RESOURCE_URL_DELIMITERS);\n\t\tfor (String url : resourceUrls) {\n\t\t\tString path = StringUtils.cleanPath(url);\n\t\t\tif (this.allowedResources != null && !this.pathMatcher.match(this.allowedResources, path)) {\n\t\t\t\tthrow new ServletException(\"Resource [\" + path +\n\t\t\t\t\t\t\"] does not match allowed pattern [\" + this.allowedResources + \"]\");\n\t\t\t}\n\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\tlogger.debug(\"Including resource [\" + path + \"]\");\n\t\t\t}\n\t\t\tRequestDispatcher rd = request.getRequestDispatcher(path);\n\t\t\trd.include(request, response);\n\t\t}\n\t}\n\n// fix_end\n", "cwe": "CWE-22", "cwe_name": "Path Traversal", "idx": 26771}
{"source": "// bug_start\npublic static Map<String, String> getSAMLAttributes() {\n        Map<String, String> attributes = new HashMap<>();\n        attributes.put(SAML_CLIENT_SIGNATURE, \"true\");\n        attributes.put(SAML_AUTHNSTATEMENT, \"true\");\n        attributes.put(SAML_FORCE_POST_BINDING, \"true\");\n        attributes.put(SAML_SERVER_SIGNATURE, \"true\");\n        attributes.put(SAML_SIGNATURE_ALGORITHM, \"RSA_SHA256\");\n        attributes.put(SAML_FORCE_NAME_ID_FORMAT, \"false\");\n        attributes.put(SAML_NAME_ID_FORMAT, \"username\");\n        attributes.put(SamlConfigAttributes.SAML_ARTIFACT_BINDING_IDENTIFIER, ArtifactBindingUtils.computeArtifactBindingIdentifierString(\"saml\"));\n        return attributes;\n    }\n// bug_end\n \n", "target": "// fix_start\n@Override\n\tpublic Authenticated authenticate(UsernamePasswordToken token) {\n\t\tString fullName = null;\n\t\tString email = null;\n\t\tCollection<String> groupNames = null;\n        Collection<String> sshKeys = null;\n// fix_end\n// fix_start\n        Name userSearchBase;\n\t\ttry {\n\t\t\tuserSearchBase = new CompositeName().add(getUserSearchBase());\n\t\t} catch (InvalidNameException e) {\n\t\t\tthrow new RuntimeException(e);\n\t\t}\n        String userSearchFilter = StringUtils.replace(getUserSearchFilter(), \"{0}\", token.getUsername());\n        userSearchFilter = StringUtils.replace(userSearchFilter, \"\\\\\", \"\\\\\\\\\");\n        logger.debug(\"Evaluated user search filter: \" + userSearchFilter);\n\n        SearchControls searchControls = new SearchControls();\n        searchControls.setSearchScope(SearchControls.SUBTREE_SCOPE);\n        List<String> attributeNames = new ArrayList<String>();\n        if (getUserFullNameAttribute() != null)\n            attributeNames.add(getUserFullNameAttribute());\n\n        if (getUserSshKeyAttribute() != null)\n        \tattributeNames.add(getUserSshKeyAttribute());\n\n        attributeNames.add(getUserEmailAttribute());\n\n        if (getGroupRetrieval() instanceof GetGroupsUsingAttribute) {\n        \tGetGroupsUsingAttribute groupRetrieval = (GetGroupsUsingAttribute)getGroupRetrieval();\n            attributeNames.add(groupRetrieval.getUserGroupsAttribute());\n        }\n        searchControls.setReturningAttributes((String[]) attributeNames.toArray(new String[0]));\n        searchControls.setReturningObjFlag(true);\n\n        Hashtable<String, String> ldapEnv = new Hashtable<>();\n        ldapEnv.put(Context.INITIAL_CONTEXT_FACTORY, \"com.sun.jndi.ldap.LdapCtxFactory\");\n        ldapEnv.put(Context.PROVIDER_URL, getLdapUrl());\n        ldapEnv.put(Context.SECURITY_AUTHENTICATION, \"simple\");\n        ldapEnv.put(\"com.sun.jndi.ldap.connect.timeout\", String.valueOf(getTimeout()*1000L));\n        ldapEnv.put(\"com.sun.jndi.ldap.read.timeout\", String.valueOf(getTimeout()*1000L));\n        ldapEnv.put(Context.REFERRAL, \"follow\");\n\n        ldapEnv.put(Context.SECURITY_PRINCIPAL, getManagerDN());\n        ldapEnv.put(Context.SECURITY_CREDENTIALS, getManagerPassword());\n\n        DirContext ctx = null;\n        DirContext referralCtx = null;\n        try {\n            logger.debug(\"Binding to ldap url '\" + getLdapUrl() + \"'...\");\n            try {\n            \tctx = new InitialDirContext(ldapEnv);\n            } catch (AuthenticationException e) {\n        \t\tthrow new RuntimeException(\"Can not bind to ldap server '\" + getLdapUrl() + \"': \" + e.getMessage());\n            }\n            NamingEnumeration<SearchResult> results = ctx.search(userSearchBase, userSearchFilter, searchControls);\n            if (results == null || !results.hasMore())\n                throw new UnknownAccountException(\"Unknown account\");\n\n            SearchResult searchResult = (SearchResult) results.next();\n            String userDN = searchResult.getNameInNamespace();\n            if (!searchResult.isRelative()) {\n            \tStringBuffer buffer = new StringBuffer();\n                buffer.append(StringUtils.substringBefore(searchResult.getName(), \"//\"));\n                buffer.append(\"//\");\n                buffer.append(StringUtils.substringBefore(\n                \t\tStringUtils.substringAfter(searchResult.getName(), \"//\"), \"/\"));\n\n                ldapEnv.put(Context.PROVIDER_URL, buffer.toString());\n                logger.debug(\"Binding to referral ldap url '\" + buffer.toString() + \"'...\");\n                referralCtx = new InitialDirContext(ldapEnv);\n            }\n            if (userDN.startsWith(\"ldap\")) {\n            \tuserDN = StringUtils.substringAfter(userDN, \"//\");\n            \tuserDN = StringUtils.substringAfter(userDN, \"/\");\n            }\n\n            ldapEnv.put(Context.SECURITY_PRINCIPAL, userDN);\n            ldapEnv.put(Context.SECURITY_CREDENTIALS, new String(token.getPassword()));\n            DirContext userCtx = null;\n            try {\n                logger.debug(\"Authenticating user by binding as '\" + userDN + \"'...\");\n                userCtx = new InitialDirContext(ldapEnv);\n            } catch (AuthenticationException e) {\n            \tthrow new org.apache.shiro.authc.AuthenticationException(\"Unable to bind as '\" + userDN + \"'\", e);\n            } finally {\n                if (userCtx != null) {\n                    try {\n                        userCtx.close();\n                    } catch (NamingException e) {\n                    }\n                }\n            }\n\n            Attributes searchResultAttributes = searchResult.getAttributes();\n\n            if (searchResultAttributes != null) {\n                if (getUserFullNameAttribute() != null) {\n                    Attribute attribute = searchResultAttributes.get(getUserFullNameAttribute());\n                    if (attribute != null && attribute.get() != null)\n                        fullName = (String) attribute.get();\n                }\n\n                Attribute attribute = searchResultAttributes.get(getUserEmailAttribute());\n                if (attribute != null && attribute.get() != null)\n                    email = (String) attribute.get();\n\n                if (getGroupRetrieval() instanceof GetGroupsUsingAttribute)\n                \tgroupNames = retrieveGroupsByAttribute(ctx, referralCtx, searchResultAttributes);\n\n                if (getUserSshKeyAttribute() != null)\n                \tsshKeys = retrieveSshKeys(searchResultAttributes);\n            }\n\n            if (getGroupRetrieval() instanceof SearchGroupsUsingFilter)\n            \tgroupNames = retrieveGroupsByFilter(ctx, referralCtx, userDN);\n\n            if (StringUtils.isBlank(email))\n            \tthrow new AccountException(\"Email is required but not available in ldap directory\");\n            else\n            \treturn new Authenticated(email, fullName, groupNames, sshKeys);\n        } catch (NamingException e) {\n        \tthrow new RuntimeException(e);\n        } finally {\n            if (ctx != null) {\n                try {\n                    ctx.close();\n                } catch (NamingException e) {\n                }\n            }\n            if (referralCtx != null) {\n                try {\n                    referralCtx.close();\n                } catch (NamingException e) {\n                }\n            }\n        }\n\t}\n\n// fix_end\n", "cwe": "CWE-287", "cwe_name": "Improper Authentication", "idx": 39603}
{"source": " @Override\n// bug_start\n    protected void configureDataFormat(DataFormat dataFormat, CamelContext camelContext) {\n        if (encoding != null) {\n            setProperty(camelContext, dataFormat, \"encoding\", encoding);\n// bug_end\n         }\n// bug_start\n        if (this.converters != null) {\n            setProperty(camelContext, dataFormat, \"converters\", this.converters);\n// bug_end\n         }\n// bug_start\n        if (this.aliases != null) {\n            setProperty(camelContext, dataFormat, \"aliases\", this.aliases);\n        }\n        if (this.omitFields != null) {\n            setProperty(camelContext, dataFormat, \"omitFields\", this.omitFields);\n        }\n        if (this.implicitCollections != null) {\n            setProperty(camelContext, dataFormat, \"implicitCollections\", this.implicitCollections);\n        }\n        if (this.mode != null) {\n            setProperty(camelContext, dataFormat, \"mode\", mode);\n        }\n    }\n// bug_end\n \n", "target": "// fix_start\n\tpublic Authenticated authenticate(UsernamePasswordToken token) {\n\t\tString fullName = null;\n\t\tString email = null;\n\t\tCollection<String> groupNames = null;\n        Collection<String> sshKeys = null;\n\n        Name userSearchBase;\n\t\ttry {\n\t\t\tuserSearchBase = new CompositeName().add(getUserSearchBase());\n\t\t} catch (InvalidNameException e) {\n\t\t\tthrow new RuntimeException(e);\n\t\t}\n\n        String userSearchFilter = StringUtils.replace(getUserSearchFilter(), \"{0}\",\n        \t\tescape(token.getUsername()));\n        userSearchFilter = StringUtils.replace(userSearchFilter, \"\\\\\", \"\\\\\\\\\");\n        logger.debug(\"Evaluated user search filter: \" + userSearchFilter);\n\n        SearchControls searchControls = new SearchControls();\n        searchControls.setSearchScope(SearchControls.SUBTREE_SCOPE);\n        List<String> attributeNames = new ArrayList<String>();\n        if (getUserFullNameAttribute() != null)\n            attributeNames.add(getUserFullNameAttribute());\n\n        if (getUserSshKeyAttribute() != null)\n        \tattributeNames.add(getUserSshKeyAttribute());\n\n        attributeNames.add(getUserEmailAttribute());\n\n        if (getGroupRetrieval() instanceof GetGroupsUsingAttribute) {\n        \tGetGroupsUsingAttribute groupRetrieval = (GetGroupsUsingAttribute)getGroupRetrieval();\n            attributeNames.add(groupRetrieval.getUserGroupsAttribute());\n// fix_end\n// fix_start\n        searchControls.setReturningAttributes((String[]) attributeNames.toArray(new String[0]));\n        searchControls.setReturningObjFlag(true);\n\n        Hashtable<String, String> ldapEnv = new Hashtable<>();\n        ldapEnv.put(Context.INITIAL_CONTEXT_FACTORY, \"com.sun.jndi.ldap.LdapCtxFactory\");\n        ldapEnv.put(Context.PROVIDER_URL, getLdapUrl());\n        ldapEnv.put(Context.SECURITY_AUTHENTICATION, \"simple\");\n        ldapEnv.put(\"com.sun.jndi.ldap.connect.timeout\", String.valueOf(getTimeout()*1000L));\n        ldapEnv.put(\"com.sun.jndi.ldap.read.timeout\", String.valueOf(getTimeout()*1000L));\n        ldapEnv.put(Context.REFERRAL, \"follow\");\n\n        ldapEnv.put(Context.SECURITY_PRINCIPAL, getManagerDN());\n        ldapEnv.put(Context.SECURITY_CREDENTIALS, getManagerPassword());\n\n        DirContext ctx = null;\n        DirContext referralCtx = null;\n        try {\n            logger.debug(\"Binding to ldap url '\" + getLdapUrl() + \"'...\");\n            try {\n            \tctx = new InitialDirContext(ldapEnv);\n            } catch (AuthenticationException e) {\n        \t\tthrow new RuntimeException(\"Can not bind to ldap server '\" + getLdapUrl() + \"': \" + e.getMessage());\n            }\n            NamingEnumeration<SearchResult> results = ctx.search(userSearchBase, userSearchFilter, searchControls);\n            if (results == null || !results.hasMore())\n                throw new UnknownAccountException(\"Unknown account\");\n\n            SearchResult searchResult = (SearchResult) results.next();\n            String userDN = searchResult.getNameInNamespace();\n            if (!searchResult.isRelative()) {\n            \tStringBuffer buffer = new StringBuffer();\n                buffer.append(StringUtils.substringBefore(searchResult.getName(), \"//\"));\n                buffer.append(\"//\");\n                buffer.append(StringUtils.substringBefore(\n                \t\tStringUtils.substringAfter(searchResult.getName(), \"//\"), \"/\"));\n\n                ldapEnv.put(Context.PROVIDER_URL, buffer.toString());\n                logger.debug(\"Binding to referral ldap url '\" + buffer.toString() + \"'...\");\n                referralCtx = new InitialDirContext(ldapEnv);\n            }\n            if (userDN.startsWith(\"ldap\")) {\n            \tuserDN = StringUtils.substringAfter(userDN, \"//\");\n            \tuserDN = StringUtils.substringAfter(userDN, \"/\");\n            }\n\n            ldapEnv.put(Context.SECURITY_PRINCIPAL, userDN);\n            ldapEnv.put(Context.SECURITY_CREDENTIALS, new String(token.getPassword()));\n            DirContext userCtx = null;\n            try {\n                logger.debug(\"Authenticating user by binding as '\" + userDN + \"'...\");\n                userCtx = new InitialDirContext(ldapEnv);\n            } catch (AuthenticationException e) {\n            \tthrow new org.apache.shiro.authc.AuthenticationException(\"Unable to bind as '\" + userDN + \"'\", e);\n            } finally {\n                if (userCtx != null) {\n                    try {\n                        userCtx.close();\n                    } catch (NamingException e) {\n                    }\n                }\n            }\n\n            Attributes searchResultAttributes = searchResult.getAttributes();\n\n            if (searchResultAttributes != null) {\n                if (getUserFullNameAttribute() != null) {\n                    Attribute attribute = searchResultAttributes.get(getUserFullNameAttribute());\n                    if (attribute != null && attribute.get() != null)\n                        fullName = (String) attribute.get();\n                }\n\n                Attribute attribute = searchResultAttributes.get(getUserEmailAttribute());\n                if (attribute != null && attribute.get() != null)\n                    email = (String) attribute.get();\n\n                if (getGroupRetrieval() instanceof GetGroupsUsingAttribute)\n                \tgroupNames = retrieveGroupsByAttribute(ctx, referralCtx, searchResultAttributes);\n\n                if (getUserSshKeyAttribute() != null)\n                \tsshKeys = retrieveSshKeys(searchResultAttributes);\n            }\n\n            if (getGroupRetrieval() instanceof SearchGroupsUsingFilter)\n            \tgroupNames = retrieveGroupsByFilter(ctx, referralCtx, userDN);\n\n            if (StringUtils.isBlank(email))\n            \tthrow new AccountException(\"Email is required but not available in ldap directory\");\n            else\n            \treturn new Authenticated(email, fullName, groupNames, sshKeys);\n        } catch (NamingException e) {\n        \tthrow new RuntimeException(e);\n        } finally {\n            if (ctx != null) {\n                try {\n                    ctx.close();\n                } catch (NamingException e) {\n                }\n            }\n            if (referralCtx != null) {\n                try {\n                    referralCtx.close();\n                } catch (NamingException e) {\n                }\n            }\n// fix_end\n// fix_start\n\t}\n// fix_end\n", "cwe": "CWE-90", "cwe_name": "", "idx": 92845}
{"source": " protected XStream createXStream(ClassResolver resolver, ClassLoader classLoader) {\n         if (xstreamDriver != null) {\n             xstream = new XStream(xstreamDriver);\n         } else {\n             xstream = new XStream();\n         }\n \n         if (mode != null) {\n             xstream.setMode(getModeFromString(mode));\n         }\n \n         ClassLoader xstreamLoader = xstream.getClassLoader();\n         if (classLoader != null && xstreamLoader instanceof CompositeClassLoader) {\n             ((CompositeClassLoader) xstreamLoader).add(classLoader);\n         }\n \n         try {\n             if (this.implicitCollections != null) {\n                 for (Entry<String, String[]> entry : this.implicitCollections.entrySet()) {\n                     for (String name : entry.getValue()) {\n                         xstream.addImplicitCollection(resolver.resolveMandatoryClass(entry.getKey()), name);\n                     }\n                 }\n             }\n \n             if (this.aliases != null) {\n                 for (Entry<String, String> entry : this.aliases.entrySet()) {\n                     xstream.alias(entry.getKey(), resolver.resolveMandatoryClass(entry.getValue()));\n                     xstream.processAnnotations(resolver.resolveMandatoryClass(entry.getValue()));\n                 }\n             }\n \n             if (this.omitFields != null) {\n                 for (Entry<String, String[]> entry : this.omitFields.entrySet()) {\n                     for (String name : entry.getValue()) {\n                         xstream.omitField(resolver.resolveMandatoryClass(entry.getKey()), name);\n                     }\n                 }\n             }\n \n             if (this.converters != null) {\n                 for (String name : this.converters) {\n                     Class<Converter> converterClass = resolver.resolveMandatoryClass(name, Converter.class);\n                     Converter converter;\n \n                     Constructor<Converter> con = null;\n                     try {\n                         con = converterClass.getDeclaredConstructor(new Class[]{XStream.class});\n                     } catch (Exception e) {\n                     }\n                     if (con != null) {\n                         converter = con.newInstance(xstream);\n                     } else {\n                         converter = converterClass.newInstance();\n                         try {\n                             Method method = converterClass.getMethod(\"setXStream\", new Class[]{XStream.class});\n                             if (method != null) {\n                                 ObjectHelper.invokeMethod(method, converter, xstream);\n                             }\n                         } catch (Throwable e) {\n                         }\n                     }\n \n                     xstream.registerConverter(converter);\n                 }\n             }\n \n// bug_start\n// bug_end\n         } catch (Exception e) {\n             throw new RuntimeException(\"Unable to build XStream instance\", e);\n         }\n \n         return xstream;\n     }\n \n", "target": "// fix_start\n            addDefaultPermissions(xstream);\n            if (this.permissions != null) {\n                addPermissions(xstream, permissions);\n            }\n// fix_end\n", "cwe": "CWE-19", "cwe_name": "Data Handling", "idx": 3609}
{"source": "// bug_start\nvoid nextRequest() {\n        request.recycle();\n\n        if (byteBuffer.remaining() > 0 && byteBuffer.position() > 0) {\n            byteBuffer.compact();\n            byteBuffer.flip();\n// bug_end\n         }\n// bug_start\n        byteBuffer.limit(byteBuffer.limit() - byteBuffer.position()).position(0);\n\n        for (int i = 0; i <= lastActiveFilter; i++) {\n            activeFilters[i].recycle();\n// bug_end\n         }\n// bug_start\n\n        lastActiveFilter = -1;\n        parsingHeader = true;\n        swallowInput = true;\n\n        headerParsePos = HeaderParsePosition.HEADER_START;\n        parsingRequestLine = true;\n        parsingRequestLinePhase = 0;\n        parsingRequestLineEol = false;\n        parsingRequestLineStart = 0;\n        parsingRequestLineQPos = -1;\n        headerData.recycle();\n// bug_end\n     }\n \n", "target": "// fix_start\n@Override\n    protected void configureDataFormat(DataFormat dataFormat, CamelContext camelContext) {\n        if (encoding != null) {\n            setProperty(camelContext, dataFormat, \"encoding\", encoding);\n// fix_end\n// fix_start\n        if (this.converters != null) {\n            setProperty(camelContext, dataFormat, \"converters\", this.converters);\n// fix_end\n// fix_start\n        if (this.aliases != null) {\n            setProperty(camelContext, dataFormat, \"aliases\", this.aliases);\n        }\n        if (this.omitFields != null) {\n            setProperty(camelContext, dataFormat, \"omitFields\", this.omitFields);\n        }\n        if (this.implicitCollections != null) {\n            setProperty(camelContext, dataFormat, \"implicitCollections\", this.implicitCollections);\n        }\n        if (this.permissions != null) {\n            setProperty(camelContext, dataFormat, \"permissions\", this.permissions);\n        }\n        if (this.mode != null) {\n            setProperty(camelContext, dataFormat, \"mode\", mode);\n        }\n// fix_end\n", "cwe": "CWE-19", "cwe_name": "Data Handling", "idx": 3122}
{"source": "// bug_start\nvoid nextRequest() {\n        request.recycle();\n\n        if (byteBuffer.remaining() > 0 && byteBuffer.position() > 0) {\n            byteBuffer.compact();\n        }\n        byteBuffer.limit(byteBuffer.limit() - byteBuffer.position()).position(0);\n\n        for (int i = 0; i <= lastActiveFilter; i++) {\n            activeFilters[i].recycle();\n        }\n\n        lastActiveFilter = -1;\n        parsingHeader = true;\n        swallowInput = true;\n\n        headerParsePos = HeaderParsePosition.HEADER_START;\n        parsingRequestLine = true;\n        parsingRequestLinePhase = 0;\n        parsingRequestLineEol = false;\n        parsingRequestLineStart = 0;\n        parsingRequestLineQPos = -1;\n        headerData.recycle();\n// bug_end\n     }\n \n", "target": "// fix_start\nprotected void serveResource(HttpServletRequest request,\n                                 HttpServletResponse response,\n                                 boolean content,\n                                 String encoding)\n        throws IOException, ServletException {\n\n        boolean serveContent = content;\n\n        String path = getRelativePath(request, true);\n\n        if (debug > 0) {\n            if (serveContent)\n                log(\"DefaultServlet.serveResource:  Serving resource '\" +\n                    path + \"' headers and data\");\n            else\n                log(\"DefaultServlet.serveResource:  Serving resource '\" +\n                    path + \"' headers only\");\n        }\n\n        if (path.length() == 0) {\n            doDirectoryRedirect(request, response);\n            return;\n        }\n\n        WebResource resource = resources.getResource(path);\n\n        if (!resource.exists()) {\n            String requestUri = (String) request.getAttribute(\n                    RequestDispatcher.INCLUDE_REQUEST_URI);\n            if (requestUri == null) {\n                requestUri = request.getRequestURI();\n            } else {\n                throw new FileNotFoundException(sm.getString(\n                        \"defaultServlet.missingResource\", requestUri));\n            }\n\n            response.sendError(HttpServletResponse.SC_NOT_FOUND, requestUri);\n            return;\n        }\n\n        if (!resource.canRead()) {\n            String requestUri = (String) request.getAttribute(\n                    RequestDispatcher.INCLUDE_REQUEST_URI);\n            if (requestUri == null) {\n                requestUri = request.getRequestURI();\n            } else {\n                throw new FileNotFoundException(sm.getString(\n                        \"defaultServlet.missingResource\", requestUri));\n            }\n\n            response.sendError(HttpServletResponse.SC_FORBIDDEN, requestUri);\n            return;\n        }\n\n        if (resource.isFile() && (path.endsWith(\"/\") || path.endsWith(\"\\\\\"))) {\n            String requestUri = (String) request.getAttribute(\n                    RequestDispatcher.INCLUDE_REQUEST_URI);\n            if (requestUri == null) {\n                requestUri = request.getRequestURI();\n            }\n            response.sendError(HttpServletResponse.SC_NOT_FOUND, requestUri);\n            return;\n        }\n\n        boolean isError = response.getStatus() >= HttpServletResponse.SC_BAD_REQUEST;\n\n        boolean included = false;\n        if (resource.isFile()) {\n            included = (request.getAttribute(\n                    RequestDispatcher.INCLUDE_CONTEXT_PATH) != null);\n            if (!included && !isError && !checkIfHeaders(request, response, resource)) {\n                return;\n            }\n        }\n\n        String contentType = resource.getMimeType();\n        if (contentType == null) {\n            contentType = getServletContext().getMimeType(resource.getName());\n            resource.setMimeType(contentType);\n        }\n\n        String eTag = null;\n        String lastModifiedHttp = null;\n        if (resource.isFile() && !isError) {\n            eTag = resource.getETag();\n            lastModifiedHttp = resource.getLastModifiedHttp();\n        }\n\n\n        boolean usingPrecompressedVersion = false;\n        if (compressionFormats.length > 0 && !included && resource.isFile() &&\n                !pathEndsWithCompressedExtension(path)) {\n            List<PrecompressedResource> precompressedResources =\n                    getAvailablePrecompressedResources(path);\n            if (!precompressedResources.isEmpty()) {\n                Collection<String> varyHeaders = response.getHeaders(\"Vary\");\n                boolean addRequired = true;\n                for (String varyHeader : varyHeaders) {\n                    if (\"*\".equals(varyHeader) ||\n                            \"accept-encoding\".equalsIgnoreCase(varyHeader)) {\n                        addRequired = false;\n                        break;\n                    }\n                }\n                if (addRequired) {\n                    response.addHeader(\"Vary\", \"accept-encoding\");\n                }\n                PrecompressedResource bestResource =\n                        getBestPrecompressedResource(request, precompressedResources);\n                if (bestResource != null) {\n                    response.addHeader(\"Content-Encoding\", bestResource.format.encoding);\n                    resource = bestResource.resource;\n                    usingPrecompressedVersion = true;\n                }\n            }\n        }\n\n        ArrayList<Range> ranges = null;\n        long contentLength = -1L;\n\n        if (resource.isDirectory()) {\n            if (!path.endsWith(\"/\")) {\n                doDirectoryRedirect(request, response);\n                return;\n            }\n\n            if (!listings) {\n                response.sendError(HttpServletResponse.SC_NOT_FOUND,\n                                   request.getRequestURI());\n                return;\n            }\n            contentType = \"text/html;charset=UTF-8\";\n        } else {\n            if (!isError) {\n                if (useAcceptRanges) {\n                    response.setHeader(\"Accept-Ranges\", \"bytes\");\n                }\n\n                ranges = parseRange(request, response, resource);\n\n                response.setHeader(\"ETag\", eTag);\n\n                response.setHeader(\"Last-Modified\", lastModifiedHttp);\n            }\n\n            contentLength = resource.getContentLength();\n            if (contentLength == 0L) {\n                serveContent = false;\n            }\n        }\n\n        ServletOutputStream ostream = null;\n        PrintWriter writer = null;\n\n        if (serveContent) {\n            try {\n                ostream = response.getOutputStream();\n            } catch (IllegalStateException e) {\n                if (!usingPrecompressedVersion &&\n                        ((contentType == null) ||\n                                (contentType.startsWith(\"text\")) ||\n                                (contentType.endsWith(\"xml\")) ||\n                                (contentType.contains(\"/javascript\")))\n                        ) {\n                    writer = response.getWriter();\n                    ranges = FULL;\n                } else {\n                    throw e;\n                }\n            }\n        }\n\n        ServletResponse r = response;\n        long contentWritten = 0;\n        while (r instanceof ServletResponseWrapper) {\n            r = ((ServletResponseWrapper) r).getResponse();\n        }\n        if (r instanceof ResponseFacade) {\n            contentWritten = ((ResponseFacade) r).getContentWritten();\n        }\n        if (contentWritten > 0) {\n            ranges = FULL;\n        }\n\n        if (resource.isDirectory() ||\n                isError ||\n                ( (ranges == null || ranges.isEmpty())\n                        && request.getHeader(\"Range\") == null ) ||\n                ranges == FULL ) {\n\n            if (contentType != null) {\n                if (debug > 0)\n                    log(\"DefaultServlet.serveFile:  contentType='\" +\n                        contentType + \"'\");\n                response.setContentType(contentType);\n            }\n            if (resource.isFile() && contentLength >= 0 &&\n                    (!serveContent || ostream != null)) {\n                if (debug > 0)\n                    log(\"DefaultServlet.serveFile:  contentLength=\" +\n                        contentLength);\n                if (contentWritten == 0) {\n                    response.setContentLengthLong(contentLength);\n                }\n            }\n\n            if (serveContent) {\n                try {\n                    response.setBufferSize(output);\n                } catch (IllegalStateException e) {\n                }\n                InputStream renderResult = null;\n                if (ostream == null) {\n                    if (resource.isDirectory()) {\n                        renderResult = render(getPathPrefix(request), resource, encoding);\n                    } else {\n                        renderResult = resource.getInputStream();\n                    }\n                    copy(resource, renderResult, writer, encoding);\n                } else {\n                    if (resource.isDirectory()) {\n                        renderResult = render(getPathPrefix(request), resource, encoding);\n                    } else {\n                        if (!checkSendfile(request, response, resource,\n                                contentLength, null)) {\n                            byte[] resourceBody = resource.getContent();\n                            if (resourceBody == null) {\n                                renderResult = resource.getInputStream();\n                            } else {\n                                ostream.write(resourceBody);\n                            }\n                        }\n                    }\n                    if (renderResult != null) {\n                        copy(resource, renderResult, ostream);\n                    }\n                }\n            }\n\n        } else {\n\n            if ((ranges == null) || (ranges.isEmpty()))\n                return;\n\n\n            response.setStatus(HttpServletResponse.SC_PARTIAL_CONTENT);\n\n            if (ranges.size() == 1) {\n\n                Range range = ranges.get(0);\n                response.addHeader(\"Content-Range\", \"bytes \"\n                                   + range.start\n                                   + \"-\" + range.end + \"/\"\n                                   + range.length);\n                long length = range.end - range.start + 1;\n                response.setContentLengthLong(length);\n\n                if (contentType != null) {\n                    if (debug > 0)\n                        log(\"DefaultServlet.serveFile:  contentType='\" +\n                            contentType + \"'\");\n                    response.setContentType(contentType);\n                }\n\n                if (serveContent) {\n                    try {\n                        response.setBufferSize(output);\n                    } catch (IllegalStateException e) {\n                    }\n                    if (ostream != null) {\n                        if (!checkSendfile(request, response, resource,\n                                range.end - range.start + 1, range))\n                            copy(resource, ostream, range);\n                    } else {\n                        throw new IllegalStateException();\n                    }\n                }\n            } else {\n                response.setContentType(\"multipart/byteranges; boundary=\"\n                                        + mimeSeparation);\n                if (serveContent) {\n                    try {\n                        response.setBufferSize(output);\n                    } catch (IllegalStateException e) {\n                    }\n                    if (ostream != null) {\n                        copy(resource, ostream, ranges.iterator(), contentType);\n                    } else {\n                        throw new IllegalStateException();\n                    }\n                }\n            }\n        }\n// fix_end\n", "cwe": "CWE-200", "cwe_name": "Exposure of Sensitive Information to an Unauthorized Actor", "idx": 17059}
{"source": "// bug_start\nprotected void extractAttachmentsFromMultipart(Multipart mp, Map<String, Attachment> map)\n        throws MessagingException, IOException {\n\n        for (int i = 0; i < mp.getCount(); i++) {\n            Part part = mp.getBodyPart(i);\n            LOG.trace(\"Part #{}: {}\", i, part);\n\n            if (part.isMimeType(\"multipart/*\")) {\n                LOG.trace(\"Part #{}: is mimetype: multipart/*\", i);\n                extractAttachmentsFromMultipart((Multipart) part.getContent(), map);\n// bug_end\n             } else {\n// bug_start\n                String disposition = part.getDisposition();\n                String fileName = part.getFileName();\n\n                if (LOG.isTraceEnabled()) {\n                    LOG.trace(\"Part #{}: Disposition: {}\", i, disposition);\n                    LOG.trace(\"Part #{}: Description: {}\", i, part.getDescription());\n                    LOG.trace(\"Part #{}: ContentType: {}\", i, part.getContentType());\n                    LOG.trace(\"Part #{}: FileName: {}\", i, fileName);\n                    LOG.trace(\"Part #{}: Size: {}\", i, part.getSize());\n                    LOG.trace(\"Part #{}: LineCount: {}\", i, part.getLineCount());\n                }\n\n                if (validDisposition(disposition, fileName)\n                        || fileName != null) {\n                    LOG.debug(\"Mail contains file attachment: {}\", fileName);\n                    if (!map.containsKey(fileName)) {\n                        DefaultAttachment camelAttachment = new DefaultAttachment(part.getDataHandler());\n                        @SuppressWarnings(\"unchecked\")\n                        Enumeration<Header> headers = part.getAllHeaders();\n                        while (headers.hasMoreElements()) {\n                            Header header = headers.nextElement();\n                            camelAttachment.addHeader(header.getName(), header.getValue());\n// bug_end\n                         }\n// bug_start\n                        map.put(fileName, camelAttachment);\n                    } else {\n                        LOG.warn(\"Cannot extract duplicate file attachment: {}.\", fileName);\n// bug_end\n                     }\n                 }\n             }\n         }\n     }\n \n", "target": "// fix_start\nprotected void serveResource(HttpServletRequest request,\n                                 HttpServletResponse response,\n                                 boolean content,\n                                 String encoding)\n        throws IOException, ServletException {\n\n        boolean serveContent = content;\n\n        String path = getRelativePath(request, true);\n\n        if (debug > 0) {\n            if (serveContent)\n                log(\"DefaultServlet.serveResource:  Serving resource '\" +\n                    path + \"' headers and data\");\n            else\n                log(\"DefaultServlet.serveResource:  Serving resource '\" +\n                    path + \"' headers only\");\n        }\n\n        if (path.length() == 0) {\n            doDirectoryRedirect(request, response);\n            return;\n        }\n\n        WebResource resource = resources.getResource(path);\n\n        if (!resource.exists()) {\n            String requestUri = (String) request.getAttribute(\n                    RequestDispatcher.INCLUDE_REQUEST_URI);\n            if (requestUri == null) {\n                requestUri = request.getRequestURI();\n// fix_end\n// fix_start\n                throw new FileNotFoundException(sm.getString(\n                        \"defaultServlet.missingResource\", requestUri));\n            }\n\n            response.sendError(HttpServletResponse.SC_NOT_FOUND, requestUri);\n            return;\n        }\n\n        if (!resource.canRead()) {\n            String requestUri = (String) request.getAttribute(\n                    RequestDispatcher.INCLUDE_REQUEST_URI);\n            if (requestUri == null) {\n                requestUri = request.getRequestURI();\n            } else {\n                throw new FileNotFoundException(sm.getString(\n                        \"defaultServlet.missingResource\", requestUri));\n            }\n\n            response.sendError(HttpServletResponse.SC_FORBIDDEN, requestUri);\n            return;\n        }\n\n        if (resource.isFile() && (path.endsWith(\"/\") || path.endsWith(\"\\\\\"))) {\n            String requestUri = (String) request.getAttribute(\n                    RequestDispatcher.INCLUDE_REQUEST_URI);\n            if (requestUri == null) {\n                requestUri = request.getRequestURI();\n            }\n            response.sendError(HttpServletResponse.SC_NOT_FOUND, requestUri);\n            return;\n        }\n\n        boolean isError = DispatcherType.ERROR == request.getDispatcherType();\n\n        boolean included = false;\n        if (resource.isFile()) {\n            included = (request.getAttribute(\n                    RequestDispatcher.INCLUDE_CONTEXT_PATH) != null);\n            if (!included && !isError && !checkIfHeaders(request, response, resource)) {\n                return;\n            }\n        }\n\n        String contentType = resource.getMimeType();\n        if (contentType == null) {\n            contentType = getServletContext().getMimeType(resource.getName());\n            resource.setMimeType(contentType);\n        }\n\n        String eTag = null;\n        String lastModifiedHttp = null;\n        if (resource.isFile() && !isError) {\n            eTag = resource.getETag();\n            lastModifiedHttp = resource.getLastModifiedHttp();\n        }\n\n\n        boolean usingPrecompressedVersion = false;\n        if (compressionFormats.length > 0 && !included && resource.isFile() &&\n                !pathEndsWithCompressedExtension(path)) {\n            List<PrecompressedResource> precompressedResources =\n                    getAvailablePrecompressedResources(path);\n            if (!precompressedResources.isEmpty()) {\n                Collection<String> varyHeaders = response.getHeaders(\"Vary\");\n                boolean addRequired = true;\n                for (String varyHeader : varyHeaders) {\n                    if (\"*\".equals(varyHeader) ||\n                            \"accept-encoding\".equalsIgnoreCase(varyHeader)) {\n                        addRequired = false;\n                        break;\n                    }\n                }\n                if (addRequired) {\n                    response.addHeader(\"Vary\", \"accept-encoding\");\n                }\n                PrecompressedResource bestResource =\n                        getBestPrecompressedResource(request, precompressedResources);\n                if (bestResource != null) {\n                    response.addHeader(\"Content-Encoding\", bestResource.format.encoding);\n                    resource = bestResource.resource;\n                    usingPrecompressedVersion = true;\n                }\n            }\n        }\n\n        ArrayList<Range> ranges = null;\n        long contentLength = -1L;\n\n        if (resource.isDirectory()) {\n            if (!path.endsWith(\"/\")) {\n                doDirectoryRedirect(request, response);\n                return;\n            }\n\n            if (!listings) {\n                response.sendError(HttpServletResponse.SC_NOT_FOUND,\n                                   request.getRequestURI());\n                return;\n            }\n            contentType = \"text/html;charset=UTF-8\";\n        } else {\n            if (!isError) {\n                if (useAcceptRanges) {\n                    response.setHeader(\"Accept-Ranges\", \"bytes\");\n                }\n\n                ranges = parseRange(request, response, resource);\n\n                response.setHeader(\"ETag\", eTag);\n\n                response.setHeader(\"Last-Modified\", lastModifiedHttp);\n            }\n\n            contentLength = resource.getContentLength();\n            if (contentLength == 0L) {\n                serveContent = false;\n            }\n        }\n\n        ServletOutputStream ostream = null;\n        PrintWriter writer = null;\n\n        if (serveContent) {\n            try {\n                ostream = response.getOutputStream();\n            } catch (IllegalStateException e) {\n                if (!usingPrecompressedVersion &&\n                        ((contentType == null) ||\n                                (contentType.startsWith(\"text\")) ||\n                                (contentType.endsWith(\"xml\")) ||\n                                (contentType.contains(\"/javascript\")))\n                        ) {\n                    writer = response.getWriter();\n                    ranges = FULL;\n                } else {\n                    throw e;\n                }\n            }\n        }\n\n        ServletResponse r = response;\n        long contentWritten = 0;\n        while (r instanceof ServletResponseWrapper) {\n            r = ((ServletResponseWrapper) r).getResponse();\n        }\n        if (r instanceof ResponseFacade) {\n            contentWritten = ((ResponseFacade) r).getContentWritten();\n        }\n        if (contentWritten > 0) {\n            ranges = FULL;\n        }\n\n        if (resource.isDirectory() ||\n                isError ||\n                ( (ranges == null || ranges.isEmpty())\n                        && request.getHeader(\"Range\") == null ) ||\n                ranges == FULL ) {\n\n            if (contentType != null) {\n                if (debug > 0)\n                    log(\"DefaultServlet.serveFile:  contentType='\" +\n                        contentType + \"'\");\n                response.setContentType(contentType);\n            }\n            if (resource.isFile() && contentLength >= 0 &&\n                    (!serveContent || ostream != null)) {\n                if (debug > 0)\n                    log(\"DefaultServlet.serveFile:  contentLength=\" +\n                        contentLength);\n                if (contentWritten == 0) {\n                    response.setContentLengthLong(contentLength);\n                }\n            }\n\n            if (serveContent) {\n                try {\n                    response.setBufferSize(output);\n                } catch (IllegalStateException e) {\n                }\n                InputStream renderResult = null;\n                if (ostream == null) {\n                    if (resource.isDirectory()) {\n                        renderResult = render(getPathPrefix(request), resource, encoding);\n                    } else {\n                        renderResult = resource.getInputStream();\n                    }\n                    copy(resource, renderResult, writer, encoding);\n                } else {\n                    if (resource.isDirectory()) {\n                        renderResult = render(getPathPrefix(request), resource, encoding);\n                    } else {\n                        if (!checkSendfile(request, response, resource,\n                                contentLength, null)) {\n                            byte[] resourceBody = resource.getContent();\n                            if (resourceBody == null) {\n                                renderResult = resource.getInputStream();\n                            } else {\n                                ostream.write(resourceBody);\n                            }\n// fix_end\n// fix_start\n                    }\n                    if (renderResult != null) {\n                        copy(resource, renderResult, ostream);\n                    }\n                }\n            }\n\n        } else {\n\n            if ((ranges == null) || (ranges.isEmpty()))\n                return;\n\n\n            response.setStatus(HttpServletResponse.SC_PARTIAL_CONTENT);\n\n            if (ranges.size() == 1) {\n\n                Range range = ranges.get(0);\n                response.addHeader(\"Content-Range\", \"bytes \"\n                                   + range.start\n                                   + \"-\" + range.end + \"/\"\n                                   + range.length);\n                long length = range.end - range.start + 1;\n                response.setContentLengthLong(length);\n\n                if (contentType != null) {\n                    if (debug > 0)\n                        log(\"DefaultServlet.serveFile:  contentType='\" +\n                            contentType + \"'\");\n                    response.setContentType(contentType);\n                }\n\n                if (serveContent) {\n                    try {\n                        response.setBufferSize(output);\n                    } catch (IllegalStateException e) {\n                    }\n                    if (ostream != null) {\n                        if (!checkSendfile(request, response, resource,\n                                range.end - range.start + 1, range))\n                            copy(resource, ostream, range);\n                    } else {\n                        throw new IllegalStateException();\n                    }\n                }\n            } else {\n                response.setContentType(\"multipart/byteranges; boundary=\"\n                                        + mimeSeparation);\n                if (serveContent) {\n                    try {\n                        response.setBufferSize(output);\n                    } catch (IllegalStateException e) {\n                    }\n                    if (ostream != null) {\n                        copy(resource, ostream, ranges.iterator(), contentType);\n                    } else {\n                        throw new IllegalStateException();\n// fix_end\n", "cwe": "CWE-755", "cwe_name": "Improper Handling of Exceptional Conditions", "idx": 74457}
{"source": "// bug_start\n@RequirePOST\n    public HttpResponse doForcePromotion(@QueryParameter(\"name\") String name) throws IOException {\n        JobPropertyImpl pp = getProject().getProperty(JobPropertyImpl.class);\n        if(pp==null)\n            throw new IllegalStateException(\"This project doesn't have any promotion criteria set\");\n// bug_end\n \n// bug_start\n        PromotionProcess p = pp.getItem(name);\n        if(p==null)\n            throw new IllegalStateException(\"This project doesn't have the promotion criterion called \"+name);\n// bug_end\n \n// bug_start\n        ManualCondition manualCondition = (ManualCondition) p.getPromotionCondition(ManualCondition.class.getName());\n        PromotionPermissionHelper.checkPermission(getProject(), manualCondition);\n// bug_end\n \n// bug_start\n        p.promote(owner,new UserCause(),new ManualPromotionBadge());\n// bug_end\n \n// bug_start\n        return HttpResponses.redirectToDot();\n// bug_end\n     }\n \n", "target": "// fix_start\nprotected void extractAttachmentsFromMultipart(Multipart mp, Map<String, Attachment> map)\n        throws MessagingException, IOException {\n// fix_end\n// fix_start\n        for (int i = 0; i < mp.getCount(); i++) {\n            Part part = mp.getBodyPart(i);\n            LOG.trace(\"Part #{}: {}\", i, part);\n// fix_end\n// fix_start\n            if (part.isMimeType(\"multipart/*\")) {\n                LOG.trace(\"Part #{}: is mimetype: multipart/*\", i);\n                extractAttachmentsFromMultipart((Multipart) part.getContent(), map);\n            } else {\n                String disposition = part.getDisposition();\n                String fileName = FileUtil.stripPath(part.getFileName());\n// fix_end\n// fix_start\n                if (LOG.isTraceEnabled()) {\n                    LOG.trace(\"Part #{}: Disposition: {}\", i, disposition);\n                    LOG.trace(\"Part #{}: Description: {}\", i, part.getDescription());\n                    LOG.trace(\"Part #{}: ContentType: {}\", i, part.getContentType());\n                    LOG.trace(\"Part #{}: FileName: {}\", i, fileName);\n                    LOG.trace(\"Part #{}: Size: {}\", i, part.getSize());\n                    LOG.trace(\"Part #{}: LineCount: {}\", i, part.getLineCount());\n                }\n// fix_end\n// fix_start\n                if (validDisposition(disposition, fileName)\n                        || fileName != null) {\n                    LOG.debug(\"Mail contains file attachment: {}\", fileName);\n                    if (!map.containsKey(fileName)) {\n                        final DataHandler dataHandler = part.getDataHandler();\n                        final DataSource dataSource = dataHandler.getDataSource();\n\n                        final DataHandler replacement = new DataHandler(new DelegatingDataSource(fileName, dataSource));\n                        DefaultAttachment camelAttachment = new DefaultAttachment(replacement);\n                        @SuppressWarnings(\"unchecked\")\n                        Enumeration<Header> headers = part.getAllHeaders();\n                        while (headers.hasMoreElements()) {\n                            Header header = headers.nextElement();\n                            camelAttachment.addHeader(header.getName(), header.getValue());\n                        }\n                        map.put(fileName, camelAttachment);\n                    } else {\n                        LOG.warn(\"Cannot extract duplicate file attachment: {}.\", fileName);\n                    }\n                }\n            }\n        }\n// fix_end\n", "cwe": "CWE-22", "cwe_name": "Path Traversal", "idx": 21184}
{"source": "// bug_start\npublic HttpResponse doForcePromotion(@QueryParameter(\"name\") String name) throws IOException {\n// bug_end\n \n// bug_start\n        JobPropertyImpl pp = getProject().getProperty(JobPropertyImpl.class);\n        if(pp==null)\n            throw new IllegalStateException(\"This project doesn't have any promotion criteria set\");\n// bug_end\n \n// bug_start\n        PromotionProcess p = pp.getItem(name);\n        if(p==null)\n            throw new IllegalStateException(\"This project doesn't have the promotion criterion called \"+name);\n// bug_end\n \n// bug_start\n        ManualCondition manualCondition = (ManualCondition) p.getPromotionCondition(ManualCondition.class.getName());\n        PromotionPermissionHelper.checkPermission(getProject(), manualCondition);\n// bug_end\n \n// bug_start\n        p.promote(owner,new UserCause(),new ManualPromotionBadge());\n// bug_end\n \n// bug_start\n        return HttpResponses.redirectToDot();\n// bug_end\n     }\n \n", "target": "// fix_start\nprivate LdapContext getLdapContextUsingStartTls( LdapContextFactory ldapContextFactory,\n            Object principal, Object credentials ) throws NamingException\n    {\n        JndiLdapContextFactory jndiLdapContextFactory = (JndiLdapContextFactory) ldapContextFactory;\n        Hashtable<String, Object> env = new Hashtable<>();\n        env.put( Context.INITIAL_CONTEXT_FACTORY, jndiLdapContextFactory.getContextFactoryClassName() );\n        env.put( Context.PROVIDER_URL, jndiLdapContextFactory.getUrl() );\n// fix_end\n// fix_start\n        LdapContext ctx = null;\n// fix_end\n// fix_start\n        try\n        {\n            ctx = new InitialLdapContext( env, null );\n// fix_end\n// fix_start\n            StartTlsRequest startTlsRequest = new StartTlsRequest();\n            StartTlsResponse tls = (StartTlsResponse) ctx.extendedOperation( startTlsRequest );\n// fix_end\n// fix_start\n            tls.negotiate();\n// fix_end\n// fix_start\n            ctx.addToEnvironment( Context.SECURITY_AUTHENTICATION,\n                    jndiLdapContextFactory.getAuthenticationMechanism() );\n            ctx.addToEnvironment( Context.SECURITY_PRINCIPAL, principal );\n            ctx.addToEnvironment( Context.SECURITY_CREDENTIALS, credentials );\n\n            return ctx;\n        }\n        catch ( IOException e )\n        {\n            LdapUtils.closeContext( ctx );\n            securityLog.error( withRealm( \"Failed to negotiate TLS connection with '%s': \",\n                    server( jndiLdapContextFactory ), e ) );\n            throw new CommunicationException( e.getMessage() );\n        }\n        catch ( Throwable t )\n        {\n            LdapUtils.closeContext( ctx );\n            securityLog.error( withRealm( \"Unexpected failure to negotiate TLS connection with '%s': \",\n                    server( jndiLdapContextFactory ), t ) );\n            throw t;\n        }\n// fix_end\n", "cwe": "CWE-352", "cwe_name": "Cross-Site Request Forgery (CSRF)", "idx": 46508}
{"source": "// bug_start\nstatic Secret tryDecrypt(Cipher cipher, byte[] in) throws UnsupportedEncodingException {\n        try {\n            String plainText = new String(cipher.doFinal(in), \"UTF-8\");\n            if(plainText.endsWith(MAGIC))\n                return new Secret(plainText.substring(0,plainText.length()-MAGIC.length()));\n            return null;\n        } catch (GeneralSecurityException e) {\n            return null;\n// bug_end\n         }\n     }\n \n", "target": "// fix_start\nprivate LdapContext getLdapContextUsingStartTls( LdapContextFactory ldapContextFactory,\n            Object principal, Object credentials ) throws NamingException\n    {\n        JndiLdapContextFactory jndiLdapContextFactory = (JndiLdapContextFactory) ldapContextFactory;\n        Hashtable<String, Object> env = new Hashtable<>();\n        env.put( Context.INITIAL_CONTEXT_FACTORY, jndiLdapContextFactory.getContextFactoryClassName() );\n        env.put( Context.PROVIDER_URL, jndiLdapContextFactory.getUrl() );\n\n        LdapContext ctx = null;\n\n        try\n        {\n            ctx = new InitialLdapContext( env, null );\n\n            StartTlsRequest startTlsRequest = new StartTlsRequest();\n            StartTlsResponse tls = (StartTlsResponse) ctx.extendedOperation( startTlsRequest );\n\n            tls.negotiate();\n\n            ctx.addToEnvironment( Context.SECURITY_AUTHENTICATION,\n                    jndiLdapContextFactory.getAuthenticationMechanism() );\n            ctx.addToEnvironment( Context.SECURITY_PRINCIPAL, principal );\n            ctx.addToEnvironment( Context.SECURITY_CREDENTIALS, credentials );\n\n            ctx.lookup( principal.toString() );\n\n            return ctx;\n        }\n        catch ( IOException e )\n        {\n            LdapUtils.closeContext( ctx );\n            securityLog.error( withRealm( \"Failed to negotiate TLS connection with '%s': \",\n                    server( jndiLdapContextFactory ), e ) );\n            throw new CommunicationException( e.getMessage() );\n        }\n        catch ( Throwable t )\n        {\n            LdapUtils.closeContext( ctx );\n            securityLog.error( withRealm( \"Unexpected failure to negotiate TLS connection with '%s': \",\n                    server( jndiLdapContextFactory ), t ) );\n            throw t;\n// fix_end\n", "cwe": "CWE-287", "cwe_name": "Improper Authentication", "idx": 38731}
{"source": "// bug_start\nprivate static Secret tryDecrypt(Cipher cipher, byte[] in) throws UnsupportedEncodingException {\n        try {\n            String plainText = new String(cipher.doFinal(in), \"UTF-8\");\n            if(plainText.endsWith(MAGIC))\n                return new Secret(plainText.substring(0,plainText.length()-MAGIC.length()));\n            return null;\n        } catch (GeneralSecurityException e) {\n            return null;\n// bug_end\n         }\n// bug_start\n// bug_end\n     }\n \n", "target": "// fix_start\nprivate void verifySavedState(HttpServletRequest request) {\n        HttpSession session = request.getSession(false);\n\n        if (session == null) {\n            logger.warn(\"The received state does not match the state saved in the context\");\n            throw new BadCredentialsException(\"The received state does not match the state saved in the context\");\n// fix_end\n// fix_start\n\n        String savedContext = (String)session.getAttribute(FederationAuthenticationEntryPoint.SAVED_CONTEXT);\n        String state = getState(request);\n        if (savedContext == null || !savedContext.equals(state)) {\n            logger.warn(\"The received state does not match the state saved in the context\");\n            throw new BadCredentialsException(\"The received state does not match the state saved in the context\");\n        }\n        session.removeAttribute(FederationAuthenticationEntryPoint.SAVED_CONTEXT);\n// fix_end\n", "cwe": "NVD-CWE-noinfo", "cwe_name": "", "idx": 98778}
{"source": "// bug_start\nprivate void verifySavedState(HttpServletRequest request) {\n        HttpSession session = request.getSession(false);\n        if (session != null) {\n            String savedContext = (String)session.getAttribute(FederationAuthenticationEntryPoint.SAVED_CONTEXT);\n            String state = getState(request);\n            if (savedContext != null && !savedContext.equals(state)) {\n                logger.warn(\"The received state does not match the state saved in the context\");\n                throw new BadCredentialsException(\"The received state does not match the state saved in the context\");\n// bug_end\n             }\n// bug_start\n// bug_end\n         }\n// bug_start\n    }\n// bug_end\n \n", "target": "// fix_start\npublic boolean processSendfile(SelectionKey sk, KeyAttachment attachment, boolean reg, boolean event) {\n            NioChannel sc = null;\n            try {\n                SendfileData sd = attachment.getSendfileData();\n                if ( sd.fchannel == null ) {\n                    File f = new File(sd.fileName);\n                    if ( !f.exists() ) {\n                        cancelledKey(sk,SocketStatus.ERROR,false);\n                        return false;\n                    }\n                    sd.fchannel = new FileInputStream(f).getChannel();\n                }\n                sc = attachment.getChannel();\n                sc.setSendFile(true);\n                WritableByteChannel wc = ((sc instanceof SecureNioChannel)?sc:sc.getIOChannel());\n\n                if (sc.getOutboundRemaining()>0) {\n                    if (sc.flushOutbound()) {\n                        attachment.access();\n                    }\n                } else {\n                    long written = sd.fchannel.transferTo(sd.pos,sd.length,wc);\n                    if ( written > 0 ) {\n                        sd.pos += written;\n                        sd.length -= written;\n                        attachment.access();\n                    } else {\n                        if (sd.fchannel.size() <= sd.pos) {\n                            throw new IOException(\"Sendfile configured to \" +\n                                    \"send more data than was available\");\n                        }\n                    }\n                }\n                if ( sd.length <= 0 && sc.getOutboundRemaining()<=0) {\n                    if (log.isDebugEnabled()) {\n                        log.debug(\"Send file complete for:\"+sd.fileName);\n                    }\n                    attachment.setSendfileData(null);\n                    try {sd.fchannel.close();}catch(Exception ignore){}\n                    if ( sd.keepAlive ) {\n                        if (reg) {\n                            if (log.isDebugEnabled()) {\n                                log.debug(\"Connection is keep alive, registering back for OP_READ\");\n                            }\n                            if (event) {\n                                this.add(attachment.getChannel(),SelectionKey.OP_READ);\n                            } else {\n                                reg(sk,attachment,SelectionKey.OP_READ);\n                            }\n                        }\n                    } else {\n                        if (log.isDebugEnabled()) {\n                            log.debug(\"Send file connection is being closed\");\n                        }\n                        cancelledKey(sk,SocketStatus.STOP,false);\n                        return false;\n                    }\n                } else if ( attachment.interestOps() == 0 && reg ) {\n                    if (log.isDebugEnabled()) {\n                        log.debug(\"OP_WRITE for sendilfe:\"+sd.fileName);\n                    }\n                    if (event) {\n                        add(attachment.getChannel(),SelectionKey.OP_WRITE);\n                    } else {\n                        reg(sk,attachment,SelectionKey.OP_WRITE);\n                    }\n                }\n            }catch ( IOException x ) {\n                if ( log.isDebugEnabled() ) log.debug(\"Unable to complete sendfile request:\", x);\n                cancelledKey(sk,SocketStatus.ERROR,false);\n                return false;\n            }catch ( Throwable t ) {\n                log.error(\"\",t);\n                cancelledKey(sk, SocketStatus.ERROR, false);\n                return false;\n            }finally {\n                if (sc!=null) sc.setSendFile(false);\n// fix_end\n// fix_start\n            return true;\n// fix_end\n// fix_start\n// fix_end\n", "cwe": "CWE-352", "cwe_name": "Cross-Site Request Forgery (CSRF)", "idx": 45089}
{"source": "// bug_start\npublic boolean processSendfile(SelectionKey sk, KeyAttachment attachment, boolean reg, boolean event) {\n            NioChannel sc = null;\n            try {\n                SendfileData sd = attachment.getSendfileData();\n                if ( sd.fchannel == null ) {\n                    File f = new File(sd.fileName);\n                    if ( !f.exists() ) {\n                        cancelledKey(sk,SocketStatus.ERROR,false);\n                        return false;\n                    }\n                    sd.fchannel = new FileInputStream(f).getChannel();\n                }\n                sc = attachment.getChannel();\n                sc.setSendFile(true);\n                WritableByteChannel wc = ((sc instanceof SecureNioChannel)?sc:sc.getIOChannel());\n// bug_end\n \n// bug_start\n                if (sc.getOutboundRemaining()>0) {\n                    if (sc.flushOutbound()) {\n                        attachment.access();\n                    }\n                } else {\n                    long written = sd.fchannel.transferTo(sd.pos,sd.length,wc);\n                    if ( written > 0 ) {\n                        sd.pos += written;\n                        sd.length -= written;\n                        attachment.access();\n                    } else {\n                        if (sd.fchannel.size() <= sd.pos) {\n                            throw new IOException(\"Sendfile configured to \" +\n                                    \"send more data than was available\");\n                        }\n                    }\n                }\n                if ( sd.length <= 0 && sc.getOutboundRemaining()<=0) {\n                    if (log.isDebugEnabled()) {\n                        log.debug(\"Send file complete for:\"+sd.fileName);\n                    }\n                    attachment.setSendfileData(null);\n                    try {sd.fchannel.close();}catch(Exception ignore){}\n                    if ( sd.keepAlive ) {\n                        if (reg) {\n                            if (log.isDebugEnabled()) {\n                                log.debug(\"Connection is keep alive, registering back for OP_READ\");\n                            }\n                            if (event) {\n                                this.add(attachment.getChannel(),SelectionKey.OP_READ);\n                            } else {\n                                reg(sk,attachment,SelectionKey.OP_READ);\n                            }\n                        }\n                    } else {\n                        if (log.isDebugEnabled()) {\n                            log.debug(\"Send file connection is being closed\");\n                        }\n                        cancelledKey(sk,SocketStatus.STOP,false);\n                    }\n                } else if ( attachment.interestOps() == 0 && reg ) {\n                    if (log.isDebugEnabled()) {\n                        log.debug(\"OP_WRITE for sendilfe:\"+sd.fileName);\n                    }\n                    if (event) {\n                        add(attachment.getChannel(),SelectionKey.OP_WRITE);\n                    } else {\n                        reg(sk,attachment,SelectionKey.OP_WRITE);\n                    }\n                }\n            }catch ( IOException x ) {\n                if ( log.isDebugEnabled() ) log.debug(\"Unable to complete sendfile request:\", x);\n                cancelledKey(sk,SocketStatus.ERROR,false);\n                return false;\n            }catch ( Throwable t ) {\n                log.error(\"\",t);\n                cancelledKey(sk, SocketStatus.ERROR, false);\n                return false;\n            }finally {\n                if (sc!=null) sc.setSendFile(false);\n            }\n            return true;\n// bug_end\n         }\n \n", "target": "// fix_start\nprivate String getSkinResourcePath(String resource)\n    {\n        String skinFolder = getSkinFolder();\n        String resourcePath = skinFolder + resource;\n// fix_end\n// fix_start\n        Path normalizedResource = Paths.get(resourcePath).normalize();\n        if (!normalizedResource.startsWith(skinFolder)) {\n            LOGGER.warn(\"Direct access to skin file [{}] refused. Possible break-in attempt!\", normalizedResource);\n            return null;\n// fix_end\n// fix_start\n        return resourcePath;\n    }\n\n// fix_end\n", "cwe": "CWE-20", "cwe_name": "Improper Input Validation", "idx": 8250}
{"source": "// bug_start\nprivate String getSkinResourcePath(String resource)\n    {\n        String skinFolder = getSkinFolder();\n        String resourcePath = skinFolder + resource;\n// bug_end\n \n// bug_start\n        Path normalizedResource = Paths.get(resourcePath).normalize();\n        if (!normalizedResource.startsWith(skinFolder)) {\n            LOGGER.warn(\"Direct access to skin file [{}] refused. Possible break-in attempt!\", normalizedResource);\n            return null;\n// bug_end\n         }\n \n// bug_start\n        return resourcePath;\n// bug_end\n     }\n \n", "target": "// fix_start\npublic void list(HttpServletRequest request,\n                     HttpServletResponse response,\n                     String message) throws IOException {\n// fix_end\n// fix_start\n        PrintWriter writer = response.getWriter();\n\n        writer.print(Constants.HTML_HEADER_SECTION);\n\n        Object[] args = new Object[2];\n        args[0] = request.getContextPath();\n        args[1] = sm.getString(\"htmlHostManagerServlet.title\");\n        writer.print(MessageFormat.format\n                     (Constants.BODY_HEADER_SECTION, args));\n\n        args = new Object[3];\n        args[0] = sm.getString(\"htmlHostManagerServlet.messageLabel\");\n        if (message == null || message.length() == 0) {\n            args[1] = \"OK\";\n        } else {\n            args[1] = RequestUtil.filter(message);\n        }\n        writer.print(MessageFormat.format(Constants.MESSAGE_SECTION, args));\n\n        args = new Object[9];\n        args[0] = sm.getString(\"htmlHostManagerServlet.manager\");\n        args[1] = response.encodeURL(request.getContextPath() + \"/html/list\");\n        args[2] = sm.getString(\"htmlHostManagerServlet.list\");\n        args[3] = response.encodeURL\n            (request.getContextPath() + \"/\" +\n             sm.getString(\"htmlHostManagerServlet.helpHtmlManagerFile\"));\n        args[4] = sm.getString(\"htmlHostManagerServlet.helpHtmlManager\");\n        args[5] = response.encodeURL\n            (request.getContextPath() + \"/\" +\n             sm.getString(\"htmlHostManagerServlet.helpManagerFile\"));\n        args[6] = sm.getString(\"htmlHostManagerServlet.helpManager\");\n        args[7] = response.encodeURL(\"/manager/status\");\n        args[8] = sm.getString(\"statusServlet.title\");\n        writer.print(MessageFormat.format(Constants.MANAGER_SECTION, args));\n\n        args = new Object[3];\n        args[0] = sm.getString(\"htmlHostManagerServlet.hostName\");\n        args[1] = sm.getString(\"htmlHostManagerServlet.hostAliases\");\n        args[2] = sm.getString(\"htmlHostManagerServlet.hostTasks\");\n        writer.print(MessageFormat.format(HOSTS_HEADER_SECTION, args));\n\n        Container[] children = engine.findChildren();\n        String hostNames[] = new String[children.length];\n        for (int i = 0; i < children.length; i++)\n            hostNames[i] = children[i].getName();\n\n        TreeMap<String,String> sortedHostNamesMap =\n            new TreeMap<String,String>();\n\n        for (int i = 0; i < hostNames.length; i++) {\n            String displayPath = hostNames[i];\n            sortedHostNamesMap.put(displayPath, hostNames[i]);\n// fix_end\n// fix_start\n        String hostsStart = sm.getString(\"htmlHostManagerServlet.hostsStart\");\n        String hostsStop = sm.getString(\"htmlHostManagerServlet.hostsStop\");\n        String hostsRemove = sm.getString(\"htmlHostManagerServlet.hostsRemove\");\n\n        Iterator<Map.Entry<String,String>> iterator =\n            sortedHostNamesMap.entrySet().iterator();\n        while (iterator.hasNext()) {\n            Map.Entry<String,String> entry = iterator.next();\n            String hostName = (String) entry.getKey();\n            Host host = (Host) engine.findChild(hostName);\n\n            if (host != null ) {\n                args = new Object[2];\n                args[0] = RequestUtil.filter(hostName);\n                String[] aliases = host.findAliases();\n                StringBuffer buf = new StringBuffer();\n                if (aliases.length > 0) {\n                    buf.append(aliases[0]);\n                    for (int j = 1; j < aliases.length; j++) {\n                        buf.append(\", \").append(aliases[j]);\n                    }\n                }\n\n                if (buf.length() == 0) {\n                    buf.append(\"&nbsp;\");\n                    args[1] = buf.toString();\n                } else {\n                    args[1] = RequestUtil.filter(buf.toString());\n                }\n\n                writer.print\n                    (MessageFormat.format(HOSTS_ROW_DETAILS_SECTION, args));\n\n                args = new Object[7];\n                args[0] = response.encodeURL\n                    (request.getContextPath() +\n                     \"/html/start?name=\" +\n                     URLEncoder.encode(hostName, \"UTF-8\"));\n                args[1] = hostsStart;\n                args[2] = response.encodeURL\n                    (request.getContextPath() +\n                     \"/html/stop?name=\" +\n                     URLEncoder.encode(hostName, \"UTF-8\"));\n                args[3] = hostsStop;\n                args[4] = response.encodeURL\n                    (request.getContextPath() +\n                     \"/html/remove?name=\" +\n                     URLEncoder.encode(hostName, \"UTF-8\"));\n                args[5] = hostsRemove;\n                args[6] = RequestUtil.filter(hostName);\n                if (host == this.host) {\n                    writer.print(MessageFormat.format(\n                        MANAGER_HOST_ROW_BUTTON_SECTION, args));\n                } else {\n                    writer.print(MessageFormat.format(\n                        HOSTS_ROW_BUTTON_SECTION, args));\n                }\n\n            }\n        }\n\n        args = new Object[6];\n        args[0] = sm.getString(\"htmlHostManagerServlet.addTitle\");\n        args[1] = sm.getString(\"htmlHostManagerServlet.addHost\");\n        args[2] = response.encodeURL(request.getContextPath() + \"/html/add\");\n        args[3] = sm.getString(\"htmlHostManagerServlet.addName\");\n        args[4] = sm.getString(\"htmlHostManagerServlet.addAliases\");\n        args[5] = sm.getString(\"htmlHostManagerServlet.addAppBase\");\n        writer.print(MessageFormat.format(ADD_SECTION_START, args));\n\n        args = new Object[3];\n        args[0] = sm.getString(\"htmlHostManagerServlet.addAutoDeploy\");\n        args[1] = \"autoDeploy\";\n        args[2] = \"checked\";\n        writer.print(MessageFormat.format(ADD_SECTION_BOOLEAN, args));\n        args[0] = sm.getString(\"htmlHostManagerServlet.addDeployOnStartup\");\n        args[1] = \"deployOnStartup\";\n        args[2] = \"checked\";\n        writer.print(MessageFormat.format(ADD_SECTION_BOOLEAN, args));\n        args[0] = sm.getString(\"htmlHostManagerServlet.addDeployXML\");\n        args[1] = \"deployXML\";\n        args[2] = \"checked\";\n        writer.print(MessageFormat.format(ADD_SECTION_BOOLEAN, args));\n        args[0] = sm.getString(\"htmlHostManagerServlet.addUnpackWARs\");\n        args[1] = \"unpackWARs\";\n        args[2] = \"checked\";\n        writer.print(MessageFormat.format(ADD_SECTION_BOOLEAN, args));\n        args[0] = sm.getString(\"htmlHostManagerServlet.addXmlNamespaceAware\");\n        args[1] = \"xmlNamespaceAware\";\n        args[2] = \"\";\n        writer.print(MessageFormat.format(ADD_SECTION_BOOLEAN, args));\n        args[0] = sm.getString(\"htmlHostManagerServlet.addXmlValidation\");\n        args[1] = \"xmlValidation\";\n        args[2] = \"\";\n        writer.print(MessageFormat.format(ADD_SECTION_BOOLEAN, args));\n\n        args[0] = sm.getString(\"htmlHostManagerServlet.addManager\");\n        args[1] = \"manager\";\n        args[2] = \"checked\";\n        writer.print(MessageFormat.format(ADD_SECTION_BOOLEAN, args));\n\n        args = new Object[1];\n        args[0] = sm.getString(\"htmlHostManagerServlet.addButton\");\n        writer.print(MessageFormat.format(ADD_SECTION_END, args));\n\n        args = new Object[7];\n        args[0] = sm.getString(\"htmlHostManagerServlet.serverTitle\");\n        args[1] = sm.getString(\"htmlHostManagerServlet.serverVersion\");\n        args[2] = sm.getString(\"htmlHostManagerServlet.serverJVMVersion\");\n        args[3] = sm.getString(\"htmlHostManagerServlet.serverJVMVendor\");\n        args[4] = sm.getString(\"htmlHostManagerServlet.serverOSName\");\n        args[5] = sm.getString(\"htmlHostManagerServlet.serverOSVersion\");\n        args[6] = sm.getString(\"htmlHostManagerServlet.serverOSArch\");\n        writer.print(MessageFormat.format\n                     (Constants.SERVER_HEADER_SECTION, args));\n\n        args = new Object[6];\n        args[0] = ServerInfo.getServerInfo();\n        args[1] = System.getProperty(\"java.runtime.version\");\n        args[2] = System.getProperty(\"java.vm.vendor\");\n        args[3] = System.getProperty(\"os.name\");\n        args[4] = System.getProperty(\"os.version\");\n        args[5] = System.getProperty(\"os.arch\");\n        writer.print(MessageFormat.format(Constants.SERVER_ROW_SECTION, args));\n\n        writer.print(Constants.HTML_TAIL_SECTION);\n\n        writer.flush();\n        writer.close();\n// fix_end\n", "cwe": "CWE-22", "cwe_name": "Path Traversal", "idx": 28849}
{"source": "// bug_start\npublic void list(HttpServletRequest request,\n                     HttpServletResponse response,\n                     String message) throws IOException {\n\n        PrintWriter writer = response.getWriter();\n\n        writer.print(Constants.HTML_HEADER_SECTION);\n\n        Object[] args = new Object[2];\n        args[0] = request.getContextPath();\n        args[1] = sm.getString(\"htmlHostManagerServlet.title\");\n        writer.print(MessageFormat.format\n                     (Constants.BODY_HEADER_SECTION, args));\n\n        args = new Object[3];\n        args[0] = sm.getString(\"htmlHostManagerServlet.messageLabel\");\n        if (message == null || message.length() == 0) {\n            args[1] = \"OK\";\n        } else {\n            args[1] = RequestUtil.filter(message);\n        }\n        writer.print(MessageFormat.format(Constants.MESSAGE_SECTION, args));\n\n        args = new Object[9];\n        args[0] = sm.getString(\"htmlHostManagerServlet.manager\");\n        args[1] = response.encodeURL(request.getContextPath() + \"/html/list\");\n        args[2] = sm.getString(\"htmlHostManagerServlet.list\");\n        args[3] = response.encodeURL\n            (request.getContextPath() + \"/\" +\n             sm.getString(\"htmlHostManagerServlet.helpHtmlManagerFile\"));\n        args[4] = sm.getString(\"htmlHostManagerServlet.helpHtmlManager\");\n        args[5] = response.encodeURL\n            (request.getContextPath() + \"/\" +\n             sm.getString(\"htmlHostManagerServlet.helpManagerFile\"));\n        args[6] = sm.getString(\"htmlHostManagerServlet.helpManager\");\n        args[7] = response.encodeURL(\"/manager/status\");\n        args[8] = sm.getString(\"statusServlet.title\");\n        writer.print(MessageFormat.format(Constants.MANAGER_SECTION, args));\n\n        args = new Object[3];\n        args[0] = sm.getString(\"htmlHostManagerServlet.hostName\");\n        args[1] = sm.getString(\"htmlHostManagerServlet.hostAliases\");\n        args[2] = sm.getString(\"htmlHostManagerServlet.hostTasks\");\n        writer.print(MessageFormat.format(HOSTS_HEADER_SECTION, args));\n\n        Container[] children = engine.findChildren();\n        String hostNames[] = new String[children.length];\n        for (int i = 0; i < children.length; i++)\n            hostNames[i] = children[i].getName();\n\n        TreeMap<String,String> sortedHostNamesMap =\n            new TreeMap<String,String>();\n\n        for (int i = 0; i < hostNames.length; i++) {\n            String displayPath = hostNames[i];\n            sortedHostNamesMap.put(displayPath, hostNames[i]);\n// bug_end\n         }\n \n// bug_start\n        String hostsStart = sm.getString(\"htmlHostManagerServlet.hostsStart\");\n        String hostsStop = sm.getString(\"htmlHostManagerServlet.hostsStop\");\n        String hostsRemove = sm.getString(\"htmlHostManagerServlet.hostsRemove\");\n// bug_end\n \n// bug_start\n        Iterator<Map.Entry<String,String>> iterator =\n            sortedHostNamesMap.entrySet().iterator();\n        while (iterator.hasNext()) {\n            Map.Entry<String,String> entry = iterator.next();\n            String hostName = (String) entry.getKey();\n            Host host = (Host) engine.findChild(hostName);\n\n            if (host != null ) {\n                args = new Object[2];\n                args[0] = RequestUtil.filter(hostName);\n                String[] aliases = host.findAliases();\n                StringBuffer buf = new StringBuffer();\n                if (aliases.length > 0) {\n                    buf.append(aliases[0]);\n                    for (int j = 1; j < aliases.length; j++) {\n                        buf.append(\", \").append(aliases[j]);\n                    }\n                }\n\n                if (buf.length() == 0) {\n                    buf.append(\"&nbsp;\");\n                    args[1] = buf.toString();\n                } else {\n                    args[1] = RequestUtil.filter(buf.toString());\n                }\n\n                writer.print\n                    (MessageFormat.format(HOSTS_ROW_DETAILS_SECTION, args));\n\n                args = new Object[7];\n                args[0] = response.encodeURL\n                    (request.getContextPath() +\n                     \"/html/start?name=\" + hostName);\n                args[1] = hostsStart;\n                args[2] = response.encodeURL\n                    (request.getContextPath() +\n                     \"/html/stop?name=\" + hostName);\n                args[3] = hostsStop;\n                args[4] = response.encodeURL\n                    (request.getContextPath() +\n                     \"/html/remove?name=\" + hostName);\n                args[5] = hostsRemove;\n                args[6] = hostName;\n                if (host == this.host) {\n                    writer.print(MessageFormat.format(\n                        MANAGER_HOST_ROW_BUTTON_SECTION, args));\n                } else {\n                    writer.print(MessageFormat.format(\n                        HOSTS_ROW_BUTTON_SECTION, args));\n                }\n\n            }\n// bug_end\n         }\n \n// bug_start\n        args = new Object[6];\n        args[0] = sm.getString(\"htmlHostManagerServlet.addTitle\");\n        args[1] = sm.getString(\"htmlHostManagerServlet.addHost\");\n        args[2] = response.encodeURL(request.getContextPath() + \"/html/add\");\n        args[3] = sm.getString(\"htmlHostManagerServlet.addName\");\n        args[4] = sm.getString(\"htmlHostManagerServlet.addAliases\");\n        args[5] = sm.getString(\"htmlHostManagerServlet.addAppBase\");\n        writer.print(MessageFormat.format(ADD_SECTION_START, args));\n// bug_end\n \n// bug_start\n        args = new Object[3];\n        args[0] = sm.getString(\"htmlHostManagerServlet.addAutoDeploy\");\n        args[1] = \"autoDeploy\";\n        args[2] = \"checked\";\n        writer.print(MessageFormat.format(ADD_SECTION_BOOLEAN, args));\n        args[0] = sm.getString(\"htmlHostManagerServlet.addDeployOnStartup\");\n        args[1] = \"deployOnStartup\";\n        args[2] = \"checked\";\n        writer.print(MessageFormat.format(ADD_SECTION_BOOLEAN, args));\n        args[0] = sm.getString(\"htmlHostManagerServlet.addDeployXML\");\n        args[1] = \"deployXML\";\n        args[2] = \"checked\";\n        writer.print(MessageFormat.format(ADD_SECTION_BOOLEAN, args));\n        args[0] = sm.getString(\"htmlHostManagerServlet.addUnpackWARs\");\n        args[1] = \"unpackWARs\";\n        args[2] = \"checked\";\n        writer.print(MessageFormat.format(ADD_SECTION_BOOLEAN, args));\n        args[0] = sm.getString(\"htmlHostManagerServlet.addXmlNamespaceAware\");\n        args[1] = \"xmlNamespaceAware\";\n        args[2] = \"\";\n        writer.print(MessageFormat.format(ADD_SECTION_BOOLEAN, args));\n        args[0] = sm.getString(\"htmlHostManagerServlet.addXmlValidation\");\n        args[1] = \"xmlValidation\";\n        args[2] = \"\";\n        writer.print(MessageFormat.format(ADD_SECTION_BOOLEAN, args));\n// bug_end\n \n// bug_start\n        args[0] = sm.getString(\"htmlHostManagerServlet.addManager\");\n        args[1] = \"manager\";\n        args[2] = \"checked\";\n        writer.print(MessageFormat.format(ADD_SECTION_BOOLEAN, args));\n// bug_end\n \n// bug_start\n        args = new Object[1];\n        args[0] = sm.getString(\"htmlHostManagerServlet.addButton\");\n        writer.print(MessageFormat.format(ADD_SECTION_END, args));\n\n        args = new Object[7];\n        args[0] = sm.getString(\"htmlHostManagerServlet.serverTitle\");\n        args[1] = sm.getString(\"htmlHostManagerServlet.serverVersion\");\n        args[2] = sm.getString(\"htmlHostManagerServlet.serverJVMVersion\");\n        args[3] = sm.getString(\"htmlHostManagerServlet.serverJVMVendor\");\n        args[4] = sm.getString(\"htmlHostManagerServlet.serverOSName\");\n        args[5] = sm.getString(\"htmlHostManagerServlet.serverOSVersion\");\n        args[6] = sm.getString(\"htmlHostManagerServlet.serverOSArch\");\n        writer.print(MessageFormat.format\n                     (Constants.SERVER_HEADER_SECTION, args));\n\n        args = new Object[6];\n        args[0] = ServerInfo.getServerInfo();\n        args[1] = System.getProperty(\"java.runtime.version\");\n        args[2] = System.getProperty(\"java.vm.vendor\");\n        args[3] = System.getProperty(\"os.name\");\n        args[4] = System.getProperty(\"os.version\");\n        args[5] = System.getProperty(\"os.arch\");\n        writer.print(MessageFormat.format(Constants.SERVER_ROW_SECTION, args));\n\n        writer.print(Constants.HTML_TAIL_SECTION);\n\n        writer.flush();\n        writer.close();\n// bug_end\n     }\n \n", "target": "// fix_start\npublic void execute(ActionInvocation invocation) throws Exception {\n        if (this.namespace == null) {\n            this.namespace = invocation.getProxy().getNamespace();\n// fix_end\n// fix_start\n        ValueStack stack = ActionContext.getContext().getValueStack();\n        String finalNamespace = TextParseUtil.translateVariables(namespace, stack);\n        String finalActionName = TextParseUtil.translateVariables(actionName, stack);\n        String finalMethodName = this.methodName != null\n                ? TextParseUtil.translateVariables(this.methodName, stack)\n                : null;\n// fix_end\n// fix_start\n        if (isInChainHistory(finalNamespace, finalActionName, finalMethodName)) {\n            addToHistory(finalNamespace, finalActionName, finalMethodName);\n            throw new XWorkException(\"Infinite recursion detected: \"\n                    + ActionChainResult.getChainHistory().toString());\n// fix_end\n// fix_start\n        if (ActionChainResult.getChainHistory().isEmpty() && invocation != null && invocation.getProxy() != null) {\n            addToHistory(finalNamespace, invocation.getProxy().getActionName(), invocation.getProxy().getMethod());\n        }\n        addToHistory(finalNamespace, finalActionName, finalMethodName);\n// fix_end\n// fix_start\n        HashMap<String, Object> extraContext = new HashMap<String, Object>();\n        extraContext.put(ActionContext.VALUE_STACK, ActionContext.getContext().getValueStack());\n        extraContext.put(ActionContext.PARAMETERS, ActionContext.getContext().getParameters());\n        extraContext.put(CHAIN_HISTORY, ActionChainResult.getChainHistory());\n// fix_end\n// fix_start\n        if (LOG.isDebugEnabled()) {\n            LOG.debug(\"Chaining to action \" + finalActionName);\n        }\n// fix_end\n// fix_start\n        proxy = actionProxyFactory.createActionProxy(finalNamespace, finalActionName, finalMethodName, extraContext);\n        proxy.execute();\n// fix_end\n", "cwe": "CWE-79", "cwe_name": "Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')", "idx": 79267}
{"source": " public void execute(ActionInvocation invocation) throws Exception {\n \t\tactionName = conditionalParse(actionName, invocation);\n// bug_start\n// bug_end\n \t\tString portletNamespace = (String)invocation.getInvocationContext().get(PortletConstants.PORTLET_NAMESPACE);\n \t\tif (portletMode != null) {\n \t\t\tMap<PortletMode, String> namespaceMap = getNamespaceMap(invocation);\n \t\t\tnamespace = namespaceMap.get(portletMode);\n \t\t}\n \t\tif (namespace == null) {\n \t\t\tnamespace = invocation.getProxy().getNamespace();\n \t\t} else {\n \t\t\tnamespace = conditionalParse(namespace, invocation);\n \t\t}\n \t\tif (method == null) {\n \t\t\tmethod = \"\";\n \t\t} else {\n \t\t\tmethod = conditionalParse(method, invocation);\n \t\t}\n \n \t\tString resultCode = invocation.getResultCode();\n \t\tif (resultCode != null) {\n \t\t\tResultConfig resultConfig = invocation.getProxy().getConfig().getResults().get(resultCode);\n \t\t\tMap<String, String> resultConfigParams = resultConfig.getParams();\n             for (Map.Entry<String, String> e : resultConfigParams.entrySet()) {\n                 if (!prohibitedResultParam.contains(e.getKey())) {\n                     requestParameters.put(e.getKey(), e.getValue() == null ? \"\" : conditionalParse(e.getValue(), invocation));\n                 }\n             }\n \t\t}\n \n \t\tStringBuilder tmpLocation = new StringBuilder(actionMapper.getUriFromActionMapping(new ActionMapping(actionName,\n \t\t\t\t(portletNamespace == null ? namespace : portletNamespace + namespace), method, null)));\n \t\turlHelper.buildParametersString(requestParameters, tmpLocation, \"&\");\n \n \t\tsetLocation(tmpLocation.toString());\n \n \t\tsuper.execute(invocation);\n \t}\n \n", "target": "// fix_start\n\t\tparseLocation = false;\n\n// fix_end\n", "cwe": "CWE-20", "cwe_name": "Improper Input Validation", "idx": 10557}
{"source": "// bug_start\n@Override\n    public AuthenticationResult handleResponse(final byte[] response)\n    {\n        if (_state == State.COMPLETE)\n        {\n            return new AuthenticationResult(AuthenticationResult.AuthenticationStatus.ERROR,\n                                            new IllegalStateException(\"Multiple Authentications not permitted.\"));\n        }\n        else if (_state == State.INITIAL && (response == null || response.length == 0))\n        {\n            _state = State.CHALLENGE_SENT;\n            return new AuthenticationResult(new byte[0], AuthenticationResult.AuthenticationStatus.CONTINUE);\n// bug_end\n         }\n \n// bug_start\n        _state = State.COMPLETE;\n        if (response == null || response.length == 0)\n        {\n            return new AuthenticationResult(AuthenticationResult.AuthenticationStatus.ERROR,\n                                            new IllegalArgumentException(\n                                                    \"Invalid PLAIN encoding, authzid null terminator not found\"));\n// bug_end\n         }\n \n// bug_start\n        int authzidNullPosition = findNullPosition(response, 0);\n        if (authzidNullPosition < 0)\n        {\n            return new AuthenticationResult(AuthenticationResult.AuthenticationStatus.ERROR,\n                                            new IllegalArgumentException(\n                                                    \"Invalid PLAIN encoding, authzid null terminator not found\"));\n        }\n        int authcidNullPosition = findNullPosition(response, authzidNullPosition + 1);\n        if (authcidNullPosition < 0)\n        {\n            return new AuthenticationResult(AuthenticationResult.AuthenticationStatus.ERROR,\n                                            new IllegalArgumentException(\n                                                    \"Invalid PLAIN encoding, authcid null terminator not found\"));\n        }\n\n        String password;\n        _username = new String(response, authzidNullPosition + 1, authcidNullPosition - authzidNullPosition - 1, UTF8);\n        int passwordLen = response.length - authcidNullPosition - 1;\n        password = new String(response, authcidNullPosition + 1, passwordLen, UTF8);\n        return _usernamePasswordAuthenticationProvider.authenticate(_username, password);\n// bug_end\n     }\n \n", "target": "// fix_start\npublic void execute(ActionInvocation invocation) throws Exception {\n        ValueStack stack = ActionContext.getContext().getValueStack();\n        String finalNamespace = this.namespace != null\n            ? TextParseUtil.translateVariables(namespace, stack)\n            : invocation.getProxy().getNamespace();\n        String finalActionName = TextParseUtil.translateVariables(actionName, stack);\n        String finalMethodName = this.methodName != null\n            ? TextParseUtil.translateVariables(this.methodName, stack)\n            : null;\n\n        if (isInChainHistory(finalNamespace, finalActionName, finalMethodName)) {\n            addToHistory(finalNamespace, finalActionName, finalMethodName);\n            throw new XWorkException(\"Infinite recursion detected: \"\n                    + ActionChainResult.getChainHistory().toString());\n// fix_end\n// fix_start\n        if (ActionChainResult.getChainHistory().isEmpty() && invocation != null && invocation.getProxy() != null) {\n            addToHistory(finalNamespace, invocation.getProxy().getActionName(), invocation.getProxy().getMethod());\n        }\n        addToHistory(finalNamespace, finalActionName, finalMethodName);\n\n        HashMap<String, Object> extraContext = new HashMap<String, Object>();\n        extraContext.put(ActionContext.VALUE_STACK, ActionContext.getContext().getValueStack());\n        extraContext.put(ActionContext.PARAMETERS, ActionContext.getContext().getParameters());\n        extraContext.put(CHAIN_HISTORY, ActionChainResult.getChainHistory());\n\n        if (LOG.isDebugEnabled()) {\n            LOG.debug(\"Chaining to action \" + finalActionName);\n// fix_end\n// fix_start\n        proxy = actionProxyFactory.createActionProxy(finalNamespace, finalActionName, finalMethodName, extraContext);\n        proxy.execute();\n// fix_end\n", "cwe": "CWE-20", "cwe_name": "Improper Input Validation", "idx": 12222}
{"source": "// bug_start\n@Override\n    public AuthenticationResult handleResponse(final byte[] response)\n    {\n        if (_state == State.COMPLETE)\n        {\n            return new AuthenticationResult(AuthenticationResult.AuthenticationStatus.ERROR,\n                                            new IllegalStateException(\"Multiple Authentications not permitted.\"));\n        }\n        else if (_state == State.INITIAL && (response == null || response.length == 0))\n        {\n            _state = State.CHALLENGE_SENT;\n            return new AuthenticationResult(new byte[0], AuthenticationResult.AuthenticationStatus.CONTINUE);\n// bug_end\n         }\n \n// bug_start\n        _state = State.COMPLETE;\n        if (response == null || response.length == 0)\n        {\n            return new AuthenticationResult(AuthenticationResult.AuthenticationStatus.ERROR,\n                                            new IllegalArgumentException(\n                                                    \"Invalid PLAIN encoding, authzid null terminator not found\"));\n        }\n\n        int authzidNullPosition = findNullPosition(response, 0);\n        if (authzidNullPosition < 0)\n        {\n            return new AuthenticationResult(AuthenticationResult.AuthenticationStatus.ERROR,\n                                            new IllegalArgumentException(\n                                                    \"Invalid PLAIN encoding, authzid null terminator not found\"));\n        }\n        int authcidNullPosition = findNullPosition(response, authzidNullPosition + 1);\n        if (authcidNullPosition < 0)\n        {\n            return new AuthenticationResult(AuthenticationResult.AuthenticationStatus.ERROR,\n                                            new IllegalArgumentException(\n                                                    \"Invalid PLAIN encoding, authcid null terminator not found\"));\n        }\n\n        String password;\n        try\n        {\n            _username = new String(response, authzidNullPosition + 1, authcidNullPosition - authzidNullPosition - 1, UTF8);\n            int passwordLen = response.length - authcidNullPosition - 1;\n            password = new String(response, authcidNullPosition + 1, passwordLen, UTF8);\n        }\n        catch (UnsupportedEncodingException e)\n        {\n            throw new RuntimeException(\"JVM does not support UTF8\", e);\n        }\n        return _usernamePasswordAuthenticationProvider.authenticate(_username, password);\n// bug_end\n     }\n \n", "target": "// fix_start\npublic void encode(FacesContext facesContext) throws IOException {\n        OutputStream outStream = facesContext.getExternalContext().getResponseOutputStream();\n        String expr = contentProducer.getExpressionString();\n\n        if (!Pattern.matches(PARENTHESES, expr)) {\n            throw new IllegalArgumentException(\"Expression \\\"\" + expr + \"\\\" contains parentheses.\");\n// fix_end\n// fix_start\n        contentProducer.invoke(facesContext.getELContext(), new Object[] { outStream, userData });\n// fix_end\n", "cwe": "CWE-20", "cwe_name": "Improper Input Validation", "idx": 5572}
{"source": "// bug_start\npublic void encode(FacesContext facesContext) throws IOException {\n        OutputStream outStream = facesContext.getExternalContext().getResponseOutputStream();\n        contentProducer.invoke(facesContext.getELContext(), new Object[] { outStream, userData });\n// bug_end\n     }\n \n", "target": "// fix_start\n@SuppressFBWarnings(\n            value = \"RCN_REDUNDANT_NULLCHECK_WOULD_HAVE_BEEN_A_NPE\",\n            justification = \"False positive for try-with-resources in Java 11\")\n    public void doSlaveInfo(StaplerRequest req, StaplerResponse rsp) throws IOException {\n        Jenkins jenkins = Jenkins.get();\n        jenkins.checkPermission(SlaveComputer.CREATE);\n\n        rsp.setContentType(\"text/xml\");\n        try (Writer w = rsp.getCompressedWriter(req)) {\n            w.write(\"<slaveInfo><swarmSecret>\" + getSwarmSecret() + \"</swarmSecret></slaveInfo>\");\n        }\n// fix_end\n", "cwe": "CWE-94", "cwe_name": "Improper Control of Generation of Code ('Code Injection')", "idx": 94850}
{"source": "// bug_start\nprotected void authenticatorConfig() {\n// bug_end\n \n// bug_start\n        LoginConfig loginConfig = context.getLoginConfig();\n        if (loginConfig == null) {\n            loginConfig = DUMMY_LOGIN_CONFIG;\n            context.setLoginConfig(loginConfig);\n        }\n\n        if (context.getAuthenticator() != null) {\n            return;\n        }\n\n        if (context.getRealm() == null) {\n            log.error(sm.getString(\"contextConfig.missingRealm\"));\n            ok = false;\n            return;\n        }\n\n        Valve authenticator = null;\n        if (customAuthenticators != null) {\n            authenticator = (Valve) customAuthenticators.get(loginConfig.getAuthMethod());\n        }\n\n        if (authenticator == null) {\n            if (authenticators == null) {\n                log.error(sm.getString(\"contextConfig.authenticatorResources\"));\n                ok = false;\n                return;\n            }\n\n            String authenticatorName = authenticators.getProperty(loginConfig.getAuthMethod());\n            if (authenticatorName == null) {\n                log.error(sm.getString(\"contextConfig.authenticatorMissing\",\n                                 loginConfig.getAuthMethod()));\n                ok = false;\n                return;\n            }\n\n            try {\n                Class<?> authenticatorClass = Class.forName(authenticatorName);\n                authenticator = (Valve) authenticatorClass.getConstructor().newInstance();\n            } catch (Throwable t) {\n                ExceptionUtils.handleThrowable(t);\n                log.error(sm.getString(\n                                    \"contextConfig.authenticatorInstantiate\",\n                                    authenticatorName),\n                          t);\n                ok = false;\n            }\n        }\n\n        if (authenticator != null) {\n            Pipeline pipeline = context.getPipeline();\n            if (pipeline != null) {\n                pipeline.addValve(authenticator);\n                if (log.isDebugEnabled()) {\n                    log.debug(sm.getString(\n                                    \"contextConfig.authenticatorConfigured\",\n                                    loginConfig.getAuthMethod()));\n                }\n            }\n// bug_end\n         }\n     }\n \n", "target": "// fix_start\n@Deprecated\n    @SuppressFBWarnings(\n            value = \"RCN_REDUNDANT_NULLCHECK_WOULD_HAVE_BEEN_A_NPE\",\n            justification = \"False positive for try-with-resources in Java 11\")\n    public void doSlaveInfo(StaplerRequest req, StaplerResponse rsp) throws IOException {\n        Jenkins jenkins = Jenkins.get();\n        jenkins.checkPermission(SlaveComputer.CREATE);\n// fix_end\n// fix_start\n        rsp.setContentType(\"text/xml\");\n        try (Writer w = rsp.getCompressedWriter(req)) {\n            w.write(\"<slaveInfo><swarmSecret>\" + UUID.randomUUID().toString() + \"</swarmSecret></slaveInfo>\");\n// fix_end\n", "cwe": "CWE-352", "cwe_name": "Cross-Site Request Forgery (CSRF)", "idx": 45084}
{"source": "// bug_start\nprotected void authenticatorConfig() {\n// bug_end\n \n// bug_start\n        LoginConfig loginConfig = context.getLoginConfig();\n// bug_end\n \n// bug_start\n        SecurityConstraint constraints[] = context.findConstraints();\n        if ((constraints == null || constraints.length ==0) &&\n                !context.getPreemptiveAuthentication())  {\n            return;\n        } else {\n            if (loginConfig == null) {\n                loginConfig = DUMMY_LOGIN_CONFIG;\n                context.setLoginConfig(loginConfig);\n            }\n        }\n\n        if (context.getAuthenticator() != null) {\n            return;\n        }\n\n        if (context.getRealm() == null) {\n            log.error(sm.getString(\"contextConfig.missingRealm\"));\n            ok = false;\n            return;\n        }\n\n        Valve authenticator = null;\n        if (customAuthenticators != null) {\n            authenticator = (Valve) customAuthenticators.get(loginConfig.getAuthMethod());\n        }\n\n        if (authenticator == null) {\n            if (authenticators == null) {\n                log.error(sm.getString(\"contextConfig.authenticatorResources\"));\n                ok = false;\n                return;\n            }\n\n            String authenticatorName = authenticators.getProperty(loginConfig.getAuthMethod());\n            if (authenticatorName == null) {\n                log.error(sm.getString(\"contextConfig.authenticatorMissing\",\n                                 loginConfig.getAuthMethod()));\n                ok = false;\n                return;\n            }\n\n            try {\n                Class<?> authenticatorClass = Class.forName(authenticatorName);\n                authenticator = (Valve) authenticatorClass.getConstructor().newInstance();\n            } catch (Throwable t) {\n                ExceptionUtils.handleThrowable(t);\n                log.error(sm.getString(\n                                    \"contextConfig.authenticatorInstantiate\",\n                                    authenticatorName),\n                          t);\n                ok = false;\n            }\n        }\n\n        if (authenticator != null) {\n            Pipeline pipeline = context.getPipeline();\n            if (pipeline != null) {\n                pipeline.addValve(authenticator);\n                if (log.isDebugEnabled()) {\n                    log.debug(sm.getString(\n                                    \"contextConfig.authenticatorConfigured\",\n                                    loginConfig.getAuthMethod()));\n                }\n            }\n        }\n    }\n\n// bug_end\n", "target": "// fix_start\npublic String verifyAndExtract(String signedStr) {\n    int index = signedStr.lastIndexOf(SIGNATURE);\n    if (index == -1) {\n      throw new IllegalArgumentException(\"Invalid input sign: \" + signedStr);\n    }\n    String originalSignature = signedStr.substring(index + SIGNATURE.length());\n    String rawValue = signedStr.substring(0, index);\n    String currentSignature = getSignature(rawValue);\n// fix_end\n// fix_start\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"Signature generated for \" + rawValue + \" inside verify is \" + currentSignature);\n    }\n    if (!originalSignature.equals(currentSignature)) {\n      throw new IllegalArgumentException(\"Invalid sign, original = \" + originalSignature +\n        \" current = \" + currentSignature);\n    }\n    return rawValue;\n  }\n// fix_end\n", "cwe": "NVD-CWE-noinfo", "cwe_name": "", "idx": 100470}
{"source": "// bug_start\npublic static Document parseDocument(InputSource source) throws XMLException {\n        try {\n            DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();\n            DocumentBuilder xmlBuilder = dbf.newDocumentBuilder();\n            return xmlBuilder.parse(source);\n        } catch (Exception er) {\n            throw new XMLException(\"Error parsing XML document\", er);\n        }\n// bug_end\n     }\n// bug_start\n// bug_end\n \n", "target": "// fix_start\npublic String verifyAndExtract(String signedStr) {\n    int index = signedStr.lastIndexOf(SIGNATURE);\n    if (index == -1) {\n      throw new IllegalArgumentException(\"Invalid input sign: \" + signedStr);\n// fix_end\n// fix_start\n    String originalSignature = signedStr.substring(index + SIGNATURE.length());\n    String rawValue = signedStr.substring(0, index);\n    String currentSignature = getSignature(rawValue);\n// fix_end\n// fix_start\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"Signature generated for \" + rawValue + \" inside verify is \" + currentSignature);\n    }\n    if (!MessageDigest.isEqual(originalSignature.getBytes(), currentSignature.getBytes())) {\n      throw new IllegalArgumentException(\"Invalid sign, original = \" + originalSignature +\n        \" current = \" + currentSignature);\n    }\n    return rawValue;\n  }\n\n// fix_end\n", "cwe": "CWE-203", "cwe_name": "Information Exposure Through Discrepancy", "idx": 20519}
{"source": "// bug_start\n@Override\n\tprotected void configure() {\n\t\tsuper.configure();\n// bug_end\n \n// bug_start\n\t\tbind(JettyRunner.class).to(DefaultJettyRunner.class);\n\t\tbind(ServletContextHandler.class).toProvider(DefaultJettyRunner.class);\n\n\t\tbind(ObjectMapper.class).toProvider(ObjectMapperProvider.class).in(Singleton.class);\n\n\t\tbind(ValidatorFactory.class).toProvider(new com.google.inject.Provider<ValidatorFactory>() {\n\n\t\t\t@Override\n\t\t\tpublic ValidatorFactory get() {\n\t\t\t\tConfiguration<?> configuration = Validation.byDefaultProvider().configure();\n\t\t\t\treturn configuration.buildValidatorFactory();\n\t\t\t}\n\n\t\t}).in(Singleton.class);\n\n\t\tbind(Validator.class).toProvider(ValidatorProvider.class).in(Singleton.class);\n\n\t\tbind(MarkdownManager.class).to(DefaultMarkdownManager.class);\n\n\t\tconfigurePersistence();\n\t\tconfigureRestServices();\n\t\tconfigureWeb();\n\t\tconfigureBuild();\n\n\t\tbind(GitConfig.class).toProvider(GitConfigProvider.class);\n\n\t\tbind(StorageManager.class).to(DefaultStorageManager.class);\n\t\tbind(SettingManager.class).to(DefaultSettingManager.class);\n\t\tbind(DataManager.class).to(DefaultDataManager.class);\n\t\tbind(TaskScheduler.class).to(DefaultTaskScheduler.class);\n\t\tbind(PullRequestCommentManager.class).to(DefaultPullRequestCommentManager.class);\n\t\tbind(CodeCommentManager.class).to(DefaultCodeCommentManager.class);\n\t\tbind(PullRequestManager.class).to(DefaultPullRequestManager.class);\n\t\tbind(PullRequestUpdateManager.class).to(DefaultPullRequestUpdateManager.class);\n\t\tbind(ProjectManager.class).to(DefaultProjectManager.class);\n\t\tbind(UserManager.class).to(DefaultUserManager.class);\n\t\tbind(PullRequestReviewManager.class).to(DefaultPullRequestReviewManager.class);\n\t\tbind(BuildManager.class).to(DefaultBuildManager.class);\n\t\tbind(BuildDependenceManager.class).to(DefaultBuildDependenceManager.class);\n\t\tbind(JobManager.class).to(DefaultJobManager.class);\n\t\tbind(LogManager.class).to(DefaultLogManager.class);\n\t\tbind(PullRequestBuildManager.class).to(DefaultPullRequestBuildManager.class);\n\t\tbind(MailManager.class).to(DefaultMailManager.class);\n\t\tbind(IssueManager.class).to(DefaultIssueManager.class);\n\t\tbind(IssueFieldManager.class).to(DefaultIssueFieldManager.class);\n\t\tbind(BuildParamManager.class).to(DefaultBuildParamManager.class);\n\t\tbind(UserAuthorizationManager.class).to(DefaultUserAuthorizationManager.class);\n\t\tbind(GroupAuthorizationManager.class).to(DefaultGroupAuthorizationManager.class);\n\t\tbind(PullRequestWatchManager.class).to(DefaultPullRequestWatchManager.class);\n\t\tbind(RoleManager.class).to(DefaultRoleManager.class);\n\t\tbind(CommitInfoManager.class).to(DefaultCommitInfoManager.class);\n\t\tbind(UserInfoManager.class).to(DefaultUserInfoManager.class);\n\t\tbind(BatchWorkManager.class).to(DefaultBatchWorkManager.class);\n\t\tbind(GroupManager.class).to(DefaultGroupManager.class);\n\t\tbind(MembershipManager.class).to(DefaultMembershipManager.class);\n\t\tbind(PullRequestChangeManager.class).to(DefaultPullRequestChangeManager.class);\n\t\tbind(CodeCommentReplyManager.class).to(DefaultCodeCommentReplyManager.class);\n\t\tbind(AttachmentStorageManager.class).to(DefaultAttachmentStorageManager.class);\n\t\tbind(CodeCommentRelationInfoManager.class).to(DefaultCodeCommentRelationInfoManager.class);\n\t\tbind(CodeCommentRelationManager.class).to(DefaultCodeCommentRelationManager.class);\n\t\tbind(WorkExecutor.class).to(DefaultWorkExecutor.class);\n\t\tbind(PullRequestNotificationManager.class);\n\t\tbind(CommitNotificationManager.class);\n\t\tbind(BuildNotificationManager.class);\n\t\tbind(IssueNotificationManager.class);\n\t\tbind(EntityReferenceManager.class);\n\t\tbind(CodeCommentNotificationManager.class);\n\t\tbind(CodeCommentManager.class).to(DefaultCodeCommentManager.class);\n\t\tbind(IssueWatchManager.class).to(DefaultIssueWatchManager.class);\n\t\tbind(IssueChangeManager.class).to(DefaultIssueChangeManager.class);\n\t\tbind(IssueVoteManager.class).to(DefaultIssueVoteManager.class);\n\t\tbind(MilestoneManager.class).to(DefaultMilestoneManager.class);\n\t\tbind(Session.class).toProvider(SessionProvider.class);\n\t\tbind(EntityManager.class).toProvider(SessionProvider.class);\n\t\tbind(SessionFactory.class).toProvider(SessionFactoryProvider.class);\n\t\tbind(EntityManagerFactory.class).toProvider(SessionFactoryProvider.class);\n\t\tbind(IssueCommentManager.class).to(DefaultIssueCommentManager.class);\n\t\tbind(IssueQuerySettingManager.class).to(DefaultIssueQuerySettingManager.class);\n\t\tbind(PullRequestQuerySettingManager.class).to(DefaultPullRequestQuerySettingManager.class);\n\t\tbind(CodeCommentQuerySettingManager.class).to(DefaultCodeCommentQuerySettingManager.class);\n\t\tbind(CommitQuerySettingManager.class).to(DefaultCommitQuerySettingManager.class);\n\t\tbind(BuildQuerySettingManager.class).to(DefaultBuildQuerySettingManager.class);\n\t\tbind(WebHookManager.class);\n\n\t\tcontribute(ObjectMapperConfigurator.class, GitObjectMapperConfigurator.class);\n\t    contribute(ObjectMapperConfigurator.class, HibernateObjectMapperConfigurator.class);\n\n\t\tbind(Realm.class).to(OneAuthorizingRealm.class);\n\t\tbind(RememberMeManager.class).to(OneRememberMeManager.class);\n\t\tbind(WebSecurityManager.class).to(OneWebSecurityManager.class);\n\t\tbind(FilterChainResolver.class).to(OneFilterChainResolver.class);\n\t\tbind(BasicAuthenticationFilter.class);\n\t\tbind(PasswordService.class).to(OnePasswordService.class);\n\t\tbind(ShiroFilter.class);\n\t\tinstall(new ShiroAopModule());\n        contribute(FilterChainConfigurator.class, new FilterChainConfigurator() {\n\n            @Override\n            public void configure(FilterChainManager filterChainManager) {\n                filterChainManager.createChain(\"/**/info/refs\", \"noSessionCreation, authcBasic\");\n                filterChainManager.createChain(\"/**/git-upload-pack\", \"noSessionCreation, authcBasic\");\n                filterChainManager.createChain(\"/**/git-receive-pack\", \"noSessionCreation, authcBasic\");\n            }\n\n        });\n        contributeFromPackage(Authenticator.class, Authenticator.class);\n\n\t\tcontribute(ImplementationProvider.class, new ImplementationProvider() {\n\n\t\t\t@Override\n\t\t\tpublic Class<?> getAbstractClass() {\n\t\t\t\treturn JobExecutor.class;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic Collection<Class<?>> getImplementations() {\n\t\t\t\treturn Sets.newHashSet(AutoDiscoveredJobExecutor.class);\n\t\t\t}\n\n\t\t});\n\n\t\tcontribute(CodePullAuthorizationSource.class, DefaultJobManager.class);\n\n\t\tbind(IndexManager.class).to(DefaultIndexManager.class);\n\t\tbind(SearchManager.class).to(DefaultSearchManager.class);\n\n\t\tbind(EntityValidator.class).to(DefaultEntityValidator.class);\n\n\t\tbind(GitFilter.class);\n\t\tbind(GitPreReceiveCallback.class);\n\t\tbind(GitPostReceiveCallback.class);\n\n\t    bind(ExecutorService.class).toProvider(new Provider<ExecutorService>() {\n\n\t\t\t@Override\n\t\t\tpublic ExecutorService get() {\n\t\t        return new ThreadPoolExecutor(0, Integer.MAX_VALUE, 60L, TimeUnit.SECONDS,\n\t\t        \t\tnew SynchronousQueue<Runnable>()) {\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic void execute(Runnable command) {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tsuper.execute(SecurityUtils.inheritSubject(command));\n\t\t\t\t\t\t} catch (RejectedExecutionException e) {\n\t\t\t\t\t\t\tif (!isShutdown())\n\t\t\t\t\t\t\t\tthrow ExceptionUtils.unchecked(e);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t        };\n\t\t\t}\n\n\t    }).in(Singleton.class);\n\n\t    bind(ForkJoinPool.class).toInstance(new ForkJoinPool() {\n\n\t\t\t@Override\n\t\t\tpublic ForkJoinTask<?> submit(Runnable task) {\n\t\t\t\treturn super.submit(SecurityUtils.inheritSubject(task));\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic void execute(Runnable task) {\n\t\t\t\tsuper.execute(SecurityUtils.inheritSubject(task));\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic <T> ForkJoinTask<T> submit(Callable<T> task) {\n\t\t\t\treturn super.submit(SecurityUtils.inheritSubject(task));\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic <T> ForkJoinTask<T> submit(Runnable task, T result) {\n\t\t\t\treturn super.submit(SecurityUtils.inheritSubject(task), result);\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic <T> T invokeAny(Collection<? extends Callable<T>> tasks)\n\t\t\t\t\tthrows InterruptedException, ExecutionException {\n\t\t\t\treturn super.invokeAny(SecurityUtils.inheritSubject(tasks));\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic <T> T invokeAny(Collection<? extends Callable<T>> tasks, long timeout, TimeUnit unit)\n\t\t\t\t\tthrows InterruptedException, ExecutionException, TimeoutException {\n\t\t\t\treturn super.invokeAny(SecurityUtils.inheritSubject(tasks), timeout, unit);\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic <T> List<Future<T>> invokeAll(Collection<? extends Callable<T>> tasks,\n\t\t\t\t\tlong timeout, TimeUnit unit) throws InterruptedException {\n\t\t\t\treturn super.invokeAll(SecurityUtils.inheritSubject(tasks), timeout, unit);\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic <T> List<Future<T>> invokeAll(Collection<? extends Callable<T>> tasks) {\n\t\t\t\treturn super.invokeAll(SecurityUtils.inheritSubject(tasks));\n\t\t\t}\n\n\t    });\n\t}\n\n// bug_end\n", "target": "// fix_start\npublic static Document parseDocument(InputSource source) throws XMLException {\n        try {\n            DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();\n            DocumentBuilder xmlBuilder = dbf.newDocumentBuilder();\n            dbf.setFeature(XMLConstants.FEATURE_SECURE_PROCESSING, true);\n            return xmlBuilder.parse(source);\n        } catch (Exception er) {\n            throw new XMLException(\"Error parsing XML document\", er);\n        }\n    }\n// fix_end\n", "cwe": "CWE-611", "cwe_name": "Improper Restriction of XML External Entity Reference ('XXE')", "idx": 66430}
{"source": "// bug_start\n@RequestMapping(value = \"/accept.do\", method = POST)\n    public String acceptInvitation(@RequestParam(\"password\") String password,\n                                   @RequestParam(\"password_confirmation\") String passwordConfirmation,\n                                   @RequestParam(\"code\") String code,\n                                   Model model,\n                                   HttpServletRequest request,\n                                   HttpServletResponse response) throws IOException {\n\n        PasswordConfirmationValidation validation = new PasswordConfirmationValidation(password, passwordConfirmation);\n\n        UaaPrincipal principal =  (UaaPrincipal) SecurityContextHolder.getContext().getAuthentication().getPrincipal();\n\n        if (!validation.valid()) {\n           return processErrorReload(code, model, principal.getEmail(), response, \"error_message_code\", validation.getMessageCode());\n        }\n        try {\n            passwordValidator.validate(password);\n        } catch (InvalidPasswordException e) {\n            return processErrorReload(code, model, principal.getEmail(), response, \"error_message\", e.getMessagesAsOneString());\n        }\n        AcceptedInvitation invitation;\n        try {\n            invitation = invitationsService.acceptInvitation(code, password);\n        } catch (HttpClientErrorException e) {\n            return handleUnprocessableEntity(model, response, \"error_message_code\", \"code_expired\", \"invitations/accept_invite\");\n        }\n        principal = new UaaPrincipal(\n            invitation.getUser().getId(),\n            invitation.getUser().getUserName(),\n            invitation.getUser().getPrimaryEmail(),\n            invitation.getUser().getOrigin(),\n            invitation.getUser().getExternalId(),\n            IdentityZoneHolder.get().getId()\n        );\n        UaaAuthentication authentication = new UaaAuthentication(principal, UaaAuthority.USER_AUTHORITIES, new UaaAuthenticationDetails(request));\n        SecurityContextHolder.getContext().setAuthentication(authentication);\n        return \"redirect:\" + invitation.getRedirectUri();\n    }\n\n// bug_end\n", "target": "// fix_start\n@Override\n\tprotected void configure() {\n\t\tsuper.configure();\n\n\t\tbind(JettyRunner.class).to(DefaultJettyRunner.class);\n\t\tbind(ServletContextHandler.class).toProvider(DefaultJettyRunner.class);\n\n\t\tbind(ObjectMapper.class).toProvider(ObjectMapperProvider.class).in(Singleton.class);\n\n\t\tbind(ValidatorFactory.class).toProvider(new com.google.inject.Provider<ValidatorFactory>() {\n\n\t\t\t@Override\n\t\t\tpublic ValidatorFactory get() {\n\t\t\t\tConfiguration<?> configuration = Validation\n\t\t\t\t\t\t.byDefaultProvider()\n\t\t\t\t\t\t.configure()\n\t\t\t\t\t\t.messageInterpolator(new ParameterMessageInterpolator());\n\t\t\t\treturn configuration.buildValidatorFactory();\n\t\t\t}\n\n\t\t}).in(Singleton.class);\n\n\t\tbind(Validator.class).toProvider(ValidatorProvider.class).in(Singleton.class);\n\n\t\tbind(MarkdownManager.class).to(DefaultMarkdownManager.class);\n\n\t\tconfigurePersistence();\n\t\tconfigureRestServices();\n\t\tconfigureWeb();\n\t\tconfigureBuild();\n\n\t\tbind(GitConfig.class).toProvider(GitConfigProvider.class);\n\n\t\tbind(StorageManager.class).to(DefaultStorageManager.class);\n\t\tbind(SettingManager.class).to(DefaultSettingManager.class);\n\t\tbind(DataManager.class).to(DefaultDataManager.class);\n\t\tbind(TaskScheduler.class).to(DefaultTaskScheduler.class);\n\t\tbind(PullRequestCommentManager.class).to(DefaultPullRequestCommentManager.class);\n\t\tbind(CodeCommentManager.class).to(DefaultCodeCommentManager.class);\n\t\tbind(PullRequestManager.class).to(DefaultPullRequestManager.class);\n\t\tbind(PullRequestUpdateManager.class).to(DefaultPullRequestUpdateManager.class);\n\t\tbind(ProjectManager.class).to(DefaultProjectManager.class);\n\t\tbind(UserManager.class).to(DefaultUserManager.class);\n\t\tbind(PullRequestReviewManager.class).to(DefaultPullRequestReviewManager.class);\n\t\tbind(BuildManager.class).to(DefaultBuildManager.class);\n\t\tbind(BuildDependenceManager.class).to(DefaultBuildDependenceManager.class);\n\t\tbind(JobManager.class).to(DefaultJobManager.class);\n\t\tbind(LogManager.class).to(DefaultLogManager.class);\n\t\tbind(PullRequestBuildManager.class).to(DefaultPullRequestBuildManager.class);\n\t\tbind(MailManager.class).to(DefaultMailManager.class);\n\t\tbind(IssueManager.class).to(DefaultIssueManager.class);\n\t\tbind(IssueFieldManager.class).to(DefaultIssueFieldManager.class);\n\t\tbind(BuildParamManager.class).to(DefaultBuildParamManager.class);\n\t\tbind(UserAuthorizationManager.class).to(DefaultUserAuthorizationManager.class);\n\t\tbind(GroupAuthorizationManager.class).to(DefaultGroupAuthorizationManager.class);\n\t\tbind(PullRequestWatchManager.class).to(DefaultPullRequestWatchManager.class);\n\t\tbind(RoleManager.class).to(DefaultRoleManager.class);\n\t\tbind(CommitInfoManager.class).to(DefaultCommitInfoManager.class);\n\t\tbind(UserInfoManager.class).to(DefaultUserInfoManager.class);\n\t\tbind(BatchWorkManager.class).to(DefaultBatchWorkManager.class);\n\t\tbind(GroupManager.class).to(DefaultGroupManager.class);\n\t\tbind(MembershipManager.class).to(DefaultMembershipManager.class);\n\t\tbind(PullRequestChangeManager.class).to(DefaultPullRequestChangeManager.class);\n\t\tbind(CodeCommentReplyManager.class).to(DefaultCodeCommentReplyManager.class);\n\t\tbind(AttachmentStorageManager.class).to(DefaultAttachmentStorageManager.class);\n\t\tbind(CodeCommentRelationInfoManager.class).to(DefaultCodeCommentRelationInfoManager.class);\n\t\tbind(CodeCommentRelationManager.class).to(DefaultCodeCommentRelationManager.class);\n\t\tbind(WorkExecutor.class).to(DefaultWorkExecutor.class);\n\t\tbind(PullRequestNotificationManager.class);\n\t\tbind(CommitNotificationManager.class);\n\t\tbind(BuildNotificationManager.class);\n\t\tbind(IssueNotificationManager.class);\n\t\tbind(EntityReferenceManager.class);\n\t\tbind(CodeCommentNotificationManager.class);\n\t\tbind(CodeCommentManager.class).to(DefaultCodeCommentManager.class);\n\t\tbind(IssueWatchManager.class).to(DefaultIssueWatchManager.class);\n\t\tbind(IssueChangeManager.class).to(DefaultIssueChangeManager.class);\n\t\tbind(IssueVoteManager.class).to(DefaultIssueVoteManager.class);\n\t\tbind(MilestoneManager.class).to(DefaultMilestoneManager.class);\n\t\tbind(Session.class).toProvider(SessionProvider.class);\n\t\tbind(EntityManager.class).toProvider(SessionProvider.class);\n\t\tbind(SessionFactory.class).toProvider(SessionFactoryProvider.class);\n\t\tbind(EntityManagerFactory.class).toProvider(SessionFactoryProvider.class);\n\t\tbind(IssueCommentManager.class).to(DefaultIssueCommentManager.class);\n\t\tbind(IssueQuerySettingManager.class).to(DefaultIssueQuerySettingManager.class);\n\t\tbind(PullRequestQuerySettingManager.class).to(DefaultPullRequestQuerySettingManager.class);\n\t\tbind(CodeCommentQuerySettingManager.class).to(DefaultCodeCommentQuerySettingManager.class);\n\t\tbind(CommitQuerySettingManager.class).to(DefaultCommitQuerySettingManager.class);\n\t\tbind(BuildQuerySettingManager.class).to(DefaultBuildQuerySettingManager.class);\n\t\tbind(WebHookManager.class);\n\n\t\tcontribute(ObjectMapperConfigurator.class, GitObjectMapperConfigurator.class);\n\t    contribute(ObjectMapperConfigurator.class, HibernateObjectMapperConfigurator.class);\n\n\t\tbind(Realm.class).to(OneAuthorizingRealm.class);\n\t\tbind(RememberMeManager.class).to(OneRememberMeManager.class);\n\t\tbind(WebSecurityManager.class).to(OneWebSecurityManager.class);\n\t\tbind(FilterChainResolver.class).to(OneFilterChainResolver.class);\n\t\tbind(BasicAuthenticationFilter.class);\n\t\tbind(PasswordService.class).to(OnePasswordService.class);\n\t\tbind(ShiroFilter.class);\n\t\tinstall(new ShiroAopModule());\n        contribute(FilterChainConfigurator.class, new FilterChainConfigurator() {\n\n            @Override\n            public void configure(FilterChainManager filterChainManager) {\n                filterChainManager.createChain(\"/**/info/refs\", \"noSessionCreation, authcBasic\");\n                filterChainManager.createChain(\"/**/git-upload-pack\", \"noSessionCreation, authcBasic\");\n                filterChainManager.createChain(\"/**/git-receive-pack\", \"noSessionCreation, authcBasic\");\n            }\n\n        });\n        contributeFromPackage(Authenticator.class, Authenticator.class);\n\n\t\tcontribute(ImplementationProvider.class, new ImplementationProvider() {\n\n\t\t\t@Override\n\t\t\tpublic Class<?> getAbstractClass() {\n\t\t\t\treturn JobExecutor.class;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic Collection<Class<?>> getImplementations() {\n\t\t\t\treturn Sets.newHashSet(AutoDiscoveredJobExecutor.class);\n\t\t\t}\n\n\t\t});\n\n\t\tcontribute(CodePullAuthorizationSource.class, DefaultJobManager.class);\n\n\t\tbind(IndexManager.class).to(DefaultIndexManager.class);\n\t\tbind(SearchManager.class).to(DefaultSearchManager.class);\n\n\t\tbind(EntityValidator.class).to(DefaultEntityValidator.class);\n\n\t\tbind(GitFilter.class);\n\t\tbind(GitPreReceiveCallback.class);\n\t\tbind(GitPostReceiveCallback.class);\n\n\t    bind(ExecutorService.class).toProvider(new Provider<ExecutorService>() {\n\n\t\t\t@Override\n\t\t\tpublic ExecutorService get() {\n\t\t        return new ThreadPoolExecutor(0, Integer.MAX_VALUE, 60L, TimeUnit.SECONDS,\n\t\t        \t\tnew SynchronousQueue<Runnable>()) {\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic void execute(Runnable command) {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tsuper.execute(SecurityUtils.inheritSubject(command));\n\t\t\t\t\t\t} catch (RejectedExecutionException e) {\n\t\t\t\t\t\t\tif (!isShutdown())\n\t\t\t\t\t\t\t\tthrow ExceptionUtils.unchecked(e);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t        };\n\t\t\t}\n\n\t    }).in(Singleton.class);\n\n\t    bind(ForkJoinPool.class).toInstance(new ForkJoinPool() {\n\n\t\t\t@Override\n\t\t\tpublic ForkJoinTask<?> submit(Runnable task) {\n\t\t\t\treturn super.submit(SecurityUtils.inheritSubject(task));\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic void execute(Runnable task) {\n\t\t\t\tsuper.execute(SecurityUtils.inheritSubject(task));\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic <T> ForkJoinTask<T> submit(Callable<T> task) {\n\t\t\t\treturn super.submit(SecurityUtils.inheritSubject(task));\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic <T> ForkJoinTask<T> submit(Runnable task, T result) {\n\t\t\t\treturn super.submit(SecurityUtils.inheritSubject(task), result);\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic <T> T invokeAny(Collection<? extends Callable<T>> tasks)\n\t\t\t\t\tthrows InterruptedException, ExecutionException {\n\t\t\t\treturn super.invokeAny(SecurityUtils.inheritSubject(tasks));\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic <T> T invokeAny(Collection<? extends Callable<T>> tasks, long timeout, TimeUnit unit)\n\t\t\t\t\tthrows InterruptedException, ExecutionException, TimeoutException {\n\t\t\t\treturn super.invokeAny(SecurityUtils.inheritSubject(tasks), timeout, unit);\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic <T> List<Future<T>> invokeAll(Collection<? extends Callable<T>> tasks,\n\t\t\t\t\tlong timeout, TimeUnit unit) throws InterruptedException {\n\t\t\t\treturn super.invokeAll(SecurityUtils.inheritSubject(tasks), timeout, unit);\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic <T> List<Future<T>> invokeAll(Collection<? extends Callable<T>> tasks) {\n\t\t\t\treturn super.invokeAll(SecurityUtils.inheritSubject(tasks));\n\t\t\t}\n\n\t    });\n\t}\n\n// fix_end\n", "cwe": "CWE-74", "cwe_name": "Improper Neutralization of Special Elements in Output Used by a Downstream Component ('Injection')", "idx": 73804}
{"source": "// bug_start\n@Override\n    public boolean willAttributeDistribute(String name, Object value) {\n        Pattern sessionAttributeNamePattern = getSessionAttributeNamePattern();\n        if (sessionAttributeNamePattern != null) {\n            if (!sessionAttributeNamePattern.matcher(name).matches()) {\n                if (getWarnOnSessionAttributeFilterFailure() || log.isDebugEnabled()) {\n                    String msg = sm.getString(\"managerBase.sessionAttributeNameFilter\",\n                            name, sessionAttributeNamePattern);\n                    if (getWarnOnSessionAttributeFilterFailure()) {\n                        log.warn(msg);\n                    } else {\n                        log.debug(msg);\n                    }\n                }\n                return false;\n            }\n// bug_end\n         }\n \n// bug_start\n        Pattern sessionAttributeValueClassNamePattern = getSessionAttributeValueClassNamePattern();\n        if (value != null && sessionAttributeValueClassNamePattern != null) {\n            if (!sessionAttributeValueClassNamePattern.matcher(\n                    value.getClass().getName()).matches()) {\n                if (getWarnOnSessionAttributeFilterFailure() || log.isDebugEnabled()) {\n                    String msg = sm.getString(\"managerBase.sessionAttributeValueClassNameFilter\",\n                            name, value.getClass().getName(), sessionAttributeNamePattern);\n                    if (getWarnOnSessionAttributeFilterFailure()) {\n                        log.warn(msg);\n                    } else {\n                        log.debug(msg);\n                    }\n                }\n                return false;\n            }\n// bug_end\n         }\n// bug_start\n\n        return true;\n// bug_end\n     }\n \n", "target": "// fix_start\n@RequestMapping(value = \"/accept.do\", method = POST)\n    public String acceptInvitation(@RequestParam(\"password\") String password,\n                                   @RequestParam(\"password_confirmation\") String passwordConfirmation,\n                                   @RequestParam(\"code\") String code,\n                                   Model model,\n                                   HttpServletRequest request,\n                                   HttpServletResponse response) throws IOException {\n\n        PasswordConfirmationValidation validation = new PasswordConfirmationValidation(password, passwordConfirmation);\n\n        UaaPrincipal principal =  (UaaPrincipal) SecurityContextHolder.getContext().getAuthentication().getPrincipal();\n\n        final ExpiringCode expiringCode = expiringCodeStore.retrieveCode(code);\n\n        if (expiringCode == null || expiringCode.getData() == null) {\n            logger.debug(\"Failing invitation. Code not found.\");\n            SecurityContextHolder.clearContext();\n            return handleUnprocessableEntity(model, response, \"error_message_code\", \"code_expired\", \"invitations/accept_invite\");\n        }\n        Map<String,String> data = JsonUtils.readValue(expiringCode.getData(), new TypeReference<Map<String,String>>() {});\n        if (principal == null || data.get(\"user_id\") == null || !data.get(\"user_id\").equals(principal.getId())) {\n            logger.debug(\"Failing invitation. Code and user ID mismatch.\");\n            SecurityContextHolder.clearContext();\n            return handleUnprocessableEntity(model, response, \"error_message_code\", \"code_expired\", \"invitations/accept_invite\");\n// fix_end\n// fix_start\n        final String newCode = expiringCodeStore.generateCode(expiringCode.getData(), new Timestamp(System.currentTimeMillis() + (10 * 60 * 1000)), expiringCode.getIntent()).getCode();\n        if (!validation.valid()) {\n           return processErrorReload(newCode, model, principal.getEmail(), response, \"error_message_code\", validation.getMessageCode());\n// fix_end\n// fix_start\n        try {\n            passwordValidator.validate(password);\n        } catch (InvalidPasswordException e) {\n            return processErrorReload(newCode, model, principal.getEmail(), response, \"error_message\", e.getMessagesAsOneString());\n        }\n        AcceptedInvitation invitation;\n        try {\n            invitation = invitationsService.acceptInvitation(newCode, password);\n        } catch (HttpClientErrorException e) {\n            return handleUnprocessableEntity(model, response, \"error_message_code\", \"code_expired\", \"invitations/accept_invite\");\n        }\n        principal = new UaaPrincipal(\n            invitation.getUser().getId(),\n            invitation.getUser().getUserName(),\n            invitation.getUser().getPrimaryEmail(),\n            invitation.getUser().getOrigin(),\n            invitation.getUser().getExternalId(),\n            IdentityZoneHolder.get().getId()\n        );\n        UaaAuthentication authentication = new UaaAuthentication(principal, UaaAuthority.USER_AUTHORITIES, new UaaAuthenticationDetails(request));\n        SecurityContextHolder.getContext().setAuthentication(authentication);\n        return \"redirect:\" + invitation.getRedirectUri();\n// fix_end\n", "cwe": "CWE-269", "cwe_name": "Improper Privilege Management", "idx": 35654}
{"source": "// bug_start\n@Override\n    public boolean willAttributeDistribute(String name, Object value) {\n        Pattern sessionAttributeNamePattern = getSessionAttributeNamePattern();\n        if (sessionAttributeNamePattern == null) {\n            return true;\n        }\n        return sessionAttributeNamePattern.matcher(name).matches();\n    }\n// bug_end\n \n", "target": "// fix_start\nprivate static CloseableHttpClient getAllTrustClient(HttpHost proxy) {\n\t\t\treturn HttpClients.custom()\n\t\t\t\t\t.setProxy(proxy)\n\t\t\t\t\t.setSslcontext(getSSLContext())\n\t\t\t\t\t.setHostnameVerifier(SSLConnectionSocketFactory.ALLOW_ALL_HOSTNAME_VERIFIER)\n\t\t\t\t\t.build();\n\t\t}\n// fix_end\n", "cwe": "CWE-264", "cwe_name": "Permissions, Privileges, and Access Controls", "idx": 31990}
{"source": "// bug_start\nprotected Object readResolve()\n        throws ObjectStreamException {\n        AbstractBrokerFactory factory = getPooledFactoryForKey(_poolKey);\n        if (factory != null)\n            return factory;\n// bug_end\n \n// bug_start\n        _transactional = new ConcurrentHashMap();\n        _brokers = newBrokerSet();\n// bug_end\n \n// bug_start\n        String saveLogConfig = _conf.getLog();\n        _conf.setLog(\"none\");\n        makeReadOnly();\n        _conf.setLog(saveLogConfig);\n// bug_end\n \n// bug_start\n        return this;\n    }\n// bug_end\n \n", "target": "// fix_start\nprivate static CloseableHttpClient getAllTrustClient(HttpHost proxy) {\n\t\t\ttry {\n\t\t\t\tHttpClientBuilder clientBuilder = HttpClientBuilder.create();\n\t\t\t\tSSLContext sslContext = new SSLContextBuilder().loadTrustMaterial(null, new TrustStrategy() {\n\t\t\t\t\tpublic boolean isTrusted(X509Certificate[] chain, String authType) throws CertificateException {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}).build();\n\t\t\t\tclientBuilder.setSSLContext(sslContext);\n// fix_end\n// fix_start\n\t\t\t\tHostnameVerifier hostnameVerifier = new NoopHostnameVerifier();\n// fix_end\n// fix_start\n\t\t\t\tSSLConnectionSocketFactory sslSocketFactory = new SSLConnectionSocketFactory(sslContext, hostnameVerifier);\n\t\t\t\tRegistry<ConnectionSocketFactory> socketFactoryRegistry = RegistryBuilder.<ConnectionSocketFactory>create()\n\t\t\t\t\t\t.register(\"http\", PlainConnectionSocketFactory.getSocketFactory())\n\t\t\t\t\t\t.register(\"https\", sslSocketFactory)\n\t\t\t\t\t\t.build();\n// fix_end\n// fix_start\n\t\t\t\tPoolingHttpClientConnectionManager connMgr = new PoolingHttpClientConnectionManager( socketFactoryRegistry);\n\t\t\t\tclientBuilder.setConnectionManager(connMgr);\n// fix_end\n// fix_start\n\t\t\t\treturn clientBuilder.build();\n\t\t\t} catch (GeneralSecurityException e) {\n\t\t\t\tthrow new RuntimeException(e);\n\t\t\t}\n\t\t}\n\n// fix_end\n", "cwe": "CWE-352", "cwe_name": "Cross-Site Request Forgery (CSRF)", "idx": 45760}
{"source": "// bug_start\nprotected Object readResolve()\n        throws ObjectStreamException {\n        AbstractBrokerFactory factory = getPooledFactoryForKey(_poolKey);\n        if (factory != null)\n            return factory;\n// bug_end\n \n// bug_start\n        _transactional = new ConcurrentHashMap();\n        _brokers = newBrokerSet();\n// bug_end\n \n// bug_start\n        makeReadOnly();\n        return this;\n// bug_end\n     }\n \n", "target": "// fix_start\n@Override\n    public synchronized SSLEngineResult wrap(\n            final ByteBuffer[] srcs, final int offset, final int length, final ByteBuffer dst) throws SSLException {\n// fix_end\n// fix_start\n        if (isDestroyed()) {\n            return CLOSED_NOT_HANDSHAKING;\n        }\n// fix_end\n// fix_start\n        if (srcs == null) {\n            throw new IllegalArgumentException(\"srcs is null\");\n        }\n        if (dst == null) {\n            throw new IllegalArgumentException(\"dst is null\");\n        }\n\n        if (offset >= srcs.length || offset + length > srcs.length) {\n            throw new IndexOutOfBoundsException(\n                    \"offset: \" + offset + \", length: \" + length +\n                            \" (expected: offset <= offset + length <= srcs.length (\" + srcs.length + \"))\");\n        }\n\n        if (dst.isReadOnly()) {\n            throw new ReadOnlyBufferException();\n        }\n\n        HandshakeStatus status = NOT_HANDSHAKING;\n        if (handshakeState != HandshakeState.FINISHED) {\n            if (handshakeState != HandshakeState.STARTED_EXPLICITLY) {\n                handshakeState = HandshakeState.STARTED_IMPLICITLY;\n            }\n\n            status = handshake();\n            if (status == NEED_UNWRAP) {\n                return NEED_UNWRAP_OK;\n            }\n\n            if (engineClosed) {\n                return NEED_UNWRAP_CLOSED;\n            }\n        }\n\n        int bytesProduced = 0;\n\n        int bytesConsumed = 0;\n        int endOffset = offset + length;\n        for (int i = offset; i < endOffset; ++ i) {\n            final ByteBuffer src = srcs[i];\n            if (src == null) {\n                throw new IllegalArgumentException(\"srcs[\" + i + \"] is null\");\n            }\n            while (src.hasRemaining()) {\n\n                int result = writePlaintextData(src);\n                if (result > 0) {\n                    bytesConsumed += result;\n                } else {\n                    int sslError = SSL.getError(ssl, result);\n                    switch (sslError) {\n                    case SSL.SSL_ERROR_ZERO_RETURN:\n                        if (!receivedShutdown) {\n                            closeAll();\n                        }\n                    case SSL.SSL_ERROR_WANT_READ:\n                    case SSL.SSL_ERROR_WANT_WRITE:\n                        break;\n                    default:\n                        throw shutdownWithError(\"SSL_write\");\n                    }\n                }\n\n                SSLEngineResult pendingNetResult = readPendingBytesFromBIO(dst, bytesConsumed, bytesProduced, status);\n                if (pendingNetResult != null) {\n                    return pendingNetResult;\n                }\n            }\n        }\n        if (bytesConsumed == 0) {\n            SSLEngineResult pendingNetResult = readPendingBytesFromBIO(dst, 0, bytesProduced, status);\n            if (pendingNetResult != null) {\n                return pendingNetResult;\n            }\n        }\n\n        return newResult(bytesConsumed, bytesProduced, status);\n// fix_end\n", "cwe": "CWE-264", "cwe_name": "Permissions, Privileges, and Access Controls", "idx": 33094}
{"source": " @Override\n// bug_start\n    public Resource getResource(String pathInContext)\n    {\n        Resource r=null;\n        if (_relativeResourceBase!=null)\n            pathInContext=URIUtil.addPaths(_relativeResourceBase,pathInContext);\n// bug_end\n \n// bug_start\n        try\n        {\n            if (_resourceBase!=null)\n            {\n                r = _resourceBase.addPath(pathInContext);\n                if (!_contextHandler.checkAlias(pathInContext,r))\n                    r=null;\n            }\n            else if (_servletContext instanceof ContextHandler.Context)\n            {\n                r = _contextHandler.getResource(pathInContext);\n            }\n            else\n            {\n                URL u = _servletContext.getResource(pathInContext);\n                r = _contextHandler.newResource(u);\n// bug_end\n             }\n \n// bug_start\n            if (LOG.isDebugEnabled())\n                LOG.debug(\"Resource \"+pathInContext+\"=\"+r);\n        }\n        catch (IOException e)\n        {\n            LOG.ignore(e);\n// bug_end\n         }\n \n// bug_start\n        if((r==null || !r.exists()) && pathInContext.endsWith(\"/jetty-dir.css\"))\n            r=_stylesheet;\n// bug_end\n \n// bug_start\n        return r;\n// bug_end\n     }\n \n", "target": "// fix_start\n    public synchronized SSLEngineResult wrap(\n            final ByteBuffer[] srcs, final int offset, final int length, final ByteBuffer dst) throws SSLException {\n// fix_end\n// fix_start\n        if (isDestroyed()) {\n            return CLOSED_NOT_HANDSHAKING;\n        }\n\n        if (srcs == null) {\n            throw new IllegalArgumentException(\"srcs is null\");\n        }\n        if (dst == null) {\n            throw new IllegalArgumentException(\"dst is null\");\n        }\n\n        if (offset >= srcs.length || offset + length > srcs.length) {\n            throw new IndexOutOfBoundsException(\n                    \"offset: \" + offset + \", length: \" + length +\n                            \" (expected: offset <= offset + length <= srcs.length (\" + srcs.length + \"))\");\n        }\n\n        if (dst.isReadOnly()) {\n            throw new ReadOnlyBufferException();\n        }\n\n        HandshakeStatus status = NOT_HANDSHAKING;\n        if (handshakeState != HandshakeState.FINISHED) {\n            if (handshakeState != HandshakeState.STARTED_EXPLICITLY) {\n                handshakeState = HandshakeState.STARTED_IMPLICITLY;\n// fix_end\n// fix_start\n            status = handshake();\n            if (status == NEED_UNWRAP) {\n                return NEED_UNWRAP_OK;\n            }\n\n            if (engineClosed) {\n                return NEED_UNWRAP_CLOSED;\n            }\n// fix_end\n// fix_start\n        int bytesProduced = 0;\n        int bytesConsumed = 0;\n        int endOffset = offset + length;\n        for (int i = offset; i < endOffset; ++ i) {\n            final ByteBuffer src = srcs[i];\n            if (src == null) {\n                throw new IllegalArgumentException(\"srcs[\" + i + \"] is null\");\n            }\n            while (src.hasRemaining()) {\n                final SSLEngineResult pendingNetResult;\n                int result = writePlaintextData(src);\n                if (result > 0) {\n                    bytesConsumed += result;\n// fix_end\n// fix_start\n                    pendingNetResult = readPendingBytesFromBIO(dst, bytesConsumed, bytesProduced, status);\n                    if (pendingNetResult != null) {\n                        return pendingNetResult;\n                    }\n                } else {\n                    int sslError = SSL.getError(ssl, result);\n                    switch (sslError) {\n                    case SSL.SSL_ERROR_ZERO_RETURN:\n                        if (!receivedShutdown) {\n                            closeAll();\n                        }\n                        pendingNetResult = readPendingBytesFromBIO(dst, bytesConsumed, bytesProduced, status);\n                        return pendingNetResult != null ? pendingNetResult : CLOSED_NOT_HANDSHAKING;\n                    case SSL.SSL_ERROR_WANT_READ:\n                        pendingNetResult = readPendingBytesFromBIO(dst, bytesConsumed, bytesProduced, status);\n                        return pendingNetResult != null ? pendingNetResult :\n                                new SSLEngineResult(getEngineStatus(), NEED_UNWRAP, bytesConsumed, bytesProduced);\n                    case SSL.SSL_ERROR_WANT_WRITE:\n                        pendingNetResult = readPendingBytesFromBIO(dst, bytesConsumed, bytesProduced, status);\n                        return pendingNetResult != null ? pendingNetResult : NEED_WRAP_CLOSED;\n                    default:\n                        throw shutdownWithError(\"SSL_write\");\n                    }\n                }\n            }\n        }\n        if (bytesConsumed == 0) {\n            SSLEngineResult pendingNetResult = readPendingBytesFromBIO(dst, 0, bytesProduced, status);\n            if (pendingNetResult != null) {\n                return pendingNetResult;\n            }\n        }\n\n        return newResult(bytesConsumed, bytesProduced, status);\n// fix_end\n", "cwe": "CWE-835", "cwe_name": "Loop with Unreachable Exit Condition ('Infinite Loop')", "idx": 82273}
{"source": "// bug_start\npublic void updateByXml(Source source) throws IOException {\n        checkPermission(CONFIGURE);\n        XmlFile configXmlFile = getConfigFile();\n        AtomicFileWriter out = new AtomicFileWriter(configXmlFile.getFile());\n        try {\n            try {\n                Transformer t = TransformerFactory.newInstance()\n                        .newTransformer();\n                t.transform(source,\n                        new StreamResult(out));\n                out.close();\n            } catch (TransformerException e) {\n                throw new IOException2(\"Failed to persist configuration.xml\", e);\n// bug_end\n             }\n \n// bug_start\n            new XmlFile(Items.XSTREAM, out.getTemporaryFile()).unmarshal(this);\n            Items.updatingByXml.set(true);\n            try {\n                onLoad(getParent(), getRootDir().getName());\n            } finally {\n                Items.updatingByXml.set(false);\n            }\n            Jenkins.getInstance().rebuildDependencyGraphAsync();\n// bug_end\n \n// bug_start\n            out.commit();\n            SaveableListener.fireOnChange(this, getConfigFile());\n        } finally {\n            out.abort();\n        }\n// bug_end\n     }\n \n", "target": "// fix_start\n@Override\n    public Resource getResource(String pathInContext)\n    {\n        Resource r=null;\n        if (_relativeResourceBase!=null)\n            pathInContext=URIUtil.addPaths(_relativeResourceBase,pathInContext);\n\n        try\n        {\n            if (_resourceBase!=null)\n            {\n                r = _resourceBase.addPath(pathInContext);\n                if (!_contextHandler.checkAlias(pathInContext,r))\n                    r=null;\n            }\n            else if (_servletContext instanceof ContextHandler.Context)\n            {\n                r = _contextHandler.getResource(pathInContext);\n            }\n            else\n            {\n                URL u = _servletContext.getResource(pathInContext);\n                r = _contextHandler.newResource(u);\n// fix_end\n// fix_start\n            if (LOG.isDebugEnabled())\n                LOG.debug(\"Resource \"+pathInContext+\"=\"+r);\n        }\n        catch (IOException e)\n        {\n            LOG.ignore(e);\n        }\n        catch (Throwable t)\n        {\n            throw (InvalidPathException) new InvalidPathException(pathInContext, \"Invalid PathInContext\").initCause(t);\n        }\n// fix_end\n// fix_start\n        if((r==null || !r.exists()) && pathInContext.endsWith(\"/jetty-dir.css\"))\n            r=_stylesheet;\n\n        return r;\n// fix_end\n", "cwe": "NVD-CWE-noinfo", "cwe_name": "", "idx": 101971}
{"source": "// bug_start\nprivate void init(ErrorDispatcher err) throws JasperException {\n        if (initialized)\n            return;\n\n        String blockExternalString = ctxt.getInitParameter(\n                Constants.XML_BLOCK_EXTERNAL_INIT_PARAM);\n        boolean blockExternal;\n        if (blockExternalString == null) {\n            blockExternal = true;\n        } else {\n            blockExternal = Boolean.parseBoolean(blockExternalString);\n        }\n\n        TagPluginParser parser = new TagPluginParser(ctxt, blockExternal);\n\n// bug_end\n         try {\n// bug_start\n            Enumeration<URL> urls =\n                    ctxt.getClassLoader().getResources(META_INF_JASPER_TAG_PLUGINS_XML);\n            if (urls != null) {\n                while (urls.hasMoreElements()) {\n                    URL url = urls.nextElement();\n                    parser.parse(url);\n                }\n// bug_end\n             }\n \n// bug_start\n            URL url = ctxt.getResource(TAG_PLUGINS_XML);\n            if (url != null) {\n                parser.parse(url);\n// bug_end\n             }\n// bug_start\n        } catch (IOException | SAXException e) {\n            throw new JasperException(e);\n// bug_end\n         }\n// bug_start\n\n        Map<String, String> plugins = parser.getPlugins();\n        tagPlugins = new HashMap<>(plugins.size());\n        for (Map.Entry<String, String> entry : plugins.entrySet()) {\n            try {\n                String tagClass = entry.getKey();\n                String pluginName = entry.getValue();\n                Class<?> pluginClass = ctxt.getClassLoader().loadClass(pluginName);\n                TagPlugin plugin = (TagPlugin) pluginClass.newInstance();\n                tagPlugins.put(tagClass, plugin);\n            } catch (Exception e) {\n                err.jspError(e);\n            }\n        }\n        initialized = true;\n// bug_end\n     }\n \n", "target": "// fix_start\npublic void updateByXml(Source source) throws IOException {\n        checkPermission(CONFIGURE);\n        XmlFile configXmlFile = getConfigFile();\n        AtomicFileWriter out = new AtomicFileWriter(configXmlFile.getFile());\n// fix_end\n// fix_start\n            try {\n                Transformer t = TransformerFactory.newInstance()\n                        .newTransformer();\n                t.transform(source,\n                        new StreamResult(out));\n                out.close();\n            } catch (TransformerException e) {\n                throw new IOException2(\"Failed to persist configuration.xml\", e);\n// fix_end\n// fix_start\n            Object o = new XmlFile(Items.XSTREAM, out.getTemporaryFile()).unmarshal(this);\n            if (o!=this) {\n                throw new IOException(\"Expecting \"+this.getClass()+\" but got \"+o.getClass()+\" instead\");\n// fix_end\n// fix_start\n\n            Items.updatingByXml.set(true);\n            try {\n                onLoad(getParent(), getRootDir().getName());\n            } finally {\n                Items.updatingByXml.set(false);\n            }\n            Jenkins.getInstance().rebuildDependencyGraphAsync();\n\n            out.commit();\n            SaveableListener.fireOnChange(this, getConfigFile());\n        } finally {\n            out.abort();\n// fix_end\n// fix_start\n// fix_end\n", "cwe": "CWE-264", "cwe_name": "Permissions, Privileges, and Access Controls", "idx": 30478}
{"source": "// bug_start\npublic void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {\n        HttpServletRequest req = (HttpServletRequest) request;\n        HttpServletResponse rsp = (HttpServletResponse) response;\n        String authorization = req.getHeader(\"Authorization\");\n// bug_end\n \n// bug_start\n        if (authorization!=null) {\n            String uidpassword = Scrambler.descramble(authorization.substring(6));\n            int idx = uidpassword.indexOf(':');\n            if (idx >= 0) {\n                String username = uidpassword.substring(0, idx);\n                try {\n                    Jenkins.getInstance().getSecurityRealm().loadUserByUsername(username);\n                } catch (UserMayOrMayNotExistException x) {\n                } catch (UsernameNotFoundException x) {\n                    chain.doFilter(request, response);\n                    return;\n                } catch (DataAccessException x) {\n                    throw new ServletException(x);\n                }\n                String password = uidpassword.substring(idx+1);\n// bug_end\n \n// bug_start\n                User u = User.get(username);\n                ApiTokenProperty t = u.getProperty(ApiTokenProperty.class);\n                if (t!=null && t.matchesPassword(password)) {\n                    SecurityContext oldContext = ACL.impersonate(u.impersonate());\n                    try {\n                        request.setAttribute(ApiTokenProperty.class.getName(), u);\n                        chain.doFilter(request,response);\n                        return;\n                    } finally {\n                        SecurityContextHolder.setContext(oldContext);\n                    }\n                }\n// bug_end\n             }\n         }\n \n// bug_start\n        chain.doFilter(request,response);\n// bug_end\n     }\n \n", "target": "// fix_start\nprivate void init(ErrorDispatcher err) throws JasperException {\n        if (initialized)\n            return;\n// fix_end\n// fix_start\n        String blockExternalString = ctxt.getInitParameter(\n                Constants.XML_BLOCK_EXTERNAL_INIT_PARAM);\n        boolean blockExternal;\n        if (blockExternalString == null) {\n            blockExternal = true;\n        } else {\n            blockExternal = Boolean.parseBoolean(blockExternalString);\n        }\n// fix_end\n// fix_start\n        TagPluginParser parser;\n        ClassLoader original;\n        if (Constants.IS_SECURITY_ENABLED) {\n            PrivilegedGetTccl pa = new PrivilegedGetTccl();\n            original = AccessController.doPrivileged(pa);\n            } else {\n                original = Thread.currentThread().getContextClassLoader();\n            }\n        try {\n            if (Constants.IS_SECURITY_ENABLED) {\n                PrivilegedSetTccl pa =\n                        new PrivilegedSetTccl(JspDocumentParser.class.getClassLoader());\n                AccessController.doPrivileged(pa);\n            } else {\n                Thread.currentThread().setContextClassLoader(\n                        JspDocumentParser.class.getClassLoader());\n            }\n\n            parser = new TagPluginParser(ctxt, blockExternal);\n\n        } finally {\n            if (Constants.IS_SECURITY_ENABLED) {\n                PrivilegedSetTccl pa = new PrivilegedSetTccl(original);\n                AccessController.doPrivileged(pa);\n            } else {\n                Thread.currentThread().setContextClassLoader(original);\n// fix_end\n// fix_start\n        try {\n            Enumeration<URL> urls =\n                    ctxt.getClassLoader().getResources(META_INF_JASPER_TAG_PLUGINS_XML);\n            if (urls != null) {\n                while (urls.hasMoreElements()) {\n                    URL url = urls.nextElement();\n                    parser.parse(url);\n                }\n            }\n\n            URL url = ctxt.getResource(TAG_PLUGINS_XML);\n            if (url != null) {\n                parser.parse(url);\n            }\n        } catch (IOException | SAXException e) {\n            throw new JasperException(e);\n        }\n\n        Map<String, String> plugins = parser.getPlugins();\n        tagPlugins = new HashMap<>(plugins.size());\n        for (Map.Entry<String, String> entry : plugins.entrySet()) {\n            try {\n                String tagClass = entry.getKey();\n                String pluginName = entry.getValue();\n                Class<?> pluginClass = ctxt.getClassLoader().loadClass(pluginName);\n                TagPlugin plugin = (TagPlugin) pluginClass.newInstance();\n                tagPlugins.put(tagClass, plugin);\n            } catch (Exception e) {\n                err.jspError(e);\n            }\n        }\n        initialized = true;\n// fix_end\n", "cwe": "CWE-264", "cwe_name": "Permissions, Privileges, and Access Controls", "idx": 32134}
{"source": "// bug_start\npublic void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {\n        HttpServletRequest req = (HttpServletRequest) request;\n        HttpServletResponse rsp = (HttpServletResponse) response;\n        String authorization = req.getHeader(\"Authorization\");\n// bug_end\n \n// bug_start\n        if (authorization!=null) {\n            String uidpassword = Scrambler.descramble(authorization.substring(6));\n            int idx = uidpassword.indexOf(':');\n            if (idx >= 0) {\n                String username = uidpassword.substring(0, idx);\n                String password = uidpassword.substring(idx+1);\n\n                User u = User.get(username);\n                ApiTokenProperty t = u.getProperty(ApiTokenProperty.class);\n                if (t!=null && t.matchesPassword(password)) {\n                    SecurityContext oldContext = ACL.impersonate(u.impersonate());\n                    try {\n                        request.setAttribute(ApiTokenProperty.class.getName(), u);\n                        chain.doFilter(request,response);\n                        return;\n                    } finally {\n                        SecurityContextHolder.setContext(oldContext);\n                    }\n                }\n            }\n// bug_end\n         }\n \n// bug_start\n        chain.doFilter(request,response);\n// bug_end\n     }\n \n", "target": "// fix_start\npublic void validate(Object object) throws ValidationException {\n        String fieldName = getFieldName();\n        Object value = this.getFieldValue(fieldName, object);\n// fix_end\n// fix_start\n        if (value == null || value.toString().length() == 0) {\n            return;\n// fix_end\n// fix_start\n        if (!(value.getClass().equals(String.class)) || !Pattern.compile(getUrlRegex(), Pattern.CASE_INSENSITIVE).matcher(String.valueOf(value).trim()).matches()) {\n            addFieldError(fieldName, object);\n        }\n// fix_end\n", "cwe": "CWE-287", "cwe_name": "Improper Authentication", "idx": 38581}
{"source": "// bug_start\npublic void validate(Object object) throws ValidationException {\n        String fieldName = getFieldName();\n        Object value = this.getFieldValue(fieldName, object);\n\n        if (value == null || value.toString().length() == 0) {\n            return;\n// bug_end\n         }\n// bug_start\n\n        if (!(value.getClass().equals(String.class)) || !Pattern.compile(getUrlRegex(), Pattern.CASE_INSENSITIVE).matcher(String.valueOf(value)).matches()) {\n            addFieldError(fieldName, object);\n        }\n// bug_end\n     }\n \n", "target": "// fix_start\n@Override\n    public boolean validateCrumb(ServletRequest request, String salt, String crumb) {\n        if (request instanceof HttpServletRequest) {\n            String newCrumb = issueCrumb(request, salt);\n            if ((newCrumb != null) && (crumb != null)) {\n                return MessageDigest.isEqual(newCrumb.getBytes(), crumb.getBytes());\n            }\n// fix_end\n// fix_start\n        return false;\n// fix_end\n", "cwe": "CWE-20", "cwe_name": "Improper Input Validation", "idx": 6430}
{"source": "// bug_start\n@Override\n    public boolean validateCrumb(ServletRequest request, String salt, String crumb) {\n        if (request instanceof HttpServletRequest) {\n            String newCrumb = issueCrumb(request, salt);\n            if ((newCrumb != null) && (crumb != null)) {\n                return newCrumb.equals(crumb);\n// bug_end\n             }\n         }\n// bug_start\n        return false;\n// bug_end\n     }\n \n", "target": "// fix_start\n@Restricted(NoExternalUse.class)\n    @RequirePOST public HttpResponse doCheckUpdatesServer() throws IOException {\n        for (UpdateSite site : Jenkins.getInstance().getUpdateCenter().getSites()) {\n            FormValidation v = site.updateDirectlyNow(DownloadService.signatureCheck);\n            if (v.kind != FormValidation.Kind.OK) {\n                return v;\n// fix_end\n// fix_start\n        for (DownloadService.Downloadable d : DownloadService.Downloadable.all()) {\n            FormValidation v = d.updateNow();\n            if (v.kind != FormValidation.Kind.OK) {\n                return v;\n            }\n        }\n        return HttpResponses.forwardToPreviousPage();\n// fix_end\n", "cwe": "CWE-200", "cwe_name": "Exposure of Sensitive Information to an Unauthorized Actor", "idx": 13770}
{"source": "// bug_start\nprotected static byte[] readFully(InputStream inp, int length, boolean shortDataIsFatal)\n            throws IOException {\n        if (length > MAX_RECORD_SIZE) {\n            throw new IOException(\"Record size (\"+length+\n                    \" bytes) is larger than the allowed record size: \"+MAX_RECORD_SIZE);\n// bug_end\n         }\n// bug_start\n        byte[] b = new byte[length];\n\n        int pos = 0;\n        int read;\n        while (pos < length) {\n            read = inp.read(b, pos, length-pos);\n            if (read == -1) {\n                if(shortDataIsFatal) {\n                   throw new IOException(\"Tried to read \" + length + \" bytes, but only \" + pos + \" bytes present\");\n                } else {\n                   return b;\n                }\n// bug_end\n             }\n// bug_start\n            pos += read;\n// bug_end\n         }\n// bug_start\n\n        return b;\n// bug_end\n     }\n \n", "target": "// fix_start\n@Restricted(NoExternalUse.class)\n    @RequirePOST public HttpResponse doCheckUpdatesServer() throws IOException {\n        Jenkins.getInstance().checkPermission(Jenkins.ADMINISTER);\n        for (UpdateSite site : Jenkins.getInstance().getUpdateCenter().getSites()) {\n            FormValidation v = site.updateDirectlyNow(DownloadService.signatureCheck);\n            if (v.kind != FormValidation.Kind.OK) {\n                return v;\n            }\n// fix_end\n// fix_start\n        for (DownloadService.Downloadable d : DownloadService.Downloadable.all()) {\n            FormValidation v = d.updateNow();\n            if (v.kind != FormValidation.Kind.OK) {\n                return v;\n// fix_end\n// fix_start\n// fix_end\n// fix_start\n        return HttpResponses.forwardToPreviousPage();\n// fix_end\n", "cwe": "CWE-264", "cwe_name": "Permissions, Privileges, and Access Controls", "idx": 30510}
{"source": "// bug_start\nprotected static byte[] readFully(InputStream inp, int length, boolean shortDataIsFatal)\n            throws IOException {\n        byte[] b = new byte[length];\n// bug_end\n \n// bug_start\n        int pos = 0;\n        int read;\n        while (pos < length) {\n            read = inp.read(b, pos, length-pos);\n            if (read == -1) {\n                if(shortDataIsFatal) {\n                   throw new IOException(\"Tried to read \" + length + \" bytes, but only \" + pos + \" bytes present\");\n                } else {\n                   return b;\n                }\n            }\n            pos += read;\n// bug_end\n         }\n// bug_start\n\n        return b;\n// bug_end\n     }\n \n", "target": "// fix_start\n@Override\n    protected void configureDataFormat(DataFormat dataFormat, CamelContext camelContext) {\n        if (mappingFile != null) {\n            setProperty(camelContext, dataFormat, \"mappingFile\", mappingFile);\n        }\n        boolean isValidation = getValidation() == null || getValidation();\n        setProperty(camelContext, dataFormat, \"validation\", isValidation);\n// fix_end\n// fix_start\n        if (encoding != null) {\n            setProperty(camelContext, dataFormat, \"encoding\", encoding);\n// fix_end\n// fix_start\n        if (packages != null) {\n            setProperty(camelContext, dataFormat, \"packages\", packages);\n        }\n        if (classes != null) {\n            setProperty(camelContext, dataFormat, \"classes\", classes);\n        }\n// fix_end\n", "cwe": "CWE-835", "cwe_name": "Loop with Unreachable Exit Condition ('Infinite Loop')", "idx": 83036}
{"source": " @Override\n// bug_start\n    public String determineTargetUrl(HttpServletRequest request, HttpServletResponse response) {\n        Object redirectAttribute = request.getAttribute(URI_OVERRIDE_ATTRIBUTE);\n        String redirectFormParam = request.getParameter(FORM_REDIRECT_PARAMETER);\n        if (redirectAttribute !=null) {\n            logger.debug(\"Returning redirectAttribute saved URI:\"+redirectAttribute);\n            return (String) redirectAttribute;\n        } else if (redirectFormParam != null) {\n            return redirectFormParam;\n        } else {\n            return super.determineTargetUrl(request, response);\n// bug_end\n         }\n     }\n \n", "target": "// fix_start\n    protected void configureDataFormat(DataFormat dataFormat, CamelContext camelContext) {\n        if (mappingFile != null) {\n            setProperty(camelContext, dataFormat, \"mappingFile\", mappingFile);\n        }\n        boolean isValidation = getValidation() == null || getValidation();\n        setProperty(camelContext, dataFormat, \"validation\", isValidation);\n\n        if (encoding != null) {\n            setProperty(camelContext, dataFormat, \"encoding\", encoding);\n        }\n        if (packages != null) {\n            setProperty(camelContext, dataFormat, \"packages\", packages);\n        }\n        if (classes != null) {\n            setProperty(camelContext, dataFormat, \"classes\", classes);\n        }\n        if (whitelistEnabled != null) {\n            setProperty(camelContext, dataFormat, \"whitelistEnabled\", whitelistEnabled);\n        }\n        if (allowedUnmarshallObjects != null) {\n            setProperty(camelContext, dataFormat, \"allowedUnmarshallObjects\", allowedUnmarshallObjects);\n        }\n        if (deniedUnmarshallObjects != null) {\n            setProperty(camelContext, dataFormat, \"deniedUnmarshallObjects\", deniedUnmarshallObjects);\n// fix_end\n", "cwe": "CWE-502", "cwe_name": "Deserialization of Untrusted Data", "idx": 57331}
{"source": " @Override\n// bug_start\n  public void handle(RoutingContext context) {\n    HttpServerRequest request = context.request();\n    if (request.method() != HttpMethod.GET && request.method() != HttpMethod.HEAD) {\n      if (log.isTraceEnabled()) log.trace(\"Not GET or HEAD so ignoring request\");\n      context.next();\n    } else {\n      String path = Utils.removeDots(Utils.urlDecode(context.normalisedPath(), false));\n      if (path == null) {\n        log.warn(\"Invalid path: \" + context.request().path());\n        context.next();\n        return;\n      }\n// bug_end\n \n// bug_start\n      if (!directoryListing && \"/\".equals(path)) {\n        path = indexPage;\n      }\n\n      sendStatic(context, path);\n\n    }\n  }\n\n// bug_end\n", "target": "// fix_start\n    public String determineTargetUrl(HttpServletRequest request, HttpServletResponse response) {\n        Object redirectAttribute = request.getAttribute(URI_OVERRIDE_ATTRIBUTE);\n        String redirectFormParam = request.getParameter(FORM_REDIRECT_PARAMETER);\n        if (redirectAttribute !=null) {\n            logger.debug(\"Returning redirectAttribute saved URI:\"+redirectAttribute);\n            return (String) redirectAttribute;\n        } else if (isApprovedFormRedirectUri(request, redirectFormParam)) {\n            return redirectFormParam;\n        } else {\n            return super.determineTargetUrl(request, response);\n        }\n    }\n// fix_end\n", "cwe": "CWE-601", "cwe_name": "URL Redirection to Untrusted Site ('Open Redirect')", "idx": 65630}
{"source": "// bug_start\npublic void changeApiToken() throws IOException {\n        _changeApiToken();\n        if (user!=null)\n            user.save();\n// bug_end\n     }\n// bug_start\n// bug_end\n \n", "target": "// fix_start\n@Override\n  public void handle(RoutingContext context) {\n    HttpServerRequest request = context.request();\n    if (request.method() != HttpMethod.GET && request.method() != HttpMethod.HEAD) {\n      if (log.isTraceEnabled()) log.trace(\"Not GET or HEAD so ignoring request\");\n      context.next();\n    } else {\n      String path = Utils.urlDecode(context.normalisedPath(), false);\n\n      if (path == null) {\n        log.warn(\"Invalid path: \" + context.request().path());\n        context.next();\n        return;\n      }\n\n      if (File.separatorChar != '/') {\n        path = path.replace(File.separatorChar, '/');\n      }\n      path = Utils.removeDots(path);\n\n      if (!directoryListing && \"/\".equals(path)) {\n        path = indexPage;\n      }\n\n      sendStatic(context, path);\n\n// fix_end\n// fix_start\n  }\n// fix_end\n", "cwe": "CWE-22", "cwe_name": "Path Traversal", "idx": 28751}
{"source": "// bug_start\nprotected void addEmptyValueMapping(DefaultMapper mapper, String field, Object model) {\n\t\tParserContext parserContext = new FluentParserContext().evaluate(model.getClass());\n\t\tExpression target = emptyValueExpressionParser.parseExpression(field, parserContext);\n\t\ttry {\n\t\t\tClass<?> propertyType = target.getValueType(model);\n\t\t\tExpression source = new StaticExpression(getEmptyValue(propertyType));\n\t\t\tDefaultMapping mapping = new DefaultMapping(source, target);\n\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\tlogger.debug(\"Adding empty value mapping for parameter '\" + field + \"'\");\n\t\t\t}\n\t\t\tmapper.addMapping(mapping);\n\t\t} catch (EvaluationException e) {\n\t\t}\n\t}\n// bug_end\n \n", "target": "// fix_start\npublic void changeApiToken() throws IOException {\n        user.checkPermission(Jenkins.ADMINISTER);\n        _changeApiToken();\n        if (user!=null)\n            user.save();\n    }\n// fix_end\n", "cwe": "CWE-17", "cwe_name": "Code", "idx": 2511}
{"source": "// bug_start\nprotected void addEmptyValueMapping(DefaultMapper mapper, String field, Object model) {\n\t\tParserContext parserContext = new FluentParserContext().evaluate(model.getClass());\n\t\tExpression target = expressionParser.parseExpression(field, parserContext);\n\t\ttry {\n\t\t\tClass<?> propertyType = target.getValueType(model);\n\t\t\tExpression source = new StaticExpression(getEmptyValue(propertyType));\n\t\t\tDefaultMapping mapping = new DefaultMapping(source, target);\n\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\tlogger.debug(\"Adding empty value mapping for parameter '\" + field + \"'\");\n\t\t\t}\n\t\t\tmapper.addMapping(mapping);\n\t\t} catch (EvaluationException e) {\n\t\t}\n\t}\n// bug_end\n \n", "target": "// fix_start\n@Exported(inline=true)\n    public synchronized Item[] getItems() {\n        Item[] r = new Item[waitingList.size() + blockedProjects.size() + buildables.size() + pendings.size()];\n        waitingList.toArray(r);\n        int idx = waitingList.size();\n        for (BlockedItem p : blockedProjects.values())\n            r[idx++] = p;\n        for (BuildableItem p : reverse(buildables.values()))\n            r[idx++] = p;\n        for (BuildableItem p : reverse(pendings.values()))\n            r[idx++] = p;\n        return r;\n    }\n// fix_end\n", "cwe": "CWE-1188", "cwe_name": "", "idx": 1325}
{"source": "// bug_start\nprivate static String localeToString(Locale locale) {\n        if (locale != null) {\n            return locale.toString();\n        } else {\n            return \"\";\n// bug_end\n         }\n// bug_start\n// bug_end\n     }\n \n", "target": "// fix_start\n@Exported(inline=true)\n    public synchronized Item[] getItems() {\n        List<Item> r = new ArrayList<Item>();\n\n        for(WaitingItem p : waitingList) {\n            r = filterItemListBasedOnPermissions(r, p);\n// fix_end\n// fix_start\n        for (BlockedItem p : blockedProjects.values()){\n            r = filterItemListBasedOnPermissions(r, p);\n        }\n        for (BuildableItem p : reverse(buildables.values())) {\n            r = filterItemListBasedOnPermissions(r, p);\n        }\n        for (BuildableItem p : reverse(pendings.values())) {\n            r= filterItemListBasedOnPermissions(r, p);\n        }\n        Item[] items = new Item[r.size()];\n        r.toArray(items);\n        return items;\n// fix_end\n", "cwe": "CWE-264", "cwe_name": "Permissions, Privileges, and Access Controls", "idx": 30556}
{"source": "// bug_start\npublic final int doWikiStartTag()\n        throws IOException\n    {\n        WikiEngine engine = m_wikiContext.getEngine();\n        WikiPage   page   = m_wikiContext.getPage();\n\n        if( page != null )\n        {\n            if( page instanceof Attachment )\n            {\n                pageContext.getOut().print( TextUtil.replaceEntities( ((Attachment)page).getFileName() ) );\n            }\n            else\n            {\n                pageContext.getOut().print( engine.beautifyTitle( m_wikiContext.getName() ) );\n            }\n// bug_end\n         }\n// bug_start\n\n        return SKIP_BODY;\n// bug_end\n     }\n \n", "target": "// fix_start\nprivate static String localeToString(Locale locale) {\n        if (locale != null) {\n            return escapeXml(locale.toString());\n        } else {\n            return \"\";\n// fix_end\n// fix_start\n// fix_end\n", "cwe": "CWE-79", "cwe_name": "Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')", "idx": 79326}
{"source": "// bug_start\npublic final int doWikiStartTag()\n        throws IOException\n    {\n        WikiEngine engine = m_wikiContext.getEngine();\n        WikiPage   page   = m_wikiContext.getPage();\n\n        if( page != null )\n        {\n            if( page instanceof Attachment )\n            {\n                pageContext.getOut().print( ((Attachment)page).getFileName() );\n            }\n            else\n            {\n                pageContext.getOut().print( engine.beautifyTitle( m_wikiContext.getName() ) );\n            }\n// bug_end\n         }\n// bug_start\n\n        return SKIP_BODY;\n// bug_end\n     }\n \n", "target": "// fix_start\n@Override\n    protected void configureDataFormat(DataFormat dataFormat, CamelContext camelContext) {\n        if (xmlMapper != null) {\n            String ref = xmlMapper.startsWith(\"#\") ? xmlMapper : \"#\" + xmlMapper;\n            setProperty(camelContext, dataFormat, \"xmlMapper\", ref);\n// fix_end\n// fix_start\n        if (unmarshalType != null) {\n            setProperty(camelContext, dataFormat, \"unmarshalType\", unmarshalType);\n        }\n        if (prettyPrint != null) {\n            setProperty(camelContext, dataFormat, \"prettyPrint\", prettyPrint);\n        }\n        if (jsonView != null) {\n            setProperty(camelContext, dataFormat, \"jsonView\", jsonView);\n        }\n        if (include != null) {\n            setProperty(camelContext, dataFormat, \"include\", include);\n        }\n        if (allowJmsType != null) {\n            setProperty(camelContext, dataFormat, \"allowJmsType\", allowJmsType);\n        }\n        if (collectionType != null) {\n            setProperty(camelContext, dataFormat, \"collectionType\", collectionType);\n        }\n        if (useList != null) {\n            setProperty(camelContext, dataFormat, \"useList\", useList);\n        }\n        if (enableJaxbAnnotationModule != null) {\n            setProperty(camelContext, dataFormat, \"enableJaxbAnnotationModule\", enableJaxbAnnotationModule);\n        }\n        if (moduleClassNames != null) {\n            setProperty(camelContext, dataFormat, \"modulesClassNames\", moduleClassNames);\n        }\n        if (moduleRefs != null) {\n            setProperty(camelContext, dataFormat, \"moduleRefs\", moduleRefs);\n        }\n        if (enableFeatures != null) {\n            setProperty(camelContext, dataFormat, \"enableFeatures\", enableFeatures);\n        }\n        if (disableFeatures != null) {\n            setProperty(camelContext, dataFormat, \"disableFeatures\", disableFeatures);\n        }\n        if (allowUnmarshallType != null) {\n            setProperty(camelContext, dataFormat, \"allowUnmarshallType\", allowUnmarshallType);\n        }\n// fix_end\n", "cwe": "CWE-79", "cwe_name": "Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')", "idx": 79600}
{"source": "// bug_start\n@Override\n    protected void configureDataFormat(DataFormat dataFormat, CamelContext camelContext) {\n        if (xmlMapper != null) {\n            String ref = xmlMapper.startsWith(\"#\") ? xmlMapper : \"#\" + xmlMapper;\n            setProperty(camelContext, dataFormat, \"xmlMapper\", ref);\n        }\n        if (unmarshalType != null) {\n            setProperty(camelContext, dataFormat, \"unmarshalType\", unmarshalType);\n        }\n        if (prettyPrint != null) {\n            setProperty(camelContext, dataFormat, \"prettyPrint\", prettyPrint);\n        }\n        if (jsonView != null) {\n            setProperty(camelContext, dataFormat, \"jsonView\", jsonView);\n        }\n        if (include != null) {\n            setProperty(camelContext, dataFormat, \"include\", include);\n        }\n        if (allowJmsType != null) {\n            setProperty(camelContext, dataFormat, \"allowJmsType\", allowJmsType);\n        }\n        if (collectionType != null) {\n            setProperty(camelContext, dataFormat, \"collectionType\", collectionType);\n        }\n        if (useList != null) {\n            setProperty(camelContext, dataFormat, \"useList\", useList);\n        }\n        if (enableJaxbAnnotationModule != null) {\n            setProperty(camelContext, dataFormat, \"enableJaxbAnnotationModule\", enableJaxbAnnotationModule);\n        }\n        if (moduleClassNames != null) {\n            setProperty(camelContext, dataFormat, \"modulesClassNames\", moduleClassNames);\n        }\n        if (moduleRefs != null) {\n            setProperty(camelContext, dataFormat, \"moduleRefs\", moduleRefs);\n        }\n        if (enableFeatures != null) {\n            setProperty(camelContext, dataFormat, \"enableFeatures\", enableFeatures);\n        }\n        if (disableFeatures != null) {\n            setProperty(camelContext, dataFormat, \"disableFeatures\", disableFeatures);\n        }\n// bug_end\n     }\n \n", "target": "// fix_start\npublic static boolean isSecureZooKeeper(Configuration conf) {\n    try {\n      javax.security.auth.login.Configuration testConfig =\n          javax.security.auth.login.Configuration.getConfiguration();\n      if (testConfig.getAppConfigurationEntry(\"Client\") == null\n          && testConfig.getAppConfigurationEntry(\n            JaasConfiguration.CLIENT_KEYTAB_KERBEROS_CONFIG_NAME) == null\n          && testConfig.getAppConfigurationEntry(\n            JaasConfiguration.SERVER_KEYTAB_KERBEROS_CONFIG_NAME) == null) {\n        return false;\n      }\n    } catch(Exception e) {\n      return false;\n// fix_end\n// fix_start\n    return(\"kerberos\".equalsIgnoreCase(conf.get(\"hbase.security.authentication\")));\n  }\n\n// fix_end\n", "cwe": "CWE-502", "cwe_name": "Deserialization of Untrusted Data", "idx": 57368}
{"source": "// bug_start\npublic static boolean isSecureZooKeeper(Configuration conf) {\n    try {\n      javax.security.auth.login.Configuration testConfig =\n          javax.security.auth.login.Configuration.getConfiguration();\n      if(testConfig.getAppConfigurationEntry(\"Client\") == null) {\n        return false;\n      }\n    } catch(Exception e) {\n      return false;\n// bug_end\n     }\n \n// bug_start\n    return(\"kerberos\".equalsIgnoreCase(conf.get(\"hbase.security.authentication\")) &&\n         conf.get(\"hbase.zookeeper.client.keytab.file\") != null);\n  }\n\n// bug_end\n", "target": "// fix_start\npublic Object read(final InputSource in) throws SAXException,\n                                            IOException {\n        if ( this.docFragment == null ) {\n            DocumentBuilderFactory f;\n            try {\n                f =  DocumentBuilderFactory.newInstance();\n            } catch ( FactoryConfigurationError e ) {\n                try {\n                    f = (DocumentBuilderFactory) Class.forName( \"org.apache.xerces.jaxp.DocumentBuilderFactoryImpl\" ).newInstance();\n                } catch ( Exception e1 ) {\n                    throw new RuntimeException( \"Unable to create new DOM Document\",\n                                                e1 );\n                }\n            } catch ( Exception e ) {\n                throw new RuntimeException( \"Unable to create new DOM Document\",\n                                            e );\n            }\n\n            try {\n                this.document = f.newDocumentBuilder().newDocument();\n            } catch ( Exception e ) {\n                throw new RuntimeException( \"Unable to create new DOM Document\",\n                                            e );\n            }\n            this.docFragment = this.document.createDocumentFragment();\n        }\n\n        SAXParser localParser = null;\n        if ( this.parser == null ) {\n            SAXParserFactory factory = null;\n            try {\n                factory = SAXParserFactory.newInstance();\n            } catch ( FactoryConfigurationError e) {\n                try {\n                    factory = (SAXParserFactory) Class.forName( \"org.apache.xerces.jaxp.SAXParserFactoryImpl\" ).newInstance();\n                } catch ( Exception e1 ) {\n                    throw new RuntimeException( \"Unable to create new DOM Document\",\n                                                e1 );\n                }\n            } catch ( Exception e ) {\n                throw new RuntimeException( \"Unable to create new DOM Document\",\n                                            e );\n            }\n\n            factory.setNamespaceAware( true );\n\n            final String isValidatingString = System.getProperty( \"drools.schema.validating\" );\n            if ( System.getProperty( \"drools.schema.validating\" ) != null ) {\n                this.isValidating = Boolean.getBoolean( \"drools.schema.validating\" );\n            }\n\n            if ( this.isValidating == true ) {\n                factory.setValidating( true );\n                try {\n                    localParser = factory.newSAXParser();\n                } catch ( final ParserConfigurationException e ) {\n                    throw new RuntimeException( e.getMessage() );\n                }\n\n                try {\n                    localParser.setProperty( ExtensibleXmlParser.JAXP_SCHEMA_LANGUAGE,\n                                             ExtensibleXmlParser.W3C_XML_SCHEMA );\n                } catch ( final SAXNotRecognizedException e ) {\n                    boolean hideWarnings = Boolean.getBoolean( \"drools.schema.hidewarnings\" );\n                    if ( !hideWarnings ) {\n                        logger.warn( \"Your SAX parser is not JAXP 1.2 compliant - turning off validation.\" );\n                    }\n                    localParser = null;\n                }\n            }\n\n            if ( localParser == null ) {\n                try {\n                    this.isValidating = false;\n                    factory.setValidating( this.isValidating );\n                    localParser = factory.newSAXParser();\n                } catch ( final ParserConfigurationException e ) {\n                    throw new RuntimeException( e.getMessage() );\n                }\n            }\n        } else {\n            localParser = this.parser;\n        }\n\n        if ( !localParser.isNamespaceAware() ) {\n            throw new RuntimeException( \"parser must be namespace-aware\" );\n        }\n\n        localParser.parse( in,\n                           this );\n\n        return this.data;\n// fix_end\n", "cwe": "CWE-284", "cwe_name": "Improper Access Control", "idx": 36935}
{"source": "// bug_start\npublic <T> T readObject() throws IOException, ClassNotFoundException {\n        ObjectInputStream ois = new ObjectInputStream(in);\n        return (T)ois.readObject();\n// bug_end\n     }\n \n", "target": "// fix_start\npublic Object read(final InputSource in) throws SAXException,\n                                            IOException {\n        if ( this.docFragment == null ) {\n            DocumentBuilderFactory f;\n            try {\n                f =  DocumentBuilderFactory.newInstance();\n            } catch ( FactoryConfigurationError e ) {\n                try {\n                    f = (DocumentBuilderFactory) Class.forName( \"org.apache.xerces.jaxp.DocumentBuilderFactoryImpl\" ).newInstance();\n                } catch ( Exception e1 ) {\n                    throw new RuntimeException( \"Unable to create new DOM Document\",\n                                                e1 );\n                }\n            } catch ( Exception e ) {\n                throw new RuntimeException( \"Unable to create new DOM Document\",\n                                            e );\n            }\n            try {\n                f.setFeature(\"http://xml.org/sax/features/external-general-entities\", false);\n                f.setFeature(\"http://xml.org/sax/features/external-parameter-entities\", false);\n\n            } catch (ParserConfigurationException e) {\n                logger.warn(\"Unable to set parser features due to {}\", e.getMessage());\n            }\n            try {\n                this.document = f.newDocumentBuilder().newDocument();\n            } catch ( Exception e ) {\n                throw new RuntimeException( \"Unable to create new DOM Document\",\n                                            e );\n            }\n            this.docFragment = this.document.createDocumentFragment();\n        }\n\n        SAXParser localParser = null;\n        if ( this.parser == null ) {\n            SAXParserFactory factory = null;\n            try {\n                factory = SAXParserFactory.newInstance();\n            } catch ( FactoryConfigurationError e) {\n                try {\n                    factory = (SAXParserFactory) Class.forName( \"org.apache.xerces.jaxp.SAXParserFactoryImpl\" ).newInstance();\n                } catch ( Exception e1 ) {\n                    throw new RuntimeException( \"Unable to create new DOM Document\",\n                                                e1 );\n                }\n            } catch ( Exception e ) {\n                throw new RuntimeException( \"Unable to create new DOM Document\",\n                                            e );\n            }\n\n            factory.setNamespaceAware( true );\n            try {\n                factory.setFeature(\"http://xml.org/sax/features/external-general-entities\", false);\n                factory.setFeature(\"http://xml.org/sax/features/external-parameter-entities\", false);\n\n            } catch (ParserConfigurationException e) {\n                logger.warn(\"Unable to set parser features due to {}\", e.getMessage());\n            }\n\n            final String isValidatingString = System.getProperty( \"drools.schema.validating\" );\n            if ( System.getProperty( \"drools.schema.validating\" ) != null ) {\n                this.isValidating = Boolean.getBoolean( \"drools.schema.validating\" );\n            }\n\n            if ( this.isValidating == true ) {\n                factory.setValidating( true );\n                try {\n                    localParser = factory.newSAXParser();\n                } catch ( final ParserConfigurationException e ) {\n                    throw new RuntimeException( e.getMessage() );\n                }\n\n                try {\n                    localParser.setProperty( ExtensibleXmlParser.JAXP_SCHEMA_LANGUAGE,\n                                             ExtensibleXmlParser.W3C_XML_SCHEMA );\n                } catch ( final SAXNotRecognizedException e ) {\n                    boolean hideWarnings = Boolean.getBoolean( \"drools.schema.hidewarnings\" );\n                    if ( !hideWarnings ) {\n                        logger.warn( \"Your SAX parser is not JAXP 1.2 compliant - turning off validation.\" );\n                    }\n                    localParser = null;\n                }\n            }\n\n            if ( localParser == null ) {\n                try {\n                    this.isValidating = false;\n                    factory.setValidating( this.isValidating );\n                    localParser = factory.newSAXParser();\n                } catch ( final ParserConfigurationException e ) {\n                    throw new RuntimeException( e.getMessage() );\n                }\n            }\n        } else {\n            localParser = this.parser;\n        }\n\n        if ( !localParser.isNamespaceAware() ) {\n            throw new RuntimeException( \"parser must be namespace-aware\" );\n        }\n\n        localParser.parse( in,\n                           this );\n\n        return this.data;\n// fix_end\n", "cwe": "NVD-CWE-Other", "cwe_name": "Other", "idx": 110774}
{"source": "// bug_start\nprotected String parseFor(final String infoName) throws ParserConfigurationException, SAXException, IOException {\n            SAXParserFactory factory = SAXParserFactory.newInstance();\n            factory.setValidating(false);\n            factory.setNamespaceAware(false);\n            factory.setFeature(\"http://xml.org/sax/features/external-general-entities\", false);\n            factory.setFeature(\"http://apache.org/xml/features/disallow-doctype-decl\", true);\n// bug_end\n \n// bug_start\n            SAXParser saxParser = factory.newSAXParser();\n            ReadInfoHandler riHandler = new ReadInfoHandler(infoName);\n            try {\n                saxParser.parse(this.reportFile, riHandler);\n            } catch (BreakParsingException e) {\n            }\n            return riHandler.getInfo();\n        }\n\n// bug_end\n", "target": "// fix_start\npublic <T> T readObject() throws IOException, ClassNotFoundException {\n        ObjectInputStream ois = new ObjectInputStreamEx(in,\n                getClass().getClassLoader(), ClassFilter.DEFAULT);\n        return (T)ois.readObject();\n    }\n// fix_end\n", "cwe": "CWE-77", "cwe_name": "Improper Neutralization of Special Elements used in a Command ('Command Injection')", "idx": 74879}
{"source": "// bug_start\nprotected String parseFor(final String infoName) throws ParserConfigurationException, SAXException, IOException {\n            SAXParserFactory factory = SAXParserFactory.newInstance();\n            factory.setValidating(false);\n            factory.setNamespaceAware(false);\n// bug_end\n \n// bug_start\n            SAXParser saxParser = factory.newSAXParser();\n            ReadInfoHandler riHandler = new ReadInfoHandler(infoName);\n            try {\n                saxParser.parse(this.reportFile, riHandler);\n            } catch (BreakParsingException e) {\n            }\n            return riHandler.getInfo();\n        }\n\n// bug_end\n", "target": "// fix_start\nstatic Set<String> keysWithVariableValues(Map<String, String> rawConfig, Pattern pattern) {\n        Set<String> keys = new HashSet<>();\n        for (Map.Entry<String, String> config : rawConfig.entrySet()) {\n            if (config.getValue() != null) {\n                Matcher matcher = pattern.matcher(config.getValue());\n                if (matcher.find()) {\n                    keys.add(config.getKey());\n                }\n            }\n        }\n        return keys;\n    }\n// fix_end\n", "cwe": "CWE-611", "cwe_name": "Improper Restriction of XML External Entity Reference ('XXE')", "idx": 69646}
{"source": "// bug_start\nprivate static Set<String> keysWithVariableValues(Map<String, String> rawConfig, Pattern pattern) {\n        Set<String> keys = new HashSet<>();\n        for (Map.Entry<String, String> config : rawConfig.entrySet()) {\n            if (config.getValue() != null) {\n                Matcher matcher = pattern.matcher(config.getValue());\n                if (matcher.matches()) {\n                    keys.add(config.getKey());\n                }\n// bug_end\n             }\n         }\n// bug_start\n        return keys;\n    }\n// bug_end\n \n", "target": "// fix_start\n@Override\n        public String getShortDescription() {\n            if(note != null) {\n                return Messages.Cause_RemoteCause_ShortDescriptionWithNote(addr, note);\n            } else {\n                return Messages.Cause_RemoteCause_ShortDescription(addr);\n// fix_end\n// fix_start\n// fix_end\n", "cwe": "CWE-319", "cwe_name": "", "idx": 41835}
{"source": "// bug_start\npublic static void enableDefaultTyping(ObjectMapper mapper) {\n\t\tif(mapper != null) {\n\t\t\tTypeResolverBuilder<?> typeBuilder = mapper.getDeserializationConfig().getDefaultTyper(null);\n\t\t\tif (typeBuilder == null) {\n\t\t\t\tmapper.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL, JsonTypeInfo.As.PROPERTY);\n\t\t\t}\n\t\t}\n\t}\n// bug_end\n \n", "target": "// fix_start\n@Override\n        public String getShortDescription() {\n            if(note != null) {\n                try {\n                    return Messages.Cause_RemoteCause_ShortDescriptionWithNote(addr, Jenkins.getInstance().getMarkupFormatter().translate(note));\n                } catch (IOException x) {\n                }\n            }\n            return Messages.Cause_RemoteCause_ShortDescription(addr);\n        }\n// fix_end\n", "cwe": "CWE-79", "cwe_name": "Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')", "idx": 77774}
{"source": "// bug_start\nprivate void doEncryptBeforeSign() {\n        try {\n            AbstractTokenWrapper encryptionWrapper = getEncryptionToken();\n            assertTokenWrapper(encryptionWrapper);\n            AbstractToken encryptionToken = encryptionWrapper.getToken();\n            List<WSEncryptionPart> encrParts = getEncryptedParts();\n            List<WSEncryptionPart> sigParts = getSignedParts();\n// bug_end\n \n// bug_start\n            if (encryptionToken != null) {\n                String tokenId = null;\n                SecurityToken tok = null;\n                if (encryptionToken instanceof IssuedToken\n                    || encryptionToken instanceof KerberosToken\n                    || encryptionToken instanceof SecureConversationToken\n                    || encryptionToken instanceof SecurityContextToken\n                    || encryptionToken instanceof SpnegoContextToken) {\n                    tok = getSecurityToken();\n                } else if (encryptionToken instanceof X509Token) {\n                    if (isRequestor()) {\n                        tokenId = setupEncryptedKey(encryptionWrapper, encryptionToken);\n                    } else {\n                        tokenId = getEncryptedKey();\n                    }\n                } else if (encryptionToken instanceof UsernameToken) {\n                    if (isRequestor()) {\n                        tokenId = setupUTDerivedKey((UsernameToken)encryptionToken);\n                    } else {\n                        tokenId = getUTDerivedKey();\n                    }\n                }\n                assertToken(encryptionToken);\n                if (tok == null) {\n                    if (tokenId != null && tokenId.startsWith(\"#\")) {\n                        tokenId = tokenId.substring(1);\n                    }\n\n                    tok = tokenStore.getToken(tokenId);\n                }\n\n                boolean attached = false;\n                if (isTokenRequired(encryptionToken.getIncludeTokenType())) {\n                    Element el = tok.getToken();\n                    this.addEncryptedKeyElement(cloneElement(el));\n                    attached = true;\n                } else if (encryptionToken instanceof X509Token && isRequestor()) {\n                    Element el = tok.getToken();\n                    this.addEncryptedKeyElement(cloneElement(el));\n                    attached = true;\n                }\n\n                WSSecBase encr = doEncryption(encryptionWrapper, tok, attached, encrParts, true);\n\n                handleEncryptedSignedHeaders(encrParts, sigParts);\n\n                if (timestampEl != null) {\n                    WSEncryptionPart timestampPart =\n                        convertToEncryptionPart(timestampEl.getElement());\n                    sigParts.add(timestampPart);\n                }\n\n                addSupportingTokens(sigParts);\n                if (!isRequestor()) {\n                    addSignatureConfirmation(sigParts);\n                }\n\n                if (sigParts.size() > 0) {\n                    signatures.add(this.doSignature(sigParts, encryptionWrapper, encryptionToken,\n                                                    tok, attached));\n                }\n\n                if (isRequestor()) {\n                    this.doEndorse();\n                }\n\n                if (sbinding.isEncryptSignature()\n                    || encryptedTokensList.size() > 0 && isRequestor()) {\n                    List<WSEncryptionPart> secondEncrParts = new ArrayList<WSEncryptionPart>();\n\n                    if (sbinding.isEncryptSignature()) {\n                        if (this.mainSigId != null) {\n                            WSEncryptionPart sigPart =\n                                new WSEncryptionPart(this.mainSigId, \"Element\");\n                            sigPart.setElement(bottomUpElement);\n                            secondEncrParts.add(sigPart);\n                        }\n                        if (sigConfList != null && !sigConfList.isEmpty()) {\n                            secondEncrParts.addAll(sigConfList);\n                        }\n                        assertPolicy(\n                            new QName(sbinding.getName().getNamespaceURI(), SPConstants.ENCRYPT_SIGNATURE));\n                    }\n\n                    if (isRequestor()) {\n                        secondEncrParts.addAll(encryptedTokensList);\n                    }\n\n                    Element secondRefList = null;\n\n                    if (encryptionToken.getDerivedKeys() == DerivedKeys.RequireDerivedKeys\n                        && !secondEncrParts.isEmpty()) {\n                        secondRefList = ((WSSecDKEncrypt)encr).encryptForExternalRef(null,\n                                secondEncrParts);\n                        this.addDerivedKeyElement(secondRefList);\n                    } else if (!secondEncrParts.isEmpty()) {\n                        secondRefList = ((WSSecEncrypt)encr).encryptForRef(null, encrParts);\n                        this.addDerivedKeyElement(secondRefList);\n                    }\n                }\n            }\n        } catch (RuntimeException ex) {\n            LOG.log(Level.FINE, ex.getMessage(), ex);\n            throw ex;\n        } catch (Exception ex) {\n            LOG.log(Level.FINE, ex.getMessage(), ex);\n            throw new Fault(ex);\n        }\n    }\n\n// bug_end\n", "target": "// fix_start\npublic static void enableDefaultTyping(ObjectMapper mapper) {\n\t\tif(mapper != null) {\n\t\t\tTypeResolverBuilder<?> typeBuilder = mapper.getDeserializationConfig().getDefaultTyper(null);\n\t\t\tif (typeBuilder == null) {\n\t\t\t\tmapper.setDefaultTyping(createWhitelistedDefaultTyping());\n\t\t\t}\n\t\t}\n\t}\n// fix_end\n", "cwe": "CWE-502", "cwe_name": "Deserialization of Untrusted Data", "idx": 59035}
{"source": "// bug_start\nprivate static @Nullable User getOrCreate(@Nonnull String id, @Nonnull String fullName, boolean create) {\n        String idkey = idStrategy().keyFor(id);\n// bug_end\n \n// bug_start\n        byNameLock.readLock().lock();\n        User u;\n        try {\n            u = AllUsers.byName().get(idkey);\n        } finally {\n            byNameLock.readLock().unlock();\n        }\n        final File configFile = getConfigFileFor(id);\n        if (u == null && !configFile.isFile() && !configFile.getParentFile().isDirectory()) {\n            File[] legacy = getLegacyConfigFilesFor(id);\n            if (legacy != null && legacy.length > 0) {\n                for (File legacyUserDir : legacy) {\n                    final XmlFile legacyXml = new XmlFile(XSTREAM, new File(legacyUserDir, \"config.xml\"));\n                    try {\n                        Object o = legacyXml.read();\n                        if (o instanceof User) {\n                            if (idStrategy().equals(id, legacyUserDir.getName()) && !idStrategy().filenameOf(legacyUserDir.getName())\n                                    .equals(legacyUserDir.getName())) {\n                                if (!legacyUserDir.renameTo(configFile.getParentFile())) {\n                                    LOGGER.log(Level.WARNING, \"Failed to migrate user record from {0} to {1}\",\n                                            new Object[]{legacyUserDir, configFile.getParentFile()});\n                                }\n                                break;\n                            }\n                        } else {\n                            LOGGER.log(Level.FINE, \"Unexpected object loaded from {0}: {1}\",\n                                    new Object[]{ legacyUserDir, o });\n// bug_end\n                         }\n// bug_start\n                    } catch (IOException e) {\n                        LOGGER.log(Level.FINE, String.format(\"Exception trying to load user from %s: %s\",\n                                new Object[]{ legacyUserDir, e.getMessage() }), e);\n// bug_end\n                     }\n                 }\n             }\n// bug_start\n// bug_end\n         }\n// bug_start\n\n        File unsanitizedLegacyConfigFile = getUnsanitizedLegacyConfigFileFor(id);\n        boolean mustMigrateLegacyConfig = isMigrationRequiredForLegacyConfigFile(unsanitizedLegacyConfigFile, configFile);\n        if (mustMigrateLegacyConfig) {\n            File ancestor = unsanitizedLegacyConfigFile.getParentFile();\n            if (!configFile.exists()) {\n                try {\n                    Files.createDirectory(configFile.getParentFile().toPath());\n                    Files.move(unsanitizedLegacyConfigFile.toPath(), configFile.toPath());\n                } catch (IOException | InvalidPathException e) {\n                    LOGGER.log(\n                            Level.WARNING,\n                            String.format(\"Failed to migrate user record from %s to %s, see SECURITY-499 for more information\", idStrategy().legacyFilenameOf(id), idStrategy().filenameOf(id)),\n                            e);\n                }\n            }\n\n            File tmp = ancestor;\n            try {\n                while (!ancestor.equals(getRootDir())) {\n                    try (DirectoryStream<Path> stream = Files.newDirectoryStream(ancestor.toPath())) {\n                        if (!stream.iterator().hasNext()) {\n                            tmp = ancestor;\n                            ancestor = tmp.getParentFile();\n                            Files.deleteIfExists(tmp.toPath());\n                        } else {\n                            break;\n                        }\n                    }\n                }\n            } catch (IOException | InvalidPathException e) {\n                if (LOGGER.isLoggable(Level.FINE)) {\n                    LOGGER.log(Level.FINE, \"Could not delete \" + tmp + \" when cleaning up legacy user directories\", e);\n                }\n            }\n        }\n\n        if (u==null && (create || configFile.exists())) {\n            User tmp = new User(id, fullName);\n            User prev;\n            byNameLock.readLock().lock();\n            try {\n                prev = AllUsers.byName().putIfAbsent(idkey, u = tmp);\n            } finally {\n                byNameLock.readLock().unlock();\n            }\n            if (prev != null) {\n                u = prev;\n                if (LOGGER.isLoggable(Level.FINE) && !fullName.equals(prev.getFullName())) {\n                    LOGGER.log(Level.FINE, \"mismatch on fullName (\u2018\" + fullName + \"\u2019 vs. \u2018\" + prev.getFullName() + \"\u2019) for \u2018\" + id + \"\u2019\", new Throwable());\n                }\n            } else if (!id.equals(fullName) && !configFile.exists()) {\n                try {\n                    u.save();\n                } catch (IOException x) {\n                    LOGGER.log(Level.WARNING, null, x);\n                }\n            }\n        }\n        return u;\n// bug_end\n     }\n \n", "target": "// fix_start\nprivate void doEncryptBeforeSign() {\n        try {\n            AbstractTokenWrapper encryptionWrapper = getEncryptionToken();\n            assertTokenWrapper(encryptionWrapper);\n            AbstractToken encryptionToken = encryptionWrapper.getToken();\n            List<WSEncryptionPart> encrParts = getEncryptedParts();\n            List<WSEncryptionPart> sigParts = getSignedParts();\n// fix_end\n// fix_start\n            if (encryptionToken != null) {\n                String tokenId = null;\n                SecurityToken tok = null;\n                if (encryptionToken instanceof IssuedToken\n                    || encryptionToken instanceof KerberosToken\n                    || encryptionToken instanceof SecureConversationToken\n                    || encryptionToken instanceof SecurityContextToken\n                    || encryptionToken instanceof SpnegoContextToken) {\n                    tok = getSecurityToken();\n                } else if (encryptionToken instanceof X509Token) {\n                    if (isRequestor()) {\n                        tokenId = setupEncryptedKey(encryptionWrapper, encryptionToken);\n                    } else {\n                        tokenId = getEncryptedKey();\n                    }\n                } else if (encryptionToken instanceof UsernameToken) {\n                    if (isRequestor()) {\n                        tokenId = setupUTDerivedKey((UsernameToken)encryptionToken);\n                    } else {\n                        tokenId = getUTDerivedKey();\n                    }\n                }\n                assertToken(encryptionToken);\n                if (tok == null) {\n                    if (tokenId != null && tokenId.startsWith(\"#\")) {\n                        tokenId = tokenId.substring(1);\n                    }\n\n                    tok = tokenStore.getToken(tokenId);\n                }\n\n                boolean attached = false;\n                if (isTokenRequired(encryptionToken.getIncludeTokenType())) {\n                    Element el = tok.getToken();\n                    this.addEncryptedKeyElement(cloneElement(el));\n                    attached = true;\n                } else if (encryptionToken instanceof X509Token && isRequestor()) {\n                    Element el = tok.getToken();\n                    this.addEncryptedKeyElement(cloneElement(el));\n                    attached = true;\n                }\n\n                WSSecBase encr = doEncryption(encryptionWrapper, tok, attached, encrParts, true);\n\n                handleEncryptedSignedHeaders(encrParts, sigParts);\n\n                if (timestampEl != null) {\n                    WSEncryptionPart timestampPart =\n                        convertToEncryptionPart(timestampEl.getElement());\n                    sigParts.add(timestampPart);\n                }\n\n                addSupportingTokens(sigParts);\n                if (!isRequestor()) {\n                    addSignatureConfirmation(sigParts);\n                }\n\n                if (sigParts.size() > 0) {\n                    signatures.add(this.doSignature(sigParts, encryptionWrapper, encryptionToken,\n                                                    tok, attached));\n                }\n\n                if (isRequestor()) {\n                    this.doEndorse();\n                }\n\n                if (sbinding.isEncryptSignature()\n                    || encryptedTokensList.size() > 0 && isRequestor()) {\n                    List<WSEncryptionPart> secondEncrParts = new ArrayList<WSEncryptionPart>();\n\n                    if (sbinding.isEncryptSignature()) {\n                        if (this.mainSigId != null) {\n                            WSEncryptionPart sigPart =\n                                new WSEncryptionPart(this.mainSigId, \"Element\");\n                            sigPart.setElement(bottomUpElement);\n                            secondEncrParts.add(sigPart);\n// fix_end\n// fix_start\n                        if (sigConfList != null && !sigConfList.isEmpty()) {\n                            secondEncrParts.addAll(sigConfList);\n                        }\n                        assertPolicy(\n                            new QName(sbinding.getName().getNamespaceURI(), SPConstants.ENCRYPT_SIGNATURE));\n                    }\n\n                    if (isRequestor()) {\n                        secondEncrParts.addAll(encryptedTokensList);\n                    }\n\n                    Element secondRefList = null;\n\n                    if (encryptionToken.getDerivedKeys() == DerivedKeys.RequireDerivedKeys\n                        && !secondEncrParts.isEmpty()) {\n                        secondRefList = ((WSSecDKEncrypt)encr).encryptForExternalRef(null,\n                                secondEncrParts);\n                        this.addDerivedKeyElement(secondRefList);\n                    } else if (!secondEncrParts.isEmpty()) {\n                        secondRefList = ((WSSecEncrypt)encr).encryptForRef(null, secondEncrParts);\n                        this.addDerivedKeyElement(secondRefList);\n// fix_end\n// fix_start\n        } catch (RuntimeException ex) {\n            LOG.log(Level.FINE, ex.getMessage(), ex);\n            throw ex;\n        } catch (Exception ex) {\n            LOG.log(Level.FINE, ex.getMessage(), ex);\n            throw new Fault(ex);\n// fix_end\n// fix_start\n// fix_end\n", "cwe": "CWE-310", "cwe_name": "Cryptographic Issues", "idx": 41586}
{"source": "// bug_start\nprivate static @Nullable User getOrCreate(@Nonnull String id, @Nonnull String fullName, boolean create) {\n        String idkey = idStrategy().keyFor(id);\n// bug_end\n \n// bug_start\n        byNameLock.readLock().lock();\n        User u;\n        try {\n            u = AllUsers.byName().get(idkey);\n        } finally {\n            byNameLock.readLock().unlock();\n        }\n        final File configFile = getConfigFileFor(id);\n        if (u == null && !configFile.isFile() && !configFile.getParentFile().isDirectory()) {\n            File[] legacy = getLegacyConfigFilesFor(id);\n            if (legacy != null && legacy.length > 0) {\n                for (File legacyUserDir : legacy) {\n                    final XmlFile legacyXml = new XmlFile(XSTREAM, new File(legacyUserDir, \"config.xml\"));\n                    try {\n                        Object o = legacyXml.read();\n                        if (o instanceof User) {\n                            if (idStrategy().equals(id, legacyUserDir.getName()) && !idStrategy().filenameOf(legacyUserDir.getName())\n                                    .equals(legacyUserDir.getName())) {\n                                if (!legacyUserDir.renameTo(configFile.getParentFile())) {\n                                    LOGGER.log(Level.WARNING, \"Failed to migrate user record from {0} to {1}\",\n                                            new Object[]{legacyUserDir, configFile.getParentFile()});\n                                }\n                                break;\n                            }\n                        } else {\n                            LOGGER.log(Level.FINE, \"Unexpected object loaded from {0}: {1}\",\n                                    new Object[]{ legacyUserDir, o });\n                        }\n                    } catch (IOException e) {\n                        LOGGER.log(Level.FINE, String.format(\"Exception trying to load user from %s: %s\",\n                                new Object[]{ legacyUserDir, e.getMessage() }), e);\n                    }\n                }\n            }\n// bug_end\n         }\n \n// bug_start\n        File unsanitizedLegacyConfigFile = getUnsanitizedLegacyConfigFileFor(id);\n        if (unsanitizedLegacyConfigFile.exists() && !unsanitizedLegacyConfigFile.equals(configFile)) {\n            File ancestor = unsanitizedLegacyConfigFile.getParentFile();\n            if (!configFile.exists()) {\n                try {\n                    Files.createDirectory(configFile.getParentFile().toPath());\n                    Files.move(unsanitizedLegacyConfigFile.toPath(), configFile.toPath());\n                } catch (IOException | InvalidPathException e) {\n                    LOGGER.log(\n                            Level.WARNING,\n                            String.format(\"Failed to migrate user record from %s to %s, see SECURITY-499 for more information\", idStrategy().legacyFilenameOf(id), idStrategy().filenameOf(id)),\n                            e);\n                }\n            }\n// bug_end\n \n// bug_start\n            File tmp = ancestor;\n            try {\n                while (!ancestor.equals(getRootDir())) {\n                    try (DirectoryStream<Path> stream = Files.newDirectoryStream(ancestor.toPath())) {\n                        if (!stream.iterator().hasNext()) {\n                            tmp = ancestor;\n                            ancestor = tmp.getParentFile();\n                            Files.deleteIfExists(tmp.toPath());\n                        } else {\n                            break;\n                        }\n                    }\n                }\n            } catch (IOException | InvalidPathException e) {\n                if (LOGGER.isLoggable(Level.FINE)) {\n                    LOGGER.log(Level.FINE, \"Could not delete \" + tmp + \" when cleaning up legacy user directories\", e);\n                }\n            }\n// bug_end\n         }\n \n// bug_start\n        if (u==null && (create || configFile.exists())) {\n            User tmp = new User(id, fullName);\n            User prev;\n            byNameLock.readLock().lock();\n            try {\n                prev = AllUsers.byName().putIfAbsent(idkey, u = tmp);\n            } finally {\n                byNameLock.readLock().unlock();\n            }\n            if (prev != null) {\n                u = prev;\n                if (LOGGER.isLoggable(Level.FINE) && !fullName.equals(prev.getFullName())) {\n                    LOGGER.log(Level.FINE, \"mismatch on fullName (\u2018\" + fullName + \"\u2019 vs. \u2018\" + prev.getFullName() + \"\u2019) for \u2018\" + id + \"\u2019\", new Throwable());\n                }\n            } else if (!id.equals(fullName) && !configFile.exists()) {\n                try {\n                    u.save();\n                } catch (IOException x) {\n                    LOGGER.log(Level.WARNING, null, x);\n                }\n            }\n// bug_end\n         }\n// bug_start\n        return u;\n// bug_end\n     }\n \n", "target": "// fix_start\npublic static RootPersistentEntity createAclEntity(String entityType, String uuid) {\n        UUID uuidObj = UUID.fromString(uuid);\n        uuid = uuidObj.toString();\n// fix_end\n// fix_start\n        if (CUBE_INSTANCE.equals(entityType)) {\n            CubeInstance cubeInstance = new CubeInstance();\n            cubeInstance.setUuid(uuid);\n\n            return cubeInstance;\n// fix_end\n// fix_start\n        if (DATA_MODEL_DESC.equals(entityType)) {\n            DataModelDesc modelInstance = new DataModelDesc();\n            modelInstance.setUuid(uuid);\n// fix_end\n// fix_start\n            return modelInstance;\n// fix_end\n// fix_start\n        if (JOB_INSTANCE.equals(entityType)) {\n            JobInstance jobInstance = new JobInstance();\n            jobInstance.setUuid(uuid);\n\n            return jobInstance;\n// fix_end\n// fix_start\n\n        if (PROJECT_INSTANCE.equals(entityType)) {\n            ProjectInstance projectInstance = new ProjectInstance();\n            projectInstance.setUuid(uuid);\n\n            return projectInstance;\n        }\n\n        throw new RuntimeException(\"Unsupported entity type!\");\n// fix_end\n", "cwe": "NVD-CWE-noinfo", "cwe_name": "", "idx": 98807}
{"source": "// bug_start\npublic static RootPersistentEntity createAclEntity(String entityType, String uuid) {\n        if (CUBE_INSTANCE.equals(entityType)) {\n            CubeInstance cubeInstance = new CubeInstance();\n            cubeInstance.setUuid(uuid);\n// bug_end\n \n// bug_start\n            return cubeInstance;\n// bug_end\n         }\n// bug_start\n\n        if (DATA_MODEL_DESC.equals(entityType)) {\n            DataModelDesc modelInstance = new DataModelDesc();\n            modelInstance.setUuid(uuid);\n\n            return modelInstance;\n        }\n\n        if (JOB_INSTANCE.equals(entityType)) {\n            JobInstance jobInstance = new JobInstance();\n            jobInstance.setUuid(uuid);\n\n            return jobInstance;\n        }\n\n        if (PROJECT_INSTANCE.equals(entityType)) {\n            ProjectInstance projectInstance = new ProjectInstance();\n            projectInstance.setUuid(uuid);\n\n            return projectInstance;\n        }\n\n        throw new RuntimeException(\"Unsupported entity type!\");\n// bug_end\n     }\n \n", "target": "// fix_start\npublic void renameUser(final String oldName, final String newName) throws Exception {\n        update();\n// fix_end\n// fix_start\n        m_writeLock.lock();\n\n        try {\n            if (m_users.containsKey(oldName)) {\n                final User data = m_users.get(oldName);\n                if (data == null) {\n                    m_users.remove(oldName);\n                    throw new Exception(\"UserFactory:rename the data contained for old user \" + oldName + \" is null\");\n                } else {\n                    if (m_users.containsKey(newName)) {\n                        throw new Exception(\"UserFactory: cannot rename user \" + oldName + \". An user with the given name \" + newName + \" already exists\");\n                    }\n\n                    m_users.remove(oldName);\n                    data.setUserId(newName);\n                    m_users.put(newName, data);\n\n                    m_groupManager.update();\n\n                    m_groupManager.renameUser(oldName, newName);\n\n                }\n            } else {\n                throw new Exception(\"UserFactory:rename the old user name \" + oldName + \" is not found\");\n            }\n\n            _saveCurrent();\n        } finally {\n            m_writeLock.unlock();\n// fix_end\n// fix_start\n// fix_end\n", "cwe": "CWE-89", "cwe_name": "Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection')", "idx": 92491}
{"source": "// bug_start\npublic void renameUser(final String oldName, final String newName) throws Exception {\n        update();\n\n        m_writeLock.lock();\n\n        try {\n            if (m_users.containsKey(oldName)) {\n                final User data = m_users.get(oldName);\n                if (data == null) {\n                    m_users.remove(oldName);\n                    throw new Exception(\"UserFactory:rename the data contained for old user \" + oldName + \" is null\");\n                } else {\n                    m_users.remove(oldName);\n                    data.setUserId(newName);\n                    m_users.put(newName, data);\n\n                    m_groupManager.update();\n\n                    m_groupManager.renameUser(oldName, newName);\n\n                }\n            } else {\n                throw new Exception(\"UserFactory:rename the old user name \" + oldName + \" is not found\");\n// bug_end\n             }\n// bug_start\n\n            _saveCurrent();\n        } finally {\n            m_writeLock.unlock();\n// bug_end\n         }\n// bug_start\n// bug_end\n     }\n \n", "target": "// fix_start\nprivate File createTemporaryFolderIn(File parentFolder) throws IOException {\n        File createdFolder = null;\n        for (int i = 0; i < TEMP_DIR_ATTEMPTS; ++i) {\n            String suffix = \".tmp\";\n            File tmpFile = File.createTempFile(TMP_PREFIX, suffix, parentFolder);\n            String tmpName = tmpFile.toString();\n            String folderName = tmpName.substring(0, tmpName.length() - suffix.length());\n            createdFolder = new File(folderName);\n            if (createdFolder.mkdir()) {\n                tmpFile.delete();\n                return createdFolder;\n// fix_end\n// fix_start\n            tmpFile.delete();\n// fix_end\n// fix_start\n        throw new IOException(\"Unable to create temporary directory in: \"\n            + parentFolder.toString() + \". Tried \" + TEMP_DIR_ATTEMPTS + \" times. \"\n            + \"Last attempted to create: \" + createdFolder.toString());\n// fix_end\n", "cwe": "CWE-352", "cwe_name": "Cross-Site Request Forgery (CSRF)", "idx": 45060}
{"source": "// bug_start\npublic R execute(HttpResponseProcessor<R> responseProcessor) {\n        byte[] bytes = null;\n\n// bug_end\n         try {\n// bug_start\n            for (Map.Entry<String, String> header : this.headers.entrySet()) {\n                this.builder.setHeader(header.getKey(), header.getValue());\n// bug_end\n             }\n// bug_start\n\n            preExecute(this.builder);\n\n            HttpResponse response = this.httpClient.execute(this.builder.build());\n            HttpEntity entity = response.getEntity();\n\n            if (entity != null) {\n                bytes = EntityUtils.toByteArray(entity);\n// bug_end\n             }\n// bug_start\n\n            StatusLine statusLine = response.getStatusLine();\n            int statusCode = statusLine.getStatusCode();\n\n            if (statusCode < 200 || statusCode >= 300) {\n                throw new HttpResponseException(\"Unexpected response from server: \" + statusCode + \" / \" + statusLine.getReasonPhrase(), statusCode, statusLine.getReasonPhrase(), bytes);\n            }\n\n            if (bytes == null) {\n                return null;\n            }\n\n            return responseProcessor.process(bytes);\n        } catch (HttpResponseException e) {\n            throw e;\n// bug_end\n         } catch (Exception e) {\n// bug_start\n            throw new RuntimeException(\"Error executing http method [\" + builder.getMethod() + \"]. Response : \" + String.valueOf(bytes), e);\n// bug_end\n         }\n     }\n \n", "target": "// fix_start\nprivate static File createTemporaryFolderIn(File parentFolder) throws IOException {\n// fix_end\n// fix_start\n            return createTemporaryFolderWithNioApi(parentFolder);\n        } catch (ClassNotFoundException ignore) {\n            return createTemporaryFolderWithFileApi(parentFolder);\n        } catch (InvocationTargetException e) {\n            Throwable cause = e.getCause();\n            if (cause instanceof IOException) {\n                throw (IOException) cause;\n// fix_end\n// fix_start\n            if (cause instanceof RuntimeException) {\n                throw (RuntimeException) cause;\n// fix_end\n// fix_start\n            IOException exception = new IOException(\"Failed to create temporary folder in \" + parentFolder);\n            exception.initCause(cause);\n            throw exception;\n// fix_end\n// fix_start\n            throw new RuntimeException(\"Failed to create temporary folder in \" + parentFolder, e);\n// fix_end\n", "cwe": "CWE-732", "cwe_name": "Incorrect Permission Assignment for Critical Resource", "idx": 72811}
{"source": "// bug_start\npublic R execute(HttpResponseProcessor<R> responseProcessor) {\n        byte[] bytes = null;\n// bug_end\n \n// bug_start\n        try {\n            for (Map.Entry<String, String> header : this.headers.entrySet()) {\n                this.builder.setHeader(header.getKey(), header.getValue());\n            }\n// bug_end\n \n// bug_start\n            preExecute(this.builder);\n// bug_end\n \n// bug_start\n            HttpResponse response = this.httpClient.execute(this.builder.build());\n            HttpEntity entity = response.getEntity();\n\n            if (entity != null) {\n                bytes = EntityUtils.toByteArray(entity);\n            }\n\n            StatusLine statusLine = response.getStatusLine();\n            int statusCode = statusLine.getStatusCode();\n\n            if (statusCode < 200 || statusCode >= 300) {\n                throw new HttpResponseException(\"Unexpected response from server: \" + statusCode + \" / \" + statusLine.getReasonPhrase(), statusCode, statusLine.getReasonPhrase(), bytes);\n            }\n\n            if (bytes == null) {\n                return null;\n            }\n\n            return responseProcessor.process(bytes);\n        } catch (HttpResponseException e) {\n            throw e;\n        } catch (Exception e) {\n            throw new RuntimeException(\"Error executing http method [\" + builder + \"]. Response : \" + String.valueOf(bytes), e);\n        }\n// bug_end\n     }\n \n", "target": "// fix_start\nprotected Configuration createConfiguration(ServletContext servletContext) throws TemplateException {\n        Configuration configuration = new Configuration(Configuration.VERSION_2_3_0);\n// fix_end\n// fix_start\n        configuration.setTemplateExceptionHandler(TemplateExceptionHandler.HTML_DEBUG_HANDLER);\n// fix_end\n// fix_start\n        if (mruMaxStrongSize > 0) {\n            LOG.debug(\"Sets Configuration.CACHE_STORAGE_KEY to strong:{}\", mruMaxStrongSize);\n            configuration.setSetting(Configuration.CACHE_STORAGE_KEY, \"strong:\" + mruMaxStrongSize);\n        }\n        if (templateUpdateDelay != null) {\n            LOG.debug(\"Sets Configuration.TEMPLATE_UPDATE_DELAY_KEY to {}\", templateUpdateDelay);\n            configuration.setSetting(Configuration.TEMPLATE_UPDATE_DELAY_KEY, templateUpdateDelay);\n        }\n        if (encoding != null) {\n            LOG.debug(\"Sets DefaultEncoding to {}\", encoding);\n            configuration.setDefaultEncoding(encoding);\n        }\n        LOG.debug(\"Disabled localized lookups\");\n        configuration.setLocalizedLookup(false);\n        LOG.debug(\"Enabled whitespace stripping\");\n        configuration.setWhitespaceStripping(true);\n        LOG.debug(\"Sets NewBuiltinClassResolver to TemplateClassResolver.SAFER_RESOLVER\");\n        configuration.setNewBuiltinClassResolver(TemplateClassResolver.SAFER_RESOLVER);\n// fix_end\n// fix_start\n        return configuration;\n// fix_end\n", "cwe": "CWE-532", "cwe_name": "Information Exposure Through Log Files", "idx": 63950}
{"source": " protected void extractAttachmentsFromMultipart(Multipart mp, Map<String, Attachment> map)\n         throws MessagingException, IOException {\n \n         for (int i = 0; i < mp.getCount(); i++) {\n             Part part = mp.getBodyPart(i);\n             LOG.trace(\"Part #\" + i + \": \" + part);\n \n             if (part.isMimeType(\"multipart/*\")) {\n                 LOG.trace(\"Part #\" + i + \": is mimetype: multipart/*\");\n                 extractAttachmentsFromMultipart((Multipart) part.getContent(), map);\n             } else {\n                 String disposition = part.getDisposition();\n// bug_start\n                String fileName = part.getFileName();\n// bug_end\n \n                 if (LOG.isTraceEnabled()) {\n                     LOG.trace(\"Part #{}: Disposition: {}\", i, disposition);\n                     LOG.trace(\"Part #{}: Description: {}\", i, part.getDescription());\n                     LOG.trace(\"Part #{}: ContentType: {}\", i, part.getContentType());\n                     LOG.trace(\"Part #{}: FileName: {}\", i, fileName);\n                     LOG.trace(\"Part #{}: Size: {}\", i, part.getSize());\n                     LOG.trace(\"Part #{}: LineCount: {}\", i, part.getLineCount());\n                 }\n \n                 if (validDisposition(disposition, fileName)\n                         || fileName != null) {\n                     LOG.debug(\"Mail contains file attachment: {}\", fileName);\n                     if (!map.containsKey(fileName)) {\n// bug_start\n                        DefaultAttachment camelAttachment = new DefaultAttachment(part.getDataHandler());\n// bug_end\n                         @SuppressWarnings(\"unchecked\")\n                         Enumeration<Header> headers = part.getAllHeaders();\n                         while (headers.hasMoreElements()) {\n                             Header header = headers.nextElement();\n                             camelAttachment.addHeader(header.getName(), header.getValue());\n                         }\n                         map.put(fileName, camelAttachment);\n                     } else {\n                         LOG.warn(\"Cannot extract duplicate file attachment: {}.\", fileName);\n                     }\n                 }\n             }\n         }\n     }\n \n", "target": "// fix_start\n                String fileName = FileUtil.stripPath(part.getFileName());\n// fix_end\n// fix_start\n                        final DataHandler dataHandler = part.getDataHandler();\n                        final DataSource dataSource = dataHandler.getDataSource();\n\n                        final DataHandler replacement = new DataHandler(new DelegatingDataSource(fileName, dataSource));\n                        DefaultAttachment camelAttachment = new DefaultAttachment(replacement);\n// fix_end\n", "cwe": "CWE-22", "cwe_name": "Path Traversal", "idx": 21246}
{"source": " private static void maybeInitJmx()\n     {\n         String jmxPort = System.getProperty(\"com.sun.management.jmxremote.port\");\n \n         if (jmxPort == null)\n         {\n             logger.warn(\"JMX is not enabled to receive remote connections. Please see cassandra-env.sh for more info.\");\n \n             jmxPort = System.getProperty(\"cassandra.jmx.local.port\");\n \n             if (jmxPort == null)\n             {\n                 logger.error(\"cassandra.jmx.local.port missing from cassandra-env.sh, unable to start local JMX service.\" + jmxPort);\n             }\n             else\n             {\n                 System.setProperty(\"java.rmi.server.hostname\", InetAddress.getLoopbackAddress().getHostAddress());\n \n                 try\n                 {\n                     RMIServerSocketFactory serverFactory = new RMIServerSocketFactoryImpl();\n// bug_start\n                    Map<String, ?> env = Collections.singletonMap(RMIConnectorServer.RMI_SERVER_SOCKET_FACTORY_ATTRIBUTE, serverFactory);\n\n// bug_end\n                     Registry registry = new JmxRegistry(Integer.valueOf(jmxPort), null, serverFactory, \"jmxrmi\");\n                     JMXServiceURL url = new JMXServiceURL(String.format(\"service:jmx:rmi://localhost/jndi/rmi://localhost:%s/jmxrmi\", jmxPort));\n                     @SuppressWarnings(\"resource\")\n                     RMIJRMPServerImpl server = new RMIJRMPServerImpl(Integer.valueOf(jmxPort),\n                                                                      null,\n                                                                      (RMIServerSocketFactory) env.get(RMIConnectorServer.RMI_SERVER_SOCKET_FACTORY_ATTRIBUTE),\n                                                                      env);\n                     jmxServer = new RMIConnectorServer(url, env, server, ManagementFactory.getPlatformMBeanServer());\n                     jmxServer.start();\n                     ((JmxRegistry)registry).setRemoteServerStub(server.toStub());\n                 }\n                 catch (IOException e)\n                 {\n                     logger.error(\"Error starting local jmx server: \", e);\n                 }\n             }\n         }\n         else\n         {\n             logger.info(\"JMX is enabled to receive remote connections on port: \" + jmxPort);\n         }\n     }\n \n", "target": "// fix_start\n                    Map<String, Object> env = new HashMap<>();\n                    env.put(RMIConnectorServer.RMI_SERVER_SOCKET_FACTORY_ATTRIBUTE, serverFactory);\n                    env.put(\"jmx.remote.rmi.server.credential.types\",\n                        new String[] { String[].class.getName(), String.class.getName() });\n// fix_end\n", "cwe": "CWE-668", "cwe_name": "Exposure of Resource to Wrong Sphere", "idx": 72440}
{"source": " @Before\n     @Override\n     public void setUp() throws Exception {\n         super.setUp();\n \n         Connector c = getTomcatInstance().getConnector();\n         c.setProperty(\"secretRequired\", \"false\");\n// bug_start\n        c.setProperty(\"allowedArbitraryRequestAttributes\", \"MYATTRIBUTE.*\");\n// bug_end\n     }\n \n", "target": "// fix_start\n        c.setProperty(\"allowedRequestAttributesPattern\", \"MYATTRIBUTE.*\");\n// fix_end\n", "cwe": "NVD-CWE-Other", "cwe_name": "Other", "idx": 115772}
{"source": " @Override\n     public void handle(String target, Request baseRequest, HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException {\n         String path = baseRequest.getPathInfo();\n         int soff = 0, eoff;\n         baseRequest.setHandled(true);\n// bug_start\n\n// bug_end\n         if (path.charAt(0) == '/') soff = 1;\n         eoff = path.indexOf('/', soff);\n         if (soff < 0) {\n             response.sendError(HttpStatus.NOT_FOUND_404);\n             return;\n         }\n         String world = path.substring(soff, eoff);\n         String uri = path.substring(eoff+1);\n         if (world.equals(\"faces\")) {\n             handleFace(response, uri);\n             return;\n         }\n         if (world.equals(\"_markers_\")) {\n             handleMarkers(response, uri);\n             return;\n         }\n \n         DynmapWorld w = null;\n         if (core.mapManager != null) {\n             w = core.mapManager.getWorld(world);\n         }\n         if (w == null) {\n             response.setContentType(\"image/png\");\n             OutputStream os = response.getOutputStream();\n             os.write(blankpng);\n             return;\n         }\n         MapStorage store = w.getMapStorage();\n         MapStorageTile tile = store.getTile(w, uri);\n         if (tile == null) {\n             response.setContentType(\"image/png\");\n             OutputStream os = response.getOutputStream();\n             os.write(blankpng);\n             return;\n         }\n         TileRead tr = null;\n         if (tile.getReadLock(5000)) {\n             tr = tile.read();\n             tile.releaseReadLock();\n         }\n         response.setHeader(\"Cache-Control\", \"max-age=0,must-revalidate\");\n         String etag;\n         if (tr == null) {\n         \tetag = \"\\\"\" + blankpnghash + \"\\\"\";\n         }\n         else {\n         \tetag = \"\\\"\" + tr.hashCode + \"\\\"\";\n         }\n         response.setHeader(\"ETag\", etag);\n         String ifnullmatch = request.getHeader(\"If-None-Match\");\n         if ((ifnullmatch != null) && ifnullmatch.equals(etag)) {\n             response.sendError(HttpStatus.NOT_MODIFIED_304);\n         \treturn;\n         }\n         if (tr == null) {\n             response.setContentType(\"image/png\");\n             response.setIntHeader(\"Content-Length\", blankpng.length);\n             OutputStream os = response.getOutputStream();\n             os.write(blankpng);\n             return;\n         }\n         response.setDateHeader(\"Last-Modified\", tr.lastModified);\n         response.setIntHeader(\"Content-Length\", tr.image.length());\n         if (tr.format == ImageEncoding.PNG) {\n             response.setContentType(\"image/png\");\n         }\n         else {\n             response.setContentType(\"image/jpeg\");\n         }\n         ServletOutputStream out = response.getOutputStream();\n         out.write(tr.image.buffer(), 0, tr.image.length());\n         out.flush();\n \n     }\n \n", "target": "// fix_start\n        if(core.getLoginRequired()\n            && request.getSession(true).getAttribute(LoginServlet.USERID_ATTRIB) == null){\n            response.sendError(HttpStatus.UNAUTHORIZED_401);\n            return;\n        }\n// fix_end\n", "cwe": "CWE-287", "cwe_name": "Improper Authentication", "idx": 38721}
{"source": " private Environment getRemoteEnvironment(RestTemplate restTemplate,\n \t\t\tConfigClientProperties properties, String label, String state) {\n \t\tString path = \"/{name}/{profile}\";\n \t\tString name = properties.getName();\n \t\tString profile = properties.getProfile();\n \t\tString token = properties.getToken();\n \t\tint noOfUrls = properties.getUri().length;\n \t\tif (noOfUrls > 1) {\n \t\t\tlogger.info(\"Multiple Config Server Urls found listed.\");\n \t\t}\n \n \t\tObject[] args = new String[] { name, profile };\n \t\tif (StringUtils.hasText(label)) {\n// bug_start\n\t\t\tif (label.contains(\"/\")) {\n\t\t\t\tlabel = label.replace(\"/\", \"(_)\");\n\t\t\t}\n// bug_end\n \t\t\targs = new String[] { name, profile, label };\n \t\t\tpath = path + \"/{label}\";\n \t\t}\n \t\tResponseEntity<Environment> response = null;\n \n \t\tfor (int i = 0; i < noOfUrls; i++) {\n \t\t\tCredentials credentials = properties.getCredentials(i);\n \t\t\tString uri = credentials.getUri();\n \t\t\tString username = credentials.getUsername();\n \t\t\tString password = credentials.getPassword();\n \n \t\t\tlogger.info(\"Fetching config from server at : \" + uri);\n \n \t\t\ttry {\n \t\t\t\tHttpHeaders headers = new HttpHeaders();\n \t\t\t\theaders.setAccept(\n \t\t\t\t\t\tCollections.singletonList(MediaType.parseMediaType(V2_JSON)));\n \t\t\t\taddAuthorizationToken(properties, headers, username, password);\n \t\t\t\tif (StringUtils.hasText(token)) {\n \t\t\t\t\theaders.add(TOKEN_HEADER, token);\n \t\t\t\t}\n \t\t\t\tif (StringUtils.hasText(state) && properties.isSendState()) {\n \t\t\t\t\theaders.add(STATE_HEADER, state);\n \t\t\t\t}\n \n \t\t\t\tfinal HttpEntity<Void> entity = new HttpEntity<>((Void) null, headers);\n \t\t\t\tresponse = restTemplate.exchange(uri + path, HttpMethod.GET, entity,\n \t\t\t\t\t\tEnvironment.class, args);\n \t\t\t}\n \t\t\tcatch (HttpClientErrorException e) {\n \t\t\t\tif (e.getStatusCode() != HttpStatus.NOT_FOUND) {\n \t\t\t\t\tthrow e;\n \t\t\t\t}\n \t\t\t}\n \t\t\tcatch (ResourceAccessException e) {\n \t\t\t\tlogger.info(\"Connect Timeout Exception on Url - \" + uri\n \t\t\t\t\t\t+ \". Will be trying the next url if available\");\n \t\t\t\tif (i == noOfUrls - 1) {\n \t\t\t\t\tthrow e;\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\tcontinue;\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tif (response == null || response.getStatusCode() != HttpStatus.OK) {\n \t\t\t\treturn null;\n \t\t\t}\n \n \t\t\tEnvironment result = response.getBody();\n \t\t\treturn result;\n \t\t}\n \n \t\treturn null;\n \t}\n \n", "target": "// fix_start\n\t\t\tlabel = Environment.denormalize(label);\n// fix_end\n", "cwe": "CWE-22", "cwe_name": "Path Traversal", "idx": 26301}
{"source": " @Override\n     public ScmServerEndpoint create(JSONObject request) {\n// bug_start\n        List<ErrorMessage.Error> errors = Lists.newLinkedList();\n// bug_end\n \n         final String name = (String) request.get(ScmServerEndpoint.NAME);\n         if(StringUtils.isBlank(name)){\n             errors.add(new ErrorMessage.Error(ScmServerEndpoint.NAME, ErrorMessage.Error.ErrorCodes.MISSING.toString(), ScmServerEndpoint.NAME + \" is required\"));\n         }\n \n         String url = (String) request.get(ScmServerEndpoint.API_URL);\n         final BitbucketEndpointConfiguration endpointConfiguration = BitbucketEndpointConfiguration.get();\n         if(StringUtils.isBlank(url)){\n             errors.add(new ErrorMessage.Error(ScmServerEndpoint.API_URL, ErrorMessage.Error.ErrorCodes.MISSING.toString(), ScmServerEndpoint.API_URL + \" is required\"));\n         }else {\n             try {\n                 String version = BitbucketServerApi.getVersion(url);\n                 if (!BitbucketServerApi.isSupportedVersion(version)) {\n                     errors.add(new ErrorMessage.Error(BitbucketServerEndpoint.API_URL, ErrorMessage.Error.ErrorCodes.INVALID.toString(),\n                             Messages.bbserver_version_validation_error(\n                                     version, BitbucketServerApi.MINIMUM_SUPPORTED_VERSION)));\n                 } else {\n                     url = BitbucketEndpointConfiguration.normalizeServerUrl(url);\n                     for (AbstractBitbucketEndpoint endpoint : endpointConfiguration.getEndpoints()) {\n                         if (url.equals(endpoint.getServerUrl())) {\n                             errors.add(new ErrorMessage.Error(ScmServerEndpoint.API_URL, ErrorMessage.Error.ErrorCodes.ALREADY_EXISTS.toString(), ScmServerEndpoint.API_URL + \" already exists\"));\n                             break;\n                         }\n                     }\n                 }\n             } catch (ServiceException e) {\n                 errors.add(new ErrorMessage.Error(BitbucketServerEndpoint.API_URL, ErrorMessage.Error.ErrorCodes.INVALID.toString(), StringUtils.isBlank(e.getMessage()) ? \"Invalid URL\" : e.getMessage()));\n             }\n         }\n \n         if(!errors.isEmpty()){\n             throw new ServiceException.BadRequestException(new ErrorMessage(400, \"Failed to create Bitbucket server endpoint\").addAll(errors));\n         }\n         final com.cloudbees.jenkins.plugins.bitbucket.endpoints.BitbucketServerEndpoint endpoint = new com.cloudbees.jenkins.plugins.bitbucket.endpoints.BitbucketServerEndpoint(name, url, false, null);\n         SecurityContext old=null;\n         try {\n             old = ACL.impersonate(ACL.SYSTEM);\n             endpointConfiguration.addEndpoint(endpoint);\n         }finally {\n             if(old != null){\n                 SecurityContextHolder.setContext(old);\n             }\n         }\n         return new BitbucketServerEndpoint(endpoint, this);\n     }\n \n", "target": "// fix_start\n\n        try {\n            Jenkins.get().checkPermission(Item.CREATE);\n        } catch (Exception e) {\n            throw new ServiceException.ForbiddenException(\"User does not have permission to create repository\", e);\n        }\n\n        List<ErrorMessage.Error> errors = new LinkedList<>();\n// fix_end\n", "cwe": "CWE-862", "cwe_name": "Missing Authorization", "idx": 83830}
{"source": " private void registerMessageListener() {\n \t\tif (mPacketListener != null)\n \t\t\tmXMPPConnection.removePacketListener(mPacketListener);\n \n \t\tPacketTypeFilter filter = new PacketTypeFilter(Message.class);\n \n \t\tmPacketListener = new PacketListener() {\n \t\t\tpublic void processPacket(Packet packet) {\n \t\t\t\ttry {\n \t\t\t\tif (packet instanceof Message) {\n \t\t\t\t\tMessage msg = (Message) packet;\n \n \t\t\t\t\tString[] fromJID = getJabberID(msg.getFrom());\n \n \t\t\t\t\tint direction = ChatConstants.INCOMING;\n \t\t\t\t\tCarbon cc = CarbonManager.getCarbon(msg);\n// bug_start\n// bug_end\n \n \t\t\t\t\tlong ts;\n \t\t\t\t\tDelayInfo timestamp = (DelayInfo)msg.getExtension(\"delay\", \"urn:xmpp:delay\");\n \t\t\t\t\tif (timestamp == null)\n \t\t\t\t\t\ttimestamp = (DelayInfo)msg.getExtension(\"x\", \"jabber:x:delay\");\n \t\t\t\t\tif (cc != null)\n \t\t\t\t\t\ttimestamp = cc.getForwarded().getDelayInfo();\n \t\t\t\t\tif (timestamp != null)\n \t\t\t\t\t\tts = timestamp.getStamp().getTime();\n \t\t\t\t\telse\n \t\t\t\t\t\tts = System.currentTimeMillis();\n \n \t\t\t\t\tif (cc != null) {\n \t\t\t\t\t\tLog.d(TAG, \"carbon: \" + cc.toXML());\n \t\t\t\t\t\tmsg = (Message)cc.getForwarded().getForwardedPacket();\n \n \t\t\t\t\t\tif (cc.getDirection() == Carbon.Direction.sent) {\n \t\t\t\t\t\t\tfromJID = getJabberID(msg.getTo());\n \t\t\t\t\t\t\tdirection = ChatConstants.OUTGOING;\n \t\t\t\t\t\t} else {\n \t\t\t\t\t\t\tfromJID = getJabberID(msg.getFrom());\n \n \t\t\t\t\t\t\tDeliveryReceipt dr = (DeliveryReceipt)msg.getExtension(\n \t\t\t\t\t\t\t\t\tDeliveryReceipt.ELEMENT, DeliveryReceipt.NAMESPACE);\n \t\t\t\t\t\t\tif (dr != null) {\n \t\t\t\t\t\t\t\tLog.d(TAG, \"got CC'ed delivery receipt for \" + dr.getId());\n \t\t\t\t\t\t\t\tchangeMessageDeliveryStatus(dr.getId(), ChatConstants.DS_ACKED);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}\n \n \t\t\t\t\t\tif (msg.getBody() != null && msg.getBody().startsWith(\"?OTR\")) {\n \t\t\t\t\t\t\tLog.i(TAG, \"Ignoring OTR carbon from \" + msg.getFrom() + \" to \" + msg.getTo());\n \t\t\t\t\t\t\treturn;\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \n \t\t\t\t\tif(direction == ChatConstants.INCOMING && handleMucInvitation(msg)) {\n \t\t\t\t\t\tsendReceiptIfRequested(packet);\n \t\t\t\t\t\treturn;\n \t\t\t\t\t}\n \n \t\t\t\t\tString chatMessage = msg.getBody();\n \n \t\t\t\t\tif (msg.getType() == Message.Type.error) {\n \t\t\t\t\t\tif (changeMessageDeliveryStatus(msg.getPacketID(), ChatConstants.DS_FAILED))\n \t\t\t\t\t\t\tmServiceCallBack.notifyMessage(fromJID, msg.getError().toString(), (cc != null), Message.Type.error);\n \t\t\t\t\t\telse if (mucJIDs.contains(msg.getFrom())) {\n \t\t\t\t\t\t\thandleKickedFromMUC(msg.getFrom(), false, null,\n \t\t\t\t\t\t\t\t\tmsg.getError().toString());\n \t\t\t\t\t\t}\n \t\t\t\t\t\treturn;\n \t\t\t\t\t}\n \n \t\t\t\t\tif (chatMessage == null) {\n \t\t\t\t\t\tif (msg.getSubject() != null && msg.getType() == Message.Type.groupchat\n \t\t\t\t\t\t\t\t&& mucJIDs.contains(fromJID[0])) {\n \t\t\t\t\t\t\tContentValues cvR = new ContentValues();\n \t\t\t\t\t\t\tcvR.put(RosterProvider.RosterConstants.STATUS_MESSAGE, msg.getSubject());\n \t\t\t\t\t\t\tcvR.put(RosterProvider.RosterConstants.STATUS_MODE, StatusMode.available.ordinal());\n \t\t\t\t\t\t\tLog.d(TAG, \"MUC subject for \" + fromJID[0] + \" set to: \" + msg.getSubject());\n \t\t\t\t\t\t\tupsertRoster(cvR, fromJID[0]);\n \t\t\t\t\t\t\treturn;\n \t\t\t\t\t\t}\n \t\t\t\t\t\tLog.d(TAG, \"empty message.\");\n \t\t\t\t\t\treturn;\n \t\t\t\t\t}\n \n \t\t\t\t\tReplace replace = (Replace)msg.getExtension(Replace.NAMESPACE);\n \t\t\t\t\tString replace_id = (replace != null) ? replace.getId() : null;\n \n \t\t\t\t\tint is_new = (cc == null) ? ChatConstants.DS_NEW : ChatConstants.DS_SENT_OR_READ;\n \t\t\t\t\tif (msg.getType() == Message.Type.error)\n \t\t\t\t\t\tis_new = ChatConstants.DS_FAILED;\n \n \t\t\t\t\tboolean is_muc = (msg.getType() == Message.Type.groupchat);\n \t\t\t\t\tboolean is_from_me = (direction == ChatConstants.OUTGOING) ||\n \t\t\t\t\t\t(is_muc && fromJID[1].equals(getMyMucNick(fromJID[0])));\n \n \t\t\t\t\tMUCUser muc_x = (MUCUser)msg.getExtension(\"x\", \"http://jabber.org/protocol/muc#user\");\n \t\t\t\t\tboolean is_muc_pm = !is_muc  && !TextUtils.isEmpty(fromJID[1]) &&\n \t\t\t\t\t\t\t(muc_x != null || mucJIDs.contains(fromJID[0]));\n \n \t\t\t\t\tif (is_muc_pm && !is_from_me && cc != null)\n \t\t\t\t\t\treturn;\n \n \t\t\t\t\tif (is_muc_pm) {\n \t\t\t\t\t\tfromJID[0] = fromJID[0] + \"/\" + fromJID[1];\n \t\t\t\t\t\tfromJID[1] = null;\n \t\t\t\t\t\tLog.d(TAG, \"MUC-PM: \" + fromJID[0] + \" d=\" + direction + \" fromme=\" + is_from_me);\n \t\t\t\t\t}\n \n \t\t\t\t\tboolean is_silent = (cc != null) || (is_muc && timestamp != null);\n \n \t\t\t\t\tif (!is_muc || checkAddMucMessage(msg, msg.getPacketID(), fromJID, timestamp)) {\n \t\t\t\t\t\taddChatMessageToDB(direction, fromJID, chatMessage, is_new, ts, msg.getPacketID(), replace_id);\n \t\t\t\t\t\tboolean need_notify = !is_muc || mConfig.needMucNotification(getMyMucNick(fromJID[0]), chatMessage);\n \t\t\t\t\t\tif (is_from_me) {\n \t\t\t\t\t\t\tmServiceCallBack.notifyMessage(fromJID, null, true, msg.getType());\n \t\t\t\t\t\t\tChatHelper.markAsRead(mService, fromJID[0]);\n \t\t\t\t\t\t} else if (direction == ChatConstants.INCOMING && need_notify)\n \t\t\t\t\t\t\tmServiceCallBack.notifyMessage(fromJID, chatMessage, is_silent, msg.getType());\n \t\t\t\t\t}\n \t\t\t\t\tsendReceiptIfRequested(packet);\n \t\t\t\t}\n \t\t\t\t} catch (Exception e) {\n \t\t\t\t\tLog.e(TAG, \"failed to process packet:\");\n \t\t\t\t\te.printStackTrace();\n \t\t\t\t}\n \t\t\t}\n \t\t};\n \n \t\tmXMPPConnection.addPacketListener(mPacketListener, filter);\n \t}\n \n", "target": "// fix_start\n\t\t\t\t\tif (cc != null && !msg.getFrom().equalsIgnoreCase(mConfig.jabberID)) {\n\t\t\t\t\t\tLog.w(TAG, \"Received illegal carbon from \" + msg.getFrom() + \": \" + cc.toXML());\n\t\t\t\t\t\tcc = null;\n\t\t\t\t\t}\n// fix_end\n", "cwe": "CWE-20", "cwe_name": "Improper Input Validation", "idx": 11523}
{"source": " public static void unJar(File jarFile, File toDir, Pattern unpackRegex)\n       throws IOException {\n     try (JarFile jar = new JarFile(jarFile)) {\n       int numOfFailedLastModifiedSet = 0;\n// bug_start\n// bug_end\n       Enumeration<JarEntry> entries = jar.entries();\n       while (entries.hasMoreElements()) {\n         final JarEntry entry = entries.nextElement();\n         if (!entry.isDirectory() &&\n             unpackRegex.matcher(entry.getName()).matches()) {\n           try (InputStream in = jar.getInputStream(entry)) {\n             File file = new File(toDir, entry.getName());\n             ensureDirectory(file.getParentFile());\n// bug_start\n// bug_end\n             try (OutputStream out = new FileOutputStream(file)) {\n               IOUtils.copyBytes(in, out, BUFFER_SIZE);\n             }\n             if (!file.setLastModified(entry.getTime())) {\n               numOfFailedLastModifiedSet++;\n             }\n           }\n         }\n       }\n       if (numOfFailedLastModifiedSet > 0) {\n         LOG.warn(\"Could not set last modfied time for {} file(s)\",\n             numOfFailedLastModifiedSet);\n       }\n     }\n   }\n \n", "target": "// fix_start\n      String targetDirPath = toDir.getCanonicalPath() + File.separator;\n// fix_end\n// fix_start\n            if (!file.getCanonicalPath().startsWith(targetDirPath)) {\n              throw new IOException(\"expanding \" + entry.getName()\n                  + \" would create file outside of \" + toDir);\n            }\n// fix_end\n", "cwe": "CWE-22", "cwe_name": "Path Traversal", "idx": 22163}
{"source": " private ResetPasswordResponse changePasswordCodeAuthenticated(String code, String newPassword) {\n         ExpiringCode expiringCode = expiringCodeStore.retrieveCode(code);\n         if (expiringCode == null) {\n             throw new InvalidCodeException(\"invalid_code\", \"Sorry, your reset password link is no longer valid. Please request a new one\", 422);\n         }\n         String userId;\n// bug_start\n        String userName = null;\n        Date passwordLastModified = null;\n        String clientId = null;\n        String redirectUri = null;\n// bug_end\n         try {\n// bug_start\n            PasswordChange change = JsonUtils.readValue(expiringCode.getData(), PasswordChange.class);\n            userId = change.getUserId();\n            userName = change.getUsername();\n            passwordLastModified = change.getPasswordModifiedTime();\n            clientId = change.getClientId();\n            redirectUri = change.getRedirectUri();\n// bug_end\n         } catch (JsonUtils.JsonUtilException x) {\n// bug_start\n            userId = expiringCode.getData();\n// bug_end\n         }\n// bug_start\n// bug_end\n         ScimUser user = scimUserProvisioning.retrieve(userId);\n         try {\n             if (isUserModified(user, expiringCode.getExpiresAt(), userName, passwordLastModified)) {\n                 throw new UaaException(\"Invalid password reset request.\");\n             }\n             if (!user.isVerified()) {\n                 scimUserProvisioning.verifyUser(userId, -1);\n             }\n             if (scimUserProvisioning.checkPasswordMatches(userId, newPassword)) {\n                 throw new InvalidPasswordException(\"Your new password cannot be the same as the old password.\", UNPROCESSABLE_ENTITY);\n             }\n             scimUserProvisioning.changePassword(userId, null, newPassword);\n             publish(new PasswordChangeEvent(\"Password changed\", getUaaUser(user), SecurityContextHolder.getContext().getAuthentication()));\n \n             String redirectLocation = \"home\";\n             if (!isEmpty(clientId) && !isEmpty(redirectUri)) {\n                 try {\n                     ClientDetails clientDetails = clientDetailsService.loadClientByClientId(clientId);\n                     Set<String> redirectUris = clientDetails.getRegisteredRedirectUri() == null ? Collections.emptySet() :\n                         clientDetails.getRegisteredRedirectUri();\n                     String matchingRedirectUri = UaaUrlUtils.findMatchingRedirectUri(redirectUris, redirectUri, null);\n                     if (matchingRedirectUri != null) {\n                         redirectLocation = matchingRedirectUri;\n                     }\n                 } catch (NoSuchClientException nsce) {}\n             }\n             return new ResetPasswordResponse(user, redirectLocation, clientId);\n         } catch (Exception e) {\n             publish(new PasswordChangeFailureEvent(e.getMessage(), getUaaUser(user), SecurityContextHolder.getContext().getAuthentication()));\n             throw e;\n         }\n     }\n \n", "target": "// fix_start\n        String userName;\n        Date passwordLastModified;\n        String clientId;\n        String redirectUri;\n        PasswordChange change;\n// fix_end\n// fix_start\n            change = JsonUtils.readValue(expiringCode.getData(), PasswordChange.class);\n// fix_end\n// fix_start\n            throw new InvalidCodeException(\"invalid_code\", \"Sorry, your reset password link is no longer valid. Please request a new one\", 422);\n// fix_end\n// fix_start\n        userId = change.getUserId();\n        userName = change.getUsername();\n        passwordLastModified = change.getPasswordModifiedTime();\n        clientId = change.getClientId();\n        redirectUri = change.getRedirectUri();\n\n// fix_end\n", "cwe": "CWE-264", "cwe_name": "Permissions, Privileges, and Access Controls", "idx": 33899}
{"source": " private static String getIdFromToken(Element token) {\n         if (token != null) {\n// bug_start\n            if (token.hasAttributeNS(WSConstants.WSU_NS, \"Id\")) {\n                return token.getAttributeNS(WSConstants.WSU_NS, \"Id\");\n            } else if (token.hasAttributeNS(null, \"ID\")) {\n// bug_end\n                 return token.getAttributeNS(null, \"ID\");\n// bug_start\n            } else if (token.hasAttributeNS(null, \"AssertionID\")) {\n// bug_end\n                 return token.getAttributeNS(null, \"AssertionID\");\n// bug_start\n// bug_end\n             }\n         }\n         return \"\";\n     }\n \n", "target": "// fix_start\n            if (\"Assertion\".equals(token.getLocalName())\n                && WSConstants.SAML2_NS.equals(token.getNamespaceURI())) {\n// fix_end\n// fix_start\n            } else if (\"Assertion\".equals(token.getLocalName())\n                && WSConstants.SAML_NS.equals(token.getNamespaceURI())) {\n// fix_end\n// fix_start\n            }\n\n            if (WSConstants.USERNAME_TOKEN_LN.equals(token.getLocalName())\n                && WSConstants.WSSE_NS.equals(token.getNamespaceURI())) {\n                Element usernameElement =\n                    XMLUtils.getDirectChildElement(token, WSConstants.USERNAME_LN, WSConstants.WSSE_NS);\n                if (usernameElement != null) {\n                    return XMLUtils.getElementText(usernameElement);\n                }\n            }\n\n            if (WSConstants.BINARY_TOKEN_LN.equals(token.getLocalName())\n                && WSConstants.WSSE_NS.equals(token.getNamespaceURI())) {\n                String text = XMLUtils.getElementText(token);\n                if (text != null && !\"\".equals(text)) {\n                    try {\n                        MessageDigest digest = MessageDigest.getInstance(\"SHA-256\");\n                        byte[] bytes = digest.digest(text.getBytes());\n                        return Base64.getMimeEncoder().encodeToString(bytes);\n                    } catch (NoSuchAlgorithmException e) {\n                    }\n                }\n// fix_end\n", "cwe": "CWE-384", "cwe_name": "", "idx": 50587}
{"source": " private static boolean validateGlobalResourceAccess(String globalName) {\n         ClassLoader cl = Thread.currentThread().getContextClassLoader();\n// bug_start\n        Map<String,String> registrations = globalResourceRegistrations.get(cl);\n        if (registrations != null && registrations.containsValue(globalName)) {\n            return true;\n// bug_end\n         }\n         return false;\n     }\n \n", "target": "// fix_start\n        while (cl != null) {\n            Map<String,String> registrations = globalResourceRegistrations.get(cl);\n            if (registrations != null && registrations.containsValue(globalName)) {\n                return true;\n            }\n            cl = cl.getParent();\n// fix_end\n", "cwe": "NVD-CWE-noinfo", "cwe_name": "", "idx": 100637}
{"source": " public void validateSubType(DeserializationContext ctxt, JavaType type) throws JsonMappingException\n     {\n         final Class<?> raw = type.getRawClass();\n         String full = raw.getName();\n \n         main_check:\n         do {\n             if (_cfgIllegalClassNames.contains(full)) {\n                 break;\n             }\n \n// bug_start\n            if (!raw.isInterface() && full.startsWith(PREFIX_STRING)) {\n// bug_end\n                 for (Class<?> cls = raw; (cls != null) && (cls != Object.class); cls = cls.getSuperclass()){\n                     String name = cls.getSimpleName();\n                     if (\"AbstractPointcutAdvisor\".equals(name)\n                             || \"AbstractApplicationContext\".equals(name)) {\n                         break main_check;\n                     }\n// bug_start\n// bug_end\n                 }\n             }\n             return;\n         } while (false);\n \n         throw JsonMappingException.from(ctxt,\n                 String.format(\"Illegal type (%s) to deserialize: prevented for security reasons\", full));\n     }\n \n", "target": "// fix_start\n            if (raw.isInterface()) {\n                ;\n            } else if (full.startsWith(PREFIX_SPRING)) {\n// fix_end\n// fix_start\n                }\n            } else if (full.startsWith(PREFIX_C3P0)) {\n                if (full.endsWith(\"DataSource\")) {\n                    break main_check;\n// fix_end\n", "cwe": "CWE-184", "cwe_name": "", "idx": 2554}
{"source": " private boolean instanceMethodParametersResolveToSameTypes(Method subTypeMethod, Method superTypeMethod) {\n \t\tif ( subTypeMethod.getParameterTypes().length == 0 ) {\n \t\t\treturn true;\n \t\t}\n \n \t\tResolvedType resolvedSubType = typeResolver.resolve( subTypeMethod.getDeclaringClass() );\n \n \t\tMemberResolver memberResolver = new MemberResolver( typeResolver );\n \t\tmemberResolver.setMethodFilter( new SimpleMethodFilter( subTypeMethod, superTypeMethod ) );\n \t\tResolvedTypeWithMembers typeWithMembers = memberResolver.resolve(\n \t\t\t\tresolvedSubType,\n \t\t\t\tnull,\n \t\t\t\tnull\n \t\t);\n \n// bug_start\n\t\tResolvedMethod[] resolvedMethods = typeWithMembers.getMemberMethods();\n// bug_end\n \n \t\tif ( resolvedMethods.length == 1 ) {\n \t\t\treturn true;\n \t\t}\n \n \t\tfor ( int i = 0; i < resolvedMethods[0].getArgumentCount(); i++ ) {\n \n \t\t\tif ( !resolvedMethods[0].getArgumentType( i )\n \t\t\t\t\t.equals( resolvedMethods[1].getArgumentType( i ) ) ) {\n \t\t\t\treturn false;\n \t\t\t}\n \t\t}\n \n \t\treturn true;\n \t}\n \n", "target": "// fix_start\n\t\tResolvedMethod[] resolvedMethods = run( GetResolvedMemberMethods.action( typeWithMembers ) );\n// fix_end\n", "cwe": "CWE-264", "cwe_name": "Permissions, Privileges, and Access Controls", "idx": 30741}
{"source": " @Override\n   public void Authenticate(String user, String password) throws AuthenticationException {\n \n     Hashtable<String, Object> env = new Hashtable<String, Object>();\n     env.put(Context.INITIAL_CONTEXT_FACTORY, \"com.sun.jndi.ldap.LdapCtxFactory\");\n     env.put(Context.PROVIDER_URL, ldapURL);\n \n     if (!hasDomain(user) && ldapDomain != null) {\n       user  = user + \"@\" + ldapDomain;\n// bug_start\n// bug_end\n     }\n \n     String bindDN;\n     if (baseDN == null) {\n       bindDN = user;\n     } else {\n       bindDN = \"uid=\" + user + \",\" + baseDN;\n     }\n     env.put(Context.SECURITY_AUTHENTICATION, \"simple\");\n     env.put(Context.SECURITY_PRINCIPAL, bindDN);\n     env.put(Context.SECURITY_CREDENTIALS, password);\n \n     try {\n       Context ctx = new InitialDirContext(env);\n       ctx.close();\n     } catch (NamingException e) {\n       throw new AuthenticationException(\"Error validating LDAP user\", e);\n     }\n   }\n \n", "target": "// fix_start\n    }\n\n    if (password == null || password.isEmpty()) {\n      throw new AuthenticationException(\"Error validating LDAP user:\" +\n          \" a null or blank password has been provided\");\n// fix_end\n", "cwe": "CWE-287", "cwe_name": "Improper Authentication", "idx": 39188}
{"source": " public boolean matches(String pattern, String source) {\n         if (pattern == null) {\n             throw new IllegalArgumentException(\"pattern argument cannot be null.\");\n         }\n// bug_start\n        Pattern p = Pattern.compile(pattern);\n// bug_end\n         Matcher m = p.matcher(source);\n         return m.matches();\n     }\n \n", "target": "// fix_start\n        Pattern p = Pattern.compile(pattern, caseInsensitive ? CASE_INSENSITIVE : DEFAULT);\n// fix_end\n", "cwe": "CWE-863", "cwe_name": "Incorrect Authorization", "idx": 86552}
{"source": "// bug_start\npublic FormValidation doCheckUrl(@QueryParameter String value) {\n// bug_end\n             try {\n                 URLConnection conn = ProxyConfiguration.open(new URL(value));\n                 conn.connect();\n                 if (conn instanceof HttpURLConnection) {\n                     if (((HttpURLConnection) conn).getResponseCode() != HttpURLConnection.HTTP_OK) {\n                         return FormValidation.error(Messages.ZipExtractionInstaller_bad_connection());\n                     }\n                 }\n                 return FormValidation.ok();\n             } catch (MalformedURLException x) {\n                 return FormValidation.error(Messages.ZipExtractionInstaller_malformed_url());\n             } catch (IOException x) {\n                 return FormValidation.error(x,Messages.ZipExtractionInstaller_could_not_connect());\n             }\n         }\n \n", "target": "// fix_start\n@RequirePOST\n        public FormValidation doCheckUrl(@QueryParameter String value) {\n            Jenkins.getInstance().checkPermission(Jenkins.ADMINISTER);\n\n// fix_end\n", "cwe": "CWE-352", "cwe_name": "Cross-Site Request Forgery (CSRF)", "idx": 44414}
{"source": "// bug_start\npublic void doDisable(StaplerRequest req, StaplerResponse rsp) throws IOException {\n        Jenkins.getInstance().checkPermission(Jenkins.ADMINISTER);\n// bug_end\n         disable(true);\n         rsp.sendRedirect2(req.getContextPath()+\"/manage\");\n     }\n \n", "target": "// fix_start\n@RequirePOST\n    public void doDisable(StaplerRequest req, StaplerResponse rsp) throws IOException {\n// fix_end\n", "cwe": "CWE-287", "cwe_name": "Improper Authentication", "idx": 38604}
{"source": " public Object getBody() throws JMSException {\n         Message message = getMessage();\n         if (message instanceof TextMessage) {\n             return ((TextMessage) message).getText();\n         }\n         if (message instanceof ObjectMessage) {\n             try {\n                 return ((ObjectMessage) message).getObject();\n// bug_start\n            } catch (JMSException e) {\n                return e;\n// bug_end\n             }\n         }\n         if (message instanceof MapMessage) {\n             return createMapBody((MapMessage) message);\n         }\n         if (message instanceof BytesMessage) {\n             BytesMessage msg = (BytesMessage) message;\n             int len = (int) msg.getBodyLength();\n             if (len > -1) {\n                 byte[] data = new byte[len];\n                 msg.readBytes(data);\n                 return new String(data);\n             } else {\n                 return \"\";\n             }\n         }\n         if (message instanceof StreamMessage) {\n             return \"StreamMessage is not viewable\";\n         }\n \n         if (message != null) {\n             return \"Unknown message type [\" + message.getClass().getName() + \"] \" + message;\n         }\n \n         return null;\n     }\n \n", "target": "// fix_start\n            } catch (Exception e) {\n                return new String(\"Cannot display ObjectMessage body. Reason: \" + e.getMessage());\n// fix_end\n", "cwe": "CWE-20", "cwe_name": "Improper Input Validation", "idx": 5523}
{"source": " private Exception doRequest() {\n \n             Tomcat tomcat = getTomcatInstance();\n \n             Context root = tomcat.addContext(\"\", TEMP_DIR);\n             Tomcat.addServlet(root, \"Bug51557\",\n                     new Bug51557Servlet(headerName));\n             root.addServletMapping(\"/test\", \"Bug51557\");\n \n             try {\n                 Connector connector = tomcat.getConnector();\n// bug_start\n                connector.setProperty(\"rejectIllegalHeaderName\",\n                        Boolean.toString(rejectIllegalHeaderName));\n// bug_end\n                 tomcat.start();\n                 setPort(connector.getLocalPort());\n \n                 connect();\n \n                 String[] request = new String[1];\n                 request[0] =\n                     \"GET /test HTTP/1.1\" + CRLF +\n                     \"host: localhost:8080\" + CRLF +\n                     headerLine + CRLF +\n                     \"X-Bug51557: abcd\" + CRLF +\n                     \"Connection: close\" + CRLF +\n                     CRLF;\n \n                 setRequest(request);\n                 processRequest();\n \n                 disconnect();\n             } catch (Exception e) {\n                 return e;\n             }\n             return null;\n         }\n \n", "target": "// fix_start\n                Assert.assertTrue(connector.setProperty(\n                        \"rejectIllegalHeader\", Boolean.toString(rejectIllegalHeader)));\n// fix_end\n", "cwe": "CWE-444", "cwe_name": "Inconsistent Interpretation of HTTP Requests ('HTTP Request Smuggling')", "idx": 56014}
{"source": " public List<String> getUserList(JdbcRealm obj) {\n     List<String> userlist = new ArrayList<>();\n     PreparedStatement ps = null;\n     ResultSet rs = null;\n     DataSource dataSource = null;\n     String authQuery = \"\";\n     String retval[];\n     String tablename = \"\";\n     String username = \"\";\n     String userquery = \"\";\n     try {\n       dataSource = (DataSource) FieldUtils.readField(obj, \"dataSource\", true);\n       authQuery = (String) FieldUtils.readField(obj, \"authenticationQuery\", true);\n       LOG.info(authQuery);\n       String authQueryLowerCase = authQuery.toLowerCase();\n       retval = authQueryLowerCase.split(\"from\", 2);\n       if (retval.length >= 2) {\n         retval = retval[1].split(\"with|where\", 2);\n         tablename = retval[0];\n         retval = retval[1].split(\"where\", 2);\n         if (retval.length >= 2)\n           retval = retval[1].split(\"=\", 2);\n         else\n           retval = retval[0].split(\"=\", 2);\n         username = retval[0];\n       }\n \n       if (StringUtils.isBlank(username) || StringUtils.isBlank(tablename)) {\n         return userlist;\n       }\n \n// bug_start\n      userquery = \"select \" + username + \" from \" + tablename;\n// bug_end\n \n     } catch (IllegalAccessException e) {\n       LOG.error(\"Error while accessing dataSource for JDBC Realm\", e);\n       return null;\n     }\n \n     try {\n       Connection con = dataSource.getConnection();\n       ps = con.prepareStatement(userquery);\n// bug_start\n// bug_end\n       rs = ps.executeQuery();\n       while (rs.next()) {\n         userlist.add(rs.getString(1).trim());\n       }\n     } catch (Exception e) {\n       LOG.error(\"Error retrieving User list from JDBC Realm\", e);\n     } finally {\n       JdbcUtils.closeResultSet(rs);\n       JdbcUtils.closeStatement(ps);\n     }\n     return userlist;\n   }\n \n", "target": "// fix_start\n      userquery = \"select ? from ?\";\n// fix_end\n// fix_start\n      ps.setString(1, username);\n      ps.setString(2, tablename);\n// fix_end\n", "cwe": "CWE-20", "cwe_name": "Improper Input Validation", "idx": 12402}
{"source": "// bug_start\npublic void doDynamic(StaplerRequest req, StaplerResponse rsp) throws IOException, ServletException {\n        String path = req.getRestOfPath();\n\n        if(path.length()==0)\n            path = \"/\";\n\n        if(path.indexOf(\"..\")!=-1 || path.length()<1) {\n            rsp.sendError(HttpServletResponse.SC_BAD_REQUEST);\n            return;\n        }\n\n        String requestPath = req.getRequestURI().substring(req.getContextPath().length());\n        boolean staticLink = requestPath.startsWith(\"/static/\");\n\n        long expires = staticLink ? TimeUnit2.DAYS.toMillis(365) : -1;\n\n        rsp.serveLocalizedFile(req, new URL(wrapper.baseResourceURL,'.'+path),expires);\n// bug_end\n     }\n \n", "target": "// fix_start\n@Override\n    public SecurityConstraint [] findSecurityConstraints(Request request,\n                                                         Context context) {\n\n        ArrayList<SecurityConstraint> results = null;\n        SecurityConstraint constraints[] = context.findConstraints();\n        if ((constraints == null) || (constraints.length == 0)) {\n            if (log.isDebugEnabled())\n                log.debug(\"  No applicable constraints defined\");\n            return null;\n        }\n\n        String uri = request.getRequestPathMB().toString();\n        if (uri == null || uri.length() == 0) {\n            uri = \"/\";\n        }\n\n        String method = request.getMethod();\n        int i;\n        boolean found = false;\n        for (i = 0; i < constraints.length; i++) {\n            SecurityCollection [] collection = constraints[i].findCollections();\n\n            if ( collection == null) {\n                continue;\n            }\n\n            if (log.isDebugEnabled()) {\n                log.debug(\"  Checking constraint '\" + constraints[i] +\n                    \"' against \" + method + \" \" + uri + \" --> \" +\n                    constraints[i].included(uri, method));\n            }\n\n            for(int j=0; j < collection.length; j++){\n                String [] patterns = collection[j].findPatterns();\n\n                if ( patterns == null) {\n                    continue;\n                }\n\n                for(int k=0; k < patterns.length; k++) {\n                    if(uri.equals(patterns[k]) || patterns[k].length() == 0 && uri.equals(\"/\")) {\n                        found = true;\n                        if(collection[j].findMethod(method)) {\n                            if(results == null) {\n                                results = new ArrayList<>();\n                            }\n                            results.add(constraints[i]);\n                        }\n                    }\n                }\n            }\n        }\n\n        if(found) {\n            return resultsToArray(results);\n        }\n\n        int longest = -1;\n\n        for (i = 0; i < constraints.length; i++) {\n            SecurityCollection [] collection = constraints[i].findCollections();\n\n            if ( collection == null) {\n                continue;\n            }\n\n            if (log.isDebugEnabled()) {\n                log.debug(\"  Checking constraint '\" + constraints[i] +\n                    \"' against \" + method + \" \" + uri + \" --> \" +\n                    constraints[i].included(uri, method));\n            }\n\n            for(int j=0; j < collection.length; j++){\n                String [] patterns = collection[j].findPatterns();\n\n                if ( patterns == null) {\n                    continue;\n                }\n\n                boolean matched = false;\n                int length = -1;\n                for(int k=0; k < patterns.length; k++) {\n                    String pattern = patterns[k];\n                    if(pattern.startsWith(\"/\") && pattern.endsWith(\"/*\") &&\n                       pattern.length() >= longest) {\n\n                        if(pattern.length() == 2) {\n                            matched = true;\n                            length = pattern.length();\n                        } else if(pattern.regionMatches(0,uri,0,\n                                                        pattern.length()-1) ||\n                                  (pattern.length()-2 == uri.length() &&\n                                   pattern.regionMatches(0,uri,0,\n                                                        pattern.length()-2))) {\n                            matched = true;\n                            length = pattern.length();\n                        }\n                    }\n                }\n                if(matched) {\n                    if(length > longest) {\n                        found = false;\n                        if(results != null) {\n                            results.clear();\n                        }\n                        longest = length;\n                    }\n                    if(collection[j].findMethod(method)) {\n                        found = true;\n                        if(results == null) {\n                            results = new ArrayList<>();\n                        }\n                        results.add(constraints[i]);\n                    }\n                }\n            }\n        }\n\n        if(found) {\n            return  resultsToArray(results);\n        }\n\n        for (i = 0; i < constraints.length; i++) {\n            SecurityCollection [] collection = constraints[i].findCollections();\n\n            if ( collection == null) {\n                continue;\n            }\n\n            if (log.isDebugEnabled()) {\n                log.debug(\"  Checking constraint '\" + constraints[i] +\n                    \"' against \" + method + \" \" + uri + \" --> \" +\n                    constraints[i].included(uri, method));\n            }\n\n            boolean matched = false;\n            int pos = -1;\n            for(int j=0; j < collection.length; j++){\n                String [] patterns = collection[j].findPatterns();\n\n                if ( patterns == null) {\n                    continue;\n                }\n\n                for(int k=0; k < patterns.length && !matched; k++) {\n                    String pattern = patterns[k];\n                    if(pattern.startsWith(\"*.\")){\n                        int slash = uri.lastIndexOf('/');\n                        int dot = uri.lastIndexOf('.');\n                        if(slash >= 0 && dot > slash &&\n                           dot != uri.length()-1 &&\n                           uri.length()-dot == pattern.length()-1) {\n                            if(pattern.regionMatches(1,uri,dot,uri.length()-dot)) {\n                                matched = true;\n                                pos = j;\n                            }\n                        }\n                    }\n                }\n            }\n            if(matched) {\n                found = true;\n                if(collection[pos].findMethod(method)) {\n                    if(results == null) {\n                        results = new ArrayList<>();\n                    }\n                    results.add(constraints[i]);\n                }\n            }\n        }\n\n        if(found) {\n            return resultsToArray(results);\n        }\n\n        for (i = 0; i < constraints.length; i++) {\n            SecurityCollection [] collection = constraints[i].findCollections();\n\n            if ( collection == null) {\n                continue;\n            }\n\n            if (log.isDebugEnabled()) {\n                log.debug(\"  Checking constraint '\" + constraints[i] +\n                    \"' against \" + method + \" \" + uri + \" --> \" +\n                    constraints[i].included(uri, method));\n            }\n\n            for(int j=0; j < collection.length; j++){\n                String [] patterns = collection[j].findPatterns();\n\n                if ( patterns == null) {\n                    continue;\n                }\n\n                boolean matched = false;\n                for(int k=0; k < patterns.length && !matched; k++) {\n                    String pattern = patterns[k];\n                    if(pattern.equals(\"/\")){\n                        matched = true;\n                    }\n                }\n                if(matched) {\n                    if(results == null) {\n                        results = new ArrayList<>();\n                    }\n                    results.add(constraints[i]);\n                }\n            }\n        }\n\n        if(results == null) {\n            if (log.isDebugEnabled())\n                log.debug(\"  No applicable constraint located\");\n        }\n        return resultsToArray(results);\n// fix_end\n", "cwe": "CWE-22", "cwe_name": "Path Traversal", "idx": 21461}
{"source": "// bug_start\n@Override\n    public SecurityConstraint [] findSecurityConstraints(Request request,\n                                                         Context context) {\n// bug_end\n \n// bug_start\n        ArrayList<SecurityConstraint> results = null;\n        SecurityConstraint constraints[] = context.findConstraints();\n        if ((constraints == null) || (constraints.length == 0)) {\n            if (log.isDebugEnabled())\n                log.debug(\"  No applicable constraints defined\");\n            return null;\n        }\n// bug_end\n \n// bug_start\n        String uri = request.getRequestPathMB().toString();\n        if (uri == null) {\n            uri = \"/\";\n        }\n// bug_end\n \n// bug_start\n        String method = request.getMethod();\n        int i;\n        boolean found = false;\n        for (i = 0; i < constraints.length; i++) {\n            SecurityCollection [] collection = constraints[i].findCollections();\n// bug_end\n \n// bug_start\n            if ( collection == null) {\n                continue;\n// bug_end\n             }\n// bug_start\n\n            if (log.isDebugEnabled()) {\n                log.debug(\"  Checking constraint '\" + constraints[i] +\n                    \"' against \" + method + \" \" + uri + \" --> \" +\n                    constraints[i].included(uri, method));\n// bug_end\n             }\n// bug_start\n\n            for(int j=0; j < collection.length; j++){\n                String [] patterns = collection[j].findPatterns();\n\n                if ( patterns == null) {\n                    continue;\n                }\n\n                for(int k=0; k < patterns.length; k++) {\n                    if(uri.equals(patterns[k])) {\n                        found = true;\n                        if(collection[j].findMethod(method)) {\n                            if(results == null) {\n                                results = new ArrayList<>();\n                            }\n                            results.add(constraints[i]);\n                        }\n                    }\n                }\n            }\n        }\n\n        if(found) {\n            return resultsToArray(results);\n        }\n\n        int longest = -1;\n\n        for (i = 0; i < constraints.length; i++) {\n            SecurityCollection [] collection = constraints[i].findCollections();\n\n            if ( collection == null) {\n                continue;\n            }\n\n            if (log.isDebugEnabled()) {\n                log.debug(\"  Checking constraint '\" + constraints[i] +\n                    \"' against \" + method + \" \" + uri + \" --> \" +\n                    constraints[i].included(uri, method));\n            }\n\n            for(int j=0; j < collection.length; j++){\n                String [] patterns = collection[j].findPatterns();\n\n                if ( patterns == null) {\n                    continue;\n                }\n\n                boolean matched = false;\n                int length = -1;\n                for(int k=0; k < patterns.length; k++) {\n                    String pattern = patterns[k];\n                    if(pattern.startsWith(\"/\") && pattern.endsWith(\"/*\") &&\n                       pattern.length() >= longest) {\n\n                        if(pattern.length() == 2) {\n                            matched = true;\n                            length = pattern.length();\n                        } else if(pattern.regionMatches(0,uri,0,\n                                                        pattern.length()-1) ||\n                                  (pattern.length()-2 == uri.length() &&\n                                   pattern.regionMatches(0,uri,0,\n                                                        pattern.length()-2))) {\n                            matched = true;\n                            length = pattern.length();\n                        }\n                    }\n                }\n                if(matched) {\n                    if(length > longest) {\n                        found = false;\n                        if(results != null) {\n                            results.clear();\n                        }\n                        longest = length;\n                    }\n                    if(collection[j].findMethod(method)) {\n                        found = true;\n                        if(results == null) {\n                            results = new ArrayList<>();\n                        }\n                        results.add(constraints[i]);\n                    }\n                }\n            }\n        }\n\n        if(found) {\n            return  resultsToArray(results);\n        }\n\n        for (i = 0; i < constraints.length; i++) {\n            SecurityCollection [] collection = constraints[i].findCollections();\n\n            if ( collection == null) {\n                continue;\n            }\n\n            if (log.isDebugEnabled()) {\n                log.debug(\"  Checking constraint '\" + constraints[i] +\n                    \"' against \" + method + \" \" + uri + \" --> \" +\n                    constraints[i].included(uri, method));\n            }\n\n            boolean matched = false;\n            int pos = -1;\n            for(int j=0; j < collection.length; j++){\n                String [] patterns = collection[j].findPatterns();\n\n                if ( patterns == null) {\n                    continue;\n                }\n\n                for(int k=0; k < patterns.length && !matched; k++) {\n                    String pattern = patterns[k];\n                    if(pattern.startsWith(\"*.\")){\n                        int slash = uri.lastIndexOf('/');\n                        int dot = uri.lastIndexOf('.');\n                        if(slash >= 0 && dot > slash &&\n                           dot != uri.length()-1 &&\n                           uri.length()-dot == pattern.length()-1) {\n                            if(pattern.regionMatches(1,uri,dot,uri.length()-dot)) {\n                                matched = true;\n                                pos = j;\n                            }\n                        }\n                    }\n                }\n            }\n            if(matched) {\n                found = true;\n                if(collection[pos].findMethod(method)) {\n                    if(results == null) {\n                        results = new ArrayList<>();\n                    }\n                    results.add(constraints[i]);\n                }\n            }\n        }\n\n        if(found) {\n            return resultsToArray(results);\n        }\n\n        for (i = 0; i < constraints.length; i++) {\n            SecurityCollection [] collection = constraints[i].findCollections();\n\n            if ( collection == null) {\n                continue;\n            }\n\n            if (log.isDebugEnabled()) {\n                log.debug(\"  Checking constraint '\" + constraints[i] +\n                    \"' against \" + method + \" \" + uri + \" --> \" +\n                    constraints[i].included(uri, method));\n            }\n\n            for(int j=0; j < collection.length; j++){\n                String [] patterns = collection[j].findPatterns();\n\n                if ( patterns == null) {\n                    continue;\n                }\n\n                boolean matched = false;\n                for(int k=0; k < patterns.length && !matched; k++) {\n                    String pattern = patterns[k];\n                    if(pattern.equals(\"/\")){\n                        matched = true;\n                    }\n                }\n                if(matched) {\n                    if(results == null) {\n                        results = new ArrayList<>();\n                    }\n                    results.add(constraints[i]);\n                }\n            }\n        }\n\n        if(results == null) {\n            if (log.isDebugEnabled())\n                log.debug(\"  No applicable constraint located\");\n        }\n        return resultsToArray(results);\n// bug_end\n     }\n \n", "target": "// fix_start\nprivate void init() {\n        addImmutableType(Result.class);\n// fix_end\n// fix_start\n        denyTypes(new Class[] { void.class, Void.class });\n// fix_end\n// fix_start\n        registerConverter(new RobustCollectionConverter(getMapper(),getReflectionProvider()),10);\n        registerConverter(new RobustMapConverter(getMapper()), 10);\n        registerConverter(new ImmutableMapConverter(getMapper(),getReflectionProvider()),10);\n        registerConverter(new ImmutableSortedSetConverter(getMapper(),getReflectionProvider()),10);\n        registerConverter(new ImmutableSetConverter(getMapper(),getReflectionProvider()),10);\n        registerConverter(new ImmutableListConverter(getMapper(),getReflectionProvider()),10);\n        registerConverter(new CopyOnWriteMap.Tree.ConverterImpl(getMapper()),10);\n        registerConverter(new DescribableList.ConverterImpl(getMapper()),10);\n        registerConverter(new Label.ConverterImpl(),10);\n// fix_end\n// fix_start\n        registerConverter(new AssociatedConverterImpl(this), -10);\n// fix_end\n// fix_start\n        registerConverter(new BlacklistedTypesConverter(), PRIORITY_VERY_HIGH);\n\n        registerConverter(new DynamicProxyConverter(getMapper()) {\n            @Override public boolean canConvert(Class type) {\n                return  type != null && super.canConvert(type);\n// fix_end\n// fix_start\n            @Override public Object unmarshal(HierarchicalStreamReader reader, UnmarshallingContext context) {\n                throw new ConversionException(\"<dynamic-proxy> not supported\");\n// fix_end\n// fix_start\n        }, PRIORITY_VERY_HIGH);\n// fix_end\n", "cwe": "NVD-CWE-noinfo", "cwe_name": "", "idx": 100873}
{"source": "// bug_start\nprivate String guard(String filename) {\n            String guarded = filename.replace(\":\", \"_\");\n            guarded = FileSystems.getDefault().getPath(guarded).normalize().toString();\n            if (LOG.isDebugEnabled()) {\n                LOG.debug(\"guarded \" + filename + \" to \" + guarded);\n// bug_end\n             }\n// bug_start\n            return guarded;\n        }\n// bug_end\n \n", "target": "// fix_start\nprivate void init() {\n        addImmutableType(Result.class);\n\n        denyTypes(new Class[] { void.class, Void.class });\n\n        registerConverter(new RobustCollectionConverter(getMapper(),getReflectionProvider()),10);\n        registerConverter(new RobustMapConverter(getMapper()), 10);\n        registerConverter(new ImmutableMapConverter(getMapper(),getReflectionProvider()),10);\n        registerConverter(new ImmutableSortedSetConverter(getMapper(),getReflectionProvider()),10);\n        registerConverter(new ImmutableSetConverter(getMapper(),getReflectionProvider()),10);\n        registerConverter(new ImmutableListConverter(getMapper(),getReflectionProvider()),10);\n        registerConverter(new CopyOnWriteMap.Tree.ConverterImpl(getMapper()),10);\n        registerConverter(new DescribableList.ConverterImpl(getMapper()),10);\n        registerConverter(new Label.ConverterImpl(),10);\n        registerConverter(new SafeURLConverter(),10);\n\n        registerConverter(new AssociatedConverterImpl(this), -10);\n\n        registerConverter(new BlacklistedTypesConverter(), PRIORITY_VERY_HIGH);\n\n        registerConverter(new DynamicProxyConverter(getMapper()) {\n            @Override public boolean canConvert(Class type) {\n                return  type != null && super.canConvert(type);\n// fix_end\n// fix_start\n            @Override public Object unmarshal(HierarchicalStreamReader reader, UnmarshallingContext context) {\n                throw new ConversionException(\"<dynamic-proxy> not supported\");\n            }\n        }, PRIORITY_VERY_HIGH);\n    }\n// fix_end\n", "cwe": "CWE-502", "cwe_name": "Deserialization of Untrusted Data", "idx": 59076}
{"source": "// bug_start\nprivate String guard(String filename) {\n            String guarded = filename.replace(\":\", \"_\").replace(\"\\\\\", \"\").replace(\"/\", \"\");\n            if (LOG.isDebugEnabled()) {\n                LOG.debug(\"guarded \" + filename + \" to \" + guarded);\n            }\n            return guarded;\n// bug_end\n         }\n \n", "target": "// fix_start\n@Override\n    public String getWindowId(FacesContext facesContext)\n    {\n        Map<String, Object> requestMap = facesContext.getExternalContext().getRequestMap();\n\n        String windowId = (String) requestMap.get(CACHE_WINDOW_ID);\n        if (windowId != null)\n        {\n            return windowId;\n// fix_end\n// fix_start\n        windowId = getOrCreateWindowId(facesContext);\n\n\n        if (windowId != null)\n        {\n            windowId = sanitiseWindowId(windowId);\n\n            ClientWindowConfig.ClientWindowRenderMode clientWindowRenderMode =\n                    clientWindowConfig.getClientWindowRenderMode(facesContext);\n            if (!ClientWindowConfig.ClientWindowRenderMode.DELEGATED.equals(clientWindowRenderMode))\n            {\n                if (windowId.length() > this.maxWindowIdCount)\n                {\n                    windowId = windowId.substring(0, this.maxWindowIdCount);\n                }\n            }\n\n            requestMap.put(CACHE_WINDOW_ID, windowId);\n        }\n\n        return windowId;\n    }\n\n// fix_end\n", "cwe": "CWE-22", "cwe_name": "Path Traversal", "idx": 20891}
{"source": "// bug_start\n@Override\n    public String getWindowId(FacesContext facesContext)\n    {\n        Map<String, Object> requestMap = facesContext.getExternalContext().getRequestMap();\n// bug_end\n \n// bug_start\n        String windowId = (String) requestMap.get(CACHE_WINDOW_ID);\n        if (windowId != null)\n        {\n            return windowId;\n        }\n\n        windowId = getOrCreateWindowId(facesContext);\n\n        if (windowId != null)\n        {\n            ClientWindowConfig.ClientWindowRenderMode clientWindowRenderMode =\n                    clientWindowConfig.getClientWindowRenderMode(facesContext);\n            if (!ClientWindowConfig.ClientWindowRenderMode.DELEGATED.equals(clientWindowRenderMode))\n            {\n                if (windowId.length() > this.maxWindowIdCount)\n                {\n                    windowId = windowId.substring(0, this.maxWindowIdCount);\n                }\n            }\n\n            requestMap.put(CACHE_WINDOW_ID, windowId);\n        }\n\n        return windowId;\n    }\n\n// bug_end\n", "target": "// fix_start\nprotected Number extractFloat() throws ParseException {\n\t\tif (!acceptLeadinZero)\n\t\t\tcheckLeadinZero();\n\t\ttry {\n\t\t\tif (!useHiPrecisionFloat)\n\t\t\t\treturn Float.parseFloat(xs);\n\t\t\tif (xs.length() > 18)\n\t\t\t\treturn new BigDecimal(xs);\n\t\t\treturn Double.parseDouble(xs);\n\t\t} catch (NumberFormatException e) {\n\t\t\tthrow new ParseException(pos, ERROR_UNEXPECTED_TOKEN, xs);\n\t\t}\n\t}\n// fix_end\n", "cwe": "CWE-79", "cwe_name": "Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')", "idx": 79085}
{"source": "// bug_start\nprotected Number extractFloat() throws ParseException {\n\t\tif (!acceptLeadinZero)\n\t\t\tcheckLeadinZero();\n\t\tif (!useHiPrecisionFloat)\n\t\t\treturn Float.parseFloat(xs);\n\t\tif (xs.length() > 18)\n\t\t\treturn new BigDecimal(xs);\n\t\treturn Double.parseDouble(xs);\n\t}\n// bug_end\n \n", "target": "// fix_start\nprivate void addSort(\n            final SearchRequestBuilder builder,\n            final AnyTypeKind kind,\n            final List<OrderByClause> orderBy) {\n// fix_end\n// fix_start\n        AnyUtils attrUtils = anyUtilsFactory.getInstance(kind);\n\n        for (OrderByClause clause : filterOrderBy(orderBy)) {\n            String sortName = null;\n\n            String fieldName = \"key\".equals(clause.getField()) ? \"id\" : clause.getField();\n\n            Field anyField = ReflectionUtils.findField(attrUtils.anyClass(), fieldName);\n            if (anyField == null) {\n                PlainSchema schema = schemaDAO.find(fieldName);\n                if (schema != null) {\n                    sortName = fieldName;\n                }\n            } else {\n                sortName = fieldName;\n            }\n\n            if (sortName == null) {\n                LOG.warn(\"Cannot build any valid clause from {}\", clause);\n            } else {\n                builder.addSort(sortName, SortOrder.valueOf(clause.getDirection().name()));\n            }\n        }\n    }\n\n// fix_end\n", "cwe": "CWE-754", "cwe_name": "Improper Check for Unusual or Exceptional Conditions", "idx": 74248}
{"source": "// bug_start\nprivate void addSort(\n            final SearchRequestBuilder builder,\n            final AnyTypeKind kind,\n            final List<OrderByClause> orderBy) {\n// bug_end\n \n// bug_start\n        AnyUtils attrUtils = anyUtilsFactory.getInstance(kind);\n// bug_end\n \n// bug_start\n        for (OrderByClause clause : orderBy) {\n            String sortName = null;\n\n            String fieldName = \"key\".equals(clause.getField()) ? \"id\" : clause.getField();\n\n            Field anyField = ReflectionUtils.findField(attrUtils.anyClass(), fieldName);\n            if (anyField == null) {\n                PlainSchema schema = schemaDAO.find(fieldName);\n                if (schema != null) {\n                    sortName = fieldName;\n// bug_end\n                 }\n// bug_start\n            } else {\n                sortName = fieldName;\n// bug_end\n             }\n// bug_start\n\n            if (sortName == null) {\n                LOG.warn(\"Cannot build any valid clause from {}\", clause);\n            } else {\n                builder.addSort(sortName, SortOrder.valueOf(clause.getDirection().name()));\n            }\n// bug_end\n         }\n     }\n \n", "target": "// fix_start\npublic T newInstance(@Nullable StaplerRequest req, @Nonnull JSONObject formData) throws FormException {\n        try {\n            Method m = getClass().getMethod(\"newInstance\", StaplerRequest.class);\n// fix_end\n// fix_start\n            if(!Modifier.isAbstract(m.getDeclaringClass().getModifiers())) {\n                return verifyNewInstance(newInstance(req));\n            } else {\n                if (req==null) {\n                    return verifyNewInstance(clazz.newInstance());\n                }\n// fix_end\n// fix_start\n                BindInterceptor oldInterceptor = req.getBindInterceptor();\n                try {\n                    NewInstanceBindInterceptor interceptor;\n                    if (oldInterceptor instanceof NewInstanceBindInterceptor) {\n                        interceptor = (NewInstanceBindInterceptor) oldInterceptor;\n                    } else {\n                        interceptor = new NewInstanceBindInterceptor(oldInterceptor);\n                        req.setBindInterceptor(interceptor);\n                    }\n                    interceptor.processed.put(formData, true);\n                    return verifyNewInstance(req.bindJSON(clazz, formData));\n                } finally {\n                    req.setBindInterceptor(oldInterceptor);\n// fix_end\n// fix_start\n// fix_end\n// fix_start\n        } catch (NoSuchMethodException e) {\n            throw new AssertionError(e);\n        } catch (InstantiationException | IllegalAccessException | RuntimeException e) {\n            throw new Error(\"Failed to instantiate \"+clazz+\" from \"+formData,e);\n// fix_end\n", "cwe": "CWE-200", "cwe_name": "Exposure of Sensitive Information to an Unauthorized Actor", "idx": 15742}
{"source": "// bug_start\npublic static boolean isStaxSource(Source source) {\n\t\treturn ((source instanceof StaxSource) || (jaxp14Available && Jaxp14StaxHandler.isStaxSource(source)));\n\t}\n// bug_end\n \n", "target": "// fix_start\npublic T newInstance(@Nullable StaplerRequest req, @Nonnull JSONObject formData) throws FormException {\n        try {\n            Method m = getClass().getMethod(\"newInstance\", StaplerRequest.class);\n// fix_end\n// fix_start\n            if(!Modifier.isAbstract(m.getDeclaringClass().getModifiers())) {\n                return verifyNewInstance(newInstance(req));\n            } else {\n                if (req==null) {\n                    return verifyNewInstance(clazz.newInstance());\n                }\n\n                BindInterceptor oldInterceptor = req.getBindInterceptor();\n                try {\n                    NewInstanceBindInterceptor interceptor;\n                    if (oldInterceptor instanceof NewInstanceBindInterceptor) {\n                        interceptor = (NewInstanceBindInterceptor) oldInterceptor;\n                    } else {\n                        interceptor = new NewInstanceBindInterceptor(oldInterceptor);\n                        req.setBindInterceptor(interceptor);\n                    }\n                    interceptor.processed.put(formData, true);\n                    return verifyNewInstance(req.bindJSON(clazz, formData));\n                } finally {\n                    req.setBindInterceptor(oldInterceptor);\n                }\n            }\n        } catch (NoSuchMethodException e) {\n            throw new AssertionError(e);\n        } catch (InstantiationException | IllegalAccessException | RuntimeException e) {\n            throw new Error(\"Failed to instantiate \"+clazz+\" from \"+RedactSecretJsonInErrorMessageSanitizer.INSTANCE.sanitize(formData),e);\n        }\n    }\n\n// fix_end\n", "cwe": "CWE-200", "cwe_name": "Exposure of Sensitive Information to an Unauthorized Actor", "idx": 14420}
{"source": "// bug_start\npublic static boolean isStaxSource(Source source) {\n\t\treturn (source instanceof StaxSource || (jaxp14Available && Jaxp14StaxHandler.isStaxSource(source)));\n\t}\n// bug_end\n \n", "target": "// fix_start\npublic Calendar ceil(Calendar cal) {\n        Calendar twoYearsFuture = (Calendar) cal.clone();\n        twoYearsFuture.add(Calendar.YEAR, 2);\n        OUTER:\n        while (true) {\n            if (cal.compareTo(twoYearsFuture) > 0) {\n                throw new RareOrImpossibleDateException();\n            }\n            for (CalendarField f : CalendarField.ADJUST_ORDER) {\n                int cur = f.valueOf(cal);\n                int next = f.ceil(this,cur);\n                if (cur==next)  continue;\n// fix_end\n// fix_start\n                for (CalendarField l=f.lowerField; l!=null; l=l.lowerField)\n                    l.clear(cal);\n\n                if (next<0) {\n                    f.rollUp(cal, 1);\n                    f.setTo(cal,f.first(this));\n                    continue OUTER;\n                } else {\n                    f.setTo(cal,next);\n                    if (f.valueOf(cal) != next) {\n                        f.rollUp(cal, 1);\n                        f.setTo(cal,f.first(this));\n                        continue OUTER;\n                    }\n                    if (f.redoAdjustmentIfModified)\n                        continue OUTER;\n                }\n            }\n            return cal;\n        }\n    }\n\n// fix_end\n", "cwe": "CWE-352", "cwe_name": "Cross-Site Request Forgery (CSRF)", "idx": 45450}
{"source": "// bug_start\npublic Calendar ceil(Calendar cal) {\n        Calendar twoYearsFuture = (Calendar) cal.clone();\n        twoYearsFuture.add(Calendar.YEAR, 2);\n        OUTER:\n        while (true) {\n            if (cal.compareTo(twoYearsFuture) > 0) {\n                throw new RareOrImpossibleDateException();\n            }\n            for (CalendarField f : CalendarField.ADJUST_ORDER) {\n                int cur = f.valueOf(cal);\n                int next = f.ceil(this,cur);\n                if (cur==next)  continue;\n// bug_end\n \n// bug_start\n                for (CalendarField l=f.lowerField; l!=null; l=l.lowerField)\n                    l.clear(cal);\n\n                if (next<0) {\n                    f.rollUp(cal, 1);\n                    f.setTo(cal,f.first(this));\n                    continue OUTER;\n                } else {\n                    f.setTo(cal,next);\n                    if (f.redoAdjustmentIfModified)\n                        continue OUTER;\n                }\n            }\n            return cal;\n        }\n    }\n\n// bug_end\n", "target": "// fix_start\npublic void execute(final FunctionContext context) {\n    CliFunctionResult result;\n    String memberId = context.getCache().getDistributedSystem().getDistributedMember().getId();\n    try {\n      LuceneDestroyIndexInfo indexInfo = (LuceneDestroyIndexInfo) context.getArguments();\n      String indexName = indexInfo.getIndexName();\n      String regionPath = indexInfo.getRegionPath();\n      LuceneService service = LuceneServiceProvider.get(context.getCache());\n      if (indexName == null) {\n        if (indexInfo.isDefinedDestroyOnly()) {\n          ((LuceneServiceImpl) service).destroyDefinedIndexes(regionPath);\n          result = new CliFunctionResult(memberId);\n        } else {\n          service.destroyIndexes(regionPath);\n          result = new CliFunctionResult(memberId, getXmlEntity(indexName, regionPath));\n        }\n      } else {\n        if (indexInfo.isDefinedDestroyOnly()) {\n          ((LuceneServiceImpl) service).destroyDefinedIndex(indexName, regionPath);\n          result = new CliFunctionResult(memberId);\n        } else {\n          service.destroyIndex(indexName, regionPath);\n          result = new CliFunctionResult(memberId, getXmlEntity(indexName, regionPath));\n        }\n      }\n    } catch (Exception e) {\n      result = new CliFunctionResult(memberId, e, e.getMessage());\n    }\n    context.getResultSender().lastResult(result);\n  }\n// fix_end\n", "cwe": "CWE-835", "cwe_name": "Loop with Unreachable Exit Condition ('Infinite Loop')", "idx": 82172}
{"source": "// bug_start\npublic void execute(final FunctionContext context) {\n    CliFunctionResult result = null;\n    String memberId = context.getCache().getDistributedSystem().getDistributedMember().getId();\n    try {\n      LuceneDestroyIndexInfo indexInfo = (LuceneDestroyIndexInfo) context.getArguments();\n      String indexName = indexInfo.getIndexName();\n      String regionPath = indexInfo.getRegionPath();\n      LuceneService service = LuceneServiceProvider.get(context.getCache());\n      if (indexName == null) {\n        if (indexInfo.isDefinedDestroyOnly()) {\n          ((LuceneServiceImpl) service).destroyDefinedIndexes(regionPath);\n          result = new CliFunctionResult(memberId);\n// bug_end\n         } else {\n// bug_start\n          service.destroyIndexes(regionPath);\n          result = new CliFunctionResult(memberId, getXmlEntity(indexName, regionPath));\n// bug_end\n         }\n// bug_start\n      } else {\n        if (indexInfo.isDefinedDestroyOnly()) {\n          ((LuceneServiceImpl) service).destroyDefinedIndex(indexName, regionPath);\n          result = new CliFunctionResult(memberId);\n        } else {\n          service.destroyIndex(indexName, regionPath);\n          result = new CliFunctionResult(memberId, getXmlEntity(indexName, regionPath));\n        }\n      }\n    } catch (Exception e) {\n      result = new CliFunctionResult(memberId, e, e.getMessage());\n// bug_end\n     }\n// bug_start\n    context.getResultSender().lastResult(result);\n  }\n// bug_end\n \n", "target": "// fix_start\npublic String getUrlRegex() {\n        if (StringUtils.isNotEmpty(urlRegexExpression)) {\n            return (String) parse(urlRegexExpression, String.class);\n        } else if (StringUtils.isNotEmpty(urlRegex)) {\n            return urlRegex;\n// fix_end\n// fix_start\n            return \"^(https?|ftp):\\\\/\\\\/\" +\n                    \"(([a-z0-9$_\\\\.\\\\+!\\\\*\\\\'\\\\(\\\\),;\\\\?&=-]|%[0-9a-f]{2})+\" +\n                    \"(:([a-z0-9$_\\\\.\\\\+!\\\\*\\\\'\\\\(\\\\),;\\\\?&=-]|%[0-9a-f]{2})+)?\" +\n                    \"@)?(#?\" +\n                    \")((([a-z0-9]\\\\.|[a-z0-9][a-z0-9-]*[a-z0-9]\\\\.)*\" +\n                    \"[a-z][a-z0-9-]*[a-z0-9]\" +\n                    \"|((\\\\d|[1-9]\\\\d|1\\\\d{2}|2[0-4][0-9]|25[0-5])\\\\.){3}\" +\n                    \"(\\\\d|[1-9]\\\\d|1\\\\d{2}|2[0-4][0-9]|25[0-5])\" +\n                    \")(:\\\\d+)?\" +\n                    \")(((\\\\/{0,1}([a-z0-9$_\\\\.\\\\+!\\\\*\\\\'\\\\(\\\\),;:@&=-]|%[0-9a-f]{2})*)*\" +\n                    \"(\\\\?([a-z0-9$_\\\\.\\\\+!\\\\*\\\\'\\\\(\\\\),;:@&=-]|%[0-9a-f]{2})*)\" +\n                    \"?)?)?\" +\n                    \"(#([a-z0-9$_\\\\.\\\\+!\\\\*\\\\'\\\\(\\\\),;:@&=-]|%[0-9a-f]{2})*)?\" +\n                    \"$\";\n// fix_end\n// fix_start\n// fix_end\n// fix_start\n// fix_end\n", "cwe": "CWE-863", "cwe_name": "Incorrect Authorization", "idx": 88200}
{"source": " private void doTestRewrite(String config, String request, String expectedURI,\n             String expectedQueryString, String expectedAttributeValue) throws Exception {\n \n         Tomcat tomcat = getTomcatInstance();\n \n         Context ctx = tomcat.addContext(\"\", null);\n \n         RewriteValve rewriteValve = new RewriteValve();\n         ctx.getPipeline().addValve(rewriteValve);\n \n         rewriteValve.setConfiguration(config);\n \n         Tomcat.addServlet(ctx, \"snoop\", new SnoopServlet());\n         ctx.addServletMappingDecoded(\"/a/%5A\", \"snoop\");\n         ctx.addServletMappingDecoded(\"/c/*\", \"snoop\");\n         Tomcat.addServlet(ctx, \"default\", new DefaultServlet());\n         ctx.addServletMappingDecoded(\"/\", \"default\");\n \n         tomcat.start();\n \n// bug_start\n        ByteChunk res = getUrl(\"http://localhost:\" + getPort() + request);\n// bug_end\n         res.setCharset(StandardCharsets.UTF_8);\n \n// bug_start\n        String body = res.toString();\n        RequestDescriptor requestDesc = SnoopResult.parse(body);\n        String requestURI = requestDesc.getRequestInfo(\"REQUEST-URI\");\n        Assert.assertEquals(expectedURI, requestURI);\n// bug_end\n \n// bug_start\n        if (expectedQueryString != null) {\n            String queryString = requestDesc.getRequestInfo(\"REQUEST-QUERY-STRING\");\n            Assert.assertEquals(expectedQueryString, queryString);\n        }\n// bug_end\n \n// bug_start\n        if (expectedAttributeValue != null) {\n            String attributeValue = requestDesc.getAttribute(\"X-Test\");\n            Assert.assertEquals(expectedAttributeValue, attributeValue);\n// bug_end\n         }\n     }\n \n", "target": "// fix_start\n        ByteChunk res = new ByteChunk();\n        int rc = getUrl(\"http://localhost:\" + getPort() + request, res, null);\n// fix_end\n// fix_start\n        if (expectedURI == null) {\n            Assert.assertEquals(400, rc);\n        } else {\n            String body = res.toString();\n            RequestDescriptor requestDesc = SnoopResult.parse(body);\n            String requestURI = requestDesc.getRequestInfo(\"REQUEST-URI\");\n            Assert.assertEquals(expectedURI, requestURI);\n// fix_end\n// fix_start\n            if (expectedQueryString != null) {\n                String queryString = requestDesc.getRequestInfo(\"REQUEST-QUERY-STRING\");\n                Assert.assertEquals(expectedQueryString, queryString);\n            }\n// fix_end\n// fix_start\n            if (expectedAttributeValue != null) {\n                String attributeValue = requestDesc.getAttribute(\"X-Test\");\n                Assert.assertEquals(expectedAttributeValue, attributeValue);\n            }\n// fix_end\n", "cwe": "CWE-20", "cwe_name": "Improper Input Validation", "idx": 11922}
{"source": "// bug_start\n@Configuration\n    public Option[] config() throws InterruptedException {\n\n        MavenArtifactUrlReference karafUrl = maven()\n                .groupId(\"org.apache.unomi\")\n                .artifactId(\"unomi\")\n                .type(\"tar.gz\")\n                .versionAsInProject();\n\n        MavenUrlReference routerRepo = maven()\n                .groupId(\"org.apache.unomi\")\n                .artifactId(\"unomi-router-karaf-feature\")\n                .classifier(\"features\")\n                .type(\"xml\")\n                .versionAsInProject();\n\n        List<Option> options = new ArrayList<>();\n\n        Option[] commonOptions = new Option[]{\n                debugConfiguration(\"5006\", false),\n                karafDistributionConfiguration()\n                        .frameworkUrl(karafUrl)\n                        .unpackDirectory(new File(KARAF_DIR))\n                        .useDeployFolder(true),\n                replaceConfigurationFile(\"etc/org.apache.unomi.router.cfg\", new File(\n                        \"src/test/resources/org.apache.unomi.router.cfg\")),\n                replaceConfigurationFile(\"data/tmp/1-basic-test.csv\", new File(\n                        \"src/test/resources/1-basic-test.csv\")),\n                replaceConfigurationFile(\"data/tmp/recurrent_import/2-surfers-test.csv\", new File(\n                        \"src/test/resources/2-surfers-test.csv\")),\n                replaceConfigurationFile(\"data/tmp/recurrent_import/3-surfers-overwrite-test.csv\", new File(\n                        \"src/test/resources/3-surfers-overwrite-test.csv\")),\n                replaceConfigurationFile(\"data/tmp/recurrent_import/4-surfers-delete-test.csv\", new File(\n                        \"src/test/resources/4-surfers-delete-test.csv\")),\n                replaceConfigurationFile(\"data/tmp/recurrent_import/5-ranking-test.csv\", new File(\n                        \"src/test/resources/5-ranking-test.csv\")),\n                replaceConfigurationFile(\"data/tmp/recurrent_import/6-actors-test.csv\", new File(\n                        \"src/test/resources/6-actors-test.csv\")),\n                replaceConfigurationFile(\"data/tmp/testLogin.json\", new File(\n                        \"src/test/resources/testLogin.json\")),\n                replaceConfigurationFile(\"data/tmp/testLoginEventCondition.json\", new File(\n                        \"src/test/resources/testLoginEventCondition.json\")),\n                keepRuntimeFolder(),\n                logLevel(LogLevel.INFO),\n                editConfigurationFilePut(\"etc/org.ops4j.pax.logging.cfg\", \"log4j2.rootLogger.level\", \"INFO\"),\n                editConfigurationFilePut(\"etc/org.apache.karaf.features.cfg\", \"serviceRequirements\", \"disable\"),\n                systemProperty(\"org.ops4j.pax.exam.rbc.rmi.port\").value(\"1199\"),\n                systemProperty(\"org.apache.unomi.itests.elasticsearch.transport.port\").value(\"9500\"),\n                systemProperty(\"org.apache.unomi.itests.elasticsearch.cluster.name\").value(\"contextElasticSearchITests\"),\n                systemProperty(\"org.apache.unomi.itests.elasticsearch.http.port\").value(\"9400\"),\n                systemProperty(\"org.apache.unomi.itests.elasticsearch.bootstrap.seccomp\").value(\"false\"),\n                systemProperty(\"org.apache.unomi.hazelcast.group.name\").value(\"cellar\"),\n                systemProperty(\"org.apache.unomi.hazelcast.group.password\").value(\"pass\"),\n                systemProperty(\"org.apache.unomi.hazelcast.network.port\").value(\"5701\"),\n                systemProperty(\"org.apache.unomi.hazelcast.tcp-ip.members\").value(\"127.0.0.1\"),\n                systemProperty(\"org.apache.unomi.hazelcast.tcp-ip.interface\").value(\"127.0.0.1\"),\n                systemProperty(\"unomi.autoStart\").value(\"true\"),\n                features(routerRepo, \"unomi-router-karaf-feature\"),\n                CoreOptions.bundleStartLevel(100),\n                CoreOptions.frameworkStartLevel(100)\n        };\n\n        options.addAll(Arrays.asList(commonOptions));\n\n        if (JavaVersionUtil.getMajorVersion() >= 9) {\n            Option[] jdk9PlusOptions = new Option[]{\n                    new VMOption(\"--add-reads=java.xml=java.logging\"),\n                    new VMOption(\"--add-exports=java.base/org.apache.karaf.specs.locator=java.xml,ALL-UNNAMED\"),\n                    new VMOption(\"--patch-module\"),\n                    new VMOption(\"java.base=lib/endorsed/org.apache.karaf.specs.locator-\"\n                            + System.getProperty(\"karaf.version\") + \".jar\"),\n                    new VMOption(\"--patch-module\"), new VMOption(\"java.xml=lib/endorsed/org.apache.karaf.specs.java.xml-\"\n                    + System.getProperty(\"karaf.version\") + \".jar\"),\n                    new VMOption(\"--add-opens\"),\n                    new VMOption(\"java.base/java.security=ALL-UNNAMED\"),\n                    new VMOption(\"--add-opens\"),\n                    new VMOption(\"java.base/java.net=ALL-UNNAMED\"),\n                    new VMOption(\"--add-opens\"),\n                    new VMOption(\"java.base/java.lang=ALL-UNNAMED\"),\n                    new VMOption(\"--add-opens\"),\n                    new VMOption(\"java.base/java.util=ALL-UNNAMED\"),\n                    new VMOption(\"--add-opens\"),\n                    new VMOption(\"java.naming/javax.naming.spi=ALL-UNNAMED\"),\n                    new VMOption(\"--add-opens\"),\n                    new VMOption(\"java.rmi/sun.rmi.transport.tcp=ALL-UNNAMED\"),\n                    new VMOption(\"--add-exports=java.base/sun.net.www.protocol.http=ALL-UNNAMED\"),\n                    new VMOption(\"--add-exports=java.base/sun.net.www.protocol.https=ALL-UNNAMED\"),\n                    new VMOption(\"--add-exports=java.base/sun.net.www.protocol.jar=ALL-UNNAMED\"),\n                    new VMOption(\"--add-exports=jdk.naming.rmi/com.sun.jndi.url.rmi=ALL-UNNAMED\"),\n                    new VMOption(\"-classpath\"),\n                    new VMOption(\"lib/jdk9plus/*\" + File.pathSeparator + \"lib/boot/*\")\n\n            };\n            options.addAll(Arrays.asList(jdk9PlusOptions));\n// bug_end\n         }\n// bug_start\n\n        return options.toArray(new Option[0]);\n// bug_end\n     }\n \n", "target": "// fix_start\n@SuppressWarnings(\"unchecked\")\n    private static Object parseParameter(Map<String, Object> context, Object value) {\n        if (value instanceof String) {\n            if (((String) value).startsWith(\"parameter::\") || ((String) value).startsWith(\"script::\")) {\n                String s = (String) value;\n                if (s.startsWith(\"parameter::\")) {\n                    return context.get(StringUtils.substringAfter(s, \"parameter::\"));\n                } else if (s.startsWith(\"script::\")) {\n                    String script = StringUtils.substringAfter(s, \"script::\");\n                    return executeScript(context, script);\n                }\n            }\n        } else if (value instanceof Map) {\n            Map<String, Object> values = new HashMap<String, Object>();\n            for (Map.Entry<String, Object> entry : ((Map<String, Object>) value).entrySet()) {\n                Object parameter = parseParameter(context, entry.getValue());\n                if (parameter == null) {\n                    return null;\n                }\n                values.put(entry.getKey(), parameter);\n            }\n            return values;\n        } else if (value instanceof List) {\n            List<Object> values = new ArrayList<Object>();\n            for (Object o : ((List<?>) value)) {\n                Object parameter = parseParameter(context, o);\n                if (parameter != null) {\n                    values.add(parameter);\n                }\n            }\n            return values;\n// fix_end\n// fix_start\n        return value;\n// fix_end\n", "cwe": "NVD-CWE-noinfo", "cwe_name": "", "idx": 99568}
{"source": "// bug_start\n@SuppressWarnings(\"unchecked\")\n    private static Object parseParameter(Map<String, Object> context, Object value) {\n        if (value instanceof String) {\n            if (((String) value).startsWith(\"parameter::\") || ((String) value).startsWith(\"script::\")) {\n                String s = (String) value;\n                if (s.startsWith(\"parameter::\")) {\n                    return context.get(StringUtils.substringAfter(s, \"parameter::\"));\n                } else if (s.startsWith(\"script::\")) {\n                    String script = StringUtils.substringAfter(s, \"script::\");\n                    if (!mvelExpressions.containsKey(script)) {\n                        ParserConfiguration parserConfiguration = new ParserConfiguration();\n                        parserConfiguration.setClassLoader(ConditionContextHelper.class.getClassLoader());\n                        mvelExpressions.put(script,MVEL.compileExpression(script, new ParserContext(parserConfiguration)));\n// bug_end\n                     }\n// bug_start\n                    return MVEL.executeExpression(mvelExpressions.get(script), context);\n// bug_end\n                 }\n             }\n// bug_start\n        } else if (value instanceof Map) {\n            Map<String, Object> values = new HashMap<String, Object>();\n            for (Map.Entry<String, Object> entry : ((Map<String, Object>) value).entrySet()) {\n                Object parameter = parseParameter(context, entry.getValue());\n                if (parameter == null) {\n                    return null;\n                }\n                values.put(entry.getKey(), parameter);\n            }\n            return values;\n        } else if (value instanceof List) {\n            List<Object> values = new ArrayList<Object>();\n            for (Object o : ((List<?>) value)) {\n                Object parameter = parseParameter(context, o);\n                if (parameter != null) {\n                    values.add(parameter);\n                }\n            }\n            return values;\n// bug_end\n         }\n// bug_start\n        return value;\n// bug_end\n     }\n \n", "target": "// fix_start\n@Configuration\n    public Option[] config() throws InterruptedException {\n\n        MavenArtifactUrlReference karafUrl = maven()\n                .groupId(\"org.apache.unomi\")\n                .artifactId(\"unomi\")\n                .type(\"tar.gz\")\n                .versionAsInProject();\n\n        MavenUrlReference routerRepo = maven()\n                .groupId(\"org.apache.unomi\")\n                .artifactId(\"unomi-router-karaf-feature\")\n                .classifier(\"features\")\n                .type(\"xml\")\n                .versionAsInProject();\n\n        List<Option> options = new ArrayList<>();\n\n        Option[] commonOptions = new Option[]{\n                karafDistributionConfiguration()\n                        .frameworkUrl(karafUrl)\n                        .unpackDirectory(new File(KARAF_DIR))\n                        .useDeployFolder(true),\n                replaceConfigurationFile(\"etc/org.apache.unomi.router.cfg\", new File(\n                        \"src/test/resources/org.apache.unomi.router.cfg\")),\n                replaceConfigurationFile(\"data/tmp/1-basic-test.csv\", new File(\n                        \"src/test/resources/1-basic-test.csv\")),\n                replaceConfigurationFile(\"data/tmp/recurrent_import/2-surfers-test.csv\", new File(\n                        \"src/test/resources/2-surfers-test.csv\")),\n                replaceConfigurationFile(\"data/tmp/recurrent_import/3-surfers-overwrite-test.csv\", new File(\n                        \"src/test/resources/3-surfers-overwrite-test.csv\")),\n                replaceConfigurationFile(\"data/tmp/recurrent_import/4-surfers-delete-test.csv\", new File(\n                        \"src/test/resources/4-surfers-delete-test.csv\")),\n                replaceConfigurationFile(\"data/tmp/recurrent_import/5-ranking-test.csv\", new File(\n                        \"src/test/resources/5-ranking-test.csv\")),\n                replaceConfigurationFile(\"data/tmp/recurrent_import/6-actors-test.csv\", new File(\n                        \"src/test/resources/6-actors-test.csv\")),\n                replaceConfigurationFile(\"data/tmp/testLogin.json\", new File(\n                        \"src/test/resources/testLogin.json\")),\n                replaceConfigurationFile(\"data/tmp/testLoginEventCondition.json\", new File(\n                        \"src/test/resources/testLoginEventCondition.json\")),\n                keepRuntimeFolder(),\n                logLevel(LogLevel.INFO),\n                editConfigurationFilePut(\"etc/org.ops4j.pax.logging.cfg\", \"log4j2.rootLogger.level\", \"INFO\"),\n                editConfigurationFilePut(\"etc/org.apache.karaf.features.cfg\", \"serviceRequirements\", \"disable\"),\n                systemProperty(\"org.ops4j.pax.exam.rbc.rmi.port\").value(\"1199\"),\n                systemProperty(\"org.apache.unomi.itests.elasticsearch.transport.port\").value(\"9500\"),\n                systemProperty(\"org.apache.unomi.itests.elasticsearch.cluster.name\").value(\"contextElasticSearchITests\"),\n                systemProperty(\"org.apache.unomi.itests.elasticsearch.http.port\").value(\"9400\"),\n                systemProperty(\"org.apache.unomi.itests.elasticsearch.bootstrap.seccomp\").value(\"false\"),\n                systemProperty(\"org.apache.unomi.hazelcast.group.name\").value(\"cellar\"),\n                systemProperty(\"org.apache.unomi.hazelcast.group.password\").value(\"pass\"),\n                systemProperty(\"org.apache.unomi.hazelcast.network.port\").value(\"5701\"),\n                systemProperty(\"org.apache.unomi.hazelcast.tcp-ip.members\").value(\"127.0.0.1\"),\n                systemProperty(\"org.apache.unomi.hazelcast.tcp-ip.interface\").value(\"127.0.0.1\"),\n                systemProperty(\"unomi.autoStart\").value(\"true\"),\n                features(routerRepo, \"unomi-router-karaf-feature\"),\n                CoreOptions.bundleStartLevel(100),\n                CoreOptions.frameworkStartLevel(100)\n        };\n\n        options.addAll(Arrays.asList(commonOptions));\n\n        String karafDebug = System.getProperty(\"it.karaf.debug\");\n        if (karafDebug != null) {\n            System.out.println(\"Found system Karaf Debug system property, activating configuration: \" + karafDebug);\n            String port = \"5006\";\n            boolean hold = true;\n            if (karafDebug.trim().length() > 0) {\n                String[] debugOptions = karafDebug.split(\",\");\n                for (String debugOption : debugOptions) {\n                    String[] debugOptionParts = debugOption.split(\":\");\n                    if (\"hold\".equals(debugOptionParts[0])) {\n                        hold = Boolean.parseBoolean(debugOptionParts[1].trim());\n// fix_end\n// fix_start\n                    if (\"port\".equals(debugOptionParts[0])) {\n                        port = debugOptionParts[1].trim();\n                    }\n// fix_end\n// fix_start\n            options.add(0, debugConfiguration(port, hold));\n// fix_end\n// fix_start\n\n        if (JavaVersionUtil.getMajorVersion() >= 9) {\n            Option[] jdk9PlusOptions = new Option[]{\n                    new VMOption(\"--add-reads=java.xml=java.logging\"),\n                    new VMOption(\"--add-exports=java.base/org.apache.karaf.specs.locator=java.xml,ALL-UNNAMED\"),\n                    new VMOption(\"--patch-module\"),\n                    new VMOption(\"java.base=lib/endorsed/org.apache.karaf.specs.locator-\"\n                            + System.getProperty(\"karaf.version\") + \".jar\"),\n                    new VMOption(\"--patch-module\"), new VMOption(\"java.xml=lib/endorsed/org.apache.karaf.specs.java.xml-\"\n                    + System.getProperty(\"karaf.version\") + \".jar\"),\n                    new VMOption(\"--add-opens\"),\n                    new VMOption(\"java.base/java.security=ALL-UNNAMED\"),\n                    new VMOption(\"--add-opens\"),\n                    new VMOption(\"java.base/java.net=ALL-UNNAMED\"),\n                    new VMOption(\"--add-opens\"),\n                    new VMOption(\"java.base/java.lang=ALL-UNNAMED\"),\n                    new VMOption(\"--add-opens\"),\n                    new VMOption(\"java.base/java.util=ALL-UNNAMED\"),\n                    new VMOption(\"--add-opens\"),\n                    new VMOption(\"java.naming/javax.naming.spi=ALL-UNNAMED\"),\n                    new VMOption(\"--add-opens\"),\n                    new VMOption(\"java.rmi/sun.rmi.transport.tcp=ALL-UNNAMED\"),\n                    new VMOption(\"--add-exports=java.base/sun.net.www.protocol.http=ALL-UNNAMED\"),\n                    new VMOption(\"--add-exports=java.base/sun.net.www.protocol.https=ALL-UNNAMED\"),\n                    new VMOption(\"--add-exports=java.base/sun.net.www.protocol.jar=ALL-UNNAMED\"),\n                    new VMOption(\"--add-exports=jdk.naming.rmi/com.sun.jndi.url.rmi=ALL-UNNAMED\"),\n                    new VMOption(\"-classpath\"),\n                    new VMOption(\"lib/jdk9plus/*\" + File.pathSeparator + \"lib/boot/*\")\n\n            };\n            options.addAll(Arrays.asList(jdk9PlusOptions));\n        }\n\n        return options.toArray(new Option[0]);\n// fix_end\n", "cwe": "NVD-CWE-noinfo", "cwe_name": "", "idx": 99569}
{"source": " public Object extractValue(String strVal)\n    {\n       if (strVal == null)\n       {\n          if (defaultValue == null)\n          {\n             if (!StringToPrimitive.isPrimitive(baseType)) return null;\n             else\n                return StringToPrimitive.stringToPrimitiveBoxType(baseType, strVal);\n          }\n          else\n          {\n             strVal = defaultValue;\n          }\n       }\n       if (paramConverter != null)\n       {\n          try {\n             return paramConverter.fromString(strVal);\n          } catch (Exception pce) {\n             throwProcessingException(Messages.MESSAGES.unableToExtractParameter(\n                     getParamSignature(), strVal, target), pce);\n          }\n       }\n       if (unmarshaller != null)\n       {\n          try {\n          return unmarshaller.fromString(strVal);\n          } catch (Exception ue) {\n             throwProcessingException(Messages.MESSAGES.unableToExtractParameter(\n                     getParamSignature(), strVal, target), ue);\n          }\n       }\n       else if (delegate != null)\n       {\n          try {\n             return delegate.fromString(strVal);\n          } catch (Exception pce) {\n             throwProcessingException(Messages.MESSAGES.unableToExtractParameter(\n                     getParamSignature(), strVal, target), pce);\n          }\n       }\n       else if (constructor != null)\n       {\n          try\n          {\n             return constructor.newInstance(strVal);\n          }\n          catch (InstantiationException e)\n          {\n// bug_start\n            throwProcessingException(Messages.MESSAGES.unableToExtractParameter(getParamSignature(), strVal, target), e);\n// bug_end\n          }\n          catch (IllegalAccessException e)\n          {\n// bug_start\n            throwProcessingException(Messages.MESSAGES.unableToExtractParameter(getParamSignature(), strVal, target), e);\n// bug_end\n          }\n          catch (InvocationTargetException e)\n          {\n             Throwable targetException = e.getTargetException();\n             if (targetException instanceof WebApplicationException)\n             {\n                throw ((WebApplicationException)targetException);\n             }\n// bug_start\n            throwProcessingException(Messages.MESSAGES.unableToExtractParameter(getParamSignature(), strVal, target), targetException);\n// bug_end\n          }\n       }\n       else if (valueOf != null)\n       {\n          try\n          {\n             return valueOf.invoke(null, strVal);\n          }\n          catch (IllegalAccessException e)\n          {\n// bug_start\n            throwProcessingException(Messages.MESSAGES.unableToExtractParameter(getParamSignature(), strVal, target), e);\n// bug_end\n          }\n          catch (InvocationTargetException e)\n          {\n             Throwable targetException = e.getTargetException();\n             if (targetException instanceof WebApplicationException)\n             {\n                throw ((WebApplicationException)targetException);\n             }\n// bug_start\n            throwProcessingException(Messages.MESSAGES.unableToExtractParameter(getParamSignature(), strVal, target), targetException);\n// bug_end\n          }\n       }\n       try\n       {\n          if (StringToPrimitive.isPrimitive(baseType)) return StringToPrimitive.stringToPrimitiveBoxType(baseType, strVal);\n       }\n       catch (Exception e)\n       {\n// bug_start\n         throwProcessingException(Messages.MESSAGES.unableToExtractParameter(getParamSignature(), strVal, target), e);\n// bug_end\n       }\n       return null;\n    }\n \n", "target": "// fix_start\n            throwProcessingException(Messages.MESSAGES.unableToExtractParameter(getParamSignature(), _encode(strVal), target), e);\n// fix_end\n// fix_start\n            throwProcessingException(Messages.MESSAGES.unableToExtractParameter(getParamSignature(), _encode(strVal), target), e);\n// fix_end\n// fix_start\n            throwProcessingException(Messages.MESSAGES.unableToExtractParameter(getParamSignature(), _encode(strVal), target), targetException);\n// fix_end\n// fix_start\n            throwProcessingException(Messages.MESSAGES.unableToExtractParameter(getParamSignature(), _encode(strVal), target), e);\n// fix_end\n// fix_start\n            throwProcessingException(Messages.MESSAGES.unableToExtractParameter(getParamSignature(), _encode(strVal), target), targetException);\n// fix_end\n// fix_start\n         throwProcessingException(Messages.MESSAGES.unableToExtractParameter(getParamSignature(), _encode(strVal), target), e);\n// fix_end\n", "cwe": "CWE-79", "cwe_name": "Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')", "idx": 79886}
{"source": " public boolean matchesPassword(String password) {\n// bug_start\n        return  getApiTokenInsecure().equals(password);\n// bug_end\n     }\n \n", "target": "// fix_start\n        String token = getApiTokenInsecure();\n        return MessageDigest.isEqual(password.getBytes(), token.getBytes());\n// fix_end\n", "cwe": "CWE-200", "cwe_name": "Exposure of Sensitive Information to an Unauthorized Actor", "idx": 14794}
{"source": " private void processParameters(byte bytes[], int start, int len,\n                                   Charset charset) {\n \n         if(log.isDebugEnabled()) {\n             try {\n                 log.debug(sm.getString(\"parameters.bytes\",\n                         new String(bytes, start, len, DEFAULT_CHARSET.name())));\n             } catch (UnsupportedEncodingException uee) {\n             }\n         }\n \n         int decodeFailCount = 0;\n \n         int pos = start;\n         int end = start + len;\n \n         while(pos < end) {\n             parameterCount ++;\n \n             if (limit > -1 && parameterCount >= limit) {\n                 parseFailed = true;\n                 log.warn(sm.getString(\"parameters.maxCountFail\",\n                         Integer.toString(limit)));\n                 break;\n             }\n             int nameStart = pos;\n             int nameEnd = -1;\n             int valueStart = -1;\n             int valueEnd = -1;\n \n             boolean parsingName = true;\n             boolean decodeName = false;\n             boolean decodeValue = false;\n             boolean parameterComplete = false;\n \n             do {\n                 switch(bytes[pos]) {\n                     case '=':\n                         if (parsingName) {\n                             nameEnd = pos;\n                             parsingName = false;\n                             valueStart = ++pos;\n                         } else {\n                             pos++;\n                         }\n                         break;\n                     case '&':\n                         if (parsingName) {\n                             nameEnd = pos;\n                         } else {\n                             valueEnd  = pos;\n                         }\n                         parameterComplete = true;\n                         pos++;\n                         break;\n                     case '%':\n                     case '+':\n                         if (parsingName) {\n                             decodeName = true;\n                         } else {\n                             decodeValue = true;\n                         }\n                         pos ++;\n                         break;\n                     default:\n                         pos ++;\n                         break;\n                 }\n             } while (!parameterComplete && pos < end);\n \n             if (pos == end) {\n                 if (nameEnd == -1) {\n                     nameEnd = pos;\n                 } else if (valueStart > -1 && valueEnd == -1){\n                     valueEnd = pos;\n                 }\n             }\n \n             if (log.isDebugEnabled() && valueStart == -1) {\n                 try {\n                     log.debug(sm.getString(\"parameters.noequal\",\n                             Integer.toString(nameStart),\n                             Integer.toString(nameEnd),\n                             new String(bytes, nameStart, nameEnd-nameStart,\n                                     DEFAULT_CHARSET.name())));\n                 } catch (UnsupportedEncodingException uee) {\n                 }\n             }\n \n             if (nameEnd <= nameStart ) {\n                 if (log.isInfoEnabled()) {\n                     if (valueEnd >= nameStart && log.isDebugEnabled()) {\n                         String extract = null;\n                         try {\n                             extract = new String(bytes, nameStart,\n                                     valueEnd - nameStart,\n                                     DEFAULT_CHARSET.name());\n                         } catch (UnsupportedEncodingException uee) {\n                         }\n                         log.info(sm.getString(\"parameters.invalidChunk\",\n                                 Integer.toString(nameStart),\n                                 Integer.toString(valueEnd),\n                                 extract));\n                     } else {\n                         log.info(sm.getString(\"parameters.invalidChunk\",\n                                 Integer.toString(nameStart),\n                                 Integer.toString(nameEnd),\n                                 null));\n                     }\n                 }\n                 parseFailed = true;\n                 continue;\n             }\n \n             tmpName.setBytes(bytes, nameStart, nameEnd - nameStart);\n             tmpValue.setBytes(bytes, valueStart, valueEnd - valueStart);\n \n             if (log.isDebugEnabled()) {\n                 try {\n                     origName.append(bytes, nameStart, nameEnd - nameStart);\n                     origValue.append(bytes, valueStart, valueEnd - valueStart);\n                 } catch (IOException ioe) {\n// bug_start\n                    log.error(sm.getString(\"paramerers.copyFail\"), ioe);\n// bug_end\n                 }\n             }\n \n             try {\n                 String name;\n                 String value;\n \n                 if (decodeName) {\n                     urlDecode(tmpName);\n                 }\n                 tmpName.setCharset(charset);\n                 name = tmpName.toString();\n \n                 if (decodeValue) {\n                     urlDecode(tmpValue);\n                 }\n                 tmpValue.setCharset(charset);\n                 value = tmpValue.toString();\n \n                 addParam(name, value);\n             } catch (IOException e) {\n                 parseFailed = true;\n                 decodeFailCount++;\n                 if (decodeFailCount == 1 || log.isDebugEnabled()) {\n                     if (log.isDebugEnabled()) {\n                         log.debug(sm.getString(\"parameters.decodeFail.debug\",\n                                 origName.toString(), origValue.toString()), e);\n                     } else if (log.isInfoEnabled()) {\n                         log.info(sm.getString(\"parameters.decodeFail.info\",\n                                 tmpName.toString(), tmpValue.toString()), e);\n                     }\n                 }\n             }\n \n             tmpName.recycle();\n             tmpValue.recycle();\n             if (log.isDebugEnabled()) {\n                 origName.recycle();\n                 origValue.recycle();\n             }\n         }\n \n         if (decodeFailCount > 1 && !log.isDebugEnabled()) {\n             log.info(sm.getString(\"parameters.multipleDecodingFail\",\n                     Integer.toString(decodeFailCount)));\n         }\n     }\n \n", "target": "// fix_start\n                    log.error(sm.getString(\"parameters.copyFail\"), ioe);\n// fix_end\n", "cwe": "CWE-189", "cwe_name": "Numeric Errors", "idx": 2866}
{"source": " public static String javaScriptEscape(String input) {\n \t\tif (input == null) {\n \t\t\treturn input;\n \t\t}\n \n \t\tStringBuilder filtered = new StringBuilder(input.length());\n \t\tchar prevChar = '\\u0000';\n \t\tchar c;\n \t\tfor (int i = 0; i < input.length(); i++) {\n \t\t\tc = input.charAt(i);\n \t\t\tif (c == '\"') {\n \t\t\t\tfiltered.append(\"\\\\\\\"\");\n \t\t\t}\n \t\t\telse if (c == '\\'') {\n \t\t\t\tfiltered.append(\"\\\\'\");\n \t\t\t}\n \t\t\telse if (c == '\\\\') {\n \t\t\t\tfiltered.append(\"\\\\\\\\\");\n \t\t\t}\n \t\t\telse if (c == '/') {\n \t\t\t\tfiltered.append(\"\\\\/\");\n \t\t\t}\n \t\t\telse if (c == '\\t') {\n \t\t\t\tfiltered.append(\"\\\\t\");\n \t\t\t}\n \t\t\telse if (c == '\\n') {\n \t\t\t\tif (prevChar != '\\r') {\n \t\t\t\t\tfiltered.append(\"\\\\n\");\n \t\t\t\t}\n \t\t\t}\n \t\t\telse if (c == '\\r') {\n \t\t\t\tfiltered.append(\"\\\\n\");\n \t\t\t}\n \t\t\telse if (c == '\\f') {\n \t\t\t\tfiltered.append(\"\\\\f\");\n \t\t\t}\n// bug_start\n// bug_end\n \t\t\telse {\n \t\t\t\tfiltered.append(c);\n \t\t\t}\n \t\t\tprevChar = c;\n \n \t\t}\n \t\treturn filtered.toString();\n \t}\n \n", "target": "// fix_start\n\t\t\telse if (c == '\\b') {\n\t\t\t\tfiltered.append(\"\\\\b\");\n\t\t\t}\n\t\t\telse if (c == '\\013') {\n\t\t\t\tfiltered.append(\"\\\\v\");\n\t\t\t}\n\t\t\telse if (c == '<') {\n\t\t\t\tfiltered.append(\"\\\\u003C\");\n\t\t\t}\n\t\t\telse if (c == '>') {\n\t\t\t\tfiltered.append(\"\\\\u003E\");\n\t\t\t}\n\t\t\telse if (c == '\\u2028') {\n\t\t\t\tfiltered.append(\"\\\\u2028\");\n\t\t\t}\n\t\t\telse if (c == '\\u2029') {\n\t\t\t\tfiltered.append(\"\\\\u2029\");\n\t\t\t}\n// fix_end\n", "cwe": "CWE-79", "cwe_name": "Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')", "idx": 79726}
{"source": " public void save(String comment, boolean minorEdit) throws XWikiException\n     {\n         if (hasAccessLevel(\"edit\")) {\n// bug_start\n            if (hasProgrammingRights()) {\n// bug_end\n                 saveDocument(comment, minorEdit);\n             } else {\n                 saveAsAuthor(comment, minorEdit);\n             }\n         } else {\n             java.lang.Object[] args = {getDefaultEntityReferenceSerializer().serialize(getDocumentReference())};\n             throw new XWikiException(XWikiException.MODULE_XWIKI_ACCESS, XWikiException.ERROR_XWIKI_ACCESS_DENIED,\n                 \"Access denied in edit mode on document {0}\", null, args);\n         }\n     }\n \n", "target": "// fix_start\n            if (hasProgrammingRights() || !getConfiguration().getProperty(\"security.script.save.checkAuthor\", true)) {\n// fix_end\n", "cwe": "CWE-863", "cwe_name": "Incorrect Authorization", "idx": 90340}
{"source": " public SecurityWebFilterChain build() {\n \t\tif(this.built != null) {\n \t\t\tthrow new IllegalStateException(\"This has already been built with the following stacktrace. \" + buildToString());\n \t\t}\n \t\tthis.built = new RuntimeException(\"First Build Invocation\").fillInStackTrace();\n \t\tif(this.headers != null) {\n \t\t\tthis.headers.configure(this);\n \t\t}\n \t\tWebFilter securityContextRepositoryWebFilter = securityContextRepositoryWebFilter();\n \t\tif(securityContextRepositoryWebFilter != null) {\n \t\t\tthis.webFilters.add(securityContextRepositoryWebFilter);\n \t\t}\n \t\tif(this.csrf != null) {\n \t\t\tthis.csrf.configure(this);\n \t\t}\n \t\tif(this.httpBasic != null) {\n \t\t\tthis.httpBasic.authenticationManager(this.authenticationManager);\n \t\t\tthis.httpBasic.configure(this);\n \t\t}\n \t\tif(this.formLogin != null) {\n \t\t\tthis.formLogin.authenticationManager(this.authenticationManager);\n \t\t\tif(this.securityContextRepository != null) {\n \t\t\t\tthis.formLogin.securityContextRepository(this.securityContextRepository);\n \t\t\t}\n \t\t\tif(this.formLogin.authenticationEntryPoint == null) {\n \t\t\t\tthis.webFilters.add(new OrderedWebFilter(new LoginPageGeneratingWebFilter(), SecurityWebFiltersOrder.LOGIN_PAGE_GENERATING.getOrder()));\n \t\t\t\tthis.webFilters.add(new OrderedWebFilter(new LogoutPageGeneratingWebFilter(), SecurityWebFiltersOrder.LOGOUT_PAGE_GENERATING.getOrder()));\n \t\t\t}\n \t\t\tthis.formLogin.configure(this);\n \t\t}\n \t\tif(this.logout != null) {\n \t\t\tthis.logout.configure(this);\n \t\t}\n \t\tthis.requestCache.configure(this);\n \t\tthis.addFilterAt(new SecurityContextServerWebExchangeWebFilter(), SecurityWebFiltersOrder.SECURITY_CONTEXT_SERVER_WEB_EXCHANGE);\n \t\tif(this.authorizeExchange != null) {\n \t\t\tServerAuthenticationEntryPoint authenticationEntryPoint = getAuthenticationEntryPoint();\n \t\t\tExceptionTranslationWebFilter exceptionTranslationWebFilter = new ExceptionTranslationWebFilter();\n \t\t\tif(authenticationEntryPoint != null) {\n \t\t\t\texceptionTranslationWebFilter.setAuthenticationEntryPoint(\n \t\t\t\t\tauthenticationEntryPoint);\n \t\t\t}\n// bug_start\n// bug_end\n \t\t\tthis.addFilterAt(exceptionTranslationWebFilter, SecurityWebFiltersOrder.EXCEPTION_TRANSLATION);\n \t\t\tthis.authorizeExchange.configure(this);\n \t\t}\n \t\tAnnotationAwareOrderComparator.sort(this.webFilters);\n \t\tList<WebFilter> sortedWebFilters = new ArrayList<>();\n \t\tthis.webFilters.forEach( f -> {\n \t\t\tif(f instanceof OrderedWebFilter) {\n \t\t\t\tf = ((OrderedWebFilter) f).webFilter;\n \t\t\t}\n \t\t\tsortedWebFilters.add(f);\n \t\t});\n \t\treturn new MatcherSecurityWebFilterChain(getSecurityMatcher(), sortedWebFilters);\n \t}\n \n", "target": "// fix_start\n\t\t\tif(accessDeniedHandler != null) {\n\t\t\t\texceptionTranslationWebFilter.setAccessDeniedHandler(accessDeniedHandler);\n\t\t\t}\n// fix_end\n", "cwe": "CWE-863", "cwe_name": "Incorrect Authorization", "idx": 86265}
{"source": " @Override\n         public void handleEvent(StreamConnection channel) {\n             final Map<String, String> headers = new HashMap<String, String>();\n             headers.put(UPGRADE, \"jboss-remoting\");\n             final String secKey = createSecKey();\n             headers.put(SEC_JBOSS_REMOTING_KEY, secKey);\n \n             IoFuture<T> upgradeFuture = HttpUpgrade.performUpgrade(type.cast(channel), uri, headers, upgradeChannel -> {\n                 ChannelListeners.invokeChannelListener(upgradeChannel, openListener);\n             }, new RemotingHandshakeChecker(secKey));\n// bug_start\n// bug_end\n             upgradeFuture.addNotifier( new IoFuture.HandlingNotifier<T, FutureResult<T>>() {\n \n                 @Override\n                 public void handleCancelled(FutureResult<T> attachment) {\n                     attachment.setCancelled();\n                 }\n \n                 @Override\n                 public void handleFailed(IOException exception, FutureResult<T> attachment) {\n                     attachment.setException(exception);\n                 }\n \n                 @Override\n                 public void handleDone(T data, FutureResult<T> attachment) {\n                     attachment.setResult(data);\n                 }\n \n             }, futureResult);\n         }\n \n", "target": "// fix_start\n\n            futureResult.addCancelHandler(new Cancellable() {\n                @Override\n                public Cancellable cancel() {\n                    if (channel.isOpen()) {\n                        safeClose(channel);\n                    }\n                    return this;\n                }\n            });\n\n// fix_end\n", "cwe": "CWE-400", "cwe_name": "Uncontrolled Resource Consumption", "idx": 52678}
{"source": " @Override\n     public void aroundWriteTo(WriterInterceptorContext context) throws IOException, WebApplicationException {\n         String function = uri.getQueryParameters().getFirst(callbackQueryParameter);\n// bug_start\n        if (function != null && !function.trim().isEmpty() && !jsonpCompatibleMediaTypes.getPossible(context.getMediaType()).isEmpty()){\n// bug_end\n \n             OutputStreamWriter writer = new OutputStreamWriter(context.getOutputStream());\n \n             if (wrapInTryCatch) writer.write(\"try{\");\n             writer.write(function + \"(\");\n             writer.flush();\n \n             OutputStream old = context.getOutputStream();\n             DoNotCloseDelegateOutputStream wrappedOutputStream = new DoNotCloseDelegateOutputStream(old);\n             context.setOutputStream(wrappedOutputStream);\n \n             try {\n                 context.proceed();\n                 wrappedOutputStream.flush();\n                 writer.write(\")\");\n                 if (wrapInTryCatch) writer.write(\"}catch(e){}\");\n                 writer.flush();\n             } finally {\n                 context.setOutputStream(old);\n             }\n         } else {\n             context.proceed();\n         }\n     }\n \n", "target": "// fix_start\n        if (enabled && function != null && !function.trim().isEmpty() && !jsonpCompatibleMediaTypes.getPossible(context.getMediaType()).isEmpty()){\n// fix_end\n", "cwe": "CWE-79", "cwe_name": "Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')", "idx": 79861}
{"source": " @Override\n     public void setupRoutes() {\n         path(controllerBasePath(), () -> {\n             before(\"\", mimeType, this::setContentType);\n// bug_start\n\n// bug_end\n \n             before(\"\", mimeType, this.apiAuthenticationHelper::checkAdminUserAnd403);\n \n             get(\"\", mimeType, this::show);\n \n             post(\"\", mimeType, this::createOrUpdate);\n             put(\"\", mimeType, this::createOrUpdate);\n \n             delete(\"\", mimeType, this::deleteBackupConfig);\n         });\n     }\n \n", "target": "// fix_start\n            before(\"/*\", mimeType, this::setContentType);\n            before(\"\", mimeType, this::verifyContentType);\n            before(\"/*\", mimeType, this::verifyContentType);\n// fix_end\n", "cwe": "CWE-352", "cwe_name": "Cross-Site Request Forgery (CSRF)", "idx": 43965}
{"source": " @Override\n     public String encodeForJSString(String source) {\n// bug_start\n        return source == null ? null : Encode.forJavaScriptSource(source);\n// bug_end\n     }\n \n", "target": "// fix_start\n        return source == null ? null : Encode.forJavaScript(source).replace(\"\\\\-\", \"\\\\u002D\");\n// fix_end\n", "cwe": "CWE-79", "cwe_name": "Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')", "idx": 77620}
{"source": " public void processPacket(Packet packet)\n         {\n             if(!(packet instanceof org.jivesoftware.smack.packet.Message))\n                 return;\n \n             org.jivesoftware.smack.packet.Message msg =\n                 (org.jivesoftware.smack.packet.Message)packet;\n \n             boolean isForwardedSentMessage = false;\n             if(msg.getBody() == null)\n             {\n \n                 CarbonPacketExtension carbonExt\n                     = (CarbonPacketExtension) msg.getExtension(\n                         CarbonPacketExtension.NAMESPACE);\n                 if(carbonExt == null)\n                     return;\n \n                 isForwardedSentMessage\n                     = (carbonExt.getElementName()\n                         == CarbonPacketExtension.SENT_ELEMENT_NAME);\n                 List<ForwardedPacketExtension> extensions\n                     = carbonExt.getChildExtensionsOfType(\n                         ForwardedPacketExtension.class);\n                 if(extensions.isEmpty())\n                     return;\n// bug_start\n// bug_end\n                 ForwardedPacketExtension forwardedExt = extensions.get(0);\n                 msg = forwardedExt.getMessage();\n                 if(msg == null || msg.getBody() == null)\n                     return;\n \n             }\n \n             Object multiChatExtension =\n                 msg.getExtension(\"x\", \"http://jabber.org/protocol/muc#user\");\n \n             if(multiChatExtension != null)\n                 return;\n \n             String userFullId\n                 = isForwardedSentMessage? msg.getTo() : msg.getFrom();\n \n             String userBareID = StringUtils.parseBareAddress(userFullId);\n \n             boolean isPrivateMessaging = false;\n             ChatRoom privateContactRoom = null;\n             OperationSetMultiUserChatJabberImpl mucOpSet =\n                 (OperationSetMultiUserChatJabberImpl)jabberProvider\n                     .getOperationSet(OperationSetMultiUserChat.class);\n             if(mucOpSet != null)\n                 privateContactRoom = mucOpSet.getChatRoom(userBareID);\n \n             if(privateContactRoom != null)\n             {\n                 isPrivateMessaging = true;\n             }\n \n             if(logger.isDebugEnabled())\n             {\n                 if (logger.isDebugEnabled())\n                     logger.debug(\"Received from \"\n                              + userBareID\n                              + \" the message \"\n                              + msg.toXML());\n             }\n \n             Message newMessage = createMessage(msg.getBody(),\n                     DEFAULT_MIME_TYPE, msg.getPacketID());\n \n             PacketExtension ext = msg.getExtension(\n                             \"http://jabber.org/protocol/xhtml-im\");\n \n             if(ext != null)\n             {\n                 XHTMLExtension xhtmlExt\n                     = (XHTMLExtension)ext;\n \n                 Iterator<String> bodies = xhtmlExt.getBodies();\n                 StringBuffer messageBuff = new StringBuffer();\n                 while (bodies.hasNext())\n                 {\n                     String body = bodies.next();\n                     messageBuff.append(body);\n                 }\n \n                 if (messageBuff.length() > 0)\n                 {\n                     String receivedMessage =\n                         messageBuff.toString()\n                         .replaceAll(\"\\\\<[bB][oO][dD][yY].*?>\",\"\")\n                         .replaceAll(\"\\\\</[bB][oO][dD][yY].*?>\",\"\");\n \n                     receivedMessage =\n                             receivedMessage.replaceAll(\"&apos;\", \"&#39;\");\n \n                     newMessage = createMessage(receivedMessage,\n                             HTML_MIME_TYPE, msg.getPacketID());\n                 }\n             }\n \n             PacketExtension correctionExtension =\n                     msg.getExtension(MessageCorrectionExtension.NAMESPACE);\n             String correctedMessageUID = null;\n             if (correctionExtension != null)\n             {\n                 correctedMessageUID = ((MessageCorrectionExtension)\n                         correctionExtension).getCorrectedMessageUID();\n             }\n \n             Contact sourceContact\n                 = opSetPersPresence.findContactByID(\n                     (isPrivateMessaging? userFullId : userBareID));\n             if(msg.getType()\n                             == org.jivesoftware.smack.packet.Message.Type.error)\n             {\n                 if(isPrivateMessaging && sourceContact == null)\n                 {\n                     if(privateContactRoom != null)\n                     {\n                         XMPPError error = packet.getError();\n                         int errorResultCode\n                             = ChatRoomMessageDeliveryFailedEvent.UNKNOWN_ERROR;\n \n                         if(error != null && error.getCode() == 403)\n                         {\n                             errorResultCode\n                                 = ChatRoomMessageDeliveryFailedEvent.FORBIDDEN;\n                         }\n \n                         String errorReason = error.getMessage();\n \n                         ChatRoomMessageDeliveryFailedEvent evt =\n                             new ChatRoomMessageDeliveryFailedEvent(\n                                 privateContactRoom,\n                                 null,\n                                 errorResultCode,\n                                 errorReason,\n                                 new Date(),\n                                 newMessage);\n                         ((ChatRoomJabberImpl)privateContactRoom)\n                             .fireMessageEvent(evt);\n                     }\n \n                     return;\n                 }\n \n                 if (logger.isInfoEnabled())\n                     logger.info(\"Message error received from \" + userBareID);\n \n                 int errorResultCode = MessageDeliveryFailedEvent.UNKNOWN_ERROR;\n                 if (packet.getError() != null)\n                 {\n                     int errorCode = packet.getError().getCode();\n \n                     if(errorCode == 503)\n                     {\n                         org.jivesoftware.smackx.packet.MessageEvent msgEvent =\n                             (org.jivesoftware.smackx.packet.MessageEvent)\n                                 packet.getExtension(\"x\", \"jabber:x:event\");\n                         if(msgEvent != null && msgEvent.isOffline())\n                         {\n                             errorResultCode =\n                                 MessageDeliveryFailedEvent\n                                     .OFFLINE_MESSAGES_NOT_SUPPORTED;\n                         }\n                     }\n                 }\n \n                 if (sourceContact == null)\n                 {\n                     sourceContact = opSetPersPresence.createVolatileContact(\n                         userFullId, isPrivateMessaging);\n                 }\n \n                 MessageDeliveryFailedEvent ev\n                     = new MessageDeliveryFailedEvent(newMessage,\n                                                      sourceContact,\n                                                      correctedMessageUID,\n                                                      errorResultCode);\n \n \n                 if (ev != null)\n                     fireMessageEvent(ev);\n                 return;\n             }\n             putJidForAddress(userFullId, msg.getThread());\n \n             if(sourceContact == null)\n             {\n                 if (logger.isDebugEnabled())\n                     logger.debug(\"received a message from an unknown contact: \"\n                                    + userBareID);\n                 sourceContact = opSetPersPresence\n                     .createVolatileContact(\n                         userFullId,\n                         isPrivateMessaging);\n             }\n \n             Date timestamp = new Date();\n             PacketExtension delay = msg.getExtension(\"x\", \"jabber:x:delay\");\n             if(delay != null && delay instanceof DelayInformation)\n             {\n                 timestamp = ((DelayInformation)delay).getStamp();\n             }\n             delay = msg.getExtension(\"delay\", \"urn:xmpp:delay\");\n             if(delay != null && delay instanceof DelayInfo)\n             {\n                 timestamp = ((DelayInfo)delay).getStamp();\n             }\n \n             ContactResource resource = ((ContactJabberImpl) sourceContact)\n                     .getResourceFromJid(userFullId);\n \n             EventObject msgEvt = null;\n             if(!isForwardedSentMessage)\n                 msgEvt\n                     = new MessageReceivedEvent( newMessage,\n                                                 sourceContact,\n                                                 resource,\n                                                 timestamp,\n                                                 correctedMessageUID,\n                                                 isPrivateMessaging,\n                                                 privateContactRoom);\n             else\n                 msgEvt = new MessageDeliveredEvent(newMessage, sourceContact, timestamp);\n             if (msgEvt != null)\n                 fireMessageEvent(msgEvt);\n         }\n \n", "target": "// fix_start\n\n                if (!msg.getFrom().equals(\n                        StringUtils.parseBareAddress(\n                            jabberProvider.getOurJID())))\n                {\n                    logger.info(\"Received a carbon copy with wrong from!\");\n                    return;\n                }\n\n// fix_end\n", "cwe": "CWE-20", "cwe_name": "Improper Input Validation", "idx": 11698}
{"source": " public QueryTargetPolicy getQueryTargetPolicyInstance() {\n         if (queryTargetPolicyPlugin.get() == null) {\n// bug_start\n            queryTargetPolicyPlugin.instantiate(ReplicationPolicy.class,\n// bug_end\n                     this, true);\n         }\n         return (QueryTargetPolicy) queryTargetPolicyPlugin.get();\n     }\n \n", "target": "// fix_start\n            queryTargetPolicyPlugin.instantiate(QueryTargetPolicy.class,\n// fix_end\n", "cwe": "CWE-264", "cwe_name": "Permissions, Privileges, and Access Controls", "idx": 33539}
{"source": " public static Document xmlText2GenericDom(InputStream is, Document emptyDoc)\n             throws SAXException, ParserConfigurationException, IOException\n     {\n// bug_start\n        SAXParserFactory factory = SAXParserFactory.newInstance();\n        factory.setNamespaceAware(true);\n\n        SAXParser parser = factory.newSAXParser();\n// bug_end\n \n         Sax2Dom handler = new Sax2Dom(emptyDoc);\n \n         parser.setProperty(\"http://xml.org/sax/properties/lexical-handler\", handler);\n         parser.parse(is, handler);\n \n         return (Document) handler.getDOM();\n     }\n \n", "target": "// fix_start\n        SAXParser parser = SAXHelper.saxFactory.newSAXParser();\n// fix_end\n", "cwe": "CWE-776", "cwe_name": "", "idx": 76387}
{"source": " @Override public SubversionChangeLogSet parse(@SuppressWarnings(\"rawtypes\") Run build, RepositoryBrowser<?> browser, File changelogFile) throws IOException, SAXException {\n \n         Digester digester = new Digester2();\n// bug_start\n// bug_end\n         ArrayList<LogEntry> r = new ArrayList<>();\n         digester.push(r);\n \n         digester.addObjectCreate(\"*/logentry\", LogEntry.class);\n         digester.addSetProperties(\"*/logentry\");\n         digester.addBeanPropertySetter(\"*/logentry/author\",\"user\");\n         digester.addBeanPropertySetter(\"*/logentry/date\");\n         digester.addBeanPropertySetter(\"*/logentry/msg\");\n         digester.addSetNext(\"*/logentry\",\"add\");\n \n         digester.addObjectCreate(\"*/logentry/paths/path\", Path.class);\n         digester.addSetProperties(\"*/logentry/paths/path\");\n         digester.addBeanPropertySetter(\"*/logentry/paths/path\",\"value\");\n         digester.addSetNext(\"*/logentry/paths/path\",\"addPath\");\n \n         try {\n             digester.parse(changelogFile);\n         } catch (IOException | SAXException e) {\n             throw new IOException(\"Failed to parse \" + changelogFile,e);\n         }\n \n         for (LogEntry e : r) {\n             e.finish();\n         }\n         return new SubversionChangeLogSet(build, browser, r, ignoreDirPropChanges);\n     }\n \n", "target": "// fix_start\n        if (!Boolean.getBoolean(SubversionChangeLogParser.class.getName() + \".UNSAFE\")) {\n            try {\n                digester.setFeature(\"http://apache.org/xml/features/disallow-doctype-decl\", true);\n                digester.setFeature(\"http://xml.org/sax/features/external-general-entities\", false);\n                digester.setFeature(\"http://xml.org/sax/features/external-parameter-entities\", false);\n                digester.setFeature(\"http://apache.org/xml/features/nonvalidating/load-external-dtd\", false);\n            } catch (ParserConfigurationException ex) {\n                LOGGER.log(Level.WARNING, \"Failed to securely configure Subversion changelog parser\", ex);\n                throw new SAXException(\"Failed to securely configure Subversion changelog parser\", ex);\n            }\n            digester.setXIncludeAware(false);\n        }\n// fix_end\n", "cwe": "CWE-611", "cwe_name": "Improper Restriction of XML External Entity Reference ('XXE')", "idx": 69713}
{"source": " private String getBodyContentAsString() {\n \t\tif (body == null) {\n \t\t\treturn null;\n \t\t}\n \t\ttry {\n \t\t\tString contentType = (messageProperties != null) ? messageProperties.getContentType() : null;\n \t\t\tif (MessageProperties.CONTENT_TYPE_SERIALIZED_OBJECT.equals(contentType)) {\n// bug_start\n\t\t\t\treturn SerializationUtils.deserialize(body).toString();\n// bug_end\n \t\t\t}\n \t\t\tif (MessageProperties.CONTENT_TYPE_TEXT_PLAIN.equals(contentType)\n \t\t\t\t\t|| MessageProperties.CONTENT_TYPE_JSON.equals(contentType)\n \t\t\t\t\t|| MessageProperties.CONTENT_TYPE_JSON_ALT.equals(contentType)\n \t\t\t\t\t|| MessageProperties.CONTENT_TYPE_XML.equals(contentType)) {\n \t\t\t\treturn new String(body, ENCODING);\n \t\t\t}\n \t\t}\n \t\tcatch (Exception e) {\n \t\t}\n \t\treturn body.toString()+\"(byte[\"+body.length+\"])\";\n \t}\n \n", "target": "// fix_start\n\t\t\t\treturn SERIALIZER_MESSAGE_CONVERTER.fromMessage(this).toString();\n// fix_end\n", "cwe": "CWE-502", "cwe_name": "Deserialization of Untrusted Data", "idx": 61698}
{"source": " public SSOValidatorResponse validateSamlResponse(\n         org.opensaml.saml.saml2.core.Response samlResponse,\n         boolean postBinding\n     ) throws WSSecurityException {\n         validateIssuer(samlResponse.getIssuer());\n \n         if (samlResponse.getAssertions() == null || samlResponse.getAssertions().isEmpty()) {\n             LOG.fine(\"The Response must contain at least one Assertion\");\n             throw new WSSecurityException(WSSecurityException.ErrorCode.FAILURE, \"invalidSAMLsecurity\");\n         }\n \n         String destination = samlResponse.getDestination();\n         if (samlResponse.isSigned()\n             && (destination == null || !destination.equals(assertionConsumerURL))) {\n             LOG.fine(\"The Response must contain a destination that matches the assertion consumer URL\");\n             throw new WSSecurityException(WSSecurityException.ErrorCode.FAILURE, \"invalidSAMLsecurity\");\n         }\n \n// bug_start\n        boolean foundValidSubject = false;\n// bug_end\n         Date sessionNotOnOrAfter = null;\n         for (org.opensaml.saml.saml2.core.Assertion assertion : samlResponse.getAssertions()) {\n             if (assertion.getIssuer() == null) {\n                 LOG.fine(\"Assertion Issuer must not be null\");\n                 throw new WSSecurityException(WSSecurityException.ErrorCode.FAILURE, \"invalidSAMLsecurity\");\n             }\n             validateIssuer(assertion.getIssuer());\n \n             if (enforceAssertionsSigned && postBinding && assertion.getSignature() == null) {\n                 LOG.fine(\"If the HTTP Post binding is used to deliver the Response, \"\n                          + \"the enclosed assertions must be signed\");\n                 throw new WSSecurityException(WSSecurityException.ErrorCode.FAILURE, \"invalidSAMLsecurity\");\n             }\n \n             if (assertion.getAuthnStatements() != null\n                 && !assertion.getAuthnStatements().isEmpty()) {\n                 org.opensaml.saml.saml2.core.Subject subject = assertion.getSubject();\n                 if (validateAuthenticationSubject(subject, assertion.getID(), postBinding)) {\n                     validateAudienceRestrictionCondition(assertion.getConditions());\n// bug_start\n                    foundValidSubject = true;\n// bug_end\n                     for (AuthnStatement authnStatment : assertion.getAuthnStatements()) {\n                         if (authnStatment.getSessionNotOnOrAfter() != null) {\n                             sessionNotOnOrAfter = authnStatment.getSessionNotOnOrAfter().toDate();\n                         }\n                     }\n                 }\n             }\n// bug_start\n\n// bug_end\n         }\n \n// bug_start\n        if (!foundValidSubject) {\n// bug_end\n             LOG.fine(\"The Response did not contain any Authentication Statement that matched \"\n                      + \"the Subject Confirmation criteria\");\n             throw new WSSecurityException(WSSecurityException.ErrorCode.FAILURE, \"invalidSAMLsecurity\");\n         }\n \n         SSOValidatorResponse validatorResponse = new SSOValidatorResponse();\n         validatorResponse.setResponseId(samlResponse.getID());\n         validatorResponse.setSessionNotOnOrAfter(sessionNotOnOrAfter);\n         if (samlResponse.getIssueInstant() != null) {\n             validatorResponse.setCreated(samlResponse.getIssueInstant().toDate());\n         }\n \n// bug_start\n        Element assertionElement = samlResponse.getAssertions().get(0).getDOM();\n// bug_end\n         Element clonedAssertionElement = (Element)assertionElement.cloneNode(true);\n         validatorResponse.setAssertionElement(clonedAssertionElement);\n         validatorResponse.setAssertion(DOM2Writer.nodeToString(clonedAssertionElement));\n \n         return validatorResponse;\n     }\n \n", "target": "// fix_start\n        org.opensaml.saml.saml2.core.Assertion validAssertion = null;\n// fix_end\n// fix_start\n                    validAssertion = assertion;\n// fix_end\n// fix_start\n// fix_end\n// fix_start\n        if (validAssertion == null) {\n// fix_end\n// fix_start\n        Element assertionElement = validAssertion.getDOM();\n// fix_end\n", "cwe": "CWE-264", "cwe_name": "Permissions, Privileges, and Access Controls", "idx": 33786}
{"source": " private State readHeaders(ByteBuf buffer) {\n         final HttpMessage message = this.message;\n         final HttpHeaders headers = message.headers();\n \n         AppendableCharSequence line = headerParser.parse(buffer);\n         if (line == null) {\n             return null;\n         }\n         if (line.length() > 0) {\n             do {\n                 char firstChar = line.charAtUnsafe(0);\n                 if (name != null && (firstChar == ' ' || firstChar == '\\t')) {\n                     String trimmedLine = line.toString().trim();\n                     String valueStr = String.valueOf(value);\n                     value = valueStr + ' ' + trimmedLine;\n                 } else {\n                     if (name != null) {\n                         headers.add(name, value);\n                     }\n                     splitHeader(line);\n                 }\n \n                 line = headerParser.parse(buffer);\n                 if (line == null) {\n                     return null;\n                 }\n             } while (line.length() > 0);\n         }\n \n         if (name != null) {\n             headers.add(name, value);\n         }\n// bug_start\n// bug_end\n         name = null;\n         value = null;\n \n// bug_start\n        State nextState;\n// bug_end\n \n         if (isContentAlwaysEmpty(message)) {\n             HttpUtil.setTransferEncodingChunked(message, false);\n// bug_start\n            nextState = State.SKIP_CONTROL_CHARS;\n// bug_end\n         } else if (HttpUtil.isTransferEncodingChunked(message)) {\n// bug_start\n            nextState = State.READ_CHUNK_SIZE;\n// bug_end\n         } else if (contentLength() >= 0) {\n// bug_start\n            nextState = State.READ_FIXED_LENGTH_CONTENT;\n// bug_end\n         } else {\n// bug_start\n            nextState = State.READ_VARIABLE_LENGTH_CONTENT;\n// bug_end\n         }\n// bug_start\n        return nextState;\n// bug_end\n     }\n \n", "target": "// fix_start\n\n// fix_end\n// fix_start\n        List<String> values = headers.getAll(HttpHeaderNames.CONTENT_LENGTH);\n        int contentLengthValuesCount = values.size();\n\n        if (contentLengthValuesCount > 0) {\n            if (contentLengthValuesCount > 1 && message.protocolVersion() == HttpVersion.HTTP_1_1) {\n                throw new IllegalArgumentException(\"Multiple Content-Length headers found\");\n            }\n            contentLength = Long.parseLong(values.get(0));\n        }\n// fix_end\n// fix_start\n            return State.SKIP_CONTROL_CHARS;\n// fix_end\n// fix_start\n            if (contentLengthValuesCount > 0 && message.protocolVersion() == HttpVersion.HTTP_1_1) {\n                throw new IllegalArgumentException(\n                        \"Both 'Content-Length: \" + contentLength + \"' and 'Transfer-Encoding: chunked' found\");\n            }\n\n            return State.READ_CHUNK_SIZE;\n// fix_end\n// fix_start\n            return State.READ_FIXED_LENGTH_CONTENT;\n// fix_end\n// fix_start\n            return State.READ_VARIABLE_LENGTH_CONTENT;\n// fix_end\n// fix_start\n// fix_end\n", "cwe": "CWE-444", "cwe_name": "Inconsistent Interpretation of HTTP Requests ('HTTP Request Smuggling')", "idx": 53933}
{"source": " public Map<String, FileEntry> generatorCode(TableDetails tableDetails, String tablePrefix,\n \t\t\tMap<String, String> customProperties, List<TemplateFile> templateFiles) {\n \n \t\tMap<String, FileEntry> map = new HashMap<>(templateFiles.size());\n \n \t\tMap<String, Object> context = GenUtils.getContext(tableDetails, tablePrefix, customProperties);\n \n \t\tfor (TemplateFile templateFile : templateFiles) {\n \t\t\tFileEntry fileEntry = new FileEntry();\n \t\t\tfileEntry.setType(templateFile.getType());\n \n// bug_start\n\t\t\tString filename = StrUtil.format(templateFile.getFilename(), context);\n// bug_end\n \t\t\tfileEntry.setFilename(filename);\n \n \t\t\tString parentFilePath = GenUtils.evaluateRealPath(templateFile.getParentFilePath(), context);\n \t\t\tfileEntry.setParentFilePath(parentFilePath);\n \n \t\t\tif (TemplateEntryTypeEnum.FILE.getType().equals(fileEntry.getType())) {\n// bug_start\n\t\t\t\tfileEntry.setFilePath(GenUtils.concatFilePath(parentFilePath, filename));\n// bug_end\n \t\t\t\tTemplateEngineTypeEnum engineTypeEnum = TemplateEngineTypeEnum.of(templateFile.getEngineType());\n// bug_start\n\t\t\t\tString content = templateEngineDelegator.render(engineTypeEnum, templateFile.getContent(), context);\n\t\t\t\tfileEntry.setContent(content);\n// bug_end\n \t\t\t}\n \t\t\telse {\n// bug_start\n\t\t\t\tString currentPath = GenUtils.evaluateRealPath(templateFile.getFilename(), context);\n// bug_end\n \t\t\t\tfileEntry.setFilePath(GenUtils.concatFilePath(parentFilePath, currentPath));\n \t\t\t}\n \n \t\t\tmap.put(fileEntry.getFilePath(), fileEntry);\n \t\t}\n \n \t\treturn map;\n \t}\n \n", "target": "// fix_start\n\t\t\tString templateFilename = templateFile.getFilename();\n\t\t\tString filename = StrUtil.format(templateFilename, context);\n// fix_end\n// fix_start\n\t\t\t\tString filePath = GenUtils.concatFilePath(parentFilePath, filename);\n\t\t\t\tfileEntry.setFilePath(filePath);\n// fix_end\n// fix_start\n\n\t\t\t\ttry {\n\t\t\t\t\tString content = templateEngineDelegator.render(engineTypeEnum, templateFile.getContent(), context);\n\t\t\t\t\tfileEntry.setContent(content);\n\t\t\t\t}\n\t\t\t\tcatch (TemplateRenderException ex) {\n\t\t\t\t\tString errorMessage = StrUtil.format(\"\u6a21\u677f\u6e32\u67d3\u5f02\u5e38\uff0c\u6a21\u677f\u6587\u4ef6\u540d\uff1a\u3010{}\u3011\uff0c\u9519\u8bef\u8be6\u60c5\uff1a{}\", templateFilename,\n\t\t\t\t\t\t\tex.getMessage());\n\t\t\t\t\tthrow new BusinessException(SystemResultCode.SERVER_ERROR.getCode(), errorMessage);\n\t\t\t\t}\n// fix_end\n// fix_start\n\t\t\t\tString currentPath = GenUtils.evaluateRealPath(templateFilename, context);\n// fix_end\n", "cwe": "CWE-20", "cwe_name": "Improper Input Validation", "idx": 5560}
{"source": " public UnixUser authenticate(String username, String password) throws PAMException {\n         this.password = password;\n         try {\n             check(libpam.pam_set_item(pht,PAM_USER,username),\"pam_set_item failed\");\n             check(libpam.pam_authenticate(pht,0),\"pam_authenticate failed\");\n             check(libpam.pam_setcred(pht,0),\"pam_setcred failed\");\n// bug_start\n// bug_end\n \n             PointerByReference r = new PointerByReference();\n             check(libpam.pam_get_item(pht,PAM_USER,r),\"pam_get_item failed\");\n             String userName = r.getValue().getString(0);\n             passwd pwd = libc.getpwnam(userName);\n             if(pwd==null)\n                 throw new PAMException(\"Authentication succeeded but no user information is available\");\n             return new UnixUser(userName,pwd);\n         } finally {\n             this.password = null;\n         }\n     }\n \n", "target": "// fix_start\n            check(libpam.pam_acct_mgmt(pht,0),\"pam_acct_mgmt failed\");\n// fix_end\n", "cwe": "CWE-20", "cwe_name": "Improper Input Validation", "idx": 11704}
{"source": " private static void writeString(ByteBuffer buffer, String string) {\n         int length = string.length();\n         for (int charIndex = 0; charIndex < length; charIndex++) {\n             char c = string.charAt(charIndex);\n// bug_start\n            if(c != '\\r' && c != '\\n') {\n                buffer.put((byte) c);\n// bug_end\n             } else {\n                 buffer.put((byte) ' ');\n             }\n         }\n     }\n \n", "target": "// fix_start\n            byte b = (byte) c;\n            if(b != '\\r' && b != '\\n') {\n                buffer.put(b);\n// fix_end\n", "cwe": "CWE-113", "cwe_name": "", "idx": 34}
{"source": " @Override\n \tpublic ParseResults call() {\n \t\ttry {\n// bug_start\n\t\t\tSAXParserFactory.newInstance().newSAXParser().parse(xmlInputStream, handler);\n// bug_end\n \t\t} catch (SAXException | IOException | ParserConfigurationException e) {\n \t\t\tthrow new ReportPortalException(ErrorType.PARSING_XML_ERROR, e.getMessage());\n \t\t}\n \t\treturn new ParseResults(handler.getStartSuiteTime(), handler.getCommonDuration());\n \t}\n \n", "target": "// fix_start\n\t\t\tSAXParserFactory spf = SAXParserFactory.newInstance();\n\t\t\tSAXParser saxParser = spf.newSAXParser();\n\t\t\tXMLReader reader = saxParser.getXMLReader();\n\n\n\t\t\tspf.setFeature(\"http://xml.org/sax/features/external-general-entities\", false);\n\t\t\treader.setFeature(\"http://xml.org/sax/features/external-general-entities\", false);\n\n\t\t\tspf.setFeature(\"http://apache.org/xml/features/disallow-doctype-decl\", true);\n\n\t\t\tsaxParser.parse(xmlInputStream, handler);\n// fix_end\n", "cwe": "CWE-611", "cwe_name": "Improper Restriction of XML External Entity Reference ('XXE')", "idx": 69752}
{"source": " @RequestMapping(\"/module/htmlformentry/htmlFormFromFile.form\")\n \tpublic void handleRequest(Model model, @RequestParam(value = \"filePath\", required = false) String filePath,\n \t                          @RequestParam(value = \"patientId\", required = false) Integer pId,\n \t                          @RequestParam(value = \"isFileUpload\", required = false) boolean isFileUpload,\n \t                          HttpServletRequest request) throws Exception {\n// bug_start\n// bug_end\n \n \t\tif (log.isDebugEnabled())\n \t\t\tlog.debug(\"In reference data...\");\n \n \t\tmodel.addAttribute(\"previewHtml\", \"\");\n \t\tString message = \"\";\n \t\tFile f = null;\n \t\ttry {\n \t\t\tif (isFileUpload) {\n \t\t\t\tMultipartHttpServletRequest multipartRequest = (MultipartHttpServletRequest) request;\n \t\t\t\tMultipartFile multipartFile = multipartRequest.getFile(\"htmlFormFile\");\n \t\t\t\tif (multipartFile != null) {\n \t\t\t\t\tf = new File(SystemUtils.JAVA_IO_TMPDIR, TEMP_HTML_FORM_FILE_PREFIX\n \t\t\t\t\t        + Context.getAuthenticatedUser().getSystemId());\n \t\t\t\t\tif (!f.exists())\n \t\t\t\t\t\tf.createNewFile();\n \n \t\t\t\t\tfilePath = f.getAbsolutePath();\n \t\t\t\t\tFileOutputStream fileOut = new FileOutputStream(f);\n \t\t\t\t\tIOUtils.copy(multipartFile.getInputStream(), fileOut);\n \t\t\t\t\tfileOut.close();\n \t\t\t\t}\n \t\t\t} else {\n \t\t\t\tif (StringUtils.hasText(filePath)) {\n \t\t\t\t\tf = new File(filePath);\n \t\t\t\t} else {\n \t\t\t\t\tmessage = \"You must specify a file path to preview from file\";\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tif (f != null && f.exists() && f.canRead()) {\n \t\t\t\tmodel.addAttribute(\"filePath\", filePath);\n \n \t\t\t\tStringWriter writer = new StringWriter();\n \t\t\t\tIOUtils.copy(new FileInputStream(f), writer, \"UTF-8\");\n \t\t\t\tString xml = writer.toString();\n \n \t\t\t\tPatient p = null;\n \t\t\t\tif (pId != null) {\n \t\t\t\t\tp = Context.getPatientService().getPatient(pId);\n \t\t\t\t} else {\n \t\t\t\t\tp = HtmlFormEntryUtil.getFakePerson();\n \t\t\t\t}\n \t\t\t\tHtmlForm fakeForm = new HtmlForm();\n \t\t\t\tfakeForm.setXmlData(xml);\n \t\t\t\tFormEntrySession fes = new FormEntrySession(p, null, Mode.ENTER, fakeForm, request.getSession());\n \t\t\t\tString html = fes.getHtmlToDisplay();\n \t\t\t\tif (fes.getFieldAccessorJavascript() != null) {\n                 \thtml += \"<script>\" + fes.getFieldAccessorJavascript() + \"</script>\";\n                 }\n \t\t\t\tmodel.addAttribute(\"previewHtml\", html);\n \t\t\t\tmessage = \"\";\n \t\t\t} else {\n \t\t\t\tmessage = \"Please specify a valid file path or select a valid file.\";\n \t\t\t}\n \t\t}\n \t\tcatch (Exception e) {\n \t\t\tlog.error(\"An error occurred while loading the html.\", e);\n \t\t\tmessage = \"An error occurred while loading the html. \" + e.getMessage();\n \t\t}\n \n \t\tmodel.addAttribute(\"message\", message);\n \t\tmodel.addAttribute(\"isFileUpload\", isFileUpload);\n \t}\n \n", "target": "// fix_start\n\n        Context.requirePrivilege(\"Manage Forms\");\n// fix_end\n", "cwe": "CWE-20", "cwe_name": "Improper Input Validation", "idx": 10438}
{"source": " @Override\n     public void validate() {\n// bug_start\n        final String filter = format(ldapConfiguration.getUserSearchFilter(), \"test\");\n// bug_end\n         ldapConnectionTemplate.searchFirst(ldapConfiguration.getSearchBases().get(0), filter, SearchScope.SUBTREE, entry -> entry);\n     }\n \n", "target": "// fix_start\n        final String filter = FilterEncoder.format(ldapConfiguration.getUserSearchFilter(), \"test\");\n// fix_end\n", "cwe": "CWE-74", "cwe_name": "Improper Neutralization of Special Elements in Output Used by a Downstream Component ('Injection')", "idx": 73837}
{"source": " public synchronized void download(StaplerRequest req, StaplerResponse rsp) throws InterruptedException, IOException {\n         rsp.setStatus(HttpServletResponse.SC_OK);\n \n         rsp.addHeader(\"Transfer-Encoding\", \"chunked\");\n         OutputStream out = rsp.getOutputStream();\n         if (DIY_CHUNKING) out = new ChunkedOutputStream(out);\n \n         out.write(\"Starting HTTP duplex channel\".getBytes());\n         out.flush();\n \n// bug_start\n        while(upload==null)\n            wait();\n// bug_end\n \n         try {\n             channel = new Channel(\"HTTP full-duplex channel \" + uuid,\n                     Computer.threadPoolForRemoting, Mode.BINARY, upload, out, null, restricted);\n \n             PingThread ping = new PingThread(channel) {\n                 @Override\n                 protected void onDead(Throwable diagnosis) {\n                     LOGGER.log(Level.INFO,\"Duplex-HTTP session \" + uuid + \" is terminated\",diagnosis);\n                     try {\n                         upload.close();\n                     } catch (IOException e) {\n                         throw new AssertionError(e);\n                     }\n                 }\n \n                 @Override\n                 protected void onDead() {\n                     onDead(null);\n                 }\n             };\n             ping.start();\n             main(channel);\n             channel.join();\n             ping.interrupt();\n         } finally {\n             completed=true;\n             notify();\n         }\n     }\n \n", "target": "// fix_start\n        {\n            long end = System.currentTimeMillis() + CONNECTION_TIMEOUT;\n            while (upload == null && System.currentTimeMillis()<end)\n                wait(1000);\n\n            if (upload==null)\n                throw new IOException(\"HTTP full-duplex channel timeout: \"+uuid);\n        }\n// fix_end\n", "cwe": "CWE-399", "cwe_name": "Resource Management Errors", "idx": 51159}
{"source": " public void doDynamic(StaplerRequest req, StaplerResponse rsp) throws IOException, ServletException {\n         String path = req.getRestOfPath();\n \n// bug_start\n        if (path.isEmpty() || path.contains(\"..\") || path.contains(\"%\") || path.contains(\"META-INF\") || path.contains(\"WEB-INF\")) {\n// bug_end\n             LOGGER.warning(\"rejecting possibly malicious \" + req.getRequestURIWithQueryString());\n             rsp.sendError(HttpServletResponse.SC_BAD_REQUEST);\n             return;\n         }\n \n         String requestPath = req.getRequestURI().substring(req.getContextPath().length());\n         boolean staticLink = requestPath.startsWith(\"/static/\");\n \n         long expires = staticLink ? TimeUnit2.DAYS.toMillis(365) : -1;\n \n         rsp.serveLocalizedFile(req, new URL(wrapper.baseResourceURL, '.' + path), expires);\n     }\n \n", "target": "// fix_start\n        String pathUC = path.toUpperCase(Locale.ENGLISH);\n        if (path.isEmpty() || path.contains(\"..\") || path.contains(\"%\") || pathUC.contains(\"META-INF\") || pathUC.contains(\"WEB-INF\")) {\n// fix_end\n", "cwe": "CWE-200", "cwe_name": "Exposure of Sensitive Information to an Unauthorized Actor", "idx": 15087}
{"source": " protected void run() {\n         JAXRSServerFactoryBean sf = new JAXRSServerFactoryBean();\n         sf.setResourceClasses(MultipartStore.class);\n \n         Map<String, Object> props = new HashMap<String, Object>();\n         props.put(AttachmentDeserializer.ATTACHMENT_MAX_SIZE, String.valueOf(1024 * 10));\n         props.put(AttachmentDeserializer.ATTACHMENT_MEMORY_THRESHOLD, String.valueOf(1024 * 5));\n// bug_start\n// bug_end\n         sf.setProperties(props);\n         sf.setResourceProvider(MultipartStore.class,\n                                new SingletonResourceProvider(new MultipartStore()));\n         sf.setAddress(\"http://localhost:\" + PORT + \"/\");\n \n         server = sf.create();\n     }\n \n", "target": "// fix_start\n        props.put(AttachmentDeserializer.ATTACHMENT_MAX_HEADER_SIZE, String.valueOf(400));\n// fix_end\n", "cwe": "NVD-CWE-noinfo", "cwe_name": "", "idx": 107979}
{"source": " private State readHeaders(ByteBuf buffer) {\n         final HttpMessage message = this.message;\n         final HttpHeaders headers = message.headers();\n \n         AppendableCharSequence line = headerParser.parse(buffer);\n         if (line == null) {\n             return null;\n         }\n         if (line.length() > 0) {\n             do {\n                 char firstChar = line.charAtUnsafe(0);\n                 if (name != null && (firstChar == ' ' || firstChar == '\\t')) {\n                     String trimmedLine = line.toString().trim();\n                     String valueStr = String.valueOf(value);\n                     value = valueStr + ' ' + trimmedLine;\n                 } else {\n                     if (name != null) {\n                         headers.add(name, value);\n                     }\n                     splitHeader(line);\n                 }\n \n                 line = headerParser.parse(buffer);\n                 if (line == null) {\n                     return null;\n                 }\n             } while (line.length() > 0);\n         }\n \n         if (name != null) {\n             headers.add(name, value);\n         }\n \n         name = null;\n         value = null;\n \n         List<String> contentLengthFields = headers.getAll(HttpHeaderNames.CONTENT_LENGTH);\n// bug_start\n\n// bug_end\n         if (!contentLengthFields.isEmpty()) {\n// bug_start\n            boolean multipleContentLengths =\n                    contentLengthFields.size() > 1 || contentLengthFields.get(0).indexOf(COMMA) >= 0;\n            if (multipleContentLengths && message.protocolVersion() == HttpVersion.HTTP_1_1) {\n                if (allowDuplicateContentLengths) {\n                    String firstValue = null;\n                    for (String field : contentLengthFields) {\n                        String[] tokens = COMMA_PATTERN.split(field, -1);\n                        for (String token : tokens) {\n                            String trimmed = token.trim();\n                            if (firstValue == null) {\n                                firstValue = trimmed;\n                            } else if (!trimmed.equals(firstValue)) {\n                                throw new IllegalArgumentException(\n                                        \"Multiple Content-Length values found: \" + contentLengthFields);\n                            }\n                        }\n                    }\n                    headers.set(HttpHeaderNames.CONTENT_LENGTH, firstValue);\n                    contentLength = Long.parseLong(firstValue);\n                } else {\n                    throw new IllegalArgumentException(\n                            \"Multiple Content-Length values found: \" + contentLengthFields);\n                }\n            } else {\n                contentLength = Long.parseLong(contentLengthFields.get(0));\n// bug_end\n             }\n         }\n \n         if (isContentAlwaysEmpty(message)) {\n             HttpUtil.setTransferEncodingChunked(message, false);\n             return State.SKIP_CONTROL_CHARS;\n         } else if (HttpUtil.isTransferEncodingChunked(message)) {\n             if (!contentLengthFields.isEmpty() && message.protocolVersion() == HttpVersion.HTTP_1_1) {\n                 handleTransferEncodingChunkedWithContentLength(message);\n             }\n             return State.READ_CHUNK_SIZE;\n         } else if (contentLength() >= 0) {\n             return State.READ_FIXED_LENGTH_CONTENT;\n         } else {\n             return State.READ_VARIABLE_LENGTH_CONTENT;\n         }\n     }\n \n", "target": "// fix_start\n// fix_end\n// fix_start\n            HttpVersion version = message.protocolVersion();\n            boolean isHttp10OrEarlier = version.majorVersion() < 1 || (version.majorVersion() == 1\n                    && version.minorVersion() == 0);\n            contentLength = HttpUtil.normalizeAndGetContentLength(contentLengthFields,\n                    isHttp10OrEarlier, allowDuplicateContentLengths);\n            if (contentLength != -1) {\n                headers.set(HttpHeaderNames.CONTENT_LENGTH, contentLength);\n// fix_end\n", "cwe": "CWE-444", "cwe_name": "Inconsistent Interpretation of HTTP Requests ('HTTP Request Smuggling')", "idx": 53996}
{"source": " private void sanitizeString(int start, int end) {\n     boolean closed = false;\n     for (int i = start; i < end; ++i) {\n       char ch = jsonish.charAt(i);\n       switch (ch) {\n         case '\\t': replace(i, i + 1, \"\\\\t\"); break;\n         case '\\n': replace(i, i + 1, \"\\\\n\"); break;\n         case '\\r': replace(i, i + 1, \"\\\\r\"); break;\n         case '\\u2028': replace(i, i + 1, \"\\\\u2028\"); break;\n         case '\\u2029': replace(i, i + 1, \"\\\\u2029\"); break;\n         case '\"': case '\\'':\n           if (i == start) {\n             if (ch == '\\'') { replace(i, i + 1, '\"'); }\n           } else {\n             if (i + 1 == end) {\n               char startDelim = jsonish.charAt(start);\n               if (startDelim != '\\'') {\n                 startDelim = '\"';\n               }\n               closed = startDelim == ch;\n             }\n             if (closed) {\n               if (ch == '\\'') { replace(i, i + 1, '\"'); }\n             } else if (ch == '\"') {\n               insert(i, '\\\\');\n             }\n           }\n           break;\n// bug_start\n        case '<':\n          if (i + 3 >= end)\n// bug_end\n             break;\n// bug_start\n// bug_end\n           char c1 = jsonish.charAt(i + 1);\n           char c2 = jsonish.charAt(i + 2);\n           char c3 = jsonish.charAt(i + 3);\n           char lc1 = (char) (c1 | 32);\n           char lc2 = (char) (c2 | 32);\n           char lc3 = (char) (c3 | 32);\n// bug_start\n          if ((c1 == '!' && c2 == '-' && c3 == '-') ||\n              (lc1 == 's' && lc2 == 'c' && lc3 == 'r') ||\n              (c1 == '/' && lc2 == 's' && lc3 == 'c')) {\n// bug_end\n             replace(i, i + 1, \"\\\\u003c\");\n           }\n           break;\n// bug_start\n// bug_end\n         case '>':\n// bug_start\n          if ((i - 2) >= start && '-' == jsonish.charAt(i - 2)\n              && '-' == jsonish.charAt(i - 1)) {\n            replace(i, i + 1, \"\\\\u003e\");\n// bug_end\n           }\n           break;\n         case ']':\n// bug_start\n          if (i + 2 < end && ']' == jsonish.charAt(i + 1)\n              && '>' == jsonish.charAt(i + 2)) {\n            replace(i, i + 1, \"\\\\u005d\");\n// bug_end\n           }\n           break;\n         case '\\\\':\n           if (i + 1 == end) {\n             elide(i, i + 1);\n             break;\n           }\n           char sch = jsonish.charAt(i + 1);\n           switch (sch) {\n             case 'b': case 'f': case 'n': case 'r': case 't': case '\\\\':\n             case '/': case '\"':\n               ++i;\n               break;\n             case 'v':\n               replace(i, i + 2, \"\\\\u0008\");\n               ++i;\n               break;\n             case 'x':\n               if (i + 4 < end && isHexAt(i+2) && isHexAt(i+3)) {\n                 replace(i, i + 2, \"\\\\u00\");\n                 i += 3;\n                 break;\n               }\n               elide(i, i + 1);\n               break;\n             case 'u':\n               if (i + 6 < end && isHexAt(i + 2) && isHexAt(i + 3)\n                   && isHexAt(i + 4) && isHexAt(i + 5)) {\n                 i += 5;\n                 break;\n               }\n               elide(i, i + 1);\n               break;\n             case '0': case '1': case '2': case '3':\n             case '4': case '5': case '6': case '7': {\n               int octalStart = i + 1;\n               int octalEnd = octalStart;\n               ++octalEnd;\n               if (octalEnd < end && isOctAt(octalEnd)) {\n                 ++octalEnd;\n                 if (sch <= '3' && octalEnd < end && isOctAt(octalEnd)) {\n                   ++octalEnd;\n                 }\n               }\n               int value = 0;\n               for (int j = octalStart; j < octalEnd; ++j) {\n                 char digit = jsonish.charAt(j);\n                 value = (value << 3) | (digit - '0');\n               }\n               replace(octalStart, octalEnd, \"u00\");\n               appendHex(value, 2);\n \n               i = octalEnd - 1;\n               break;\n             }\n             default:\n               elide(i, i + 1);\n               break;\n           }\n           break;\n         default:\n           if (ch < 0x20) {\n           } else if (ch < 0xd800) {\n             continue;\n           } else if (ch < 0xe000) {\n             if (Character.isHighSurrogate(ch) && i+1 < end\n                 && Character.isLowSurrogate(jsonish.charAt(i+1))) {\n               ++i;\n               continue;\n             }\n           } else if (ch <= 0xfffd) {\n             continue;\n           }\n           replace(i, i + 1, \"\\\\u\");\n           for (int j = 4; --j >= 0;) {\n             sanitizedJson.append(HEX_DIGITS[(ch >>> (j << 2)) & 0xf]);\n           }\n           break;\n       }\n     }\n     if (!closed) { insert(end, '\"'); }\n   }\n \n", "target": "// fix_start\n        case '<': {\n          if (i + 3 >= end) {\n// fix_end\n// fix_start\n          }\n// fix_end\n// fix_start\n          if (\n                  (c1 == '\\\\' || c2 == '\\\\' || c3 == '\\\\') ||\n                          (c1 == '!' && c2 == '-' && c3 == '-') ||\n                          (lc1 == 's' && lc2 == 'c' && lc3 == 'r') ||\n                          (c1 == '/' && lc2 == 's' && lc3 == 'c')\n          ) {\n// fix_end\n// fix_start\n        }\n// fix_end\n// fix_start\n          if ((i - 2) >= start) {\n            int cm2 = jsonish.charAt(i - 2);\n            int cm1 = jsonish.charAt(i - 1);\n            if (('-' == cm2 || '\\\\' == cm2) && ('-' == cm1 || '\\\\' == cm1)) {\n              replace(i, i + 1, \"\\\\u003e\");\n            }\n// fix_end\n// fix_start\n          if (i + 2 < end) {\n            char c1 = jsonish.charAt(i + 1);\n            char c2 = jsonish.charAt(i + 2);\n            if ((']' == c1 || '\\\\' == c1) && ('>' == c2 || '\\\\' == c2)) {\n              replace(i, i + 1, \"\\\\u005d\");\n            }\n// fix_end\n", "cwe": "CWE-611", "cwe_name": "Improper Restriction of XML External Entity Reference ('XXE')", "idx": 69760}
{"source": " protected String determineTargetUrl(HttpServletRequest request, HttpServletResponse response) {\n \t\tString targetUrl = null;\n \t\tHttpSession session = request.getSession(false);\n \t\tif (session != null && targetUrlSessionAttribute != null) {\n \t\t\ttargetUrl = (String) session.getAttribute(targetUrlSessionAttribute);\n \t\t\tsession.removeAttribute(targetUrlSessionAttribute);\n \t\t}\n \n \t\tif (isAlwaysUseDefaultTargetUrl() || !StringUtils.hasText(targetUrl) || (getTargetUrlParameter() != null && StringUtils.hasText(request.getParameter(getTargetUrlParameter())))) {\n// bug_start\n\t\t\treturn super.determineTargetUrl(request, response);\n// bug_end\n \t\t}\n \n// bug_start\n\t\tlogger.debug(\"Found targetUrlSessionAttribute in request: \" + targetUrl);\n// bug_end\n \n// bug_start\n\t\tif (targetUrl.startsWith(request.getContextPath()))\n\t\t\treturn targetUrl.substring(request.getContextPath().length());\n// bug_end\n \n \t\treturn targetUrl;\n \t}\n \n", "target": "// fix_start\n\t\t\ttargetUrl = super.determineTargetUrl(request, response);\n\t\t} else {\n\t\t\tlogger.debug(\"Found targetUrlSessionAttribute in request: \" + targetUrl);\n// fix_end\n// fix_start\n\t\tif (targetUrl.startsWith(request.getContextPath())) {\n\t\t\ttargetUrl = targetUrl.substring(request.getContextPath().length());\n\t\t}\n// fix_end\n// fix_start\n\t\tif (!Util.isSafeToRedirectTo(targetUrl)) {\n\t\t\tlogger.debug(\"Target URL is not safe to redirect to and will be ignored: \" + targetUrl);\n\t\t\ttargetUrl = getDefaultTargetUrl();\n\t\t}\n// fix_end\n", "cwe": "CWE-601", "cwe_name": "URL Redirection to Untrusted Site ('Open Redirect')", "idx": 65799}
{"source": " @Override\n     protected void onSuccessfulAuthentication(HttpServletRequest request, HttpServletResponse response, Authentication authResult) throws IOException {\n         super.onSuccessfulAuthentication(request,response,authResult);\n// bug_start\n// bug_end\n         request.getSession();\n     }\n \n", "target": "// fix_start\n        request.getSession().invalidate();\n// fix_end\n", "cwe": "CWE-287", "cwe_name": "Improper Authentication", "idx": 38628}
{"source": " protected void run() {\n         JAXRSServerFactoryBean sf = new JAXRSServerFactoryBean();\n         sf.setResourceClasses(MultipartStore.class);\n \n         Map<String, Object> props = new HashMap<>();\n         props.put(AttachmentDeserializer.ATTACHMENT_MAX_SIZE, String.valueOf(1024 * 10));\n         props.put(AttachmentDeserializer.ATTACHMENT_MEMORY_THRESHOLD, String.valueOf(1024 * 5));\n// bug_start\n// bug_end\n         sf.setProperties(props);\n         sf.setResourceProvider(MultipartStore.class,\n                                new SingletonResourceProvider(new MultipartStore()));\n         sf.setAddress(\"http://localhost:\" + PORT + \"/\");\n \n         server = sf.create();\n     }\n \n", "target": "// fix_start\n        props.put(AttachmentDeserializer.ATTACHMENT_MAX_HEADER_SIZE, String.valueOf(400));\n// fix_end\n", "cwe": "NVD-CWE-noinfo", "cwe_name": "", "idx": 107998}
{"source": " @Override\n   public ExitCode runWithoutHelp(CommandRunnerParams params)\n       throws IOException, InterruptedException {\n \n     if (saveFilename != null && loadFilename != null) {\n       params.getConsole().printErrorText(\"Can't use both --load and --save\");\n       return ExitCode.COMMANDLINE_ERROR;\n     }\n \n     if (saveFilename != null) {\n       invalidateChanges(params);\n       RemoteDaemonicParserState state = params.getParser().storeParserState(params.getCell());\n       try (FileOutputStream fos = new FileOutputStream(saveFilename);\n           ZipOutputStream zipos = new ZipOutputStream(fos)) {\n         zipos.putNextEntry(new ZipEntry(\"parser_data\"));\n         try (ObjectOutputStream oos = new ObjectOutputStream(zipos)) {\n           oos.writeObject(state);\n         }\n       }\n     } else if (loadFilename != null) {\n       try (FileInputStream fis = new FileInputStream(loadFilename);\n           ZipInputStream zipis = new ZipInputStream(fis)) {\n         ZipEntry entry = zipis.getNextEntry();\n         Preconditions.checkState(entry.getName().equals(\"parser_data\"));\n// bug_start\n        try (ObjectInputStream ois = new ObjectInputStream(zipis)) {\n// bug_end\n           RemoteDaemonicParserState state;\n           try {\n             state = (RemoteDaemonicParserState) ois.readObject();\n           } catch (ClassNotFoundException e) {\n             params.getConsole().printErrorText(\"Invalid file format\");\n             return ExitCode.COMMANDLINE_ERROR;\n           }\n           params.getParser().restoreParserState(state, params.getCell());\n         }\n       }\n       invalidateChanges(params);\n \n       ParserConfig configView = params.getBuckConfig().getView(ParserConfig.class);\n       if (configView.isParserCacheMutationWarningEnabled()) {\n         params\n             .getConsole()\n             .printErrorText(\n                 params\n                     .getConsole()\n                     .getAnsi()\n                     .asWarningText(\n                         \"WARNING: Buck injected a parser state that may not match the local state.\"));\n       }\n     }\n \n     return ExitCode.SUCCESS;\n   }\n \n", "target": "// fix_start\n        try (ObjectInputStream ois = new ParserStateObjectInputStream(zipis)) {\n// fix_end\n", "cwe": "CWE-502", "cwe_name": "Deserialization of Untrusted Data", "idx": 62168}
{"source": "// bug_start\npublic AuthenticationInfo loadAuthenticationInfo(JSONWebToken token) {\n        Key key = getJWTKey();\n        Jwt jwt;\n        try {\n            jwt = Jwts.parser().setSigningKey(key).parse(token.getPrincipal());\n        } catch (JwtException e) {\n            throw new AuthenticationException(e);\n        }\n        String credentials = legacyHashing ? token.getCredentials() : encryptPassword(token.getCredentials());\n        Object principal = extractPrincipalFromWebToken(jwt);\n        return new SimpleAuthenticationInfo(principal, credentials, getName());\n// bug_end\n     }\n \n", "target": "// fix_start\n@Override\n    protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken token) throws AuthenticationException {\n        String secret = getSecret();\n        Key key = new SecretKeySpec(Decoders.BASE64.decode(secret), getSignatureAlgorithm().getJcaName());\n\n        Jwt jwt = Jwts.parser().\n                setSigningKey(key).\n                parse((String) token.getPrincipal());\n        Map<String, Serializable> principal = getPrincipal(jwt);\n        return new SimpleAuthenticationInfo(principal, ((String) token.getCredentials()).toCharArray(), getName());\n// fix_end\n", "cwe": "CWE-347", "cwe_name": "Improper Verification of Cryptographic Signature", "idx": 43594}
{"source": "// bug_start\n@Override\n    protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken token) throws AuthenticationException {\n        String secret = getSecret();\n        Key key = new SecretKeySpec(Decoders.BASE64.decode(secret), getSignatureAlgorithm().getJcaName());\n\n        Jws<Claims> jwt = Jwts.parser().\n                setSigningKey(key).\n                parseClaimsJws((String) token.getPrincipal());\n        Map<String, Serializable> principal = getPrincipal(jwt);\n        return new SimpleAuthenticationInfo(principal, ((String) token.getCredentials()).toCharArray(), getName());\n// bug_end\n     }\n \n", "target": "// fix_start\npublic AuthenticationInfo loadAuthenticationInfo(JSONWebToken token) {\n        Key key = getJWTKey();\n        Jws<Claims> jwt;\n        try {\n            jwt = Jwts.parser().setSigningKey(key).parseClaimsJws(token.getPrincipal());\n        } catch (JwtException e) {\n            throw new AuthenticationException(e);\n        }\n        String credentials = legacyHashing ? token.getCredentials() : encryptPassword(token.getCredentials());\n        Object principal = extractPrincipalFromWebToken(jwt);\n        return new SimpleAuthenticationInfo(principal, credentials, getName());\n// fix_end\n", "cwe": "CWE-347", "cwe_name": "Improper Verification of Cryptographic Signature", "idx": 43595}
{"source": "// bug_start\npublic static String substituteEnv(String s) {\n        return replaceMacro(s, System.getenv());\n// bug_end\n     }\n \n", "target": "// fix_start\n@Deprecated\n    public static String substituteEnv(String s) {\n        return SUBSTITUTE_ENV ? replaceMacro(s, System.getenv()) : s;\n// fix_end\n", "cwe": "CWE-200", "cwe_name": "Exposure of Sensitive Information to an Unauthorized Actor", "idx": 19190}
{"source": " public T readFrom(Class<T> clazz, Type t, Annotation[] a, MediaType mt,\n                          MultivaluedMap<String, String> headers, InputStream is)\n         throws IOException {\n         Parser parser = ATOM_ENGINE.getParser();\n         synchronized (parser) {\n             ParserOptions options = parser.getDefaultParserOptions();\n             if (options != null) {\n                 options.setAutodetectCharset(autodetectCharset);\n// bug_start\n                options.setResolveEntities(false);\n// bug_end\n             }\n         }\n// bug_start\n        Document<T> doc = parser.parse(is);\n// bug_end\n         return doc.getRoot();\n     }\n \n", "target": "// fix_start\n// fix_end\n// fix_start\n        XMLStreamReader reader = StaxUtils.createXMLStreamReader(is);\n        Document<T> doc = parser.parse(reader);\n// fix_end\n", "cwe": "CWE-611", "cwe_name": "Improper Restriction of XML External Entity Reference ('XXE')", "idx": 68638}
{"source": " private static void processZipStream(File dir, InputStream inputStream) throws IOException\n    {\n// bug_start\n// bug_end\n       ZipInputStream zip = new ZipInputStream(inputStream);\n       while (true)\n       {\n          ZipEntry entry = zip.getNextEntry();\n          if (entry == null)\n          {\n             break;\n          }\n \n          File file = new File(dir, entry.getName());\n// bug_start\n// bug_end\n          if (entry.isDirectory())\n          {\n             FileHelper.mkdirsQuietly(file);\n             continue;\n          }\n \n          File parent = file.getParentFile();\n          if (parent != null)\n          {\n             FileHelper.mkdirsQuietly(parent);\n          }\n \n          FileOutputStream fos = new FileOutputStream(file);\n          byte[] bytes = new byte[1024];\n          int length;\n          while ((length = zip.read(bytes)) >= 0)\n          {\n             fos.write(bytes, 0, length);\n          }\n          fos.close();\n       }\n    }\n \n", "target": "// fix_start\n      String canonicalDestinationDirPath = dir.getCanonicalPath();\n// fix_end\n// fix_start\n\n         String canonicalDestinationFile = file.getCanonicalPath();\n         if (!canonicalDestinationFile.startsWith(canonicalDestinationDirPath + File.separator))\n         {\n            throw new IOException(\"Entry is outside of the target dir: \" + entry.getName());\n         }\n\n// fix_end\n", "cwe": "CWE-22", "cwe_name": "Path Traversal", "idx": 27288}
{"source": " protected synchronized void decorateWithTLS(TLSClientParameters tlsClientParameters,\n             HttpURLConnection connection) throws GeneralSecurityException {\n \n \n         int hash = tlsClientParameters.hashCode();\n         if (hash != lastTlsHash) {\n             lastTlsHash = hash;\n             socketFactory = null;\n         }\n \n         if (tlsClientParameters.isUseHttpsURLConnectionDefaultSslSocketFactory()) {\n             socketFactory = HttpsURLConnection.getDefaultSSLSocketFactory();\n \n         } else if (tlsClientParameters.getSSLSocketFactory() != null) {\n             socketFactory = tlsClientParameters.getSSLSocketFactory();\n \n         } else if (socketFactory == null) {\n \n             SSLContext ctx =\n                 org.apache.cxf.transport.https.SSLUtils.getSSLContext(tlsClientParameters);\n \n             String[] cipherSuites =\n                 SSLUtils.getCiphersuitesToInclude(tlsClientParameters.getCipherSuites(),\n                                                   tlsClientParameters.getCipherSuitesFilter(),\n                                                   ctx.getSocketFactory().getDefaultCipherSuites(),\n                                                   SSLUtils.getSupportedCipherSuites(ctx),\n                                                   LOG);\n             String protocol = tlsClientParameters.getSecureSocketProtocol() != null ? tlsClientParameters\n                 .getSecureSocketProtocol() : \"TLS\";\n             socketFactory = new SSLSocketFactoryWrapper(ctx.getSocketFactory(), cipherSuites,\n                                                         protocol);\n             lastTlsHash = tlsClientParameters.hashCode();\n         } else {\n         }\n \n \n         HostnameVerifier verifier = org.apache.cxf.transport.https.SSLUtils\n             .getHostnameVerifier(tlsClientParameters);\n \n         if (connection instanceof HttpsURLConnection) {\n             HttpsURLConnection conn = (HttpsURLConnection) connection;\n             conn.setHostnameVerifier(verifier);\n             conn.setSSLSocketFactory(socketFactory);\n         } else {\n             try {\n                 Method method = connection.getClass().getMethod(\"getHostnameVerifier\");\n \n                 InvocationHandler handler = new ReflectionInvokationHandler(verifier) {\n                     public Object invoke(Object proxy,\n                                          Method method,\n                                          Object[] args) throws Throwable {\n                         try {\n                             return super.invoke(proxy, method, args);\n                         } catch (Exception ex) {\n// bug_start\n                            return true;\n// bug_end\n                         }\n                     }\n                 };\n                 Object proxy = java.lang.reflect.Proxy.newProxyInstance(this.getClass().getClassLoader(),\n                                                                         new Class[] {method.getReturnType()},\n                                                                         handler);\n \n                 method = connection.getClass().getMethod(\"setHostnameVerifier\", method.getReturnType());\n                 method.invoke(connection, proxy);\n             } catch (Exception ex) {\n             }\n             try {\n                 Method getSSLSocketFactory =  connection.getClass().getMethod(\"getSSLSocketFactory\");\n                 Method setSSLSocketFactory = connection.getClass()\n                     .getMethod(\"setSSLSocketFactory\", getSSLSocketFactory.getReturnType());\n                 if (getSSLSocketFactory.getReturnType().isInstance(socketFactory)) {\n                     setSSLSocketFactory.invoke(connection, socketFactory);\n                 } else {\n                     Constructor<?> c = getSSLSocketFactory.getReturnType()\n                         .getDeclaredConstructor(SSLSocketFactory.class);\n                     ReflectionUtil.setAccessible(c);\n                     setSSLSocketFactory.invoke(connection, c.newInstance(socketFactory));\n                 }\n             } catch (Exception ex) {\n                 if (connection.getClass().getName().contains(\"weblogic\")) {\n                     if (!weblogicWarned) {\n                         weblogicWarned = true;\n                         LOG.warning(\"Could not configure SSLSocketFactory on Weblogic.  \"\n                                     + \" Use the Weblogic control panel to configure the SSL settings.\");\n                     }\n                     return;\n                 }\n                 throw new IllegalArgumentException(\"Error decorating connection class \"\n                         + connection.getClass().getName(), ex);\n             }\n         }\n     }\n \n", "target": "// fix_start\n                            return false;\n// fix_end\n", "cwe": "CWE-755", "cwe_name": "Improper Handling of Exceptional Conditions", "idx": 74789}
{"source": " private void unzip(File dir, File zipFile) throws IOException {\n         dir = dir.getAbsoluteFile();\n         ZipFile zip = new ZipFile(zipFile);\n         @SuppressWarnings(\"unchecked\")\n         Enumeration<ZipEntry> entries = zip.getEntries();\n \n         try {\n             while (entries.hasMoreElements()) {\n                 ZipEntry e = entries.nextElement();\n                 File f = new File(dir, e.getName());\n// bug_start\n// bug_end\n                 if (e.isDirectory()) {\n                     mkdirs(f);\n                 } else {\n                     File p = f.getParentFile();\n                     if (p != null) {\n                         mkdirs(p);\n                     }\n                     try (InputStream input = zip.getInputStream(e)) {\n                         IOUtils.copy(input, writing(f));\n                     }\n                     try {\n                         FilePath target = new FilePath(f);\n                         int mode = e.getUnixMode();\n                         if (mode!=0)\n                             target.chmod(mode);\n                     } catch (InterruptedException ex) {\n                         LOGGER.log(Level.WARNING, \"unable to set permissions\", ex);\n                     }\n                     f.setLastModified(e.getTime());\n                 }\n             }\n         } finally {\n             zip.close();\n         }\n     }\n \n", "target": "// fix_start\n                if (!f.toPath().normalize().startsWith(dir.toPath())) {\n                    throw new IOException(\n                        \"Zip \" + zipFile.getPath() + \" contains illegal file name that breaks out of the target directory: \" + e.getName());\n                }\n// fix_end\n", "cwe": "CWE-79", "cwe_name": "Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')", "idx": 77923}
{"source": " public static String resolvePath(String uri) {\n \t\tif (uri.isEmpty()) {\n \t\t\treturn uri;\n \t\t}\n \n// bug_start\n\t\tString path;\n\t\tif (uri.charAt(0) == '/') {\n\t\t\tpath = uri;\n\t\t\tfor (int i = 0; i < path.length(); i++) {\n\t\t\t\tchar c = path.charAt(i);\n\t\t\t\tif (c == '?' || c == '#') {\n\t\t\t\t\tpath = path.substring(0, i);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tpath = URI.create(uri).getPath();\n\t\t}\n// bug_end\n \t\tif (!path.isEmpty()) {\n \t\t\tif (path.charAt(0) == '/') {\n \t\t\t\tpath = path.substring(1);\n// bug_start\n\t\t\t\tif (path.length() <= 1) {\n// bug_end\n \t\t\t\t\treturn path;\n \t\t\t\t}\n \t\t\t}\n \t\t\tif (path.charAt(path.length() - 1) == '/') {\n \t\t\t\treturn path.substring(0, path.length() - 1);\n \t\t\t}\n \t\t}\n \t\treturn path;\n \t}\n \n", "target": "// fix_start\n\t\tString path = URI.create(uri.charAt(0) == '/' ? \"http://localhost:8080\" + uri : uri)\n\t\t                 .getPath();\n// fix_end\n// fix_start\n\t\t\t\tif (path.isEmpty()) {\n// fix_end\n", "cwe": "CWE-755", "cwe_name": "Improper Handling of Exceptional Conditions", "idx": 74862}
{"source": " public static String migrate(String xml) {\n \t\tDocument xmlDoc;\n \t\ttry {\n// bug_start\n\t\t\txmlDoc = new SAXReader().read(new StringReader(xml));\n\t\t} catch (DocumentException e) {\n// bug_end\n \t\t\tthrow new RuntimeException(e);\n \t\t}\n \n \t\tList<NodeTuple> tuples = new ArrayList<>();\n \t\tNode keyNode = new ScalarNode(Tag.STR, \"version\");\n \t\tNode valueNode = new ScalarNode(Tag.INT, \"0\");\n \t\ttuples.add(new NodeTuple(keyNode, valueNode));\n \n \t\tList<Node> jobNodes = new ArrayList<>();\n \t\tfor (Element jobElement: xmlDoc.getRootElement().element(\"jobs\").elements())\n \t\t\tjobNodes.add(migrateJob(jobElement));\n \n \t\tif (!jobNodes.isEmpty()) {\n \t\t\tkeyNode = new ScalarNode(Tag.STR, \"jobs\");\n \t\t\ttuples.add(new NodeTuple(keyNode, new SequenceNode(Tag.SEQ, jobNodes, FlowStyle.BLOCK)));\n \t\t}\n \n \t\tList<Node> propertyNodes = new ArrayList<>();\n \t\tElement propertiesElement = xmlDoc.getRootElement().element(\"properties\");\n \t\tif (propertiesElement != null) {\n \t\t\tfor (Element propertyElement: propertiesElement.elements()) {\n \t\t\t\tNode nameNode = new ScalarNode(Tag.STR, propertyElement.elementText(\"name\").trim());\n \t\t\t\tvalueNode = new ScalarNode(Tag.STR, propertyElement.elementText(\"value\").trim());\n \t\t\t\tList<NodeTuple> propertyTuples = Lists.newArrayList(\n \t\t\t\t\t\tnew NodeTuple(new ScalarNode(Tag.STR, \"name\"), nameNode),\n \t\t\t\t\t\tnew NodeTuple(new ScalarNode(Tag.STR, \"value\"), valueNode));\n \t\t\t\tpropertyNodes.add(new MappingNode(Tag.MAP, propertyTuples, FlowStyle.BLOCK));\n \t\t\t}\n \t\t}\n \t\tif(!propertyNodes.isEmpty()) {\n \t\t\tkeyNode = new ScalarNode(Tag.STR, \"properties\");\n \t\t\ttuples.add(new NodeTuple(keyNode, new SequenceNode(Tag.SEQ, propertyNodes, FlowStyle.BLOCK)));\n \t\t}\n \n \t\tMappingNode rootNode = new MappingNode(Tag.MAP, tuples, FlowStyle.BLOCK);\n \t\tStringWriter writer = new StringWriter();\n \t\tDumperOptions dumperOptions = new DumperOptions();\n \t\tSerializer serializer = new Serializer(new Emitter(writer, dumperOptions),\n \t\t\t\tnew Resolver(), dumperOptions, Tag.MAP);\n \t\ttry {\n \t\t\tserializer.open();\n \t\t\tserializer.serialize(rootNode);\n \t\t\tserializer.close();\n \t\t\treturn writer.toString();\n \t\t} catch (IOException e) {\n \t\t\tthrow new RuntimeException(e);\n \t\t}\n \n \t}\n \n", "target": "// fix_start\n\t\t\tSAXReader reader = new SAXReader();\n\t\t\treader.setFeature(\"http://apache.org/xml/features/disallow-doctype-decl\", true);\n\t\t\txmlDoc = reader.read(new StringReader(xml));\n\t\t} catch (DocumentException | SAXException e) {\n// fix_end\n", "cwe": "CWE-538", "cwe_name": "", "idx": 64235}
{"source": " @Override\n         public SocketState process(SocketWrapperBase<S> wrapper, SocketEvent status) {\n             if (getLog().isDebugEnabled()) {\n                 getLog().debug(sm.getString(\"abstractConnectionHandler.process\",\n                         wrapper.getSocket(), status));\n             }\n             if (wrapper == null) {\n                 return SocketState.CLOSED;\n             }\n \n             S socket = wrapper.getSocket();\n \n             Processor processor = connections.get(socket);\n             if (getLog().isDebugEnabled()) {\n                 getLog().debug(sm.getString(\"abstractConnectionHandler.connectionsGet\",\n                         processor, socket));\n             }\n \n             if (SocketEvent.TIMEOUT == status &&\n                     (processor == null ||\n                     !processor.isAsync() && !processor.isUpgrade() ||\n                     processor.isAsync() && !processor.checkAsyncTimeoutGeneration())) {\n                 return SocketState.OPEN;\n             }\n \n             if (processor != null) {\n                 getProtocol().removeWaitingProcessor(processor);\n             } else if (status == SocketEvent.DISCONNECT || status == SocketEvent.ERROR) {\n                 return SocketState.CLOSED;\n             }\n \n             ContainerThreadMarker.set();\n \n             try {\n                 if (processor == null) {\n                     String negotiatedProtocol = wrapper.getNegotiatedProtocol();\n                     if (negotiatedProtocol != null && negotiatedProtocol.length() > 0) {\n                         UpgradeProtocol upgradeProtocol = getProtocol().getNegotiatedProtocol(negotiatedProtocol);\n                         if (upgradeProtocol != null) {\n                             processor = upgradeProtocol.getProcessor(wrapper, getProtocol().getAdapter());\n                             if (getLog().isDebugEnabled()) {\n                                 getLog().debug(sm.getString(\"abstractConnectionHandler.processorCreate\", processor));\n                             }\n                         } else if (negotiatedProtocol.equals(\"http/1.1\")) {\n                         } else {\n                             if (getLog().isDebugEnabled()) {\n                                 getLog().debug(sm.getString(\"abstractConnectionHandler.negotiatedProcessor.fail\",\n                                         negotiatedProtocol));\n                             }\n                             return SocketState.CLOSED;\n                         }\n                     }\n                 }\n                 if (processor == null) {\n                     processor = recycledProcessors.pop();\n                     if (getLog().isDebugEnabled()) {\n                         getLog().debug(sm.getString(\"abstractConnectionHandler.processorPop\", processor));\n                     }\n                 }\n                 if (processor == null) {\n                     processor = getProtocol().createProcessor();\n                     register(processor);\n                     if (getLog().isDebugEnabled()) {\n                         getLog().debug(sm.getString(\"abstractConnectionHandler.processorCreate\", processor));\n                     }\n                 }\n \n                 processor.setSslSupport(\n                         wrapper.getSslSupport(getProtocol().getClientCertProvider()));\n \n                 connections.put(socket, processor);\n \n                 SocketState state = SocketState.CLOSED;\n                 do {\n                     state = processor.process(wrapper, status);\n \n                     if (state == SocketState.UPGRADING) {\n                         UpgradeToken upgradeToken = processor.getUpgradeToken();\n                         ByteBuffer leftOverInput = processor.getLeftoverInput();\n                         if (upgradeToken == null) {\n                             UpgradeProtocol upgradeProtocol = getProtocol().getUpgradeProtocol(\"h2c\");\n                             if (upgradeProtocol != null) {\n// bug_start\n                                processor = upgradeProtocol.getProcessor(\n                                        wrapper, getProtocol().getAdapter());\n// bug_end\n                                 wrapper.unRead(leftOverInput);\n                                 connections.put(socket, processor);\n                             } else {\n                                 if (getLog().isDebugEnabled()) {\n                                     getLog().debug(sm.getString(\n                                         \"abstractConnectionHandler.negotiatedProcessor.fail\",\n                                         \"h2c\"));\n                                 }\n// bug_start\n                                return SocketState.CLOSED;\n// bug_end\n                             }\n                         } else {\n                             HttpUpgradeHandler httpUpgradeHandler = upgradeToken.getHttpUpgradeHandler();\n                             release(processor);\n                             processor = getProtocol().createUpgradeProcessor(wrapper, upgradeToken);\n                             if (getLog().isDebugEnabled()) {\n                                 getLog().debug(sm.getString(\"abstractConnectionHandler.upgradeCreate\",\n                                         processor, wrapper));\n                             }\n                             wrapper.unRead(leftOverInput);\n                             wrapper.setUpgraded(true);\n                             connections.put(socket, processor);\n                             if (upgradeToken.getInstanceManager() == null) {\n                                 httpUpgradeHandler.init((WebConnection) processor);\n                             } else {\n                                 ClassLoader oldCL = upgradeToken.getContextBind().bind(false, null);\n                                 try {\n                                     httpUpgradeHandler.init((WebConnection) processor);\n                                 } finally {\n                                     upgradeToken.getContextBind().unbind(false, oldCL);\n                                 }\n                             }\n                         }\n                     }\n                 } while ( state == SocketState.UPGRADING);\n \n                 if (state == SocketState.LONG) {\n                     longPoll(wrapper, processor);\n                     if (processor.isAsync()) {\n                         getProtocol().addWaitingProcessor(processor);\n                     }\n                 } else if (state == SocketState.OPEN) {\n                     connections.remove(socket);\n                     release(processor);\n                     wrapper.registerReadInterest();\n                 } else if (state == SocketState.SENDFILE) {\n                 } else if (state == SocketState.UPGRADED) {\n                     if (status != SocketEvent.OPEN_WRITE) {\n                         longPoll(wrapper, processor);\n                         getProtocol().addWaitingProcessor(processor);\n                     }\n                 } else if (state == SocketState.SUSPENDED) {\n                 } else {\n                     connections.remove(socket);\n                     if (processor.isUpgrade()) {\n                         UpgradeToken upgradeToken = processor.getUpgradeToken();\n                         HttpUpgradeHandler httpUpgradeHandler = upgradeToken.getHttpUpgradeHandler();\n                         InstanceManager instanceManager = upgradeToken.getInstanceManager();\n                         if (instanceManager == null) {\n                             httpUpgradeHandler.destroy();\n                         } else {\n                             ClassLoader oldCL = upgradeToken.getContextBind().bind(false, null);\n                             try {\n                                 httpUpgradeHandler.destroy();\n                             } finally {\n                                 try {\n                                     instanceManager.destroyInstance(httpUpgradeHandler);\n                                 } catch (Throwable e) {\n                                     ExceptionUtils.handleThrowable(e);\n                                     getLog().error(sm.getString(\"abstractConnectionHandler.error\"), e);\n                                 }\n                                 upgradeToken.getContextBind().unbind(false, oldCL);\n                             }\n                         }\n                     }\n                     release(processor);\n                 }\n                 return state;\n             } catch(java.net.SocketException e) {\n                 getLog().debug(sm.getString(\n                         \"abstractConnectionHandler.socketexception.debug\"), e);\n             } catch (java.io.IOException e) {\n                 getLog().debug(sm.getString(\n                         \"abstractConnectionHandler.ioexception.debug\"), e);\n             } catch (ProtocolException e) {\n                 getLog().debug(sm.getString(\n                         \"abstractConnectionHandler.protocolexception.debug\"), e);\n             }\n             catch (OutOfMemoryError oome) {\n                 getLog().error(sm.getString(\"abstractConnectionHandler.oome\"), oome);\n             } catch (Throwable e) {\n                 ExceptionUtils.handleThrowable(e);\n                 getLog().error(sm.getString(\"abstractConnectionHandler.error\"), e);\n             } finally {\n                 ContainerThreadMarker.clear();\n             }\n \n             connections.remove(socket);\n             release(processor);\n             return SocketState.CLOSED;\n         }\n \n", "target": "// fix_start\n                                release(processor);\n                                processor = upgradeProtocol.getProcessor(wrapper, getProtocol().getAdapter());\n// fix_end\n// fix_start\n                                state = SocketState.CLOSED;\n// fix_end\n", "cwe": "CWE-476", "cwe_name": "NULL Pointer Dereference", "idx": 56903}
{"source": " @Override\n   protected void process(final ClusterDistributionManager dm) {\n     Throwable thr = null;\n     ReplyException rex = null;\n     if (this.functionObject == null) {\n       rex = new ReplyException(\n           new FunctionException(LocalizedStrings.ExecuteFunction_FUNCTION_NAMED_0_IS_NOT_REGISTERED\n               .toLocalizedString(this.functionName)));\n \n       replyWithException(dm, rex);\n       return;\n     }\n \n     FunctionStats stats =\n         FunctionStats.getFunctionStats(this.functionObject.getId(), dm.getSystem());\n     TXStateProxy tx = null;\n     InternalCache cache = dm.getCache();\n \n     try {\n       tx = prepForTransaction(dm);\n       ResultSender resultSender = new MemberFunctionResultSender(dm, this, this.functionObject);\n       Set<Region> regions = new HashSet<Region>();\n       if (this.regionPathSet != null) {\n         for (String regionPath : this.regionPathSet) {\n           if (checkCacheClosing(dm) || checkDSClosing(dm)) {\n             if (dm.getCache() == null) {\n               thr = new CacheClosedException(\n                   LocalizedStrings.PartitionMessage_REMOTE_CACHE_IS_CLOSED_0\n                       .toLocalizedString(dm.getId()));\n             } else {\n               dm.getCache().getCacheClosedException(\n                   LocalizedStrings.PartitionMessage_REMOTE_CACHE_IS_CLOSED_0\n                       .toLocalizedString(dm.getId()));\n             }\n             return;\n           }\n           regions.add(cache.getRegion(regionPath));\n         }\n       }\n       FunctionContextImpl context = new MultiRegionFunctionContextImpl(cache,\n           this.functionObject.getId(), this.args, resultSender, regions, isReExecute);\n \n       long start = stats.startTime();\n       stats.startFunctionExecution(this.functionObject.hasResult());\n       if (logger.isDebugEnabled()) {\n         logger.debug(\"Executing Function: {} on remote member with context: {}\",\n             this.functionObject.getId(), context.toString());\n       }\n       this.functionObject.execute(context);\n       if (!this.replyLastMsg && this.functionObject.hasResult()) {\n         throw new FunctionException(\n             LocalizedStrings.ExecuteFunction_THE_FUNCTION_0_DID_NOT_SENT_LAST_RESULT\n                 .toString(functionObject.getId()));\n       }\n       stats.endFunctionExecution(start, this.functionObject.hasResult());\n     } catch (FunctionException functionException) {\n       if (logger.isDebugEnabled()) {\n         logger.debug(\"FunctionException occurred on remote member while executing Function: {}\",\n             this.functionObject.getId(), functionException);\n       }\n       stats.endFunctionExecutionWithException(this.functionObject.hasResult());\n       rex = new ReplyException(functionException);\n       replyWithException(dm, rex);\n     } catch (CancelException exception) {\n       thr = new FunctionInvocationTargetException(exception);\n       stats.endFunctionExecutionWithException(this.functionObject.hasResult());\n       rex = new ReplyException(thr);\n       replyWithException(dm, rex);\n     } catch (Exception exception) {\n// bug_start\n      logger.error(\"Exception occurred on remote member while executing Function: {}\",\n          this.functionObject.getId(), exception);\n\n// bug_end\n       stats.endFunctionExecutionWithException(this.functionObject.hasResult());\n       rex = new ReplyException(exception);\n       replyWithException(dm, rex);\n     } catch (VirtualMachineError err) {\n       SystemFailure.initiateFailure(err);\n       throw err;\n     } catch (Throwable t) {\n       SystemFailure.checkFailure();\n       thr = t;\n     } finally {\n       cleanupTransaction(tx);\n       if (thr != null) {\n         rex = new ReplyException(thr);\n         replyWithException(dm, rex);\n       }\n     }\n   }\n \n", "target": "// fix_start\n      if (logger.isDebugEnabled()) {\n        logger.debug(\"Exception occurred on remote member while executing Function: {}\",\n            this.functionObject.getId(), exception);\n      }\n// fix_end\n", "cwe": "CWE-863", "cwe_name": "Incorrect Authorization", "idx": 87815}
{"source": " private void prepareRequest() throws IOException {\n \n         http11 = true;\n         http09 = false;\n         contentDelimitation = false;\n \n         if (endpoint.isSSLEnabled()) {\n             request.scheme().setString(\"https\");\n         }\n         MessageBytes protocolMB = request.protocol();\n         if (protocolMB.equals(Constants.HTTP_11)) {\n             protocolMB.setString(Constants.HTTP_11);\n         } else if (protocolMB.equals(Constants.HTTP_10)) {\n             http11 = false;\n             keepAlive = false;\n             protocolMB.setString(Constants.HTTP_10);\n         } else if (protocolMB.equals(\"\")) {\n             http09 = true;\n             http11 = false;\n             keepAlive = false;\n         } else {\n             http11 = false;\n             response.setStatus(505);\n             setErrorState(ErrorState.CLOSE_CLEAN, null);\n             if (log.isDebugEnabled()) {\n                 log.debug(sm.getString(\"http11processor.request.prepare\")+\n                           \" Unsupported HTTP version \\\"\"+protocolMB+\"\\\"\");\n             }\n         }\n \n         MimeHeaders headers = request.getMimeHeaders();\n \n         MessageBytes connectionValueMB = headers.getValue(Constants.CONNECTION);\n         if (connectionValueMB != null && !connectionValueMB.isNull()) {\n             Set<String> tokens = new HashSet<>();\n             TokenList.parseTokenList(headers.values(Constants.CONNECTION), tokens);\n             if (tokens.contains(Constants.CLOSE)) {\n                 keepAlive = false;\n             } else if (tokens.contains(Constants.KEEP_ALIVE_HEADER_VALUE_TOKEN)) {\n                 keepAlive = true;\n             }\n         }\n \n         if (http11) {\n             MessageBytes expectMB = headers.getValue(\"expect\");\n             if (expectMB != null && !expectMB.isNull()) {\n                 if (expectMB.toString().trim().equalsIgnoreCase(\"100-continue\")) {\n                     inputBuffer.setSwallowInput(false);\n                     request.setExpectation(true);\n                 } else {\n                     response.setStatus(HttpServletResponse.SC_EXPECTATION_FAILED);\n                     setErrorState(ErrorState.CLOSE_CLEAN, null);\n                 }\n             }\n         }\n \n         if (restrictedUserAgents != null && (http11 || keepAlive)) {\n             MessageBytes userAgentValueMB = headers.getValue(\"user-agent\");\n             if(userAgentValueMB != null && !userAgentValueMB.isNull()) {\n                 String userAgentValue = userAgentValueMB.toString();\n                 if (restrictedUserAgents != null &&\n                         restrictedUserAgents.matcher(userAgentValue).matches()) {\n                     http11 = false;\n                     keepAlive = false;\n                 }\n             }\n         }\n \n \n         MessageBytes hostValueMB = null;\n         try {\n             hostValueMB = headers.getUniqueValue(\"host\");\n         } catch (IllegalArgumentException iae) {\n             badRequest(\"http11processor.request.multipleHosts\");\n         }\n         if (http11 && hostValueMB == null) {\n             badRequest(\"http11processor.request.noHostHeader\");\n         }\n \n         ByteChunk uriBC = request.requestURI().getByteChunk();\n         byte[] uriB = uriBC.getBytes();\n         if (uriBC.startsWithIgnoreCase(\"http\", 0)) {\n             int pos = 4;\n             if (uriBC.startsWithIgnoreCase(\"s\", pos)) {\n                 pos++;\n             }\n             if (uriBC.startsWith(\"://\", pos)) {\n                 pos += 3;\n                 int uriBCStart = uriBC.getStart();\n \n                 int slashPos = uriBC.indexOf('/', pos);\n                 int atPos = uriBC.indexOf('@', pos);\n                 if (slashPos > -1 && atPos > slashPos) {\n                     atPos = -1;\n                 }\n \n                 if (slashPos == -1) {\n                     slashPos = uriBC.getLength();\n                     request.requestURI().setBytes(uriB, uriBCStart + 6, 1);\n                 } else {\n                     request.requestURI().setBytes(uriB, uriBCStart + slashPos, uriBC.getLength() - slashPos);\n                 }\n \n                 if (atPos != -1) {\n                     for (; pos < atPos; pos++) {\n                         byte c = uriB[uriBCStart + pos];\n                         if (!HttpParser.isUserInfo(c)) {\n                             badRequest(\"http11processor.request.invalidUserInfo\");\n                             break;\n                         }\n                     }\n                     pos = atPos + 1;\n                 }\n \n                 if (http11) {\n                     if (hostValueMB != null) {\n                         if (!hostValueMB.getByteChunk().equals(\n                                 uriB, uriBCStart + pos, slashPos - pos)) {\n                             if (protocol.getAllowHostHeaderMismatch()) {\n                                 hostValueMB = headers.setValue(\"host\");\n                                 hostValueMB.setBytes(uriB, uriBCStart + pos, slashPos - pos);\n                             } else {\n                                 badRequest(\"http11processor.request.inconsistentHosts\");\n                             }\n                         }\n                     }\n                 } else {\n                     try {\n                         hostValueMB = headers.setValue(\"host\");\n                         hostValueMB.setBytes(uriB, uriBCStart + pos, slashPos - pos);\n                     } catch (IllegalStateException e) {\n                     }\n                 }\n             } else {\n                 badRequest(\"http11processor.request.invalidScheme\");\n             }\n         }\n \n         for (int i = uriBC.getStart(); i < uriBC.getEnd(); i++) {\n             if (!httpParser.isAbsolutePathRelaxed(uriB[i])) {\n                 badRequest(\"http11processor.request.invalidUri\");\n                 break;\n             }\n         }\n \n         InputFilter[] inputFilters = inputBuffer.getFilters();\n \n         if (http11) {\n             MessageBytes transferEncodingValueMB = headers.getValue(\"transfer-encoding\");\n             if (transferEncodingValueMB != null) {\n                 List<String> encodingNames = new ArrayList<>();\n// bug_start\n                TokenList.parseTokenList(headers.values(\"transfer-encoding\"), encodingNames);\n                for (String encodingName : encodingNames) {\n                    addInputFilter(inputFilters, encodingName);\n// bug_end\n                 }\n             }\n         }\n \n         long contentLength = -1;\n         try {\n             contentLength = request.getContentLengthLong();\n         } catch (NumberFormatException e) {\n             badRequest(\"http11processor.request.nonNumericContentLength\");\n         } catch (IllegalArgumentException e) {\n             badRequest(\"http11processor.request.multipleContentLength\");\n         }\n         if (contentLength >= 0) {\n             if (contentDelimitation) {\n                 headers.removeHeader(\"content-length\");\n                 request.setContentLength(-1);\n             } else {\n                 inputBuffer.addActiveFilter(inputFilters[Constants.IDENTITY_FILTER]);\n                 contentDelimitation = true;\n             }\n         }\n \n         parseHost(hostValueMB);\n \n         if (!contentDelimitation) {\n             inputBuffer.addActiveFilter(inputFilters[Constants.VOID_FILTER]);\n             contentDelimitation = true;\n         }\n \n         if (!getErrorState().isIoAllowed()) {\n             getAdapter().log(request, response, 0);\n         }\n     }\n \n", "target": "// fix_start\n                if (TokenList.parseTokenList(headers.values(\"transfer-encoding\"), encodingNames)) {\n                    for (String encodingName : encodingNames) {\n                        addInputFilter(inputFilters, encodingName);\n                    }\n                } else {\n                    badRequest(\"http11processor.request.invalidTransferEncoding\");\n// fix_end\n", "cwe": "CWE-444", "cwe_name": "Inconsistent Interpretation of HTTP Requests ('HTTP Request Smuggling')", "idx": 55623}
{"source": " @RequestMapping(value = \"/oauth/authorize\", method = RequestMethod.POST, params = OAuth2Utils.USER_OAUTH_APPROVAL)\n     public View approveOrDeny(@RequestParam Map<String, String> approvalParameters, Map<String, ?> model,\n                               SessionStatus sessionStatus, Principal principal) {\n \n         if (!(principal instanceof Authentication)) {\n             sessionStatus.setComplete();\n             throw new InsufficientAuthenticationException(\n               \"User must be authenticated with Spring Security before authorizing an access token.\");\n         }\n \n         AuthorizationRequest authorizationRequest = (AuthorizationRequest) model.get(\"authorizationRequest\");\n \n         if (authorizationRequest == null) {\n             sessionStatus.setComplete();\n             throw new InvalidRequestException(\"Cannot approve uninitialized authorization request.\");\n         }\n \n         @SuppressWarnings(\"unchecked\")\n         Map<String, Object> originalAuthorizationRequest = (Map<String, Object>) model.get(\"org.springframework.security.oauth2.provider.endpoint.AuthorizationEndpoint.ORIGINAL_AUTHORIZATION_REQUEST\");\n         if (isAuthorizationRequestModified(authorizationRequest, originalAuthorizationRequest)) {\n             throw new InvalidRequestException(\"Changes were detected from the original authorization request.\");\n// bug_start\n// bug_end\n         }\n \n         try {\n             Set<String> responseTypes = authorizationRequest.getResponseTypes();\n             String grantType = deriveGrantTypeFromResponseType(responseTypes);\n \n             authorizationRequest.setApprovalParameters(approvalParameters);\n             authorizationRequest = userApprovalHandler.updateAfterApproval(authorizationRequest,\n               (Authentication) principal);\n             boolean approved = userApprovalHandler.isApproved(authorizationRequest, (Authentication) principal);\n             authorizationRequest.setApproved(approved);\n \n             if (authorizationRequest.getRedirectUri() == null) {\n                 sessionStatus.setComplete();\n                 throw new InvalidRequestException(\"Cannot approve request when no redirect URI is provided.\");\n             }\n \n             if (!authorizationRequest.isApproved()) {\n                 return new RedirectView(getUnsuccessfulRedirect(authorizationRequest,\n                   new UserDeniedAuthorizationException(\"User denied access\"), responseTypes.contains(\"token\")),\n                   false, true, false);\n             }\n \n             if (responseTypes.contains(\"token\") || responseTypes.contains(\"id_token\")) {\n                 return getImplicitGrantOrHybridResponse(\n                   authorizationRequest,\n                   (Authentication) principal,\n                   grantType\n                 ).getView();\n             }\n \n             return getAuthorizationCodeResponse(authorizationRequest, (Authentication) principal);\n         } finally {\n             sessionStatus.setComplete();\n         }\n \n     }\n \n", "target": "// fix_start\n        }\n\n        for (String approvalParameter : approvalParameters.keySet()) {\n            if (approvalParameter.startsWith(SCOPE_PREFIX)) {\n                String scope = approvalParameters.get(approvalParameter).substring(SCOPE_PREFIX.length());\n                Set<String> originalScopes = (Set<String>) originalAuthorizationRequest.get(\"scope\");\n                if (!originalScopes.contains(scope)) {\n                    sessionStatus.setComplete();\n\n                    return new RedirectView(getUnsuccessfulRedirect(authorizationRequest,\n                            new InvalidScopeException(\"The requested scopes are invalid. Please use valid scope names in the request.\"), false), false, true, false);\n                }\n            }\n// fix_end\n", "cwe": "NVD-CWE-noinfo", "cwe_name": "", "idx": 102826}
{"source": " @RequestMapping(\"/session\")\n     public String session(Model model, @RequestParam String clientId, @RequestParam String messageOrigin) {\n// bug_start\n        model.addAttribute(\"clientId\", clientId);\n        model.addAttribute(\"messageOrigin\", messageOrigin);\n// bug_end\n         return \"session\";\n     }\n \n", "target": "// fix_start\n        model.addAttribute(\"clientId\", escape(clientId));\n        model.addAttribute(\"messageOrigin\", escape(messageOrigin));\n// fix_end\n", "cwe": "CWE-79", "cwe_name": "Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')", "idx": 80391}
{"source": " protected InputStream findXsltInputStream(WebResource directory)\n         throws IOException {\n \n         if (localXsltFile != null) {\n             WebResource resource = resources.getResource(\n                     directory.getWebappPath() + localXsltFile);\n             if (resource.isFile()) {\n                 InputStream is = resource.getInputStream();\n                 if (is != null) {\n                     return is;\n                 }\n             }\n             if (debug > 10) {\n                 log(\"localXsltFile '\" + localXsltFile + \"' not found\");\n             }\n         }\n \n         if (contextXsltFile != null) {\n             InputStream is =\n                 getServletContext().getResourceAsStream(contextXsltFile);\n             if (is != null)\n                 return is;\n \n             if (debug > 10)\n                 log(\"contextXsltFile '\" + contextXsltFile + \"' not found\");\n         }\n \n// bug_start\n        if (globalXsltFile!=null) {\n            FileInputStream fis = null;\n\n            try {\n                File f = new File(globalXsltFile);\n                if (f.exists()){\n                    fis =new FileInputStream(f);\n// bug_end\n                     byte b[] = new byte[(int)f.length()];\n                     fis.read(b);\n                     return new ByteArrayInputStream(b);\n                 }\n// bug_start\n            } finally {\n                if (fis!=null)\n                    fis.close();\n// bug_end\n             }\n         }\n \n         return null;\n     }\n \n", "target": "// fix_start\n        if (globalXsltFile != null) {\n            File f = validateGlobalXsltFile();\n            if (f != null && f.exists()){\n                try (FileInputStream fis = new FileInputStream(f)){\n// fix_end\n// fix_start\n// fix_end\n", "cwe": "CWE-264", "cwe_name": "Permissions, Privileges, and Access Controls", "idx": 32430}
{"source": " @RequestMapping(value=\"/change_password.do\", method = POST)\n     public String changePassword(\n             Model model,\n             @RequestParam(\"current_password\") String currentPassword,\n             @RequestParam(\"new_password\") String newPassword,\n             @RequestParam(\"confirm_password\") String confirmPassword,\n             HttpServletResponse response,\n             HttpServletRequest request) {\n \n         PasswordConfirmationValidation validation = new PasswordConfirmationValidation(newPassword, confirmPassword);\n         if (!validation.valid()) {\n             model.addAttribute(\"message_code\", validation.getMessageCode());\n             response.setStatus(HttpStatus.UNPROCESSABLE_ENTITY.value());\n             return \"change_password\";\n         }\n \n         SecurityContext securityContext = SecurityContextHolder.getContext();\n         Authentication authentication = securityContext.getAuthentication();\n         String username = authentication.getName();\n \n         try {\n             changePasswordService.changePassword(username, currentPassword, newPassword);\n             request.getSession().invalidate();\n             request.getSession(true);\n// bug_start\n// bug_end\n             securityContext.setAuthentication(authentication);\n             return \"redirect:profile\";\n         } catch (BadCredentialsException e) {\n             model.addAttribute(\"message_code\", \"unauthorized\");\n         } catch (InvalidPasswordException e) {\n             model.addAttribute(\"message\", e.getMessagesAsOneString());\n         }\n         response.setStatus(HttpStatus.UNPROCESSABLE_ENTITY.value());\n         return \"change_password\";\n     }\n \n", "target": "// fix_start\n            if (authentication instanceof UaaAuthentication) {\n                UaaAuthentication uaaAuthentication = (UaaAuthentication)authentication;\n                authentication = new UaaAuthentication(\n                    uaaAuthentication.getPrincipal(),\n                    new LinkedList<>(uaaAuthentication.getAuthorities()),\n                    new UaaAuthenticationDetails(request)\n                );\n            }\n// fix_end\n", "cwe": "CWE-613", "cwe_name": "Insufficient Session Expiration", "idx": 70897}
{"source": " protected DocumentBuilder getDocumentBuilder() throws IOException {\n         DocumentBuilder result = null;\n \n         try {\n             DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();\n             dbf.setNamespaceAware(isNamespaceAware());\n             dbf.setValidating(isValidatingDtd());\n             dbf.setCoalescing(isCoalescing());\n// bug_start\n            dbf.setExpandEntityReferences(isExpandingEntityRefs());\n// bug_end\n             dbf.setIgnoringComments(isIgnoringComments());\n             dbf.setIgnoringElementContentWhitespace(isIgnoringExtraWhitespaces());\n \n             try {\n                 dbf.setXIncludeAware(isXIncludeAware());\n             } catch (UnsupportedOperationException uoe) {\n                 Context.getCurrentLogger().log(Level.FINE,\n                         \"The JAXP parser doesn't support XInclude.\", uoe);\n             }\n \n             javax.xml.validation.Schema xsd = getSchema();\n \n             if (xsd != null) {\n                 dbf.setSchema(xsd);\n             }\n \n             result = dbf.newDocumentBuilder();\n             result.setEntityResolver(getEntityResolver());\n             result.setErrorHandler(getErrorHandler());\n         } catch (ParserConfigurationException pce) {\n             throw new IOException(\"Couldn't create the empty document: \"\n                     + pce.getMessage());\n         }\n \n         return result;\n     }\n \n", "target": "// fix_start\n            dbf.setExpandEntityReferences(false);\n            dbf.setFeature(\"http://xml.org/sax/features/external-parameter-entities\",isExpandingEntityRefs());\n            dbf.setFeature(\"http://xml.org/sax/features/external-general-entities\",isExpandingEntityRefs());\n\n// fix_end\n", "cwe": "CWE-611", "cwe_name": "Improper Restriction of XML External Entity Reference ('XXE')", "idx": 67900}
{"source": " @Override\n     public void send(Map<String, String> config, UserModel user, String subject, String textBody, String htmlBody) throws EmailException {\n         Transport transport = null;\n         try {\n             String address = retrieveEmailAddress(user);\n \n             Properties props = new Properties();\n \n             if (config.containsKey(\"host\")) {\n                 props.setProperty(\"mail.smtp.host\", config.get(\"host\"));\n             }\n \n             boolean auth = \"true\".equals(config.get(\"auth\"));\n             boolean ssl = \"true\".equals(config.get(\"ssl\"));\n             boolean starttls = \"true\".equals(config.get(\"starttls\"));\n \n             if (config.containsKey(\"port\") && config.get(\"port\") != null) {\n                 props.setProperty(\"mail.smtp.port\", config.get(\"port\"));\n             }\n \n             if (auth) {\n                 props.setProperty(\"mail.smtp.auth\", \"true\");\n             }\n \n             if (ssl) {\n                 props.setProperty(\"mail.smtp.ssl.enable\", \"true\");\n             }\n \n             if (starttls) {\n                 props.setProperty(\"mail.smtp.starttls.enable\", \"true\");\n             }\n \n             if (ssl || starttls) {\n// bug_start\n// bug_end\n                 setupTruststore(props);\n             }\n \n             props.setProperty(\"mail.smtp.timeout\", \"10000\");\n             props.setProperty(\"mail.smtp.connectiontimeout\", \"10000\");\n \n             String from = config.get(\"from\");\n             String fromDisplayName = config.get(\"fromDisplayName\");\n             String replyTo = config.get(\"replyTo\");\n             String replyToDisplayName = config.get(\"replyToDisplayName\");\n             String envelopeFrom = config.get(\"envelopeFrom\");\n \n             Session session = Session.getInstance(props);\n \n             Multipart multipart = new MimeMultipart(\"alternative\");\n \n             if (textBody != null) {\n                 MimeBodyPart textPart = new MimeBodyPart();\n                 textPart.setText(textBody, \"UTF-8\");\n                 multipart.addBodyPart(textPart);\n             }\n \n             if (htmlBody != null) {\n                 MimeBodyPart htmlPart = new MimeBodyPart();\n                 htmlPart.setContent(htmlBody, \"text/html; charset=UTF-8\");\n                 multipart.addBodyPart(htmlPart);\n             }\n \n             SMTPMessage msg = new SMTPMessage(session);\n             msg.setFrom(toInternetAddress(from, fromDisplayName));\n \n             msg.setReplyTo(new Address[]{toInternetAddress(from, fromDisplayName)});\n             if (replyTo != null && !replyTo.isEmpty()) {\n                 msg.setReplyTo(new Address[]{toInternetAddress(replyTo, replyToDisplayName)});\n             }\n             if (envelopeFrom != null && !envelopeFrom.isEmpty()) {\n                 msg.setEnvelopeFrom(envelopeFrom);\n             }\n \n             msg.setHeader(\"To\", address);\n             msg.setSubject(subject, \"utf-8\");\n             msg.setContent(multipart);\n             msg.saveChanges();\n             msg.setSentDate(new Date());\n \n             transport = session.getTransport(\"smtp\");\n             if (auth) {\n                 try (VaultStringSecret vaultStringSecret = this.session.vault().getStringSecret(config.get(\"password\"))) {\n                     transport.connect(config.get(\"user\"), vaultStringSecret.get().orElse(config.get(\"password\")));\n                 }\n             } else {\n                 transport.connect();\n             }\n             transport.sendMessage(msg, new InternetAddress[]{new InternetAddress(address)});\n         } catch (Exception e) {\n             ServicesLogger.LOGGER.failedToSendEmail(e);\n             throw new EmailException(e);\n         } finally {\n             if (transport != null) {\n                 try {\n                     transport.close();\n                 } catch (MessagingException e) {\n                     logger.warn(\"Failed to close transport\", e);\n                 }\n             }\n         }\n     }\n \n", "target": "// fix_start\n                props.put(\"mail.smtp.ssl.protocols\", SUPPORTED_SSL_PROTOCOLS);\n\n// fix_end\n", "cwe": "CWE-295", "cwe_name": "Improper Certificate Validation", "idx": 40502}
{"source": " protected static File getTmpFolder() {\n         try {\n// bug_start\n            File outputFolder = File.createTempFile(\"codegen-\", \"-tmp\");\n            outputFolder.delete();\n            outputFolder.mkdir();\n// bug_end\n             outputFolder.deleteOnExit();\n             return outputFolder;\n         } catch (Exception e) {\n             e.printStackTrace();\n             return null;\n         }\n     }\n \n", "target": "// fix_start\n            File outputFolder = Files.createTempDirectory(\"codegen-\").toFile();\n// fix_end\n", "cwe": "CWE-378", "cwe_name": "", "idx": 50011}
{"source": " @Override\n   public void handle(RoutingContext ctx) {\n \n     if (nagHttps) {\n       String uri = ctx.request().absoluteURI();\n       if (uri != null && !uri.startsWith(\"https:\")) {\n         log.warn(\"Using session cookies without https could make you susceptible to session hijacking: \" + uri);\n       }\n     }\n \n     HttpMethod method = ctx.request().method();\n \n     switch (method) {\n       case GET:\n         final String token = generateToken();\n         ctx.put(headerName, token);\n         ctx.addCookie(Cookie.cookie(cookieName, token).setPath(cookiePath));\n         ctx.next();\n         break;\n       case POST:\n       case PUT:\n       case DELETE:\n       case PATCH:\n         final String header = ctx.request().getHeader(headerName);\n// bug_start\n        if (validateToken(header == null ? ctx.request().getFormAttribute(headerName) : header)) {\n// bug_end\n           ctx.next();\n         } else {\n           forbidden(ctx);\n         }\n         break;\n       default:\n         ctx.next();\n         break;\n     }\n   }\n \n", "target": "// fix_start\n        final String cookie = ctx.getCookie(cookieName).getValue();\n        if (validateToken(header == null ? ctx.request().getFormAttribute(headerName) : header, cookie)) {\n// fix_end\n", "cwe": "CWE-352", "cwe_name": "Cross-Site Request Forgery (CSRF)", "idx": 48023}
{"source": "// bug_start\npublic FormValidation doSendTestMail(\n// bug_end\n                 @QueryParameter String smtpServer, @QueryParameter String adminAddress, @QueryParameter boolean useSMTPAuth,\n                 @QueryParameter String smtpAuthUserName, @QueryParameter Secret smtpAuthPasswordSecret,\n                 @QueryParameter boolean useSsl, @QueryParameter String smtpPort, @QueryParameter String charset,\n                 @QueryParameter String sendTestMailTo) throws IOException, ServletException, InterruptedException {\n             try {\n                 final Jenkins jenkins = Jenkins.getInstance();\n                 if (jenkins == null) {\n                     throw new IOException(\"Jenkins instance is not ready\");\n                 }\n// bug_start\n// bug_end\n \n                 if (!useSMTPAuth) {\n                     smtpAuthUserName = null;\n                     smtpAuthPasswordSecret = null;\n                 }\n \n                 MimeMessage msg = new MimeMessage(createSession(smtpServer, smtpPort, useSsl, smtpAuthUserName, smtpAuthPasswordSecret));\n                 msg.setSubject(Messages.Mailer_TestMail_Subject(testEmailCount.incrementAndGet()), charset);\n                 msg.setText(Messages.Mailer_TestMail_Content(testEmailCount.get(), jenkins.getDisplayName()), charset);\n                 msg.setFrom(stringToAddress(adminAddress, charset));\n                 if (StringUtils.isNotBlank(replyToAddress)) {\n                     msg.setReplyTo(new Address[]{stringToAddress(replyToAddress, charset)});\n                 }\n                 msg.setSentDate(new Date());\n                 msg.setRecipient(Message.RecipientType.TO, stringToAddress(sendTestMailTo, charset));\n \n                 Transport.send(msg);\n                 return FormValidation.ok(Messages.Mailer_EmailSentSuccessfully());\n             } catch (MessagingException e) {\n                 return FormValidation.errorWithMarkup(\"<p>\"+Messages.Mailer_FailedToSendEmail()+\"</p><pre>\"+Util.escape(Functions.printThrowable(e))+\"</pre>\");\n             }\n         }\n \n", "target": "// fix_start\n@RequirePOST\n        public FormValidation doSendTestMail(\n// fix_end\n// fix_start\n\n                jenkins.checkPermission(Jenkins.ADMINISTER);\n// fix_end\n", "cwe": "CWE-352", "cwe_name": "Cross-Site Request Forgery (CSRF)", "idx": 47162}
{"source": " private void introspectInterfaces(Class<?> beanClass, Class<?> currClass) throws IntrospectionException {\n \t\tfor (Class<?> ifc : currClass.getInterfaces()) {\n \t\t\tif (!ClassUtils.isJavaLanguageInterface(ifc)) {\n \t\t\t\tfor (PropertyDescriptor pd : getBeanInfo(ifc).getPropertyDescriptors()) {\n \t\t\t\t\tPropertyDescriptor existingPd = this.propertyDescriptors.get(pd.getName());\n \t\t\t\t\tif (existingPd == null ||\n \t\t\t\t\t\t\t(existingPd.getReadMethod() == null && pd.getReadMethod() != null)) {\n \t\t\t\t\t\tpd = buildGenericTypeAwarePropertyDescriptor(beanClass, pd);\n// bug_start\n// bug_end\n \t\t\t\t\t\tthis.propertyDescriptors.put(pd.getName(), pd);\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\tintrospectInterfaces(ifc, ifc);\n \t\t\t}\n \t\t}\n \t}\n \n", "target": "// fix_start\n\t\t\t\t\t\tif (pd.getPropertyType() != null && (ClassLoader.class.isAssignableFrom(pd.getPropertyType())\n\t\t\t\t\t\t\t\t|| ProtectionDomain.class.isAssignableFrom(pd.getPropertyType()))) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n// fix_end\n", "cwe": "CWE-94", "cwe_name": "Improper Control of Generation of Code ('Code Injection')", "idx": 95364}
{"source": "// bug_start\n@RequirePOST\n// bug_end\n     public void doConfigSubmit(StaplerRequest req, StaplerResponse rsp) throws IOException, ServletException {\n// bug_start\n// bug_end\n         this.implications(req.bindJSONToList(\n                 Implication.class, req.getSubmittedForm().get(\"impl\")\n         ));\n         rsp.sendRedirect(\"\");\n     }\n \n", "target": "// fix_start\n@POST\n// fix_end\n// fix_start\n        Jenkins.get().checkPermission(Jenkins.ADMINISTER);\n// fix_end\n", "cwe": "CWE-862", "cwe_name": "Missing Authorization", "idx": 85311}
{"source": " void resumeReadsInternal(boolean wakeup) {\n         synchronized (lock) {\n             boolean alreadyResumed = anyAreSet(state, STATE_READS_RESUMED);\n             state |= STATE_READS_RESUMED;\n             if (!alreadyResumed || wakeup) {\n                 if (!anyAreSet(state, STATE_IN_LISTENER_LOOP)) {\n                     state |= STATE_IN_LISTENER_LOOP;\n                     getFramedChannel().runInIoThread(new Runnable() {\n \n                         @Override\n                         public void run() {\n                             try {\n                                 boolean moreData;\n                                 do {\n                                     ChannelListener<? super R> listener = getReadListener();\n                                     if (listener == null || !isReadResumed()) {\n                                         return;\n                                     }\n                                     ChannelListeners.invokeChannelListener((R) AbstractFramedStreamSourceChannel.this, listener);\n                                     moreData = (frameDataRemaining > 0 && data != null) || !pendingFrameData.isEmpty() || anyAreSet(state, STATE_WAITNG_MINUS_ONE);\n                                 }\n// bug_start\n                                while (allAreSet(state, STATE_READS_RESUMED) && allAreClear(state, STATE_CLOSED) && moreData);\n// bug_end\n                             } finally {\n                                 state &= ~STATE_IN_LISTENER_LOOP;\n                             }\n                         }\n                     });\n                 }\n             }\n         }\n     }\n \n", "target": "// fix_start\n                                while (allAreSet(state, STATE_READS_RESUMED) && allAreClear(state, STATE_CLOSED | STATE_STREAM_BROKEN) && moreData);\n// fix_end\n", "cwe": "CWE-835", "cwe_name": "Loop with Unreachable Exit Condition ('Infinite Loop')", "idx": 82208}
{"source": " public Object map2bean(final Map map, Class targetType) {\n \t\tObject target = null;\n \n \t\tString className = (String) map.get(classMetadataName);\n \n \t\tif (className == null) {\n \t\t\tif (targetType == null) {\n \t\t\t\ttarget = map;\n \t\t\t}\n \t\t}\n \t\telse {\n// bug_start\n// bug_end\n \t\t\ttry {\n \t\t\t\ttargetType = ClassLoaderUtil.loadClass(className);\n \t\t\t} catch (ClassNotFoundException cnfex) {\n \t\t\t\tthrow new JsonException(cnfex);\n \t\t\t}\n \t\t}\n \n \t\tif (target == null) {\n \t\t\ttarget = jsonParser.newObjectInstance(targetType);\n \t\t}\n \n \t\tClassDescriptor cd = ClassIntrospector.get().lookup(target.getClass());\n \n \t\tboolean targetIsMap = target instanceof Map;\n \n \t\tfor (Object key : map.keySet()) {\n \t\t\tString keyName = key.toString();\n \n \t\t\tif (classMetadataName != null) {\n \t\t\t\tif (keyName.equals(classMetadataName)) {\n \t\t\t\t\tcontinue;\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tPropertyDescriptor pd = cd.getPropertyDescriptor(keyName, declared);\n \n \t\t\tif (!targetIsMap && pd == null) {\n \t\t\t\tcontinue;\n \t\t\t}\n \n \t\t\tObject value = map.get(key);\n \n \t\t\tClass propertyType = pd == null ? null : pd.getType();\n \t\t\tClass componentType = pd == null ? null : pd.resolveComponentType(true);\n \n \t\t\tif (value != null) {\n \t\t\t\tif (value instanceof List) {\n \t\t\t\t\tif (componentType != null && componentType != String.class) {\n \t\t\t\t\t\tvalue = generifyList((List) value, componentType);\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\telse if (value instanceof Map) {\n \t\t\t\t\tif (!ClassUtil.isTypeOf(propertyType, Map.class)) {\n \t\t\t\t\t\tvalue = map2bean((Map) value, propertyType);\n \t\t\t\t\t}\n \t\t\t\t\telse {\n \t\t\t\t\t\tClass keyType = pd == null ? null : pd.resolveKeyType(true);\n \n \t\t\t\t\t\tif (keyType != String.class || componentType != String.class) {\n \t\t\t\t\t\t\tvalue = generifyMap((Map) value, keyType, componentType);\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \n \t\t\tif (targetIsMap) {\n \t\t\t\t((Map)target).put(keyName, value);\n \t\t\t}\n \t\t\telse {\n \t\t\t\ttry {\n \t\t\t\t\tsetValue(target, pd, value);\n \t\t\t\t} catch (Exception ignore) {\n \t\t\t\t\tignore.printStackTrace();\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \n \t\treturn target;\n \t}\n \n", "target": "// fix_start\n\t\t\tcheckClassName(jsonParser.classnameWhitelist, className);\n\n// fix_end\n", "cwe": "CWE-502", "cwe_name": "Deserialization of Untrusted Data", "idx": 59457}
{"source": "// bug_start\n@Override\n    public void setAllowJavaSerializedObject(boolean allowJavaSerializedObject) {\n        super.setAllowJavaSerializedObject(allowJavaSerializedObject);\n// bug_end\n     }\n \n", "target": "// fix_start\nprotected SchemaFactory createSchemaFactory() {\n        SchemaFactory factory = SchemaFactory.newInstance(schemaLanguage);\n        if (getResourceResolver() != null) {\n            factory.setResourceResolver(getResourceResolver());\n        }\n        if (camelContext == null || !Boolean.parseBoolean(camelContext.getGlobalOptions().get(ACCESS_EXTERNAL_DTD))) {\n            try {\n                factory.setProperty(XMLConstants.ACCESS_EXTERNAL_DTD, \"\");\n            } catch (SAXException e) {\n                LOG.error(e.getMessage(), e);\n                throw new IllegalStateException(e);\n            }\n        }\n        return factory;\n// fix_end\n", "cwe": "CWE-611", "cwe_name": "Improper Restriction of XML External Entity Reference ('XXE')", "idx": 67141}
{"source": "// bug_start\npublic static ClusterNodeInformation unmarshal(final InputStream is) throws JAXBException {\n        try {\n            final Unmarshaller unmarshaller = JAXB_CONTEXT.createUnmarshaller();\n            final XMLStreamReader xsr = XmlUtils.createSafeReader(is);\n            return (ClusterNodeInformation) unmarshaller.unmarshal(xsr);\n        } catch (XMLStreamException e) {\n            throw new JAXBException(\"Error unmarshalling the cluster node information\", e);\n        }\n// bug_end\n     }\n \n", "target": "// fix_start\npublic void setAllowJavaSerializedObject(boolean allowJavaSerializedObject) {\n        this.allowJavaSerializedObject = allowJavaSerializedObject;\n// fix_end\n", "cwe": "CWE-19", "cwe_name": "Data Handling", "idx": 4129}
{"source": "// bug_start\npublic static ClusterNodeInformation unmarshal(final InputStream is) throws JAXBException {\n        final Unmarshaller unmarshaller = JAXB_CONTEXT.createUnmarshaller();\n        return (ClusterNodeInformation) unmarshaller.unmarshal(is);\n// bug_end\n     }\n \n", "target": "// fix_start\n@Override\n    @SuppressWarnings(\"unchecked\")\n    public <T> T fromString(String content, Class<T> classOfT) {\n        try (StringReader reader = new StringReader(content)) {\n            JAXBContext jaxbContext = JAXBContext.newInstance(classOfT);\n\n            XMLInputFactory xmlInputFactory = XMLInputFactory.newFactory();\n            xmlInputFactory.setProperty(XMLInputFactory.IS_SUPPORTING_EXTERNAL_ENTITIES, false);\n            xmlInputFactory.setProperty(XMLInputFactory.SUPPORT_DTD, true);\n            XMLStreamReader xmlStreamReader = xmlInputFactory.createXMLStreamReader(reader);\n\n            Unmarshaller unmarshaller = jaxbContext.createUnmarshaller();\n\n            return (T) unmarshaller.unmarshal(xmlStreamReader);\n        } catch (JAXBException | XMLStreamException e) {\n            throw new PippoRuntimeException(e, \"Failed to deserialize content to '{}'\", classOfT.getName());\n        }\n// fix_end\n", "cwe": "CWE-611", "cwe_name": "Improper Restriction of XML External Entity Reference ('XXE')", "idx": 67994}
{"source": "// bug_start\n@Override\n    @SuppressWarnings(\"unchecked\")\n    public <T> T fromString(String content, Class<T> classOfT) {\n        try (StringReader reader = new StringReader(content)) {\n            JAXBContext jaxbContext = JAXBContext.newInstance(classOfT);\n            Unmarshaller jaxbUnmarshaller = jaxbContext.createUnmarshaller();\n// bug_end\n \n// bug_start\n            return (T) jaxbUnmarshaller.unmarshal(reader);\n        } catch (JAXBException e) {\n            throw new PippoRuntimeException(e, \"Failed to deserialize content to '{}'\", classOfT.getName());\n// bug_end\n         }\n// bug_start\n// bug_end\n     }\n \n", "target": "// fix_start\nprotected TlsSecret safeDecryptPreMasterSecret(TlsCryptoParameters cryptoParams, PrivateKey rsaServerPrivateKey,\n                                                   byte[] encryptedPreMasterSecret)\n    {\n        SecureRandom secureRandom = crypto.getSecureRandom();\n// fix_end\n// fix_start\n        ProtocolVersion clientVersion = cryptoParams.getClientVersion();\n\n        boolean versionNumberCheckDisabled = false;\n\n        byte[] fallback = new byte[48];\n        secureRandom.nextBytes(fallback);\n\n        byte[] M = Arrays.clone(fallback);\n        try\n        {\n            Cipher c = crypto.createRSAEncryptionCipher();\n            c.init(Cipher.DECRYPT_MODE, rsaServerPrivateKey);\n            M = c.doFinal(encryptedPreMasterSecret);\n// fix_end\n// fix_start\n        catch (Exception e)\n        {\n        }\n\n        if (versionNumberCheckDisabled && clientVersion.isEqualOrEarlierVersionOf(ProtocolVersion.TLSv10))\n        {\n        }\n        else\n        {\n            int correct = (clientVersion.getMajorVersion() ^ (M[0] & 0xff))\n                | (clientVersion.getMinorVersion() ^ (M[1] & 0xff));\n            correct |= correct >> 1;\n            correct |= correct >> 2;\n            correct |= correct >> 4;\n            int mask = ~((correct & 1) - 1);\n\n            for (int i = 0; i < 48; i++)\n            {\n                M[i] = (byte)((M[i] & (~mask)) | (fallback[i] & mask));\n            }\n        }\n        return crypto.createSecret(M);\n// fix_end\n", "cwe": "CWE-611", "cwe_name": "Improper Restriction of XML External Entity Reference ('XXE')", "idx": 68625}
{"source": "// bug_start\npublic void testValidUrlWithDefaultRegex() throws Exception {\n        URLValidator validator = new URLValidator();\n// bug_end\n \n// bug_start\n        Pattern pattern = Pattern.compile(validator.getUrlRegex(), Pattern.CASE_INSENSITIVE);\n// bug_end\n \n// bug_start\n        assertFalse(pattern.matcher(\"myapp://test.com\").matches());\n        assertFalse(pattern.matcher(\"myap://test.com\").matches());\n        assertFalse(pattern.matcher(\"\").matches());\n        assertFalse(pattern.matcher(\"   \").matches());\n        assertFalse(pattern.matcher(\"no url\").matches());\n        assertFalse(pattern.matcher(\"http://example.com////////////////////////////////////////////////////////////////////////////////////??\").matches());\n// bug_end\n \n// bug_start\n        assertTrue(pattern.matcher(\"http://www.opensymphony.com\").matches());\n        assertTrue(pattern.matcher(\"https://www.opensymphony.com\").matches());\n        assertTrue(pattern.matcher(\"https://www.opensymphony.com:443/login\").matches());\n        assertTrue(pattern.matcher(\"http://localhost:8080/myapp\").matches());\n// bug_end\n \n// bug_start\n        assertTrue(pattern.matcher(\"http://www.legalspace.com/__media__/js/netsoltrademark.php?d=www.a-vos-travaux.fr%2Facheter-un-aspirateur-sans-sac-pas-cher%2F\").matches());\n        assertTrue(UrlValidator.getInstance().isValid(\"http://www.legalspace.com/__media__/js/netsoltrademark.php?d=www.a-vos-travaux.fr%2Facheter-un-aspirateur-sans-sac-pas-cher%2F\"));\n// bug_end\n \n// bug_start\n        assertTrue(pattern.matcher(\"http://www.duadmin.isaev.Infoduadmin.Isaev.info/?a%5B%5D=%3Ca%20href%3Dhttp%3A%2F%2Fwww.aspert.fr%2Fun-seche-cheveux-lisseur-est-il-vraiment-utile%2F%3Eseche%20cheveux%20dyson%20test%3C%2Fa\").matches());\n        assertTrue(UrlValidator.getInstance().isValid(\"http://www.duadmin.isaev.Infoduadmin.Isaev.info/?a%5B%5D=%3Ca%20href%3Dhttp%3A%2F%2Fwww.aspert.fr%2Fun-seche-cheveux-lisseur-est-il-vraiment-utile%2F%3Eseche%20cheveux%20dyson%20test%3C%2Fa\"));\n// bug_end\n \n// bug_start\n        assertTrue(pattern.matcher(\"http://netsol-underconstruction-page-monitor-1.com/__media__/js/netsoltrademark.php?d=www.le-soutien-scolaire.fr%2Favis-et-test-comparatifs-des-robots-multifonctions%2F\").matches());\n        assertTrue(UrlValidator.getInstance().isValid(\"http://netsol-underconstruction-page-monitor-1.com/__media__/js/netsoltrademark.php?d=www.le-soutien-scolaire.fr%2Favis-et-test-comparatifs-des-robots-multifonctions%2F\"));\n\n        assertTrue(pattern.matcher(\"http://www.javaroad.jp/news/redirect.jsp?link=http://www.forum-course-de-cote.com/que-penser-dune-trottinette-electrique/\").matches());\n        assertTrue(UrlValidator.getInstance().isValid(\"http://www.javaroad.jp/news/redirect.jsp?link=http://www.forum-course-de-cote.com/que-penser-dune-trottinette-electrique/\"));\n\n        assertTrue(pattern.matcher(\"http://wargame.ch/wc/acw/sub/aotm/guestbook/index.php?page3D183EClearwater20Roofing20Contractors3C/a3E3Ekaldu20non20msg3C/a3E\").matches());\n        assertTrue(UrlValidator.getInstance().isValid(\"http://wargame.ch/wc/acw/sub/aotm/guestbook/index.php?page3D183EClearwater20Roofing20Contractors3C/a3E3Ekaldu20non20msg3C/a3E\"));\n\n        assertTrue(pattern.matcher(\"http://253.254.255.1\").matches());\n        assertTrue(UrlValidator.getInstance().isValid(\"http://253.254.255.1\"));\n\n        assertTrue(pattern.matcher(\"http://253.254.255.12\").matches());\n        assertTrue(UrlValidator.getInstance().isValid(\"http://253.254.255.12\"));\n\n        assertTrue(pattern.matcher(\"http://1.2.3.100\").matches());\n        assertTrue(UrlValidator.getInstance().isValid(\"http://1.2.3.100\"));\n\n        assertTrue(pattern.matcher(\"http://1.2.3.255\").matches());\n        assertTrue(UrlValidator.getInstance().isValid(\"http://1.2.3.255\"));\n\n// bug_end\n     }\n \n", "target": "// fix_start\nprotected TlsSecret safeDecryptPreMasterSecret(TlsCryptoParameters cryptoParams, PrivateKey rsaServerPrivateKey,\n                                                   byte[] encryptedPreMasterSecret)\n    {\n        SecureRandom secureRandom = crypto.getSecureRandom();\n// fix_end\n// fix_start\n        ProtocolVersion clientVersion = cryptoParams.getClientVersion();\n// fix_end\n// fix_start\n        boolean versionNumberCheckDisabled = false;\n// fix_end\n// fix_start\n        byte[] fallback = new byte[48];\n        secureRandom.nextBytes(fallback);\n// fix_end\n// fix_start\n        byte[] M = Arrays.clone(fallback);\n        try\n        {\n            Cipher c = crypto.createRSAEncryptionCipher();\n            c.init(Cipher.DECRYPT_MODE, rsaServerPrivateKey);\n            byte[] m = c.doFinal(encryptedPreMasterSecret);\n            if (m != null && m.length == 48)\n            {\n                M = m;\n            }\n        }\n        catch (Exception e)\n        {\n        }\n// fix_end\n// fix_start\n        if (versionNumberCheckDisabled && clientVersion.isEqualOrEarlierVersionOf(ProtocolVersion.TLSv10))\n        {\n        }\n        else\n        {\n            int correct = (clientVersion.getMajorVersion() ^ (M[0] & 0xff))\n                | (clientVersion.getMinorVersion() ^ (M[1] & 0xff));\n            correct |= correct >> 1;\n            correct |= correct >> 2;\n            correct |= correct >> 4;\n            int mask = ~((correct & 1) - 1);\n// fix_end\n// fix_start\n            for (int i = 0; i < 48; i++)\n            {\n                M[i] = (byte)((M[i] & (~mask)) | (fallback[i] & mask));\n            }\n        }\n        return crypto.createSecret(M);\n// fix_end\n", "cwe": "CWE-203", "cwe_name": "Information Exposure Through Discrepancy", "idx": 20524}
{"source": "// bug_start\npublic void testValidUrlWithDefaultRegex() throws Exception {\n        URLValidator validator = new URLValidator();\n\n        Pattern pattern = Pattern.compile(validator.getUrlRegex(), Pattern.CASE_INSENSITIVE);\n\n        assertFalse(pattern.matcher(\"myapp://test.com\").matches());\n        assertFalse(pattern.matcher(\"myap://test.com\").matches());\n        assertFalse(pattern.matcher(\"\").matches());\n        assertFalse(pattern.matcher(\"   \").matches());\n        assertFalse(pattern.matcher(\"no url\").matches());\n        assertFalse(pattern.matcher(\"http://example.com////////////////////////////////////////////////////////////////////////////////////??\").matches());\n\n        assertTrue(pattern.matcher(\"http://www.opensymphony.com\").matches());\n        assertTrue(pattern.matcher(\"https://www.opensymphony.com\").matches());\n        assertTrue(pattern.matcher(\"https://www.opensymphony.com:443/login\").matches());\n        assertTrue(pattern.matcher(\"http://localhost:8080/myapp\").matches());\n\n        assertTrue(pattern.matcher(\"http://www.legalspace.com/__media__/js/netsoltrademark.php?d=www.a-vos-travaux.fr%2Facheter-un-aspirateur-sans-sac-pas-cher%2F\").matches());\n        assertTrue(UrlValidator.getInstance().isValid(\"http://www.legalspace.com/__media__/js/netsoltrademark.php?d=www.a-vos-travaux.fr%2Facheter-un-aspirateur-sans-sac-pas-cher%2F\"));\n\n        assertTrue(pattern.matcher(\"http://www.duadmin.isaev.Infoduadmin.Isaev.info/?a%5B%5D=%3Ca%20href%3Dhttp%3A%2F%2Fwww.aspert.fr%2Fun-seche-cheveux-lisseur-est-il-vraiment-utile%2F%3Eseche%20cheveux%20dyson%20test%3C%2Fa\").matches());\n        assertTrue(UrlValidator.getInstance().isValid(\"http://www.duadmin.isaev.Infoduadmin.Isaev.info/?a%5B%5D=%3Ca%20href%3Dhttp%3A%2F%2Fwww.aspert.fr%2Fun-seche-cheveux-lisseur-est-il-vraiment-utile%2F%3Eseche%20cheveux%20dyson%20test%3C%2Fa\"));\n\n        assertTrue(pattern.matcher(\"http://netsol-underconstruction-page-monitor-1.com/__media__/js/netsoltrademark.php?d=www.le-soutien-scolaire.fr%2Favis-et-test-comparatifs-des-robots-multifonctions%2F\").matches());\n        assertTrue(UrlValidator.getInstance().isValid(\"http://netsol-underconstruction-page-monitor-1.com/__media__/js/netsoltrademark.php?d=www.le-soutien-scolaire.fr%2Favis-et-test-comparatifs-des-robots-multifonctions%2F\"));\n\n        assertTrue(pattern.matcher(\"http://www.javaroad.jp/news/redirect.jsp?link=http://www.forum-course-de-cote.com/que-penser-dune-trottinette-electrique/\").matches());\n        assertTrue(UrlValidator.getInstance().isValid(\"http://www.javaroad.jp/news/redirect.jsp?link=http://www.forum-course-de-cote.com/que-penser-dune-trottinette-electrique/\"));\n\n        assertTrue(pattern.matcher(\"http://wargame.ch/wc/acw/sub/aotm/guestbook/index.php?page3D183EClearwater20Roofing20Contractors3C/a3E3Ekaldu20non20msg3C/a3E\").matches());\n        assertTrue(UrlValidator.getInstance().isValid(\"http://wargame.ch/wc/acw/sub/aotm/guestbook/index.php?page3D183EClearwater20Roofing20Contractors3C/a3E3Ekaldu20non20msg3C/a3E\"));\n// bug_end\n     }\n \n", "target": "// fix_start\nprivate void expand(ArchiveEntrySupplier supplier, EntryWriter writer, File targetDirectory)\n        throws IOException {\n        String targetDirPath = targetDirectory.getCanonicalPath() + File.separatorChar;\n        ArchiveEntry nextEntry = supplier.getNextReadableEntry();\n        while (nextEntry != null) {\n            File f = new File(targetDirectory, nextEntry.getName());\n            if (!f.getCanonicalPath().startsWith(targetDirPath)) {\n                throw new IOException(\"expanding \" + nextEntry.getName()\n                    + \" would create file outside of \" + targetDirectory);\n            }\n            if (nextEntry.isDirectory()) {\n                if (!f.isDirectory() && !f.mkdirs()) {\n                    throw new IOException(\"failed to create directory \" + f);\n                }\n            } else {\n                File parent = f.getParentFile();\n                if (!parent.isDirectory() && !parent.mkdirs()) {\n                    throw new IOException(\"failed to create directory \" + parent);\n                }\n                try (OutputStream o = Files.newOutputStream(f.toPath())) {\n                    writer.writeEntryDataTo(nextEntry, o);\n                }\n            }\n            nextEntry = supplier.getNextReadableEntry();\n        }\n// fix_end\n", "cwe": "CWE-20", "cwe_name": "Improper Input Validation", "idx": 7195}
{"source": "// bug_start\nprivate void expand(ArchiveEntrySupplier supplier, EntryWriter writer, File targetDirectory)\n        throws IOException {\n        String targetDirPath = targetDirectory.getCanonicalPath();\n        ArchiveEntry nextEntry = supplier.getNextReadableEntry();\n        while (nextEntry != null) {\n            File f = new File(targetDirectory, nextEntry.getName());\n            if (!f.getCanonicalPath().startsWith(targetDirPath)) {\n                throw new IOException(\"expanding \" + nextEntry.getName()\n                    + \" would create file outside of \" + targetDirectory);\n            }\n            if (nextEntry.isDirectory()) {\n                if (!f.isDirectory() && !f.mkdirs()) {\n                    throw new IOException(\"failed to create directory \" + f);\n                }\n            } else {\n                File parent = f.getParentFile();\n                if (!parent.isDirectory() && !parent.mkdirs()) {\n                    throw new IOException(\"failed to create directory \" + parent);\n                }\n                try (OutputStream o = Files.newOutputStream(f.toPath())) {\n                    writer.writeEntryDataTo(nextEntry, o);\n                }\n            }\n            nextEntry = supplier.getNextReadableEntry();\n        }\n// bug_end\n     }\n \n", "target": "// fix_start\npublic void doIconSize( StaplerRequest req, StaplerResponse rsp ) throws IOException, ServletException {\n        String qs = req.getQueryString();\n        if(qs==null)\n            throw new ServletException();\n        Cookie cookie = new Cookie(\"iconSize\", Functions.validateIconSize(qs));\n        cookie.setMaxAge(9999999);\n        rsp.addCookie(cookie);\n        String ref = req.getHeader(\"Referer\");\n        if(ref==null)   ref=\".\";\n        rsp.sendRedirect2(ref);\n// fix_end\n", "cwe": "CWE-20", "cwe_name": "Improper Input Validation", "idx": 11719}
{"source": "// bug_start\npublic void doIconSize( StaplerRequest req, StaplerResponse rsp ) throws IOException, ServletException {\n        String qs = req.getQueryString();\n        if(qs==null || !ICON_SIZE.matcher(qs).matches())\n            throw new ServletException();\n        Cookie cookie = new Cookie(\"iconSize\", qs);\n        cookie.setMaxAge(9999999);\n        rsp.addCookie(cookie);\n        String ref = req.getHeader(\"Referer\");\n        if(ref==null)   ref=\".\";\n        rsp.sendRedirect2(ref);\n// bug_end\n     }\n \n", "target": "// fix_start\n@Override\n    public int setErrorParameter(BeforeEnterEvent event,\n            ErrorParameter<NotFoundException> parameter) {\n        String path = event.getLocation().getPath();\n        String additionalInfo = \"\";\n        if (parameter.hasCustomMessage()) {\n            additionalInfo = \"Reason: \" + parameter.getCustomMessage();\n        }\n        path = Jsoup.clean(path, Whitelist.none());\n        additionalInfo = Jsoup.clean(additionalInfo, Whitelist.none());\n\n        boolean productionMode = event.getUI().getSession().getConfiguration()\n                .isProductionMode();\n\n        String template = getErrorHtml(productionMode);\n        template = template.replace(\"{{path}}\", path);\n        template = template.replace(\"{{additionalInfo}}\", additionalInfo);\n        if (template.contains(\"{{routes}}\")) {\n            template = template.replace(\"{{routes}}\", getRoutes(event));\n        }\n\n        getElement().appendChild(new Html(template).getElement());\n        return HttpServletResponse.SC_NOT_FOUND;\n// fix_end\n", "cwe": "CWE-79", "cwe_name": "Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')", "idx": 78496}
{"source": "// bug_start\npublic static boolean isCsrfTokenValid(VaadinSession session,\n            String requestToken) {\n// bug_end\n \n// bug_start\n        if (session.getService().getDeploymentConfiguration()\n                .isXsrfProtectionEnabled()) {\n            String sessionToken = session.getCsrfToken();\n// bug_end\n \n// bug_start\n            try {\n                if (sessionToken == null || !MessageDigest.isEqual(\n                        sessionToken.getBytes(\"UTF-8\"),\n                        requestToken.getBytes(\"UTF-8\"))) {\n                    return false;\n                }\n            } catch (UnsupportedEncodingException e) {\n                getLogger().log(Level.WARNING,\n                        \"Session token was not UTF-8, this should never happen.\");\n                return false;\n            }\n// bug_end\n         }\n// bug_start\n        return true;\n// bug_end\n     }\n \n", "target": "// fix_start\n@Override\n    public int setErrorParameter(BeforeEnterEvent event,\n            ErrorParameter<NotFoundException> parameter) {\n        String path = event.getLocation().getPath();\n        String additionalInfo = \"\";\n        if (parameter.hasCustomMessage()) {\n            additionalInfo = \"Reason: \" + parameter.getCustomMessage();\n        }\n        path = Jsoup.clean(path, Whitelist.none());\n        additionalInfo = Jsoup.clean(additionalInfo, Whitelist.none());\n// fix_end\n// fix_start\n        boolean productionMode = event.getUI().getSession().getConfiguration()\n                .isProductionMode();\n// fix_end\n// fix_start\n        String template = getErrorHtml(productionMode);\n        if (template.contains(\"{{routes}}\")) {\n            template = template.replace(\"{{routes}}\", getRoutes(event));\n// fix_end\n// fix_start\n        template = template.replace(\"{{additionalInfo}}\", additionalInfo);\n        template = template.replace(\"{{path}}\", path);\n\n        getElement().appendChild(new Html(template).getElement());\n        return HttpServletResponse.SC_NOT_FOUND;\n// fix_end\n", "cwe": "CWE-20", "cwe_name": "Improper Input Validation", "idx": 7712}
{"source": " protected void throwable(BodyWriter w, Throwable throwable, boolean isCause) {\n     if (throwable != null) {\n       if (isCause) {\n         w.escape(\"Caused by: \");\n       }\n \n// bug_start\n      w.println(throwable.toString());\n// bug_end\n       for (StackTraceElement ste : throwable.getStackTrace()) {\n         String className = ste.getClassName();\n         if (className.startsWith(\"ratpack\")\n           || className.startsWith(\"io.netty\")\n           || className.startsWith(\"com.google\")\n           || className.startsWith(\"java\")\n           || className.startsWith(\"org.springsource.loaded\")\n           ) {\n           w.print(\"<span class='stack-core'>  at \").escape(ste.toString()).println(\"</span>\");\n         } else {\n           w.print(\"  at \").escape(ste.toString()).println(\"\");\n         }\n       }\n \n       throwable(w, throwable.getCause(), true);\n     }\n   }\n \n", "target": "// fix_start\n      w.escapeln(throwable.toString());\n// fix_end\n", "cwe": "CWE-79", "cwe_name": "Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')", "idx": 79872}
{"source": " @Override\n     public HttpContent getContent(String pathInContext,int maxBufferSize)\n         throws IOException\n     {\n// bug_start\n        Resource resource=_factory.getResource(pathInContext);\n        HttpContent loaded = load(pathInContext,resource,maxBufferSize);\n        return loaded;\n// bug_end\n     }\n \n", "target": "// fix_start\n        try\n        {\n            Resource resource = _factory.getResource(pathInContext);\n            HttpContent loaded = load(pathInContext, resource, maxBufferSize);\n            return loaded;\n        }\n        catch (Throwable t)\n        {\n            throw (InvalidPathException) new InvalidPathException(pathInContext, \"Invalid PathInContext\").initCause(t);\n        }\n// fix_end\n", "cwe": "NVD-CWE-noinfo", "cwe_name": "", "idx": 101962}
{"source": " public ResponseEntity<Void> postForRedirect(String path, HttpHeaders headers, MultiValueMap<String, String> params) {\n         ResponseEntity<Void> exchange = postForResponse(path, headers, params);\n \n         if (exchange.getStatusCode() != HttpStatus.FOUND) {\n             throw new IllegalStateException(\"Expected 302 but server returned status code \" + exchange.getStatusCode());\n         }\n \n// bug_start\n// bug_end\n         if (exchange.getHeaders().containsKey(\"Set-Cookie\")) {\n// bug_start\n            String cookie = exchange.getHeaders().getFirst(\"Set-Cookie\");\n            headers.set(\"Cookie\", cookie);\n// bug_end\n         }\n \n         String location = exchange.getHeaders().getLocation().toString();\n \n         return client.exchange(location, HttpMethod.GET, new HttpEntity<Void>(null, headers), Void.class);\n     }\n \n", "target": "// fix_start\n        headers.remove(\"Cookie\");\n// fix_end\n// fix_start\n            for (String cookie : exchange.getHeaders().get(\"Set-Cookie\")) {\n                headers.add(\"Cookie\", cookie);\n            }\n// fix_end\n", "cwe": "CWE-352", "cwe_name": "Cross-Site Request Forgery (CSRF)", "idx": 44175}
{"source": " @Override\n     public String toString() {\n         StringBuilder sb = new StringBuilder();\n         if (origin != null) {\n             sb.append(\"remoteAddress=\").append(origin);\n         }\n         if (clientId != null) {\n             if (sb.length() > 0) {\n                 sb.append(\", \");\n             }\n             sb.append(\"clientId=\").append(clientId);\n         }\n// bug_start\n        if (sessionId != null) {\n            if (sb.length() > 0) {\n                sb.append(\", \");\n            }\n            sb.append(\"sessionId=\").append(sessionId);\n        }\n// bug_end\n         return sb.toString();\n     }\n \n", "target": "// fix_start\n// fix_end\n", "cwe": "CWE-200", "cwe_name": "Exposure of Sensitive Information to an Unauthorized Actor", "idx": 18722}
{"source": " private void postWorkDirectory() {\n \n         String workDir = getWorkDir();\n         if (workDir == null || workDir.length() == 0) {\n \n             String hostName = null;\n             String engineName = null;\n             String hostWorkDir = null;\n             Container parentHost = getParent();\n             if (parentHost != null) {\n                 hostName = parentHost.getName();\n                 if (parentHost instanceof StandardHost) {\n                     hostWorkDir = ((StandardHost)parentHost).getWorkDir();\n                 }\n                 Container parentEngine = parentHost.getParent();\n                 if (parentEngine != null) {\n                    engineName = parentEngine.getName();\n                 }\n             }\n             if ((hostName == null) || (hostName.length() < 1))\n                 hostName = \"_\";\n             if ((engineName == null) || (engineName.length() < 1))\n                 engineName = \"_\";\n \n             String temp = getPath();\n             if (temp.startsWith(\"/\"))\n                 temp = temp.substring(1);\n             temp = temp.replace('/', '_');\n             temp = temp.replace('\\\\', '_');\n             if (temp.length() < 1)\n                 temp = \"_\";\n             if (hostWorkDir != null ) {\n                 workDir = hostWorkDir + File.separator + temp;\n             } else {\n                 workDir = \"work\" + File.separator + engineName +\n                     File.separator + hostName + File.separator + temp;\n             }\n             setWorkDir(workDir);\n         }\n \n         File dir = new File(workDir);\n         if (!dir.isAbsolute()) {\n             File catalinaHome = engineBase();\n             String catalinaHomePath = null;\n             try {\n                 catalinaHomePath = catalinaHome.getCanonicalPath();\n                 dir = new File(catalinaHomePath, workDir);\n             } catch (IOException e) {\n             }\n         }\n         dir.mkdirs();\n \n// bug_start\n        getServletContext().setAttribute(ServletContext.TEMPDIR, dir);\n        if (getServletContext() instanceof ApplicationContext)\n            ((ApplicationContext) getServletContext()).setAttributeReadOnly\n                (ServletContext.TEMPDIR);\n\n// bug_end\n     }\n \n", "target": "// fix_start\n        if (context == null) {\n            getServletContext();\n        }\n        context.setAttribute(ServletContext.TEMPDIR, dir);\n        context.setAttributeReadOnly(ServletContext.TEMPDIR);\n// fix_end\n", "cwe": "NVD-CWE-Other", "cwe_name": "Other", "idx": 113206}
{"source": "// bug_start\nprotected UserModel validateCache(RealmModel realm, CachedUser cached) {\n        StorageId storageId = new StorageId(cached.getId());\n        if (!storageId.isLocal()) {\n            ComponentModel component = realm.getComponent(storageId.getProviderId());\n            UserStorageProviderModel model = new UserStorageProviderModel(component);\n            UserStorageProviderModel.CachePolicy policy = model.getCachePolicy();\n            boolean invalidate = false;\n            if (policy != null) {\n                String currentTime = DateFormat.getDateTimeInstance(DateFormat.FULL, DateFormat.FULL).format(new Date(Time.currentTimeMillis()));\n                if (policy == UserStorageProviderModel.CachePolicy.NO_CACHE) {\n                    invalidate = true;\n                } else if (cached.getCacheTimestamp() < model.getCacheInvalidBefore()) {\n                    invalidate = true;\n                } else if (policy == UserStorageProviderModel.CachePolicy.EVICT_DAILY) {\n                    long dailyTimeout = dailyTimeout(model.getEvictionHour(), model.getEvictionMinute());\n                    dailyTimeout = dailyTimeout - (24 * 60 * 60 * 1000);\n                    if (cached.getCacheTimestamp() <= dailyTimeout) {\n                        invalidate = true;\n                    }\n                } else if (policy == UserStorageProviderModel.CachePolicy.EVICT_WEEKLY) {\n                    int oneWeek = 7 * 24 * 60 * 60 * 1000;\n                    long weeklyTimeout = weeklyTimeout(model.getEvictionDay(), model.getEvictionHour(), model.getEvictionMinute());\n                    long lastTimeout = weeklyTimeout - oneWeek;\n                    String timeout = DateFormat.getDateTimeInstance(DateFormat.FULL, DateFormat.FULL).format(new Date(weeklyTimeout));\n                    String stamp = DateFormat.getDateTimeInstance(DateFormat.FULL, DateFormat.FULL).format(new Date(cached.getCacheTimestamp()));\n                    if (cached.getCacheTimestamp() <= lastTimeout) {\n                        invalidate = true;\n                    }\n                }\n            }\n            if (invalidate) {\n                registerUserInvalidation(realm, cached);\n                return getDelegate().getUserById(cached.getId(), realm);\n            }\n        }\n        return new UserAdapter(cached, this, session, realm);\n    }\n// bug_end\n \n", "target": "// fix_start\n@Override\n\tpublic ParseResults call() {\n\t\ttry {\n\t\t\tSAXParserFactory spf = SAXParserFactory.newInstance();\n\t\t\tSAXParser saxParser = spf.newSAXParser();\n\t\t\tXMLReader reader = saxParser.getXMLReader();\n// fix_end\n// fix_start\n\n\t\t\tspf.setFeature(\"http://apache.org/xml/features/disallow-doctype-decl\", true);\n\t\t\tspf.setFeature(\"http://xml.org/sax/features/external-general-entities\", false);\n\t\t\tspf.setFeature(\"http://xml.org/sax/features/external-parameter-entities\", false);\n\t\t\tspf.setFeature(\"http://apache.org/xml/features/nonvalidating/load-external-dtd\", false);\n\t\t\tspf.setXIncludeAware(false);\n\t\t\treader.setFeature(\"http://apache.org/xml/features/disallow-doctype-decl\", true);\n\t\t\treader.setFeature(\"http://apache.org/xml/features/nonvalidating/load-external-dtd\", false);\n\t\t\treader.setFeature(\"http://xml.org/sax/features/external-general-entities\", false);\n\t\t\treader.setFeature(\"http://xml.org/sax/features/external-parameter-entities\", false);\n\n\t\t\tsaxParser.parse(xmlInputStream, handler);\n\t\t} catch (SAXException | IOException | ParserConfigurationException e) {\n\t\t\tthrow new ReportPortalException(ErrorType.PARSING_XML_ERROR, e.getMessage());\n\t\t}\n\t\treturn new ParseResults(handler.getStartSuiteTime(), handler.getCommonDuration());\n\t}\n\n// fix_end\n", "cwe": "CWE-611", "cwe_name": "Improper Restriction of XML External Entity Reference ('XXE')", "idx": 69789}
{"source": "// bug_start\n@Path(\"{id}\")\n    @PUT\n    @Consumes(MediaType.APPLICATION_JSON)\n    public Response updateUser(final @PathParam(\"id\") String id, final UserRepresentation rep) {\n        auth.requireManage();\n// bug_end\n \n// bug_start\n        try {\n            UserModel user = session.users().getUserById(id, realm);\n            if (user == null) {\n                throw new NotFoundException(\"User not found\");\n            }\n\n             Set<String> attrsToRemove;\n            if (rep.getAttributes() != null) {\n                attrsToRemove = new HashSet<>(user.getAttributes().keySet());\n                attrsToRemove.removeAll(rep.getAttributes().keySet());\n            } else {\n                attrsToRemove = Collections.emptySet();\n            }\n\n            if (rep.isEnabled() != null && rep.isEnabled()) {\n                UserLoginFailureModel failureModel = session.sessions().getUserLoginFailure(realm, id);\n                if (failureModel != null) {\n                    failureModel.clearFailures();\n// bug_end\n                 }\n             }\n// bug_start\n\n            updateUserFromRep(user, rep, attrsToRemove, realm, session, true);\n            adminEvent.operation(OperationType.UPDATE).resourcePath(uriInfo).representation(rep).success();\n\n            if (session.getTransactionManager().isActive()) {\n                session.getTransactionManager().commit();\n// bug_end\n             }\n// bug_start\n            return Response.noContent().build();\n        } catch (ModelDuplicateException e) {\n            return ErrorResponse.exists(\"User exists with same username or email\");\n        } catch (ModelReadOnlyException re) {\n            return ErrorResponse.exists(\"User is read only!\");\n        } catch (ModelException me) {\n            return ErrorResponse.exists(\"Could not update user!\");\n        } catch (Exception me) {\n            return ErrorResponse.exists(\"Could not update user!\");\n// bug_end\n         }\n// bug_start\n// bug_end\n     }\n \n", "target": "// fix_start\nprotected UserModel validateCache(RealmModel realm, CachedUser cached) {\n        if (!realm.getId().equals(cached.getRealm())) {\n            return null;\n        }\n// fix_end\n// fix_start\n        StorageId storageId = new StorageId(cached.getId());\n        if (!storageId.isLocal()) {\n            ComponentModel component = realm.getComponent(storageId.getProviderId());\n            UserStorageProviderModel model = new UserStorageProviderModel(component);\n            UserStorageProviderModel.CachePolicy policy = model.getCachePolicy();\n            boolean invalidate = false;\n            if (policy != null) {\n                String currentTime = DateFormat.getDateTimeInstance(DateFormat.FULL, DateFormat.FULL).format(new Date(Time.currentTimeMillis()));\n                if (policy == UserStorageProviderModel.CachePolicy.NO_CACHE) {\n                    invalidate = true;\n                } else if (cached.getCacheTimestamp() < model.getCacheInvalidBefore()) {\n                    invalidate = true;\n                } else if (policy == UserStorageProviderModel.CachePolicy.EVICT_DAILY) {\n                    long dailyTimeout = dailyTimeout(model.getEvictionHour(), model.getEvictionMinute());\n                    dailyTimeout = dailyTimeout - (24 * 60 * 60 * 1000);\n                    if (cached.getCacheTimestamp() <= dailyTimeout) {\n                        invalidate = true;\n                    }\n                } else if (policy == UserStorageProviderModel.CachePolicy.EVICT_WEEKLY) {\n                    int oneWeek = 7 * 24 * 60 * 60 * 1000;\n                    long weeklyTimeout = weeklyTimeout(model.getEvictionDay(), model.getEvictionHour(), model.getEvictionMinute());\n                    long lastTimeout = weeklyTimeout - oneWeek;\n                    String timeout = DateFormat.getDateTimeInstance(DateFormat.FULL, DateFormat.FULL).format(new Date(weeklyTimeout));\n                    String stamp = DateFormat.getDateTimeInstance(DateFormat.FULL, DateFormat.FULL).format(new Date(cached.getCacheTimestamp()));\n                    if (cached.getCacheTimestamp() <= lastTimeout) {\n                        invalidate = true;\n                    }\n// fix_end\n// fix_start\n            if (invalidate) {\n                registerUserInvalidation(realm, cached);\n                return getDelegate().getUserById(cached.getId(), realm);\n// fix_end\n// fix_start\n// fix_end\n// fix_start\n        return new UserAdapter(cached, this, session, realm);\n// fix_end\n", "cwe": "CWE-264", "cwe_name": "Permissions, Privileges, and Access Controls", "idx": 32939}
{"source": "// bug_start\n@Override\n      public Object getGroup(Object instance) {\n         Object object;\n         if (System.getSecurityManager() == null) {\n            return invokeAccessibly(instance, method, Util.EMPTY_OBJECT_ARRAY);\n         } else {\n            return AccessController.doPrivileged((PrivilegedAction<Object>) () -> invokeAccessibly(instance, method, Util.EMPTY_OBJECT_ARRAY));\n         }\n      }\n// bug_end\n \n", "target": "// fix_start\n@Path(\"{id}\")\n    @PUT\n    @Consumes(MediaType.APPLICATION_JSON)\n    public Response updateUser(final @PathParam(\"id\") String id, final UserRepresentation rep) {\n        auth.requireManage();\n// fix_end\n// fix_start\n        try {\n            UserModel user = session.users().getUserById(id, realm);\n            if (user == null) {\n                return Response.status(Status.NOT_FOUND).build();\n            }\n\n            Set<String> attrsToRemove;\n            if (rep.getAttributes() != null) {\n                attrsToRemove = new HashSet<>(user.getAttributes().keySet());\n                attrsToRemove.removeAll(rep.getAttributes().keySet());\n            } else {\n                attrsToRemove = Collections.emptySet();\n            }\n\n            if (rep.isEnabled() != null && rep.isEnabled()) {\n                UserLoginFailureModel failureModel = session.sessions().getUserLoginFailure(realm, id);\n                if (failureModel != null) {\n                    failureModel.clearFailures();\n                }\n            }\n\n            updateUserFromRep(user, rep, attrsToRemove, realm, session, true);\n            adminEvent.operation(OperationType.UPDATE).resourcePath(uriInfo).representation(rep).success();\n\n            if (session.getTransactionManager().isActive()) {\n                session.getTransactionManager().commit();\n            }\n            return Response.noContent().build();\n        } catch (ModelDuplicateException e) {\n            return ErrorResponse.exists(\"User exists with same username or email\");\n        } catch (ModelReadOnlyException re) {\n            return ErrorResponse.exists(\"User is read only!\");\n        } catch (ModelException me) {\n            return ErrorResponse.exists(\"Could not update user!\");\n        } catch (Exception me) {\n            return ErrorResponse.exists(\"Could not update user!\");\n        }\n    }\n\n// fix_end\n", "cwe": "CWE-264", "cwe_name": "Permissions, Privileges, and Access Controls", "idx": 34073}
{"source": "// bug_start\npublic static boolean isCsrfTokenValid(VaadinSession session,\n            String requestToken) {\n// bug_end\n \n// bug_start\n        if (session.getService().getDeploymentConfiguration()\n                .isXsrfProtectionEnabled()) {\n            String sessionToken = session.getCsrfToken();\n\n            if (sessionToken == null || !sessionToken.equals(requestToken)) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n// bug_end\n", "target": "// fix_start\n@Override\n      public Object getGroup(Object instance) {\n         if (System.getSecurityManager() == null) {\n            method.setAccessible(true);\n         } else {\n            AccessController.doPrivileged((PrivilegedAction<List<Method>>) () -> {\n               method.setAccessible(true);\n               return null;\n            });\n         }\n         return invokeMethod(instance, method, Util.EMPTY_OBJECT_ARRAY);\n      }\n// fix_end\n", "cwe": "CWE-470", "cwe_name": "", "idx": 56464}
{"source": "// bug_start\nprivate javax.crypto.Cipher initNewCipher(int jcaCipherMode, byte[] key, byte[] iv, boolean streaming)\n            throws CryptoException {\n// bug_end\n \n// bug_start\n        javax.crypto.Cipher cipher = newCipherInstance(streaming);\n        java.security.Key jdkKey = new SecretKeySpec(key, getAlgorithmName());\n        IvParameterSpec ivSpec = null;\n        if (iv != null && iv.length > 0) {\n            ivSpec = new IvParameterSpec(iv);\n// bug_end\n         }\n// bug_start\n\n        init(cipher, jcaCipherMode, jdkKey, ivSpec, getSecureRandom());\n\n        return cipher;\n// bug_end\n     }\n \n", "target": "// fix_start\npublic static boolean isCsrfTokenValid(VaadinSession session,\n            String requestToken) {\n// fix_end\n// fix_start\n        if (session.getService().getDeploymentConfiguration()\n                .isXsrfProtectionEnabled()) {\n            String sessionToken = session.getCsrfToken();\n\n            if (uiToken == null || !MessageDigest.isEqual(\n                    uiToken.getBytes(StandardCharsets.UTF_8),\n                    requestToken.getBytes(StandardCharsets.UTF_8))) {\n                return false;\n            }\n// fix_end\n// fix_start\n        return true;\n// fix_end\n", "cwe": "CWE-203", "cwe_name": "Information Exposure Through Discrepancy", "idx": 20048}
{"source": "// bug_start\nprivate javax.crypto.Cipher initNewCipher(int jcaCipherMode, byte[] key, byte[] iv, boolean streaming)\n            throws CryptoException {\n// bug_end\n \n// bug_start\n        javax.crypto.Cipher cipher = newCipherInstance(streaming);\n        java.security.Key jdkKey = new SecretKeySpec(key, getAlgorithmName());\n        AlgorithmParameterSpec ivSpec = null;\n// bug_end\n \n// bug_start\n        if (iv != null && iv.length > 0) {\n            ivSpec = createParameterSpec(iv, streaming);\n        }\n// bug_end\n \n// bug_start\n        init(cipher, jcaCipherMode, jdkKey, ivSpec, getSecureRandom());\n// bug_end\n \n// bug_start\n        return cipher;\n// bug_end\n     }\n \n", "target": "// fix_start\n@Test(expected = CryptoException.class)\n    public void getRememberedPrincipalsNoMoreDefaultCipher() {\n        HttpServletRequest mockRequest = createMock(HttpServletRequest.class);\n        HttpServletResponse mockResponse = createMock(HttpServletResponse.class);\n        WebSubjectContext context = new DefaultWebSubjectContext();\n        context.setServletRequest(mockRequest);\n        context.setServletResponse(mockResponse);\n// fix_end\n// fix_start\n        expect(mockRequest.getAttribute(ShiroHttpServletRequest.IDENTITY_REMOVED_KEY)).andReturn(null);\n        expect(mockRequest.getContextPath()).andReturn( \"/test\" );\n// fix_end\n// fix_start\n// fix_end\n// fix_start\n        final String userPCAesBase64 = \"0o6DCfePYTjK4q579qzUFEfkeGRvbBOdKHp2y8/nGAltt1Vz8uW0Z8igeO\" +\n                \"Tq/yBmcw25f3Q0ui/Leg3x0iQZWhw9Bbu0mFHmHsGxEd6mPwtUpSegIjyX5c/kZpqnb7QLdajPWiczX8P\" +\n                \"Oc2Eku5+8ye1u38Y8uKlklHxcYCPh0pRiDSBxfjPsLaDfOpGbmPjZd4SVg68i/++TvUjqBNJyb+pDix3f\" +\n                \"PeuPvReWGcE50iovezVZrEfDOAQ0cZYW35ShypMWOmE9yZnb+p8++StDyAUegryyuIa4pjuRzfMh9D+sN\" +\n                \"F9tm/EnDC1VCer2S/a0AGlWAQiM7jrWt1sNinZcKIrvShaWI21tONJt8WhozNS2H72lk4p92rfLNHeglT\" +\n                \"xObxIYxLfTI9KiToSe1nYmpQmbBO8x1wWDkWBG//EqRvhgbIfQVqJp12T0fJC1nFuZuVhw/ZanaAZGDk8\" +\n                \"7aLMiw3T6FBZtWaspgvfH+0TJrTD8Ra386ekNXNN8JW8=\";\n// fix_end\n// fix_start\n        Cookie[] cookies = new Cookie[]{\n            new Cookie(CookieRememberMeManager.DEFAULT_REMEMBER_ME_COOKIE_NAME, userPCAesBase64)\n        };\n\n        expect(mockRequest.getCookies()).andReturn(cookies);\n        replay(mockRequest);\n\n        CookieRememberMeManager mgr = new CookieRememberMeManager();\n        mgr.getRememberedPrincipals(context);\n// fix_end\n", "cwe": "NVD-CWE-noinfo", "cwe_name": "", "idx": 109404}
{"source": "// bug_start\n@Test(expected = CryptoException.class)\n    public void getRememberedPrincipalsNoMoreDefaultCipher() {\n        HttpServletRequest mockRequest = createMock(HttpServletRequest.class);\n        HttpServletResponse mockResponse = createMock(HttpServletResponse.class);\n        WebSubjectContext context = new DefaultWebSubjectContext();\n        context.setServletRequest(mockRequest);\n        context.setServletResponse(mockResponse);\n// bug_end\n \n// bug_start\n        expect(mockRequest.getAttribute(ShiroHttpServletRequest.IDENTITY_REMOVED_KEY)).andReturn(null);\n        expect(mockRequest.getContextPath()).andReturn( \"/test\" );\n// bug_end\n \n// bug_start\n// bug_end\n \n// bug_start\n        final String userPCAesBase64 = \"WlD5MLzzZznN3dQ1lPJO/eScSuY245k29aECNmjUs31o7Yu478hWhaM5Sj\" +\n            \"jmoe900/72JNu3hcJaPG6Q17Vuz4F8x0kBjbFnPVx4PqzsZYT6yreeS2jwO6OwfI+efqXOKyB2a5KPtnr\" +\n            \"7jt5kZsyH38XJISb81cf6xqTGUru8zC+kNqJFz7E5RpO0kraBofS5jhMm45gDVjDRkjgPJAzocVWMtrza\" +\n            \"zy67P8eb+kMSBCqGI251JTNAGboVgQ28KjfaAJ/6LXRJUj7kB7CGia7mgRk+hxzEJGDs81at5VOPqODJr\" +\n            \"xb8tcIdemFUFIkiYVP9bGs4dP3ECtmw7aNrCzv+84sx3vRFUrd5DbDYpEuE12hF2Y9owDK9sxStbXoF0y\" +\n            \"A32dhfGDIqS+agsass0sWn8WX2TM9i8SxrUjiFbxqyIG49HbqGrZp5QLM9IuIwO+TzGfF1FzumQGdwmWT\" +\n            \"xkVapw5UESl34YvA615cb+82ue1I=\";\n// bug_end\n \n// bug_start\n        Cookie[] cookies = new Cookie[]{\n            new Cookie(CookieRememberMeManager.DEFAULT_REMEMBER_ME_COOKIE_NAME, userPCAesBase64)\n        };\n// bug_end\n \n// bug_start\n        expect(mockRequest.getCookies()).andReturn(cookies);\n        replay(mockRequest);\n// bug_end\n \n// bug_start\n        CookieRememberMeManager mgr = new CookieRememberMeManager();\n        mgr.getRememberedPrincipals(context);\n// bug_end\n     }\n \n", "target": "// fix_start\nprivate static String verifyRedirectUri(UriInfo uriInfo, String rootUrl, String redirectUri, RealmModel realm, Set<String> validRedirects, boolean requireRedirectUri) {\n// fix_end\n// fix_start\n        if (redirectUri != null)\n            redirectUri = normalizeUrl(redirectUri);\n// fix_end\n// fix_start\n        if (redirectUri == null) {\n            if (!requireRedirectUri) {\n                redirectUri = getSingleValidRedirectUri(validRedirects);\n            }\n// fix_end\n// fix_start\n            if (redirectUri == null) {\n                logger.debug(\"No Redirect URI parameter specified\");\n                return null;\n            }\n        } else if (validRedirects.isEmpty()) {\n            logger.debug(\"No Redirect URIs supplied\");\n            redirectUri = null;\n        } else {\n            redirectUri = lowerCaseHostname(redirectUri);\n// fix_end\n// fix_start\n            String r = redirectUri;\n            Set<String> resolveValidRedirects = resolveValidRedirects(uriInfo, rootUrl, validRedirects);\n// fix_end\n// fix_start\n            boolean valid = matchesRedirects(resolveValidRedirects, r);\n// fix_end\n// fix_start\n            if (!valid && r.startsWith(Constants.INSTALLED_APP_URL) && r.indexOf(':', Constants.INSTALLED_APP_URL.length()) >= 0) {\n                int i = r.indexOf(':', Constants.INSTALLED_APP_URL.length());\n\n                StringBuilder sb = new StringBuilder();\n                sb.append(r.substring(0, i));\n\n                i = r.indexOf('/', i);\n                if (i >= 0) {\n                    sb.append(r.substring(i));\n                }\n\n                r = sb.toString();\n\n                valid = matchesRedirects(resolveValidRedirects, r);\n            }\n            if (valid && redirectUri.startsWith(\"/\")) {\n                redirectUri = relativeToAbsoluteURI(uriInfo, rootUrl, redirectUri);\n            }\n            redirectUri = valid ? redirectUri : null;\n        }\n\n        if (Constants.INSTALLED_APP_URN.equals(redirectUri)) {\n            return Urls.realmInstalledAppUrnCallback(uriInfo.getBaseUri(), realm.getName()).toString();\n        } else {\n            return redirectUri;\n        }\n// fix_end\n", "cwe": "NVD-CWE-noinfo", "cwe_name": "", "idx": 109403}
{"source": "// bug_start\nprivate static String verifyRedirectUri(UriInfo uriInfo, String rootUrl, String redirectUri, RealmModel realm, Set<String> validRedirects, boolean requireRedirectUri) {\n        if (redirectUri == null) {\n            if (!requireRedirectUri) {\n                redirectUri = getSingleValidRedirectUri(validRedirects);\n            }\n// bug_end\n \n// bug_start\n            if (redirectUri == null) {\n                logger.debug(\"No Redirect URI parameter specified\");\n                return null;\n            }\n        } else if (validRedirects.isEmpty()) {\n            logger.debug(\"No Redirect URIs supplied\");\n            redirectUri = null;\n        } else {\n            redirectUri = lowerCaseHostname(redirectUri);\n// bug_end\n \n// bug_start\n            String r = redirectUri;\n            Set<String> resolveValidRedirects = resolveValidRedirects(uriInfo, rootUrl, validRedirects);\n\n            boolean valid = matchesRedirects(resolveValidRedirects, r);\n\n            if (!valid && r.startsWith(Constants.INSTALLED_APP_URL) && r.indexOf(':', Constants.INSTALLED_APP_URL.length()) >= 0) {\n                int i = r.indexOf(':', Constants.INSTALLED_APP_URL.length());\n\n                StringBuilder sb = new StringBuilder();\n                sb.append(r.substring(0, i));\n\n                i = r.indexOf('/', i);\n                if (i >= 0) {\n                    sb.append(r.substring(i));\n                }\n\n                r = sb.toString();\n\n                valid = matchesRedirects(resolveValidRedirects, r);\n            }\n            if (valid && redirectUri.startsWith(\"/\")) {\n                redirectUri = relativeToAbsoluteURI(uriInfo, rootUrl, redirectUri);\n            }\n            redirectUri = valid ? redirectUri : null;\n// bug_end\n         }\n \n// bug_start\n        if (Constants.INSTALLED_APP_URN.equals(redirectUri)) {\n            return Urls.realmInstalledAppUrnCallback(uriInfo.getBaseUri(), realm.getName()).toString();\n        } else {\n            return redirectUri;\n// bug_end\n         }\n// bug_start\n// bug_end\n     }\n \n", "target": "// fix_start\nprotected final File file(String name, boolean mustExist) {\n// fix_end\n// fix_start\n        if (name.equals(\"/\")) {\n            name = \"\";\n        }\n        File file = new File(fileBase, name);\n// fix_end\n// fix_start\n        if (name.endsWith(\"/\") && file.isFile()) {\n            return null;\n// fix_end\n// fix_start\n        if (mustExist && !file.canRead()) {\n            return null;\n// fix_end\n// fix_start\n\n        if (getRoot().getAllowLinking()) {\n            return file;\n        }\n\n        String canPath = null;\n        try {\n            canPath = file.getCanonicalPath();\n        } catch (IOException e) {\n        }\n        if (canPath == null || !canPath.startsWith(canonicalBase)) {\n            return null;\n        }\n\n        String absPath = normalize(file.getAbsolutePath());\n        if (absoluteBase.length() > absPath.length()) {\n            return null;\n        }\n\n        absPath = absPath.substring(absoluteBase.length());\n        canPath = canPath.substring(canonicalBase.length());\n\n        if (canPath.length() > 0) {\n            canPath = normalize(canPath);\n        }\n        if (!canPath.equals(absPath)) {\n            return null;\n        }\n\n        return file;\n// fix_end\n", "cwe": "CWE-601", "cwe_name": "URL Redirection to Untrusted Site ('Open Redirect')", "idx": 65793}
{"source": "// bug_start\n@Override\n\t\tprotected void doGet(HttpServletRequest request, HttpServletResponse response)\n\t\t\t\tthrows ServletException, IOException {\n\t\t\tString origin = request.getParameter(\"origin\");\n\t\t\tif (origin == null) {\n\t\t\t\tresponse.setStatus(500);\n\t\t\t\tresponse.getWriter().println(\n\t\t\t\t\t\t\"Required parameter 'origin' missing. Example: 107.20.175.135:7001\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t\torigin = origin.trim();\n// bug_end\n \n// bug_start\n\t\t\tHttpGet httpget = null;\n\t\t\tInputStream is = null;\n\t\t\tboolean hasFirstParameter = false;\n\t\t\tStringBuilder url = new StringBuilder();\n\t\t\tif (!origin.startsWith(\"http\")) {\n\t\t\t\turl.append(\"http://\");\n\t\t\t}\n\t\t\turl.append(origin);\n\t\t\tif (origin.contains(\"?\")) {\n\t\t\t\thasFirstParameter = true;\n\t\t\t}\n\t\t\tMap<String, String[]> params = request.getParameterMap();\n\t\t\tfor (String key : params.keySet()) {\n\t\t\t\tif (!key.equals(\"origin\")) {\n\t\t\t\t\tString[] values = params.get(key);\n\t\t\t\t\tString value = values[0].trim();\n\t\t\t\t\tif (hasFirstParameter) {\n\t\t\t\t\t\turl.append(\"&\");\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\turl.append(\"?\");\n\t\t\t\t\t\thasFirstParameter = true;\n\t\t\t\t\t}\n\t\t\t\t\turl.append(key).append(\"=\").append(value);\n\t\t\t\t}\n\t\t\t}\n\t\t\tString proxyUrlString = url.toString();\n// bug_end\n \n// bug_start\n\t\t\tif (!isAllowedToProxy(proxyUrlString)) {\n\t\t\t\tlog.warn(\"Origin parameter: \" + origin\n\t\t\t\t\t\t+ \" is not in the allowed list of proxy host names.  If it \"\n\t\t\t\t\t\t+ \"should be allowed add it to hystrix.dashboard.proxyStreamAllowList.\");\n\t\t\t\treturn;\n\t\t\t}\n// bug_end\n \n// bug_start\n\t\t\tlog.info(\"\\n\\nProxy opening connection to: \" + proxyUrlString + \"\\n\\n\");\n\t\t\ttry {\n\t\t\t\thttpget = new HttpGet(proxyUrlString);\n\t\t\t\tHttpClient client = ProxyConnectionManager.httpClient;\n\t\t\t\tHttpResponse httpResponse = client.execute(httpget);\n\t\t\t\tint statusCode = httpResponse.getStatusLine().getStatusCode();\n\t\t\t\tif (statusCode == HttpStatus.SC_OK) {\n\t\t\t\t\tis = httpResponse.getEntity().getContent();\n// bug_end\n \n// bug_start\n\t\t\t\t\tcopyHeadersToServletResponse(httpResponse.getAllHeaders(), response);\n// bug_end\n \n// bug_start\n\t\t\t\t\tOutputStream os = response.getOutputStream();\n\t\t\t\t\tint b = -1;\n\t\t\t\t\twhile ((b = is.read()) != -1) {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tos.write(b);\n\t\t\t\t\t\t\tif (b == 10\n\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\tos.flush();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcatch (Exception ex) {\n\t\t\t\t\t\t\tif (ex.getClass().getSimpleName()\n\t\t\t\t\t\t\t\t\t.equalsIgnoreCase(\"ClientAbortException\")) {\n\t\t\t\t\t\t\t\tlog.debug(\n\t\t\t\t\t\t\t\t\t\t\"Connection closed by client. Will stop proxying ...\");\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tthrow new RuntimeException(ex);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tlog.warn(\"Failed opening connection to \" + proxyUrlString + \" : \"\n\t\t\t\t\t\t\t+ statusCode + \" : \" + httpResponse.getStatusLine());\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception ex) {\n\t\t\t\tlog.error(\"Error proxying request: \" + url, ex);\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\tif (httpget != null) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\thttpget.abort();\n\t\t\t\t\t}\n\t\t\t\t\tcatch (Exception ex) {\n\t\t\t\t\t\tlog.error(\"failed aborting proxy connection.\", ex);\n\t\t\t\t\t}\n\t\t\t\t}\n// bug_end\n \n// bug_start\n\t\t\t\tif (is != null) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tis.close();\n\t\t\t\t\t}\n\t\t\t\t\tcatch (Exception ex) {\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n// bug_end\n \n// bug_start\n\t\t}\n// bug_end\n \n", "target": "// fix_start\nprotected final File file(String name, boolean mustExist) {\n// fix_end\n// fix_start\n        if (name.equals(\"/\")) {\n            name = \"\";\n        }\n        File file = new File(fileBase, name);\n// fix_end\n// fix_start\n        if (name.endsWith(\"/\") && file.isFile()) {\n            return null;\n        }\n// fix_end\n// fix_start\n        if (mustExist && !file.canRead()) {\n            return null;\n        }\n// fix_end\n// fix_start\n        if (getRoot().getAllowLinking()) {\n            return file;\n        }\n// fix_end\n// fix_start\n        if (JrePlatform.IS_WINDOWS && isInvalidWindowsFilename(name)) {\n            return null;\n        }\n// fix_end\n// fix_start\n        String canPath = null;\n        try {\n            canPath = file.getCanonicalPath();\n        } catch (IOException e) {\n        }\n        if (canPath == null || !canPath.startsWith(canonicalBase)) {\n            return null;\n        }\n// fix_end\n// fix_start\n        String absPath = normalize(file.getAbsolutePath());\n        if (absoluteBase.length() > absPath.length()) {\n            return null;\n        }\n// fix_end\n// fix_start\n        absPath = absPath.substring(absoluteBase.length());\n        canPath = canPath.substring(canonicalBase.length());\n\n        if (canPath.length() > 0) {\n            canPath = normalize(canPath);\n        }\n        if (!canPath.equals(absPath)) {\n            return null;\n        }\n\n        return file;\n    }\n\n// fix_end\n", "cwe": "CWE-434", "cwe_name": "Unrestricted Upload of File with Dangerous Type", "idx": 53721}
{"source": "// bug_start\n@Override\n\t\tprotected void doGet(HttpServletRequest request, HttpServletResponse response)\n\t\t\t\tthrows ServletException, IOException {\n\t\t\tString origin = request.getParameter(\"origin\");\n\t\t\tif (origin == null) {\n\t\t\t\tresponse.setStatus(500);\n\t\t\t\tresponse.getWriter().println(\n\t\t\t\t\t\t\"Required parameter 'origin' missing. Example: 107.20.175.135:7001\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t\torigin = origin.trim();\n// bug_end\n \n// bug_start\n\t\t\tHttpGet httpget = null;\n\t\t\tInputStream is = null;\n\t\t\tboolean hasFirstParameter = false;\n\t\t\tStringBuilder url = new StringBuilder();\n\t\t\tif (!origin.startsWith(\"http\")) {\n\t\t\t\turl.append(\"http://\");\n\t\t\t}\n\t\t\turl.append(origin);\n\t\t\tif (origin.contains(\"?\")) {\n\t\t\t\thasFirstParameter = true;\n\t\t\t}\n\t\t\tMap<String, String[]> params = request.getParameterMap();\n\t\t\tfor (String key : params.keySet()) {\n\t\t\t\tif (!key.equals(\"origin\")) {\n\t\t\t\t\tString[] values = params.get(key);\n\t\t\t\t\tString value = values[0].trim();\n\t\t\t\t\tif (hasFirstParameter) {\n\t\t\t\t\t\turl.append(\"&\");\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\turl.append(\"?\");\n\t\t\t\t\t\thasFirstParameter = true;\n\t\t\t\t\t}\n\t\t\t\t\turl.append(key).append(\"=\").append(value);\n\t\t\t\t}\n\t\t\t}\n\t\t\tString proxyUrl = url.toString();\n\t\t\tlog.info(\"\\n\\nProxy opening connection to: \" + proxyUrl + \"\\n\\n\");\n\t\t\ttry {\n\t\t\t\thttpget = new HttpGet(proxyUrl);\n\t\t\t\tHttpClient client = ProxyConnectionManager.httpClient;\n\t\t\t\tHttpResponse httpResponse = client.execute(httpget);\n\t\t\t\tint statusCode = httpResponse.getStatusLine().getStatusCode();\n\t\t\t\tif (statusCode == HttpStatus.SC_OK) {\n\t\t\t\t\tis = httpResponse.getEntity().getContent();\n// bug_end\n \n// bug_start\n\t\t\t\t\tcopyHeadersToServletResponse(httpResponse.getAllHeaders(), response);\n\n\t\t\t\t\tOutputStream os = response.getOutputStream();\n\t\t\t\t\tint b = -1;\n\t\t\t\t\twhile ((b = is.read()) != -1) {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tos.write(b);\n\t\t\t\t\t\t\tif (b == 10\n\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\tos.flush();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcatch (Exception ex) {\n\t\t\t\t\t\t\tif (ex.getClass().getSimpleName()\n\t\t\t\t\t\t\t\t\t.equalsIgnoreCase(\"ClientAbortException\")) {\n\t\t\t\t\t\t\t\tlog.debug(\n\t\t\t\t\t\t\t\t\t\t\"Connection closed by client. Will stop proxying ...\");\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tthrow new RuntimeException(ex);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tlog.warn(\"Failed opening connection to \" + proxyUrl + \" : \"\n\t\t\t\t\t\t\t+ statusCode + \" : \" + httpResponse.getStatusLine());\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception ex) {\n\t\t\t\tlog.error(\"Error proxying request: \" + url, ex);\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\tif (httpget != null) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\thttpget.abort();\n\t\t\t\t\t}\n\t\t\t\t\tcatch (Exception ex) {\n\t\t\t\t\t\tlog.error(\"failed aborting proxy connection.\", ex);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (is != null) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tis.close();\n\t\t\t\t\t}\n\t\t\t\t\tcatch (Exception ex) {\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\n// bug_end\n", "target": "// fix_start\n@BeforeClass\n  public static void setupClass() {\n    functionStringMap.put(new AlterRuntimeConfigFunction(), \"CLUSTER:WRITE\");\n    functionStringMap.put(new ChangeLogLevelFunction(), \"CLUSTER:WRITE\");\n    functionStringMap.put(new CloseDurableClientFunction(), \"CLUSTER:MANAGE:QUERY\");\n    functionStringMap.put(new CloseDurableCqFunction(), \"CLUSTER:MANAGE:QUERY\");\n    functionStringMap.put(new ContinuousQueryFunction(), \"CLUSTER:READ\");\n    functionStringMap.put(new CreateAsyncEventQueueFunction(), \"CLUSTER:MANAGE:DEPLOY\");\n    functionStringMap.put(new CreateDefinedIndexesFunction(), \"CLUSTER:MANAGE:QUERY\");\n    functionStringMap.put(new CreateDiskStoreFunction(), \"CLUSTER:MANAGE:DISK\");\n    functionStringMap.put(new CreateIndexFunction(), \"CLUSTER:MANAGE:QUERY\");\n    functionStringMap.put(new DataCommandFunction(), \"DATA\");\n    functionStringMap.put(new DeployFunction(), \"CLUSTER:MANAGE:DEPLOY\");\n    functionStringMap.put(new DescribeDiskStoreFunction(), \"CLUSTER:READ\");\n    functionStringMap.put(new DestroyAsyncEventQueueFunction(), \"CLUSTER:MANAGE\");\n    functionStringMap.put(new DestroyDiskStoreFunction(), \"CLUSTER:MANAGE:DISK\");\n    functionStringMap.put(new DestroyIndexFunction(), \"CLUSTER:MANAGE:QUERY\");\n    functionStringMap.put(new ExportConfigFunction(), \"CLUSTER:READ\");\n    functionStringMap.put(new ExportDataFunction(), \"DATA:READ\");\n    functionStringMap.put(new ExportLogsFunction(), \"CLUSTER:READ\");\n    functionStringMap.put(new FetchRegionAttributesFunction(), \"CLUSTER:READ\");\n    functionStringMap.put(new FetchSharedConfigurationStatusFunction(), \"CLUSTER:READ\");\n    functionStringMap.put(new GarbageCollectionFunction(), \"CLUSTER:MANAGE\");\n    functionStringMap.put(new GatewayReceiverCreateFunction(), \"CLUSTER:MANAGE:GATEWAY\");\n    functionStringMap.put(new GatewaySenderCreateFunction(), \"CLUSTER:MANAGE:GATEWAY\");\n    functionStringMap.put(new GatewaySenderDestroyFunction(), \"CLUSTER:MANAGE:GATEWAY\");\n    functionStringMap.put(new GetClusterConfigurationFunction(), \"*\");\n    functionStringMap.put(new GetMemberConfigInformationFunction(), \"CLUSTER:READ\");\n    functionStringMap.put(new GetMemberInformationFunction(), \"CLUSTER:READ\");\n    functionStringMap.put(new GetRegionDescriptionFunction(), \"CLUSTER:READ\");\n    functionStringMap.put(new GetRegionsFunction(), \"CLUSTER:READ\");\n    functionStringMap.put(new GetStackTracesFunction(), \"CLUSTER:READ\");\n    functionStringMap.put(new GetSubscriptionQueueSizeFunction(), \"CLUSTER:READ\");\n    functionStringMap.put(new ImportDataFunction(), \"DATA:WRITE\");\n    functionStringMap.put(new ListAsyncEventQueuesFunction(), \"CLUSTER:READ\");\n    functionStringMap.put(new ListDeployedFunction(), \"CLUSTER:READ\");\n    functionStringMap.put(new ListDiskStoresFunction(), \"CLUSTER:READ\");\n    functionStringMap.put(new ListDurableCqNamesFunction(), \"CLUSTER:READ\");\n    functionStringMap.put(new ListFunctionFunction(), \"CLUSTER:READ\");\n    functionStringMap.put(new ListIndexFunction(), \"CLUSTER:READ:QUERY\");\n    functionStringMap.put(new NetstatFunction(), \"CLUSTER:READ\");\n    functionStringMap.put(new RebalanceFunction(), \"DATA:MANAGE\");\n    functionStringMap.put(new RegionAlterFunction(), \"DATA:MANAGE\");\n    functionStringMap.put(new RegionCreateFunction(), \"DATA:MANAGE\");\n    functionStringMap.put(new RegionDestroyFunction(), \"DATA:MANAGE\");\n    functionStringMap.put(new ShowMissingDiskStoresFunction(), \"CLUSTER:READ\");\n    functionStringMap.put(new ShutDownFunction(), \"CLUSTER:MANAGE\");\n    functionStringMap.put(new SizeExportLogsFunction(), \"CLUSTER:READ\");\n    functionStringMap.put(new UndeployFunction(), \"CLUSTER:MANAGE:DEPLOY\");\n    functionStringMap.put(new UnregisterFunction(), \"CLUSTER:MANAGE:DEPLOY\");\n    functionStringMap.put(new GetRegionNamesFunction(), \"CLUSTER:READ\");\n    functionStringMap.put(new RecreateCacheFunction(), \"CLUSTER:MANAGE\");\n    functionStringMap.put(new DownloadJarFunction(), \"CLUSTER:READ\");\n// fix_end\n// fix_start\n    functionStringMap.keySet().forEach(FunctionService::registerFunction);\n  }\n// fix_end\n", "cwe": "CWE-610", "cwe_name": "", "idx": 65988}
{"source": " @BeforeClass\n   public static void setupClass() {\n// bug_start\n    functionStringMap.put(new AlterRuntimeConfigFunction(), \"*\");\n    functionStringMap.put(new ChangeLogLevelFunction(), \"*\");\n    functionStringMap.put(new CloseDurableClientFunction(), \"*\");\n    functionStringMap.put(new CloseDurableCqFunction(), \"*\");\n    functionStringMap.put(new ContinuousQueryFunction(), \"*\");\n    functionStringMap.put(new CreateAsyncEventQueueFunction(), \"*\");\n    functionStringMap.put(new CreateDefinedIndexesFunction(), \"*\");\n    functionStringMap.put(new CreateDiskStoreFunction(), \"*\");\n    functionStringMap.put(new CreateIndexFunction(), \"*\");\n    functionStringMap.put(new DataCommandFunction(), \"*\");\n    functionStringMap.put(new DeployFunction(), \"*\");\n    functionStringMap.put(new DescribeDiskStoreFunction(), \"*\");\n    functionStringMap.put(new DestroyAsyncEventQueueFunction(), \"*\");\n    functionStringMap.put(new DestroyDiskStoreFunction(), \"*\");\n    functionStringMap.put(new DestroyIndexFunction(), \"*\");\n    functionStringMap.put(new ExportConfigFunction(), \"*\");\n    functionStringMap.put(new ExportDataFunction(), \"*\");\n    functionStringMap.put(new ExportLogsFunction(), \"*\");\n    functionStringMap.put(new FetchRegionAttributesFunction(), \"*\");\n    functionStringMap.put(new FetchSharedConfigurationStatusFunction(), \"*\");\n    functionStringMap.put(new GarbageCollectionFunction(), \"*\");\n    functionStringMap.put(new GatewayReceiverCreateFunction(), \"*\");\n    functionStringMap.put(new GatewaySenderCreateFunction(), \"*\");\n    functionStringMap.put(new GatewaySenderDestroyFunction(), \"*\");\n    functionStringMap.put(new GetClusterConfigurationFunction(), \"*\");\n    functionStringMap.put(new GetMemberConfigInformationFunction(), \"*\");\n    functionStringMap.put(new GetMemberInformationFunction(), \"*\");\n    functionStringMap.put(new GetRegionDescriptionFunction(), \"*\");\n    functionStringMap.put(new GetRegionsFunction(), \"*\");\n    functionStringMap.put(new GetStackTracesFunction(), \"*\");\n    functionStringMap.put(new GetSubscriptionQueueSizeFunction(), \"*\");\n    functionStringMap.put(new ImportDataFunction(), \"*\");\n    functionStringMap.put(new ListAsyncEventQueuesFunction(), \"*\");\n    functionStringMap.put(new ListDeployedFunction(), \"*\");\n    functionStringMap.put(new ListDiskStoresFunction(), \"*\");\n    functionStringMap.put(new ListDurableCqNamesFunction(), \"*\");\n    functionStringMap.put(new ListFunctionFunction(), \"*\");\n    functionStringMap.put(new ListIndexFunction(), \"*\");\n    functionStringMap.put(new NetstatFunction(), \"*\");\n    functionStringMap.put(new RebalanceFunction(), \"*\");\n    functionStringMap.put(new RegionAlterFunction(), \"*\");\n    functionStringMap.put(new RegionCreateFunction(), \"*\");\n    functionStringMap.put(new RegionDestroyFunction(), \"*\");\n    functionStringMap.put(new ShowMissingDiskStoresFunction(), \"*\");\n    functionStringMap.put(new ShutDownFunction(), \"*\");\n    functionStringMap.put(new SizeExportLogsFunction(), \"*\");\n    functionStringMap.put(new UndeployFunction(), \"*\");\n    functionStringMap.put(new UnregisterFunction(), \"*\");\n    functionStringMap.put(new GetRegionNamesFunction(), \"*\");\n    functionStringMap.put(new RecreateCacheFunction(), \"*\");\n    functionStringMap.put(new DownloadJarFunction(), \"*\");\n\n// bug_end\n     functionStringMap.keySet().forEach(FunctionService::registerFunction);\n   }\n \n", "target": "// fix_start\n    functionStringMap.put(new AlterConnectionFunction(), \"*\");\n    functionStringMap.put(new AlterMappingFunction(), \"*\");\n    functionStringMap.put(new CreateConnectionFunction(), \"*\");\n    functionStringMap.put(new CreateMappingFunction(), \"*\");\n    functionStringMap.put(new DescribeConnectionFunction(), \"*\");\n    functionStringMap.put(new DescribeMappingFunction(), \"*\");\n    functionStringMap.put(new DestroyConnectionFunction(), \"*\");\n    functionStringMap.put(new DestroyMappingFunction(), \"*\");\n    functionStringMap.put(new ListConnectionFunction(), \"*\");\n    functionStringMap.put(new ListMappingFunction(), \"*\");\n    functionStringMap.put(new InheritsDefaultPermissionsJDBCFunction(), \"*\");\n// fix_end\n", "cwe": "CWE-863", "cwe_name": "Incorrect Authorization", "idx": 87342}
{"source": " private void writeSession(SessionInformations session, boolean displayUser) throws IOException {\n \t\tfinal String nextColumnAlignRight = \"</td><td align='right'>\";\n \t\tfinal String nextColumnAlignCenter = \"</td><td align='center'>\";\n \t\twrite(\"<td><a href='?part=sessions&amp;sessionId=\");\n \t\twrite(htmlEncodeButNotSpace(session.getId()));\n \t\twrite(\"'>\");\n \t\twrite(htmlEncodeButNotSpace(session.getId()));\n \t\twrite(\"</a>\");\n \t\twrite(nextColumnAlignRight);\n \t\twrite(durationFormat.format(session.getLastAccess()));\n \t\twrite(nextColumnAlignRight);\n \t\twrite(durationFormat.format(session.getAge()));\n \t\twrite(nextColumnAlignRight);\n \t\twrite(expiryFormat.format(session.getExpirationDate()));\n \n \t\twrite(nextColumnAlignRight);\n \t\twrite(integerFormat.format(session.getAttributeCount()));\n \t\twrite(nextColumnAlignCenter);\n \t\tif (session.isSerializable()) {\n \t\t\twrite(\"#oui#\");\n \t\t} else {\n \t\t\twrite(\"<span class='severe'>#non#</span>\");\n \t\t}\n \t\twrite(nextColumnAlignRight);\n \t\twrite(integerFormat.format(session.getSerializedSize()));\n \t\tfinal String nextColumn = \"</td><td>\";\n \t\twrite(nextColumn);\n \t\tfinal String remoteAddr = session.getRemoteAddr();\n \t\tif (remoteAddr == null) {\n \t\t\twrite(\"&nbsp;\");\n \t\t} else {\n// bug_start\n\t\t\twrite(remoteAddr);\n// bug_end\n \t\t}\n \t\twrite(nextColumnAlignCenter);\n \t\twriteCountry(session);\n \t\tif (displayUser) {\n \t\t\twrite(nextColumn);\n \t\t\tfinal String remoteUser = session.getRemoteUser();\n \t\t\tif (remoteUser == null) {\n \t\t\t\twrite(\"&nbsp;\");\n \t\t\t} else {\n \t\t\t\twriteDirectly(htmlEncodeButNotSpace(remoteUser));\n \t\t\t}\n \t\t}\n \t\twrite(\"</td><td align='center' class='noPrint'>\");\n \t\twrite(A_HREF_PART_SESSIONS);\n \t\twrite(\"&amp;action=invalidate_session&amp;sessionId=\");\n \t\twrite(urlEncode(session.getId()));\n \t\twrite(\"' onclick=\\\"javascript:return confirm('\"\n \t\t\t\t+ getStringForJavascript(\"confirm_invalidate_session\") + \"');\\\">\");\n \t\twrite(\"<img width='16' height='16' src='?resource=user-trash.png' alt='#invalidate_session#' title='#invalidate_session#' />\");\n \t\twrite(\"</a>\");\n \t\twrite(\"</td>\");\n \t}\n \n", "target": "// fix_start\n\t\t\twrite(htmlEncodeButNotSpace(remoteAddr));\n// fix_end\n", "cwe": "CWE-79", "cwe_name": "Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')", "idx": 79342}
{"source": " private JWT decode(String encodedJWT, Header header, String[] parts, Verifier verifier) {\n// bug_start\n    int index = encodedJWT.lastIndexOf(\".\");\n    byte[] message = encodedJWT.substring(0, index).getBytes(StandardCharsets.UTF_8);\n// bug_end\n \n     if (parts.length == 3 && verifier == null) {\n       throw new MissingVerifierException(\"No Verifier has been provided for verify a signature signed using [\" + header.algorithm.getName() + \"]\");\n     }\n \n     if (parts.length == 2 && verifier != null) {\n       throw new InvalidJWTSignatureException();\n     }\n// bug_start\n// bug_end\n \n     if (parts.length == 3) {\n       byte[] signature = base64Decode(parts[2].getBytes(StandardCharsets.UTF_8));\n       verifier.verify(header.algorithm, message, signature);\n     }\n \n     JWT jwt = Mapper.deserialize(base64Decode(parts[1].getBytes(StandardCharsets.UTF_8)), JWT.class);\n \n     if (jwt.isExpired()) {\n       throw new JWTExpiredException();\n     }\n \n     if (jwt.isUnavailableForProcessing()) {\n       throw new JWTUnavailableForProcessingException();\n     }\n \n     return jwt;\n   }\n \n", "target": "// fix_start\n    if (header.algorithm == Algorithm.none) {\n      throw new MissingVerifierException(\"No Verifier has been provided for verify a signature signed using [\" + header.algorithm.getName() + \"]\");\n    }\n// fix_end\n// fix_start\n\n    int index = encodedJWT.lastIndexOf(\".\");\n    byte[] message = encodedJWT.substring(0, index).getBytes(StandardCharsets.UTF_8);\n// fix_end\n", "cwe": "CWE-20", "cwe_name": "Improper Input Validation", "idx": 11733}
{"source": " public Session createSession(String from) throws MessagingException {\n         Properties props = new Properties(System.getProperties());\n \n         MailAccount acc = mailAccount;\n         if(StringUtils.isNotBlank(from)){\n             InternetAddress fromAddress = new InternetAddress(from);\n             for(MailAccount ma : addAccounts) {\n                 if(ma == null || !ma.isValid() || !ma.getAddress().equalsIgnoreCase(fromAddress.getAddress())) continue;\n                 acc = ma;\n                 break;\n             }\n         }\n \n         if(!acc.isValid()) {\n         }\n \n         if (acc.getSmtpHost() != null) {\n             props.put(\"mail.smtp.host\", acc.getSmtpHost());\n         }\n         if (acc.getSmtpPort() != null) {\n             props.put(\"mail.smtp.port\", acc.getSmtpPort());\n         }\n         if (acc.isUseSsl()) {\n             if (props.getProperty(\"mail.smtp.socketFactory.port\") == null) {\n                 String port = acc.getSmtpPort() == null ? \"465\" : mailAccount.getSmtpPort();\n                 props.put(\"mail.smtp.port\", port);\n                 props.put(\"mail.smtp.socketFactory.port\", port);\n             }\n             if (props.getProperty(\"mail.smtp.socketFactory.class\") == null) {\n                 props.put(\"mail.smtp.socketFactory.class\", \"javax.net.ssl.SSLSocketFactory\");\n             }\n             props.put(\"mail.smtp.socketFactory.fallback\", \"false\");\n// bug_start\n// bug_end\n         }\n         if (!StringUtils.isBlank(acc.getSmtpUsername())) {\n             props.put(\"mail.smtp.auth\", \"true\");\n         }\n \n         props.put(\"mail.smtp.timeout\", \"60000\");\n         props.put(\"mail.smtp.connectiontimeout\", \"60000\");\n \n         try {\n             String ap = acc.getAdvProperties();\n             if (ap != null && !isBlank(ap.trim())) {\n                 props.load(new StringReader(ap));\n             }\n         } catch (IOException e) {\n             LOGGER.log(Level.WARNING, \"Parameters parse fail.\", e);\n         }\n \n         return Session.getInstance(props, getAuthenticator(acc));\n     }\n \n", "target": "// fix_start\n\n            if (props.getProperty(\"mail.smtp.ssl.checkserveridentity\") == null) {\n                props.put(\"mail.smtp.ssl.checkserveridentity\", \"true\");\n            }\n// fix_end\n", "cwe": "CWE-295", "cwe_name": "Improper Certificate Validation", "idx": 40751}
{"source": " public void update(long done, long total, int item) {\n     if (exceptionTrhown) { return; }\n \n     boolean save = bytesRead == 0 && done > 0 || done >= total || (new Date()).getTime() - saved.getTime() > DEFAULT_SAVE_INTERVAL;\n     bytesRead = done;\n     contentLength = total;\n     if (save) {\n       save();\n     }\n \n     if (isCanceled()) {\n       String eName = exception.getClass().getName().replaceAll(\"^.+\\\\.\", \"\");\n       logger.info(className + \" \" + sessionId + \" The upload has been canceled after \" + bytesRead + \" bytes received, raising an exception (\" + eName + \") to close the socket\");\n       exceptionTrhown = true;\n       throw exception;\n     }\n \n// bug_start\n    if (slowUploads > 0 && done < total) {\n// bug_end\n       try {\n         Thread.sleep(slowUploads);\n       } catch (Exception e) {\n         exception = new RuntimeException(e);\n       }\n     }\n   }\n \n", "target": "// fix_start\n    if (slowUploads > 0 && slowUploads < 30000 && done < total) {\n// fix_end\n", "cwe": "CWE-434", "cwe_name": "Unrestricted Upload of File with Dangerous Type", "idx": 53715}
{"source": " private void doDsaTest(String sigName, BigInteger s, KeyFactory ecKeyFact, DSAPublicKeySpec pubKey, DSAPrivateKeySpec priKey)\n         throws NoSuchAlgorithmException, NoSuchProviderException, InvalidKeyException, InvalidKeySpecException, SignatureException\n     {\n// bug_start\n        SecureRandom k = new TestRandomBigInteger(BigIntegers.asUnsignedByteArray(new BigInteger(\"72546832179840998877302529996971396893172522460793442785601695562409154906335\")));\n// bug_end\n \n         byte[] M = Hex.decode(\"1BD4ED430B0F384B4E8D458EFF1A8A553286D7AC21CB2F6806172EF5F94A06AD\");\n \n         Signature dsa = Signature.getInstance(sigName, \"BC\");\n \n         dsa.initSign(ecKeyFact.generatePrivate(priKey), k);\n \n         dsa.update(M, 0, M.length);\n \n         byte[] encSig = dsa.sign();\n \n         ASN1Sequence sig = ASN1Sequence.getInstance(encSig);\n \n         BigInteger r = new BigInteger(\"4864074fe30e6601268ee663440e4d9b703f62673419864e91e9edb0338ce510\", 16);\n \n         BigInteger sigR = ASN1Integer.getInstance(sig.getObjectAt(0)).getValue();\n         if (!r.equals(sigR))\n         {\n             fail(\"r component wrong.\" + Strings.lineSeparator()\n                 + \" expecting: \" + r.toString(16) + Strings.lineSeparator()\n                 + \" got      : \" + sigR.toString(16));\n         }\n \n         BigInteger sigS = ASN1Integer.getInstance(sig.getObjectAt(1)).getValue();\n         if (!s.equals(sigS))\n         {\n             fail(\"s component wrong.\" + Strings.lineSeparator()\n                 + \" expecting: \" + s.toString(16) + Strings.lineSeparator()\n                 + \" got      : \" + sigS.toString(16));\n         }\n \n         dsa.initVerify(ecKeyFact.generatePublic(pubKey));\n \n         dsa.update(M, 0, M.length);\n \n         if (!dsa.verify(encSig))\n         {\n             fail(\"signature fails\");\n         }\n     }\n \n", "target": "// fix_start\n        SecureRandom k = new FixedSecureRandom(\n            new FixedSecureRandom.Source[] { new FixedSecureRandom.BigInteger(BigIntegers.asUnsignedByteArray(new BigInteger(\"72546832179840998877302529996971396893172522460793442785601695562409154906335\"))),\n                new FixedSecureRandom.Data(Hex.decode(\"01020304\")) });\n// fix_end\n", "cwe": "CWE-361", "cwe_name": "Time and State", "idx": 48220}
{"source": " public byte[] toXML() throws TransformerException {\n         removeEmptyNodes(doc);\n         TransformerFactory transformerFactory = TransformerFactory.newInstance();\n// bug_start\n// bug_end\n         Transformer transformer = transformerFactory.newTransformer();\n         transformer.setOutputProperty(OutputKeys.METHOD, \"xml\");\n         transformer.setOutputProperty(OutputKeys.INDENT, \"yes\");\n         transformer.setOutputProperty(\"{http://xml.apache.org/xslt}indent-amount\", \"4\");\n// bug_start\n\tDOMSource source = new DOMSource(doc);\n// bug_end\n         ByteArrayOutputStream out = new ByteArrayOutputStream();\n         Result result = new StreamResult(out);\n         transformer.transform(source, result);\n         return out.toByteArray();\n     }\n \n", "target": "// fix_start\n        try {\n            transformerFactory.setFeature(XMLConstants.FEATURE_SECURE_PROCESSING, true);\n        } catch (Exception exc) {}\n// fix_end\n// fix_start\n\t    DOMSource source = new DOMSource(doc);\n// fix_end\n", "cwe": "CWE-399", "cwe_name": "Resource Management Errors", "idx": 52001}
{"source": "// bug_start\n@Override\n\t\tpublic void setPropertyValue(String propertyName, @Nullable Object value) throws BeansException {\n// bug_end\n \n// bug_start\n\t\t\tif (!isWritableProperty(propertyName)) {\n\t\t\t\tthrow new NotWritablePropertyException(type, propertyName);\n\t\t\t}\n// bug_end\n \n// bug_start\n\t\t\tStandardEvaluationContext context = new StandardEvaluationContext();\n\t\t\tcontext.addPropertyAccessor(new PropertyTraversingMapAccessor(type, conversionService));\n\t\t\tcontext.setTypeConverter(new StandardTypeConverter(conversionService));\n\t\t\tcontext.setTypeLocator(typeName -> {\n\t\t\t\tthrow new SpelEvaluationException(SpelMessage.TYPE_NOT_FOUND, typeName);\n\t\t\t});\n\t\t\tcontext.setRootObject(map);\n// bug_end\n \n// bug_start\n\t\t\tExpression expression = PARSER.parseExpression(propertyName);\n// bug_end\n \n// bug_start\n\t\t\tPropertyPath leafProperty = getPropertyPath(propertyName).getLeafProperty();\n\t\t\tTypeInformation<?> owningType = leafProperty.getOwningType();\n\t\t\tTypeInformation<?> propertyType = leafProperty.getTypeInformation();\n// bug_end\n \n// bug_start\n\t\t\tpropertyType = propertyName.endsWith(\"]\") ? propertyType.getActualType() : propertyType;\n// bug_end\n \n// bug_start\n\t\t\tif (propertyType != null && conversionRequired(value, propertyType.getType())) {\n// bug_end\n \n// bug_start\n\t\t\t\tPropertyDescriptor descriptor = BeanUtils.getPropertyDescriptor(owningType.getType(),\n\t\t\t\t\t\tleafProperty.getSegment());\n// bug_end\n \n// bug_start\n\t\t\t\tif (descriptor == null) {\n\t\t\t\t\tthrow new IllegalStateException(String.format(\"Couldn't find PropertyDescriptor for %s on %s!\",\n\t\t\t\t\t\t\tleafProperty.getSegment(), owningType.getType()));\n\t\t\t\t}\n\n\t\t\t\tMethodParameter methodParameter = new MethodParameter(descriptor.getReadMethod(), -1);\n\t\t\t\tTypeDescriptor typeDescriptor = TypeDescriptor.nested(methodParameter, 0);\n\n\t\t\t\tif (typeDescriptor == null) {\n\t\t\t\t\tthrow new IllegalStateException(\n\t\t\t\t\t\t\tString.format(\"Couldn't obtain type descriptor for method parameter %s!\", methodParameter));\n\t\t\t\t}\n\n\t\t\t\tvalue = conversionService.convert(value, TypeDescriptor.forObject(value), typeDescriptor);\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\texpression.setValue(context, value);\n\t\t\t} catch (SpelEvaluationException o_O) {\n\t\t\t\tthrow new NotWritablePropertyException(type, propertyName, \"Could not write property!\", o_O);\n\t\t\t}\n\t\t}\n\n// bug_end\n", "target": "// fix_start\nprivate void init(ErrorDispatcher err) throws JasperException {\n        if (initialized)\n            return;\n// fix_end\n// fix_start\n        String blockExternalString = ctxt.getInitParameter(\n                Constants.XML_BLOCK_EXTERNAL_INIT_PARAM);\n        boolean blockExternal;\n        if (blockExternalString == null) {\n            blockExternal = true;\n        } else {\n            blockExternal = Boolean.parseBoolean(blockExternalString);\n        }\n// fix_end\n// fix_start\n        TagPluginParser parser;\n        ClassLoader original;\n        if (Constants.IS_SECURITY_ENABLED) {\n            PrivilegedGetTccl pa = new PrivilegedGetTccl();\n            original = AccessController.doPrivileged(pa);\n        } else {\n            original = Thread.currentThread().getContextClassLoader();\n        }\n        try {\n            if (Constants.IS_SECURITY_ENABLED) {\n                PrivilegedSetTccl pa =\n                        new PrivilegedSetTccl(TagPluginManager.class.getClassLoader());\n                AccessController.doPrivileged(pa);\n            } else {\n                Thread.currentThread().setContextClassLoader(\n                        TagPluginManager.class.getClassLoader());\n            }\n// fix_end\n// fix_start\n            parser = new TagPluginParser(ctxt, blockExternal);\n// fix_end\n// fix_start\n        } finally {\n            if (Constants.IS_SECURITY_ENABLED) {\n                PrivilegedSetTccl pa = new PrivilegedSetTccl(original);\n                AccessController.doPrivileged(pa);\n            } else {\n                Thread.currentThread().setContextClassLoader(original);\n            }\n        }\n// fix_end\n// fix_start\n        try {\n            Enumeration<URL> urls =\n                    ctxt.getClassLoader().getResources(META_INF_JASPER_TAG_PLUGINS_XML);\n            if (urls != null) {\n                while (urls.hasMoreElements()) {\n                    URL url = urls.nextElement();\n                    parser.parse(url);\n                }\n            }\n// fix_end\n// fix_start\n            URL url = ctxt.getResource(TAG_PLUGINS_XML);\n            if (url != null) {\n                parser.parse(url);\n            }\n        } catch (IOException | SAXException e) {\n            throw new JasperException(e);\n        }\n// fix_end\n// fix_start\n        Map<String, String> plugins = parser.getPlugins();\n        tagPlugins = new HashMap<>(plugins.size());\n        for (Map.Entry<String, String> entry : plugins.entrySet()) {\n            try {\n                String tagClass = entry.getKey();\n                String pluginName = entry.getValue();\n                Class<?> pluginClass = ctxt.getClassLoader().loadClass(pluginName);\n                TagPlugin plugin = (TagPlugin) pluginClass.newInstance();\n                tagPlugins.put(tagClass, plugin);\n            } catch (Exception e) {\n                err.jspError(e);\n            }\n        }\n        initialized = true;\n    }\n// fix_end\n", "cwe": "CWE-264", "cwe_name": "Permissions, Privileges, and Access Controls", "idx": 32720}
{"source": " @Override\n// bug_start\n        public String getProperty( String key ) {\n            return System.getProperty(key);\n        }\n// bug_end\n \n", "target": "// fix_start\n\t\tpublic void setPropertyValue(String propertyName, @Nullable Object value) throws BeansException {\n// fix_end\n// fix_start\n\t\t\tif (!isWritableProperty(propertyName)) {\n\t\t\t\tthrow new NotWritablePropertyException(type, propertyName);\n\t\t\t}\n\n\t\t\tPropertyPath leafProperty = getPropertyPath(propertyName).getLeafProperty();\n\t\t\tTypeInformation<?> owningType = leafProperty.getOwningType();\n\t\t\tTypeInformation<?> propertyType = leafProperty.getTypeInformation();\n\n\t\t\tpropertyType = propertyName.endsWith(\"]\") ? propertyType.getActualType() : propertyType;\n\n\t\t\tif (propertyType != null && conversionRequired(value, propertyType.getType())) {\n\n\t\t\t\tPropertyDescriptor descriptor = BeanUtils.getPropertyDescriptor(owningType.getType(),\n\t\t\t\t\t\tleafProperty.getSegment());\n\n\t\t\t\tif (descriptor == null) {\n\t\t\t\t\tthrow new IllegalStateException(String.format(\"Couldn't find PropertyDescriptor for %s on %s!\",\n\t\t\t\t\t\t\tleafProperty.getSegment(), owningType.getType()));\n\t\t\t\t}\n\n\t\t\t\tMethodParameter methodParameter = new MethodParameter(descriptor.getReadMethod(), -1);\n\t\t\t\tTypeDescriptor typeDescriptor = TypeDescriptor.nested(methodParameter, 0);\n\n\t\t\t\tif (typeDescriptor == null) {\n\t\t\t\t\tthrow new IllegalStateException(\n\t\t\t\t\t\t\tString.format(\"Couldn't obtain type descriptor for method parameter %s!\", methodParameter));\n\t\t\t\t}\n\n\t\t\t\tvalue = conversionService.convert(value, TypeDescriptor.forObject(value), typeDescriptor);\n\t\t\t}\n\n\t\t\tEvaluationContext context = SimpleEvaluationContext\n\t\t\t\t\t.forPropertyAccessors(new PropertyTraversingMapAccessor(type, conversionService))\n\t\t\t\t\t.withConversionService(conversionService)\n\t\t\t\t\t.withRootObject(map)\n\t\t\t\t\t.build();\n\n\t\t\tExpression expression = PARSER.parseExpression(propertyName);\n\n\t\t\ttry {\n\t\t\t\texpression.setValue(context, value);\n\t\t\t} catch (SpelEvaluationException o_O) {\n\t\t\t\tthrow new NotWritablePropertyException(type, propertyName, \"Could not write property!\", o_O);\n\t\t\t}\n\t\t}\n\n// fix_end\n", "cwe": "CWE-20", "cwe_name": "Improper Input Validation", "idx": 11743}
{"source": "// bug_start\npublic static boolean isFileOutsideDir(\n          @NonNull final String filePath, @NonNull final String baseDirPath) throws IOException {\n    File file = new File(filePath);\n    File baseDir = new File(baseDirPath);\n    return !file.getCanonicalPath().startsWith(baseDir.getCanonicalPath());\n  }\n// bug_end\n \n", "target": "// fix_start\n@Override\n        public String getProperty( String key ) {\n            ClassLoader cl = Thread.currentThread().getContextClassLoader();\n            if (cl instanceof PermissionCheck) {\n                Permission p = new PropertyPermission(key, \"read\");\n                if (!((PermissionCheck) cl).check(p)) {\n                    return null;\n                }\n            }\n            return System.getProperty(key);\n        }\n// fix_end\n", "cwe": "NVD-CWE-noinfo", "cwe_name": "", "idx": 101465}
{"source": "// bug_start\npublic Object eval(String xml, String path, QName qname) {\n    if (xml == null || path == null || qname == null) {\n      return null;\n    }\n\n    if (xml.length() == 0 || path.length() == 0) {\n      return null;\n    }\n\n    if (!path.equals(oldPath)) {\n      try {\n        expression = xpath.compile(path);\n      } catch (XPathExpressionException e) {\n        expression = null;\n      }\n      oldPath = path;\n    }\n\n    if (expression == null) {\n      return null;\n    }\n\n    if (builder == null){\n      try {\n        initializeDocumentBuilderFactory();\n        builder = dbf.newDocumentBuilder();\n      } catch (ParserConfigurationException e) {\n        throw new RuntimeException(\"Error instantiating DocumentBuilder, cannot build xml parser\", e);\n      }\n    }\n\n    reader.set(xml);\n\n    try {\n      return expression.evaluate(builder.parse(inputSource), qname);\n    } catch (XPathExpressionException e) {\n      throw new RuntimeException (\"Invalid expression '\" + oldPath + \"'\", e);\n    } catch (Exception e) {\n      throw new RuntimeException(\"Error loading expression '\" + oldPath + \"'\", e);\n    }\n// bug_end\n   }\n \n", "target": "// fix_start\npublic static boolean isFileOutsideDir(\n          @NonNull final String filePath, @NonNull final String baseDirPath) throws IOException {\n    File file = new File(filePath);\n    File baseDir = new File(baseDirPath);\n    return !file.getCanonicalFile().toPath().startsWith(baseDir.getCanonicalFile().toPath());\n// fix_end\n", "cwe": "CWE-22", "cwe_name": "Path Traversal", "idx": 27290}
{"source": "// bug_start\npublic Object eval(String xml, String path, QName qname) {\n    if (xml == null || path == null || qname == null) {\n      return null;\n    }\n// bug_end\n \n// bug_start\n    if (xml.length() == 0 || path.length() == 0) {\n      return null;\n    }\n\n    if (!path.equals(oldPath)) {\n      try {\n        expression = xpath.compile(path);\n      } catch (XPathExpressionException e) {\n        expression = null;\n      }\n      oldPath = path;\n    }\n\n    if (expression == null) {\n      return null;\n    }\n\n    reader.set(xml);\n\n    try {\n      return expression.evaluate(inputSource, qname);\n    } catch (XPathExpressionException e) {\n      throw new RuntimeException (\"Invalid expression '\" + oldPath + \"'\", e);\n    }\n  }\n\n// bug_end\n", "target": "// fix_start\npublic HttpResponse doPostCredential(@QueryParameter String username, @QueryParameter String password) throws IOException, ServletException {\n            this.username = username;\n            this.password = Secret.fromString(password);\n            save();\n            return HttpResponses.redirectTo(\"credentialOK\");\n        }\n// fix_end\n", "cwe": "CWE-200", "cwe_name": "Exposure of Sensitive Information to an Unauthorized Actor", "idx": 18597}
{"source": "// bug_start\n@Override\n        public void onHeadersRead(ChannelHandlerContext ctx, int streamId, Http2Headers headers, int streamDependency,\n                short weight, boolean exclusive, int padding, boolean endOfStream) throws Http2Exception {\n            Http2Stream stream = connection.stream(streamId);\n            boolean allowHalfClosedRemote = false;\n            boolean isTrailers = false;\n            if (stream == null && !connection.streamMayHaveExisted(streamId)) {\n                stream = connection.remote().createStream(streamId, endOfStream);\n                allowHalfClosedRemote = stream.state() == HALF_CLOSED_REMOTE;\n            } else if (stream != null) {\n                isTrailers = stream.isHeadersReceived();\n            }\n\n            if (shouldIgnoreHeadersOrDataFrame(ctx, streamId, stream, \"HEADERS\")) {\n                return;\n            }\n\n            boolean isInformational = !connection.isServer() &&\n                    HttpStatusClass.valueOf(headers.status()) == INFORMATIONAL;\n            if ((isInformational || !endOfStream) && stream.isHeadersReceived() || stream.isTrailersReceived()) {\n                throw streamError(streamId, PROTOCOL_ERROR,\n                                  \"Stream %d received too many headers EOS: %s state: %s\",\n                                  streamId, endOfStream, stream.state());\n            }\n\n            switch (stream.state()) {\n                case RESERVED_REMOTE:\n                    stream.open(endOfStream);\n                    break;\n                case OPEN:\n                case HALF_CLOSED_LOCAL:\n                    break;\n                case HALF_CLOSED_REMOTE:\n                    if (!allowHalfClosedRemote) {\n                        throw streamError(stream.id(), STREAM_CLOSED, \"Stream %d in unexpected state: %s\",\n                                stream.id(), stream.state());\n                    }\n                    break;\n                case CLOSED:\n                    throw streamError(stream.id(), STREAM_CLOSED, \"Stream %d in unexpected state: %s\",\n                            stream.id(), stream.state());\n                default:\n                    throw connectionError(PROTOCOL_ERROR, \"Stream %d in unexpected state: %s\", stream.id(),\n                            stream.state());\n            }\n\n            if (!isTrailers) {\n                List<? extends CharSequence> contentLength = headers.getAll(HttpHeaderNames.CONTENT_LENGTH);\n                if (contentLength != null && !contentLength.isEmpty()) {\n                    try {\n                        long cLength = HttpUtil.normalizeAndGetContentLength(contentLength, false, true);\n                        if (cLength != -1) {\n                            headers.setLong(HttpHeaderNames.CONTENT_LENGTH, cLength);\n                            stream.setProperty(contentLengthKey, new ContentLength(cLength));\n                        }\n                    } catch (IllegalArgumentException e) {\n                        throw streamError(stream.id(), PROTOCOL_ERROR, e,\n                                \"Multiple content-length headers received\");\n                    }\n                }\n            }\n\n            stream.headersReceived(isInformational);\n            verifyContentLength(stream, 0, endOfStream);\n            encoder.flowController().updateDependencyTree(streamId, streamDependency, weight, exclusive);\n            listener.onHeadersRead(ctx, streamId, headers, streamDependency,\n                    weight, exclusive, padding, endOfStream);\n            if (endOfStream) {\n                lifecycleManager.closeStreamRemote(stream, ctx.newSucceededFuture());\n            }\n// bug_end\n         }\n \n", "target": "// fix_start\n@RequirePOST\n        public HttpResponse doPostCredential(@QueryParameter String username, @QueryParameter String password) throws IOException, ServletException {\n            Jenkins.getInstance().checkPermission(Jenkins.ADMINISTER);\n            this.username = username;\n            this.password = Secret.fromString(password);\n            save();\n            return HttpResponses.redirectTo(\"credentialOK\");\n// fix_end\n", "cwe": "CWE-732", "cwe_name": "Incorrect Permission Assignment for Critical Resource", "idx": 72677}
{"source": "// bug_start\n@Override\n        public void onHeadersRead(ChannelHandlerContext ctx, int streamId, Http2Headers headers, int streamDependency,\n                short weight, boolean exclusive, int padding, boolean endOfStream) throws Http2Exception {\n            Http2Stream stream = connection.stream(streamId);\n            boolean allowHalfClosedRemote = false;\n            if (stream == null && !connection.streamMayHaveExisted(streamId)) {\n                stream = connection.remote().createStream(streamId, endOfStream);\n                allowHalfClosedRemote = stream.state() == HALF_CLOSED_REMOTE;\n            }\n// bug_end\n \n// bug_start\n            if (shouldIgnoreHeadersOrDataFrame(ctx, streamId, stream, \"HEADERS\")) {\n                return;\n            }\n// bug_end\n \n// bug_start\n            boolean isInformational = !connection.isServer() &&\n                    HttpStatusClass.valueOf(headers.status()) == INFORMATIONAL;\n            if ((isInformational || !endOfStream) && stream.isHeadersReceived() || stream.isTrailersReceived()) {\n                throw streamError(streamId, PROTOCOL_ERROR,\n                                  \"Stream %d received too many headers EOS: %s state: %s\",\n                                  streamId, endOfStream, stream.state());\n            }\n// bug_end\n \n// bug_start\n            switch (stream.state()) {\n                case RESERVED_REMOTE:\n                    stream.open(endOfStream);\n                    break;\n                case OPEN:\n                case HALF_CLOSED_LOCAL:\n                    break;\n                case HALF_CLOSED_REMOTE:\n                    if (!allowHalfClosedRemote) {\n                        throw streamError(stream.id(), STREAM_CLOSED, \"Stream %d in unexpected state: %s\",\n                                stream.id(), stream.state());\n                    }\n                    break;\n                case CLOSED:\n                    throw streamError(stream.id(), STREAM_CLOSED, \"Stream %d in unexpected state: %s\",\n                            stream.id(), stream.state());\n                default:\n                    throw connectionError(PROTOCOL_ERROR, \"Stream %d in unexpected state: %s\", stream.id(),\n                            stream.state());\n            }\n// bug_end\n \n// bug_start\n            if (!stream.isHeadersReceived()) {\n                List<? extends CharSequence> contentLength = headers.getAll(HttpHeaderNames.CONTENT_LENGTH);\n                if (contentLength != null && !contentLength.isEmpty()) {\n                    try {\n                        long cLength = HttpUtil.normalizeAndGetContentLength(contentLength, false, true);\n                        if (cLength != -1) {\n                            headers.setLong(HttpHeaderNames.CONTENT_LENGTH, cLength);\n                            stream.setProperty(contentLengthKey, new ContentLength(cLength));\n                        }\n                    } catch (IllegalArgumentException e) {\n                        throw streamError(stream.id(), PROTOCOL_ERROR, e,\n                                \"Multiple content-length headers received\");\n                    }\n                }\n            }\n// bug_end\n \n// bug_start\n            stream.headersReceived(isInformational);\n            verifyContentLength(stream, 0, endOfStream);\n            encoder.flowController().updateDependencyTree(streamId, streamDependency, weight, exclusive);\n            listener.onHeadersRead(ctx, streamId, headers, streamDependency,\n                    weight, exclusive, padding, endOfStream);\n            if (endOfStream) {\n                lifecycleManager.closeStreamRemote(stream, ctx.newSucceededFuture());\n            }\n        }\n// bug_end\n \n", "target": "// fix_start\npublic SerializedInfoflowResults readResults(String fileName) throws XMLStreamException, IOException {\n\t\tSerializedInfoflowResults results = new SerializedInfoflowResults();\n\t\tInfoflowPerformanceData perfData = null;\n// fix_end\n// fix_start\n\t\tXMLStreamReader reader = null;\n\t\ttry (InputStream in = new FileInputStream(fileName)) {\n\t\t\tXMLInputFactory factory = XMLInputFactory.newInstance();\n\t\t\tfactory.setProperty(XMLInputFactory.IS_SUPPORTING_EXTERNAL_ENTITIES, false);\n\t\t\tfactory.setProperty(XMLInputFactory.SUPPORT_DTD, false);\n\t\t\treader = factory.createXMLStreamReader(in);\n// fix_end\n// fix_start\n\t\t\tString statement = null;\n\t\t\tString method = null;\n\t\t\tString apValue = null;\n\t\t\tString apValueType = null;\n\t\t\tboolean apTaintSubFields = false;\n\t\t\tList<String> apFields = new ArrayList<>();\n\t\t\tList<String> apTypes = new ArrayList<>();\n\t\t\tSerializedAccessPath ap = null;\n\t\t\tSerializedSinkInfo sink = null;\n\t\t\tSerializedSourceInfo source = null;\n\t\t\tList<SerializedPathElement> pathElements = new ArrayList<>();\n// fix_end\n// fix_start\n\t\t\tStack<State> stateStack = new Stack<>();\n\t\t\tstateStack.push(State.init);\n// fix_end\n// fix_start\n\t\t\twhile (reader.hasNext()) {\n\t\t\t\treader.next();\n\t\t\t\tif (!reader.hasName())\n\t\t\t\t\tcontinue;\n// fix_end\n// fix_start\n\t\t\t\tif (reader.getLocalName().equals(XmlConstants.Tags.root) && reader.isStartElement()\n\t\t\t\t\t\t&& stateStack.peek() == State.init) {\n\t\t\t\t\tstateStack.push(State.dataFlowResults);\n// fix_end\n// fix_start\n\t\t\t\t\tresults.setFileFormatVersion(\n\t\t\t\t\t\t\tint2Str(getAttributeByName(reader, XmlConstants.Attributes.fileFormatVersion)));\n\t\t\t\t} else if (reader.getLocalName().equals(XmlConstants.Tags.results) && reader.isStartElement()\n\t\t\t\t\t\t&& stateStack.peek() == State.dataFlowResults) {\n\t\t\t\t\tstateStack.push(State.results);\n\t\t\t\t} else if (reader.getLocalName().equals(XmlConstants.Tags.result) && reader.isStartElement()\n\t\t\t\t\t\t&& stateStack.peek() == State.results) {\n\t\t\t\t\tstateStack.push(State.result);\n\t\t\t\t} else if (reader.getLocalName().equals(XmlConstants.Tags.sink) && reader.isStartElement()\n\t\t\t\t\t\t&& stateStack.peek() == State.result) {\n\t\t\t\t\tstateStack.push(State.sink);\n\n\t\t\t\t\tstatement = getAttributeByName(reader, XmlConstants.Attributes.statement);\n\t\t\t\t} else if (reader.getLocalName().equals(XmlConstants.Tags.accessPath) && reader.isStartElement()) {\n\t\t\t\t\tstateStack.push(State.accessPath);\n\n\t\t\t\t\tapValue = getAttributeByName(reader, XmlConstants.Attributes.value);\n\t\t\t\t\tapValueType = getAttributeByName(reader, XmlConstants.Attributes.type);\n\t\t\t\t\tapTaintSubFields = getAttributeByName(reader, XmlConstants.Attributes.taintSubFields)\n\t\t\t\t\t\t\t.equals(XmlConstants.Values.TRUE);\n\n\t\t\t\t\tapFields.clear();\n\t\t\t\t\tapTypes.clear();\n\t\t\t\t} else if (reader.getLocalName().equals(XmlConstants.Tags.fields) && reader.isStartElement()\n\t\t\t\t\t\t&& stateStack.peek() == State.accessPath) {\n\t\t\t\t\tstateStack.push(State.fields);\n\t\t\t\t} else if (reader.getLocalName().equals(XmlConstants.Tags.field) && reader.isStartElement()\n\t\t\t\t\t\t&& stateStack.peek() == State.fields) {\n\t\t\t\t\tstateStack.push(State.field);\n\n\t\t\t\t\tString value = getAttributeByName(reader, XmlConstants.Attributes.value);\n\t\t\t\t\tString type = getAttributeByName(reader, XmlConstants.Attributes.type);\n\t\t\t\t\tif (value != null && !value.isEmpty() && type != null && !type.isEmpty()) {\n\t\t\t\t\t\tapFields.add(value);\n\t\t\t\t\t\tapTypes.add(value);\n\t\t\t\t\t}\n\t\t\t\t} else if (reader.getLocalName().equals(XmlConstants.Tags.sources) && reader.isStartElement()\n\t\t\t\t\t\t&& stateStack.peek() == State.result) {\n\t\t\t\t\tstateStack.push(State.sources);\n\t\t\t\t} else if (reader.getLocalName().equals(XmlConstants.Tags.source) && reader.isStartElement()\n\t\t\t\t\t\t&& stateStack.peek() == State.sources) {\n\t\t\t\t\tstateStack.push(State.source);\n\n\t\t\t\t\tstatement = getAttributeByName(reader, XmlConstants.Attributes.statement);\n\t\t\t\t\tmethod = getAttributeByName(reader, XmlConstants.Attributes.method);\n\t\t\t\t} else if (reader.getLocalName().equals(XmlConstants.Tags.taintPath) && reader.isStartElement()\n\t\t\t\t\t\t&& stateStack.peek() == State.source) {\n\t\t\t\t\tstateStack.push(State.taintPath);\n\n\t\t\t\t\tpathElements.clear();\n\t\t\t\t} else if (reader.getLocalName().equals(XmlConstants.Tags.pathElement) && reader.isStartElement()\n\t\t\t\t\t\t&& stateStack.peek() == State.source) {\n\t\t\t\t\tstateStack.push(State.taintPath);\n\n\t\t\t\t\tstatement = getAttributeByName(reader, XmlConstants.Attributes.statement);\n\t\t\t\t\tmethod = getAttributeByName(reader, XmlConstants.Attributes.method);\n\t\t\t\t} else if (reader.getLocalName().equals(XmlConstants.Tags.performanceData) && reader.isStartElement()\n\t\t\t\t\t\t&& stateStack.peek() == State.dataFlowResults) {\n\t\t\t\t\tstateStack.push(State.performanceData);\n\t\t\t\t} else if (reader.getLocalName().equals(XmlConstants.Tags.performanceEntry) && reader.isStartElement()\n\t\t\t\t\t\t&& stateStack.peek() == State.performanceData) {\n\t\t\t\t\tstateStack.push(State.performanceEntry);\n\n\t\t\t\t\tif (perfData == null)\n\t\t\t\t\t\tperfData = results.getOrCreatePerformanceData();\n\n\t\t\t\t\tString perfName = getAttributeByName(reader, XmlConstants.Attributes.name);\n\t\t\t\t\tString perfValue = getAttributeByName(reader, XmlConstants.Attributes.value);\n\n\t\t\t\t\tswitch (perfName) {\n\t\t\t\t\tcase XmlConstants.Values.PERF_CALLGRAPH_SECONDS:\n\t\t\t\t\t\tperfData.setCallgraphConstructionSeconds(Integer.parseInt(perfValue));\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase XmlConstants.Values.PERF_PATH_RECONSTRUCTION_SECONDS:\n\t\t\t\t\t\tperfData.setPathReconstructionSeconds(Integer.parseInt(perfValue));\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase XmlConstants.Values.PERF_TAINT_PROPAGATION_SECONDS:\n\t\t\t\t\t\tperfData.setTaintPropagationSeconds(Integer.parseInt(perfValue));\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase XmlConstants.Values.PERF_TOTAL_RUNTIME_SECONDS:\n\t\t\t\t\t\tperfData.setTotalRuntimeSeconds(Integer.parseInt(perfValue));\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase XmlConstants.Values.PERF_MAX_MEMORY_CONSUMPTION:\n\t\t\t\t\t\tperfData.setMaxMemoryConsumption(Integer.parseInt(perfValue));\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase XmlConstants.Values.PERF_SOURCE_COUNT:\n\t\t\t\t\t\tperfData.setSourceCount(Integer.parseInt(perfValue));\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase XmlConstants.Values.PERF_SINK_COUNT:\n\t\t\t\t\t\tperfData.setSinkCount(Integer.parseInt(perfValue));\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t} else if (reader.isEndElement()) {\n\t\t\t\t\tstateStack.pop();\n\n\t\t\t\t\tif (reader.getLocalName().equals(XmlConstants.Tags.accessPath))\n\t\t\t\t\t\tap = new SerializedAccessPath(apValue, apValueType, apTaintSubFields,\n\t\t\t\t\t\t\t\tapFields.toArray(new String[apFields.size()]),\n\t\t\t\t\t\t\t\tapTypes.toArray(new String[apTypes.size()]));\n\t\t\t\t\telse if (reader.getLocalName().equals(XmlConstants.Tags.sink))\n\t\t\t\t\t\tsink = new SerializedSinkInfo(ap, statement, method);\n\t\t\t\t\telse if (reader.getLocalName().equals(XmlConstants.Tags.source))\n\t\t\t\t\t\tsource = new SerializedSourceInfo(ap, statement, method, pathElements);\n\t\t\t\t\telse if (reader.getLocalName().equals(XmlConstants.Tags.result))\n\t\t\t\t\t\tresults.addResult(source, sink);\n\t\t\t\t\telse if (reader.getLocalName().equals(XmlConstants.Tags.pathElement))\n\t\t\t\t\t\tpathElements.add(new SerializedPathElement(ap, statement, method));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn results;\n\t\t} finally {\n\t\t\tif (reader != null)\n\t\t\t\treader.close();\n\t\t}\n\t}\n\n// fix_end\n", "cwe": "CWE-444", "cwe_name": "Inconsistent Interpretation of HTTP Requests ('HTTP Request Smuggling')", "idx": 54165}
{"source": "// bug_start\npublic SerializedInfoflowResults readResults(String fileName) throws XMLStreamException, IOException {\n\t\tSerializedInfoflowResults results = new SerializedInfoflowResults();\n\t\tInfoflowPerformanceData perfData = null;\n// bug_end\n \n// bug_start\n\t\tXMLStreamReader reader = null;\n\t\ttry (InputStream in = new FileInputStream(fileName)) {\n\t\t\treader = XMLInputFactory.newInstance().createXMLStreamReader(in);\n\n\t\t\tString statement = null;\n\t\t\tString method = null;\n\t\t\tString apValue = null;\n\t\t\tString apValueType = null;\n\t\t\tboolean apTaintSubFields = false;\n\t\t\tList<String> apFields = new ArrayList<>();\n\t\t\tList<String> apTypes = new ArrayList<>();\n\t\t\tSerializedAccessPath ap = null;\n\t\t\tSerializedSinkInfo sink = null;\n\t\t\tSerializedSourceInfo source = null;\n\t\t\tList<SerializedPathElement> pathElements = new ArrayList<>();\n\n\t\t\tStack<State> stateStack = new Stack<>();\n\t\t\tstateStack.push(State.init);\n\n\t\t\twhile (reader.hasNext()) {\n\t\t\t\treader.next();\n\t\t\t\tif (!reader.hasName())\n\t\t\t\t\tcontinue;\n\n\t\t\t\tif (reader.getLocalName().equals(XmlConstants.Tags.root) && reader.isStartElement()\n\t\t\t\t\t\t&& stateStack.peek() == State.init) {\n\t\t\t\t\tstateStack.push(State.dataFlowResults);\n\n\t\t\t\t\tresults.setFileFormatVersion(\n\t\t\t\t\t\t\tint2Str(getAttributeByName(reader, XmlConstants.Attributes.fileFormatVersion)));\n\t\t\t\t} else if (reader.getLocalName().equals(XmlConstants.Tags.results) && reader.isStartElement()\n\t\t\t\t\t\t&& stateStack.peek() == State.dataFlowResults) {\n\t\t\t\t\tstateStack.push(State.results);\n\t\t\t\t} else if (reader.getLocalName().equals(XmlConstants.Tags.result) && reader.isStartElement()\n\t\t\t\t\t\t&& stateStack.peek() == State.results) {\n\t\t\t\t\tstateStack.push(State.result);\n\t\t\t\t} else if (reader.getLocalName().equals(XmlConstants.Tags.sink) && reader.isStartElement()\n\t\t\t\t\t\t&& stateStack.peek() == State.result) {\n\t\t\t\t\tstateStack.push(State.sink);\n\n\t\t\t\t\tstatement = getAttributeByName(reader, XmlConstants.Attributes.statement);\n\t\t\t\t} else if (reader.getLocalName().equals(XmlConstants.Tags.accessPath) && reader.isStartElement()) {\n\t\t\t\t\tstateStack.push(State.accessPath);\n\n\t\t\t\t\tapValue = getAttributeByName(reader, XmlConstants.Attributes.value);\n\t\t\t\t\tapValueType = getAttributeByName(reader, XmlConstants.Attributes.type);\n\t\t\t\t\tapTaintSubFields = getAttributeByName(reader, XmlConstants.Attributes.taintSubFields)\n\t\t\t\t\t\t\t.equals(XmlConstants.Values.TRUE);\n\n\t\t\t\t\tapFields.clear();\n\t\t\t\t\tapTypes.clear();\n\t\t\t\t} else if (reader.getLocalName().equals(XmlConstants.Tags.fields) && reader.isStartElement()\n\t\t\t\t\t\t&& stateStack.peek() == State.accessPath) {\n\t\t\t\t\tstateStack.push(State.fields);\n\t\t\t\t} else if (reader.getLocalName().equals(XmlConstants.Tags.field) && reader.isStartElement()\n\t\t\t\t\t\t&& stateStack.peek() == State.fields) {\n\t\t\t\t\tstateStack.push(State.field);\n\n\t\t\t\t\tString value = getAttributeByName(reader, XmlConstants.Attributes.value);\n\t\t\t\t\tString type = getAttributeByName(reader, XmlConstants.Attributes.type);\n\t\t\t\t\tif (value != null && !value.isEmpty() && type != null && !type.isEmpty()) {\n\t\t\t\t\t\tapFields.add(value);\n\t\t\t\t\t\tapTypes.add(value);\n\t\t\t\t\t}\n\t\t\t\t} else if (reader.getLocalName().equals(XmlConstants.Tags.sources) && reader.isStartElement()\n\t\t\t\t\t\t&& stateStack.peek() == State.result) {\n\t\t\t\t\tstateStack.push(State.sources);\n\t\t\t\t} else if (reader.getLocalName().equals(XmlConstants.Tags.source) && reader.isStartElement()\n\t\t\t\t\t\t&& stateStack.peek() == State.sources) {\n\t\t\t\t\tstateStack.push(State.source);\n\n\t\t\t\t\tstatement = getAttributeByName(reader, XmlConstants.Attributes.statement);\n\t\t\t\t\tmethod = getAttributeByName(reader, XmlConstants.Attributes.method);\n\t\t\t\t} else if (reader.getLocalName().equals(XmlConstants.Tags.taintPath) && reader.isStartElement()\n\t\t\t\t\t\t&& stateStack.peek() == State.source) {\n\t\t\t\t\tstateStack.push(State.taintPath);\n\n\t\t\t\t\tpathElements.clear();\n\t\t\t\t} else if (reader.getLocalName().equals(XmlConstants.Tags.pathElement) && reader.isStartElement()\n\t\t\t\t\t\t&& stateStack.peek() == State.source) {\n\t\t\t\t\tstateStack.push(State.taintPath);\n\n\t\t\t\t\tstatement = getAttributeByName(reader, XmlConstants.Attributes.statement);\n\t\t\t\t\tmethod = getAttributeByName(reader, XmlConstants.Attributes.method);\n\t\t\t\t} else if (reader.getLocalName().equals(XmlConstants.Tags.performanceData) && reader.isStartElement()\n\t\t\t\t\t\t&& stateStack.peek() == State.dataFlowResults) {\n\t\t\t\t\tstateStack.push(State.performanceData);\n\t\t\t\t} else if (reader.getLocalName().equals(XmlConstants.Tags.performanceEntry) && reader.isStartElement()\n\t\t\t\t\t\t&& stateStack.peek() == State.performanceData) {\n\t\t\t\t\tstateStack.push(State.performanceEntry);\n\n\t\t\t\t\tif (perfData == null)\n\t\t\t\t\t\tperfData = results.getOrCreatePerformanceData();\n\n\t\t\t\t\tString perfName = getAttributeByName(reader, XmlConstants.Attributes.name);\n\t\t\t\t\tString perfValue = getAttributeByName(reader, XmlConstants.Attributes.value);\n\n\t\t\t\t\tswitch (perfName) {\n\t\t\t\t\tcase XmlConstants.Values.PERF_CALLGRAPH_SECONDS:\n\t\t\t\t\t\tperfData.setCallgraphConstructionSeconds(Integer.parseInt(perfValue));\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase XmlConstants.Values.PERF_PATH_RECONSTRUCTION_SECONDS:\n\t\t\t\t\t\tperfData.setPathReconstructionSeconds(Integer.parseInt(perfValue));\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase XmlConstants.Values.PERF_TAINT_PROPAGATION_SECONDS:\n\t\t\t\t\t\tperfData.setTaintPropagationSeconds(Integer.parseInt(perfValue));\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase XmlConstants.Values.PERF_TOTAL_RUNTIME_SECONDS:\n\t\t\t\t\t\tperfData.setTotalRuntimeSeconds(Integer.parseInt(perfValue));\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase XmlConstants.Values.PERF_MAX_MEMORY_CONSUMPTION:\n\t\t\t\t\t\tperfData.setMaxMemoryConsumption(Integer.parseInt(perfValue));\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase XmlConstants.Values.PERF_SOURCE_COUNT:\n\t\t\t\t\t\tperfData.setSourceCount(Integer.parseInt(perfValue));\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase XmlConstants.Values.PERF_SINK_COUNT:\n\t\t\t\t\t\tperfData.setSinkCount(Integer.parseInt(perfValue));\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t} else if (reader.isEndElement()) {\n\t\t\t\t\tstateStack.pop();\n\n\t\t\t\t\tif (reader.getLocalName().equals(XmlConstants.Tags.accessPath))\n\t\t\t\t\t\tap = new SerializedAccessPath(apValue, apValueType, apTaintSubFields,\n\t\t\t\t\t\t\t\tapFields.toArray(new String[apFields.size()]),\n\t\t\t\t\t\t\t\tapTypes.toArray(new String[apTypes.size()]));\n\t\t\t\t\telse if (reader.getLocalName().equals(XmlConstants.Tags.sink))\n\t\t\t\t\t\tsink = new SerializedSinkInfo(ap, statement, method);\n\t\t\t\t\telse if (reader.getLocalName().equals(XmlConstants.Tags.source))\n\t\t\t\t\t\tsource = new SerializedSourceInfo(ap, statement, method, pathElements);\n\t\t\t\t\telse if (reader.getLocalName().equals(XmlConstants.Tags.result))\n\t\t\t\t\t\tresults.addResult(source, sink);\n\t\t\t\t\telse if (reader.getLocalName().equals(XmlConstants.Tags.pathElement))\n\t\t\t\t\t\tpathElements.add(new SerializedPathElement(ap, statement, method));\n\t\t\t\t}\n// bug_end\n \t\t\t}\n \n// bug_start\n\t\t\treturn results;\n\t\t} finally {\n\t\t\tif (reader != null)\n\t\t\t\treader.close();\n// bug_end\n \t\t}\n// bug_start\n\t}\n// bug_end\n \n", "target": "// fix_start\n@Override\n\t\tpublic void setPropertyValue(String propertyName, Object value) throws BeansException {\n// fix_end\n// fix_start\n\t\t\tif (!isWritableProperty(propertyName)) {\n\t\t\t\tthrow new NotWritablePropertyException(type, propertyName);\n// fix_end\n// fix_start\n\t\t\tStandardEvaluationContext context = new StandardEvaluationContext();\n\t\t\tcontext.addPropertyAccessor(new PropertyTraversingMapAccessor(type, conversionService));\n\t\t\tcontext.setTypeConverter(new StandardTypeConverter(conversionService));\n\t\t\tcontext.setTypeLocator(REJECTING_LOCATOR);\n\t\t\tcontext.setRootObject(map);\n\n\t\t\tExpression expression = PARSER.parseExpression(propertyName);\n\n\t\t\tPropertyPath leafProperty = getPropertyPath(propertyName).getLeafProperty();\n\t\t\tTypeInformation<?> owningType = leafProperty.getOwningType();\n\t\t\tTypeInformation<?> propertyType = owningType.getProperty(leafProperty.getSegment());\n\n\t\t\tpropertyType = propertyName.endsWith(\"]\") ? propertyType.getActualType() : propertyType;\n\n\t\t\tif (conversionRequired(value, propertyType.getType())) {\n\n\t\t\t\tPropertyDescriptor descriptor = BeanUtils.getPropertyDescriptor(owningType.getType(),\n\t\t\t\t\t\tleafProperty.getSegment());\n\t\t\t\tMethodParameter methodParameter = new MethodParameter(descriptor.getReadMethod(), -1);\n\t\t\t\tTypeDescriptor typeDescriptor = TypeDescriptor.nested(methodParameter, 0);\n\n\t\t\t\tvalue = conversionService.convert(value, TypeDescriptor.forObject(value), typeDescriptor);\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\texpression.setValue(context, value);\n\t\t\t} catch (SpelEvaluationException o_O) {\n\t\t\t\tthrow new NotWritablePropertyException(type, propertyName, \"Could not write property!\", o_O);\n\t\t\t}\n// fix_end\n// fix_start\n// fix_end\n", "cwe": "CWE-611", "cwe_name": "Improper Restriction of XML External Entity Reference ('XXE')", "idx": 69020}
{"source": "// bug_start\npublic UploadFileResponse getCloudUrl(String contextPath, String uri, String finalFilePath, HttpServletRequest request) {\n        UploadFileResponse uploadFileResponse = new UploadFileResponse();\n        Map<String, String[]> map = new HashMap<>();\n        map.put(\"fileInfo\", new String[]{finalFilePath + \",\" + uri});\n        map.put(\"name\", new String[]{\"uploadService\"});\n        String url;\n        try {\n            List<Map> urls = HttpUtil.getInstance().sendGetRequest(Constants.pluginServer + \"/service\", map\n                    , new HttpJsonArrayHandle<Map>(), PluginHelper.genHeaderMapByRequest(request)).getT();\n            if (urls != null && !urls.isEmpty()) {\n                url = (String) urls.get(0).get(\"url\");\n                if (!url.startsWith(\"https://\") && !url.startsWith(\"http://\")) {\n                    String tUrl = url;\n                    if (!url.startsWith(\"/\")) {\n                        tUrl = \"/\" + url;\n                    }\n                    url = contextPath + tUrl;\n                }\n            } else {\n                url = contextPath + uri;\n            }\n        } catch (Exception e) {\n            url = contextPath + uri;\n            LOGGER.error(e);\n        }\n        uploadFileResponse.setUrl(url);\n        return uploadFileResponse;\n    }\n// bug_end\n \n", "target": "// fix_start\n@Override\n\t\tpublic void setPropertyValue(String propertyName, Object value) throws BeansException {\n// fix_end\n// fix_start\n\t\t\tif (!isWritableProperty(propertyName)) {\n\t\t\t\tthrow new NotWritablePropertyException(type, propertyName);\n\t\t\t}\n\n\t\t\tPropertyPath leafProperty = getPropertyPath(propertyName).getLeafProperty();\n\t\t\tTypeInformation<?> owningType = leafProperty.getOwningType();\n\t\t\tTypeInformation<?> propertyType = owningType.getProperty(leafProperty.getSegment());\n\n\t\t\tpropertyType = propertyName.endsWith(\"]\") ? propertyType.getActualType() : propertyType;\n\n\t\t\tif (conversionRequired(value, propertyType.getType())) {\n\n\t\t\t\tPropertyDescriptor descriptor = BeanUtils.getPropertyDescriptor(owningType.getType(),\n\t\t\t\t\t\tleafProperty.getSegment());\n\t\t\t\tMethodParameter methodParameter = new MethodParameter(descriptor.getReadMethod(), -1);\n\t\t\t\tTypeDescriptor typeDescriptor = TypeDescriptor.nested(methodParameter, 0);\n\n\t\t\t\tvalue = conversionService.convert(value, TypeDescriptor.forObject(value), typeDescriptor);\n\t\t\t}\n\n\t\t\tEvaluationContext context = SimpleEvaluationContext\n\n\t\t\t\t\t.forPropertyAccessors(new PropertyTraversingMapAccessor(type, conversionService))\n\t\t\t\t\t.withConversionService(conversionService)\n\t\t\t\t\t.withRootObject(map)\n\t\t\t\t\t.build();\n\n\t\t\tExpression expression = PARSER.parseExpression(propertyName);\n\n\t\t\ttry {\n\t\t\t\texpression.setValue(context, value);\n\t\t\t} catch (SpelEvaluationException o_O) {\n\t\t\t\tthrow new NotWritablePropertyException(type, propertyName, \"Could not write property!\", o_O);\n\t\t\t}\n\t\t}\n\n// fix_end\n", "cwe": "CWE-20", "cwe_name": "Improper Input Validation", "idx": 11868}
{"source": "// bug_start\n@Restricted(NoExternalUse.class)\n        public FormValidation doCheckItemPattern(@QueryParameter String itemPattern) {\n            try {\n// bug_end\n \n// bug_start\n                Pattern.compile(itemPattern);\n                return FormValidation.ok();\n            } catch (PatternSyntaxException ex) {\n\n                return FormValidation.errorWithMarkup(\"Not a regular expression: <pre>\" + ex.getMessage() + \"</pre>\");\n            }\n        }\n\n// bug_end\n", "target": "// fix_start\npublic UploadFileResponse getCloudUrl(String contextPath, String uri, String finalFilePath, HttpServletRequest request) {\n        UploadFileResponse uploadFileResponse = new UploadFileResponse();\n        Map<String, String[]> map = new HashMap<>();\n        map.put(\"fileInfo\", new String[]{finalFilePath + \",\" + uri});\n        map.put(\"name\", new String[]{\"uploadService\"});\n        String url;\n        try {\n            List<Map> urls = HttpUtil.getInstance().sendGetRequest(Constants.pluginServer + \"/service\", map\n                    , new HttpJsonArrayHandle<Map>(), PluginHelper.genHeaderMapByRequest(request, AdminTokenThreadLocal.getUser())).getT();\n            if (urls != null && !urls.isEmpty()) {\n                url = (String) urls.get(0).get(\"url\");\n                if (!url.startsWith(\"https://\") && !url.startsWith(\"http://\")) {\n                    String tUrl = url;\n                    if (!url.startsWith(\"/\")) {\n                        tUrl = \"/\" + url;\n                    }\n                    url = contextPath + tUrl;\n                }\n            } else {\n                url = contextPath + uri;\n            }\n        } catch (Exception e) {\n            url = contextPath + uri;\n            LOGGER.error(e);\n        }\n        uploadFileResponse.setUrl(url);\n        return uploadFileResponse;\n    }\n// fix_end\n", "cwe": "CWE-863", "cwe_name": "Incorrect Authorization", "idx": 89512}
{"source": "// bug_start\npublic void testBasics() throws Exception {\n        jenkins.setSecurityRealm(createDummySecurityRealm());\n        User u = User.get(\"foo\");\n        final ApiTokenProperty t = u.getProperty(ApiTokenProperty.class);\n        final String token = t.getApiToken();\n// bug_end\n \n// bug_start\n        ACL.impersonate(u.impersonate(), new Runnable() {\n            @Override\n            public void run() {\n                assertEquals(\"User is unable to get its own token\", token, t.getApiToken());\n// bug_end\n             }\n// bug_start\n        });\n// bug_end\n \n// bug_start\n        WebClient wc = createClientForUser(\"foo\");\n        assertEquals(u,wc.executeOnServer(new Callable<User>() {\n            public User call() throws Exception {\n                return User.current();\n            }\n        }));\n\n        HtmlPage config = wc.goTo(u.getUrl() + \"/configure\");\n        HtmlForm form = config.getFormByName(\"config\");\n        assertEquals(token, form.getInputByName(\"_.apiToken\").getValueAttribute());\n\n        submit(form);\n        assertSame(t, u.getProperty(ApiTokenProperty.class));\n    }\n\n// bug_end\n", "target": "// fix_start\n@Restricted(NoExternalUse.class)\n        public FormValidation doCheckItemPattern(@QueryParameter String itemPattern) {\n            try {\n// fix_end\n// fix_start\n                Pattern.compile(itemPattern);\n                return FormValidation.ok();\n            } catch (PatternSyntaxException ex) {\n\n                return FormValidation.error(\"Not a regular expression: \" + ex.getMessage());\n// fix_end\n// fix_start\n        }\n// fix_end\n", "cwe": "CWE-79", "cwe_name": "Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')", "idx": 80872}
{"source": "// bug_start\npublic void testBasics() throws Exception {\n        jenkins.setSecurityRealm(createDummySecurityRealm());\n        User u = User.get(\"foo\");\n        ApiTokenProperty t = u.getProperty(ApiTokenProperty.class);\n        final String token = t.getApiToken();\n// bug_end\n \n// bug_start\n        HtmlPage config = createWebClient().goTo(u.getUrl() + \"/configure\");\n        HtmlForm form = config.getFormByName(\"config\");\n        assertEquals(token, form.getInputByName(\"_.apiToken\").getValueAttribute());\n// bug_end\n \n// bug_start\n        submit(form);\n        assertSame(t, u.getProperty(ApiTokenProperty.class));\n// bug_end\n \n// bug_start\n        WebClient wc = createWebClient();\n        wc.setCredentialsProvider(new CredentialsProvider() {\n            public Credentials getCredentials(AuthScheme scheme, String host, int port, boolean proxy) throws CredentialsNotAvailableException {\n                return new UsernamePasswordCredentials(\"foo\", token);\n            }\n        });\n        wc.setWebConnection(new HttpWebConnection(wc) {\n            @Override\n            protected HttpClient getHttpClient() {\n                HttpClient c = super.getHttpClient();\n                c.getParams().setAuthenticationPreemptive(true);\n                c.getState().setCredentials(new AuthScope(\"localhost\", localPort, AuthScope.ANY_REALM), new UsernamePasswordCredentials(\"foo\", token));\n                return c;\n            }\n        });\n// bug_end\n \n// bug_start\n        assertEquals(u,wc.executeOnServer(new Callable<User>() {\n            public User call() throws Exception {\n                return User.current();\n            }\n        }));\n// bug_end\n     }\n \n", "target": "// fix_start\npublic void recycle() {\n        bytesRead=0;\n// fix_end\n// fix_start\n        contentLength = -1;\n        contentTypeMB = null;\n        charset = null;\n        characterEncoding = null;\n        expectation = false;\n        headers.recycle();\n        trailerFields.clear();\n        serverNameMB.recycle();\n        serverPort=-1;\n        localAddrMB.recycle();\n        localNameMB.recycle();\n        localPort = -1;\n        peerAddrMB.recycle();\n        remoteAddrMB.recycle();\n        remoteHostMB.recycle();\n        remotePort = -1;\n        available = 0;\n        sendfile = true;\n// fix_end\n// fix_start\n        serverCookies.recycle();\n        parameters.recycle();\n        pathParameters.clear();\n// fix_end\n// fix_start\n        uriMB.recycle();\n        decodedUriMB.recycle();\n        queryMB.recycle();\n        methodMB.recycle();\n        protoMB.recycle();\n// fix_end\n// fix_start\n        schemeMB.recycle();\n\n        remoteUser.recycle();\n        remoteUserNeedsAuthorization = false;\n        authType.recycle();\n        attributes.clear();\n\n        listener = null;\n        synchronized (nonBlockingStateLock) {\n            fireListener = false;\n            registeredForRead = false;\n        }\n        allDataReadEventSent.set(false);\n\n        startTimeNanos = -1;\n// fix_end\n", "cwe": "CWE-264", "cwe_name": "Permissions, Privileges, and Access Controls", "idx": 35165}
{"source": "// bug_start\npublic String encodeCharacter( char[] immune, Character c )\n\t{\n\t\tString cStr = String.valueOf(c.charValue());\n\t\tbyte[] bytes;\n\t\tStringBuilder sb;\n// bug_end\n \n// bug_start\n        if ( immune != null && containsCharacter( c.charValue(), immune ) )\n            return cStr;\n// bug_end\n \n// bug_start\n\t\tif(UNENCODED_SET.contains(c))\n\t\t\treturn cStr;\n// bug_end\n \n// bug_start\n\t\tbytes = toUtf8Bytes(cStr);\n\t\tsb = new StringBuilder(bytes.length * 3);\n\t\tfor(byte b : bytes)\n\t\t\tappendTwoUpperHex(sb.append('%'), b);\n\t\treturn sb.toString();\n\t}\n// bug_end\n \n", "target": "// fix_start\npublic void recycle() {\n        bytesRead=0;\n// fix_end\n// fix_start\n        contentLength = -1;\n        contentTypeMB = null;\n        charset = null;\n        characterEncoding = null;\n        expectation = false;\n        headers.recycle();\n        trailerFields.clear();\n        serverNameMB.recycle();\n        serverPort=-1;\n        localAddrMB.recycle();\n        localNameMB.recycle();\n        localPort = -1;\n        peerAddrMB.recycle();\n        remoteAddrMB.recycle();\n        remoteHostMB.recycle();\n        remotePort = -1;\n        available = 0;\n        sendfile = true;\n// fix_end\n// fix_start\n        serverCookies.recycle();\n        parameters.recycle();\n        pathParameters.clear();\n// fix_end\n// fix_start\n        uriMB.recycle();\n        decodedUriMB.recycle();\n        queryMB.recycle();\n        methodMB.recycle();\n        protoMB.recycle();\n// fix_end\n// fix_start\n        schemeMB.recycle();\n\n        remoteUser.recycle();\n        remoteUserNeedsAuthorization = false;\n        authType.recycle();\n        attributes.clear();\n\n        errorException = null;\n\n        listener = null;\n        synchronized (nonBlockingStateLock) {\n            fireListener = false;\n            registeredForRead = false;\n        }\n        allDataReadEventSent.set(false);\n\n        startTimeNanos = -1;\n    }\n\n// fix_end\n", "cwe": "CWE-755", "cwe_name": "Improper Handling of Exceptional Conditions", "idx": 74732}
{"source": "// bug_start\npublic String encodeCharacter( char[] immune, Character c )\n\t{\n\t\tString cStr = String.valueOf(c.charValue());\n\t\tbyte[] bytes;\n\t\tStringBuilder sb;\n// bug_end\n \n// bug_start\n\t\tif(UNENCODED_SET.contains(c))\n\t\t\treturn cStr;\n\n\t\tbytes = toUtf8Bytes(cStr);\n\t\tsb = new StringBuilder(bytes.length * 3);\n\t\tfor(byte b : bytes)\n\t\t\tappendTwoUpperHex(sb.append('%'), b);\n\t\treturn sb.toString();\n\t}\n\n// bug_end\n", "target": "// fix_start\npublic @CheckForNull User getUser(String name) {\n        return User.get(name,hasPermission(ADMINISTER));\n    }\n// fix_end\n", "cwe": "CWE-310", "cwe_name": "Cryptographic Issues", "idx": 41693}
{"source": "// bug_start\npublic static String applySorting(String query, Sort sort, String alias) {\n// bug_end\n \n// bug_start\n\t\tAssert.hasText(query);\n\n\t\tif (null == sort || !sort.iterator().hasNext()) {\n\t\t\treturn query;\n\t\t}\n\n\t\tStringBuilder builder = new StringBuilder(query);\n\n\t\tif (!ORDER_BY.matcher(query).matches()) {\n\t\t\tbuilder.append(\" order by \");\n\t\t} else {\n\t\t\tbuilder.append(\", \");\n\t\t}\n\n\t\tSet<String> aliases = getOuterJoinAliases(query);\n\n\t\tfor (Order order : sort) {\n\t\t\tbuilder.append(getOrderClause(aliases, alias, order)).append(\", \");\n\t\t}\n\n\t\tbuilder.delete(builder.length() - 2, builder.length());\n\n\t\treturn builder.toString();\n\t}\n\n// bug_end\n", "target": "// fix_start\npublic @CheckForNull User getUser(String name) {\n        return User.get(name, User.ALLOW_USER_CREATION_VIA_URL && hasPermission(ADMINISTER));\n    }\n// fix_end\n", "cwe": "CWE-352", "cwe_name": "Cross-Site Request Forgery (CSRF)", "idx": 44645}
{"source": "// bug_start\n@Parameterized.Parameters(name = \"{index}: user[{3}], pwd[{4}]\")\n    public static Collection<Object[]> parameters() {\n        List<Object[]> parameterSets = new ArrayList<>();\n        for (String roleSearch : new String[] { ROLE_SEARCH_A, ROLE_SEARCH_B }) {\n            addUsers(USER_PATTERN, null, null, roleSearch, parameterSets);\n            addUsers(null, USER_SEARCH, USER_BASE, roleSearch, parameterSets);\n        }\n        return parameterSets;\n    }\n// bug_end\n \n", "target": "// fix_start\npublic static String applySorting(String query, Sort sort, String alias) {\n// fix_end\n// fix_start\n\t\tAssert.hasText(query);\n\n\t\tif (null == sort || !sort.iterator().hasNext()) {\n\t\t\treturn query;\n\t\t}\n\n\t\tStringBuilder builder = new StringBuilder(query);\n\n\t\tif (!ORDER_BY.matcher(query).matches()) {\n\t\t\tbuilder.append(\" order by \");\n\t\t} else {\n\t\t\tbuilder.append(\", \");\n\t\t}\n\n\t\tSet<String> aliases = getOuterJoinAliases(query);\n\t\tSet<String> functionAliases = getFunctionAliases(query);\n\n\t\tfor (Order order : sort) {\n\t\t\tbuilder.append(getOrderClause(aliases, functionAliases, alias, order)).append(\", \");\n\t\t}\n\n\t\tbuilder.delete(builder.length() - 2, builder.length());\n\n\t\treturn builder.toString();\n\t}\n\n// fix_end\n", "cwe": "CWE-89", "cwe_name": "Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection')", "idx": 92662}
{"source": "// bug_start\n@Parameterized.Parameters(name = \"{index}: user[{3}], pwd[{4}]\")\n    public static Collection<Object[]> parameters() {\n        List<Object[]> parameterSets = new ArrayList<>();\n        addUsers(USER_PATTERN, null, null, parameterSets);\n        addUsers(null, USER_SEARCH, USER_BASE, parameterSets);\n        return parameterSets;\n// bug_end\n     }\n \n", "target": "// fix_start\nprotected List<String> getRoles(JNDIConnection connection, User user) throws NamingException {\n\n        if (user == null) {\n            return null;\n        }\n\n        String dn = user.getDN();\n        String username = user.getUserName();\n        String userRoleId = user.getUserRoleId();\n\n        if (dn == null || username == null) {\n            return null;\n        }\n\n        if (containerLog.isTraceEnabled()) {\n            containerLog.trace(\"  getRoles(\" + dn + \")\");\n        }\n\n        List<String> list = new ArrayList<>();\n        List<String> userRoles = user.getRoles();\n        if (userRoles != null) {\n            list.addAll(userRoles);\n        }\n        if (commonRole != null) {\n            list.add(commonRole);\n        }\n\n        if (containerLog.isTraceEnabled()) {\n            containerLog.trace(\"  Found \" + list.size() + \" user internal roles\");\n            containerLog.trace(\"  Found user internal roles \" + list.toString());\n        }\n\n        if ((connection.roleFormat == null) || (roleName == null)) {\n            return list;\n        }\n\n        String filter = connection.roleFormat.format(new String[] { doFilterEscaping(dn), username, userRoleId });\n        SearchControls controls = new SearchControls();\n        if (roleSubtree) {\n            controls.setSearchScope(SearchControls.SUBTREE_SCOPE);\n        } else {\n            controls.setSearchScope(SearchControls.ONELEVEL_SCOPE);\n        }\n        controls.setReturningAttributes(new String[] {roleName});\n\n        String base = null;\n        if (connection.roleBaseFormat != null) {\n            NameParser np = connection.context.getNameParser(\"\");\n            Name name = np.parse(dn);\n            String nameParts[] = new String[name.size()];\n            for (int i = 0; i < name.size(); i++) {\n                nameParts[i] = name.get(i);\n            }\n            base = connection.roleBaseFormat.format(nameParts);\n        } else {\n            base = \"\";\n        }\n\n        NamingEnumeration<SearchResult> results = searchAsUser(connection.context, user, base, filter, controls,\n                isRoleSearchAsUser());\n\n        if (results == null) {\n            return list;\n        }\n\n        Map<String, String> groupMap = new HashMap<>();\n        try {\n            while (results.hasMore()) {\n                SearchResult result = results.next();\n                Attributes attrs = result.getAttributes();\n                if (attrs == null) {\n                    continue;\n                }\n                String dname = getDistinguishedName(connection.context, roleBase, result);\n                String name = getAttributeValue(roleName, attrs);\n                if (name != null && dname != null) {\n                    groupMap.put(dname, name);\n                }\n            }\n        } catch (PartialResultException ex) {\n            if (!adCompat) {\n                throw ex;\n            }\n        } finally {\n            results.close();\n        }\n\n        if (containerLog.isTraceEnabled()) {\n            Set<Entry<String, String>> entries = groupMap.entrySet();\n            containerLog.trace(\"  Found \" + entries.size() + \" direct roles\");\n            for (Entry<String, String> entry : entries) {\n                containerLog.trace(  \"  Found direct role \" + entry.getKey() + \" -> \" + entry.getValue());\n            }\n        }\n\n        if (getRoleNested()) {\n\n\n            Map<String, String> newGroups = new HashMap<>(groupMap);\n            while (!newGroups.isEmpty()) {\n                Map<String, String> newThisRound = new HashMap<>();\n\n                for (Entry<String, String> group : newGroups.entrySet()) {\n                    filter = connection.roleFormat.format(new String[] { doFilterEscaping(group.getKey()),\n                            group.getValue(), group.getValue() });\n\n                    if (containerLog.isTraceEnabled()) {\n                        containerLog.trace(\"Perform a nested group search with base \"+ roleBase +\n                                \" and filter \" + filter);\n                    }\n\n                    results = searchAsUser(connection.context, user, roleBase, filter, controls, isRoleSearchAsUser());\n\n                    try {\n                        while (results.hasMore()) {\n                            SearchResult result = results.next();\n                            Attributes attrs = result.getAttributes();\n                            if (attrs == null) {\n                                continue;\n                            }\n                            String dname = getDistinguishedName(connection.context, roleBase, result);\n                            String name = getAttributeValue(roleName, attrs);\n                            if (name != null && dname != null && !groupMap.keySet().contains(dname)) {\n                                groupMap.put(dname, name);\n                                newThisRound.put(dname, name);\n\n                                if (containerLog.isTraceEnabled()) {\n                                    containerLog.trace(\"  Found nested role \" + dname + \" -> \" + name);\n                                }\n                            }\n                        }\n                    } catch (PartialResultException ex) {\n                        if (!adCompat) {\n                            throw ex;\n                        }\n                    } finally {\n                        results.close();\n                    }\n                }\n\n                newGroups = newThisRound;\n            }\n        }\n\n        list.addAll(groupMap.values());\n        return list;\n// fix_end\n", "cwe": "CWE-116", "cwe_name": "Improper Encoding or Escaping of Output", "idx": 1111}
{"source": " @Override\n   public void launchContainer(ContainerRuntimeContext ctx)\n       throws ContainerExecutionException {\n     Container container = ctx.getContainer();\n     Map<String, String> environment = container.getLaunchContext()\n         .getEnvironment();\n     String imageName = environment.get(ENV_DOCKER_CONTAINER_IMAGE);\n \n// bug_start\n    if (imageName == null) {\n      throw new ContainerExecutionException(ENV_DOCKER_CONTAINER_IMAGE\n          + \" not set!\");\n    }\n// bug_end\n \n     String containerIdStr = container.getContainerId().toString();\n     String runAsUser = ctx.getExecutionAttribute(RUN_AS_USER);\n     Path containerWorkDir = ctx.getExecutionAttribute(CONTAINER_WORK_DIR);\n     @SuppressWarnings(\"unchecked\")\n     List<String> localDirs = ctx.getExecutionAttribute(LOCAL_DIRS);\n     @SuppressWarnings(\"unchecked\")\n     List<String> logDirs = ctx.getExecutionAttribute(LOG_DIRS);\n     Set<String> capabilities = new HashSet<>(Arrays.asList(conf.getStrings(\n         YarnConfiguration.NM_DOCKER_CONTAINER_CAPABILITIES,\n         YarnConfiguration.DEFAULT_NM_DOCKER_CONTAINER_CAPABILITIES)));\n \n     @SuppressWarnings(\"unchecked\")\n     DockerRunCommand runCommand = new DockerRunCommand(containerIdStr,\n         runAsUser, imageName)\n         .detachOnRun()\n         .setContainerWorkDir(containerWorkDir.toString())\n         .setNetworkType(\"host\")\n         .setCapabilities(capabilities)\n         .addMountLocation(\"/etc/passwd\", \"/etc/password:ro\");\n     List<String> allDirs = new ArrayList<>(localDirs);\n \n     allDirs.add(containerWorkDir.toString());\n     allDirs.addAll(logDirs);\n     for (String dir: allDirs) {\n       runCommand.addMountLocation(dir, dir);\n     }\n \n     if (allowPrivilegedContainerExecution(container)) {\n       runCommand.setPrivileged();\n     }\n \n     String resourcesOpts = ctx.getExecutionAttribute(RESOURCES_OPTIONS);\n \n \n    Path nmPrivateContainerScriptPath = ctx.getExecutionAttribute(\n         NM_PRIVATE_CONTAINER_SCRIPT_PATH);\n \n     String disableOverride = environment.get(\n         ENV_DOCKER_CONTAINER_RUN_OVERRIDE_DISABLE);\n \n     if (disableOverride != null && disableOverride.equals(\"true\")) {\n       if (LOG.isInfoEnabled()) {\n         LOG.info(\"command override disabled\");\n       }\n     } else {\n       List<String> overrideCommands = new ArrayList<>();\n       Path launchDst =\n           new Path(containerWorkDir, ContainerLaunch.CONTAINER_SCRIPT);\n \n       overrideCommands.add(\"bash\");\n       overrideCommands.add(launchDst.toUri().getPath());\n       runCommand.setOverrideCommandWithArgs(overrideCommands);\n     }\n \n     String commandFile = dockerClient.writeCommandToTempFile(runCommand,\n         containerIdStr);\n     PrivilegedOperation launchOp = new PrivilegedOperation(\n         PrivilegedOperation.OperationType.LAUNCH_DOCKER_CONTAINER);\n \n     launchOp.appendArgs(runAsUser, ctx.getExecutionAttribute(USER),\n         Integer.toString(PrivilegedOperation\n             .RunAsUserCommand.LAUNCH_DOCKER_CONTAINER.getValue()),\n         ctx.getExecutionAttribute(APPID),\n         containerIdStr, containerWorkDir.toString(),\n         nmPrivateContainerScriptPath.toUri().getPath(),\n         ctx.getExecutionAttribute(NM_PRIVATE_TOKENS_PATH).toUri().getPath(),\n         ctx.getExecutionAttribute(PID_FILE_PATH).toString(),\n         StringUtils.join(PrivilegedOperation.LINUX_FILE_PATH_SEPARATOR,\n             localDirs),\n         StringUtils.join(PrivilegedOperation.LINUX_FILE_PATH_SEPARATOR,\n             logDirs),\n         commandFile,\n         resourcesOpts);\n \n     String tcCommandFile = ctx.getExecutionAttribute(TC_COMMAND_FILE);\n \n     if (tcCommandFile != null) {\n       launchOp.appendArgs(tcCommandFile);\n     }\n \n     try {\n       privilegedOperationExecutor.executePrivilegedOperation(null,\n           launchOp, null, container.getLaunchContext().getEnvironment(),\n           false, false);\n     } catch (PrivilegedOperationException e) {\n       LOG.warn(\"Launch container failed. Exception: \", e);\n \n       throw new ContainerExecutionException(\"Launch container failed\", e\n           .getExitCode(), e.getOutput(), e.getErrorOutput());\n     }\n   }\n \n", "target": "// fix_start\n    validateImageName(imageName);\n// fix_end\n", "cwe": "CWE-20", "cwe_name": "Improper Input Validation", "idx": 7755}
{"source": " @Override\n     protected void initializeStreams() throws IOException {\n         NIOOutputStream outputStream = null;\n         try {\n             channel = socket.getChannel();\n             channel.configureBlocking(false);\n \n             if (sslContext == null) {\n                 sslContext = SSLContext.getDefault();\n             }\n \n             String remoteHost = null;\n             int remotePort = -1;\n \n             try {\n                 URI remoteAddress = new URI(this.getRemoteAddress());\n                 remoteHost = remoteAddress.getHost();\n                 remotePort = remoteAddress.getPort();\n             } catch (Exception e) {\n             }\n \n             if (remoteHost != null && remotePort != -1) {\n                 sslEngine = sslContext.createSSLEngine(remoteHost, remotePort);\n             } else {\n                 sslEngine = sslContext.createSSLEngine();\n// bug_start\n// bug_end\n             }\n \n             sslEngine.setUseClientMode(false);\n             if (enabledCipherSuites != null) {\n                 sslEngine.setEnabledCipherSuites(enabledCipherSuites);\n             }\n \n             if (enabledProtocols != null) {\n                 sslEngine.setEnabledProtocols(enabledProtocols);\n             }\n \n             if (wantClientAuth) {\n                 sslEngine.setWantClientAuth(wantClientAuth);\n             }\n \n             if (needClientAuth) {\n                 sslEngine.setNeedClientAuth(needClientAuth);\n             }\n \n             sslSession = sslEngine.getSession();\n \n             inputBuffer = ByteBuffer.allocate(sslSession.getPacketBufferSize());\n             inputBuffer.clear();\n \n             outputStream = new NIOOutputStream(channel);\n             outputStream.setEngine(sslEngine);\n             this.dataOut = new DataOutputStream(outputStream);\n             this.buffOut = outputStream;\n             sslEngine.beginHandshake();\n             handshakeStatus = sslEngine.getHandshakeStatus();\n             doHandshake();\n \n         } catch (Exception e) {\n             try {\n                 if(outputStream != null) {\n                     outputStream.close();\n                 }\n                 super.closeStreams();\n             } catch (Exception ex) {}\n             throw new IOException(e);\n         }\n     }\n \n", "target": "// fix_start\n            }\n\n            if (verifyHostName) {\n                SSLParameters sslParams = new SSLParameters();\n                sslParams.setEndpointIdentificationAlgorithm(\"HTTPS\");\n                sslEngine.setSSLParameters(sslParams);\n// fix_end\n", "cwe": "CWE-295", "cwe_name": "Improper Certificate Validation", "idx": 39782}
{"source": " @Override\n         public int fill(ByteBuffer buffer) throws IOException\n         {\n             try\n             {\n                 try (AutoLock l = _lock.lock())\n                 {\n                     if (LOG.isDebugEnabled())\n                         LOG.debug(\">fill {}\", SslConnection.this);\n \n                     int filled = -2;\n                     try\n                     {\n                         if (_fillState != FillState.IDLE)\n                             return filled = 0;\n \n                         if (BufferUtil.hasContent(_decryptedInput))\n                             return filled = BufferUtil.append(buffer, _decryptedInput);\n \n                         while (true)\n                         {\n                             HandshakeStatus status = _sslEngine.getHandshakeStatus();\n                             if (LOG.isDebugEnabled())\n                                 LOG.debug(\"fill {}\", status);\n                             switch (status)\n                             {\n                                 case NEED_UNWRAP:\n                                 case NOT_HANDSHAKING:\n                                     break;\n \n                                 case NEED_TASK:\n                                     _sslEngine.getDelegatedTask().run();\n                                     continue;\n \n                                 case NEED_WRAP:\n                                     if (_flushState == FlushState.IDLE && flush(BufferUtil.EMPTY_BUFFER))\n                                     {\n                                         Throwable failure = _failure;\n                                         if (failure != null)\n                                             rethrow(failure);\n                                         if (_sslEngine.isInboundDone())\n                                             return filled = -1;\n                                         continue;\n                                     }\n                                     return filled = 0;\n \n                                 default:\n                                     throw new IllegalStateException(\"Unexpected HandshakeStatus \" + status);\n                             }\n \n                             acquireEncryptedInput();\n \n                             ByteBuffer appIn;\n                             int appBufferSize = getApplicationBufferSize();\n                             if (_decryptedInput == null)\n                             {\n                                 if (BufferUtil.space(buffer) > appBufferSize)\n                                     appIn = buffer;\n                                 else\n                                     appIn = _decryptedInput = _bufferPool.acquire(appBufferSize, _decryptedDirectBuffers);\n                             }\n                             else\n                             {\n                                 appIn = _decryptedInput;\n                                 BufferUtil.compact(_encryptedInput);\n                             }\n \n                             int netFilled = networkFill(_encryptedInput);\n                             if (LOG.isDebugEnabled())\n                                 LOG.debug(\"net filled={}\", netFilled);\n \n                             if (netFilled < 0 && isHandshakeInitial() && BufferUtil.isEmpty(_encryptedInput))\n                                 closeInbound();\n \n                             if (netFilled > 0 && !isHandshakeComplete() && isOutboundDone())\n                                 throw new SSLHandshakeException(\"Closed during handshake\");\n \n                             if (_handshake.compareAndSet(HandshakeState.INITIAL, HandshakeState.HANDSHAKE))\n                             {\n                                 if (LOG.isDebugEnabled())\n                                     LOG.debug(\"fill starting handshake {}\", SslConnection.this);\n                             }\n \n                             int pos = BufferUtil.flipToFill(appIn);\n                             SSLEngineResult unwrapResult;\n                             try\n                             {\n                                 _underflown = false;\n                                 unwrapResult = SslConnection.this.unwrap(_sslEngine, _encryptedInput, appIn);\n                             }\n                             finally\n                             {\n                                 BufferUtil.flipToFlush(appIn, pos);\n                             }\n                             if (LOG.isDebugEnabled())\n                                 LOG.debug(\"unwrap net_filled={} {} encryptedBuffer={} unwrapBuffer={} appBuffer={}\",\n                                     netFilled,\n                                     StringUtil.replace(unwrapResult.toString(), '\\n', ' '),\n                                     BufferUtil.toSummaryString(_encryptedInput),\n                                     BufferUtil.toDetailString(appIn),\n                                     BufferUtil.toDetailString(buffer));\n \n                             SSLEngineResult.Status unwrap = unwrapResult.getStatus();\n \n                             if (unwrap == Status.OK && unwrapResult.bytesConsumed() == 0 && unwrapResult.bytesProduced() == 0)\n                                 unwrap = Status.BUFFER_UNDERFLOW;\n \n                             switch (unwrap)\n                             {\n                                 case CLOSED:\n                                     Throwable failure = _failure;\n                                     if (failure != null)\n                                         rethrow(failure);\n                                     return filled = -1;\n \n                                 case BUFFER_UNDERFLOW:\n                                     if (netFilled > 0)\n// bug_start\n                                        continue;\n// bug_end\n                                     _underflown = true;\n                                     if (netFilled < 0 && _sslEngine.getUseClientMode())\n                                     {\n                                         Throwable closeFailure = closeInbound();\n                                         if (_flushState == FlushState.WAIT_FOR_FILL)\n                                         {\n                                             Throwable handshakeFailure = new SSLHandshakeException(\"Abruptly closed by peer\");\n                                             if (closeFailure != null)\n// bug_start\n                                                handshakeFailure.initCause(closeFailure);\n// bug_end\n                                             throw handshakeFailure;\n                                         }\n                                         return filled = -1;\n                                     }\n                                     return filled = netFilled;\n \n                                 case BUFFER_OVERFLOW:\n                                     if (BufferUtil.isEmpty(_decryptedInput) && appBufferSize < getApplicationBufferSize())\n                                     {\n                                         releaseDecryptedInputBuffer();\n                                         continue;\n                                     }\n                                     throw new IllegalStateException(\"Unexpected unwrap result \" + unwrap);\n \n                                 case OK:\n                                     if (unwrapResult.getHandshakeStatus() == HandshakeStatus.FINISHED)\n                                         handshakeSucceeded();\n \n                                     if (isRenegotiating() && !allowRenegotiate())\n                                         return filled = -1;\n \n                                     if (unwrapResult.bytesProduced() > 0)\n                                     {\n                                         if (appIn == buffer)\n                                             return filled = unwrapResult.bytesProduced();\n                                         return filled = BufferUtil.append(buffer, _decryptedInput);\n                                     }\n \n                                     break;\n \n                                 default:\n                                     throw new IllegalStateException(\"Unexpected unwrap result \" + unwrap);\n                             }\n                         }\n                     }\n                     catch (Throwable x)\n                     {\n                         Throwable f = handleException(x, \"fill\");\n                         Throwable failure = handshakeFailed(f);\n                         if (_flushState == FlushState.WAIT_FOR_FILL)\n                         {\n                             _flushState = FlushState.IDLE;\n                             getExecutor().execute(() -> _decryptedEndPoint.getWriteFlusher().onFail(failure));\n                         }\n                         throw failure;\n                     }\n                     finally\n                     {\n                         releaseEncryptedInputBuffer();\n                         releaseDecryptedInputBuffer();\n \n                         if (_flushState == FlushState.WAIT_FOR_FILL)\n                         {\n                             _flushState = FlushState.IDLE;\n                             getExecutor().execute(() -> _decryptedEndPoint.getWriteFlusher().completeWrite());\n                         }\n \n                         if (LOG.isDebugEnabled())\n                             LOG.debug(\"<fill f={} uf={} {}\", filled, _underflown, SslConnection.this);\n                     }\n                 }\n             }\n             catch (Throwable x)\n             {\n                 close(x);\n                 rethrow(x);\n                 throw new AssertionError();\n             }\n         }\n \n", "target": "// fix_start\n                                    {\n                                        if (BufferUtil.space(_encryptedInput) > 0)\n                                            continue;\n                                        BufferUtil.clear(_encryptedInput);\n                                        throw new SSLHandshakeException(\"Encrypted buffer max length exceeded\");\n                                    }\n// fix_end\n// fix_start\n                                                handshakeFailure.addSuppressed(closeFailure);\n// fix_end\n", "cwe": "CWE-59", "cwe_name": "Improper Link Resolution Before File Access ('Link Following')", "idx": 65348}
{"source": " @BeforeEach\n     public void startServer() throws Exception\n     {\n         String keystore = MavenTestingUtils.getTestResourceFile(\"keystore.p12\").getAbsolutePath();\n// bug_start\n        SslContextFactory.Server sslContextFactory = new SslContextFactory.Server();\n// bug_end\n         sslContextFactory.setKeyStorePath(keystore);\n         sslContextFactory.setKeyStorePassword(\"storepwd\");\n \n         server = new Server();\n         HttpConnectionFactory http = new HttpConnectionFactory();\n         http.setInputBufferSize(512);\n         http.getHttpConfiguration().setRequestHeaderSize(512);\n         connector = new ServerConnector(server, sslContextFactory, http);\n         connector.setPort(0);\n         connector.getConnectionFactory(HttpConnectionFactory.class).getHttpConfiguration().setSendDateHeader(false);\n \n         server.addConnector(connector);\n     }\n \n", "target": "// fix_start\n        sslContextFactory = new SslContextFactory.Server();\n// fix_end\n", "cwe": "CWE-59", "cwe_name": "Improper Link Resolution Before File Access ('Link Following')", "idx": 65388}
{"source": " protected String sanitiseWindowId(String windowId)\n     {\n// bug_start\n        return windowId.replace('(', '_').replace('<', '_').replace('&', '_');\n// bug_end\n     }\n \n", "target": "// fix_start\n        return StringUtils.removeSpecialChars(windowId);\n// fix_end\n", "cwe": "CWE-74", "cwe_name": "Improper Neutralization of Special Elements in Output Used by a Downstream Component ('Injection')", "idx": 73329}
{"source": " public static @Nonnull ConfidentialStore get() {\n         if (TEST!=null) return TEST.get();\n// bug_start\n        return Jenkins.getInstance().getExtensionList(ConfidentialStore.class).get(0);\n// bug_end\n     }\n \n", "target": "// fix_start\n\n        Lookup lookup = Jenkins.getInstance().lookup;\n        ConfidentialStore cs = lookup.get(ConfidentialStore.class);\n        if (cs==null) {\n            try {\n                List<ConfidentialStore> r = (List) Service.loadInstances(ConfidentialStore.class.getClassLoader(), ConfidentialStore.class);\n                if (!r.isEmpty())\n                    cs = r.get(0);\n            } catch (IOException e) {\n                LOGGER.log(Level.WARNING, \"Failed to list up ConfidentialStore implementations\",e);\n            }\n\n            if (cs==null)\n                try {\n                    cs = new DefaultConfidentialStore();\n                } catch (Exception e) {\n                    throw new Error(e);\n                }\n\n            cs = lookup.setIfNull(ConfidentialStore.class,cs);\n        }\n        return cs;\n// fix_end\n", "cwe": "NVD-CWE-noinfo", "cwe_name": "", "idx": 99420}
{"source": " public static void setFeaturesBySystemProperty(SAXParserFactory factory)\n                 throws SAXException, ParserConfigurationException {\n \n             final boolean enableExternalDtdLoad = Boolean.parseBoolean(\n                 System.getProperty(ENABLE_EXTERNAL_DTD_LOAD, \"false\"));\n \n             factory.setFeature(LOAD_EXTERNAL_DTD, enableExternalDtdLoad);\n             factory.setFeature(EXTERNAL_GENERAL_ENTITIES, enableExternalDtdLoad);\n// bug_start\n// bug_end\n         }\n \n", "target": "// fix_start\n            factory.setFeature(EXTERNAL_PARAMETER_ENTITIES, enableExternalDtdLoad);\n// fix_end\n", "cwe": "CWE-611", "cwe_name": "Improper Restriction of XML External Entity Reference ('XXE')", "idx": 69878}
{"source": " private final void internalMapWrapper(ContextVersion contextVersion,\n                                           CharChunk path,\n                                           MappingData mappingData) throws IOException {\n \n         int pathOffset = path.getOffset();\n         int pathEnd = path.getEnd();\n         boolean noServletPath = false;\n \n         int length = contextVersion.path.length();\n         if (length == (pathEnd - pathOffset)) {\n             noServletPath = true;\n         }\n         int servletPath = pathOffset + length;\n         path.setOffset(servletPath);\n \n         MappedWrapper[] exactWrappers = contextVersion.exactWrappers;\n         internalMapExactWrapper(exactWrappers, path, mappingData);\n \n         boolean checkJspWelcomeFiles = false;\n         MappedWrapper[] wildcardWrappers = contextVersion.wildcardWrappers;\n         if (mappingData.wrapper == null) {\n             internalMapWildcardWrapper(wildcardWrappers, contextVersion.nesting,\n                                        path, mappingData);\n             if (mappingData.wrapper != null && mappingData.jspWildCard) {\n                 char[] buf = path.getBuffer();\n                 if (buf[pathEnd - 1] == '/') {\n                     mappingData.wrapper = null;\n                     checkJspWelcomeFiles = true;\n                 } else {\n                     mappingData.wrapperPath.setChars(buf, path.getStart(),\n                                                      path.getLength());\n                     mappingData.pathInfo.recycle();\n                 }\n             }\n         }\n \n         if(mappingData.wrapper == null && noServletPath &&\n                 mappingData.context.getMapperContextRootRedirectEnabled()) {\n// bug_start\n// bug_end\n             mappingData.redirectPath.setChars\n// bug_start\n                (path.getBuffer(), pathOffset, pathEnd-pathOffset);\n// bug_end\n             path.setEnd(pathEnd - 1);\n             return;\n         }\n \n         MappedWrapper[] extensionWrappers = contextVersion.extensionWrappers;\n         if (mappingData.wrapper == null && !checkJspWelcomeFiles) {\n             internalMapExtensionWrapper(extensionWrappers, path, mappingData,\n                     true);\n         }\n \n         if (mappingData.wrapper == null) {\n             boolean checkWelcomeFiles = checkJspWelcomeFiles;\n             if (!checkWelcomeFiles) {\n                 char[] buf = path.getBuffer();\n                 checkWelcomeFiles = (buf[pathEnd - 1] == '/');\n             }\n             if (checkWelcomeFiles) {\n                 for (int i = 0; (i < contextVersion.welcomeResources.length)\n                          && (mappingData.wrapper == null); i++) {\n                     path.setOffset(pathOffset);\n                     path.setEnd(pathEnd);\n                     path.append(contextVersion.welcomeResources[i], 0,\n                             contextVersion.welcomeResources[i].length());\n                     path.setOffset(servletPath);\n \n                     internalMapExactWrapper(exactWrappers, path, mappingData);\n \n                     if (mappingData.wrapper == null) {\n                         internalMapWildcardWrapper\n                             (wildcardWrappers, contextVersion.nesting,\n                              path, mappingData);\n                     }\n \n                     if (mappingData.wrapper == null\n                         && contextVersion.resources != null) {\n                         String pathStr = path.toString();\n                         WebResource file =\n                                 contextVersion.resources.getResource(pathStr);\n                         if (file != null && file.isFile()) {\n                             internalMapExtensionWrapper(extensionWrappers, path,\n                                                         mappingData, true);\n                             if (mappingData.wrapper == null\n                                 && contextVersion.defaultWrapper != null) {\n                                 mappingData.wrapper =\n                                     contextVersion.defaultWrapper.object;\n                                 mappingData.requestPath.setChars\n                                     (path.getBuffer(), path.getStart(),\n                                      path.getLength());\n                                 mappingData.wrapperPath.setChars\n                                     (path.getBuffer(), path.getStart(),\n                                      path.getLength());\n                                 mappingData.requestPath.setString(pathStr);\n                                 mappingData.wrapperPath.setString(pathStr);\n                             }\n                         }\n                     }\n                 }\n \n                 path.setOffset(servletPath);\n                 path.setEnd(pathEnd);\n             }\n \n         }\n \n         if (mappingData.wrapper == null) {\n             boolean checkWelcomeFiles = checkJspWelcomeFiles;\n             if (!checkWelcomeFiles) {\n                 char[] buf = path.getBuffer();\n                 checkWelcomeFiles = (buf[pathEnd - 1] == '/');\n             }\n             if (checkWelcomeFiles) {\n                 for (int i = 0; (i < contextVersion.welcomeResources.length)\n                          && (mappingData.wrapper == null); i++) {\n                     path.setOffset(pathOffset);\n                     path.setEnd(pathEnd);\n                     path.append(contextVersion.welcomeResources[i], 0,\n                                 contextVersion.welcomeResources[i].length());\n                     path.setOffset(servletPath);\n                     internalMapExtensionWrapper(extensionWrappers, path,\n                                                 mappingData, false);\n                 }\n \n                 path.setOffset(servletPath);\n                 path.setEnd(pathEnd);\n             }\n         }\n \n \n         if (mappingData.wrapper == null && !checkJspWelcomeFiles) {\n             if (contextVersion.defaultWrapper != null) {\n                 mappingData.wrapper = contextVersion.defaultWrapper.object;\n                 mappingData.requestPath.setChars\n                     (path.getBuffer(), path.getStart(), path.getLength());\n                 mappingData.wrapperPath.setChars\n                     (path.getBuffer(), path.getStart(), path.getLength());\n             }\n             char[] buf = path.getBuffer();\n             if (contextVersion.resources != null && buf[pathEnd -1 ] != '/') {\n                 String pathStr = path.toString();\n                 WebResource file;\n                 if (pathStr.length() == 0) {\n                     file = contextVersion.resources.getResource(\"/\");\n                 } else {\n                     file = contextVersion.resources.getResource(pathStr);\n                 }\n                 if (file != null && file.isDirectory() &&\n                         mappingData.context.getMapperDirectoryRedirectEnabled()) {\n                     path.setOffset(pathOffset);\n                     path.append('/');\n                     mappingData.redirectPath.setChars\n                         (path.getBuffer(), path.getStart(), path.getLength());\n                 } else {\n                     mappingData.requestPath.setString(pathStr);\n                     mappingData.wrapperPath.setString(pathStr);\n                 }\n             }\n         }\n \n         path.setOffset(pathOffset);\n         path.setEnd(pathEnd);\n     }\n \n", "target": "// fix_start\n            path.append('/');\n            pathEnd = path.getEnd();\n// fix_end\n// fix_start\n                (path.getBuffer(), pathOffset, pathEnd - pathOffset);\n// fix_end\n", "cwe": "CWE-22", "cwe_name": "Path Traversal", "idx": 25640}
{"source": " protected COSDictionary parseXref(long startXRefOffset) throws IOException\n     {\n         source.seek(startXRefOffset);\n         long startXrefOffset = Math.max(0, parseStartXref());\n         long fixedOffset = checkXRefOffset(startXrefOffset);\n         if (fixedOffset > -1)\n         {\n             startXrefOffset = fixedOffset;\n         }\n         document.setStartXref(startXrefOffset);\n         long prev = startXrefOffset;\n         Set<Long> prevSet = new HashSet<Long>();\n         COSDictionary trailer = null;\n         while (prev > 0)\n         {\n             source.seek(prev);\n// bug_start\n\n// bug_end\n             skipSpaces();\n// bug_start\n// bug_end\n             if (source.peek() == X)\n             {\n                 if (!parseXrefTable(prev) || !parseTrailer())\n                 {\n                     throw new IOException(\"Expected trailer object at offset \"\n                             + source.getPosition());\n                 }\n                 trailer = xrefTrailerResolver.getCurrentTrailer();\n                 if(trailer.containsKey(COSName.XREF_STM))\n                 {\n                     int streamOffset = trailer.getInt(COSName.XREF_STM);\n                     fixedOffset = checkXRefOffset(streamOffset);\n                     if (fixedOffset > -1 && fixedOffset != streamOffset)\n                     {\n                         LOG.warn(\"/XRefStm offset \" + streamOffset + \" is incorrect, corrected to \" + fixedOffset);\n                         streamOffset = (int)fixedOffset;\n                         trailer.setInt(COSName.XREF_STM, streamOffset);\n                     }\n                     if (streamOffset > 0)\n                     {\n                         source.seek(streamOffset);\n                         skipSpaces();\n                         try\n                         {\n                             parseXrefObjStream(prev, false);\n                         }\n                         catch (IOException ex)\n                         {\n                             if (isLenient)\n                             {\n                                 LOG.error(\"Failed to parse /XRefStm at offset \" + streamOffset, ex);\n                             }\n                             else\n                             {\n                                 throw ex;\n                             }\n                         }\n                     }\n                     else\n                     {\n                         if(isLenient)\n                         {\n                             LOG.error(\"Skipped XRef stream due to a corrupt offset:\"+streamOffset);\n                         }\n                         else\n                         {\n                             throw new IOException(\"Skipped XRef stream due to a corrupt offset:\"+streamOffset);\n                         }\n                     }\n                 }\n                 prev = trailer.getLong(COSName.PREV);\n             }\n             else\n             {\n                 prev = parseXrefObjStream(prev, true);\n                 trailer = xrefTrailerResolver.getCurrentTrailer();\n             }\n             if (prev > 0)\n             {\n                 fixedOffset = checkXRefOffset(prev);\n                 if (fixedOffset > -1 && fixedOffset != prev)\n                 {\n                     prev = fixedOffset;\n                     trailer.setLong(COSName.PREV, prev);\n                 }\n             }\n             if (prevSet.contains(prev))\n             {\n                 throw new IOException(\"/Prev loop at offset \" + prev);\n             }\n// bug_start\n            prevSet.add(prev);\n// bug_end\n         }\n         xrefTrailerResolver.setStartxref(startXrefOffset);\n         trailer = xrefTrailerResolver.getTrailer();\n         document.setTrailer(trailer);\n         document.setIsXRefStream(XRefType.STREAM == xrefTrailerResolver.getXrefType());\n         checkXrefOffsets();\n         document.addXRefTable(xrefTrailerResolver.getXrefTable());\n         return trailer;\n     }\n \n", "target": "// fix_start\n// fix_end\n// fix_start\n            prevSet.add(source.getPosition());\n// fix_end\n// fix_start\n// fix_end\n", "cwe": "CWE-835", "cwe_name": "Loop with Unreachable Exit Condition ('Infinite Loop')", "idx": 82597}
{"source": " @Override\n    public boolean apply(Run<?, ?> run) {\n// bug_start\n// bug_end\n       boolean retVal = false;\n       M2ReleaseBadgeAction a = run.getAction(M2ReleaseBadgeAction.class);\n       if (a != null) {\n           if (!run.isBuilding()) {\n               if (!a.isDryRun() && run.getResult() == Result.SUCCESS) {\n                   retVal = true;\n               }\n           }\n       }\n       return retVal;\n     }\n \n", "target": "// fix_start\n      if (run == null) {\n         return false;\n      }\n// fix_end\n", "cwe": "CWE-611", "cwe_name": "Improper Restriction of XML External Entity Reference ('XXE')", "idx": 69920}
{"source": " @Override\n     public SessionData decode(String data) {\n         byte[] bytes = Base64.getDecoder().decode(data);\n         try (ByteArrayInputStream inputStream = new ByteArrayInputStream(bytes);\n// bug_start\n                ObjectInputStream objectInputStream = new ObjectInputStream(inputStream)) {\n// bug_end\n             return (SessionData) objectInputStream.readObject();\n         } catch (IOException | ClassNotFoundException e) {\n             throw new PippoRuntimeException(e, \"Cannot deserialize session. A new one will be created.\");\n         }\n     }\n \n", "target": "// fix_start\n             WhitelistObjectInputStream objectInputStream = new WhitelistObjectInputStream(inputStream)) {\n// fix_end\n", "cwe": "CWE-502", "cwe_name": "Deserialization of Untrusted Data", "idx": 61522}
{"source": " @Override\n \tpublic OAuth2TokenValidatorResult validate(Jwt token) {\n \t\tAssert.notNull(token, \"token cannot be null\");\n \n// bug_start\n\t\tif (this.issuer.equals(token.getIssuer())) {\n// bug_end\n \t\t\treturn OAuth2TokenValidatorResult.success();\n \t\t} else {\n \t\t\treturn OAuth2TokenValidatorResult.failure(INVALID_ISSUER);\n \t\t}\n \t}\n \n", "target": "// fix_start\n\t\tString tokenIssuer = token.getClaimAsString(JwtClaimNames.ISS);\n\t\tif (this.issuer.equals(tokenIssuer)) {\n// fix_end\n", "cwe": "CWE-345", "cwe_name": "Insufficient Verification of Data Authenticity", "idx": 42940}
{"source": "// bug_start\nprivate static File newFile() throws IOException {\n        File file = File.createTempFile(\"netty-\", \".tmp\");\n        file.deleteOnExit();\n\n        final FileOutputStream out = new FileOutputStream(file);\n        out.write(data);\n        out.close();\n        return file;\n// bug_end\n     }\n \n", "target": "// fix_start\nprivate File tempFile() throws IOException {\n        String newpostfix;\n        String diskFilename = getDiskFilename();\n        if (diskFilename != null) {\n            newpostfix = '_' + diskFilename;\n        } else {\n            newpostfix = getPostfix();\n        }\n        File tmpFile;\n        if (getBaseDirectory() == null) {\n            tmpFile = PlatformDependent.createTempFile(getPrefix(), newpostfix, null);\n        } else {\n            tmpFile = PlatformDependent.createTempFile(getPrefix(), newpostfix, new File(\n                    getBaseDirectory()));\n        }\n        if (deleteOnExit()) {\n            DeleteFileOnExitHook.add(tmpFile.getPath());\n        }\n        return tmpFile;\n// fix_end\n", "cwe": "CWE-378", "cwe_name": "", "idx": 49793}
{"source": "// bug_start\npublic static void load(String originalName, ClassLoader loader) {\n        String packagePrefix = calculatePackagePrefix().replace('.', '_');\n        String name = packagePrefix + originalName;\n        List<Throwable> suppressed = new ArrayList<Throwable>();\n// bug_end\n         try {\n// bug_start\n            loadLibrary(loader, name, false);\n            return;\n        } catch (Throwable ex) {\n            suppressed.add(ex);\n        }\n\n        String libname = System.mapLibraryName(name);\n        String path = NATIVE_RESOURCE_HOME + libname;\n\n        InputStream in = null;\n        OutputStream out = null;\n        File tmpFile = null;\n        URL url;\n        if (loader == null) {\n            url = ClassLoader.getSystemResource(path);\n        } else {\n            url = loader.getResource(path);\n        }\n        try {\n            if (url == null) {\n                if (PlatformDependent.isOsx()) {\n                    String fileName = path.endsWith(\".jnilib\") ? NATIVE_RESOURCE_HOME + \"lib\" + name + \".dynlib\" :\n                            NATIVE_RESOURCE_HOME + \"lib\" + name + \".jnilib\";\n                    if (loader == null) {\n                        url = ClassLoader.getSystemResource(fileName);\n                    } else {\n                        url = loader.getResource(fileName);\n                    }\n                    if (url == null) {\n                        FileNotFoundException fnf = new FileNotFoundException(fileName);\n                        ThrowableUtil.addSuppressedAndClear(fnf, suppressed);\n                        throw fnf;\n                    }\n                } else {\n                    FileNotFoundException fnf = new FileNotFoundException(path);\n                    ThrowableUtil.addSuppressedAndClear(fnf, suppressed);\n                    throw fnf;\n// bug_end\n                 }\n// bug_start\n            }\n\n            int index = libname.lastIndexOf('.');\n            String prefix = libname.substring(0, index);\n            String suffix = libname.substring(index);\n\n            tmpFile = File.createTempFile(prefix, suffix, WORKDIR);\n            in = url.openStream();\n            out = new FileOutputStream(tmpFile);\n\n            if (shouldShadedLibraryIdBePatched(packagePrefix)) {\n                patchShadedLibraryId(in, out, originalName, name);\n            } else {\n                byte[] buffer = new byte[8192];\n                int length;\n                while ((length = in.read(buffer)) > 0) {\n                    out.write(buffer, 0, length);\n                }\n            }\n\n            out.flush();\n\n            closeQuietly(out);\n            out = null;\n            loadLibrary(loader, tmpFile.getPath(), true);\n        } catch (UnsatisfiedLinkError e) {\n            try {\n                if (tmpFile != null && tmpFile.isFile() && tmpFile.canRead() &&\n                    !NoexecVolumeDetector.canExecuteExecutable(tmpFile)) {\n                    logger.info(\"{} exists but cannot be executed even when execute permissions set; \" +\n                                \"check volume for \\\"noexec\\\" flag; use -D{}=[path] \" +\n                                \"to set native working directory separately.\",\n                                tmpFile.getPath(), \"io.netty.native.workdir\");\n                }\n            } catch (Throwable t) {\n                suppressed.add(t);\n                logger.debug(\"Error checking if {} is on a file store mounted with noexec\", tmpFile, t);\n            }\n            ThrowableUtil.addSuppressedAndClear(e, suppressed);\n            throw e;\n        } catch (Exception e) {\n            UnsatisfiedLinkError ule = new UnsatisfiedLinkError(\"could not load a native library: \" + name);\n            ule.initCause(e);\n            ThrowableUtil.addSuppressedAndClear(ule, suppressed);\n            throw ule;\n        } finally {\n            closeQuietly(in);\n            closeQuietly(out);\n            if (tmpFile != null && (!DELETE_NATIVE_LIB_AFTER_LOADING || !tmpFile.delete())) {\n                tmpFile.deleteOnExit();\n            }\n// bug_end\n         }\n     }\n \n", "target": "// fix_start\npublic static DomainSocketAddress newSocketAddress() {\n// fix_end\n// fix_start\n            File file;\n            do {\n                file = File.createTempFile(\"NETTY\", \"UDS\");\n                if (!file.delete()) {\n                    throw new IOException(\"failed to delete: \" + file);\n// fix_end\n// fix_start\n            } while (file.getAbsolutePath().length() > 128);\n            return new DomainSocketAddress(file);\n        } catch (IOException e) {\n            throw new IllegalStateException(e);\n// fix_end\n", "cwe": "CWE-378", "cwe_name": "", "idx": 49835}
{"source": "// bug_start\nprivate File tempFile() throws IOException {\n        String newpostfix;\n        String diskFilename = getDiskFilename();\n        if (diskFilename != null) {\n            newpostfix = '_' + diskFilename;\n// bug_end\n         } else {\n// bug_start\n            newpostfix = getPostfix();\n// bug_end\n         }\n// bug_start\n        File tmpFile;\n        if (getBaseDirectory() == null) {\n            tmpFile = File.createTempFile(getPrefix(), newpostfix);\n        } else {\n            tmpFile = File.createTempFile(getPrefix(), newpostfix, new File(\n                    getBaseDirectory()));\n// bug_end\n         }\n// bug_start\n        if (deleteOnExit()) {\n            DeleteFileOnExitHook.add(tmpFile.getPath());\n        }\n        return tmpFile;\n// bug_end\n     }\n \n", "target": "// fix_start\npublic static void load(String originalName, ClassLoader loader) {\n        String packagePrefix = calculatePackagePrefix().replace('.', '_');\n        String name = packagePrefix + originalName;\n        List<Throwable> suppressed = new ArrayList<Throwable>();\n        try {\n            loadLibrary(loader, name, false);\n            return;\n        } catch (Throwable ex) {\n            suppressed.add(ex);\n        }\n\n        String libname = System.mapLibraryName(name);\n        String path = NATIVE_RESOURCE_HOME + libname;\n\n        InputStream in = null;\n        OutputStream out = null;\n        File tmpFile = null;\n        URL url;\n        if (loader == null) {\n            url = ClassLoader.getSystemResource(path);\n// fix_end\n// fix_start\n            url = loader.getResource(path);\n// fix_end\n// fix_start\n        try {\n            if (url == null) {\n                if (PlatformDependent.isOsx()) {\n                    String fileName = path.endsWith(\".jnilib\") ? NATIVE_RESOURCE_HOME + \"lib\" + name + \".dynlib\" :\n                            NATIVE_RESOURCE_HOME + \"lib\" + name + \".jnilib\";\n                    if (loader == null) {\n                        url = ClassLoader.getSystemResource(fileName);\n                    } else {\n                        url = loader.getResource(fileName);\n                    }\n                    if (url == null) {\n                        FileNotFoundException fnf = new FileNotFoundException(fileName);\n                        ThrowableUtil.addSuppressedAndClear(fnf, suppressed);\n                        throw fnf;\n                    }\n                } else {\n                    FileNotFoundException fnf = new FileNotFoundException(path);\n                    ThrowableUtil.addSuppressedAndClear(fnf, suppressed);\n                    throw fnf;\n                }\n            }\n\n            int index = libname.lastIndexOf('.');\n            String prefix = libname.substring(0, index);\n            String suffix = libname.substring(index);\n\n            tmpFile = PlatformDependent.createTempFile(prefix, suffix, WORKDIR);\n            in = url.openStream();\n            out = new FileOutputStream(tmpFile);\n\n            if (shouldShadedLibraryIdBePatched(packagePrefix)) {\n                patchShadedLibraryId(in, out, originalName, name);\n            } else {\n                byte[] buffer = new byte[8192];\n                int length;\n                while ((length = in.read(buffer)) > 0) {\n                    out.write(buffer, 0, length);\n                }\n            }\n\n            out.flush();\n\n            closeQuietly(out);\n            out = null;\n            loadLibrary(loader, tmpFile.getPath(), true);\n        } catch (UnsatisfiedLinkError e) {\n            try {\n                if (tmpFile != null && tmpFile.isFile() && tmpFile.canRead() &&\n                    !NoexecVolumeDetector.canExecuteExecutable(tmpFile)) {\n                    logger.info(\"{} exists but cannot be executed even when execute permissions set; \" +\n                                \"check volume for \\\"noexec\\\" flag; use -D{}=[path] \" +\n                                \"to set native working directory separately.\",\n                                tmpFile.getPath(), \"io.netty.native.workdir\");\n                }\n            } catch (Throwable t) {\n                suppressed.add(t);\n                logger.debug(\"Error checking if {} is on a file store mounted with noexec\", tmpFile, t);\n            }\n            ThrowableUtil.addSuppressedAndClear(e, suppressed);\n            throw e;\n        } catch (Exception e) {\n            UnsatisfiedLinkError ule = new UnsatisfiedLinkError(\"could not load a native library: \" + name);\n            ule.initCause(e);\n            ThrowableUtil.addSuppressedAndClear(ule, suppressed);\n            throw ule;\n        } finally {\n            closeQuietly(in);\n            closeQuietly(out);\n            if (tmpFile != null && (!DELETE_NATIVE_LIB_AFTER_LOADING || !tmpFile.delete())) {\n                tmpFile.deleteOnExit();\n            }\n// fix_end\n// fix_start\n// fix_end\n", "cwe": "CWE-378", "cwe_name": "", "idx": 49792}
{"source": "// bug_start\n@Test(timeout = 10000)\n    public void spliceToFile() throws Throwable {\n        EventLoopGroup group = new EpollEventLoopGroup(1);\n        File file = File.createTempFile(\"netty-splice\", null);\n        file.deleteOnExit();\n\n        SpliceHandler sh = new SpliceHandler(file);\n        ServerBootstrap bs = new ServerBootstrap();\n        bs.channel(EpollServerSocketChannel.class);\n        bs.group(group).childHandler(sh);\n        bs.childOption(EpollChannelOption.EPOLL_MODE, EpollMode.LEVEL_TRIGGERED);\n        Channel sc = bs.bind(NetUtil.LOCALHOST, 0).syncUninterruptibly().channel();\n\n        Bootstrap cb = new Bootstrap();\n        cb.group(group);\n        cb.channel(EpollSocketChannel.class);\n        cb.handler(new ChannelInboundHandlerAdapter());\n        Channel cc = cb.connect(sc.localAddress()).syncUninterruptibly().channel();\n\n        for (int i = 0; i < data.length;) {\n            int length = Math.min(random.nextInt(1024 * 64), data.length - i);\n            ByteBuf buf = Unpooled.wrappedBuffer(data, i, length);\n            cc.writeAndFlush(buf);\n            i += length;\n        }\n\n        while (sh.future2 == null || !sh.future2.isDone() || !sh.future.isDone()) {\n            if (sh.exception.get() != null) {\n                break;\n            }\n            try {\n                Thread.sleep(50);\n            } catch (InterruptedException e) {\n            }\n        }\n\n        sc.close().sync();\n        cc.close().sync();\n\n        if (sh.exception.get() != null && !(sh.exception.get() instanceof IOException)) {\n            throw sh.exception.get();\n        }\n\n        byte[] written = new byte[data.length];\n        FileInputStream in = new FileInputStream(file);\n\n// bug_end\n         try {\n// bug_start\n            Assert.assertEquals(written.length, in.read(written));\n            Assert.assertArrayEquals(data, written);\n        } finally {\n            in.close();\n            group.shutdownGracefully();\n// bug_end\n         }\n     }\n \n", "target": "// fix_start\npublic static DomainSocketAddress newSocketAddress() {\n// fix_end\n// fix_start\n            File file;\n            do {\n                file = PlatformDependent.createTempFile(\"NETTY\", \"UDS\", null);\n                if (!file.delete()) {\n                    throw new IOException(\"failed to delete: \" + file);\n                }\n            } while (file.getAbsolutePath().length() > 128);\n            return new DomainSocketAddress(file);\n        } catch (IOException e) {\n            throw new IllegalStateException(e);\n// fix_end\n", "cwe": "CWE-378", "cwe_name": "", "idx": 50050}
{"source": "// bug_start\n@Test(timeout = 10000)\n    public void spliceToFile() throws Throwable {\n        EventLoopGroup group = new EpollEventLoopGroup(1);\n        File file = PlatformDependent.createTempFile(\"netty-splice\", null, null);\n// bug_end\n         file.deleteOnExit();\n \n// bug_start\n        SpliceHandler sh = new SpliceHandler(file);\n        ServerBootstrap bs = new ServerBootstrap();\n        bs.channel(EpollServerSocketChannel.class);\n        bs.group(group).childHandler(sh);\n        bs.childOption(EpollChannelOption.EPOLL_MODE, EpollMode.LEVEL_TRIGGERED);\n        Channel sc = bs.bind(NetUtil.LOCALHOST, 0).syncUninterruptibly().channel();\n\n        Bootstrap cb = new Bootstrap();\n        cb.group(group);\n        cb.channel(EpollSocketChannel.class);\n        cb.handler(new ChannelInboundHandlerAdapter());\n        Channel cc = cb.connect(sc.localAddress()).syncUninterruptibly().channel();\n\n        for (int i = 0; i < data.length;) {\n            int length = Math.min(random.nextInt(1024 * 64), data.length - i);\n            ByteBuf buf = Unpooled.wrappedBuffer(data, i, length);\n            cc.writeAndFlush(buf);\n            i += length;\n        }\n\n        while (sh.future2 == null || !sh.future2.isDone() || !sh.future.isDone()) {\n            if (sh.exception.get() != null) {\n                break;\n            }\n            try {\n                Thread.sleep(50);\n            } catch (InterruptedException e) {\n            }\n        }\n\n        sc.close().sync();\n        cc.close().sync();\n\n        if (sh.exception.get() != null && !(sh.exception.get() instanceof IOException)) {\n            throw sh.exception.get();\n        }\n\n        byte[] written = new byte[data.length];\n        FileInputStream in = new FileInputStream(file);\n\n        try {\n            Assert.assertEquals(written.length, in.read(written));\n            Assert.assertArrayEquals(data, written);\n        } finally {\n            in.close();\n            group.shutdownGracefully();\n        }\n// bug_end\n     }\n \n", "target": "// fix_start\nprivate static File newFile() throws IOException {\n        File file = PlatformDependent.createTempFile(\"netty-\", \".tmp\", null);\n// fix_end\n// fix_start\n        final FileOutputStream out = new FileOutputStream(file);\n        out.write(data);\n        out.close();\n        return file;\n// fix_end\n", "cwe": "CWE-378", "cwe_name": "", "idx": 50039}
{"source": " @Override\n     protected void onFullPongMessage(final WebSocketChannel webSocketChannel, BufferedBinaryMessage bufferedBinaryMessage) {\n         if(session.isSessionClosed()) {\n             bufferedBinaryMessage.getData().free();\n             return;\n         }\n         final HandlerWrapper handler = getHandler(FrameType.PONG);\n         if (handler != null) {\n             final Pooled<ByteBuffer[]> pooled = bufferedBinaryMessage.getData();\n             final PongMessage message = DefaultPongMessage.create(toBuffer(pooled.getResource()));\n \n             session.getContainer().invokeEndpointMethod(executor, new Runnable() {\n                 @Override\n                 public void run() {\n                     try {\n                         ((MessageHandler.Whole) handler.getHandler()).onMessage(message);\n                     } catch (Exception e) {\n                         invokeOnError(e);\n                     } finally {\n                         pooled.close();\n                     }\n                 }\n             });\n// bug_start\n// bug_end\n         }\n     }\n \n", "target": "// fix_start\n        } else {\n            bufferedBinaryMessage.getData().free();\n// fix_end\n", "cwe": "CWE-400", "cwe_name": "Uncontrolled Resource Consumption", "idx": 52806}
{"source": " private boolean isFileWithinDirectory(\n             final File dir,\n             final File file\n     ) throws IOException {\n         final File dir_ = dir.getAbsoluteFile();\n         if (dir_.isDirectory()) {\n             final File fl = new File(dir_, file.getPath());\n             if (fl.isFile()) {\n// bug_start\n                if (fl.getCanonicalPath().startsWith(dir_.getCanonicalPath())) {\n// bug_end\n                     return true;\n                 }\n             }\n         }\n \n         return false;\n     }\n \n", "target": "// fix_start\n                if (fl.getCanonicalFile().toPath().startsWith(dir_.getCanonicalFile().toPath())) {\n// fix_end\n", "cwe": "CWE-22", "cwe_name": "Path Traversal", "idx": 27441}
{"source": " protected void doDirectory(HttpServletRequest request,HttpServletResponse response, Resource resource)\n         throws IOException\n     {\n         if (_directory)\n         {\n// bug_start\n            String listing = resource.getListHTML(request.getRequestURI(),request.getPathInfo().lastIndexOf(\"/\") > 0);\n// bug_end\n             response.setContentType(\"text/html; charset=UTF-8\");\n             response.getWriter().println(listing);\n         }\n         else\n             response.sendError(HttpStatus.FORBIDDEN_403);\n     }\n \n", "target": "// fix_start\n            String listing = resource.getListHTML(request.getRequestURI(),request.getPathInfo().lastIndexOf(\"/\") > 0, request.getQueryString());\n// fix_end\n", "cwe": "CWE-79", "cwe_name": "Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')", "idx": 79530}
{"source": "// bug_start\nprotected void sendDirectory(HttpServletRequest request,\n            HttpServletResponse response,\n            Resource resource,\n            String pathInContext)\n    throws IOException\n    {\n        if (!_dirAllowed)\n// bug_end\n         {\n// bug_start\n            response.sendError(HttpServletResponse.SC_FORBIDDEN);\n            return;\n// bug_end\n         }\n \n// bug_start\n        byte[] data=null;\n        String base = URIUtil.addPaths(request.getRequestURI(),URIUtil.SLASH);\n\n        if (_resourceBase != null)\n        {\n            if (_resourceBase instanceof ResourceCollection)\n                resource=_resourceBase.addPath(pathInContext);\n        }\n        else if (_contextHandler.getBaseResource() instanceof ResourceCollection)\n            resource=_contextHandler.getBaseResource().addPath(pathInContext);\n\n        String dir = resource.getListHTML(base,pathInContext.length()>1);\n        if (dir==null)\n        {\n            response.sendError(HttpServletResponse.SC_FORBIDDEN,\n            \"No directory\");\n            return;\n        }\n\n        data=dir.getBytes(\"UTF-8\");\n        response.setContentType(\"text/html; charset=UTF-8\");\n        response.setContentLength(data.length);\n        response.getOutputStream().write(data);\n    }\n\n// bug_end\n", "target": "// fix_start\n@Override\n        public void handle( String target,\n                            Request baseRequest,\n                            HttpServletRequest request,\n                            HttpServletResponse response ) throws IOException,\n                                                          ServletException\n// fix_end\n// fix_start\n            final int SMALL = response.getBufferSize();\n            final int MEDIUM = 8 * SMALL;\n\n            final File file = new File(this.dir, request.getPathInfo());\n\n            if (!file.exists())\n                return;\n\n            baseRequest.setHandled(true);\n\n            if (file.isDirectory())\n            {\n                if (!request.getPathInfo().endsWith(URIUtil.SLASH))\n                {\n                    response.sendRedirect(response.encodeRedirectURL(URIUtil\n                            .addPaths(request.getRequestURI(), URIUtil.SLASH)));\n                    return;\n                }\n                String listing = Resource.newResource(file).getListHTML(\n                        request.getRequestURI(),\n                        request.getPathInfo().lastIndexOf(\"/\") > 0);\n                response.setContentType(\"text/html; charset=utf-8\");\n                response.getWriter().println(listing);\n                return;\n            }\n\n\n            response.setDateHeader(\"Last-Modified\", file.lastModified());\n            response.setDateHeader(\"Content-Length\", file.length());\n            response.setContentType(mimeTypes.getMimeByExtension(file.getName()));\n\n            if (file.length() < SMALL)\n            {\n                ((HttpOutput) response.getOutputStream())\n                        .sendContent(FileChannel.open(file.toPath(),\n                                StandardOpenOption.READ));\n                return;\n            }\n\n            final AsyncContext async = request.startAsync();\n            Callback completionCB = new Callback()\n            {\n                @Override\n                public void succeeded()\n                {\n                    async.complete();\n                }\n\n                @Override\n                public void failed( Throwable x )\n                {\n                    x.printStackTrace();\n                    async.complete();\n                }\n            };\n\n            if (file.length() < MEDIUM)\n            {\n                ((HttpOutput) response.getOutputStream())\n                        .sendContent(FileChannel.open(file.toPath(),\n                                StandardOpenOption.READ), completionCB);\n                return;\n            }\n\n            ByteBuffer buffer;\n            try ( RandomAccessFile raf = new RandomAccessFile(file, \"r\"); )\n            {\n                buffer = raf.getChannel().map(MapMode.READ_ONLY, 0,\n                        raf.length());\n            }\n\n            buffer = buffer.asReadOnlyBuffer();\n\n            ((HttpOutput) response.getOutputStream()).sendContent(buffer,\n                    completionCB);\n// fix_end\n", "cwe": "CWE-79", "cwe_name": "Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')", "idx": 79546}
{"source": "// bug_start\nprotected void sendDirectory(HttpServletRequest request,\n            HttpServletResponse response,\n            Resource resource,\n            String pathInContext)\n    throws IOException\n    {\n        if (!_dirAllowed)\n// bug_end\n         {\n// bug_start\n            response.sendError(HttpServletResponse.SC_FORBIDDEN);\n            return;\n// bug_end\n         }\n \n// bug_start\n        byte[] data=null;\n        String base = URIUtil.addPaths(request.getRequestURI(),URIUtil.SLASH);\n\n        if (_resourceBase != null)\n        {\n            if (_resourceBase instanceof ResourceCollection)\n                resource=_resourceBase.addPath(pathInContext);\n        }\n        else if (_contextHandler.getBaseResource() instanceof ResourceCollection)\n            resource=_contextHandler.getBaseResource().addPath(pathInContext);\n\n        String dir = resource.getListHTML(base,pathInContext.length()>1, request.getQueryString());\n        if (dir==null)\n        {\n            response.sendError(HttpServletResponse.SC_FORBIDDEN,\n            \"No directory\");\n            return;\n        }\n\n        data=dir.getBytes(\"UTF-8\");\n        response.setContentType(\"text/html; charset=UTF-8\");\n        response.setContentLength(data.length);\n        response.getOutputStream().write(data);\n    }\n\n// bug_end\n", "target": "// fix_start\n@Override\n        public void handle( String target,\n                            Request baseRequest,\n                            HttpServletRequest request,\n                            HttpServletResponse response ) throws IOException,\n                                                          ServletException\n// fix_end\n// fix_start\n            final int SMALL = response.getBufferSize();\n            final int MEDIUM = 8 * SMALL;\n\n            final File file = new File(this.dir, request.getPathInfo());\n\n            if (!file.exists())\n                return;\n\n            baseRequest.setHandled(true);\n\n            if (file.isDirectory())\n            {\n                if (!request.getPathInfo().endsWith(URIUtil.SLASH))\n                {\n                    response.sendRedirect(response.encodeRedirectURL(URIUtil\n                            .addPaths(request.getRequestURI(), URIUtil.SLASH)));\n                    return;\n                }\n                String listing = Resource.newResource(file).getListHTML(\n                        request.getRequestURI(),\n                        request.getPathInfo().lastIndexOf(\"/\") > 0,\n                        request.getQueryString());\n                response.setContentType(\"text/html; charset=utf-8\");\n                response.getWriter().println(listing);\n                return;\n            }\n\n\n            response.setDateHeader(\"Last-Modified\", file.lastModified());\n            response.setDateHeader(\"Content-Length\", file.length());\n            response.setContentType(mimeTypes.getMimeByExtension(file.getName()));\n\n            if (file.length() < SMALL)\n            {\n                ((HttpOutput) response.getOutputStream())\n                        .sendContent(FileChannel.open(file.toPath(),\n                                StandardOpenOption.READ));\n                return;\n            }\n\n            final AsyncContext async = request.startAsync();\n            Callback completionCB = new Callback()\n            {\n                @Override\n                public void succeeded()\n                {\n                    async.complete();\n                }\n\n                @Override\n                public void failed( Throwable x )\n                {\n                    x.printStackTrace();\n                    async.complete();\n                }\n            };\n\n            if (file.length() < MEDIUM)\n            {\n                ((HttpOutput) response.getOutputStream())\n                        .sendContent(FileChannel.open(file.toPath(),\n                                StandardOpenOption.READ), completionCB);\n                return;\n            }\n\n            ByteBuffer buffer;\n            try ( RandomAccessFile raf = new RandomAccessFile(file, \"r\"); )\n            {\n                buffer = raf.getChannel().map(MapMode.READ_ONLY, 0,\n                        raf.length());\n            }\n\n            buffer = buffer.asReadOnlyBuffer();\n\n            ((HttpOutput) response.getOutputStream()).sendContent(buffer,\n                    completionCB);\n// fix_end\n", "cwe": "CWE-79", "cwe_name": "Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')", "idx": 79151}
{"source": " public SendfileState processSendfile(SelectionKey sk, NioSocketWrapper socketWrapper,\n                 boolean calledByProcessor) {\n             NioChannel sc = null;\n             try {\n                 unreg(sk, socketWrapper, sk.readyOps());\n                 SendfileData sd = socketWrapper.getSendfileData();\n \n                 if (log.isTraceEnabled()) {\n                     log.trace(\"Processing send file for: \" + sd.fileName);\n                 }\n \n                 if (sd.fchannel == null) {\n                     File f = new File(sd.fileName);\n                     if (!f.exists()) {\n// bug_start\n                        cancelledKey(sk);\n// bug_end\n                         return SendfileState.ERROR;\n                     }\n                     @SuppressWarnings(\"resource\")\n                     FileInputStream fis = new FileInputStream(f);\n                     sd.fchannel = fis.getChannel();\n                 }\n \n                 sc = socketWrapper.getSocket();\n                 WritableByteChannel wc = ((sc instanceof SecureNioChannel)?sc:sc.getIOChannel());\n \n                 if (sc.getOutboundRemaining()>0) {\n                     if (sc.flushOutbound()) {\n                         socketWrapper.updateLastWrite();\n                     }\n                 } else {\n                     long written = sd.fchannel.transferTo(sd.pos,sd.length,wc);\n                     if (written > 0) {\n                         sd.pos += written;\n                         sd.length -= written;\n                         socketWrapper.updateLastWrite();\n                     } else {\n                         if (sd.fchannel.size() <= sd.pos) {\n                             throw new IOException(\"Sendfile configured to \" +\n                                     \"send more data than was available\");\n                         }\n                     }\n                 }\n                 if (sd.length <= 0 && sc.getOutboundRemaining()<=0) {\n                     if (log.isDebugEnabled()) {\n                         log.debug(\"Send file complete for: \"+sd.fileName);\n                     }\n                     socketWrapper.setSendfileData(null);\n                     try {\n                         sd.fchannel.close();\n                     } catch (Exception ignore) {\n                     }\n                     if (!calledByProcessor) {\n                         if (sd.keepAlive) {\n                             if (log.isDebugEnabled()) {\n                                 log.debug(\"Connection is keep alive, registering back for OP_READ\");\n                             }\n                             reg(sk,socketWrapper,SelectionKey.OP_READ);\n                         } else {\n                             if (log.isDebugEnabled()) {\n                                 log.debug(\"Send file connection is being closed\");\n                             }\n                             close(sc, sk);\n                         }\n                     }\n                     return SendfileState.DONE;\n                 } else {\n                     if (log.isDebugEnabled()) {\n                         log.debug(\"OP_WRITE for sendfile: \" + sd.fileName);\n                     }\n                     if (calledByProcessor) {\n                         add(socketWrapper.getSocket(),SelectionKey.OP_WRITE);\n                     } else {\n                         reg(sk,socketWrapper,SelectionKey.OP_WRITE);\n                     }\n                     return SendfileState.PENDING;\n                 }\n             } catch (IOException x) {\n                 if (log.isDebugEnabled()) log.debug(\"Unable to complete sendfile request:\", x);\n                 if (!calledByProcessor && sc != null) {\n                     close(sc, sk);\n// bug_start\n                } else {\n                    cancelledKey(sk);\n// bug_end\n                 }\n                 return SendfileState.ERROR;\n             } catch (Throwable t) {\n                 log.error(\"\", t);\n                 if (!calledByProcessor && sc != null) {\n                     close(sc, sk);\n// bug_start\n                } else {\n                    cancelledKey(sk);\n// bug_end\n                 }\n                 return SendfileState.ERROR;\n             }\n         }\n \n", "target": "// fix_start\n// fix_end\n// fix_start\n// fix_end\n// fix_start\n// fix_end\n", "cwe": "CWE-388", "cwe_name": "Error Handling Issues", "idx": 50791}
{"source": " protected Class<?> resolveClass(ObjectStreamClass desc)\n             throws IOException,\n             ClassNotFoundException\n         {\n             if (!found)\n             {\n                 if (!desc.getName().equals(mainClass.getName()))\n                 {\n                     throw new InvalidClassException(\n                         \"unexpected class: \", desc.getName());\n                 }\n                 else\n                 {\n                     found = true;\n                 }\n             }\n// bug_start\n// bug_end\n             return super.resolveClass(desc);\n         }\n \n", "target": "// fix_start\n            else\n            {\n                if (!components.contains(desc.getName()))\n                {\n                    throw new InvalidClassException(\n                          \"unexpected class: \", desc.getName());\n                }\n            }\n// fix_end\n", "cwe": "CWE-502", "cwe_name": "Deserialization of Untrusted Data", "idx": 59121}
{"source": "// bug_start\n@Override\n\tprotected Object doZipTransform(final Message<?> message) throws Exception {\n// bug_end\n \n// bug_start\n\t\ttry {\n\t\t\tfinal Object payload = message.getPayload();\n\t\t\tfinal Object unzippedData;\n\n\t\t\tInputStream inputStream = null;\n\n\t\t\ttry {\n\t\t\t\tif (payload instanceof File) {\n\t\t\t\t\tfinal File filePayload = (File) payload;\n\n\t\t\t\t\tif (filePayload.isDirectory()) {\n\t\t\t\t\t\tthrow new UnsupportedOperationException(String.format(\"Cannot unzip a directory: '%s'\",\n\t\t\t\t\t\t\t\tfilePayload.getAbsolutePath()));\n\t\t\t\t\t}\n\n\t\t\t\t\tif (!SpringZipUtils.isValid(filePayload)) {\n\t\t\t\t\t\tthrow new IllegalStateException(String.format(\"Not a zip file: '%s'.\",\n\t\t\t\t\t\t\t\tfilePayload.getAbsolutePath()));\n\t\t\t\t\t}\n\n\t\t\t\t\tinputStream = new FileInputStream(filePayload);\n\t\t\t\t}\n\t\t\t\telse if (payload instanceof InputStream) {\n\t\t\t\t\tinputStream = (InputStream) payload;\n\t\t\t\t}\n\t\t\t\telse if (payload instanceof byte[]) {\n\t\t\t\t\tinputStream = new ByteArrayInputStream((byte[]) payload);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tthrow new IllegalArgumentException(String.format(\"Unsupported payload type '%s'. \" +\n\t\t\t\t\t\t\t\t\t\"The only supported payload types are java.io.File, byte[] and java.io.InputStream\",\n\t\t\t\t\t\t\tpayload.getClass().getSimpleName()));\n\t\t\t\t}\n\n\t\t\t\tfinal SortedMap<String, Object> uncompressedData = new TreeMap<String, Object>();\n\n\t\t\t\tZipUtil.iterate(inputStream, new ZipEntryCallback() {\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic void process(InputStream zipEntryInputStream, ZipEntry zipEntry) throws IOException {\n\n\t\t\t\t\t\tfinal String zipEntryName = zipEntry.getName();\n\t\t\t\t\t\tfinal long zipEntryTime = zipEntry.getTime();\n\t\t\t\t\t\tfinal long zipEntryCompressedSize = zipEntry.getCompressedSize();\n\t\t\t\t\t\tfinal String type = zipEntry.isDirectory() ? \"directory\" : \"file\";\n\n\t\t\t\t\t\tif (logger.isInfoEnabled()) {\n\t\t\t\t\t\t\tlogger.info(String.format(\"Unpacking Zip Entry - Name: '%s',Time: '%s', \" +\n\t\t\t\t\t\t\t\t\t\t\t\"Compressed Size: '%s', Type: '%s'\",\n\t\t\t\t\t\t\t\t\tzipEntryName, zipEntryTime, zipEntryCompressedSize, type));\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (ZipResultType.FILE.equals(zipResultType)) {\n\t\t\t\t\t\t\tfinal File destinationFile = checkPath(message, zipEntryName);\n\n\t\t\t\t\t\t\tif (zipEntry.isDirectory()) {\n\t\t\t\t\t\t\t\tdestinationFile.mkdirs();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tSpringZipUtils.copy(zipEntryInputStream, destinationFile);\n\t\t\t\t\t\t\t\tuncompressedData.put(zipEntryName, destinationFile);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (ZipResultType.BYTE_ARRAY.equals(zipResultType)) {\n\t\t\t\t\t\t\tif (!zipEntry.isDirectory()) {\n\t\t\t\t\t\t\t\tcheckPath(message, zipEntryName);\n\t\t\t\t\t\t\t\tbyte[] data = IOUtils.toByteArray(zipEntryInputStream);\n\t\t\t\t\t\t\t\tuncompressedData.put(zipEntryName, data);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tthrow new IllegalStateException(\"Unsupported zipResultType \" + zipResultType);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tpublic File checkPath(final Message<?> message, final String zipEntryName) throws IOException {\n\t\t\t\t\t\tfinal File tempDir = new File(workDirectory, message.getHeaders().getId().toString());\n\t\t\t\t\t\ttempDir.mkdirs();\n\t\t\t\t\t\tfinal File destinationFile = new File(tempDir, zipEntryName);\n\n\t\t\t\t\t\tif (!destinationFile.getCanonicalPath().startsWith(workDirectory.getCanonicalPath())) {\n\t\t\t\t\t\t\tthrow new ZipException(\"The file \" + zipEntryName +\n\t\t\t\t\t\t\t\t\t\" is trying to leave the target output directory of \" + workDirectory);\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn destinationFile;\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\t\tif (uncompressedData.isEmpty()) {\n\t\t\t\t\tif (logger.isWarnEnabled()) {\n\t\t\t\t\t\tlogger.warn(\"No data unzipped from payload with message Id \" + message.getHeaders().getId());\n\t\t\t\t\t}\n\t\t\t\t\tunzippedData = null;\n\t\t\t\t}\n\t\t\t\telse {\n\n\t\t\t\t\tif (this.expectSingleResult) {\n\t\t\t\t\t\tif (uncompressedData.size() == 1) {\n\t\t\t\t\t\t\tunzippedData = uncompressedData.values().iterator().next();\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tthrow new MessagingException(message,\n\t\t\t\t\t\t\t\t\tString.format(\"The UnZip operation extracted %s \"\n\t\t\t\t\t\t\t\t\t\t\t+ \"result objects but expectSingleResult was 'true'.\", uncompressedData.size()));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tunzippedData = uncompressedData;\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\tIOUtils.closeQuietly(inputStream);\n\t\t\t\tif (payload instanceof File && this.deleteFiles) {\n\t\t\t\t\tfinal File filePayload = (File) payload;\n\t\t\t\t\tif (!filePayload.delete() && logger.isWarnEnabled()) {\n\t\t\t\t\t\tif (logger.isWarnEnabled()) {\n\t\t\t\t\t\t\tlogger.warn(\"failed to delete File '\" + filePayload + \"'\");\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn unzippedData;\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tthrow new MessageHandlingException(message, \"Failed to apply Zip transformation.\", e);\n\t\t}\n\t}\n\n// bug_end\n", "target": "// fix_start\nprotected String cleanupActionName(final String rawActionName) {\n        if (rawActionName.matches(allowedActionNames)) {\n            return rawActionName;\n        } else {\n            if (LOG.isWarnEnabled()) {\n                LOG.warn(\"Action [#0] do not match allowed action names pattern [#1], cleaning it up!\",\n                        rawActionName, allowedActionNames);\n            }\n            String cleanActionName = rawActionName;\n            for(String chunk : rawActionName.split(allowedActionNames)) {\n                cleanActionName = cleanActionName.replace(chunk, \"\");\n            }\n            if (LOG.isDebugEnabled()) {\n                LOG.debug(\"Cleaned action name [#0]\", cleanActionName);\n            }\n            return cleanActionName;\n        }\n    }\n// fix_end\n", "cwe": "CWE-94", "cwe_name": "Improper Control of Generation of Code ('Code Injection')", "idx": 95161}
{"source": "// bug_start\n@Override\n\tprotected Object doZipTransform(final Message<?> message) throws Exception {\n// bug_end\n \n// bug_start\n\t\ttry {\n\t\t\tfinal Object payload = message.getPayload();\n\t\t\tfinal Object unzippedData;\n\n\t\t\tInputStream inputStream = null;\n\n\t\t\ttry {\n\t\t\t\tif (payload instanceof File) {\n\t\t\t\t\tfinal File filePayload = (File) payload;\n\n\t\t\t\t\tif (filePayload.isDirectory()) {\n\t\t\t\t\t\tthrow new UnsupportedOperationException(String.format(\"Cannot unzip a directory: '%s'\",\n\t\t\t\t\t\t\t\tfilePayload.getAbsolutePath()));\n\t\t\t\t\t}\n\n\t\t\t\t\tif (!SpringZipUtils.isValid(filePayload)) {\n\t\t\t\t\t\tthrow new IllegalStateException(String.format(\"Not a zip file: '%s'.\",\n\t\t\t\t\t\t\t\tfilePayload.getAbsolutePath()));\n\t\t\t\t\t}\n\n\t\t\t\t\tinputStream = new FileInputStream(filePayload);\n\t\t\t\t}\n\t\t\t\telse if (payload instanceof InputStream) {\n\t\t\t\t\tinputStream = (InputStream) payload;\n\t\t\t\t}\n\t\t\t\telse if (payload instanceof byte[]) {\n\t\t\t\t\tinputStream = new ByteArrayInputStream((byte[]) payload);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tthrow new IllegalArgumentException(String.format(\"Unsupported payload type '%s'. \" +\n\t\t\t\t\t\t\t\t\t\"The only supported payload types are java.io.File, byte[] and java.io.InputStream\",\n\t\t\t\t\t\t\tpayload.getClass().getSimpleName()));\n\t\t\t\t}\n\n\t\t\t\tfinal SortedMap<String, Object> uncompressedData = new TreeMap<String, Object>();\n\n\t\t\t\tZipUtil.iterate(inputStream, new ZipEntryCallback() {\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic void process(InputStream zipEntryInputStream, ZipEntry zipEntry) throws IOException {\n\n\t\t\t\t\t\tfinal String zipEntryName = zipEntry.getName();\n\t\t\t\t\t\tfinal long zipEntryTime = zipEntry.getTime();\n\t\t\t\t\t\tfinal long zipEntryCompressedSize = zipEntry.getCompressedSize();\n\t\t\t\t\t\tfinal String type = zipEntry.isDirectory() ? \"directory\" : \"file\";\n\n\t\t\t\t\t\tif (logger.isInfoEnabled()) {\n\t\t\t\t\t\t\tlogger.info(String.format(\"Unpacking Zip Entry - Name: '%s',Time: '%s', \" +\n\t\t\t\t\t\t\t\t\t\t\t\"Compressed Size: '%s', Type: '%s'\",\n\t\t\t\t\t\t\t\t\tzipEntryName, zipEntryTime, zipEntryCompressedSize, type));\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (ZipResultType.FILE.equals(zipResultType)) {\n\t\t\t\t\t\t\tfinal File tempDir = new File(workDirectory, message.getHeaders().getId().toString());\n\t\t\t\t\t\t\ttempDir.mkdirs();\n\t\t\t\t\t\t\tfinal File destinationFile = new File(tempDir, zipEntryName);\n\n\t\t\t\t\t\t\tif (!destinationFile.getCanonicalPath().startsWith(workDirectory.getCanonicalPath())) {\n\t\t\t\t\t\t\t\tthrow new ZipException(\"The file \" + zipEntryName +\n\t\t\t\t\t\t\t\t\t\t\" is trying to leave the target output directory of \" + workDirectory);\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (zipEntry.isDirectory()) {\n\t\t\t\t\t\t\t\tdestinationFile.mkdirs();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tSpringZipUtils.copy(zipEntryInputStream, destinationFile);\n\t\t\t\t\t\t\t\tuncompressedData.put(zipEntryName, destinationFile);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (ZipResultType.BYTE_ARRAY.equals(zipResultType)) {\n\t\t\t\t\t\t\tif (!zipEntry.isDirectory()) {\n\t\t\t\t\t\t\t\tbyte[] data = IOUtils.toByteArray(zipEntryInputStream);\n\t\t\t\t\t\t\t\tuncompressedData.put(zipEntryName, data);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tthrow new IllegalStateException(\"Unsupported zipResultType \" + zipResultType);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\t\tif (uncompressedData.isEmpty()) {\n\t\t\t\t\tif (logger.isWarnEnabled()) {\n\t\t\t\t\t\tlogger.warn(\"No data unzipped from payload with message Id \" + message.getHeaders().getId());\n\t\t\t\t\t}\n\t\t\t\t\tunzippedData = null;\n\t\t\t\t}\n\t\t\t\telse {\n\n\t\t\t\t\tif (this.expectSingleResult) {\n\t\t\t\t\t\tif (uncompressedData.size() == 1) {\n\t\t\t\t\t\t\tunzippedData = uncompressedData.values().iterator().next();\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tthrow new MessagingException(message,\n\t\t\t\t\t\t\t\t\tString.format(\"The UnZip operation extracted %s \"\n\t\t\t\t\t\t\t\t\t\t\t+ \"result objects but expectSingleResult was 'true'.\", uncompressedData.size()));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tunzippedData = uncompressedData;\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\tIOUtils.closeQuietly(inputStream);\n\t\t\t\tif (payload instanceof File && this.deleteFiles) {\n\t\t\t\t\tfinal File filePayload = (File) payload;\n\t\t\t\t\tif (!filePayload.delete() && logger.isWarnEnabled()) {\n\t\t\t\t\t\tif (logger.isWarnEnabled()) {\n\t\t\t\t\t\t\tlogger.warn(\"failed to delete File '\" + filePayload + \"'\");\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn unzippedData;\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tthrow new MessageHandlingException(message, \"Failed to apply Zip transformation.\", e);\n\t\t}\n\t}\n\n// bug_end\n", "target": "// fix_start\nprivate static Document loadConfigFile(SolrResourceLoader resourceLoader, String parseContextConfigLoc) throws Exception {\n    try (InputStream in = resourceLoader.openResource(parseContextConfigLoc)) {\n      return DocumentBuilderFactory.newInstance().newDocumentBuilder().parse(in, parseContextConfigLoc);\n    }\n  }\n// fix_end\n", "cwe": "CWE-22", "cwe_name": "Path Traversal", "idx": 26487}
{"source": "// bug_start\nprivate static void processHeaderConfig(MultivaluedMap<String, String> httpHeaders, Object object, String key, String prefix) {\n// bug_end\n \n// bug_start\n        try {String property = StringUtils.removeStart(key, prefix);\n            Field field = null;\n            try {\n                field = object.getClass().getDeclaredField(StringUtils.uncapitalize(property));\n            } catch (NoSuchFieldException e) {\n            }\n            String setter = property;\n            setter = \"set\"+setter.substring(0,1).toUpperCase(Locale.US)+setter.substring(1);\n            Class clazz = String.class;\n            if (field != null) {\n                if (field.getType() == int.class || field.getType() == Integer.class) {\n                    clazz = int.class;\n                } else if (field.getType() == double.class) {\n                    clazz = double.class;\n                } else if (field.getType() == Double.class) {\n                    clazz = Double.class;\n                } else if (field.getType() == float.class) {\n                    clazz = float.class;\n                } else if (field.getType() == Float.class) {\n                    clazz = Float.class;\n                } else if (field.getType() == boolean.class) {\n                    clazz = boolean.class;\n                } else if (field.getType() == Boolean.class) {\n                    clazz = Boolean.class;\n                }\n            }\n\n            Method m = tryToGetMethod(object, setter, clazz);\n            if (m == null && clazz != String.class) {\n                m = tryToGetMethod(object, setter, String.class);\n            }\n\n            if (m != null) {\n                String val = httpHeaders.getFirst(key);\n                val = val.trim();\n                if (clazz == String.class) {\n                    checkTrustWorthy(setter, val);\n                    m.invoke(object, val);\n                } else if (clazz == int.class || clazz == Integer.class) {\n                    m.invoke(object, Integer.parseInt(val));\n                } else if (clazz == double.class || clazz == Double.class) {\n                    m.invoke(object, Double.parseDouble(val));\n                } else if (clazz == boolean.class || clazz == Boolean.class) {\n                    m.invoke(object, Boolean.parseBoolean(val));\n                } else if (clazz == float.class || clazz == Float.class) {\n                    m.invoke(object, Float.parseFloat(val));\n                } else {\n                    throw new IllegalArgumentException(\"setter must be String, int, float, double or boolean...for now\");\n                }\n            } else {\n                throw new NoSuchMethodException(\"Couldn't find: \"+setter);\n            }\n\n        } catch (Throwable ex) {\n            throw new WebApplicationException(String.format(Locale.ROOT,\n                    \"%s is an invalid %s header\", key, X_TIKA_OCR_HEADER_PREFIX));\n        }\n    }\n\n// bug_end\n", "target": "// fix_start\nprivate static Document loadConfigFile(SolrResourceLoader resourceLoader, String parseContextConfigLoc) throws Exception {\n    return SafeXMLParsing.parseConfigXML(log, resourceLoader, parseContextConfigLoc);\n  }\n// fix_end\n", "cwe": "CWE-611", "cwe_name": "Improper Restriction of XML External Entity Reference ('XXE')", "idx": 68911}
{"source": " public static URL valueOf(String url) {\n         if (url == null || (url = url.trim()).length() == 0) {\n             throw new IllegalArgumentException(\"url == null\");\n         }\n         String protocol = null;\n         String username = null;\n         String password = null;\n         String host = null;\n         int port = 0;\n         String path = null;\n         Map<String, String> parameters = null;\n// bug_start\n// bug_end\n         int i = url.indexOf('?');\n         if (i >= 0) {\n             String[] parts = url.substring(i + 1).split(\"&\");\n             parameters = new HashMap<>();\n             for (String part : parts) {\n                 part = part.trim();\n                 if (part.length() > 0) {\n                     int j = part.indexOf('=');\n                     if (j >= 0) {\n                         String key = part.substring(0, j);\n                         String value = part.substring(j + 1);\n                         parameters.put(key, value);\n                         if (key.startsWith(DEFAULT_KEY_PREFIX)) {\n                             parameters.putIfAbsent(key.substring(DEFAULT_KEY_PREFIX.length()), value);\n                         }\n                     } else {\n                         parameters.put(part, part);\n                     }\n                 }\n             }\n             url = url.substring(0, i);\n         }\n         i = url.indexOf(\"://\");\n         if (i >= 0) {\n             if (i == 0) {\n                 throw new IllegalStateException(\"url missing protocol: \\\"\" + url + \"\\\"\");\n             }\n             protocol = url.substring(0, i);\n             url = url.substring(i + 3);\n         } else {\n             i = url.indexOf(\":/\");\n             if (i >= 0) {\n                 if (i == 0) {\n                     throw new IllegalStateException(\"url missing protocol: \\\"\" + url + \"\\\"\");\n                 }\n                 protocol = url.substring(0, i);\n                 url = url.substring(i + 1);\n             }\n         }\n \n         i = url.indexOf('/');\n         if (i >= 0) {\n             path = url.substring(i + 1);\n             url = url.substring(0, i);\n         }\n         i = url.lastIndexOf('@');\n         if (i >= 0) {\n             username = url.substring(0, i);\n             int j = username.indexOf(':');\n             if (j >= 0) {\n                 password = username.substring(j + 1);\n                 username = username.substring(0, j);\n             }\n             url = url.substring(i + 1);\n         }\n         i = url.lastIndexOf(':');\n         if (i >= 0 && i < url.length() - 1) {\n             if (url.lastIndexOf('%') > i) {\n             } else {\n                 port = Integer.parseInt(url.substring(i + 1));\n                 url = url.substring(0, i);\n             }\n         }\n         if (url.length() > 0) {\n             host = url;\n         }\n \n         return new URL(protocol, username, password, host, port, path, parameters);\n     }\n \n", "target": "// fix_start\n        int poundIndex = url.indexOf('#');\n        if (poundIndex != -1) {\n            url = url.substring(0, poundIndex);\n        }\n// fix_end\n", "cwe": "CWE-601", "cwe_name": "URL Redirection to Untrusted Site ('Open Redirect')", "idx": 65394}
{"source": " protected void setUpSSL() throws Exception {\n \t\tif (this.sslPropertiesLocation == null && this.keyStore == null && this.trustStore == null\n \t\t\t\t&& this.keyStoreResource == null && this.trustStoreResource == null) {\n \t\t\tif (this.skipServerCertificateValidation) {\n \t\t\t\tif (this.sslAlgorithmSet) {\n \t\t\t\t\tthis.connectionFactory.useSslProtocol(this.sslAlgorithm);\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\tthis.connectionFactory.useSslProtocol();\n \t\t\t\t}\n \t\t\t}\n \t\t\telse {\n \t\t\t\tuseDefaultTrustStoreMechanism();\n \t\t\t}\n \t\t}\n \t\telse {\n \t\t\tif (this.sslPropertiesLocation != null) {\n \t\t\t\tthis.sslProperties.load(this.sslPropertiesLocation.getInputStream());\n \t\t\t}\n \t\t\tPathMatchingResourcePatternResolver resolver = new PathMatchingResourcePatternResolver();\n \t\t\tString keyStoreName = getKeyStore();\n \t\t\tString trustStoreName = getTrustStore();\n \t\t\tString keyStorePassword = getKeyStorePassphrase();\n \t\t\tString trustStorePassword = getTrustStorePassphrase();\n \t\t\tString keyStoreType = getKeyStoreType();\n \t\t\tString trustStoreType = getTrustStoreType();\n \t\t\tchar[] keyPassphrase = null;\n \t\t\tif (keyStorePassword != null) {\n \t\t\t\tkeyPassphrase = keyStorePassword.toCharArray();\n \t\t\t}\n \t\t\tchar[] trustPassphrase = null;\n \t\t\tif (trustStorePassword != null) {\n \t\t\t\ttrustPassphrase = trustStorePassword.toCharArray();\n \t\t\t}\n \t\t\tKeyManager[] keyManagers = null;\n \t\t\tTrustManager[] trustManagers = null;\n \t\t\tif (StringUtils.hasText(keyStoreName) || this.keyStoreResource != null) {\n \t\t\t\tResource keyStoreResource = this.keyStoreResource != null ? this.keyStoreResource\n \t\t\t\t\t\t: resolver.getResource(keyStoreName);\n \t\t\t\tKeyStore ks = KeyStore.getInstance(keyStoreType);\n \t\t\t\tks.load(keyStoreResource.getInputStream(), keyPassphrase);\n \t\t\t\tKeyManagerFactory kmf = KeyManagerFactory.getInstance(\"SunX509\");\n \t\t\t\tkmf.init(ks, keyPassphrase);\n \t\t\t\tkeyManagers = kmf.getKeyManagers();\n \t\t\t}\n \t\t\tif (StringUtils.hasText(trustStoreName) || this.trustStoreResource != null) {\n \t\t\t\tResource trustStoreResource = this.trustStoreResource != null ? this.trustStoreResource\n \t\t\t\t\t\t: resolver.getResource(trustStoreName);\n \t\t\t\tKeyStore tks = KeyStore.getInstance(trustStoreType);\n \t\t\t\ttks.load(trustStoreResource.getInputStream(), trustPassphrase);\n \t\t\t\tTrustManagerFactory tmf = TrustManagerFactory.getInstance(\"SunX509\");\n \t\t\t\ttmf.init(tks);\n \t\t\t\ttrustManagers = tmf.getTrustManagers();\n \t\t\t}\n \n \t\t\tif (this.logger.isDebugEnabled()) {\n \t\t\t\tthis.logger.debug(\"Initializing SSLContext with KM: \"\n \t\t\t\t\t\t+ Arrays.toString(keyManagers)\n \t\t\t\t\t\t+ \", TM: \" + Arrays.toString(trustManagers)\n \t\t\t\t\t\t+ \", random: \" + this.secureRandom);\n \t\t\t}\n \t\t\tSSLContext context = createSSLContext();\n \t\t\tcontext.init(keyManagers, trustManagers, this.secureRandom);\n \t\t\tthis.connectionFactory.useSslProtocol(context);\n// bug_start\n// bug_end\n \t\t}\n \t}\n \n", "target": "// fix_start\n\t\t\tcheckHostVerification();\n// fix_end\n", "cwe": "CWE-295", "cwe_name": "Improper Certificate Validation", "idx": 40637}
{"source": " public void setMetaData(MetaData.Request request)\n     {\n         if (_metaData == null && _input != null && _channel != null)\n         {\n             _input.reopen();\n             _channel.getResponse().getHttpOutput().reopen();\n         }\n         _metaData = request;\n         _method = request.getMethod();\n         _httpFields = request.getFields();\n         final HttpURI uri = request.getURI();\n \n// bug_start\n        if (uri.isAmbiguous())\n// bug_end\n         {\n             UriCompliance compliance = _channel == null || _channel.getHttpConfiguration() == null ? null : _channel.getHttpConfiguration().getUriCompliance();\n             if (uri.hasAmbiguousSegment() && (compliance == null || !compliance.allows(UriCompliance.Violation.AMBIGUOUS_PATH_SEGMENT)))\n                 throw new BadMessageException(\"Ambiguous segment in URI\");\n             if (uri.hasAmbiguousSeparator() && (compliance == null || !compliance.allows(UriCompliance.Violation.AMBIGUOUS_PATH_SEPARATOR)))\n                 throw new BadMessageException(\"Ambiguous segment in URI\");\n             if (uri.hasAmbiguousParameter() && (compliance == null || !compliance.allows(UriCompliance.Violation.AMBIGUOUS_PATH_PARAMETER)))\n                 throw new BadMessageException(\"Ambiguous path parameter in URI\");\n         }\n \n         if (uri.isAbsolute() && uri.hasAuthority() && uri.getPath() != null)\n         {\n             _uri = uri;\n         }\n         else\n         {\n             HttpURI.Mutable builder = HttpURI.build(uri);\n \n             if (!uri.isAbsolute())\n                 builder.scheme(HttpScheme.HTTP.asString());\n \n             if (uri.getPath() == null)\n                 builder.path(\"/\");\n \n             if (!uri.hasAuthority())\n             {\n                 HttpField field = getHttpFields().getField(HttpHeader.HOST);\n                 if (field instanceof HostPortHttpField)\n                 {\n                     HostPortHttpField authority = (HostPortHttpField)field;\n                     builder.host(authority.getHost()).port(authority.getPort());\n                 }\n                 else\n                 {\n                     builder.host(findServerName()).port(findServerPort());\n                 }\n             }\n             _uri = builder.asImmutable();\n         }\n \n         setSecure(HttpScheme.HTTPS.is(_uri.getScheme()));\n \n         String encoded = _uri.getPath();\n         String path;\n         if (encoded == null)\n             path = _uri.isAbsolute() ? \"/\" : null;\n         else if (encoded.startsWith(\"/\"))\n// bug_start\n// bug_end\n             path = (encoded.length() == 1) ? \"/\" : _uri.getDecodedPath();\n// bug_start\n// bug_end\n         else if (\"*\".equals(encoded) || HttpMethod.CONNECT.is(getMethod()))\n             path = encoded;\n         else\n             path = null;\n \n         if (path == null || path.isEmpty())\n         {\n             _pathInContext = encoded == null ? \"\" : encoded;\n             throw new BadMessageException(400, \"Bad URI\");\n         }\n         _pathInContext = path;\n     }\n \n", "target": "// fix_start\n        boolean ambiguous = uri.isAmbiguous();\n        if (ambiguous)\n// fix_end\n// fix_start\n        {\n// fix_end\n// fix_start\n            if (ambiguous)\n                path = URIUtil.canonicalPath(path);\n        }\n// fix_end\n", "cwe": "NVD-CWE-Other", "cwe_name": "Other", "idx": 114808}
{"source": " private void normalizeNumber(int start, int end) {\n     int pos = start;\n     if (pos < end) {\n       switch (jsonish.charAt(pos)) {\n         case '+':\n           elide(pos, pos + 1);\n           ++pos;\n           break;\n         case '-':\n           ++pos;\n           break;\n         default:\n           break;\n       }\n     }\n \n     int intEnd = endOfDigitRun(pos, end);\n     if (pos == intEnd) {\n       insert(pos, '0');\n     } else if ('0' == jsonish.charAt(pos)) {\n       boolean reencoded = false;\n       int maxDigVal = 0;\n       int probableBase = 10;\n       int firstDigitIndex = -1;\n       if (intEnd - pos == 1 && intEnd < end\n               && 'x' == (jsonish.charAt(intEnd) | 32)) {\n         probableBase = 16;\n         firstDigitIndex = intEnd + 1;\n         for (intEnd = intEnd + 1; intEnd < end; ++intEnd) {\n           char ch = jsonish.charAt(intEnd);\n           int digVal;\n           if ('0' <= ch && ch <= '9') {\n             digVal = ch - '0';\n           } else {\n             ch |= 32;\n             if ('a' <= ch && ch <= 'f') {\n               digVal = ch - ('a' - 10);\n             } else {\n               break;\n             }\n           }\n           maxDigVal = Math.max(digVal, maxDigVal);\n         }\n         reencoded = true;\n       } else if (intEnd - pos > 1) {\n         probableBase = 8;\n         firstDigitIndex = pos;\n         for (int i = pos; i < intEnd; ++i) {\n           int digVal = jsonish.charAt(i) - '0';\n           if (digVal < 0) {\n             break;\n           }\n           maxDigVal = Math.max(digVal, maxDigVal);\n         }\n         reencoded = true;\n       }\n       if (reencoded) {\n         elide(pos, intEnd);\n \n         String digits = jsonish.substring(firstDigitIndex, intEnd);\n \n         int nDigits = digits.length();\n         int base = probableBase > maxDigVal ? probableBase : maxDigVal > 10 ? 16 : 10;\n// bug_start\n        if (DIGITS_BY_BASE_THAT_FIT_IN_63B[base] >= nDigits) {\n// bug_end\n           long value = Long.parseLong(digits, base);\n           sanitizedJson.append(value);\n         } else {\n           BigInteger value = new BigInteger(digits, base);\n           sanitizedJson.append(value);\n         }\n       }\n     }\n     pos = intEnd;\n \n     if (pos < end && jsonish.charAt(pos) == '.') {\n       ++pos;\n       int fractionEnd = endOfDigitRun(pos, end);\n       if (fractionEnd == pos) {\n         insert(pos, '0');\n       }\n       pos = fractionEnd;\n     }\n \n     if (pos < end && 'e' == (jsonish.charAt(pos) | 32)) {\n       ++pos;\n       if (pos < end) {\n         switch (jsonish.charAt(pos)) {\n           case '+': case '-': ++pos; break;\n           default: break;\n         }\n       }\n       int expEnd = endOfDigitRun(pos, end);\n       if (expEnd == pos) {\n         insert(pos, '0');\n       }\n       pos = expEnd;\n     }\n     if (pos != end) {\n       elide(pos, end);\n     }\n   }\n \n", "target": "// fix_start\n        if (nDigits == 0) {\n          sanitizedJson.append('0');\n        } else if (DIGITS_BY_BASE_THAT_FIT_IN_63B[base] >= nDigits) {\n// fix_end\n", "cwe": "CWE-611", "cwe_name": "Improper Restriction of XML External Entity Reference ('XXE')", "idx": 69937}
{"source": "// bug_start\nprotected String sanitiseWindowId(String windowId)\n    {\n        return windowId.replace('(', '_');\n// bug_end\n     }\n \n", "target": "// fix_start\n@Override\n    public void init(ServletConfig config) throws ServletException {\n\n        super.init(config);\n        this.config = config;\n        this.context = config.getServletContext();\n\n        String engineOptionsName = config.getInitParameter(\"engineOptionsClass\");\n        if (engineOptionsName != null) {\n            try {\n                ClassLoader loader = Thread.currentThread().getContextClassLoader();\n                Class<?> engineOptionsClass = loader.loadClass(engineOptionsName);\n                Class<?>[] ctorSig = { ServletConfig.class, ServletContext.class };\n                Constructor<?> ctor = engineOptionsClass.getConstructor(ctorSig);\n                Object[] args = { config, context };\n                options = (Options) ctor.newInstance(args);\n            } catch (Throwable e) {\n                e = ExceptionUtils.unwrapInvocationTargetException(e);\n                ExceptionUtils.handleThrowable(e);\n                log.warn(\"Failed to load engineOptionsClass\", e);\n                options = new EmbeddedServletOptions(config, context);\n            }\n        } else {\n            options = new EmbeddedServletOptions(config, context);\n        }\n        rctxt = new JspRuntimeContext(context, options);\n        if (config.getInitParameter(\"jspFile\") != null) {\n            jspFile = config.getInitParameter(\"jspFile\");\n            try {\n                if (null == context.getResource(jspFile)) {\n                    return;\n                }\n            } catch (MalformedURLException e) {\n                throw new ServletException(\"Can not locate jsp file\", e);\n            }\n            try {\n                if (SecurityUtil.isPackageProtectionEnabled()){\n                   AccessController.doPrivileged(new PrivilegedExceptionAction<Object>(){\n                        @Override\n                        public Object run() throws IOException, ServletException {\n                            serviceJspFile(null, null, jspFile, true);\n                            return null;\n                        }\n                    });\n                } else {\n                    serviceJspFile(null, null, jspFile, true);\n                }\n            } catch (IOException e) {\n                throw new ServletException(\"Could not precompile jsp: \" + jspFile, e);\n            } catch (PrivilegedActionException e) {\n                Throwable t = e.getCause();\n                if (t instanceof ServletException) throw (ServletException)t;\n                throw new ServletException(\"Could not precompile jsp: \" + jspFile, e);\n            }\n        }\n\n        if (log.isDebugEnabled()) {\n            log.debug(Localizer.getMessage(\"jsp.message.scratch.dir.is\",\n                    options.getScratchDir().toString()));\n            log.debug(Localizer.getMessage(\"jsp.message.dont.modify.servlets\"));\n        }\n// fix_end\n", "cwe": "CWE-79", "cwe_name": "Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')", "idx": 79102}
{"source": "// bug_start\nprivate void prepareRequest() throws IOException {\n// bug_end\n \n// bug_start\n        contentDelimitation = false;\n// bug_end\n \n// bug_start\n        if (endpoint.isSSLEnabled()) {\n            request.scheme().setString(\"https\");\n// bug_end\n         }\n// bug_start\n\n        MimeHeaders headers = request.getMimeHeaders();\n\n        MessageBytes connectionValueMB = headers.getValue(Constants.CONNECTION);\n        if (connectionValueMB != null && !connectionValueMB.isNull()) {\n            Set<String> tokens = new HashSet<>();\n            TokenList.parseTokenList(headers.values(Constants.CONNECTION), tokens);\n            if (tokens.contains(Constants.CLOSE)) {\n                keepAlive = false;\n            } else if (tokens.contains(Constants.KEEP_ALIVE_HEADER_VALUE_TOKEN)) {\n                keepAlive = true;\n// bug_end\n             }\n         }\n \n// bug_start\n        if (http11) {\n            MessageBytes expectMB = headers.getValue(\"expect\");\n            if (expectMB != null && !expectMB.isNull()) {\n                if (expectMB.toString().trim().equalsIgnoreCase(\"100-continue\")) {\n                    inputBuffer.setSwallowInput(false);\n                    request.setExpectation(true);\n                } else {\n                    response.setStatus(HttpServletResponse.SC_EXPECTATION_FAILED);\n                    setErrorState(ErrorState.CLOSE_CLEAN, null);\n                }\n            }\n        }\n\n        if (restrictedUserAgents != null && (http11 || keepAlive)) {\n            MessageBytes userAgentValueMB = headers.getValue(\"user-agent\");\n            if(userAgentValueMB != null && !userAgentValueMB.isNull()) {\n                String userAgentValue = userAgentValueMB.toString();\n                if (restrictedUserAgents != null &&\n                        restrictedUserAgents.matcher(userAgentValue).matches()) {\n                    http11 = false;\n                    keepAlive = false;\n                }\n            }\n        }\n\n\n        MessageBytes hostValueMB = null;\n        try {\n            hostValueMB = headers.getUniqueValue(\"host\");\n        } catch (IllegalArgumentException iae) {\n            badRequest(\"http11processor.request.multipleHosts\");\n        }\n        if (http11 && hostValueMB == null) {\n            badRequest(\"http11processor.request.noHostHeader\");\n        }\n\n        ByteChunk uriBC = request.requestURI().getByteChunk();\n        byte[] uriB = uriBC.getBytes();\n        if (uriBC.startsWithIgnoreCase(\"http\", 0)) {\n            int pos = 4;\n            if (uriBC.startsWithIgnoreCase(\"s\", pos)) {\n                pos++;\n            }\n            if (uriBC.startsWith(\"://\", pos)) {\n                pos += 3;\n                int uriBCStart = uriBC.getStart();\n\n                int slashPos = uriBC.indexOf('/', pos);\n                int atPos = uriBC.indexOf('@', pos);\n                if (slashPos > -1 && atPos > slashPos) {\n                    atPos = -1;\n                }\n\n                if (slashPos == -1) {\n                    slashPos = uriBC.getLength();\n                    request.requestURI().setBytes(uriB, uriBCStart + 6, 1);\n                } else {\n                    request.requestURI().setBytes(uriB, uriBCStart + slashPos, uriBC.getLength() - slashPos);\n                }\n\n                if (atPos != -1) {\n                    for (; pos < atPos; pos++) {\n                        byte c = uriB[uriBCStart + pos];\n                        if (!HttpParser.isUserInfo(c)) {\n                            badRequest(\"http11processor.request.invalidUserInfo\");\n                            break;\n                        }\n                    }\n                    pos = atPos + 1;\n                }\n\n                if (http11) {\n                    if (hostValueMB != null) {\n                        if (!hostValueMB.getByteChunk().equals(\n                                uriB, uriBCStart + pos, slashPos - pos)) {\n                            if (protocol.getAllowHostHeaderMismatch()) {\n                                hostValueMB = headers.setValue(\"host\");\n                                hostValueMB.setBytes(uriB, uriBCStart + pos, slashPos - pos);\n                            } else {\n                                badRequest(\"http11processor.request.inconsistentHosts\");\n                            }\n                        }\n                    }\n                } else {\n                    try {\n                        hostValueMB = headers.setValue(\"host\");\n                        hostValueMB.setBytes(uriB, uriBCStart + pos, slashPos - pos);\n                    } catch (IllegalStateException e) {\n                    }\n                }\n            } else {\n                badRequest(\"http11processor.request.invalidScheme\");\n            }\n        }\n\n        for (int i = uriBC.getStart(); i < uriBC.getEnd(); i++) {\n            if (!httpParser.isAbsolutePathRelaxed(uriB[i])) {\n                badRequest(\"http11processor.request.invalidUri\");\n                break;\n            }\n        }\n\n        InputFilter[] inputFilters = inputBuffer.getFilters();\n\n        if (http11) {\n            MessageBytes transferEncodingValueMB = headers.getValue(\"transfer-encoding\");\n            if (transferEncodingValueMB != null) {\n                List<String> encodingNames = new ArrayList<>();\n                if (TokenList.parseTokenList(headers.values(\"transfer-encoding\"), encodingNames)) {\n                    for (String encodingName : encodingNames) {\n                        addInputFilter(inputFilters, encodingName);\n                    }\n                } else {\n                    badRequest(\"http11processor.request.invalidTransferEncoding\");\n                }\n            }\n        }\n\n        long contentLength = -1;\n        try {\n            contentLength = request.getContentLengthLong();\n        } catch (NumberFormatException e) {\n            badRequest(\"http11processor.request.nonNumericContentLength\");\n        } catch (IllegalArgumentException e) {\n            badRequest(\"http11processor.request.multipleContentLength\");\n        }\n        if (contentLength >= 0) {\n            if (contentDelimitation) {\n                headers.removeHeader(\"content-length\");\n                request.setContentLength(-1);\n                keepAlive = false;\n            } else {\n                inputBuffer.addActiveFilter(inputFilters[Constants.IDENTITY_FILTER]);\n                contentDelimitation = true;\n            }\n        }\n\n        parseHost(hostValueMB);\n\n        if (!contentDelimitation) {\n            inputBuffer.addActiveFilter(inputFilters[Constants.VOID_FILTER]);\n            contentDelimitation = true;\n        }\n\n        if (!getErrorState().isIoAllowed()) {\n            getAdapter().log(request, response, 0);\n// bug_end\n         }\n     }\n \n", "target": "// fix_start\n@Override\n    public void init(ServletConfig config) throws ServletException {\n// fix_end\n// fix_start\n        super.init(config);\n        this.config = config;\n        this.context = config.getServletContext();\n// fix_end\n// fix_start\n        String engineOptionsName = config.getInitParameter(\"engineOptionsClass\");\n        if (Constants.IS_SECURITY_ENABLED && engineOptionsName != null) {\n            log.info(Localizer.getMessage(\n                    \"jsp.info.ignoreSetting\", \"engineOptionsClass\", engineOptionsName));\n            engineOptionsName = null;\n// fix_end\n// fix_start\n        if (engineOptionsName != null) {\n            try {\n                ClassLoader loader = Thread.currentThread().getContextClassLoader();\n                Class<?> engineOptionsClass = loader.loadClass(engineOptionsName);\n                Class<?>[] ctorSig = { ServletConfig.class, ServletContext.class };\n                Constructor<?> ctor = engineOptionsClass.getConstructor(ctorSig);\n                Object[] args = { config, context };\n                options = (Options) ctor.newInstance(args);\n            } catch (Throwable e) {\n                e = ExceptionUtils.unwrapInvocationTargetException(e);\n                ExceptionUtils.handleThrowable(e);\n                log.warn(\"Failed to load engineOptionsClass\", e);\n                options = new EmbeddedServletOptions(config, context);\n            }\n        } else {\n            options = new EmbeddedServletOptions(config, context);\n        }\n        rctxt = new JspRuntimeContext(context, options);\n        if (config.getInitParameter(\"jspFile\") != null) {\n            jspFile = config.getInitParameter(\"jspFile\");\n            try {\n                if (null == context.getResource(jspFile)) {\n                    return;\n                }\n            } catch (MalformedURLException e) {\n                throw new ServletException(\"Can not locate jsp file\", e);\n            }\n            try {\n                if (SecurityUtil.isPackageProtectionEnabled()){\n                   AccessController.doPrivileged(new PrivilegedExceptionAction<Object>(){\n                        @Override\n                        public Object run() throws IOException, ServletException {\n                            serviceJspFile(null, null, jspFile, true);\n                            return null;\n                        }\n                    });\n                } else {\n                    serviceJspFile(null, null, jspFile, true);\n                }\n            } catch (IOException e) {\n                throw new ServletException(\"Could not precompile jsp: \" + jspFile, e);\n            } catch (PrivilegedActionException e) {\n                Throwable t = e.getCause();\n                if (t instanceof ServletException) throw (ServletException)t;\n                throw new ServletException(\"Could not precompile jsp: \" + jspFile, e);\n// fix_end\n// fix_start\n        if (log.isDebugEnabled()) {\n            log.debug(Localizer.getMessage(\"jsp.message.scratch.dir.is\",\n                    options.getScratchDir().toString()));\n            log.debug(Localizer.getMessage(\"jsp.message.dont.modify.servlets\"));\n// fix_end\n", "cwe": "NVD-CWE-noinfo", "cwe_name": "", "idx": 101781}
{"source": "// bug_start\nprivate void renewSeedInternal() {\n        String currentSeed = this.seed;\n        String newSeed = currentSeed;\n        while (Objects.equals(newSeed, currentSeed)) {\n            newSeed = new String(Hex.encodeHex(RANDOM.generateSeed(SEED_NUM_BYTES)));\n// bug_end\n         }\n// bug_start\n        this.seed = newSeed;\n// bug_end\n     }\n \n", "target": "// fix_start\nprivate void prepareRequest() throws IOException {\n\n        contentDelimitation = false;\n\n        if (endpoint.isSSLEnabled()) {\n            request.scheme().setString(\"https\");\n// fix_end\n// fix_start\n\n        MimeHeaders headers = request.getMimeHeaders();\n\n        MessageBytes connectionValueMB = headers.getValue(Constants.CONNECTION);\n        if (connectionValueMB != null && !connectionValueMB.isNull()) {\n            Set<String> tokens = new HashSet<>();\n            TokenList.parseTokenList(headers.values(Constants.CONNECTION), tokens);\n            if (tokens.contains(Constants.CLOSE)) {\n                keepAlive = false;\n            } else if (tokens.contains(Constants.KEEP_ALIVE_HEADER_VALUE_TOKEN)) {\n                keepAlive = true;\n            }\n        }\n\n        if (http11) {\n            MessageBytes expectMB = headers.getValue(\"expect\");\n            if (expectMB != null && !expectMB.isNull()) {\n                if (expectMB.toString().trim().equalsIgnoreCase(\"100-continue\")) {\n                    inputBuffer.setSwallowInput(false);\n                    request.setExpectation(true);\n                } else {\n                    response.setStatus(HttpServletResponse.SC_EXPECTATION_FAILED);\n                    setErrorState(ErrorState.CLOSE_CLEAN, null);\n                }\n            }\n        }\n\n        if (restrictedUserAgents != null && (http11 || keepAlive)) {\n            MessageBytes userAgentValueMB = headers.getValue(\"user-agent\");\n            if(userAgentValueMB != null && !userAgentValueMB.isNull()) {\n                String userAgentValue = userAgentValueMB.toString();\n                if (restrictedUserAgents != null &&\n                        restrictedUserAgents.matcher(userAgentValue).matches()) {\n                    http11 = false;\n                    keepAlive = false;\n                }\n            }\n        }\n\n\n        MessageBytes hostValueMB = null;\n        try {\n            hostValueMB = headers.getUniqueValue(\"host\");\n        } catch (IllegalArgumentException iae) {\n            badRequest(\"http11processor.request.multipleHosts\");\n        }\n        if (http11 && hostValueMB == null) {\n            badRequest(\"http11processor.request.noHostHeader\");\n        }\n\n        ByteChunk uriBC = request.requestURI().getByteChunk();\n        byte[] uriB = uriBC.getBytes();\n        if (uriBC.startsWithIgnoreCase(\"http\", 0)) {\n            int pos = 4;\n            if (uriBC.startsWithIgnoreCase(\"s\", pos)) {\n                pos++;\n            }\n            if (uriBC.startsWith(\"://\", pos)) {\n                pos += 3;\n                int uriBCStart = uriBC.getStart();\n\n                int slashPos = uriBC.indexOf('/', pos);\n                int atPos = uriBC.indexOf('@', pos);\n                if (slashPos > -1 && atPos > slashPos) {\n                    atPos = -1;\n                }\n\n                if (slashPos == -1) {\n                    slashPos = uriBC.getLength();\n                    request.requestURI().setBytes(uriB, uriBCStart + 6, 1);\n                } else {\n                    request.requestURI().setBytes(uriB, uriBCStart + slashPos, uriBC.getLength() - slashPos);\n                }\n\n                if (atPos != -1) {\n                    for (; pos < atPos; pos++) {\n                        byte c = uriB[uriBCStart + pos];\n                        if (!HttpParser.isUserInfo(c)) {\n                            badRequest(\"http11processor.request.invalidUserInfo\");\n                            break;\n                        }\n                    }\n                    pos = atPos + 1;\n                }\n\n                if (http11) {\n                    if (hostValueMB != null) {\n                        if (!hostValueMB.getByteChunk().equals(\n                                uriB, uriBCStart + pos, slashPos - pos)) {\n                            if (protocol.getAllowHostHeaderMismatch()) {\n                                hostValueMB = headers.setValue(\"host\");\n                                hostValueMB.setBytes(uriB, uriBCStart + pos, slashPos - pos);\n                            } else {\n                                badRequest(\"http11processor.request.inconsistentHosts\");\n                            }\n                        }\n                    }\n                } else {\n                    try {\n                        hostValueMB = headers.setValue(\"host\");\n                        hostValueMB.setBytes(uriB, uriBCStart + pos, slashPos - pos);\n                    } catch (IllegalStateException e) {\n                    }\n                }\n            } else {\n                badRequest(\"http11processor.request.invalidScheme\");\n            }\n        }\n\n        for (int i = uriBC.getStart(); i < uriBC.getEnd(); i++) {\n            if (!httpParser.isAbsolutePathRelaxed(uriB[i])) {\n                badRequest(\"http11processor.request.invalidUri\");\n                break;\n            }\n        }\n\n        InputFilter[] inputFilters = inputBuffer.getFilters();\n\n        if (!http09) {\n            MessageBytes transferEncodingValueMB = headers.getValue(\"transfer-encoding\");\n            if (transferEncodingValueMB != null) {\n                List<String> encodingNames = new ArrayList<>();\n                if (TokenList.parseTokenList(headers.values(\"transfer-encoding\"), encodingNames)) {\n                    for (String encodingName : encodingNames) {\n                        addInputFilter(inputFilters, encodingName);\n                    }\n                } else {\n                    badRequest(\"http11processor.request.invalidTransferEncoding\");\n                }\n            }\n        }\n\n        long contentLength = -1;\n        try {\n            contentLength = request.getContentLengthLong();\n        } catch (NumberFormatException e) {\n            badRequest(\"http11processor.request.nonNumericContentLength\");\n        } catch (IllegalArgumentException e) {\n            badRequest(\"http11processor.request.multipleContentLength\");\n        }\n        if (contentLength >= 0) {\n            if (contentDelimitation) {\n                headers.removeHeader(\"content-length\");\n                request.setContentLength(-1);\n                keepAlive = false;\n            } else {\n                inputBuffer.addActiveFilter(inputFilters[Constants.IDENTITY_FILTER]);\n                contentDelimitation = true;\n            }\n        }\n\n        parseHost(hostValueMB);\n\n        if (!contentDelimitation) {\n            inputBuffer.addActiveFilter(inputFilters[Constants.VOID_FILTER]);\n            contentDelimitation = true;\n        }\n\n        if (!getErrorState().isIoAllowed()) {\n            getAdapter().log(request, response, 0);\n        }\n// fix_end\n", "cwe": "CWE-444", "cwe_name": "Inconsistent Interpretation of HTTP Requests ('HTTP Request Smuggling')", "idx": 55774}
{"source": "// bug_start\n@Nullable\n  SearchResult getLdapUserObject(BasicAuthLDAPConfig ldapConfig, DirContext context, String username)\n  {\n    try {\n      SearchControls sc = new SearchControls();\n      sc.setSearchScope(SearchControls.SUBTREE_SCOPE);\n      sc.setReturningAttributes(new String[] {ldapConfig.getUserAttribute(), \"memberOf\" });\n      NamingEnumeration<SearchResult> results = context.search(\n          ldapConfig.getBaseDn(),\n          StringUtils.format(ldapConfig.getUserSearch(), username),\n          sc);\n      try {\n        if (!results.hasMore()) {\n          return null;\n// bug_end\n         }\n// bug_start\n        return results.next();\n      }\n      finally {\n        results.close();\n      }\n// bug_end\n     }\n// bug_start\n    catch (NamingException e) {\n      LOG.debug(e, \"Unable to find user '%s'\", username);\n      return null;\n    }\n  }\n// bug_end\n \n", "target": "// fix_start\nprivate void renewSeedInternal() {\n        String currentSeed = this.seed;\n        String newSeed = currentSeed;\n        byte[] bytes = new byte[SEED_NUM_BYTES];\n        while (Objects.equals(newSeed, currentSeed)) {\n            RANDOM.nextBytes(bytes);\n            newSeed = new String(Hex.encodeHex(bytes));\n// fix_end\n// fix_start\n        this.seed = newSeed;\n// fix_end\n// fix_start\n// fix_end\n", "cwe": "NVD-CWE-Other", "cwe_name": "Other", "idx": 110755}
{"source": "// bug_start\n@Override\n        public void doFilter(final ServletRequest req, final ServletResponse resp, final FilterChain filterChain)\n                throws IOException, ServletException {\n// bug_end\n \n// bug_start\n            final HttpServletResponse response = (HttpServletResponse) resp;\n            response.setHeader(FRAME_OPTIONS, SAME_ORIGIN);\n\n            filterChain.doFilter(req, resp);\n        }\n\n// bug_end\n", "target": "// fix_start\n@Nullable\n  SearchResult getLdapUserObject(BasicAuthLDAPConfig ldapConfig, DirContext context, String username)\n  {\n    try {\n      SearchControls sc = new SearchControls();\n      sc.setSearchScope(SearchControls.SUBTREE_SCOPE);\n      sc.setReturningAttributes(new String[] {ldapConfig.getUserAttribute(), \"memberOf\" });\n      String encodedUsername = encodeForLDAP(username, true);\n      NamingEnumeration<SearchResult> results = context.search(\n          ldapConfig.getBaseDn(),\n          StringUtils.format(ldapConfig.getUserSearch(), encodedUsername),\n          sc);\n      try {\n        if (!results.hasMore()) {\n          return null;\n        }\n        return results.next();\n      }\n      finally {\n        results.close();\n      }\n    }\n    catch (NamingException e) {\n      LOG.debug(e, \"Unable to find user '%s'\", username);\n      return null;\n    }\n  }\n// fix_end\n", "cwe": "CWE-74", "cwe_name": "Improper Neutralization of Special Elements in Output Used by a Downstream Component ('Injection')", "idx": 73454}
{"source": "// bug_start\n@Override\n        public void doFilter(final ServletRequest req, final ServletResponse resp, final FilterChain filterChain)\n                throws IOException, ServletException {\n// bug_end\n \n// bug_start\n            final HttpServletResponse response = (HttpServletResponse) resp;\n            response.addHeader(FRAME_OPTIONS, SAME_ORIGIN);\n\n            filterChain.doFilter(req, resp);\n        }\n\n// bug_end\n", "target": "// fix_start\npublic ResourceInvoker match(HttpRequest request, int start)\n   {\n      if (!CACHE || (request.getHttpHeaders().getMediaType() !=null && !request.getHttpHeaders().getMediaType().getParameters().isEmpty())) {\n         return root.match(request, start).invoker;\n      }\n      MatchCache.Key key = new MatchCache.Key(request, start);\n      MatchCache match = cache.get(key);\n      if (match != null) {\n         request.setAttribute(RESTEASY_CHOSEN_ACCEPT, match.chosen);\n      } else {\n         match = root.match(request, start);\n         if (match.match != null && match.match.expression.getNumGroups() == 0 && match.invoker instanceof ResourceMethodInvoker) {\n            match.match = null;\n            if (cache.size() >= CACHE_SIZE) {\n               cache.clear();\n            }\n            cache.putIfAbsent(key, match);\n         }\n      }\n      return match.invoker;\n   }\n// fix_end\n", "cwe": "CWE-1021", "cwe_name": "Improper Restriction of Rendered UI Layers or Frames", "idx": 27}
{"source": "// bug_start\npublic ResourceInvoker match(HttpRequest request, int start)\n   {\n      if (!CACHE) {\n         return root.match(request, start).invoker;\n      }\n      MatchCache.Key key = new MatchCache.Key(request, start);\n      MatchCache match = cache.get(key);\n      if (match != null) {\n         request.setAttribute(RESTEASY_CHOSEN_ACCEPT, match.chosen);\n      } else {\n         match = root.match(request, start);\n         if (match.match != null && match.match.expression.getNumGroups() == 0 && match.invoker instanceof ResourceMethodInvoker) {\n            match.match = null;\n            cache.putIfAbsent(key, match);\n         }\n      }\n      return match.invoker;\n   }\n// bug_end\n \n", "target": "// fix_start\npublic static ListBoxModel doFillCredentialsIdItems(ItemGroup context) {\n        AbstractIdCredentialsListBoxModel result = new StandardListBoxModel().includeEmptyValue();\n        if (hasPermission(context)) {\n            result = result.withMatching(\n                            CredentialsMatchers.always(),\n                            CredentialsProvider.lookupCredentials(AmazonWebServicesCredentials.class,\n                                    context,\n                                    ACL.SYSTEM,\n                                    Collections.EMPTY_LIST));\n        }\n        return result;\n    }\n// fix_end\n", "cwe": "NVD-CWE-Other", "cwe_name": "Other", "idx": 115267}
{"source": "// bug_start\npublic static ListBoxModel doFillCredentialsIdItems(ItemGroup context) {\n        return new StandardListBoxModel()\n                .withEmptySelection()\n                .withMatching(\n                        CredentialsMatchers.always(),\n                        CredentialsProvider.lookupCredentials(AmazonWebServicesCredentials.class,\n                                context,\n                                ACL.SYSTEM,\n                                Collections.EMPTY_LIST));\n// bug_end\n     }\n \n", "target": "// fix_start\nprivate static byte[] getRandomKey(List<String> dataRefURIs, Document doc, WSDocInfo wsDocInfo) throws WSSecurityException {\n        try {\n            String alg = \"AES\";\n            int size = 128;\n            if (!dataRefURIs.isEmpty()) {\n                String uri = dataRefURIs.iterator().next();\n                Element ee = ReferenceListProcessor.findEncryptedDataElement(doc, wsDocInfo, uri);\n                String algorithmURI = X509Util.getEncAlgo(ee);\n                alg = JCEMapper.getJCEKeyAlgorithmFromURI(algorithmURI);\n                size = KeyUtils.getKeyLength(algorithmURI);\n            }\n            KeyGenerator kgen = KeyGenerator.getInstance(alg);\n            kgen.init(size * 8);\n            SecretKey k = kgen.generateKey();\n            return k.getEncoded();\n        } catch (Exception ex) {\n            throw new WSSecurityException(WSSecurityException.ErrorCode.FAILED_CHECK, ex);\n        }\n// fix_end\n", "cwe": "CWE-862", "cwe_name": "Missing Authorization", "idx": 85425}
{"source": "// bug_start\nprivate User createAccount(StaplerRequest req, StaplerResponse rsp, boolean selfRegistration, String formView) throws ServletException, IOException {\n        SignupInfo si = new SignupInfo(req);\n\n        if(selfRegistration && !validateCaptcha(si.captcha))\n            si.errorMessage = Messages.HudsonPrivateSecurityRealm_CreateAccount_TextNotMatchWordInImage();\n\n        if(si.password1 != null && !si.password1.equals(si.password2))\n            si.errorMessage = Messages.HudsonPrivateSecurityRealm_CreateAccount_PasswordNotMatch();\n\n        if(!(si.password1 != null && si.password1.length() != 0))\n            si.errorMessage = Messages.HudsonPrivateSecurityRealm_CreateAccount_PasswordRequired();\n\n        if(si.username==null || si.username.length()==0)\n            si.errorMessage = Messages.HudsonPrivateSecurityRealm_CreateAccount_UserNameRequired();\n        else if(!containsOnlyAcceptableCharacters(si.username))\n            if(ID_REGEX == null){\n                si.errorMessage = Messages.HudsonPrivateSecurityRealm_CreateAccount_UserNameInvalidCharacters();\n            }else{\n                si.errorMessage = Messages.HudsonPrivateSecurityRealm_CreateAccount_UserNameInvalidCharactersCustom(ID_REGEX);\n// bug_end\n             }\n// bug_start\n        else {\n            User user = User.getById(si.username, false);\n            if (null != user)\n                if (user.getProperty(Details.class) != null)\n                    si.errorMessage = Messages.HudsonPrivateSecurityRealm_CreateAccount_UserNameAlreadyTaken();\n        }\n\n        if(si.fullname==null || si.fullname.length()==0)\n            si.fullname = si.username;\n\n        if(isMailerPluginPresent() && (si.email==null || !si.email.contains(\"@\")))\n            si.errorMessage = Messages.HudsonPrivateSecurityRealm_CreateAccount_InvalidEmailAddress();\n\n        if (! User.isIdOrFullnameAllowed(si.username)) {\n            si.errorMessage = hudson.model.Messages.User_IllegalUsername(si.username);\n        }\n\n        if (! User.isIdOrFullnameAllowed(si.fullname)) {\n            si.errorMessage = hudson.model.Messages.User_IllegalFullname(si.fullname);\n        }\n\n        if(si.errorMessage!=null) {\n            req.setAttribute(\"data\",si);\n            req.getView(this, formView).forward(req,rsp);\n            return null;\n        }\n\n        User user = createAccount(si.username,si.password1);\n        user.setFullName(si.fullname);\n        if(isMailerPluginPresent()) {\n// bug_end\n             try {\n// bug_start\n                Class<?> up = Jenkins.getInstance().pluginManager.uberClassLoader.loadClass(\"hudson.tasks.Mailer$UserProperty\");\n                Constructor<?> c = up.getDeclaredConstructor(String.class);\n                user.addProperty((UserProperty)c.newInstance(si.email));\n            } catch (ReflectiveOperationException e) {\n                throw new RuntimeException(e);\n// bug_end\n             }\n         }\n// bug_start\n        user.save();\n        return user;\n// bug_end\n     }\n \n", "target": "// fix_start\nprivate static byte[] getRandomKey(List<String> dataRefURIs, Document doc, WSDocInfo wsDocInfo) throws WSSecurityException {\n        try {\n            String alg = \"AES\";\n            int size = 16;\n            if (!dataRefURIs.isEmpty()) {\n                String uri = dataRefURIs.iterator().next();\n                Element ee = ReferenceListProcessor.findEncryptedDataElement(doc, wsDocInfo, uri);\n                String algorithmURI = X509Util.getEncAlgo(ee);\n                alg = JCEMapper.getJCEKeyAlgorithmFromURI(algorithmURI);\n                size = KeyUtils.getKeyLength(algorithmURI);\n// fix_end\n// fix_start\n            KeyGenerator kgen = KeyGenerator.getInstance(alg);\n            kgen.init(size * 8);\n            SecretKey k = kgen.generateKey();\n            return k.getEncoded();\n        } catch (Throwable ex) {\n// fix_end\n// fix_start\n                KeyGenerator kgen = KeyGenerator.getInstance(\"AES\");\n                kgen.init(128);\n                SecretKey k = kgen.generateKey();\n                return k.getEncoded();\n            } catch (NoSuchAlgorithmException e) {\n                throw new WSSecurityException(WSSecurityException.ErrorCode.FAILED_CHECK, e);\n// fix_end\n// fix_start\n// fix_end\n", "cwe": "CWE-327", "cwe_name": "Use of a Broken or Risky Cryptographic Algorithm", "idx": 42559}
{"source": "// bug_start\nprivate User createAccount(StaplerRequest req, StaplerResponse rsp, boolean selfRegistration, String formView) throws ServletException, IOException {\n        SignupInfo si = new SignupInfo(req);\n// bug_end\n \n// bug_start\n        if(selfRegistration && !validateCaptcha(si.captcha))\n            si.errorMessage = Messages.HudsonPrivateSecurityRealm_CreateAccount_TextNotMatchWordInImage();\n// bug_end\n \n// bug_start\n        if(si.password1 != null && !si.password1.equals(si.password2))\n            si.errorMessage = Messages.HudsonPrivateSecurityRealm_CreateAccount_PasswordNotMatch();\n// bug_end\n \n// bug_start\n        if(!(si.password1 != null && si.password1.length() != 0))\n            si.errorMessage = Messages.HudsonPrivateSecurityRealm_CreateAccount_PasswordRequired();\n// bug_end\n \n// bug_start\n        if(si.username==null || si.username.length()==0)\n            si.errorMessage = Messages.HudsonPrivateSecurityRealm_CreateAccount_UserNameRequired();\n        else {\n            User user = User.getById(si.username, false);\n            if (null != user)\n                if (user.getProperty(Details.class) != null)\n                    si.errorMessage = Messages.HudsonPrivateSecurityRealm_CreateAccount_UserNameAlreadyTaken();\n// bug_end\n         }\n \n// bug_start\n        if(si.fullname==null || si.fullname.length()==0)\n            si.fullname = si.username;\n\n        if(isMailerPluginPresent() && (si.email==null || !si.email.contains(\"@\")))\n            si.errorMessage = Messages.HudsonPrivateSecurityRealm_CreateAccount_InvalidEmailAddress();\n\n        if (! User.isIdOrFullnameAllowed(si.username)) {\n            si.errorMessage = hudson.model.Messages.User_IllegalUsername(si.username);\n// bug_end\n         }\n \n// bug_start\n        if (! User.isIdOrFullnameAllowed(si.fullname)) {\n            si.errorMessage = hudson.model.Messages.User_IllegalFullname(si.fullname);\n// bug_end\n         }\n// bug_start\n\n        if(si.errorMessage!=null) {\n            req.setAttribute(\"data\",si);\n            req.getView(this, formView).forward(req,rsp);\n            return null;\n        }\n\n        User user = createAccount(si.username,si.password1);\n        user.setFullName(si.fullname);\n        if(isMailerPluginPresent()) {\n            try {\n                Class<?> up = Jenkins.getInstance().pluginManager.uberClassLoader.loadClass(\"hudson.tasks.Mailer$UserProperty\");\n                Constructor<?> c = up.getDeclaredConstructor(String.class);\n                user.addProperty((UserProperty)c.newInstance(si.email));\n            } catch (ReflectiveOperationException e) {\n                throw new RuntimeException(e);\n            }\n        }\n        user.save();\n        return user;\n// bug_end\n     }\n \n", "target": "// fix_start\nprivate Optional<Style> tryLoadSLD(\n            final byte[] bytes, final Integer styleIndex,\n            final ClientHttpRequestFactory clientHttpRequestFactory) {\n        Assert.isTrue(styleIndex == null || styleIndex > -1,\n                      \"styleIndex must be > -1 but was: \" + styleIndex);\n// fix_end\n// fix_start\n        final Style[] styles;\n        try {\n// fix_end\n// fix_start\n            DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();\n            dbf.setNamespaceAware(true);\n            dbf.setFeature(\"http://apache.org/xml/features/disallow-doctype-decl\", true);\n            DocumentBuilder db = dbf.newDocumentBuilder();\n            db.setErrorHandler(new ErrorHandler());\n            db.parse(new ByteArrayInputStream(bytes));\n// fix_end\n// fix_start\n            final SLDParser sldParser = new SLDParser(CommonFactoryFinder.getStyleFactory());\n            sldParser.setOnLineResourceLocator(new DefaultResourceLocator() {\n                @Override\n                public URL locateResource(final String uri) {\n                    try {\n                        final URL theUrl = super.locateResource(uri);\n                        final URI theUri;\n                        if (theUrl != null) {\n                            theUri = theUrl.toURI();\n                        } else {\n                            theUri = URI.create(uri);\n                        }\n                        if (theUri.getScheme().startsWith(\"http\")) {\n                            final ClientHttpRequest request = clientHttpRequestFactory.createRequest(\n                                    theUri, HttpMethod.GET);\n                            return request.getURI().toURL();\n                        }\n                        return null;\n                    } catch (IOException | URISyntaxException e) {\n                        return null;\n                    }\n                }\n            });\n            sldParser.setInput(new ByteArrayInputStream(bytes));\n            styles = sldParser.readXML();\n// fix_end\n// fix_start\n        } catch (Throwable e) {\n            return Optional.empty();\n// fix_end\n// fix_start\n        if (styleIndex != null) {\n            Assert.isTrue(styleIndex < styles.length, String.format(\"There where %s styles in file but \" +\n                                                                            \"requested index was: %s\",\n                                                                    styles.length, styleIndex + 1));\n        } else {\n            Assert.isTrue(styles.length < 2, String.format(\"There are %s therefore the styleRef must \" +\n                                                                   \"contain an index identifying the style.\" +\n                                                                   \"  The index starts at 1 for the first \" +\n                                                                   \"style.\\n\" +\n                                                                   \"\\tExample: thinline.sld##1\",\n                                                           styles.length));\n// fix_end\n// fix_start\n        if (styleIndex == null) {\n            return Optional.of(styles[0]);\n        } else {\n            return Optional.of(styles[styleIndex]);\n// fix_end\n// fix_start\n// fix_end\n", "cwe": "CWE-74", "cwe_name": "Improper Neutralization of Special Elements in Output Used by a Downstream Component ('Injection')", "idx": 73232}
{"source": "// bug_start\nprivate Optional<Style> tryLoadSLD(\n            final byte[] bytes, final Integer styleIndex,\n            final ClientHttpRequestFactory clientHttpRequestFactory) {\n        Assert.isTrue(styleIndex == null || styleIndex > -1,\n                      \"styleIndex must be > -1 but was: \" + styleIndex);\n\n        final Style[] styles;\n        try {\n\n            DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();\n            dbf.setNamespaceAware(true);\n            DocumentBuilder db = dbf.newDocumentBuilder();\n            db.setErrorHandler(new ErrorHandler());\n            db.parse(new ByteArrayInputStream(bytes));\n\n            final SLDParser sldParser = new SLDParser(CommonFactoryFinder.getStyleFactory());\n            sldParser.setOnLineResourceLocator(new DefaultResourceLocator() {\n                @Override\n                public URL locateResource(final String uri) {\n                    try {\n                        final URL theUrl = super.locateResource(uri);\n                        final URI theUri;\n                        if (theUrl != null) {\n                            theUri = theUrl.toURI();\n                        } else {\n                            theUri = URI.create(uri);\n                        }\n                        if (theUri.getScheme().startsWith(\"http\")) {\n                            final ClientHttpRequest request = clientHttpRequestFactory.createRequest(\n                                    theUri, HttpMethod.GET);\n                            return request.getURI().toURL();\n                        }\n                        return null;\n                    } catch (IOException | URISyntaxException e) {\n                        return null;\n                    }\n                }\n            });\n            sldParser.setInput(new ByteArrayInputStream(bytes));\n            styles = sldParser.readXML();\n\n        } catch (Throwable e) {\n            return Optional.empty();\n// bug_end\n         }\n \n// bug_start\n        if (styleIndex != null) {\n            Assert.isTrue(styleIndex < styles.length, String.format(\"There where %s styles in file but \" +\n                                                                            \"requested index was: %s\",\n                                                                    styles.length, styleIndex + 1));\n        } else {\n            Assert.isTrue(styles.length < 2, String.format(\"There are %s therefore the styleRef must \" +\n                                                                   \"contain an index identifying the style.\" +\n                                                                   \"  The index starts at 1 for the first \" +\n                                                                   \"style.\\n\" +\n                                                                   \"\\tExample: thinline.sld##1\",\n                                                           styles.length));\n// bug_end\n         }\n \n// bug_start\n        if (styleIndex == null) {\n            return Optional.of(styles[0]);\n        } else {\n            return Optional.of(styles[styleIndex]);\n        }\n// bug_end\n     }\n \n", "target": "// fix_start\nstatic public File allocateFile(File dir, String name) {\n        int q = name.indexOf('?');\n        if (q > 0) {\n            name = name.substring(0, q);\n// fix_end\n// fix_start\n        File file = new File(dir, name);\n\n        int dot = name.indexOf('.');\n        String prefix = dot < 0 ? name : name.substring(0, dot);\n        String suffix = dot < 0 ? \"\" : name.substring(dot);\n        int index = 2;\n        while (file.exists()) {\n            file = new File(dir, prefix + \"-\" + index++ + suffix);\n// fix_end\n// fix_start\n        file.getParentFile().mkdirs();\n\n        return file;\n// fix_end\n", "cwe": "CWE-611", "cwe_name": "Improper Restriction of XML External Entity Reference ('XXE')", "idx": 67342}
{"source": "// bug_start\nprivate static AbstractVariableEvaluationContextPostProcessor createPostProcessor(\n\t\t\tObject request) {\n\t\tif (request instanceof AntPathRequestMatcher) {\n\t\t\treturn new AntPathMatcherEvaluationContextPostProcessor(\n\t\t\t\t\t(AntPathRequestMatcher) request);\n\t\t}\n\t\treturn null;\n\t}\n// bug_end\n \n", "target": "// fix_start\nstatic public File allocateFile(File dir, String name) {\n        int q = name.indexOf('?');\n        if (q > 0) {\n            name = name.substring(0, q);\n        }\n// fix_end\n// fix_start\n        File file = new File(dir, name);\n        if (!file.toPath().normalize().startsWith(dir.toPath().normalize())) {\n        \tthrow new IllegalArgumentException(\"Zip archives with files escaping their root directory are not allowed.\");\n        }\n\n        int dot = name.indexOf('.');\n        String prefix = dot < 0 ? name : name.substring(0, dot);\n        String suffix = dot < 0 ? \"\" : name.substring(dot);\n        int index = 2;\n        while (file.exists()) {\n            file = new File(dir, prefix + \"-\" + index++ + suffix);\n        }\n\n        file.getParentFile().mkdirs();\n\n        return file;\n    }\n\n// fix_end\n", "cwe": "CWE-22", "cwe_name": "Path Traversal", "idx": 25761}
{"source": "// bug_start\nprotected boolean evaluate(InputSource inputSource) {\n        try {\n            DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();\n            factory.setFeature(\"http://xml.org/sax/features/external-general-entities\", false);\n            factory.setFeature(\"http://xml.org/sax/features/external-parameter-entities\", false);\n            factory.setFeature(\"http://apache.org/xml/features/disallow-doctype-decl\", true);\n            setupFeatures(factory);\n            factory.setNamespaceAware(true);\n            factory.setIgnoringElementContentWhitespace(true);\n            factory.setIgnoringComments(true);\n            DocumentBuilder dbuilder = factory.newDocumentBuilder();\n            Document doc = dbuilder.parse(inputSource);\n// bug_end\n \n// bug_start\n\n            CachedXPathAPI cachedXPathAPI = new CachedXPathAPI();\n            XObject result = cachedXPathAPI.eval(doc, xpath);\n            if (result.bool())\n            \treturn true;\n            else {\n            \tNodeIterator iterator = cachedXPathAPI.selectNodeIterator(doc, xpath);\n            \treturn (iterator.nextNode() != null);\n            }\n\n        } catch (Throwable e) {\n            return false;\n        }\n    }\n\n// bug_end\n", "target": "// fix_start\nprivate static AbstractVariableEvaluationContextPostProcessor createPostProcessor(\n\t\t\tObject request) {\n\t\tif (request instanceof AntPathRequestMatcher) {\n\t\t\treturn new AntPathMatcherEvaluationContextPostProcessor(\n\t\t\t\t\t(AntPathRequestMatcher) request);\n\t\t}\n\t\tif (request instanceof RequestVariablesExtractor) {\n\t\t\treturn new RequestVariablesExtractorEvaluationContextPostProcessor(\n\t\t\t\t\t(RequestVariablesExtractor) request);\n\t\t}\n\t\treturn null;\n\t}\n// fix_end\n", "cwe": "CWE-20", "cwe_name": "Improper Input Validation", "idx": 12065}
{"source": "// bug_start\nprotected boolean evaluate(InputSource inputSource) {\n        try {\n            DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();\n            factory.setNamespaceAware(true);\n            DocumentBuilder dbuilder = factory.newDocumentBuilder();\n            Document doc = dbuilder.parse(inputSource);\n// bug_end\n \n// bug_start\n// bug_end\n \n// bug_start\n            CachedXPathAPI cachedXPathAPI = new CachedXPathAPI();\n            XObject result = cachedXPathAPI.eval(doc, xpath);\n            if (result.bool())\n            \treturn true;\n            else {\n            \tNodeIterator iterator = cachedXPathAPI.selectNodeIterator(doc, xpath);\n            \treturn (iterator.nextNode() != null);\n// bug_end\n             }\n// bug_start\n// bug_end\n \n// bug_start\n        } catch (Throwable e) {\n            return false;\n// bug_end\n         }\n     }\n \n", "target": "// fix_start\nprivate static void assertSendsCorrectly(final byte[] sourceBytes, SSLEngine source,\n            SSLEngine dest, boolean needsRecordSplit) throws SSLException {\n        ByteBuffer sourceOut = ByteBuffer.wrap(sourceBytes);\n        SSLSession sourceSession = source.getSession();\n        ByteBuffer sourceToDest = ByteBuffer.allocate(sourceSession.getPacketBufferSize());\n        SSLEngineResult sourceOutRes = source.wrap(sourceOut, sourceToDest);\n        sourceToDest.flip();\n// fix_end\n// fix_start\n        String sourceCipherSuite = source.getSession().getCipherSuite();\n        assertEquals(sourceCipherSuite, sourceBytes.length, sourceOutRes.bytesConsumed());\n        assertEquals(sourceCipherSuite, HandshakeStatus.NOT_HANDSHAKING,\n                sourceOutRes.getHandshakeStatus());\n// fix_end\n// fix_start\n        SSLSession destSession = dest.getSession();\n        ByteBuffer destIn = ByteBuffer.allocate(destSession.getApplicationBufferSize());\n\n        int numUnwrapCalls = 0;\n        while (destIn.position() != sourceOut.limit()) {\n            SSLEngineResult destRes = dest.unwrap(sourceToDest, destIn);\n            assertEquals(sourceCipherSuite, HandshakeStatus.NOT_HANDSHAKING,\n                    destRes.getHandshakeStatus());\n            if (needsRecordSplit && numUnwrapCalls == 0) {\n                assertEquals(sourceCipherSuite, 1, destRes.bytesProduced());\n// fix_end\n// fix_start\n            numUnwrapCalls++;\n        }\n// fix_end\n// fix_start\n        destIn.flip();\n        byte[] actual = new byte[destIn.remaining()];\n        destIn.get(actual);\n        assertEquals(sourceCipherSuite, Arrays.toString(sourceBytes), Arrays.toString(actual));\n\n        if (needsRecordSplit) {\n            assertEquals(sourceCipherSuite, 2, numUnwrapCalls);\n        } else {\n            assertEquals(sourceCipherSuite, 1, numUnwrapCalls);\n            assertSendsCorrectlyWhenSplit(sourceBytes, source, dest);\n// fix_end\n", "cwe": "CWE-611", "cwe_name": "Improper Restriction of XML External Entity Reference ('XXE')", "idx": 66015}
{"source": "// bug_start\nprivate static void assertSendsCorrectly(final byte[] sourceBytes, SSLEngine source,\n            SSLEngine dest, boolean needsRecordSplit) throws SSLException {\n        ByteBuffer sourceOut = ByteBuffer.wrap(sourceBytes);\n        SSLSession sourceSession = source.getSession();\n        ByteBuffer sourceToDest = ByteBuffer.allocate(sourceSession.getPacketBufferSize());\n        SSLEngineResult sourceOutRes = source.wrap(sourceOut, sourceToDest);\n        sourceToDest.flip();\n// bug_end\n \n// bug_start\n        String sourceCipherSuite = source.getSession().getCipherSuite();\n        assertEquals(sourceCipherSuite, sourceBytes.length, sourceOutRes.bytesConsumed());\n        assertEquals(sourceCipherSuite, HandshakeStatus.NOT_HANDSHAKING,\n                sourceOutRes.getHandshakeStatus());\n\n        SSLSession destSession = dest.getSession();\n        ByteBuffer destIn = ByteBuffer.allocate(destSession.getApplicationBufferSize());\n\n        int numUnwrapCalls = 0;\n        while (destIn.position() != sourceOut.limit()) {\n            SSLEngineResult destRes = dest.unwrap(sourceToDest, destIn);\n            assertEquals(sourceCipherSuite, HandshakeStatus.NOT_HANDSHAKING,\n                    destRes.getHandshakeStatus());\n            if (needsRecordSplit && numUnwrapCalls == 0) {\n                assertEquals(sourceCipherSuite, 1, destRes.bytesProduced());\n            }\n            numUnwrapCalls++;\n        }\n\n        destIn.flip();\n        byte[] actual = new byte[destIn.remaining()];\n        destIn.get(actual);\n        assertEquals(sourceCipherSuite, Arrays.toString(sourceBytes), Arrays.toString(actual));\n\n        if (needsRecordSplit) {\n            assertEquals(sourceCipherSuite, 2, numUnwrapCalls);\n        } else {\n            assertEquals(sourceCipherSuite, 1, numUnwrapCalls);\n// bug_end\n         }\n     }\n \n", "target": "// fix_start\nprivate int readEncryptedData(final ByteBuffer dst, final int pending) throws SSLException {\n        try {\n            int bytesRead = 0;\n            final int pos = dst.position();\n            if (dst.remaining() >= pending) {\n                final int limit = dst.limit();\n                final int len = min(pending, limit - pos);\n                if (dst.isDirect()) {\n                    bytesRead = readEncryptedDataDirect(dst, pos, len);\n                    if (bytesRead > 0) {\n                        dst.position(pos + bytesRead);\n                    }\n                } else {\n                    bytesRead = readEncryptedDataHeap(dst, len);\n                }\n            }\n// fix_end\n// fix_start\n            return bytesRead;\n        } catch (Exception e) {\n            throw convertException(e);\n// fix_end\n", "cwe": "NVD-CWE-noinfo", "cwe_name": "", "idx": 102248}
{"source": "// bug_start\nprivate int readEncryptedData(final ByteBuffer dst, final int pending) throws SSLException {\n        try {\n            int bytesRead = 0;\n            final int pos = dst.position();\n            if (dst.remaining() >= pending) {\n                final int limit = dst.limit();\n                final int len = min(pending, limit - pos);\n                if (dst.isDirect()) {\n                    bytesRead = readEncryptedDataDirect(dst, pos, len);\n                    if (bytesRead > 0) {\n                        dst.position(pos + bytesRead);\n                    }\n                } else {\n                    bytesRead = readEncryptedDataHeap(dst, pos, len);\n                }\n            }\n// bug_end\n \n// bug_start\n            return bytesRead;\n        } catch (Exception e) {\n            throw convertException(e);\n// bug_end\n         }\n     }\n \n", "target": "// fix_start\npublic QName get(String qualifiedName, String uri) {\n        int index = qualifiedName.indexOf(':');\n// fix_end\n// fix_start\n        if (index < 0) {\n            return get(qualifiedName, Namespace.get(uri));\n        } else {\n            String name = qualifiedName.substring(index + 1);\n            String prefix = qualifiedName.substring(0, index);\n\n            return get(name, Namespace.get(prefix, uri));\n// fix_end\n", "cwe": "NVD-CWE-noinfo", "cwe_name": "", "idx": 97862}
{"source": "// bug_start\npublic static void main(String[] args) throws Exception {\n                System.out.println(\"_________________________________________________\");\n                System.out.println(\"Configure options using uddi.xml and tck.properties\");\n                System.out.println(\"java -Duddi.client.xml=uddi.xml -jar juddi-tck-runner-{VERSION}-SNAPSHOT-jar-with-dependencies.jar\");\n                System.out.println(\"_________________________________________________\");\n                System.out.println();\n                System.out.println(\"Options\");\n                System.out.println(\"-Dtests=TestClass1,TestClass2    Comma delimited set of focused tests to run\");\n                System.out.println(\"_________________________________________________\");\n                System.out.println(\"Running! this can take anywhere from 2-5 minutes!\");\n                System.out.println(\"\");\n                if (!new File(\"tck.properties\").exists()) {\n                        System.out.println(\"tck.properties was not found! I give up!\");\n                        System.exit(1);\n                }\n                String s = System.getProperty(\"uddi.client.xml\");\n                if (s == null || !new File(s).exists()) {\n                        System.out.println(\"The value for option -Duddi.client.xml=\" + s + \" is either null or the file doesn't exist! I give up!\");\n                        System.exit(1);\n                }\n                String focusedTests = System.getProperty(\"tests\");\n                Result result = null;\n                JUnitCore junit = new JUnitCore();\n                Class[] cs = null;\n                if (focusedTests != null) {\n                        String[] items = focusedTests.split(\",\");\n                        cs = new Class[items.length];\n                        for (int i = 0; i < items.length; i++) {\n                                cs[i] = Class.forName(items[i]);\n                        }\n                } else {\n                        cs = new Class[]{\n                                org.apache.juddi.v2.tck.UDDI_020_TmodelIntegrationTest.class,\n                                org.apache.juddi.v2.tck.UDDI_030_BusinessEntityIntegrationTest.class,\n                                org.apache.juddi.v2.tck.UDDI_040_BusinessServiceIntegrationTest.class,\n                                org.apache.juddi.v2.tck.UDDI_050_BindingTemplateIntegrationTest.class,\n                                org.apache.juddi.v2.tck.UDDI_060_PublisherAssertionIntegrationTest.class,\n                                org.apache.juddi.v2.tck.UDDI_070_FindEntityIntegrationTest.class,\n                                org.apache.juddi.v3.bpel.BPEL_010_IntegrationTest.class,\n                                org.apache.juddi.v3.bpel.BPEL_020_IntegrationTest.class,\n                                org.apache.juddi.v3.tck.JUDDI_010_PublisherIntegrationTest.class,\n                                org.apache.juddi.v3.tck.JUDDI_100_ClientSubscriptionInfoIntegrationTest.class,\n                                org.apache.juddi.v3.tck.JUDDI_300_MultiNodeIntegrationTest.class,\n                                org.apache.juddi.v3.tck.UDDI_010_PublisherIntegrationTest.class,\n                                org.apache.juddi.v3.tck.UDDI_020_TmodelIntegrationTest.class,\n                                org.apache.juddi.v3.tck.UDDI_030_BusinessEntityIntegrationTest.class,\n                                org.apache.juddi.v3.tck.UDDI_030_BusinessEntityLoadIntegrationTest.class,\n                                org.apache.juddi.v3.tck.UDDI_040_BusinessServiceIntegrationTest.class,\n                                org.apache.juddi.v3.tck.UDDI_040_PerformanceIntegrationTest.class,\n                                org.apache.juddi.v3.tck.UDDI_040_BusinessServiceLoadIntegrationTest.class,\n                                org.apache.juddi.v3.tck.UDDI_050_BindingTemplateIntegrationTest.class,\n                                org.apache.juddi.v3.tck.UDDI_060_PublisherAssertionIntegrationTest.class,\n                                org.apache.juddi.v3.tck.UDDI_070_FindEntityIntegrationTest.class,\n                                org.apache.juddi.v3.tck.UDDI_080_SubscriptionIntegrationTest.class,\n                                org.apache.juddi.v3.tck.UDDI_090_HttpExternalTest.class,\n                                org.apache.juddi.v3.tck.UDDI_090_Smtp_ExternalTest.class,\n                                org.apache.juddi.v3.tck.UDDI_090_RMIIntegrationTest.class,\n// bug_end\n \n// bug_start\n                                org.apache.juddi.v3.tck.UDDI_110_FindBusinessIntegrationTest.class,\n                                org.apache.juddi.v3.tck.UDDI_120_CombineCategoryBagsFindServiceIntegrationTest.class,\n                                org.apache.juddi.v3.tck.UDDI_130_CombineCategoryBagsFindBusinessIntegrationTest.class,\n                                org.apache.juddi.v3.tck.UDDI_140_NegativePublicationIntegrationTest.class,\n                                org.apache.juddi.v3.tck.UDDI_141_JIRAIntegrationTest.class,\n                                org.apache.juddi.v3.tck.UDDI_142_DigitalSignatureIntegrationTest.class,\n                                org.apache.juddi.v3.tck.UDDI_150_CustodyTransferIntegrationTest.class,\n                                org.apache.juddi.v3.tck.UDDI_160_RESTIntergrationTest.class,\n                                org.apache.juddi.v3.tck.UDDI_170_ValueSetValidationIntegrationTest.class\n                        };\n                }\n// bug_end\n \n// bug_start\n                result = junit.run(cs);\n// bug_end\n \n// bug_start\n                String filename = \"uddi-tck-results-\" + new SimpleDateFormat(\"yyyyMMddhhmm\").format(new Date()) + \".txt\";\n                FileWriter fw = new FileWriter(filename);\n\n                BufferedWriter bw = new BufferedWriter(fw);\n                bw.write(\"UDDI-TCK Test Results generated \" + new SimpleDateFormat(\"yyyy-MM-dd'T'HH:mm:ss.SSSZ\").format(new Date()));\n                bw.newLine();\n                bw.write(\"____________________________________________\");\n                bw.newLine();\n                bw.write(\"Summary\");\n                bw.newLine();\n                bw.write(\"Failed Test Cases: \" + result.getFailureCount());\n                bw.newLine();\n                bw.write(\"Skipped Test Cases: \" + result.getIgnoreCount());\n                bw.newLine();\n                bw.write(\"Ran Test Cases: \" + result.getRunCount());\n                bw.newLine();\n                bw.write(\"Time: \" + result.getRunTime());\n                bw.newLine();\n                bw.write(\"____________________________________________\");\n\n                bw.newLine();\n                bw.write(\"Tests Ran\");\n                bw.newLine();\n                for (int i = 0; i < cs.length; i++) {\n                        bw.write(cs[i].getCanonicalName());\n                        bw.newLine();\n                }\n                bw.write(\"____________________________________________\");\n                bw.newLine();\n                bw.write(\"Failed Test cases\");\n                bw.newLine();\n                bw.write(\"____________________________________________\");\n                bw.newLine();\n                for (int i = 0; i < result.getFailures().size(); i++) {\n                        try {\n                                try {\n                                        bw.write(result.getFailures().get(i).getTestHeader());\n                                } catch (Exception ex) {\n                                        bw.write(ex.getMessage());\n                                }\n                                bw.newLine();\n                                try {\n                                        bw.write(result.getFailures().get(i).getDescription().getClassName());\n                                }\n                                catch (Exception ex) {\n                                        bw.write(ex.getMessage());\n                                }\n                                bw.newLine();\n                                try {\n                                        bw.write(result.getFailures().get(i).getDescription().getMethodName() == null ? \"null method!\" : result.getFailures().get(i).getDescription().getMethodName());\n                                } catch (Exception ex) {\n                                        bw.write(ex.getMessage());\n                                }\n                                bw.newLine();\n                                try {\n                                        bw.write(result.getFailures().get(i).getMessage() == null ? \"no message\" : result.getFailures().get(i).getMessage());\n                                } catch (Exception ex) {\n                                        bw.write(ex.getMessage());\n                                }\n                                bw.newLine();\n                                try {\n                                        bw.write(result.getFailures().get(i).getTrace());\n                                } catch (Exception ex) {\n                                        bw.write(ex.getMessage());\n                                }\n                                bw.newLine();\n                                bw.write(\"____________________________________________\");\n                                bw.newLine();\n                        } catch (Exception ex) {\n                                ex.printStackTrace();\n                        }\n                }\n                System.out.println(\"____________________________________________\");\n                System.out.println(\"Summary\");\n                System.out.println(\"Failed Test Cases: \" + result.getFailureCount());\n                System.out.println(\"Skipped Test Cases: \" + result.getIgnoreCount());\n                System.out.println(\"Ran Test Cases: \" + result.getRunCount());\n                System.out.println(\"Time: \" + result.getRunTime() + \"ms which is \" +\n                org.apache.commons.lang.time.DurationFormatUtils.formatDurationHMS(result.getRunTime()));\n                System.out.println(\"-------------------------------------\");\n                System.out.println(\"Results written to \" + filename);\n\n                bw.close();\n                fw.close();\n                junit = null;\n                System.out.println(\"Exit code: \" + result.getFailureCount());\n                System.exit(result.getFailureCount());\n        }\n\n// bug_end\n", "target": "// fix_start\npublic QName get(String qualifiedName, String uri) {\n        int index = qualifiedName.indexOf(':');\n// fix_end\n// fix_start\n        if (index < 0) {\n            return get(qualifiedName, Namespace.get(uri));\n        } else if (index == 0){\n            throw new IllegalArgumentException(\"Qualified name cannot start with ':'.\");\n        } else {\n            String name = qualifiedName.substring(index + 1);\n            String prefix = qualifiedName.substring(0, index);\n// fix_end\n// fix_start\n            return get(name, Namespace.get(prefix, uri));\n        }\n    }\n// fix_end\n", "cwe": "CWE-91", "cwe_name": "", "idx": 94228}
{"source": "// bug_start\nprivate void initialJpsClassList(String packageName) throws Exception {\n                Package pk = Package.getPackage(packageName);\n                List<Class> classesForPackage = new ArrayList<>();\n                if (pk != null) {\n                        classesForPackage.addAll(getClassesForPackage(pk));\n// bug_end\n                 } else {\n// bug_start\n                        classesForPackage.addAll(getClassesForPackage(packageName));\n// bug_end\n                 }\n// bug_start\n                for (Class<Object> clazz : classesForPackage) {\n// bug_end\n \n// bug_start\n                        jpaClasses.add(clazz);\n// bug_end\n                 }\n// bug_start\n// bug_end\n         }\n \n", "target": "// fix_start\npublic static void main(String[] args) throws Exception {\n                System.out.println(\"_________________________________________________\");\n                System.out.println(\"Configure options using uddi.xml and tck.properties\");\n                System.out.println(\"java -Duddi.client.xml=uddi.xml -jar juddi-tck-runner-{VERSION}-SNAPSHOT-jar-with-dependencies.jar\");\n                System.out.println(\"_________________________________________________\");\n                System.out.println();\n                System.out.println(\"Options\");\n                System.out.println(\"-Dtests=TestClass1,TestClass2    Comma delimited set of focused tests to run\");\n                System.out.println(\"_________________________________________________\");\n                System.out.println(\"Running! this can take anywhere from 2-5 minutes!\");\n                System.out.println(\"\");\n                if (!new File(\"tck.properties\").exists()) {\n                        System.out.println(\"tck.properties was not found! I give up!\");\n                        System.exit(1);\n                }\n                String s = System.getProperty(\"uddi.client.xml\");\n                if (s == null || !new File(s).exists()) {\n                        System.out.println(\"The value for option -Duddi.client.xml=\" + s + \" is either null or the file doesn't exist! I give up!\");\n                        System.exit(1);\n                }\n                String focusedTests = System.getProperty(\"tests\");\n                Result result = null;\n                JUnitCore junit = new JUnitCore();\n                Class[] cs = null;\n                if (focusedTests != null) {\n                        String[] items = focusedTests.split(\",\");\n                        cs = new Class[items.length];\n                        for (int i = 0; i < items.length; i++) {\n                                cs[i] = Class.forName(items[i]);\n                        }\n// fix_end\n// fix_start\n                        cs = new Class[]{\n                                org.apache.juddi.v2.tck.UDDI_020_TmodelIntegrationTest.class,\n                                org.apache.juddi.v2.tck.UDDI_030_BusinessEntityIntegrationTest.class,\n                                org.apache.juddi.v2.tck.UDDI_040_BusinessServiceIntegrationTest.class,\n                                org.apache.juddi.v2.tck.UDDI_050_BindingTemplateIntegrationTest.class,\n                                org.apache.juddi.v2.tck.UDDI_060_PublisherAssertionIntegrationTest.class,\n                                org.apache.juddi.v2.tck.UDDI_070_FindEntityIntegrationTest.class,\n                                org.apache.juddi.v3.bpel.BPEL_010_IntegrationTest.class,\n                                org.apache.juddi.v3.bpel.BPEL_020_IntegrationTest.class,\n                                org.apache.juddi.v3.tck.JUDDI_010_PublisherIntegrationTest.class,\n                                org.apache.juddi.v3.tck.JUDDI_100_ClientSubscriptionInfoIntegrationTest.class,\n                                org.apache.juddi.v3.tck.JUDDI_300_MultiNodeIntegrationTest.class,\n                                org.apache.juddi.v3.tck.UDDI_010_PublisherIntegrationTest.class,\n                                org.apache.juddi.v3.tck.UDDI_020_TmodelIntegrationTest.class,\n                                org.apache.juddi.v3.tck.UDDI_030_BusinessEntityIntegrationTest.class,\n                                org.apache.juddi.v3.tck.UDDI_030_BusinessEntityLoadIntegrationTest.class,\n                                org.apache.juddi.v3.tck.UDDI_040_BusinessServiceIntegrationTest.class,\n                                org.apache.juddi.v3.tck.UDDI_040_PerformanceIntegrationTest.class,\n                                org.apache.juddi.v3.tck.UDDI_040_BusinessServiceLoadIntegrationTest.class,\n                                org.apache.juddi.v3.tck.UDDI_050_BindingTemplateIntegrationTest.class,\n                                org.apache.juddi.v3.tck.UDDI_060_PublisherAssertionIntegrationTest.class,\n                                org.apache.juddi.v3.tck.UDDI_070_FindEntityIntegrationTest.class,\n                                org.apache.juddi.v3.tck.UDDI_080_SubscriptionIntegrationTest.class,\n                                org.apache.juddi.v3.tck.UDDI_090_HttpExternalTest.class,\n                                org.apache.juddi.v3.tck.UDDI_090_Smtp_ExternalTest.class,\n\n                                org.apache.juddi.v3.tck.UDDI_110_FindBusinessIntegrationTest.class,\n                                org.apache.juddi.v3.tck.UDDI_120_CombineCategoryBagsFindServiceIntegrationTest.class,\n                                org.apache.juddi.v3.tck.UDDI_130_CombineCategoryBagsFindBusinessIntegrationTest.class,\n                                org.apache.juddi.v3.tck.UDDI_140_NegativePublicationIntegrationTest.class,\n                                org.apache.juddi.v3.tck.UDDI_141_JIRAIntegrationTest.class,\n                                org.apache.juddi.v3.tck.UDDI_142_DigitalSignatureIntegrationTest.class,\n                                org.apache.juddi.v3.tck.UDDI_150_CustodyTransferIntegrationTest.class,\n                                org.apache.juddi.v3.tck.UDDI_160_RESTIntergrationTest.class,\n                                org.apache.juddi.v3.tck.UDDI_170_ValueSetValidationIntegrationTest.class\n                        };\n// fix_end\n// fix_start\n// fix_end\n// fix_start\n                result = junit.run(cs);\n\n                String filename = \"uddi-tck-results-\" + new SimpleDateFormat(\"yyyyMMddhhmm\").format(new Date()) + \".txt\";\n                FileWriter fw = new FileWriter(filename);\n\n                BufferedWriter bw = new BufferedWriter(fw);\n                bw.write(\"UDDI-TCK Test Results generated \" + new SimpleDateFormat(\"yyyy-MM-dd'T'HH:mm:ss.SSSZ\").format(new Date()));\n                bw.newLine();\n                bw.write(\"____________________________________________\");\n                bw.newLine();\n                bw.write(\"Summary\");\n                bw.newLine();\n                bw.write(\"Failed Test Cases: \" + result.getFailureCount());\n                bw.newLine();\n                bw.write(\"Skipped Test Cases: \" + result.getIgnoreCount());\n                bw.newLine();\n                bw.write(\"Ran Test Cases: \" + result.getRunCount());\n                bw.newLine();\n                bw.write(\"Time: \" + result.getRunTime());\n                bw.newLine();\n                bw.write(\"____________________________________________\");\n\n                bw.newLine();\n                bw.write(\"Tests Ran\");\n                bw.newLine();\n                for (int i = 0; i < cs.length; i++) {\n                        bw.write(cs[i].getCanonicalName());\n                        bw.newLine();\n// fix_end\n// fix_start\n                bw.write(\"____________________________________________\");\n                bw.newLine();\n                bw.write(\"Failed Test cases\");\n                bw.newLine();\n                bw.write(\"____________________________________________\");\n                bw.newLine();\n                for (int i = 0; i < result.getFailures().size(); i++) {\n                        try {\n                                try {\n                                        bw.write(result.getFailures().get(i).getTestHeader());\n                                } catch (Exception ex) {\n                                        bw.write(ex.getMessage());\n                                }\n                                bw.newLine();\n                                try {\n                                        bw.write(result.getFailures().get(i).getDescription().getClassName());\n                                }\n                                catch (Exception ex) {\n                                        bw.write(ex.getMessage());\n                                }\n                                bw.newLine();\n                                try {\n                                        bw.write(result.getFailures().get(i).getDescription().getMethodName() == null ? \"null method!\" : result.getFailures().get(i).getDescription().getMethodName());\n                                } catch (Exception ex) {\n                                        bw.write(ex.getMessage());\n                                }\n                                bw.newLine();\n                                try {\n                                        bw.write(result.getFailures().get(i).getMessage() == null ? \"no message\" : result.getFailures().get(i).getMessage());\n                                } catch (Exception ex) {\n                                        bw.write(ex.getMessage());\n                                }\n                                bw.newLine();\n                                try {\n                                        bw.write(result.getFailures().get(i).getTrace());\n                                } catch (Exception ex) {\n                                        bw.write(ex.getMessage());\n                                }\n                                bw.newLine();\n                                bw.write(\"____________________________________________\");\n                                bw.newLine();\n                        } catch (Exception ex) {\n                                ex.printStackTrace();\n                        }\n                }\n                System.out.println(\"____________________________________________\");\n                System.out.println(\"Summary\");\n                System.out.println(\"Failed Test Cases: \" + result.getFailureCount());\n                System.out.println(\"Skipped Test Cases: \" + result.getIgnoreCount());\n                System.out.println(\"Ran Test Cases: \" + result.getRunCount());\n                System.out.println(\"Time: \" + result.getRunTime() + \"ms which is \" +\n                org.apache.commons.lang.time.DurationFormatUtils.formatDurationHMS(result.getRunTime()));\n                System.out.println(\"-------------------------------------\");\n                System.out.println(\"Results written to \" + filename);\n\n                bw.close();\n                fw.close();\n                junit = null;\n                System.out.println(\"Exit code: \" + result.getFailureCount());\n                System.exit(result.getFailureCount());\n// fix_end\n", "cwe": "CWE-502", "cwe_name": "Deserialization of Untrusted Data", "idx": 62933}
{"source": "// bug_start\npublic synchronized TopLevelItem createProjectFromXML(String name, InputStream xml) throws IOException {\n        acl.checkPermission(Item.CREATE);\n// bug_end\n \n// bug_start\n        Jenkins.getInstance().getProjectNamingStrategy().checkName(name);\n        if (parent.getItem(name) != null) {\n            throw new IllegalArgumentException(parent.getDisplayName() + \" already contains an item '\" + name + \"'\");\n// bug_end\n         }\n \n// bug_start\n        File configXml = Items.getConfigFile(getRootDirFor(name)).getFile();\n        final File dir = configXml.getParentFile();\n        dir.mkdirs();\n        try {\n            IOUtils.copy(xml,configXml);\n\n            TopLevelItem result = Items.whileUpdatingByXml(new NotReallyRoleSensitiveCallable<TopLevelItem,IOException>() {\n                @Override public TopLevelItem call() throws IOException {\n                    return (TopLevelItem) Items.load(parent, dir);\n                }\n            });\n            add(result);\n\n            ItemListener.fireOnCreated(result);\n            Jenkins.getInstance().rebuildDependencyGraphAsync();\n\n            return result;\n        } catch (IOException e) {\n            Util.deleteRecursive(dir);\n            throw e;\n        }\n    }\n\n// bug_end\n", "target": "// fix_start\nprivate void initialJpsClassList(String packageName) throws Exception {\n                Package pk = Package.getPackage(packageName);\n                List<Class> classesForPackage = new ArrayList<Class>();\n                if (pk != null) {\n                        classesForPackage.addAll(getClassesForPackage(pk));\n                } else {\n                        classesForPackage.addAll(getClassesForPackage(packageName));\n                }\n                for (Class<Object> clazz : classesForPackage) {\n// fix_end\n// fix_start\n                        jpaClasses.add(clazz);\n                }\n// fix_end\n", "cwe": "CWE-502", "cwe_name": "Deserialization of Untrusted Data", "idx": 59482}
{"source": "// bug_start\nprivate List<GHPoint> getPointsFromRequest(HttpServletRequest httpServletRequest, String profile) {\n// bug_end\n \n// bug_start\n        String url = httpServletRequest.getRequestURI();\n        url = url.replaceFirst(\"/navigate/directions/v5/gh/\" + profile + \"/\", \"\");\n        url = url.replaceAll(\"\\\\?[*]\", \"\");\n\n        String[] pointStrings = url.split(\";\");\n\n        List<GHPoint> points = new ArrayList<>(pointStrings.length);\n        for (int i = 0; i < pointStrings.length; i++) {\n            points.add(GHPoint.fromStringLonLat(pointStrings[i]));\n// bug_end\n         }\n \n// bug_start\n        return points;\n// bug_end\n     }\n \n", "target": "// fix_start\npublic synchronized TopLevelItem createProjectFromXML(String name, InputStream xml) throws IOException {\n        acl.checkPermission(Item.CREATE);\n// fix_end\n// fix_start\n        Jenkins.getInstance().getProjectNamingStrategy().checkName(name);\n        if (parent.getItem(name) != null) {\n            throw new IllegalArgumentException(parent.getDisplayName() + \" already contains an item '\" + name + \"'\");\n// fix_end\n// fix_start\n        File configXml = Items.getConfigFile(getRootDirFor(name)).getFile();\n        final File dir = configXml.getParentFile();\n        dir.mkdirs();\n        final AtomicFileWriter out = new AtomicFileWriter(configXml);\n\n        try {\n            XMLUtils.safeTransform((Source)new StreamSource(xml), new StreamResult(out));\n            out.close();\n            out.commit();\n\n            TopLevelItem result = Items.whileUpdatingByXml(new NotReallyRoleSensitiveCallable<TopLevelItem,IOException>() {\n                @Override public TopLevelItem call() throws IOException {\n                    return (TopLevelItem) Items.load(parent, dir);\n                }\n            });\n            add(result);\n\n            ItemListener.fireOnCreated(result);\n            Jenkins.getInstance().rebuildDependencyGraphAsync();\n\n            return result;\n        } catch (TransformerException e) {\n            Util.deleteRecursive(dir);\n            throw new IOException(\"Failed to persist config.xml\", e);\n        } catch (SAXException e) {\n            Util.deleteRecursive(dir);\n            throw new IOException(\"Failed to persist config.xml\", e);\n        } catch (IOException e) {\n            Util.deleteRecursive(dir);\n            throw e;\n        } finally {\n            out.abort();\n        }\n// fix_end\n", "cwe": "NVD-CWE-Other", "cwe_name": "Other", "idx": 110766}
{"source": "// bug_start\npublic void copyDirectoryFromPod(\n      String namespace,\n      String pod,\n      String container,\n      String srcPath,\n      Path destination,\n      boolean enableTarCompressing)\n      throws IOException, ApiException {\n    if (!enableTarCompressing) {\n      TreeNode tree = new TreeNode(true, srcPath, true);\n      createDirectoryTree(tree, namespace, pod, container, srcPath);\n      createDirectoryStructureFromTree(tree, namespace, pod, container, srcPath, destination);\n      return;\n// bug_end\n     }\n// bug_start\n    final Process proc =\n        this.exec(\n            namespace,\n            pod,\n            new String[] {\"sh\", \"-c\", \"tar cz - \" + srcPath + \" | base64\"},\n            container,\n            false,\n            false);\n    try (InputStream is = new Base64InputStream(new BufferedInputStream(proc.getInputStream()));\n        ArchiveInputStream archive = new TarArchiveInputStream(new GzipCompressorInputStream(is))) {\n      for (ArchiveEntry entry = archive.getNextEntry();\n          entry != null;\n          entry = archive.getNextEntry()) {\n        if (!archive.canReadEntryData(entry)) {\n          log.error(\"Can't read: \" + entry);\n          continue;\n        }\n        File f = new File(destination.toFile(), entry.getName());\n        if (entry.isDirectory()) {\n          if (!f.isDirectory() && !f.mkdirs()) {\n            throw new IOException(\"create directory failed: \" + f);\n          }\n        } else {\n          File parent = f.getParentFile();\n          if (!parent.isDirectory() && !parent.mkdirs()) {\n            throw new IOException(\"create directory failed: \" + parent);\n          }\n          try (OutputStream fs = new FileOutputStream(f)) {\n            ByteStreams.copy(archive, fs);\n            fs.flush();\n          }\n        }\n      }\n    }\n    try {\n      int status = proc.waitFor();\n      if (status != 0) {\n        throw new IOException(\"Copy command failed with status \" + status);\n      }\n    } catch (InterruptedException ex) {\n      throw new IOException(ex);\n    }\n  }\n// bug_end\n \n", "target": "// fix_start\nprivate List<GHPoint> getPointsFromRequest(HttpServletRequest httpServletRequest, String profile) {\n        String url = httpServletRequest.getRequestURI();\n        String urlStart = \"/navigate/directions/v5/gh/\" + profile + \"/\";\n        if (!url.startsWith(urlStart)) throw new IllegalArgumentException(\"Incorrect URL \" + url);\n        url = url.substring(urlStart.length());\n        String[] pointStrings = url.split(\";\");\n        List<GHPoint> points = new ArrayList<>(pointStrings.length);\n        for (int i = 0; i < pointStrings.length; i++) {\n            points.add(GHPoint.fromStringLonLat(pointStrings[i]));\n        }\n\n        return points;\n// fix_end\n// fix_start\n// fix_end\n", "cwe": "CWE-400", "cwe_name": "Uncontrolled Resource Consumption", "idx": 52625}
{"source": "// bug_start\nprivate void init(ErrorDispatcher err) throws JasperException {\n        if (initialized)\n            return;\n// bug_end\n \n// bug_start\n        String blockExternalString = ctxt.getInitParameter(\n                Constants.XML_BLOCK_EXTERNAL_INIT_PARAM);\n        boolean blockExternal;\n        if (blockExternalString == null) {\n            blockExternal = true;\n        } else {\n            blockExternal = Boolean.parseBoolean(blockExternalString);\n        }\n\n        TagPluginParser parser;\n        ClassLoader original;\n        if (Constants.IS_SECURITY_ENABLED) {\n            PrivilegedGetTccl pa = new PrivilegedGetTccl();\n            original = AccessController.doPrivileged(pa);\n        } else {\n            original = Thread.currentThread().getContextClassLoader();\n        }\n        try {\n            if (Constants.IS_SECURITY_ENABLED) {\n                PrivilegedSetTccl pa =\n                        new PrivilegedSetTccl(TagPluginManager.class.getClassLoader());\n                AccessController.doPrivileged(pa);\n            } else {\n                Thread.currentThread().setContextClassLoader(\n                        TagPluginManager.class.getClassLoader());\n            }\n\n            parser = new TagPluginParser(ctxt, blockExternal);\n\n            Enumeration<URL> urls =\n                    ctxt.getClassLoader().getResources(META_INF_JASPER_TAG_PLUGINS_XML);\n            if (urls != null) {\n                while (urls.hasMoreElements()) {\n                    URL url = urls.nextElement();\n                    parser.parse(url);\n                }\n            }\n\n            URL url = ctxt.getResource(TAG_PLUGINS_XML);\n            if (url != null) {\n                parser.parse(url);\n            }\n        } catch (IOException | SAXException e) {\n            throw new JasperException(e);\n        } finally {\n            if (Constants.IS_SECURITY_ENABLED) {\n                PrivilegedSetTccl pa = new PrivilegedSetTccl(original);\n                AccessController.doPrivileged(pa);\n            } else {\n                Thread.currentThread().setContextClassLoader(original);\n            }\n        }\n\n        Map<String, String> plugins = parser.getPlugins();\n        tagPlugins = new HashMap<>(plugins.size());\n        for (Map.Entry<String, String> entry : plugins.entrySet()) {\n            try {\n                String tagClass = entry.getKey();\n                String pluginName = entry.getValue();\n                Class<?> pluginClass = ctxt.getClassLoader().loadClass(pluginName);\n                TagPlugin plugin = (TagPlugin) pluginClass.newInstance();\n                tagPlugins.put(tagClass, plugin);\n            } catch (Exception e) {\n                err.jspError(e);\n            }\n        }\n        initialized = true;\n    }\n\n// bug_end\n", "target": "// fix_start\npublic void copyDirectoryFromPod(\n      String namespace,\n      String pod,\n      String container,\n      String srcPath,\n      Path destination,\n      boolean enableTarCompressing)\n      throws IOException, ApiException {\n    if (!enableTarCompressing) {\n      TreeNode tree = new TreeNode(true, srcPath, true);\n      createDirectoryTree(tree, namespace, pod, container, srcPath);\n      createDirectoryStructureFromTree(tree, namespace, pod, container, srcPath, destination);\n      return;\n    }\n    final Process proc =\n        this.exec(\n            namespace,\n            pod,\n            new String[] {\"sh\", \"-c\", \"tar cz - \" + srcPath + \" | base64\"},\n            container,\n            false,\n            false);\n    try (InputStream is = new Base64InputStream(new BufferedInputStream(proc.getInputStream()));\n        ArchiveInputStream archive = new TarArchiveInputStream(new GzipCompressorInputStream(is))) {\n      for (ArchiveEntry entry = archive.getNextEntry();\n          entry != null;\n          entry = archive.getNextEntry()) {\n        if (!archive.canReadEntryData(entry)) {\n          log.error(\"Can't read: \" + entry);\n          continue;\n        }\n        String normalName = FilenameUtils.normalize(entry.getName());\n        if (normalName == null) {\n          throw new IOException(\"Invalid entry: \" + entry.getName());\n        }\n        File f = new File(destination.toFile(), normalName);\n        if (entry.isDirectory()) {\n          if (!f.isDirectory() && !f.mkdirs()) {\n            throw new IOException(\"create directory failed: \" + f);\n          }\n        } else {\n          File parent = f.getParentFile();\n          if (!parent.isDirectory() && !parent.mkdirs()) {\n            throw new IOException(\"create directory failed: \" + parent);\n          }\n          try (OutputStream fs = new FileOutputStream(f)) {\n            ByteStreams.copy(archive, fs);\n            fs.flush();\n          }\n        }\n      }\n    }\n    try {\n      int status = proc.waitFor();\n      if (status != 0) {\n        throw new IOException(\"Copy command failed with status \" + status);\n      }\n    } catch (InterruptedException ex) {\n      throw new IOException(ex);\n    }\n  }\n// fix_end\n", "cwe": "CWE-22", "cwe_name": "Path Traversal", "idx": 28737}
{"source": " protected boolean bindUser(DirContext context, String dn, String password) throws NamingException {\n       boolean isValid = false;\n \n       if (logger.isDebugEnabled()) {\n          logger.debug(\"Binding the user.\");\n       }\n// bug_start\n// bug_end\n       context.addToEnvironment(Context.SECURITY_PRINCIPAL, dn);\n       context.addToEnvironment(Context.SECURITY_CREDENTIALS, password);\n       try {\n          context.getAttributes(\"\", null);\n          isValid = true;\n          if (logger.isDebugEnabled()) {\n             logger.debug(\"User \" + dn + \" successfully bound.\");\n          }\n       } catch (AuthenticationException e) {\n          isValid = false;\n          if (logger.isDebugEnabled()) {\n             logger.debug(\"Authentication failed for dn=\" + dn);\n          }\n       }\n \n       if (isLoginPropertySet(CONNECTION_USERNAME)) {\n          context.addToEnvironment(Context.SECURITY_PRINCIPAL, getLDAPPropertyValue(CONNECTION_USERNAME));\n       } else {\n          context.removeFromEnvironment(Context.SECURITY_PRINCIPAL);\n       }\n       if (isLoginPropertySet(CONNECTION_PASSWORD)) {\n          context.addToEnvironment(Context.SECURITY_CREDENTIALS, getPlainPassword(getLDAPPropertyValue(CONNECTION_PASSWORD)));\n       } else {\n          context.removeFromEnvironment(Context.SECURITY_CREDENTIALS);\n       }\n// bug_start\n// bug_end\n \n       return isValid;\n    }\n \n", "target": "// fix_start\n      context.addToEnvironment(Context.SECURITY_AUTHENTICATION, \"simple\");\n// fix_end\n// fix_start\n      context.addToEnvironment(Context.SECURITY_AUTHENTICATION, getLDAPPropertyValue(AUTHENTICATION));\n// fix_end\n", "cwe": "CWE-287", "cwe_name": "Improper Authentication", "idx": 38280}
{"source": " @Override\n     @Nonnull\n     public String getValidHref(final String url) {\n         if (StringUtils.isNotEmpty(url)) {\n// bug_start\n            try {\n                String unescapedURL = URLDecoder.decode(url, StandardCharsets.UTF_8.name());\n                unescapedURL = StringEscapeUtils.unescapeXml(unescapedURL);\n                String encodedUrl = unescapedURL.replaceAll(\"\\\"\", \"%22\")\n                        .replaceAll(\"'\", \"%27\")\n                        .replaceAll(\">\", \"%3E\")\n                        .replaceAll(\"<\", \"%3C\")\n                        .replaceAll(\"`\", \"%60\")\n                        .replaceAll(\" \", \"%20\");\n                int qMarkIx = encodedUrl.indexOf('?');\n                if (qMarkIx > 0) {\n                    encodedUrl = encodedUrl.substring(0, qMarkIx) + encodedUrl.substring(qMarkIx).replaceAll(\":\", \"%3A\");\n                }\n\n                encodedUrl = mangleNamespaces(encodedUrl);\n                if (xssFilter.isValidHref(encodedUrl)) {\n                    return encodedUrl;\n                }\n            } catch (UnsupportedEncodingException e) {\n                LOGGER.error(\"Unable to decode url: {}.\", url);\n// bug_end\n             }\n         }\n         return \"\";\n     }\n \n", "target": "// fix_start\n            String encodedUrl = url.replaceAll(\"\\\"\", \"%22\")\n                    .replaceAll(\"'\", \"%27\")\n                    .replaceAll(\">\", \"%3E\")\n                    .replaceAll(\"<\", \"%3C\")\n                    .replaceAll(\"`\", \"%60\")\n                    .replaceAll(\" \", \"%20\");\n            int qMarkIx = encodedUrl.indexOf('?');\n            if (qMarkIx > 0) {\n                encodedUrl = encodedUrl.substring(0, qMarkIx) + encodedUrl.substring(qMarkIx).replaceAll(\":\", \"%3A\");\n            }\n            encodedUrl = mangleNamespaces(encodedUrl);\n            if (xssFilter.isValidHref(encodedUrl)) {\n                return encodedUrl;\n// fix_end\n", "cwe": "CWE-79", "cwe_name": "Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')", "idx": 80969}
{"source": " private static String parseSoapMethodName(InputStream stream, String charEncoding) {\n \t\ttry {\n \t\t\tfinal XMLInputFactory factory = XMLInputFactory.newInstance();\n// bug_start\n// bug_end\n \t\t\tfinal XMLStreamReader xmlReader;\n \t\t\tif (charEncoding != null) {\n \t\t\t\txmlReader = factory.createXMLStreamReader(stream, charEncoding);\n \t\t\t} else {\n \t\t\t\txmlReader = factory.createXMLStreamReader(stream);\n \t\t\t}\n \n \n \t\t\txmlReader.nextTag();\n \n \t\t\tif (!\"Envelope\".equals(xmlReader.getLocalName())) {\n \t\t\t\tLOG.debug(\"Unexpected first tag of SOAP request: '\" + xmlReader.getLocalName()\n \t\t\t\t\t\t+ \"' (expected 'Envelope')\");\n \t\t\t\treturn null;\n \t\t\t}\n \n \t\t\tif (!scanForChildTag(xmlReader, \"Body\")) {\n \t\t\t\tLOG.debug(\"Unable to find SOAP 'Body' tag\");\n \t\t\t\treturn null;\n \t\t\t}\n \n \t\t\txmlReader.nextTag();\n \n \t\t\treturn \".\" + xmlReader.getLocalName();\n \t\t} catch (final XMLStreamException e) {\n \t\t\tLOG.debug(\"Unable to parse SOAP request\", e);\n \t\t\treturn null;\n \t\t}\n \t}\n \n", "target": "// fix_start\n\t\t\tfactory.setProperty(XMLInputFactory.SUPPORT_DTD, false);\n\t\t\tfactory.setProperty(XMLInputFactory.IS_SUPPORTING_EXTERNAL_ENTITIES, false);\n// fix_end\n", "cwe": "CWE-611", "cwe_name": "Improper Restriction of XML External Entity Reference ('XXE')", "idx": 67515}
{"source": " @Override\n     public void onApplicationEvent(ApplicationEnvironmentPreparedEvent event) {\n         if (cloud != null) return;\n         try {\n             cloud = new CloudFactory().getCloud();\n         } catch (CloudException e) {\n             return;\n         }\n \n         for (ServiceInfo serviceInfo : cloud.getServiceInfos()) {\n             if (serviceInfo instanceof SsoServiceInfo) {\n                 Map<String, Object> map = new HashMap<>();\n                 SsoServiceInfo ssoServiceInfo = (SsoServiceInfo) serviceInfo;\n                 map.put(\"security.oauth2.client.clientId\", ssoServiceInfo.getClientId());\n                 map.put(\"security.oauth2.client.clientSecret\", ssoServiceInfo.getClientSecret());\n                 map.put(\"security.oauth2.client.accessTokenUri\", ssoServiceInfo.getAuthDomain() + \"/oauth/token\");\n                 map.put(\"security.oauth2.client.userAuthorizationUri\", ssoServiceInfo.getAuthDomain() + \"/oauth/authorize\");\n                 map.put(\"ssoServiceUrl\", ssoServiceInfo.getAuthDomain());\n                 map.put(\"security.oauth2.resource.userInfoUri\", ssoServiceInfo.getAuthDomain() + \"/userinfo\");\n                 map.put(\"security.oauth2.resource.tokenInfoUri\", ssoServiceInfo.getAuthDomain() + \"/check_token\");\n                 map.put(\"security.oauth2.resource.jwk.key-set-uri\", ssoServiceInfo.getAuthDomain() + \"/token_keys\");\n// bug_start\n                map.put(\"sso.connector.cloud.available\", \"success\");\n// bug_end\n                 MapPropertySource mapPropertySource = new MapPropertySource(\"vcapPivotalSso\", map);\n \n                 event.getEnvironment().getPropertySources().addFirst(mapPropertySource);\n             }\n         }\n     }\n \n", "target": "// fix_start\n// fix_end\n", "cwe": "NVD-CWE-noinfo", "cwe_name": "", "idx": 105669}
{"source": " private void doDirectoryRedirect(HttpServletRequest request, HttpServletResponse response)\n             throws IOException {\n         StringBuilder location = new StringBuilder(request.getRequestURI());\n         location.append('/');\n         if (request.getQueryString() != null) {\n             location.append('?');\n             location.append(request.getQueryString());\n         }\n// bug_start\n// bug_end\n         response.sendRedirect(response.encodeRedirectURL(location.toString()));\n     }\n \n", "target": "// fix_start\n        while (location.length() > 1 && location.charAt(1) == '/') {\n            location.deleteCharAt(0);\n        }\n// fix_end\n", "cwe": "CWE-601", "cwe_name": "URL Redirection to Untrusted Site ('Open Redirect')", "idx": 65600}
{"source": " private void newRequest(ChannelHandlerContext ctx, HttpRequest nettyRequest) throws Exception {\n     if (!nettyRequest.decoderResult().isSuccess()) {\n       LOGGER.debug(\"Failed to decode HTTP request.\", nettyRequest.decoderResult().cause());\n       sendError(ctx, HttpResponseStatus.BAD_REQUEST);\n       return;\n     }\n \n     Headers requestHeaders = new NettyHeadersBackedHeaders(nettyRequest.headers());\n \n     Long contentLength = HttpUtil.getContentLength(nettyRequest, -1L);\n     String transferEncoding = requestHeaders.get(HttpHeaderNames.TRANSFER_ENCODING);\n \n     boolean hasBody = (contentLength > 0) || (transferEncoding != null);\n \n     RequestBody requestBody = hasBody ? new RequestBody(contentLength, nettyRequest, ctx) : null;\n \n     Channel channel = ctx.channel();\n \n     if (requestBody != null) {\n       channel.attr(BODY_ACCUMULATOR_KEY).set(requestBody);\n     }\n     InetSocketAddress remoteAddress = (InetSocketAddress) channel.remoteAddress();\n     InetSocketAddress socketAddress = (InetSocketAddress) channel.localAddress();\n \n     ConnectionIdleTimeout connectionIdleTimeout = ConnectionIdleTimeout.of(channel);\n \n     DefaultRequest request = new DefaultRequest(\n       clock.instant(),\n       requestHeaders,\n       nettyRequest.method(),\n       nettyRequest.protocolVersion(),\n       nettyRequest.uri(),\n       remoteAddress,\n       socketAddress,\n       serverRegistry.get(ServerConfig.class),\n       requestBody,\n       connectionIdleTimeout,\n       channel.attr(CLIENT_CERT_KEY).get()\n     );\n \n// bug_start\n    HttpHeaders nettyHeaders = new DefaultHttpHeaders(false);\n// bug_end\n     MutableHeaders responseHeaders = new NettyHeadersBackedMutableHeaders(nettyHeaders);\n     AtomicBoolean transmitted = new AtomicBoolean(false);\n \n     DefaultResponseTransmitter responseTransmitter = new DefaultResponseTransmitter(transmitted, channel, clock, nettyRequest, request, nettyHeaders, requestBody);\n \n     ctx.channel().attr(DefaultResponseTransmitter.ATTRIBUTE_KEY).set(responseTransmitter);\n \n     Action<Action<Object>> subscribeHandler = thing -> {\n       transmitted.set(true);\n       ctx.channel().attr(CHANNEL_SUBSCRIBER_ATTRIBUTE_KEY).set(thing);\n     };\n \n     DefaultContext.RequestConstants requestConstants = new DefaultContext.RequestConstants(\n       applicationConstants,\n       request,\n       channel,\n       responseTransmitter,\n       subscribeHandler\n     );\n \n     Response response = new DefaultResponse(responseHeaders, ctx.alloc(), responseTransmitter);\n     requestConstants.response = response;\n \n     DefaultContext.start(channel.eventLoop(), requestConstants, serverRegistry, handlers, execution -> {\n       if (!transmitted.get()) {\n         Handler lastHandler = requestConstants.handler;\n         StringBuilder description = new StringBuilder();\n         description\n           .append(\"No response sent for \")\n           .append(request.getMethod().getName())\n           .append(\" request to \")\n           .append(request.getUri());\n \n         if (lastHandler != null) {\n           description.append(\" (last handler: \");\n \n           if (lastHandler instanceof DescribingHandler) {\n             ((DescribingHandler) lastHandler).describeTo(description);\n           } else {\n             DescribingHandlers.describeTo(lastHandler, description);\n           }\n           description.append(\")\");\n         }\n \n         String message = description.toString();\n         LOGGER.warn(message);\n \n         response.getHeaders().clear();\n \n         ByteBuf body;\n         if (development) {\n           CharBuffer charBuffer = CharBuffer.wrap(message);\n           body = ByteBufUtil.encodeString(ctx.alloc(), charBuffer, CharsetUtil.UTF_8);\n           response.contentType(HttpHeaderConstants.PLAIN_TEXT_UTF8);\n         } else {\n           body = Unpooled.EMPTY_BUFFER;\n         }\n \n         response.getHeaders().set(HttpHeaderConstants.CONTENT_LENGTH, body.readableBytes());\n         responseTransmitter.transmit(HttpResponseStatus.INTERNAL_SERVER_ERROR, body);\n       }\n     });\n   }\n \n", "target": "// fix_start\n    HttpHeaders nettyHeaders = new DefaultHttpHeaders();\n// fix_end\n", "cwe": "CWE-74", "cwe_name": "Improper Neutralization of Special Elements in Output Used by a Downstream Component ('Injection')", "idx": 73761}
{"source": " public static Map<String, Lookup> getDefaultPrefixLookups() {\n// bug_start\n        return DEFAULT_PREFIX_LOOKUPS;\n// bug_end\n     }\n \n", "target": "// fix_start\n        return DefaultPrefixLookupsHolder.INSTANCE.getDefaultPrefixLookups();\n// fix_end\n", "cwe": "NVD-CWE-noinfo", "cwe_name": "", "idx": 105781}
{"source": " @SuppressFBWarnings(value = \"PATH_TRAVERSAL_IN\", justification = \"False positive\")\n     public synchronized int run(String[] args) throws Exception{\n         if (used) {\n             throw new IllegalStateException(\"CLI instance already used\");\n         }\n \n         used = true;\n \n         CLIParser parser = new CLIParser(\"oozie-setup.sh\", HELP_INFO);\n         String oozieHome = System.getProperty(OOZIE_HOME);\n         parser.addCommand(HELP_CMD, \"\", \"display usage for all commands or specified command\", new Options(), false);\n         parser.addCommand(CREATE_CMD, \"\", \"create a new timestamped version of oozie sharelib\",\n                 createUpgradeOptions(CREATE_CMD), false);\n         parser.addCommand(UPGRADE_CMD, \"\",\n                 \"[deprecated][use command \\\"create\\\" to create new version]   upgrade oozie sharelib \\n\",\n                 createUpgradeOptions(UPGRADE_CMD), false);\n \n         try {\n             final CLIParser.Command command = parser.parse(args);\n             String sharelibAction = command.getName();\n \n             if (sharelibAction.equals(HELP_CMD)){\n                 parser.showHelp(command.getCommandLine());\n                 return 0;\n             }\n \n             if (!command.getCommandLine().hasOption(FS_OPT)){\n                 throw new Exception(\"-fs option must be specified\");\n             }\n \n             int threadPoolSize = Integer.valueOf(command.getCommandLine().getOptionValue(CONCURRENCY_OPT, \"1\"));\n             File srcFile = null;\n \n             if (command.getCommandLine().hasOption(LIB_OPT)){\n                 srcFile = new File(command.getCommandLine().getOptionValue(LIB_OPT));\n             }\n             else {\n                 Collection<File> files =\n                         FileUtils.listFiles(new File(oozieHome), new WildcardFileFilter(\"oozie-sharelib*.tar.gz\"), null);\n \n                 if (files.size() > 1){\n                     throw new IOException(\"more than one sharelib tar found at \" + oozieHome);\n                 }\n \n                 if (files.isEmpty()){\n                     throw new IOException(\"default sharelib tar not found in oozie home dir: \" + oozieHome);\n                 }\n \n                 srcFile = files.iterator().next();\n             }\n \n             Map<String, String> extraLibs = new HashMap<>();\n             if (command.getCommandLine().hasOption(EXTRALIBS)) {\n                 String[] param = command.getCommandLine().getOptionValues(EXTRALIBS);\n                 extraLibs = getExtraLibs(param);\n             }\n \n// bug_start\n            File temp = File.createTempFile(\"oozie\", \".dir\");\n            temp.delete();\n            temp.mkdir();\n// bug_end\n             temp.deleteOnExit();\n \n             if (!srcFile.isDirectory()){\n                 FileUtil.unTar(srcFile, temp);\n                 srcFile = new File(temp.toString() + \"/share/lib\");\n             }\n             else {\n                 srcFile = new File(srcFile, \"lib\");\n             }\n \n             String hdfsUri = command.getCommandLine().getOptionValue(FS_OPT);\n             Path srcPath = new Path(srcFile.toString());\n \n             Services services = new Services();\n             services.getConf().set(Services.CONF_SERVICE_CLASSES,\n                 \"org.apache.oozie.service.LiteWorkflowAppService, org.apache.oozie.service.HadoopAccessorService\");\n             services.getConf().set(Services.CONF_SERVICE_EXT_CLASSES, \"\");\n             services.init();\n             WorkflowAppService lwas = services.get(WorkflowAppService.class);\n             HadoopAccessorService has = services.get(HadoopAccessorService.class);\n             Path dstPath = lwas.getSystemLibPath();\n \n             URI uri = new Path(hdfsUri).toUri();\n             Configuration fsConf = has.createConfiguration(uri.getAuthority());\n             FileSystem fs = FileSystem.get(uri, fsConf);\n \n             if (!fs.exists(dstPath)) {\n                 fs.mkdirs(dstPath);\n             }\n             ECPolicyDisabler.tryDisableECPolicyForPath(fs, dstPath);\n \n             if (sharelibAction.equals(CREATE_CMD) || sharelibAction.equals(UPGRADE_CMD)){\n                 dstPath= new Path(dstPath.toString() +  Path.SEPARATOR +  SHARE_LIB_PREFIX + getTimestampDirectory()  );\n             }\n \n             System.out.println(\"the destination path for sharelib is: \" + dstPath);\n \n             checkIfSourceFilesExist(srcFile);\n             copyToSharelib(threadPoolSize, srcFile, srcPath, dstPath, fs);\n             copyExtraLibs(threadPoolSize, extraLibs, dstPath, fs);\n \n             if (sharelibAction.equals(CREATE_CMD) || sharelibAction.equals(UPGRADE_CMD)) {\n                 applySharelibPermission(fs, dstPath);\n             }\n \n             services.destroy();\n             FileUtils.deleteDirectory(temp);\n \n             return 0;\n         }\n         catch (ParseException ex) {\n             System.err.println(\"Invalid sub-command: \" + ex.getMessage());\n             System.err.println();\n             System.err.println(parser.shortHelp());\n             return 1;\n         }\n         catch (NumberFormatException ex) {\n             logError(\"Invalid configuration value: \", ex);\n             return 1;\n         }\n         catch (Exception ex) {\n             logError(ex.getMessage(), ex);\n             return 1;\n         }\n     }\n \n", "target": "// fix_start\n           File temp = Files.createTempDirectory(\"oozie\").toFile();\n// fix_end\n", "cwe": "CWE-362", "cwe_name": "Concurrent Execution using Shared Resource with Improper Synchronization ('Race Condition')", "idx": 49427}
{"source": " @Override\n \tprotected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain)\n \t\t\tthrows ServletException, IOException {\n \n \t\tHttpServletRequest requestToUse = request;\n \n \t\tif (\"POST\".equals(request.getMethod()) && request.getAttribute(WebUtils.ERROR_EXCEPTION_ATTRIBUTE) == null) {\n \t\t\tString paramValue = request.getParameter(this.methodParam);\n \t\t\tif (StringUtils.hasLength(paramValue)) {\n// bug_start\n\t\t\t\trequestToUse = new HttpMethodRequestWrapper(request, paramValue);\n// bug_end\n \t\t\t}\n \t\t}\n \n \t\tfilterChain.doFilter(requestToUse, response);\n \t}\n \n", "target": "// fix_start\n\t\t\t\tString method = paramValue.toUpperCase(Locale.ENGLISH);\n\t\t\t\tif (ALLOWED_METHODS.contains(method)) {\n\t\t\t\t\trequestToUse = new HttpMethodRequestWrapper(request, method);\n\t\t\t\t}\n// fix_end\n", "cwe": "NVD-CWE-noinfo", "cwe_name": "", "idx": 103427}
{"source": " public AsciiString generateSessionId() {\n// bug_start\n    ThreadLocalRandom random = ThreadLocalRandom.current();\n    UUID uuid = new UUID(random.nextLong(), random.nextLong());\n    return AsciiString.of(uuid.toString());\n// bug_end\n   }\n \n", "target": "// fix_start\n    return AsciiString.cached(UUID.randomUUID().toString());\n// fix_end\n", "cwe": "CWE-338", "cwe_name": "", "idx": 42657}
{"source": " private void sanitizeString(int start, int end) {\n     boolean closed = false;\n     for (int i = start; i < end; ++i) {\n       char ch = jsonish.charAt(i);\n       switch (ch) {\n// bug_start\n// bug_end\n         case '\\n': replace(i, i + 1, \"\\\\n\"); break;\n         case '\\r': replace(i, i + 1, \"\\\\r\"); break;\n         case '\\u2028': replace(i, i + 1, \"\\\\u2028\"); break;\n         case '\\u2029': replace(i, i + 1, \"\\\\u2029\"); break;\n         case '\"': case '\\'':\n           if (i == start) {\n             if (ch == '\\'') { replace(i, i + 1, '\"'); }\n           } else {\n             if (i + 1 == end) {\n               char startDelim = jsonish.charAt(start);\n               if (startDelim != '\\'') {\n                 startDelim = '\"';\n               }\n               closed = startDelim == ch;\n             }\n             if (closed) {\n               if (ch == '\\'') { replace(i, i + 1, '\"'); }\n             } else if (ch == '\"') {\n               insert(i, '\\\\');\n             }\n           }\n           break;\n         case '<':\n           if (i + 3 >= end)\n             break;\n           char c1 = jsonish.charAt(i + 1);\n           char c2 = jsonish.charAt(i + 2);\n           char c3 = jsonish.charAt(i + 3);\n           char lc1 = (char) (c1 | 32);\n           char lc2 = (char) (c2 | 32);\n           char lc3 = (char) (c3 | 32);\n           if ((c1 == '!' && c2 == '-' && c3 == '-') ||\n               (lc1 == 's' && lc2 == 'c' && lc3 == 'r') ||\n               (c1 == '/' && lc2 == 's' && lc3 == 'c')) {\n             replace(i, i + 1, \"\\\\u003c\");\n           }\n           break;\n         case '>':\n           if ((i - 2) >= start && '-' == jsonish.charAt(i - 2)\n               && '-' == jsonish.charAt(i - 1)) {\n             replace(i, i + 1, \"\\\\u003e\");\n           }\n           break;\n         case ']':\n           if (i + 2 < end && ']' == jsonish.charAt(i + 1)\n               && '>' == jsonish.charAt(i + 2)) {\n             replace(i, i + 1, \"\\\\u005d\");\n           }\n           break;\n         case '\\\\':\n           if (i + 1 == end) {\n             elide(i, i + 1);\n             break;\n           }\n           char sch = jsonish.charAt(i + 1);\n           switch (sch) {\n             case 'b': case 'f': case 'n': case 'r': case 't': case '\\\\':\n             case '/': case '\"':\n               ++i;\n               break;\n             case 'v':\n               replace(i, i + 2, \"\\\\u0008\");\n               ++i;\n               break;\n             case 'x':\n               if (i + 4 < end && isHexAt(i+2) && isHexAt(i+3)) {\n                 replace(i, i + 2, \"\\\\u00\");\n                 i += 3;\n                 break;\n               }\n               elide(i, i + 1);\n               break;\n             case 'u':\n               if (i + 6 < end && isHexAt(i + 2) && isHexAt(i + 3)\n                   && isHexAt(i + 4) && isHexAt(i + 5)) {\n                 i += 5;\n                 break;\n               }\n               elide(i, i + 1);\n               break;\n             case '0': case '1': case '2': case '3':\n             case '4': case '5': case '6': case '7':\n               int octalEnd = i + 1;\n               if (octalEnd + 1 < end && isOctAt(octalEnd + 1)) {\n                 ++octalEnd;\n                 if (ch <= '3' && octalEnd + 1 < end && isOctAt(octalEnd + 1)) {\n                   ++octalEnd;\n                 }\n                 int value = 0;\n                 for (int j = i; j < octalEnd; ++j) {\n                   value = (value << 3) | (jsonish.charAt(j) - '0');\n                 }\n                 replace(i + 1, octalEnd, \"u00\");\n                 appendHex(value, 2);\n               }\n               i = octalEnd - 1;\n               break;\n             default:\n               elide(i, i + 1);\n               break;\n           }\n           break;\n         default:\n           if (ch < 0x20) {\n// bug_start\n            if (ch == 9 || ch == 0xa || ch == 0xd) { continue; }\n// bug_end\n           } else if (ch < 0xd800) {\n             continue;\n           } else if (ch < 0xe000) {\n             if (Character.isHighSurrogate(ch) && i+1 < end\n                 && Character.isLowSurrogate(jsonish.charAt(i+1))) {\n               ++i;\n               continue;\n             }\n           } else if (ch <= 0xfffd) {\n             continue;\n           }\n           replace(i, i + 1, \"\\\\u\");\n           for (int j = 4; --j >= 0;) {\n             sanitizedJson.append(HEX_DIGITS[(ch >>> (j << 2)) & 0xf]);\n           }\n           break;\n       }\n     }\n     if (!closed) { insert(end, '\"'); }\n   }\n \n", "target": "// fix_start\n        case '\\t': replace(i, i + 1, \"\\\\t\"); break;\n// fix_end\n// fix_start\n// fix_end\n", "cwe": "CWE-611", "cwe_name": "Improper Restriction of XML External Entity Reference ('XXE')", "idx": 70004}
{"source": "// bug_start\npublic FormValidation doMatchText(\n// bug_end\n                 @QueryParameter(\"pattern\") final String testPattern,\n                 @QueryParameter(\"testText\") String testText,\n                 @QueryParameter(\"textSourceIsUrl\") final boolean textSourceIsUrl) {\n// bug_start\n// bug_end\n             if (textSourceIsUrl) {\n                 testText = testText.replaceAll(\"/\\\\./\", \"/\").replaceAll(\"/view/change-requests\", \"\");\n                 Matcher urlMatcher = URL_PATTERN.matcher(testText);\n                 if (urlMatcher.matches()) {\n                     String[] urlParts = new String[NUM_OF_URL_PARTS];\n                     for (int i = 0; i < urlParts.length; i++) {\n                         urlParts[i] = urlMatcher.group(i + 1);\n                     }\n \n                     Run build = null;\n                     ItemGroup getItemInstance;\n \n                     if (urlParts[0].split(\"/job/\").length > 1) {\n                         StringBuilder fullFolderName = new StringBuilder();\n                         String[] interestingJobParts = urlParts[0].split(\"/job/\", 2);\n                         String[] jobParts = interestingJobParts[interestingJobParts.length - 1].split(\"/job/\");\n                         for (String part: jobParts) {\n                             fullFolderName.append(\"/\").append(part);\n                         }\n                         getItemInstance = (ItemGroup)Jenkins.getInstance().getItemByFullName(fullFolderName.toString());\n                     } else {\n                         getItemInstance = (ItemGroup)Jenkins.getInstance();\n                     }\n \n                     if (getItemInstance == null) {\n                         throw new AssertionError(\"Folder not found!\");\n                     }\n \n \n                     final Item itemFromPart2 = getItemInstance.getItem(urlParts[2]);\n                     if (itemFromPart2 instanceof Job\n                             && isValidBuildId(urlParts[3])) {\n                         Job project = (Job)itemFromPart2;\n                         build = getBuildById(project, urlParts[3]);\n                     } else {\n                         final Item itemFromPart1 = getItemInstance.getItem(urlParts[1]);\n                         if (itemFromPart1 instanceof MatrixProject\n                                 && isValidBuildId(urlParts[3])) {\n                             MatrixProject project = (MatrixProject)itemFromPart1;\n                             MatrixConfiguration configuration = project.getItem(urlParts[2]);\n                             build = getBuildById(configuration, urlParts[3]);\n                         } else if (itemFromPart1 instanceof MatrixProject\n                                 && isValidBuildId(urlParts[2])) {\n                             MatrixProject matrixProject = (MatrixProject)itemFromPart1;\n                             MatrixConfiguration configuration = matrixProject.getItem(urlParts[3]);\n                             build = getBuildById(configuration, urlParts[2]);\n                         }\n                     }\n                     if (build != null) {\n                         try {\n                             final FailureReader failureReader = getFailureReader(testPattern);\n                             final FoundIndication foundIndication = failureReader.scan(build);\n                             if (foundIndication == null) {\n                                 return FormValidation.warning(Messages.StringDoesNotMatchPattern());\n                             }\n                             return FormValidation.okWithMarkup(foundIndication.getFirstMatchingLine());\n                         } catch (IOException e) {\n                             return FormValidation.error(Messages.FailedToScanFile_Error());\n                         }\n                     }\n                 }\n                 return FormValidation.error(Messages.InvalidURL_Error());\n             } else {\n                 try {\n// bug_start\n                    if (testText.matches(testPattern)) {\n// bug_end\n                         return FormValidation.ok(Messages.StringMatchesPattern());\n                     }\n                     return FormValidation.warning(Messages.StringDoesNotMatchPattern());\n                 } catch (PatternSyntaxException e) {\n                     return FormValidation.error(Messages.InvalidPattern_Error());\n                 }\n             }\n         }\n \n", "target": "// fix_start\n@RequirePOST\n        public FormValidation doMatchText(\n// fix_end\n// fix_start\n            Jenkins.get().checkPermission(PluginImpl.UPDATE_PERMISSION);\n// fix_end\n// fix_start\n                    final Pattern pattern = Pattern.compile(testPattern);\n                    final Matcher matcher = pattern.matcher(new FailureReader.InterruptibleCharSequence(testText));\n                    if (matcher.matches()) {\n// fix_end\n", "cwe": "CWE-400", "cwe_name": "Uncontrolled Resource Consumption", "idx": 52795}
{"source": "// bug_start\nprivate void sanitizeString(int start, int end) {\n    boolean closed = false;\n    for (int i = start; i < end; ++i) {\n      char ch = jsonish.charAt(i);\n      switch (ch) {\n        case '\\n': replace(i, i + 1, \"\\\\n\"); break;\n        case '\\r': replace(i, i + 1, \"\\\\r\"); break;\n        case '\\u2028': replace(i, i + 1, \"\\\\u2028\"); break;\n        case '\\u2029': replace(i, i + 1, \"\\\\u2029\"); break;\n        case '\"': case '\\'':\n          if (i == start) {\n            if (ch == '\\'') { replace(i, i + 1, '\"'); }\n          } else {\n            if (i + 1 == end) {\n              char startDelim = jsonish.charAt(start);\n              if (startDelim != '\\'') {\n                startDelim = '\"';\n              }\n              closed = startDelim == ch;\n            }\n            if (closed) {\n              if (ch == '\\'') { replace(i, i + 1, '\"'); }\n            } else if (ch == '\"') {\n              insert(i, '\\\\');\n            }\n          }\n          break;\n        case '/':\n          if (i > start && i + 2 < end && '<' == jsonish.charAt(i - 1)\n              && 's' == (jsonish.charAt(i + 1) | 32)\n              && 'c' == (jsonish.charAt(i + 2) | 32)) {\n            insert(i, '\\\\');\n          }\n          break;\n        case ']':\n          if (i + 2 < end && ']' == jsonish.charAt(i + 1)\n              && '>' == jsonish.charAt(i + 2)) {\n            replace(i, i + 1, \"\\\\u005d\");\n          }\n          break;\n        case '\\\\':\n          if (i + 1 == end) {\n            elide(i, i + 1);\n            break;\n          }\n          char sch = jsonish.charAt(i + 1);\n          switch (sch) {\n            case 'b': case 'f': case 'n': case 'r': case 't': case '\\\\':\n            case '/': case '\"':\n              ++i;\n              break;\n            case 'v':\n              replace(i, i + 2, \"\\\\u0008\");\n              ++i;\n              break;\n            case 'x':\n              if (i + 4 < end && isHexAt(i+2) && isHexAt(i+3)) {\n                replace(i, i + 2, \"\\\\u00\");\n                i += 3;\n                break;\n              }\n              elide(i, i + 1);\n              break;\n            case 'u':\n              if (i + 6 < end && isHexAt(i + 2) && isHexAt(i + 3)\n                  && isHexAt(i + 4) && isHexAt(i + 5)) {\n                i += 5;\n                break;\n              }\n              elide(i, i + 1);\n              break;\n            case '0': case '1': case '2': case '3':\n            case '4': case '5': case '6': case '7':\n              int octalEnd = i + 1;\n              if (octalEnd + 1 < end && isOctAt(octalEnd + 1)) {\n                ++octalEnd;\n                if (ch <= '3' && octalEnd + 1 < end && isOctAt(octalEnd + 1)) {\n                  ++octalEnd;\n                }\n                int value = 0;\n                for (int j = i; j < octalEnd; ++j) {\n                  value = (value << 3) | (jsonish.charAt(j) - '0');\n                }\n                replace(i + 1, octalEnd, \"u00\");\n                appendHex(value, 2);\n              }\n              i = octalEnd - 1;\n              break;\n            default:\n              elide(i, i + 1);\n              break;\n          }\n          break;\n        default:\n          if (ch < 0x20) {\n            if (ch == 9 || ch == 0xa || ch == 0xd) { continue; }\n          } else if (ch < 0xd800) {\n            continue;\n          } else if (ch < 0xe000) {\n            if (Character.isHighSurrogate(ch) && i+1 < end\n                && Character.isLowSurrogate(jsonish.charAt(i+1))) {\n              ++i;\n              continue;\n            }\n          } else if (ch <= 0xfffd) {\n            continue;\n          }\n          replace(i, i + 1, \"\\\\u\");\n          for (int j = 4; --j >= 0;) {\n            sanitizedJson.append(HEX_DIGITS[(ch >>> (j << 2)) & 0xf]);\n          }\n          break;\n      }\n// bug_end\n     }\n// bug_start\n    if (!closed) { insert(end, '\"'); }\n  }\n// bug_end\n \n", "target": "// fix_start\npublic C3P0Config findConfig() throws Exception\n    {\n\tC3P0Config out;\n\n\tHashMap flatDefaults = C3P0ConfigUtils.extractHardcodedC3P0Defaults();\n\n\tflatDefaults.putAll( C3P0ConfigUtils.extractC3P0PropertiesResources() );\n\n\tString cfgFile = C3P0Config.getPropsFileConfigProperty( XML_CFG_FILE_KEY );\n\tboolean expandEntityReferences = findExpandEntityReferences();\n\n\tif (cfgFile == null)\n\t    {\n\t\tC3P0Config xmlConfig = C3P0ConfigXmlUtils.extractXmlConfigFromDefaultResource( expandEntityReferences );\n\t\tif (xmlConfig != null)\n\t\t    {\n\t\t\tinsertDefaultsUnderNascentConfig( flatDefaults, xmlConfig );\n\t\t\tout = xmlConfig;\n\n\t\t\tmbOverrideWarning(\"resource\", C3P0ConfigXmlUtils.XML_CONFIG_RSRC_PATH);\n\t\t    }\n\t\telse\n\t\t    out = C3P0ConfigUtils.configFromFlatDefaults( flatDefaults );\n\t    }\n\telse\n\t    {\n\t\tcfgFile = cfgFile.trim();\n\n\t\tInputStream is = null;\n\t\ttry\n\t\t    {\n\t\t\tif ( cfgFile.startsWith( CLASSLOADER_RESOURCE_PREFIX ) )\n\t\t\t{\n\t\t\t    ClassLoader cl = this.getClass().getClassLoader();\n\t\t\t    String rsrcPath = cfgFile.substring( CLASSLOADER_RESOURCE_PREFIX.length() );\n\n\t\t\t    if (rsrcPath.startsWith(\"/\"))\n\t\t\t\trsrcPath = rsrcPath.substring(1);\n\n\t\t\t    is = cl.getResourceAsStream( rsrcPath );\n\t\t\t    if ( is == null )\n\t\t\t\tthrow new FileNotFoundException(\"Specified ClassLoader resource '\" + rsrcPath + \"' could not be found. \" +\n\t\t\t\t\t\t\t\t\"[ Found in configuration: \" + XML_CFG_FILE_KEY + '=' + cfgFile + \" ]\");\n\n\t\t\t    mbOverrideWarning( \"resource\", rsrcPath );\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t    is = new BufferedInputStream( new FileInputStream( cfgFile ) );\n\t\t\t    mbOverrideWarning( \"file\", cfgFile );\n\t\t\t}\n\n\t\t\tC3P0Config xmlConfig = C3P0ConfigXmlUtils.extractXmlConfigFromInputStream( is, expandEntityReferences );\n\t\t\tinsertDefaultsUnderNascentConfig( flatDefaults, xmlConfig );\n\t\t\tout = xmlConfig;\n\t\t    }\n\t\tfinally\n\t\t    {\n\t\t\ttry { if (is != null) is.close();}\n\t\t\tcatch (Exception e)\n\t\t\t    { e.printStackTrace(); }\n\t\t    }\n\t    }\n\n\tProperties sysPropConfig = C3P0ConfigUtils.findAllC3P0SystemProperties();\n\tout.defaultConfig.props.putAll( sysPropConfig );\n\n\treturn out;\n// fix_end\n// fix_start\n// fix_end\n", "cwe": "CWE-79", "cwe_name": "Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')", "idx": 81270}
{"source": "// bug_start\nprotected User getUserByPattern(JNDIConnection connection, String username, String credentials, String[] attrIds,\n            int curUserPattern) throws NamingException {\n// bug_end\n \n// bug_start\n        User user = null;\n// bug_end\n \n// bug_start\n        if (username == null || userPatternArray[curUserPattern] == null) {\n            return null;\n        }\n// bug_end\n \n// bug_start\n        String dn = connection.userPatternFormatArray[curUserPattern].format(\n                new String[] { doAttributeValueEscaping(username) });\n// bug_end\n \n// bug_start\n        try {\n            user = getUserByPattern(connection.context, username, attrIds, dn);\n        } catch (NameNotFoundException e) {\n            return null;\n        } catch (NamingException e) {\n            try {\n                userCredentialsAdd(connection.context, dn, credentials);\n// bug_end\n \n// bug_start\n                user = getUserByPattern(connection.context, username, attrIds, dn);\n            } finally {\n                userCredentialsRemove(connection.context);\n            }\n        }\n        return user;\n// bug_end\n     }\n \n", "target": "// fix_start\npublic C3P0Config findConfig() throws Exception\n    {\n\tC3P0Config out;\n// fix_end\n// fix_start\n\tHashMap flatDefaults = C3P0ConfigUtils.extractHardcodedC3P0Defaults();\n// fix_end\n// fix_start\n\tflatDefaults.putAll( C3P0ConfigUtils.extractC3P0PropertiesResources() );\n// fix_end\n// fix_start\n\tString cfgFile = C3P0Config.getPropsFileConfigProperty( XML_CFG_FILE_KEY );\n\tboolean usePermissiveParser = findUsePermissiveParser();\n// fix_end\n// fix_start\n\tif (cfgFile == null)\n\t    {\n\t\tC3P0Config xmlConfig = C3P0ConfigXmlUtils.extractXmlConfigFromDefaultResource( usePermissiveParser );\n\t\tif (xmlConfig != null)\n\t\t    {\n\t\t\tinsertDefaultsUnderNascentConfig( flatDefaults, xmlConfig );\n\t\t\tout = xmlConfig;\n// fix_end\n// fix_start\n\t\t\tmbOverrideWarning(\"resource\", C3P0ConfigXmlUtils.XML_CONFIG_RSRC_PATH);\n\t\t    }\n\t\telse\n\t\t    out = C3P0ConfigUtils.configFromFlatDefaults( flatDefaults );\n\t    }\n\telse\n\t    {\n\t\tcfgFile = cfgFile.trim();\n\n\t\tInputStream is = null;\n\t\ttry\n\t\t    {\n\t\t\tif ( cfgFile.startsWith( CLASSLOADER_RESOURCE_PREFIX ) )\n\t\t\t{\n\t\t\t    ClassLoader cl = this.getClass().getClassLoader();\n\t\t\t    String rsrcPath = cfgFile.substring( CLASSLOADER_RESOURCE_PREFIX.length() );\n\n\t\t\t    if (rsrcPath.startsWith(\"/\"))\n\t\t\t\trsrcPath = rsrcPath.substring(1);\n\n\t\t\t    is = cl.getResourceAsStream( rsrcPath );\n\t\t\t    if ( is == null )\n\t\t\t\tthrow new FileNotFoundException(\"Specified ClassLoader resource '\" + rsrcPath + \"' could not be found. \" +\n\t\t\t\t\t\t\t\t\"[ Found in configuration: \" + XML_CFG_FILE_KEY + '=' + cfgFile + \" ]\");\n\n\t\t\t    mbOverrideWarning( \"resource\", rsrcPath );\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t    is = new BufferedInputStream( new FileInputStream( cfgFile ) );\n\t\t\t    mbOverrideWarning( \"file\", cfgFile );\n\t\t\t}\n\n\t\t\tC3P0Config xmlConfig = C3P0ConfigXmlUtils.extractXmlConfigFromInputStream( is, usePermissiveParser );\n\t\t\tinsertDefaultsUnderNascentConfig( flatDefaults, xmlConfig );\n\t\t\tout = xmlConfig;\n\t\t    }\n\t\tfinally\n\t\t    {\n\t\t\ttry { if (is != null) is.close();}\n\t\t\tcatch (Exception e)\n\t\t\t    { e.printStackTrace(); }\n\t\t    }\n\t    }\n\n\tProperties sysPropConfig = C3P0ConfigUtils.findAllC3P0SystemProperties();\n\tout.defaultConfig.props.putAll( sysPropConfig );\n\n\treturn out;\n// fix_end\n", "cwe": "CWE-776", "cwe_name": "", "idx": 76603}
{"source": "// bug_start\nprotected User getUserByPattern(JNDIConnection connection, String username, String credentials, String[] attrIds,\n            int curUserPattern) throws NamingException {\n// bug_end\n \n// bug_start\n        User user = null;\n// bug_end\n \n// bug_start\n        if (username == null || userPatternArray[curUserPattern] == null) {\n            return null;\n// bug_end\n         }\n// bug_start\n\n        String dn = connection.userPatternFormatArray[curUserPattern].format(new String[] { username });\n\n        try {\n            user = getUserByPattern(connection.context, username, attrIds, dn);\n        } catch (NameNotFoundException e) {\n            return null;\n        } catch (NamingException e) {\n            try {\n                userCredentialsAdd(connection.context, dn, credentials);\n\n                user = getUserByPattern(connection.context, username, attrIds, dn);\n            } finally {\n                userCredentialsRemove(connection.context);\n            }\n        }\n        return user;\n// bug_end\n     }\n \n", "target": "// fix_start\npublic static void unzipFileTo(String file, String dest) throws IOException {\n        File target = new File(file);\n        if (!target.exists())\n            throw new IllegalArgumentException(\"Archive doesnt exist\");\n        FileInputStream fin = new FileInputStream(target);\n        int BUFFER = 2048;\n        byte data[] = new byte[BUFFER];\n// fix_end\n// fix_start\n        if (file.endsWith(\".zip\") || file.endsWith(\".jar\")) {\n            try(ZipInputStream zis = new ZipInputStream(fin)) {\n                ZipEntry ze = zis.getNextEntry();\n// fix_end\n// fix_start\n                while (ze != null) {\n                    String fileName = ze.getName();\n\n                    String canonicalDestinationDirPath = new File(dest).getCanonicalPath();\n                    File newFile = new File(dest + File.separator + fileName);\n                    String canonicalDestinationFile = newFile.getCanonicalPath();\n\n                    if (!canonicalDestinationFile.startsWith(canonicalDestinationDirPath + File.separator)) {\n                        log.debug(\"Attempt to unzip entry is outside of the target dir\");\n                        throw new IOException(\"Entry is outside of the target dir: \");\n                    }\n\n                    if (ze.isDirectory()) {\n                        newFile.mkdirs();\n                        zis.closeEntry();\n                        ze = zis.getNextEntry();\n                        continue;\n                    }\n\n                    FileOutputStream fos = new FileOutputStream(newFile);\n\n                    int len;\n                    while ((len = zis.read(data)) > 0) {\n                        fos.write(data, 0, len);\n                    }\n\n                    fos.close();\n                    ze = zis.getNextEntry();\n                    log.debug(\"File extracted: \" + newFile.getAbsoluteFile());\n                }\n\n                zis.closeEntry();\n            }\n        } else if (file.endsWith(\".tar.gz\") || file.endsWith(\".tgz\")) {\n\n            BufferedInputStream in = new BufferedInputStream(fin);\n            GzipCompressorInputStream gzIn = new GzipCompressorInputStream(in);\n            TarArchiveInputStream tarIn = new TarArchiveInputStream(gzIn);\n\n            TarArchiveEntry entry;\n            while ((entry = (TarArchiveEntry) tarIn.getNextEntry()) != null) {\n                log.info(\"Extracting: \" + entry.getName());\n\n                if (entry.isDirectory()) {\n                    File f = new File(dest + File.separator + entry.getName());\n                    f.mkdirs();\n                }\n                else {\n                    int count;\n                    try(FileOutputStream fos = new FileOutputStream(dest + File.separator + entry.getName());\n                        BufferedOutputStream destStream = new BufferedOutputStream(fos, BUFFER);) {\n                        while ((count = tarIn.read(data, 0, BUFFER)) != -1) {\n                            destStream.write(data, 0, count);\n                        }\n\n                        destStream.flush();\n                        IOUtils.closeQuietly(destStream);\n                    }\n                }\n            }\n\n            tarIn.close();\n        } else if (file.endsWith(\".gz\")) {\n            File extracted = new File(target.getParent(), target.getName().replace(\".gz\", \"\"));\n            if (extracted.exists())\n                extracted.delete();\n            extracted.createNewFile();\n            try(GZIPInputStream is2 = new GZIPInputStream(fin); OutputStream fos = FileUtils.openOutputStream(extracted)) {\n                IOUtils.copyLarge(is2, fos);\n                fos.flush();\n            }\n        } else {\n            throw new IllegalStateException(\"Unable to infer file type (compression format) from source file name: \" +\n                    file);\n// fix_end\n// fix_start\n        target.delete();\n// fix_end\n", "cwe": "CWE-116", "cwe_name": "Improper Encoding or Escaping of Output", "idx": 1058}
{"source": "// bug_start\npublic static void unzipFileTo(String file, String dest) throws IOException {\n        File target = new File(file);\n        if (!target.exists())\n            throw new IllegalArgumentException(\"Archive doesnt exist\");\n        FileInputStream fin = new FileInputStream(target);\n        int BUFFER = 2048;\n        byte data[] = new byte[BUFFER];\n// bug_end\n \n// bug_start\n        if (file.endsWith(\".zip\") || file.endsWith(\".jar\")) {\n            try(ZipInputStream zis = new ZipInputStream(fin)) {\n                ZipEntry ze = zis.getNextEntry();\n\n                while (ze != null) {\n                    String fileName = ze.getName();\n                    File newFile = new File(dest + File.separator + fileName);\n\n                    if (ze.isDirectory()) {\n                        newFile.mkdirs();\n                        zis.closeEntry();\n                        ze = zis.getNextEntry();\n                        continue;\n                    }\n\n                    FileOutputStream fos = new FileOutputStream(newFile);\n\n                    int len;\n                    while ((len = zis.read(data)) > 0) {\n                        fos.write(data, 0, len);\n                    }\n\n                    fos.close();\n                    ze = zis.getNextEntry();\n                    log.debug(\"File extracted: \" + newFile.getAbsoluteFile());\n                }\n\n                zis.closeEntry();\n            }\n        } else if (file.endsWith(\".tar.gz\") || file.endsWith(\".tgz\")) {\n\n            BufferedInputStream in = new BufferedInputStream(fin);\n            GzipCompressorInputStream gzIn = new GzipCompressorInputStream(in);\n            TarArchiveInputStream tarIn = new TarArchiveInputStream(gzIn);\n\n            TarArchiveEntry entry;\n            while ((entry = (TarArchiveEntry) tarIn.getNextEntry()) != null) {\n                log.info(\"Extracting: \" + entry.getName());\n\n                if (entry.isDirectory()) {\n                    File f = new File(dest + File.separator + entry.getName());\n                    f.mkdirs();\n                }\n                else {\n                    int count;\n                    try(FileOutputStream fos = new FileOutputStream(dest + File.separator + entry.getName());\n                        BufferedOutputStream destStream = new BufferedOutputStream(fos, BUFFER);) {\n                        while ((count = tarIn.read(data, 0, BUFFER)) != -1) {\n                            destStream.write(data, 0, count);\n                        }\n\n                        destStream.flush();\n                        IOUtils.closeQuietly(destStream);\n                    }\n                }\n            }\n\n            tarIn.close();\n        } else if (file.endsWith(\".gz\")) {\n            File extracted = new File(target.getParent(), target.getName().replace(\".gz\", \"\"));\n            if (extracted.exists())\n                extracted.delete();\n            extracted.createNewFile();\n            try(GZIPInputStream is2 = new GZIPInputStream(fin); OutputStream fos = FileUtils.openOutputStream(extracted)) {\n                IOUtils.copyLarge(is2, fos);\n                fos.flush();\n            }\n        } else {\n            throw new IllegalStateException(\"Unable to infer file type (compression format) from source file name: \" +\n                    file);\n        }\n        target.delete();\n    }\n\n// bug_end\n", "target": "// fix_start\n@Override\n        public void processPacket(PacketContext context) {\n            for (ProcessorEntry entry : processors) {\n                long start = System.nanoTime();\n                entry.processor().process(context);\n                entry.addNanos(System.nanoTime() - start);\n            }\n        }\n// fix_end\n", "cwe": "CWE-352", "cwe_name": "Cross-Site Request Forgery (CSRF)", "idx": 45000}
{"source": "// bug_start\npublic void doCommand(StaplerRequest req, StaplerResponse rsp) throws ServletException, IOException {\n        final Jenkins jenkins = Jenkins.getInstance();\n        jenkins.checkPermission(Jenkins.READ);\n\n        final String commandName = req.getRestOfPath().substring(1);\n        CLICommand command = CLICommand.clone(commandName);\n        if (command == null) {\n            rsp.sendError(HttpServletResponse.SC_NOT_FOUND, \"No such command \" + commandName);\n            return;\n// bug_end\n         }\n \n// bug_start\n        req.setAttribute(\"command\", command);\n        req.getView(this, \"command.jelly\").forward(req, rsp);\n    }\n\n// bug_end\n", "target": "// fix_start\n@Override\n        public void processPacket(PacketContext context) {\n            for (ProcessorEntry entry : processors) {\n                try {\n                    long start = System.nanoTime();\n                    entry.processor().process(context);\n                    entry.addNanos(System.nanoTime() - start);\n                } catch (Exception e) {\n                    log.warn(\"Packet processor {} threw an exception\", entry.processor(), e);\n                }\n            }\n// fix_end\n", "cwe": "CWE-476", "cwe_name": "NULL Pointer Dereference", "idx": 56725}
{"source": "// bug_start\n@Override\n    public void init(ServletConfig config) throws ServletException {\n// bug_end\n \n// bug_start\n        super.init(config);\n        this.config = config;\n        this.context = config.getServletContext();\n\n        String engineOptionsName = config.getInitParameter(\"engineOptionsClass\");\n        if (engineOptionsName != null) {\n            try {\n                ClassLoader loader = Thread.currentThread().getContextClassLoader();\n                Class<?> engineOptionsClass = loader.loadClass(engineOptionsName);\n                Class<?>[] ctorSig = { ServletConfig.class, ServletContext.class };\n                Constructor<?> ctor = engineOptionsClass.getConstructor(ctorSig);\n                Object[] args = { config, context };\n                options = (Options) ctor.newInstance(args);\n            } catch (Throwable e) {\n                e = ExceptionUtils.unwrapInvocationTargetException(e);\n                ExceptionUtils.handleThrowable(e);\n                log.warn(\"Failed to load engineOptionsClass\", e);\n                options = new EmbeddedServletOptions(config, context);\n            }\n        } else {\n            options = new EmbeddedServletOptions(config, context);\n        }\n        rctxt = new JspRuntimeContext(context, options);\n        if (config.getInitParameter(\"jspFile\") != null) {\n            jspFile = config.getInitParameter(\"jspFile\");\n            try {\n                if (null == context.getResource(jspFile)) {\n                    return;\n                }\n            } catch (MalformedURLException e) {\n                throw new ServletException(\"cannot locate jsp file\", e);\n            }\n            try {\n                if (SecurityUtil.isPackageProtectionEnabled()){\n                   AccessController.doPrivileged(new PrivilegedExceptionAction<Object>(){\n                        @Override\n                        public Object run() throws IOException, ServletException {\n                            serviceJspFile(null, null, jspFile, true);\n                            return null;\n                        }\n                    });\n                } else {\n                    serviceJspFile(null, null, jspFile, true);\n                }\n            } catch (IOException e) {\n                throw new ServletException(\"Could not precompile jsp: \" + jspFile, e);\n            } catch (PrivilegedActionException e) {\n                Throwable t = e.getCause();\n                if (t instanceof ServletException) throw (ServletException)t;\n                throw new ServletException(\"Could not precompile jsp: \" + jspFile, e);\n            }\n// bug_end\n         }\n \n// bug_start\n        if (log.isDebugEnabled()) {\n            log.debug(Localizer.getMessage(\"jsp.message.scratch.dir.is\",\n                    options.getScratchDir().toString()));\n            log.debug(Localizer.getMessage(\"jsp.message.dont.modify.servlets\"));\n        }\n// bug_end\n     }\n \n", "target": "// fix_start\npublic void doCommand(StaplerRequest req, StaplerResponse rsp) throws ServletException, IOException {\n        final Jenkins jenkins = Jenkins.getInstance();\n        jenkins.checkPermission(Jenkins.READ);\n// fix_end\n// fix_start\n        final String commandName = req.getRestOfPath().substring(1);\n        CLICommand command = CLICommand.clone(commandName);\n        if (command == null) {\n            rsp.sendError(HttpServletResponse.SC_NOT_FOUND, \"No such command\");\n            return;\n// fix_end\n// fix_start\n        req.setAttribute(\"command\", command);\n        req.getView(this, \"command.jelly\").forward(req, rsp);\n// fix_end\n", "cwe": "CWE-20", "cwe_name": "Improper Input Validation", "idx": 7676}
{"source": " @Override\n// bug_start\n\tpublic void configure(ServletContextHandler context) {\n\t\tcontext.setContextPath(\"/\");\n// bug_end\n \n// bug_start\n\t\tcontext.getSessionHandler().setMaxInactiveInterval(serverConfig.getSessionTimeout());\n// bug_end\n \n// bug_start\n\t\tcontext.setInitParameter(EnvironmentLoader.ENVIRONMENT_CLASS_PARAM, DefaultWebEnvironment.class.getName());\n\t\tcontext.addEventListener(new EnvironmentLoaderListener());\n\t\tcontext.addFilter(new FilterHolder(shiroFilter), \"/*\", EnumSet.allOf(DispatcherType.class));\n// bug_end\n \n// bug_start\n        context.addFilter(new FilterHolder(gitFilter), \"/*\", EnumSet.allOf(DispatcherType.class));\n// bug_end\n \n// bug_start\n\t\tcontext.addServlet(new ServletHolder(preReceiveServlet), GitPreReceiveCallback.PATH + \"/*\");\n\n        context.addServlet(new ServletHolder(postReceiveServlet), GitPostReceiveCallback.PATH + \"/*\");\n\n\t\tcontext.addServlet(new ServletHolder(wicketServlet), \"/\");\n\n\t\tcontext.addServlet(new ServletHolder(new ClasspathAssetServlet(ImageScope.class)), \"/img/*\");\n\t\tcontext.addServlet(new ServletHolder(new ClasspathAssetServlet(IconScope.class)), \"/icon/*\");\n\n\t\tcontext.getSessionHandler().addEventListener(new HttpSessionListener() {\n\n\t\t\t@Override\n\t\t\tpublic void sessionCreated(HttpSessionEvent se) {\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic void sessionDestroyed(HttpSessionEvent se) {\n\t\t\t\twebSocketManager.onDestroySession(se.getSession().getId());\n\t\t\t}\n\n\t\t});\n\n\t\tServletHolder fileServletHolder = new ServletHolder(new FileAssetServlet(Bootstrap.getSiteDir()));\n\t\tcontext.addServlet(fileServletHolder, \"/site/*\");\n\t\tcontext.addServlet(fileServletHolder, \"/robots.txt\");\n\n\t\tcontext.addServlet(new ServletHolder(jerseyServlet), \"/rest/*\");\n\t}\n\n// bug_end\n", "target": "// fix_start\n    public void init(ServletConfig config) throws ServletException {\n// fix_end\n// fix_start\n        super.init(config);\n        this.config = config;\n        this.context = config.getServletContext();\n// fix_end\n// fix_start\n        String engineOptionsName = config.getInitParameter(\"engineOptionsClass\");\n        if (Constants.IS_SECURITY_ENABLED && engineOptionsName != null) {\n            log.info(Localizer.getMessage(\n                    \"jsp.info.ignoreSetting\", \"engineOptionsClass\", engineOptionsName));\n            engineOptionsName = null;\n        }\n        if (engineOptionsName != null) {\n            try {\n                ClassLoader loader = Thread.currentThread().getContextClassLoader();\n                Class<?> engineOptionsClass = loader.loadClass(engineOptionsName);\n                Class<?>[] ctorSig = { ServletConfig.class, ServletContext.class };\n                Constructor<?> ctor = engineOptionsClass.getConstructor(ctorSig);\n                Object[] args = { config, context };\n                options = (Options) ctor.newInstance(args);\n            } catch (Throwable e) {\n                e = ExceptionUtils.unwrapInvocationTargetException(e);\n                ExceptionUtils.handleThrowable(e);\n                log.warn(\"Failed to load engineOptionsClass\", e);\n                options = new EmbeddedServletOptions(config, context);\n            }\n        } else {\n            options = new EmbeddedServletOptions(config, context);\n        }\n        rctxt = new JspRuntimeContext(context, options);\n        if (config.getInitParameter(\"jspFile\") != null) {\n            jspFile = config.getInitParameter(\"jspFile\");\n            try {\n                if (null == context.getResource(jspFile)) {\n                    return;\n                }\n            } catch (MalformedURLException e) {\n                throw new ServletException(\"cannot locate jsp file\", e);\n            }\n            try {\n                if (SecurityUtil.isPackageProtectionEnabled()){\n                   AccessController.doPrivileged(new PrivilegedExceptionAction<Object>(){\n                        @Override\n                        public Object run() throws IOException, ServletException {\n                            serviceJspFile(null, null, jspFile, true);\n                            return null;\n                        }\n                    });\n                } else {\n                    serviceJspFile(null, null, jspFile, true);\n                }\n            } catch (IOException e) {\n                throw new ServletException(\"Could not precompile jsp: \" + jspFile, e);\n            } catch (PrivilegedActionException e) {\n                Throwable t = e.getCause();\n                if (t instanceof ServletException) throw (ServletException)t;\n                throw new ServletException(\"Could not precompile jsp: \" + jspFile, e);\n            }\n        }\n// fix_end\n// fix_start\n        if (log.isDebugEnabled()) {\n            log.debug(Localizer.getMessage(\"jsp.message.scratch.dir.is\",\n                    options.getScratchDir().toString()));\n            log.debug(Localizer.getMessage(\"jsp.message.dont.modify.servlets\"));\n        }\n    }\n// fix_end\n", "cwe": "NVD-CWE-noinfo", "cwe_name": "", "idx": 101832}
{"source": " @Override\n// bug_start\n\tpublic void configure(ServletContextHandler context) {\n\t\tcontext.setContextPath(\"/\");\n// bug_end\n \n// bug_start\n\t\tcontext.getSessionHandler().setMaxInactiveInterval(serverConfig.getSessionTimeout());\n// bug_end\n \n// bug_start\n\t\tcontext.setInitParameter(EnvironmentLoader.ENVIRONMENT_CLASS_PARAM, DefaultWebEnvironment.class.getName());\n\t\tcontext.addEventListener(new EnvironmentLoaderListener());\n\t\tcontext.addFilter(new FilterHolder(shiroFilter), \"/*\", EnumSet.allOf(DispatcherType.class));\n// bug_end\n \n// bug_start\n        context.addFilter(new FilterHolder(gitFilter), \"/*\", EnumSet.allOf(DispatcherType.class));\n// bug_end\n \n// bug_start\n\t\tcontext.addServlet(new ServletHolder(preReceiveServlet), GitPreReceiveCallback.PATH + \"/*\");\n// bug_end\n \n// bug_start\n        context.addServlet(new ServletHolder(postReceiveServlet), GitPostReceiveCallback.PATH + \"/*\");\n// bug_end\n \n// bug_start\n\t\tcontext.addServlet(new ServletHolder(wicketServlet), \"/\");\n\n\t\tcontext.addServlet(new ServletHolder(attachmentUploadServlet), \"/attachment_upload\");\n\n\t\tcontext.addServlet(new ServletHolder(new ClasspathAssetServlet(ImageScope.class)), \"/img/*\");\n\t\tcontext.addServlet(new ServletHolder(new ClasspathAssetServlet(IconScope.class)), \"/icon/*\");\n\n\t\tcontext.getSessionHandler().addEventListener(new HttpSessionListener() {\n\n\t\t\t@Override\n\t\t\tpublic void sessionCreated(HttpSessionEvent se) {\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic void sessionDestroyed(HttpSessionEvent se) {\n\t\t\t\twebSocketManager.onDestroySession(se.getSession().getId());\n\t\t\t}\n\n\t\t});\n\n\t\tServletHolder fileServletHolder = new ServletHolder(new FileAssetServlet(Bootstrap.getSiteDir()));\n\t\tcontext.addServlet(fileServletHolder, \"/site/*\");\n\t\tcontext.addServlet(fileServletHolder, \"/robots.txt\");\n\n\t\tcontext.addServlet(new ServletHolder(jerseyServlet), \"/rest/*\");\n\t}\n\n// bug_end\n", "target": "// fix_start\n    public Collection<FileAnnotation> parse(final InputStream file, final String moduleName) throws InvocationTargetException {\n        try {\n            Digester digester = new Digester();\n            digester.setValidating(false);\n            digester.setClassLoader(PmdParser.class.getClassLoader());\n// fix_end\n// fix_start\n            String rootXPath = \"pmd\";\n            digester.addObjectCreate(rootXPath, Pmd.class);\n            digester.addSetProperties(rootXPath);\n// fix_end\n// fix_start\n            String fileXPath = \"pmd/file\";\n            digester.addObjectCreate(fileXPath, hudson.plugins.pmd.parser.File.class);\n            digester.addSetProperties(fileXPath);\n            digester.addSetNext(fileXPath, \"addFile\", hudson.plugins.pmd.parser.File.class.getName());\n// fix_end\n// fix_start\n            String bugXPath = \"pmd/file/violation\";\n            digester.addObjectCreate(bugXPath, Violation.class);\n            digester.addSetProperties(bugXPath);\n            digester.addCallMethod(bugXPath, \"setMessage\", 0);\n            digester.addSetNext(bugXPath, \"addViolation\", Violation.class.getName());\n// fix_end\n// fix_start\n            Pmd module = (Pmd)digester.parse(file);\n            if (module == null) {\n                throw new SAXException(\"Input stream is not a PMD file.\");\n            }\n// fix_end\n// fix_start\n            return convert(module, moduleName);\n        }\n        catch (IOException exception) {\n            throw new InvocationTargetException(exception);\n        }\n        catch (SAXException exception) {\n            throw new InvocationTargetException(exception);\n        }\n    }\n// fix_end\n", "cwe": "CWE-502", "cwe_name": "Deserialization of Untrusted Data", "idx": 61666}
{"source": "// bug_start\nprivate void readObject(java.io.ObjectInputStream s)\n      throws java.io.IOException, ClassNotFoundException {\n    s.defaultReadObject();\n// bug_end\n \n// bug_start\n    int length = s.readInt();\n    ImmutableLongArray.Builder builder = ImmutableLongArray.builder();\n    for (int i = 0; i < length; i++) {\n      builder.add(doubleToRawLongBits(s.readDouble()));\n// bug_end\n     }\n// bug_start\n    this.longs = new AtomicLongArray(builder.build().toArray());\n  }\n// bug_end\n \n", "target": "// fix_start\n@Override\n    public Collection<FileAnnotation> parse(final InputStream file, final String moduleName) throws InvocationTargetException {\n        try {\n            SecureDigester digester = new SecureDigester(PmdParser.class);\n// fix_end\n// fix_start\n            String rootXPath = \"pmd\";\n            digester.addObjectCreate(rootXPath, Pmd.class);\n            digester.addSetProperties(rootXPath);\n\n            String fileXPath = \"pmd/file\";\n            digester.addObjectCreate(fileXPath, hudson.plugins.pmd.parser.File.class);\n            digester.addSetProperties(fileXPath);\n            digester.addSetNext(fileXPath, \"addFile\", hudson.plugins.pmd.parser.File.class.getName());\n\n            String bugXPath = \"pmd/file/violation\";\n            digester.addObjectCreate(bugXPath, Violation.class);\n            digester.addSetProperties(bugXPath);\n            digester.addCallMethod(bugXPath, \"setMessage\", 0);\n            digester.addSetNext(bugXPath, \"addViolation\", Violation.class.getName());\n\n            Pmd module = (Pmd)digester.parse(file);\n            if (module == null) {\n                throw new SAXException(\"Input stream is not a PMD file.\");\n            }\n\n            return convert(module, moduleName);\n        }\n        catch (IOException exception) {\n            throw new InvocationTargetException(exception);\n        }\n        catch (SAXException exception) {\n            throw new InvocationTargetException(exception);\n        }\n// fix_end\n// fix_start\n// fix_end\n", "cwe": "CWE-611", "cwe_name": "Improper Restriction of XML External Entity Reference ('XXE')", "idx": 70025}
{"source": "// bug_start\nprivate void readObject(java.io.ObjectInputStream s)\n      throws java.io.IOException, ClassNotFoundException {\n    s.defaultReadObject();\n\n    int length = s.readInt();\n    this.longs = new AtomicLongArray(length);\n\n    for (int i = 0; i < length; i++) {\n      set(i, s.readDouble());\n// bug_end\n     }\n// bug_start\n// bug_end\n   }\n \n", "target": "// fix_start\n@SuppressWarnings(\"unchecked\")\n  public static CompoundOrdering<Object> instantiate(SerializationStreamReader reader)\n      throws SerializationException {\n    int n = reader.readInt();\n    List<Comparator<Object>> comparators = new ArrayList<>();\n    for (int i = 0; i < n; i++) {\n      comparators.add((Comparator<Object>) reader.readObject());\n// fix_end\n// fix_start\n    return new CompoundOrdering<>(comparators);\n// fix_end\n", "cwe": "CWE-770", "cwe_name": "Allocation of Resources Without Limits or Throttling", "idx": 76107}
{"source": "// bug_start\n@SuppressWarnings(\"unchecked\")\n  public static CompoundOrdering<Object> instantiate(SerializationStreamReader reader)\n      throws SerializationException {\n    int n = reader.readInt();\n    List<Comparator<Object>> comparators = new ArrayList<>(n);\n    for (int i = 0; i < n; i++) {\n      comparators.add((Comparator<Object>) reader.readObject());\n// bug_end\n     }\n// bug_start\n    return new CompoundOrdering<>(comparators);\n  }\n// bug_end\n \n", "target": "// fix_start\npublic void handleMessage(Message message) {\n        if (isGET(message) || message.getContent(XMLStreamReader.class) != null) {\n            LOG.fine(\"StaxInInterceptor skipped.\");\n            return;\n        }\n        InputStream is = message.getContent(InputStream.class);\n        Reader reader = null;\n        if (is == null) {\n            reader = message.getContent(Reader.class);\n            if (reader == null) {\n                return;\n            }\n        }\n        String contentType = (String)message.get(Message.CONTENT_TYPE);\n\n        if (contentType != null\n            && contentType.contains(\"text/html\")\n            && MessageUtils.isRequestor(message)) {\n            StringBuilder htmlMessage = new StringBuilder(1024);\n            try {\n                if (reader == null) {\n                    reader = new InputStreamReader(is, (String)message.get(Message.ENCODING));\n                }\n                char s[] = new char[1024];\n                int i = reader.read(s);\n                while (htmlMessage.length() < 64536 && i > 0) {\n                    htmlMessage.append(s, 0, i);\n                    i = reader.read(s);\n                }\n            } catch (IOException e) {\n                throw new Fault(new org.apache.cxf.common.i18n.Message(\"INVALID_HTML_RESPONSETYPE\",\n                        LOG, \"(none)\"));\n            }\n            throw new Fault(new org.apache.cxf.common.i18n.Message(\"INVALID_HTML_RESPONSETYPE\",\n                    LOG, (htmlMessage == null || htmlMessage.length() == 0) ? \"(none)\" : htmlMessage));\n        }\n        if (contentType == null) {\n            Map<String, List<String>> m = CastUtils.cast((Map<?, ?>)message.get(Message.PROTOCOL_HEADERS));\n            if (m != null) {\n                List<String> contentLen = HttpHeaderHelper\n                    .getHeader(m, HttpHeaderHelper.CONTENT_LENGTH);\n                List<String> contentTE = HttpHeaderHelper\n                    .getHeader(m, HttpHeaderHelper.CONTENT_TRANSFER_ENCODING);\n                if ((StringUtils.isEmpty(contentLen) || \"0\".equals(contentLen.get(0)))\n                    && StringUtils.isEmpty(contentTE)) {\n                    return;\n                }\n            }\n        }\n\n        String encoding = (String)message.get(Message.ENCODING);\n\n        XMLStreamReader xreader;\n        try {\n            XMLInputFactory factory = getXMLInputFactory(message);\n            if (factory == null) {\n                if (reader != null) {\n                    xreader = StaxUtils.createXMLStreamReader(reader);\n                } else {\n                    xreader = StaxUtils.createXMLStreamReader(is, encoding);\n                }\n            } else {\n                synchronized (factory) {\n                    if (reader != null) {\n                        xreader = factory.createXMLStreamReader(reader);\n                    } else {\n                        xreader = factory.createXMLStreamReader(is, encoding);\n                    }\n                }\n            }\n            xreader = configureRestrictions(xreader, message);\n        } catch (XMLStreamException e) {\n            throw new Fault(new org.apache.cxf.common.i18n.Message(\"STREAM_CREATE_EXC\",\n                                                                   LOG,\n                                                                   encoding), e);\n        }\n        message.setContent(XMLStreamReader.class, xreader);\n        message.getInterceptorChain().add(StaxInEndingInterceptor.INSTANCE);\n// fix_end\n// fix_start\n// fix_end\n", "cwe": "CWE-770", "cwe_name": "Allocation of Resources Without Limits or Throttling", "idx": 76106}
{"source": "// bug_start\npublic void handleMessage(Message message) {\n        if (isGET(message) || message.getContent(XMLStreamReader.class) != null) {\n            LOG.fine(\"StaxInInterceptor skipped.\");\n            return;\n// bug_end\n         }\n// bug_start\n        InputStream is = message.getContent(InputStream.class);\n        Reader reader = null;\n        if (is == null) {\n            reader = message.getContent(Reader.class);\n            if (reader == null) {\n                return;\n            }\n        }\n        String contentType = (String)message.get(Message.CONTENT_TYPE);\n\n        if (contentType != null && contentType.contains(\"text/html\")) {\n            String htmlMessage = null;\n            try {\n                htmlMessage = IOUtils.toString(is, 500);\n            } catch (IOException e) {\n                throw new Fault(new org.apache.cxf.common.i18n.Message(\"INVALID_HTML_RESPONSETYPE\",\n                        LOG, \"(none)\"));\n            }\n            throw new Fault(new org.apache.cxf.common.i18n.Message(\"INVALID_HTML_RESPONSETYPE\",\n                    LOG, (htmlMessage == null || htmlMessage.length() == 0) ? \"(none)\" : htmlMessage));\n        }\n        if (contentType == null) {\n            Map<String, List<String>> m = CastUtils.cast((Map<?, ?>)message.get(Message.PROTOCOL_HEADERS));\n            if (m != null) {\n                List<String> contentLen = HttpHeaderHelper\n                    .getHeader(m, HttpHeaderHelper.CONTENT_LENGTH);\n                List<String> contentTE = HttpHeaderHelper\n                    .getHeader(m, HttpHeaderHelper.CONTENT_TRANSFER_ENCODING);\n                if ((StringUtils.isEmpty(contentLen) || \"0\".equals(contentLen.get(0)))\n                    && StringUtils.isEmpty(contentTE)) {\n                    return;\n                }\n            }\n        }\n\n        String encoding = (String)message.get(Message.ENCODING);\n\n        XMLStreamReader xreader;\n        try {\n            XMLInputFactory factory = getXMLInputFactory(message);\n            if (factory == null) {\n                if (reader != null) {\n                    xreader = StaxUtils.createXMLStreamReader(reader);\n                } else {\n                    xreader = StaxUtils.createXMLStreamReader(is, encoding);\n                }\n            } else {\n                synchronized (factory) {\n                    if (reader != null) {\n                        xreader = factory.createXMLStreamReader(reader);\n                    } else {\n                        xreader = factory.createXMLStreamReader(is, encoding);\n                    }\n                }\n            }\n            xreader = configureRestrictions(xreader, message);\n        } catch (XMLStreamException e) {\n            throw new Fault(new org.apache.cxf.common.i18n.Message(\"STREAM_CREATE_EXC\",\n                                                                   LOG,\n                                                                   encoding), e);\n        }\n        message.setContent(XMLStreamReader.class, xreader);\n        message.getInterceptorChain().add(StaxInEndingInterceptor.INSTANCE);\n// bug_end\n     }\n \n", "target": "// fix_start\npublic int validateUser(boolean withConfirmEmail, XWikiContext context) throws XWikiException\n    {\n        try {\n            XWikiRequest request = context.getRequest();\n            String username = convertUsername(request.getParameter(\"xwikiname\"), context);\n            if (username.indexOf('.') == -1) {\n                username = \"XWiki.\" + username;\n            }\n            XWikiDocument userDocument = getDocument(username, context);\n\n            BaseObject userObject = userDocument.getObject(\"XWiki.XWikiUsers\", 0);\n            String storedKey = userObject.getStringValue(\"validkey\");\n\n            String validationKey = request.getParameter(\"validkey\");\n            PropertyInterface validationKeyClass = getClass(\"XWiki.XWikiUsers\", context).get(\"validkey\");\n            if (validationKeyClass instanceof PasswordClass) {\n                validationKey = ((PasswordClass) validationKeyClass).getEquivalentPassword(storedKey, validationKey);\n            }\n\n            if ((!storedKey.equals(\"\") && (storedKey.equals(validationKey)))) {\n                userObject.setStringValue(\"validkey\", \"\");\n                saveDocument(userDocument, context);\n\n                XWikiUser xWikiUser = new XWikiUser(userDocument.getDocumentReference());\n                xWikiUser.setDisabled(false, context);\n                xWikiUser.setEmailChecked(true, context);\n\n                if (withConfirmEmail) {\n                    String email = userObject.getStringValue(\"email\");\n                    String password = userObject.getStringValue(\"password\");\n                    sendValidationEmail(username, password, email, request.getParameter(\"validkey\"),\n                        \"confirmation_email_content\", context);\n                }\n\n                return 0;\n            } else {\n                return -1;\n            }\n        } catch (Exception e) {\n            LOGGER.error(e.getMessage(), e);\n\n            throw new XWikiException(XWikiException.MODULE_XWIKI_APP, XWikiException.ERROR_XWIKI_APP_VALIDATE_USER,\n                \"Exception while validating user\", e, null);\n// fix_end\n// fix_start\n// fix_end\n", "cwe": "CWE-399", "cwe_name": "Resource Management Errors", "idx": 51163}
{"source": "// bug_start\npublic int validateUser(boolean withConfirmEmail, XWikiContext context) throws XWikiException\n    {\n        try {\n            XWikiRequest request = context.getRequest();\n            String username = convertUsername(request.getParameter(\"xwikiname\"), context);\n            if (username.indexOf('.') == -1) {\n                username = \"XWiki.\" + username;\n// bug_end\n             }\n// bug_start\n            XWikiDocument userDocument = getDocument(username, context);\n\n            BaseObject userObject = userDocument.getObject(\"XWiki.XWikiUsers\", 0);\n            String storedKey = userObject.getStringValue(\"validkey\");\n\n            String validationKey = request.getParameter(\"validkey\");\n            PropertyInterface validationKeyClass = getClass(\"XWiki.XWikiUsers\", context).get(\"validkey\");\n            if (validationKeyClass instanceof PasswordClass) {\n                validationKey = ((PasswordClass) validationKeyClass).getEquivalentPassword(storedKey, validationKey);\n// bug_end\n             }\n// bug_start\n\n            if ((!storedKey.equals(\"\") && (storedKey.equals(validationKey)))) {\n                XWikiUser xWikiUser = new XWikiUser(userDocument.getDocumentReference());\n                xWikiUser.setDisabled(false, context);\n                xWikiUser.setEmailChecked(true, context);\n                saveDocument(userDocument, context);\n\n                if (withConfirmEmail) {\n                    String email = userObject.getStringValue(\"email\");\n                    String password = userObject.getStringValue(\"password\");\n                    sendValidationEmail(username, password, email, request.getParameter(\"validkey\"),\n                        \"confirmation_email_content\", context);\n                }\n\n                return 0;\n            } else {\n                return -1;\n            }\n        } catch (Exception e) {\n            LOGGER.error(e.getMessage(), e);\n\n            throw new XWikiException(XWikiException.MODULE_XWIKI_APP, XWikiException.ERROR_XWIKI_APP_VALIDATE_USER,\n                \"Exception while validating user\", e, null);\n// bug_end\n         }\n// bug_start\n// bug_end\n     }\n \n", "target": "// fix_start\nprivate boolean processRemainingHeader() throws IOException {\n        int headerLength;\n        if (isMasked()) {\n            headerLength = 4;\n        } else {\n            headerLength = 0;\n        }\n        if (payloadLength == 126) {\n            headerLength += 2;\n        } else if (payloadLength == 127) {\n            headerLength += 8;\n        }\n        if (writePos - readPos < headerLength) {\n            return false;\n        }\n        if (payloadLength == 126) {\n            payloadLength = byteArrayToLong(inputBuffer, readPos, 2);\n            readPos += 2;\n        } else if (payloadLength == 127) {\n            payloadLength = byteArrayToLong(inputBuffer, readPos, 8);\n            readPos += 8;\n        }\n        if (Util.isControl(opCode)) {\n            if (payloadLength > 125) {\n                throw new WsIOException(new CloseReason(\n                        CloseCodes.PROTOCOL_ERROR,\n                        sm.getString(\"wsFrame.controlPayloadTooBig\",\n                                Long.valueOf(payloadLength))));\n// fix_end\n// fix_start\n            if (!fin) {\n                throw new WsIOException(new CloseReason(\n                        CloseCodes.PROTOCOL_ERROR,\n                        sm.getString(\"wsFrame.controlNoFin\")));\n// fix_end\n// fix_start\n// fix_end\n// fix_start\n        if (isMasked()) {\n            System.arraycopy(inputBuffer, readPos, mask, 0, 4);\n            readPos += 4;\n        }\n        state = State.DATA;\n        return true;\n// fix_end\n", "cwe": "CWE-863", "cwe_name": "Incorrect Authorization", "idx": 90597}
{"source": "// bug_start\npublic static String[] validateObject(ParaObject content) {\n\t\tif (content == null) {\n\t\t\treturn new String[]{\"Object cannot be null.\"};\n\t\t}\n\t\tLinkedList<String> list = new LinkedList<>();\n\t\ttry {\n\t\t\tfor (ConstraintViolation<ParaObject> constraintViolation : getValidator().validate(content)) {\n\t\t\t\tString prop = \"'\".concat(constraintViolation.getPropertyPath().toString()).concat(\"'\");\n\t\t\t\tlist.add(prop.concat(\" \").concat(constraintViolation.getMessage()));\n\t\t\t}\n\t\t} catch (Exception e) {\n\t\t\tlogger.error(null, e);\n\t\t}\n\t\treturn list.toArray(new String[]{});\n\t}\n// bug_end\n \n", "target": "// fix_start\nprivate boolean processRemainingHeader() throws IOException {\n        int headerLength;\n        if (isMasked()) {\n            headerLength = 4;\n        } else {\n            headerLength = 0;\n        }\n        if (payloadLength == 126) {\n            headerLength += 2;\n        } else if (payloadLength == 127) {\n            headerLength += 8;\n        }\n        if (writePos - readPos < headerLength) {\n            return false;\n        }\n        if (payloadLength == 126) {\n            payloadLength = byteArrayToLong(inputBuffer, readPos, 2);\n            readPos += 2;\n        } else if (payloadLength == 127) {\n            payloadLength = byteArrayToLong(inputBuffer, readPos, 8);\n            if (payloadLength < 0) {\n                throw new WsIOException(\n                        new CloseReason(CloseCodes.PROTOCOL_ERROR, sm.getString(\"wsFrame.payloadMsbInvalid\")));\n            }\n            readPos += 8;\n        }\n        if (Util.isControl(opCode)) {\n            if (payloadLength > 125) {\n                throw new WsIOException(new CloseReason(\n                        CloseCodes.PROTOCOL_ERROR,\n                        sm.getString(\"wsFrame.controlPayloadTooBig\",\n                                Long.valueOf(payloadLength))));\n            }\n            if (!fin) {\n                throw new WsIOException(new CloseReason(\n                        CloseCodes.PROTOCOL_ERROR,\n                        sm.getString(\"wsFrame.controlNoFin\")));\n            }\n        }\n        if (isMasked()) {\n            System.arraycopy(inputBuffer, readPos, mask, 0, 4);\n            readPos += 4;\n        }\n        state = State.DATA;\n        return true;\n    }\n// fix_end\n", "cwe": "CWE-835", "cwe_name": "Loop with Unreachable Exit Condition ('Infinite Loop')", "idx": 82568}
{"source": "// bug_start\npublic void testCall(final String path, final String expectedResponse) throws Exception {\n        TestHttpClient client = new TestHttpClient();\n        String servletPath = \"/servletContext/secured/\" + path;\n        String url = DefaultServer.getDefaultServerURL() + servletPath;\n        HttpGet get = new HttpGet(url);\n        HttpResponse result = client.execute(get);\n        assertEquals(StatusCodes.UNAUTHORIZED, result.getStatusLine().getStatusCode());\n        Header[] values = result.getHeaders(WWW_AUTHENTICATE.toString());\n        assertEquals(1, values.length);\n        String value = values[0].getValue();\n        assertTrue(value.startsWith(DIGEST.toString()));\n        Map<DigestWWWAuthenticateToken, String> parsedHeader = DigestWWWAuthenticateToken.parseHeader(value.substring(7));\n        assertEquals(REALM_NAME, parsedHeader.get(DigestWWWAuthenticateToken.REALM));\n        assertEquals(DigestAlgorithm.MD5.getToken(), parsedHeader.get(DigestWWWAuthenticateToken.ALGORITHM));\n        assertTrue(parsedHeader.containsKey(DigestWWWAuthenticateToken.MESSAGE_QOP));\n// bug_end\n \n// bug_start\n        String nonce = parsedHeader.get(DigestWWWAuthenticateToken.NONCE);\n\n        String clientResponse = createResponse(\"user1\", REALM_NAME, \"password1\", \"GET\", servletPath, nonce);\n\n        client = new TestHttpClient();\n        get = new HttpGet(url);\n        StringBuilder sb = new StringBuilder(DIGEST.toString());\n        sb.append(\" \");\n        sb.append(DigestAuthorizationToken.USERNAME.getName()).append(\"=\").append(\"\\\"user1\\\"\").append(\",\");\n        sb.append(DigestAuthorizationToken.REALM.getName()).append(\"=\\\"\").append(REALM_NAME).append(\"\\\",\");\n        sb.append(DigestAuthorizationToken.NONCE.getName()).append(\"=\\\"\").append(nonce).append(\"\\\",\");\n        sb.append(DigestAuthorizationToken.DIGEST_URI.getName()).append(\"=\\\"\" + servletPath + \"\\\",\");\n        sb.append(DigestAuthorizationToken.RESPONSE.getName()).append(\"=\\\"\").append(clientResponse).append(\"\\\"\");\n\n        get.addHeader(AUTHORIZATION.toString(), sb.toString());\n        result = client.execute(get);\n        assertEquals(StatusCodes.OK, result.getStatusLine().getStatusCode());\n\n        final String response = HttpClientUtils.readResponse(result);\n        assertEquals(expectedResponse, response);\n    }\n\n// bug_end\n", "target": "// fix_start\npublic static String[] validateObject(ParaObject content) {\n\t\tif (content == null) {\n\t\t\treturn new String[]{\"Object cannot be null.\"};\n\t\t}\n\t\tLinkedList<String> list = new LinkedList<>();\n\t\ttry {\n\t\t\tfor (ConstraintViolation<ParaObject> constraintViolation : getValidator().validate(content)) {\n\t\t\t\tString prop = \"'\".concat(constraintViolation.getPropertyPath().toString()).concat(\"'\");\n\t\t\t\tlist.add(prop.concat(\" \").concat(constraintViolation.getMessage()));\n\t\t\t}\n\t\t\tif (content instanceof User && StringUtils.length(((User) content).getPassword()) > User.MAX_PASSWORD_LENGTH) {\n\t\t\t\tlist.add(Utils.formatMessage(\"{0} must not be longer than {1}.\", Config._PASSWORD, User.MAX_PASSWORD_LENGTH));\n\t\t\t}\n\t\t} catch (Exception e) {\n\t\t\tlogger.error(null, e);\n\t\t}\n\t\treturn list.toArray(new String[]{});\n\t}\n// fix_end\n", "cwe": "NVD-CWE-noinfo", "cwe_name": "", "idx": 102374}
{"source": "// bug_start\npublic void testCall(final String path, final String expectedResponse) throws Exception {\n        TestHttpClient client = new TestHttpClient();\n        String url = DefaultServer.getDefaultServerURL() + \"/servletContext/secured/\" + path;\n        HttpGet get = new HttpGet(url);\n        HttpResponse result = client.execute(get);\n        assertEquals(StatusCodes.UNAUTHORIZED, result.getStatusLine().getStatusCode());\n        Header[] values = result.getHeaders(WWW_AUTHENTICATE.toString());\n        assertEquals(1, values.length);\n        String value = values[0].getValue();\n        assertTrue(value.startsWith(DIGEST.toString()));\n        Map<DigestWWWAuthenticateToken, String> parsedHeader = DigestWWWAuthenticateToken.parseHeader(value.substring(7));\n        assertEquals(REALM_NAME, parsedHeader.get(DigestWWWAuthenticateToken.REALM));\n        assertEquals(DigestAlgorithm.MD5.getToken(), parsedHeader.get(DigestWWWAuthenticateToken.ALGORITHM));\n        assertTrue(parsedHeader.containsKey(DigestWWWAuthenticateToken.MESSAGE_QOP));\n// bug_end\n \n// bug_start\n        String nonce = parsedHeader.get(DigestWWWAuthenticateToken.NONCE);\n// bug_end\n \n// bug_start\n        String clientResponse = createResponse(\"user1\", REALM_NAME, \"password1\", \"GET\", \"/\", nonce);\n// bug_end\n \n// bug_start\n        client = new TestHttpClient();\n        get = new HttpGet(url);\n        StringBuilder sb = new StringBuilder(DIGEST.toString());\n        sb.append(\" \");\n        sb.append(DigestAuthorizationToken.USERNAME.getName()).append(\"=\").append(\"\\\"user1\\\"\").append(\",\");\n        sb.append(DigestAuthorizationToken.REALM.getName()).append(\"=\\\"\").append(REALM_NAME).append(\"\\\",\");\n        sb.append(DigestAuthorizationToken.NONCE.getName()).append(\"=\\\"\").append(nonce).append(\"\\\",\");\n        sb.append(DigestAuthorizationToken.DIGEST_URI.getName()).append(\"=\\\"/\\\",\");\n        sb.append(DigestAuthorizationToken.RESPONSE.getName()).append(\"=\\\"\").append(clientResponse).append(\"\\\"\");\n// bug_end\n \n// bug_start\n        get.addHeader(AUTHORIZATION.toString(), sb.toString());\n        result = client.execute(get);\n        assertEquals(StatusCodes.OK, result.getStatusLine().getStatusCode());\n// bug_end\n \n// bug_start\n        final String response = HttpClientUtils.readResponse(result);\n        assertEquals(expectedResponse, response);\n// bug_end\n     }\n \n", "target": "// fix_start\npublic void handleMessage(Message message) throws Fault {\n        String method = (String)message.get(Message.HTTP_REQUEST_METHOD);\n        if (\"GET\".equals(method)) {\n            return;\n        }\n// fix_end\n// fix_start\n        Message outMs = message.getExchange().getOutMessage();\n        Message inMsg = outMs == null ? message : outMs.getExchange().getInMessage();\n// fix_end\n// fix_start\n        XMLStreamReader originalXmlStreamReader = inMsg.getContent(XMLStreamReader.class);\n        if (originalXmlStreamReader == null) {\n            InputStream is = inMsg.getContent(InputStream.class);\n            if (is != null) {\n                originalXmlStreamReader = StaxUtils.createXMLStreamReader(is);\n            }\n        }\n// fix_end\n// fix_start\n        registerStaxActionInInterceptor(inMsg);\n// fix_end\n// fix_start\n        try {\n            XMLSecurityProperties properties = new XMLSecurityProperties();\n            configureDecryptionKeys(inMsg, properties);\n            Crypto signatureCrypto = getSignatureCrypto(inMsg);\n            configureSignatureKeys(signatureCrypto, inMsg, properties);\n// fix_end\n// fix_start\n            SecurityEventListener securityEventListener =\n                configureSecurityEventListener(signatureCrypto, inMsg, properties);\n            InboundXMLSec inboundXMLSec = XMLSec.getInboundWSSec(properties);\n\n            XMLStreamReader newXmlStreamReader =\n                inboundXMLSec.processInMessage(originalXmlStreamReader, null, securityEventListener);\n            inMsg.setContent(XMLStreamReader.class, newXmlStreamReader);\n\n        } catch (XMLStreamException e) {\n            throwFault(e.getMessage(), e);\n        } catch (XMLSecurityException e) {\n            throwFault(e.getMessage(), e);\n        } catch (IOException e) {\n            throwFault(e.getMessage(), e);\n        } catch (UnsupportedCallbackException e) {\n            throwFault(e.getMessage(), e);\n        }\n// fix_end\n", "cwe": "CWE-863", "cwe_name": "Incorrect Authorization", "idx": 89514}
{"source": "// bug_start\nprivate void addJsr160DispatcherIfExternallyConfigured(Configuration pConfig) {\n        for (String param : new String[] {\n            System.getProperty(\"org.jolokia.jsr160ProxyEnabled\"),\n            System.getenv(\"JOLOKIA_JSR160_PROXY_ENABLED\")\n        }) {\n            if (param !=null && (param.isEmpty() || Boolean.parseBoolean(param))){\n                String dispatchers = pConfig.get(ConfigKey.DISPATCHER_CLASSES);\n\n                pConfig.updateGlobalConfiguration(\n                    Collections.singletonMap(\n                        ConfigKey.DISPATCHER_CLASSES.getKeyValue(),\n                        (dispatchers != null ? dispatchers + \",\" : \"\") + \"org.jolokia.jsr160.Jsr160RequestDispatcher\"));\n                return;\n            }\n// bug_end\n         }\n// bug_start\n// bug_end\n     }\n \n", "target": "// fix_start\npublic void handleMessage(Message message) throws Fault {\n        if (isServerGet(message)) {\n            return;\n// fix_end\n// fix_start\n        prepareMessage(message);\n        message.getInterceptorChain().add(\n              new StaxActionInInterceptor(requireSignature, requireEncryption));\n// fix_end\n", "cwe": "CWE-295", "cwe_name": "Improper Certificate Validation", "idx": 40420}
{"source": "// bug_start\n@Override\n    public void log(org.apache.coyote.Request req,\n            org.apache.coyote.Response res, long time) {\n// bug_end\n \n// bug_start\n        Request request = (Request) req.getNote(ADAPTER_NOTES);\n        Response response = (Response) res.getNote(ADAPTER_NOTES);\n        boolean create = false;\n\n        if (request == null) {\n            create = true;\n            request = connector.createRequest();\n            request.setCoyoteRequest(req);\n            response = connector.createResponse();\n            response.setCoyoteResponse(res);\n\n            request.setResponse(response);\n            response.setRequest(request);\n\n            req.setNote(ADAPTER_NOTES, request);\n            res.setNote(ADAPTER_NOTES, response);\n\n            req.getParameters().setQueryStringEncoding\n                (connector.getURIEncoding());\n        }\n\n        try {\n            connector.getService().getContainer().logAccess(\n                    request, response, time, true);\n        } catch (Throwable t) {\n            ExceptionUtils.handleThrowable(t);\n            log.warn(sm.getString(\"coyoteAdapter.accesslogFail\"), t);\n        }\n\n        if (create) {\n            request.recycle();\n            response.recycle();\n// bug_end\n         }\n     }\n \n", "target": "// fix_start\nprivate void addJsr160DispatcherIfExternallyConfigured(Configuration pConfig) {\n        String dispatchers = pConfig.get(ConfigKey.DISPATCHER_CLASSES);\n        String jsr160DispatcherClass = \"org.jolokia.jsr160.Jsr160RequestDispatcher\";\n// fix_end\n// fix_start\n        if (dispatchers == null || !dispatchers.contains(jsr160DispatcherClass)) {\n            for (String param : new String[]{\n                System.getProperty(\"org.jolokia.jsr160ProxyEnabled\"),\n                System.getenv(\"JOLOKIA_JSR160_PROXY_ENABLED\")\n            }) {\n                if (param != null && (param.isEmpty() || Boolean.parseBoolean(param))) {\n                    {\n                        pConfig.updateGlobalConfiguration(\n                            Collections.singletonMap(\n                                ConfigKey.DISPATCHER_CLASSES.getKeyValue(),\n                                (dispatchers != null ? dispatchers + \",\" : \"\") + jsr160DispatcherClass));\n                    }\n                    return;\n                }\n            }\n            if (dispatchers == null) {\n                pConfig.updateGlobalConfiguration(Collections.singletonMap(\n                    ConfigKey.DISPATCHER_CLASSES.getKeyValue(),\n                    Jsr160ProxyNotEnabledByDefaultAnymoreDispatcher.class.getCanonicalName()));\n            }\n// fix_end\n", "cwe": "CWE-74", "cwe_name": "Improper Neutralization of Special Elements in Output Used by a Downstream Component ('Injection')", "idx": 72915}
{"source": "// bug_start\n@Override\n    public void log(org.apache.coyote.Request req,\n            org.apache.coyote.Response res, long time) {\n// bug_end\n \n// bug_start\n        Request request = (Request) req.getNote(ADAPTER_NOTES);\n        Response response = (Response) res.getNote(ADAPTER_NOTES);\n        boolean create = false;\n\n        if (request == null) {\n            create = true;\n            request = connector.createRequest();\n            request.setCoyoteRequest(req);\n            response = connector.createResponse();\n            response.setCoyoteResponse(res);\n\n            request.setResponse(response);\n            response.setRequest(request);\n\n            req.setNote(ADAPTER_NOTES, request);\n            res.setNote(ADAPTER_NOTES, response);\n\n            req.getParameters().setQueryStringEncoding\n                (connector.getURIEncoding());\n        }\n\n        connector.getService().getContainer().logAccess(\n                request, response, time, true);\n\n        if (create) {\n            request.recycle();\n            response.recycle();\n        }\n// bug_end\n     }\n \n", "target": "// fix_start\nprivate static FormValidation _error(Kind kind, Throwable e, String message) {\n        if (e==null)    return _errorWithMarkup(Util.escape(message),kind);\n// fix_end\n// fix_start\n        return _errorWithMarkup(Util.escape(message)+\n            \" <a href='#' class='showDetails'>\"\n            + Messages.FormValidation_Error_Details()\n            + \"</a><pre style='display:none'>\"\n            + Util.escape(Functions.printThrowable(e)) +\n            \"</pre>\",kind\n        );\n// fix_end\n", "cwe": "CWE-20", "cwe_name": "Improper Input Validation", "idx": 9056}
{"source": "// bug_start\nprivate static FormValidation _error(Kind kind, Throwable e, String message) {\n        if (e==null)    return _errorWithMarkup(Util.escape(message),kind);\n// bug_end\n \n// bug_start\n        return _errorWithMarkup(Util.escape(message)+\n            \" <a href='#' class='showDetails'>\"\n            + Messages.FormValidation_Error_Details()\n            + \"</a><pre style='display:none'>\"\n            + Functions.printThrowable(e) +\n            \"</pre>\",kind\n        );\n// bug_end\n     }\n \n", "target": "// fix_start\nprotected void doSend(HttpServletResponse response)\n            throws IOException {\n// fix_end\n// fix_start\n        response.setContentType(\"text/html\");\n        response.setCharacterEncoding(\"UTF-8\");\n\n        changes.insert(0, \"<pre>\");\n        changes.append(\"</pre>\");\n        setProperty(PN_CHANGE_LOG, changes.toString());\n\n        Writer out = response.getWriter();\n        InputStream template = getClass().getResourceAsStream(TEMPLATE_NAME);\n        Reader in = new BufferedReader(new InputStreamReader(template));\n        StringBuffer varBuffer = new StringBuffer();\n        int state = 0;\n        int read;\n        while ((read = in.read()) >= 0) {\n            char c = (char) read;\n            switch (state) {\n                case 0:\n                    if (c == '$') {\n                        state = 1;\n                    } else {\n                        out.write(c);\n                    }\n                    break;\n                case 1:\n                    if (c == '{') {\n                        state = 2;\n                    } else {\n                        state = 0;\n                        out.write('$');\n                        out.write(c);\n                    }\n                    break;\n                case 2:\n                    if (c == '}') {\n                        state = 0;\n                        Object prop = getProperty(varBuffer.toString());\n                        if (prop != null) {\n                            out.write(ResponseUtil.escapeXml(prop.toString()));\n                        }\n                        varBuffer.setLength(0);\n                    } else {\n                        varBuffer.append(c);\n                    }\n            }\n        }\n        in.close();\n        out.flush();\n// fix_end\n", "cwe": "CWE-79", "cwe_name": "Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')", "idx": 79053}
{"source": "// bug_start\nprotected void doSend(HttpServletResponse response)\n            throws IOException {\n// bug_end\n \n// bug_start\n        response.setContentType(\"text/html\");\n        response.setCharacterEncoding(\"UTF-8\");\n// bug_end\n \n// bug_start\n        changes.insert(0, \"<pre>\");\n        changes.append(\"</pre>\");\n        setProperty(PN_CHANGE_LOG, changes.toString());\n\n        Writer out = response.getWriter();\n        InputStream template = getClass().getResourceAsStream(TEMPLATE_NAME);\n        Reader in = new BufferedReader(new InputStreamReader(template));\n        StringBuffer varBuffer = new StringBuffer();\n        int state = 0;\n        int read;\n        while ((read = in.read()) >= 0) {\n            char c = (char) read;\n            switch (state) {\n                case 0:\n                    if (c == '$') {\n                        state = 1;\n                    } else {\n                        out.write(c);\n                    }\n                    break;\n                case 1:\n                    if (c == '{') {\n                        state = 2;\n                    } else {\n                        state = 0;\n                        out.write('$');\n                        out.write(c);\n                    }\n                    break;\n                case 2:\n                    if (c == '}') {\n                        state = 0;\n                        Object prop = getProperty(varBuffer.toString());\n                        if (prop != null) {\n                            out.write(htmlEscape(prop.toString()));\n                        }\n                        varBuffer.setLength(0);\n                    } else {\n                        varBuffer.append(c);\n                    }\n            }\n        }\n        in.close();\n        out.flush();\n    }\n\n// bug_end\n", "target": "// fix_start\npublic boolean processSendfile(SelectionKey sk, KeyAttachment attachment, boolean reg, boolean event) {\n            NioChannel sc = null;\n            try {\n                SendfileData sd = attachment.getSendfileData();\n                if ( sd.fchannel == null ) {\n                    File f = new File(sd.fileName);\n                    if ( !f.exists() ) {\n                        cancelledKey(sk,SocketStatus.ERROR,false);\n                        return false;\n                    }\n                    sd.fchannel = new FileInputStream(f).getChannel();\n                }\n                sc = attachment.getChannel();\n                sc.setSendFile(true);\n                WritableByteChannel wc = ((sc instanceof SecureNioChannel)?sc:sc.getIOChannel());\n// fix_end\n// fix_start\n                if (sc.getOutboundRemaining()>0) {\n                    if (sc.flushOutbound()) {\n                        attachment.access();\n                    }\n                } else {\n                    long written = sd.fchannel.transferTo(sd.pos,sd.length,wc);\n                    if ( written > 0 ) {\n                        sd.pos += written;\n                        sd.length -= written;\n                        attachment.access();\n                    } else {\n                        if (sd.fchannel.size() <= sd.pos) {\n                            throw new IOException(\"Sendfile configured to \" +\n                                    \"send more data than was available\");\n                        }\n                    }\n                }\n                if ( sd.length <= 0 && sc.getOutboundRemaining()<=0) {\n                    if (log.isDebugEnabled()) {\n                        log.debug(\"Send file complete for:\"+sd.fileName);\n                    }\n                    attachment.setSendfileData(null);\n                    try {sd.fchannel.close();}catch(Exception ignore){}\n                    if ( sd.keepAlive ) {\n                        if (reg) {\n                            if (log.isDebugEnabled()) {\n                                log.debug(\"Connection is keep alive, registering back for OP_READ\");\n                            }\n                            if (event) {\n                                this.add(attachment.getChannel(),SelectionKey.OP_READ);\n                            } else {\n                                reg(sk,attachment,SelectionKey.OP_READ);\n                            }\n                        }\n                    } else {\n                        if (log.isDebugEnabled()) {\n                            log.debug(\"Send file connection is being closed\");\n                        }\n                        cancelledKey(sk,SocketStatus.STOP,false);\n                    }\n                } else if ( attachment.interestOps() == 0 && reg ) {\n                    if (log.isDebugEnabled()) {\n                        log.debug(\"OP_WRITE for sendilfe:\"+sd.fileName);\n                    }\n                    if (event) {\n                        add(attachment.getChannel(),SelectionKey.OP_WRITE);\n                    } else {\n                        reg(sk,attachment,SelectionKey.OP_WRITE);\n                    }\n                }\n            }catch ( IOException x ) {\n                if ( log.isDebugEnabled() ) log.debug(\"Unable to complete sendfile request:\", x);\n                cancelledKey(sk,SocketStatus.ERROR,false);\n                return false;\n            }catch ( Throwable t ) {\n                log.error(\"\",t);\n                cancelledKey(sk, SocketStatus.ERROR, false);\n                return false;\n            }finally {\n                if (sc!=null) sc.setSendFile(false);\n            }\n            return true;\n        }\n// fix_end\n", "cwe": "CWE-79", "cwe_name": "Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')", "idx": 81317}
{"source": "// bug_start\npublic boolean processSendfile(SelectionKey sk, KeyAttachment attachment, boolean reg, boolean event) {\n            NioChannel sc = null;\n            try {\n                SendfileData sd = attachment.getSendfileData();\n                if ( sd.fchannel == null ) {\n                    File f = new File(sd.fileName);\n                    if ( !f.exists() ) {\n                        cancelledKey(sk,SocketStatus.ERROR,false);\n                        return false;\n                    }\n                    sd.fchannel = new FileInputStream(f).getChannel();\n                }\n                sc = attachment.getChannel();\n                sc.setSendFile(true);\n                WritableByteChannel wc = ((sc instanceof SecureNioChannel)?sc:sc.getIOChannel());\n// bug_end\n \n// bug_start\n                if (sc.getOutboundRemaining()>0) {\n                    if (sc.flushOutbound()) {\n                        attachment.access();\n                    }\n                } else {\n                    long written = sd.fchannel.transferTo(sd.pos,sd.length,wc);\n                    if ( written > 0 ) {\n                        sd.pos += written;\n                        sd.length -= written;\n                        attachment.access();\n                    }\n                }\n                if ( sd.length <= 0 && sc.getOutboundRemaining()<=0) {\n                    if (log.isDebugEnabled()) {\n                        log.debug(\"Send file complete for:\"+sd.fileName);\n                    }\n                    attachment.setSendfileData(null);\n                    try {sd.fchannel.close();}catch(Exception ignore){}\n                    if ( sd.keepAlive ) {\n                        if (reg) {\n                            if (log.isDebugEnabled()) {\n                                log.debug(\"Connection is keep alive, registering back for OP_READ\");\n                            }\n                            if (event) {\n                                this.add(attachment.getChannel(),SelectionKey.OP_READ);\n                            } else {\n                                reg(sk,attachment,SelectionKey.OP_READ);\n                            }\n                        }\n                    } else {\n                        if (log.isDebugEnabled()) {\n                            log.debug(\"Send file connection is being closed\");\n                        }\n                        cancelledKey(sk,SocketStatus.STOP,false);\n                    }\n                } else if ( attachment.interestOps() == 0 && reg ) {\n                    if (log.isDebugEnabled()) {\n                        log.debug(\"OP_WRITE for sendilfe:\"+sd.fileName);\n                    }\n                    if (event) {\n                        add(attachment.getChannel(),SelectionKey.OP_WRITE);\n                    } else {\n                        reg(sk,attachment,SelectionKey.OP_WRITE);\n                    }\n                }\n            }catch ( IOException x ) {\n                if ( log.isDebugEnabled() ) log.debug(\"Unable to complete sendfile request:\", x);\n                cancelledKey(sk,SocketStatus.ERROR,false);\n                return false;\n            }catch ( Throwable t ) {\n                log.error(\"\",t);\n                cancelledKey(sk, SocketStatus.ERROR, false);\n                return false;\n            }finally {\n                if (sc!=null) sc.setSendFile(false);\n// bug_end\n             }\n// bug_start\n            return true;\n// bug_end\n         }\n// bug_start\n// bug_end\n \n", "target": "// fix_start\nprivate void enumerateChmDirectoryListingList(ChmItsfHeader chmItsHeader,\n            ChmItspHeader chmItspHeader) throws TikaException {\n        try {\n            int startPmgl = chmItspHeader.getIndex_head();\n            int stopPmgl = chmItspHeader.getUnknown_0024();\n            int dir_offset = (int) (chmItsHeader.getDirOffset() + chmItspHeader\n                    .getHeader_len());\n            setDataOffset(chmItsHeader.getDataOffset());\n// fix_end\n// fix_start\n            byte[] dir_chunk = null;\n            for (int i = startPmgl; i>=0; ) {\n                dir_chunk = new byte[(int) chmItspHeader.getBlock_len()];\n                int start = i * (int) chmItspHeader.getBlock_len() + dir_offset;\n                dir_chunk = ChmCommons\n                        .copyOfRange(getData(), start,\n                                start +(int) chmItspHeader.getBlock_len());\n\n                PMGLheader = new ChmPmglHeader();\n                PMGLheader.parse(dir_chunk, PMGLheader);\n                enumerateOneSegment(dir_chunk);\n\n                i=PMGLheader.getBlockNext();\n                dir_chunk = null;\n// fix_end\n// fix_start\n        } catch (ChmParsingException e) {\n            LOG.warn(\"Chm parse exception\", e);\n        } finally {\n            setData(null);\n// fix_end\n// fix_start\n    }\n// fix_end\n", "cwe": "CWE-20", "cwe_name": "Improper Input Validation", "idx": 9130}
{"source": " public void render(Map<String, ?> model, HttpServletRequest request, HttpServletResponse response)\n \t\t\tthrows Exception {\n \t\tMap<String, Object> map = new HashMap<String, Object>(model);\n \t\tString path = ServletUriComponentsBuilder.fromContextPath(request).build()\n \t\t\t\t.getPath();\n \t\tmap.put(\"path\", (Object) path==null ? \"\" : path);\n \t\tcontext.setRootObject(map);\n// bug_start\n\t\tString result = helper.replacePlaceholders(template, resolver);\n// bug_end\n \t\tresponse.setContentType(getContentType());\n \t\tresponse.getWriter().append(result);\n \t}\n \n", "target": "// fix_start\n\t\tString maskedTemplate = template.replace(\"${\", prefix);\n\t\tPropertyPlaceholderHelper helper = new PropertyPlaceholderHelper(prefix, \"}\");\n\t\tString result = helper.replacePlaceholders(maskedTemplate, resolver);\n\t\tresult = result.replace(prefix, \"${\");\n// fix_end\n", "cwe": "CWE-19", "cwe_name": "Data Handling", "idx": 4919}
